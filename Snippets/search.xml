<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Calculated_Columns</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_DAX_Calculated_Columns</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Calculated_Columns</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_DAX_Calculated_Columns</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_DAX_Calculated_Columns

'when you look at Measures in the DATA view you don't see it's column or individual values, rather you have to put it into a Table Visual to see it's value
'when you look at a Calculated Column in the DATA view you see a column, and values in every row.

the ICON of a calculated column is a little SIGMA inside a square

'Calculated Columns: "Expands" a table by adding columns defined ba a defined ???
'					They can only look in the row that they are in.
'			b/c Calculated columns are actual values that are stored in the dataset, then can be used in Slicers/Filters
'			AND when a DAX calculation takes a long time, it might be advantagous to put them into a Calculated column that can be created ahead of time (e.g. SSRS scheduler)

'vs.
'Measures : "Summarizes" all the data into a single value
'			works with whold columns of data and condense them into a single value
'			Computed at run time, stored temporarily
'			Limited by a Filter Context, which are ALL the filters applied by the user

			
----------------------------------------------------------------------------------
'SO if you created two columns in a Visual (e.g. Table) and one was based on a Calculated Column using data from a Related table, 
'	and the other was based on a Measure using data from a Related table, then the Calculated-based Rank would remain unchanged as you
'	apply filters to the related Table, but the Measure-based Rank would change as you applied filters to the related Table.

'e.g. for a Calculated Column
Ranking =        RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))

'e.g. for a MEASURE Column
RankingMeasure = RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))		
---------------------------------------------------------------------------------
			
'Column calculations are computed at time of refresh, and then stored with the table

'They are limited to the row context: They can only look in the row that they are in.

---SIMPLE
'.e.g. 
Gross Sales = [Price] * [Quantity] * (1-[Discount])

---RELATED TABLE
'e.g. calculated value based on column in another table related by [ProductID]
'			uses color from a related table
Color = RELATED(Products[Color]) 'used to pull to a many table from a one table in a 'Many-to-one' relationship

---INTERATOR 'Takes 2 parameters: related table name, and an expression
'e.g. want Total Sales by product between 2 related tables, related by [ProductID] 
'		want the calculation done in the ONE end of the 1-to-Many relationship
SUMX : sums values from a related table  - This is the interator function
RELATEDTABLE: the related table for SUMX
TotalSales = SUMX(RELATEDTABLE(SalesOrderDetail),SalesOrderDetail[LineTotal])</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Evaluation_Contexts</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_DAX_Evaluation_Contexts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Evaluation_Contexts</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_DAX_Evaluation_Contexts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_DAX_Evaluation_Contexts

The evaluation context determines what your expression can see
you have to imagine what the expression is able to access WHEN it evaluates

Evaluation Context define what values an expression can see when it is evaluating

- no context: all rows and columns are available

- Filter Context: All the implicit filters that are applied
		=&gt;	Is a combination of Visual and User Filters
		=&gt;	Can be changed w/ CALCULATE
		=&gt;	Propogates filters to other tables via the relationships
		
- Row Context: CALCULATED columns implicitly create a row context
				it is limited to the current row
		=&gt; Limits to the current row, when iterating 
		=&gt; used in calculated columns
		=&gt; used in Iterators, when it goes row-by-row
		=&gt; Does NOT propogate filters (e.g. working on Table_1, would not affect anything on Table_2)
		=&gt; 	in fact, Row Context requires RELATED/RELATEDTABLE to use other tables
		

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Filtering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ALL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Filtering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ALL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ALL:	'Removes Filters
'Use with CALCULATE
'Returns all the rows in a table, or all the values in a column, ignoring any filters that might have been applied. 
'This function is useful for clearing filters and creating calculations on all the rows in a table.

'Syntax:
ALL( {&lt;table&gt; | &lt;column&gt;[, &lt;column&gt;[, &lt;column&gt;[,…]]]} )  


e.g. 'This removes filters from all columns in the Products table
% of Total Sales = SUM(SalesOrderDetail[OrderQty]) / CALCULATE(SUM(SalesOrderDetail[OrderQty]), ALL(Products))

e.g. 'This removes filters from the Color Column in the Products table, but any other filter would still override it
% of Total Sales = SUM(SalesOrderDetail[OrderQty]) / CALCULATE(SUM(SalesOrderDetail[OrderQty]), ALL(Products[Color]))

'ALLEXCEPT

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Filter_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Filter_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/filter-functions-dax

' FILTER functions output a temporary table
' Filters do not propogate in a Row Context, i.e. in Calculated Columns

ADDMISSINGITEMS
ALL
	'Returns all the rows in a table, or all the values in a column, 
	'	ignoring any filters that might have been applied. 
	'	This function is useful for clearing filters 
	'	and creating calculations on all the rows in a table.
	

ALLEXCEPT
ALLNOBLANKROW
ALLSELECTED
CALCULATE	'to override filters, designed to be fast, can use multiple filter statements: Single column to fixed value
			'Evaluates an expression in a context that is modified by the specified filters.
			'It works fastest w/out filters

			'Syntax: 'CALCULATE ( Expression, Filter )
					CALCULATE(&lt;expression&gt;,&lt;filter1&gt;,&lt;filter2&gt;…)  
					'where the expression is some function (often and aggregate function) of the data
					
			'e.g.
			BlackAveragePrice = CALCULATE(AVERAGE(SalesOrderDetail[UnitPrice]), Products[Color] = "Black")
			'If this measure were added to a table, where each row is a different color, it would override the GUI
			'	filters and still show the average black price, regardless of which color was sliced.			
CALCULATETABLE
CROSSFILTER function
DISTINCT 'returns a one column table that contains the unique values in a column,
		 '  OR Multiple columnswith distinct combination of values, for a table expression argument
		 
		'e.g.  Notice: DISTINCT gets rid of the duplicates
		Colors = CONCATENATEX(DISTINCT(Products[Color]),Products[Color], ", ")

EARLIER
EARLIEST
FILTER
FILTERS
HASONEFILTER
HASONEVALUE
ISCROSSFILTERED
ISFILTERED
KEEPFILTERS

RELATED 
	'=&gt; used in Row-Context: so used in CALCULATED Columns, but not in MEASURES
	' outputs a temporary table

RELATEDTABLE
	'=&gt; used in Row-Context: so used in CALCULATED Columns, but not in MEASURES
	' outputs a temporary table of just the rows related by the JOIN
	
SELECTEDVALUE
SUBSTITUTEWITHINDEX
USERELATIONSHIP
VALUES
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Logical_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Logical_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/logical-functions-dax

'IF/SWITCH can’t return tables: 
'Another subtlety that I noted in my research is that IF and SWITCH can only return scalar values and NOT tables.


AND
FALSE
		
==================================================================================================================
IF:			IF(logical_test&gt;,&lt;value_if_true&gt;, value_if_false)  
=======================================================================================================
'Checks if a condition provided as the first argument is met. Returns one value if the condition is TRUE, 
		'	and returns another value if the condition is FALSE: 
		  
		'IF(logical_test&gt;,&lt;value_if_true&gt;, value_if_false)
		'value_if_true:		If omitted, TRUE is returned.
		'value_if_false :	If omitted, FALSE is returned.  
		---------------------------------------------------
		=
			IF (
			    [StateProvinceCode] = "CA"
			        &amp;&amp; ( [MaritalStatus] = "M"
			        || [NumberChildrenAtHome] &gt; 1 ),
			    [City]
			)
		---------------------------------------------------
            IF (
                AND (
	                    CurrentSales &lt;&gt; 0,
	                    PreviousSales &lt;&gt; 0
		             ),
	                CurrentSales - PreviousSales
            	)
        ---------------------------------------------------    			
		Homeowner = if([HomeOwnerFlag] = 0, "Not Homeowner", "Homeowner")
		
		=IF([Calls]&lt;200,"low",IF([Calls]&lt;300,"medium","high"))  
		
		'the condition in the IF function checks for the value of the columns [MaritalStatus] AND [NumberChildrenAtHome], 
		'	and outputs the city if either condition is met AND if the customer is in California. 
		'	Otherwise, it outputs the empty string.

	=IF([StateProvinceCode]= "CA" &amp;&amp; ([MaritalStatus] = "M" || [NumberChildrenAtHome] &gt;1),[City])  	

	----------------------------------------------------------------------------------------------	
	DING, DING, DING or ...
	
	Mouse = IF(FIND("Mouse",'Product'[ProductName],1,0) &gt; 0, "DING, DING, DING", "....")    
=======================================================================================================				
IFERROR	'Evaluates an expression and returns a specified value if the expression returns an error; otherwise returns the value of the expression itself.

		=IFERROR(25/0,9999)

=======================================================================================================		
NOT
OR
=======================================================================================================
SWITCH				SWITCH(&lt;expression&gt;, &lt;value&gt;, &lt;result&gt;[, &lt;value&gt;, &lt;result&gt;]…[, &lt;else&gt;])  
=======================================================================================================
	'Evaluates an expression against a list of values and returns one of multiple possible result expressions.
		'SWITCH checks for exact matches i.e. equals, but not less than or greater than
		---------------------------------------------for "="
			=
			SWITCH (
			    [Month],
			    1, "January",
			    2, "February",
			    3, "March",
			    4, "April",
			    5, "May",
			    6, "June",
			    7, "July",
			    8, "August",
			    9, "September",
			    10, "October",
			    11, "November",
			    12, "December",
			    "Unknown month number"
			)
		-----------------------------------------------	for &lt; or &gt;
		'https://powerpivotpro.com/2015/03/the-diabolical-genius-of-switch-true/
		'SWITCH() is still testing for equivalence!  
		'	By providing the first argument as TRUE(), now each subsequent “test” is going to be checking for TRUE().
		'And since each of our inequality tests results in either TRUE() or FALSE() as a value, 
		'	the test case that evaluate to TRUE() is the one that gets matched, 
		'	and therefore the one that gets used.  For instance, if [Measure]&lt;1 evaluates to TRUE(), then expr1 gets returned.
		'you STILL have to sequence your “overlapping” test cases carefully
		
		SWITCH(
          TRUE(),
          [MyMeasure]&lt;1,expr1,
          [MyMeasure]&lt;2,expr2,
          [MyMeasure]&lt;3,expr3,
         …)
=======================================================================================================
TRUE
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Math_and_Trig_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Math_and_Trig_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/math-and-trig-functions-dax

ABS
ACOS
ACOSH
ASIN
ASINH
ATAN
ATANH
CEILING
COMBIN
COMBINA
COS
COSH
CURRENCY
DEGREES
DIVIDE
	'Safe Divide, with ability to handle divide by zero
	'e.g. a MEASURE  NOTE: third parameter is optional, if missing then when a divide by zero occurs it just puts a blank
	'NOTE I am using an Aggregate(TABLE[ColumnName]) for the 1st and 2nd Parameter
	'syntax
	DIVIDE(&lt;numerator&gt;, &lt;denominator&gt; [,&lt;alternateresult&gt;])  
	'a MEASURE: 
	Gross Profit pcntMeasure = DIVIDE(SUM(Sales[Gross Profit]),SUM(Sales[SalesAmount])) 	
	'a Calc Column with every cell the same b/c of aggregate
	Gross Profit pcntCalc_1 = DIVIDE(SUM(Sales[Gross Profit]),SUM(Sales[SalesAmount])) 
	'a Calc Column with every cell the dependent on the values in the row, b/c it does not use an aggregate	
	Gross Profit pcntCalc_2 = DIVIDE( Sales[Gross Profit],Sales[SalesAmount] )
	
EVEN
EXP
FACT
FLOOR
GCD
INT
INT
ISO.CEILING
LCMLCM
LN
LOG
LOG10
MOD
	MOD(&lt;number&gt;, &lt;divisor&gt;)  
	'The following formula returns 1, the remainder of 3 divided by 2.
	= MOD(3,2)  
MROUND
ODD
PI
POWER
PRODUCT
PRODUCTX
QUOTIENT
RADIANS
RAND
RANDBETWEEN
ROUND
ROUNDDOWN
ROUNDUP
SIGN
SQRT
SUM
SUMX	'Returns the sum of an expression evaluated for each row in a table:   SUMX(&lt;table&gt;, &lt;expression&gt;)
		'Only the numbers in the column are counted. Blanks, logical values, and text are ignored.  
		'SYNTAX
			SUMX(&lt;table&gt;, &lt;expression&gt;) 
			'The second argument is a column that contains the numbers you want to sum, or an expression that evaluates to a column. 
			'where:  expression=The expression to be evaluated for each row of the table.
		
		    SUMX (
		        VALUES ( 'Date'[Calendar Year Month Number] ),
		        IF (
		            AND (
		                [Sales Amount] &lt;&gt; 0,
		                [Sales LY] &lt;&gt; 0
		            ),
		            [Sales Amount] - [Sales LY]
		        )
		'EXAMPLE
			'The following example 
			'	first filters the table, [InternetSales], on the expression, { ShippingTerritoryID = 5 } 
			'	and then returns the sum of all values in the column, Freight. 
			'In other words, the expression returns the sum of freight charges for only the specified sales area.
			= SUMX(FILTER(InternetSales, InternetSales[SalesTerritoryID]=5),[Freight]) 		

TRUNC
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Table_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Table_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Table_Functions

'One key limitation of a table function is that its output can’t be used in a visual in your report. 
'	If you think about it, 
'	each cell on a pivot table can only fit one number, not an entire table of numbers.

 'returns a table of data
------------------------------------------------ 
 'In DAX, a table function is used in a few ways:

'1]	As input to another DAX function where the function argument requires a table. 
'		For example, the FILTER function iterates over a table of data 
'		and tests each value for a condition 
'		(actually any X function like SUMX or AVERAGEX is an iterator and would require a table as the first argument.)
'2] As a calculated table definition in Power BI Desktop
'3] As a query written against your data model using DAX Studio or SQL Server Management Studio.
------------------------------------------------

'Tables can become scalars: 
'	A neat feature of DAX is that any table function that resolves to a single row and column (i.e., one value) is automatically converted to a scalar value if possible. That means that you can use a table function as an input to another function, 
'	but do so cautiously to avoid the dreaded “Table of Multiple Values…” error.

----------------------------------------------------------------------------------
'SO if you created two columns in a Visual (e.g. Table) and one was based on a Calculated Column using data from a Related table, 
'	and the other was based on a Measure using data from a Related table, then the Calculated-based Rank would remain unchanged as you
'	apply filters to the related Table, but the Measure-based Rank would change as you applied filters to the related Table.

'e.g. for a Calculated Column
Ranking =        RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))

'e.g. for a MEASURE Column
RankingMeasure = RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))		
---------------------------------------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Text_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Text_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/text-functions-dax

BLANK
CODE
CONCATENATE

CONCATENATEX - 'returns the concatenation of those values in a single string result, seperated by a specified delimiter
	'e.g.Notice: DISTINCT gets rid of the duplicates
	Colors = CONCATENATEX(DISTINCT(Products[Color]),Products[Color], ", ")
	'It is possible to pass Unicode characters to the CONCATENATEX function, using the UNICHAR(number) function.	
	'new line is given by UNICHAR(10).
	
Custom date and time formats for the FORMAT function
Custom Numeric Formats for the FORMAT function
EXACT
FIND
	'e.g.: Caps sensitive, find 'Mouse" in column  'Product'[ProductName], 1= yes report back the position if found, if not found then put a zero(0)
	Mouse = FIND("Mouse",'Product'[ProductName],1,0)

FIXED
FORMAT
LEFT
LEN
LOWER
MID
Pre-defined date and time formats for the FORMAT function
Pre-Defined Numeric Formats for the FORMAT function
REPLACE
REPT
RIGHT
SEARCH
SUBSTITUTE
TRIM
UNICHAR
UPPER
VALUE
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Iterators</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_DAX_Iterators</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Iterators</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_DAX_Iterators</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_DAX_Iterators

'Iterators have the advantage over calculated columns b/c they don't use up RAM

'Iterators are Limited by a Filter Context, which are ALL the filters applied by the user

'Iterators can be implemented as MEASURES, so remember:
'When you create a 'MEASURE' in the 'Fields' panel of a Table, 
'	and you look at the table in Data View, 
'	you do NOT see a column for the measure
'HOWEVER, you can drag n drop the MEASURE from the 'Fields' panel, into the 'Values' field of a Matrix visualization (for example)
'	and it will show up as a column in the Matrix Visualization, so it can 
'	be used in a Table or Matrix Visualization



'can use for row-by-row 
SUM vs SUMX 'SUMX is an iterator
			'Many Iterators end in 'X'

'Row-by-row iterators do have worse performance than their non-interator functions

'Iterators allow for multi-column expressions (in an aggregator)

'Iterator Parameters: 2
'First Parameter:  is a Table
'Second Parameter: is an expression

'Iterator says for each row, of the Table Parameter, evaluate the Expression Parameter

FILTER ' is an Interator

'Using AVERAGEX vs AVERAGE
Average Gross Sales := AVERAGEX ( Category, [Quantity] * [Price] )
'You could put the Iterator in a Measure

'AVERAGE function, unlike AVERAGEX only excepts 1 column as an argument


'e.g. this can be used to show which colors are being filtered on, by dropping this measure into a detail card 
Colors = CONCATENATEX(DISTINCT(Products[Color]),Products[Color], ", ")
'e.g.
AverageGrossSales = AVERAGEX(SalesOrderDetail, SalesOrderDetail[OrderQty] * SalesOrderDetail[UnitPrice] * (1 - SalesOrderDetail[UnitPriceDiscount]))
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Measures</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_DAX_Measures</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Measures</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_DAX_Measures</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_DAX_Measures

'when you look at Measures in the DATA view you don't see it's column or individual values, rather you have to put it into a Table Visual to see it's value
'when you look at a Calculated Column in the DATA view you see a column, and values in every row.

the ICON of a MEASURE column is a little CALCULATOR inside a square 

'Calculated Columns: "Expands" a table by adding columns defined ba a defined ???
'					They can only look in the row that they are in.
'vs.
'Measures : "Summarizes" all the data into a single value
'			works with whole columns of data and condense them into a single value
'			Computed at run time, stored temporarily
'			Limited by a Filter Context, which are ALL the filters applied by the user

----------------------------------------------------------------------------------
'SO if you created two columns in a Visual (e.g. Table) and one was based on a Calculated Column using data from a Related table, 
'	and the other was based on a Measure using data from a Related table, then the Calculated-based Rank would remain unchanged as you
'	apply filters to the related Table, but the Measure-based Rank would change as you applied filters to the related Table.

'e.g. for a Calculated Column
Ranking =        RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))

'e.g. for a MEASURE Column
RankingMeasure = RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))		
---------------------------------------------------------------------------------
'e.g.
Total Gross Sales := SUM( Sales[Gross Sales] )  'where Sales[Gross Sales] is Table[field])

'To make sure you are applying the measure to the right table, right click on the table {in Data View}

'You can create Measures in tables with no data

'When you create a 'MEASURE' in the 'Fields' panel of a Table, 
'	and you look at the table in Data View, 
'	you do NOT see a column for the measure
'HOWEVER, you can drag n drop the MEASURE from the 'Fields' panel, into the 'Values' field of a Matrix visualization (for example)
'	and it will show up as a column in the Matrix Visualization

'You can NOT use a MEASURE in a SLICER

CALCULATE 'is good for writing Measures

'You can move a Measure:
Visualization View =&gt; Select the Measure {located in some table} =&gt; Modeling {top menu}
	=&gt; Home Table:xxxTable {drop down}  =&gt; {pick some other table}
---------------------------------------------------------------------------------
'A measure can only use in it's formula: (a) other measures or (b) functions of regular columns (e.g. SUM(someColumn), but it can not use a simple column.	
'Example:
Net Sales = sum(Sales[SalesAmount])-sum(Sales[TotalCost])-sum(Sales[ReturnAmount])-sum(Sales[DiscountAmount])
'Whereas here is a calculated column
Net Sales Calc = Sales[SalesAmount]-Sales[TotalCost]-Sales[ReturnAmount]-Sales[DiscountAmount]
'If you use the Meausure's formulate (i.e. with the Aggregate functions) in a Calculated column then every row has the same value:
Net Sales Calc using Aggregates = sum(Sales[SalesAmount])-sum(Sales[TotalCost])-sum(Sales[ReturnAmount])-sum(Sales[DiscountAmount])</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Misc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>VAR_Variables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Misc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>VAR_Variables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'PseudoCode:
myFormula = VAR = VariableName1 = &lt;some valid DAX formula&gt;
            VAR = VariableName2 = &lt;some other valid DAX formula&gt;
            RETURN &lt;another valid DAX formula that can use VariableName1 
                       and VariableName2 as part of the expression&gt;
                       
'Example:

[ABC Class] =
				VAR MySales = Products[ProductSales]
				VAR ProductsWithSalesBiggerThanMine =									'&lt;==== Table Variable
				    FILTER ( ALL ( Products ), Products[ProductSales] &gt;= MySales )
				VAR CumulatedSales =
				    CALCULATE ( SUM ( Sales[SalesAmount] ), ProductsWithSalesBiggerThanMine )
				VAR CumulatedPercentage =
				    CumulatedSales / SUM ( Sales[SalesAmount] )
				RETURN
				    SWITCH (
						        TRUE (),
						        CumulatedPercentage &lt;= 0.7, "A",
						        CumulatedPercentage &lt;= 0.9, "B",
						        "C"
						    )                       
                       
'It is possible to set scalar values as variables but it is also possible to assign tables as variables.

'Scalar Value Example
---------------------
VAR myScalarValue = SUM(Sales[Extended Amount]) 

'Table Example
------------------
VAR myTable = FILTER(Customer,Customer[Post Code] = 50210) 
'The above variable myTable returns a virtual table 
'that can be used anywhere that a table is used in a DAX formula, such as a filter inside a CALCULATE function.              

'Once the variable has been assigned a value, that value cannot change during the execution of the RETURN portion of the formula. 
'From that perspective, the variables act more like constants than regular variables in a traditional programming language context.


-----------------------------------------------------------------DEFINE clause
'You can declare DAX variables in the DEFINE clause of a query like so:
DEFINE
    VAR MyMonth = "January"
    VAR FilteredMonths =
        FILTER ( VALUES ( Sales[Month] ), Sales[Month] = MyMonth )
EVALUATE
CALCULATETABLE ( Sales, FilteredMonths )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Operators</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Operators</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Operators</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Operators</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>whatever

Arithmetic operator					Meaning						Example
+ (plus sign)						Addition						3+3
– (minus sign)						Subtraction or sign				3–1–1
* (asterisk)						Multiplication					3*3
/ (forward slash)					Division						3-Mar
^ (caret)							Exponentiation					16^4

Comparison operator					Meaning						Example
=									Equal to						[Region] = "USA"
&gt;									Greater than					[Sales Date] &gt; "Jan 2009"
&lt;									Less than						[Sales Date] &lt; "Jan 1 2009"
&gt;=									Greater than or equal to		[Amount] &gt;= 20000
&lt;=									Less than or equal to			[Amount] &lt;= 100
&lt;&gt;									Not equal to					[Region] &lt;&gt; "USA"

Text operator								
&amp; (ampersand)						Connects, or concatenates, two values to produce one continuous text value						
									[Region] &amp; ", " &amp; [City]
||	  OR
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Relationhships</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>problems_creating_Relationships</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Relationhships</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>problems_creating_Relationships</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1]ERROR: 
"We cannot create a relatioship between 'Table1'[field1] and 'Table2'[field1]."
"This could be because there is missing intermediate data to connect the two columns"

'TRY:
The columns can not have the Summation Symbol (Sigma) which indicates that 
PowerBI will provide summations for the column b/c they are numeric, in a visual.
But we want to use the column as an Identifier column

So: go to the model (not the query) select the table and column =&gt; Modeling {tab} =&gt;
	Default Summarization Count {drop-down} =&gt; {change it to "Do Not Summarize"}
	
Another problem is duplicates:
In that case go back to the Query, and using the Filter drop-down, 
	remove a category that is creating duplicates
	
'2] ERROR:	
"You can't create a relationship between these two columns because one of the 
" columns must have unique values

In that case go back to the Query, and using the Filter drop-down, 
	remove a category that is creating duplicates
	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Time_Intelligence</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>YearOverYear_Growth</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Time_Intelligence</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>YearOverYear_Growth</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>YearOverYear_Growth

'Relationship:
[OrderDate] of table [SalesHeader]  &lt;=&gt; [Date] of table [Date]
'Cardinality: Many-to-one

'TABLE: [Date] w/ 3 column &amp; 1 Measure
--------------
'C1: Date
'C2: "Year"
'C3: "Month"

Date =
ADDCOLUMNS (
    CALENDARAUTO ( 12 ),
    "Year", YEAR ( [Date] ),
    "Month", MONTH ( [Date] )
)
'Measure: YTD which pulls from the [SalesHeader] Table
YTD = TOTALYTD(SUM(SalesHeader[TotalDue]),'Date'[Date])


'TABLE: [SalesHeader]
---------------------
'C1: OrderDate
'C2: OrderDateNum  {YYYYMMDD : INTEGER}
'Measure1: 
	Prev Year = CALCULATE(SUM(SalesHeader[TotalDue]),PREVIOUSYEAR('Date'[Date]))
'C3: SalesOrderID
'C4: TotalDue
'Measure2: 
YoY Growth =
	 ( SUM ( SalesHeader[TotalDue] ) - [Prev Year] )
	    / SUM ( SalesHeader[TotalDue] )
	
'Design Surface
---------------------
Table Visual
'Values:
	[DATE].[Year]				'{Don't summarize}
	[SalesHeader].[TotalDue]	'{Sum}
	[SalesHeader].[Prev Year]	'
	[SalesHeader].[YoY Growth]	'
	
	

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Time_Intelligence</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>YearToDate_total</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Time_Intelligence</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>YearToDate_total</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Start w/ 2 tables:

'Relationship:
[OrderDate] of table [SalesHeader]  &lt;=&gt; [Date] of table [Date]
'Cardinality: Many-to-one

'TABLE: [Date] w/ 3 column &amp; 1 Measure
--------------
'C1: Date
'C2: "Year"
'C3: "Month"
Date = ADDCOLUMNS(CALENDARAUTO(12),"Year", YEAR([Date]),"Month", Month([Date]))
'Measure: YTD which pulls from the [SalesHeader] Table
YTD = TOTALYTD(SUM(SalesHeader[TotalDue]),'Date'[Date])


'TABLE: [SalesHeader]
---------------------
'C1: OrderDate
'C2: OrderDateNum  {YYYYMMDD : INTEGER}
'Measure1: 
	Prev Year = CALCULATE(SUM(SalesHeader[TotalDue]),PREVIOUSYEAR('Date'[Date]))
'C3: SalesOrderID
'C4: TotalDue
'Measure2: 
	YoY Growth = (SUM(SalesHeader[TotalDue]) - [Prev Year]) / Sum(SalesHeader[TotalDue])

'Design Surface
---------------------
Table Visual
'Values:
	[DATE].[Year]				'{Don't summarize}
	[DATE].[Month]				'{Don't summarize}	
	[SalesHeader].[TotalDue]	'{Sum}
	[DATE].[YTD]				'
	
	

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_PowerQuery</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_M_PowerQuery</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_PowerQuery</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_M_PowerQuery</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_M_PowerQuery

DAX formualas &lt;&gt; Power Query Formulas &lt;&gt; M Formula Language
'These are three seperate languages, but M Formula Language is specific to the Power Query Editor.
'M can contain: Variables, Expressions and Values


Powerquery is used when creating Custom Columns, in the Edit Query Window
That is: Power BI Data View =&gt; Edit Queries =&gt; {Select a query} =&gt; Add Column {top menu} =&gt; Custom Column {icon on ribbon}

You can also see the M Language for the 'Applied Steps' 
when you go to the Advanced Editor:
 Power BI Data View =&gt; Edit Queries =&gt; {Select a query} =&gt; Home {top menu} 
 	=&gt; Query {section of ribbon} =&gt; Advanced Editor

References
-------------
List of M functions

https://docs.microsoft.com/en-us/powerquery-m/power-query-m-function-reference

https://docs.microsoft.com/en-us/powerquery-m/power-query-m-reference



 M Queries In Visual Studio
 --------------------------
 https://blog.crossjoin.co.uk/2018/02/12/running-m-queries-in-visual-studio-with-the-power-query-sdk/
 
 can get the Power Query SDK for VS:
 https://marketplace.visualstudio.com/items?itemName=Dakahn.PowerQuerySDK</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_PowerQuery</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>DATE_Table_1_record_every14days_using_LIST_functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_PowerQuery</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>DATE_Table_1_record_every14days_using_LIST_functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
		
'FINAL CODE
========================================================================================		
		
let
    referencedate = Number.From(#"Reference Date"),
    startdate = Number.From(Date.StartOfYear(#"Reference Date")),
    enddate = Number.From(Date.EndOfYear(#"Reference Date")),
    list1 = List.Generate(()=&gt;referencedate, each _ &lt;=enddate, each _+14),
    list2 = List.Generate(()=&gt;startdate, each _ &lt;referencedate, each _-14),
    dates = List.Combine({list2,list1}),
    #"Converted to Table" = Table.FromList(dates, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
    #"Changed Type" = Table.TransformColumntypes(#"Converted to Table",{{"Column1", type date}}),
    #"Renamed Columns" = Table.RenameColumns(#"Changed Type",{{"Column1", "Dates"}})
in
    #"Renamed Columns"
======================================================================================== 


'This M-Code produces a date List for every day from start to end of the present year
'=====================================================================================
let
    startdate = Number.From(Date.StartOfYear(DateTime.Date(DateTime.FixedLocalNow()))),
    enddate = Number.From(Date.EndOfYear(DateTime.Date(DateTime.FixedLocalNow()))),
    Source = {startdate..enddate},
    #"Converted to Table" = Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
    #"Changed Type" = Table.TransformColumntypes(#"Converted to Table",{{"Column1", type date}}),
    #"Renamed Columns" = Table.RenameColumns(#"Changed Type",{{"Column1", "Dates"}})
in
    #"Renamed Columns"

' BUT we want a List of dates, every 14 days, on Fridays, for the year
'============================================================

1] 'Create a reference day from a Blank Query, this is a Friday
	'Turn a string value into a DATE value using the Date.From function
	= Date.From("8/23/2019")

2] 'Then start the second query w/ a List.Generate Function
	' start with zero, increase each value in the list by increments of 2
	' until we reach 10, then the loop stops
	' the underscore serves as a 'variable' in conjunction with'each' for the LIST function

	= List.Generate(()=&gt;0, each _ &lt;=10, each _+2)
	
	'OUTPUT
	------------
		0
		2
		4
		6
		8
		10
		
	'Then convert to a table: Transform {menu} =&gt; [To Table]	
	= Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error)	
		
	'Then change datatype to DATE: in the header of the column
	= Table.TransformColumnTypes(#"Converted to Table",{{"Column1", type date}})
	
	'This is proof-of-concept that we can go from a list of numbers to a DATES table
		
3] 'Remove the last two steps from the query back to this:		
	= List.Generate(()=&gt;0, each _ &lt;=10, each _+2)	
		
	' and go into the advanced editor:
	
		let
		    Source = List.Generate(()=&gt;0, each _ &lt;=10, each _+2)
		in
		    Source		
			
4] 'Add the Parms, and test to look at the 'enddate'

		let
		    referencedate = Number.From(#"Reference Date"),
		    startdate = Number.From(Date.StartOfYear(#"Reference Date")),
		    enddate = Number.From(Date.EndOfYear(#"Reference Date"))
		    Source = List.Generate(()=&gt;0, each _ &lt;=10, each _+2)
		in
		    enddate
		
	'OUTPUT
	========
	43830	
		
5] 'Modify the 'source' using reference date,enddate, and jumping 14 days at atime:
		let
		    referencedate = Number.From(#"Reference Date"),
		    startdate = Number.From(Date.StartOfYear(#"Reference Date")),
		    enddate = Number.From(Date.EndOfYear(#"Reference Date")),
			Source = List.Generate(()=&gt;referencedate, each _ &lt;=enddate, each _+14)
		in
		    Source		
		
	'OUTPUT
	========
		43700
		43714
		43728
		43742
		43756
		43770
		43784
		43798
		43812
		43826			
				
6] 'MODIFY the M-Code: create 2 lists, one counting up, the other counting down.
	' exclude the reference date (i.e. remove "=") from list2, so that it is not duplicated
	'NOTE: put the pair of lists within brackets (i.e. list characters}
	'Put list2 before list1 to get them in the right order
	
		let
			referencedate = Number.From(#"Reference Date"),
			startdate = Number.From(Date.StartOfYear(#"Reference Date")),
			enddate = Number.From(Date.EndOfYear(#"Reference Date")),
			list1 = List.Generate(()=&gt;referencedate, each _ &lt;=enddate, each _+14),
			list2 = List.Generate(()=&gt;startdate, each _ &lt;referencedate, each _-14),
			dates = List.Combine({list2,list1})
			
		in
			dates
			
	'OUTPUT is whole numbers
	=========
		43700
		43714
		43728
		43742
		...
		29648
		29634
		29620		
		
7] 'Convert Whole numbers to DATEs		
	Transform {menu} =&gt; [To Table]
	{and convert to DATE type}
		
	'OUTPUT
	=======
	1/1/2019
	12/18/2018
	12/4/2018
	11/20/2018
	11/6/2018
	10/23/2018
	10/9/2018
	...
	12/23/1980
	12/9/1980
	11/25/1980
	11/11/1980
	10/28/1980
	10/14/1980
	9/30/1980
	9/16/1980			
		
   </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_PowerQuery</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>DATE_Table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_PowerQuery</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>DATE_Table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>To creat a Dynamic Data Table for the current year from the START to the END of the current year:



1] Create a list from 1..100

	New Source =&gt; Blank Query
	{set the Formula Bar:}  = {1..100}
	
2] In the Transform {Menu, Ribbon} =&gt; [To Table] {except defaults}

	{now you have a table}
	
	{Now you see in the formulat bar:}
		= Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error)
		
3] }Select the column, and change the Data type to DATE}
	{Right click the column head} =&gt; DATE
	{Now you see dates in the column, and this in the formula Bar:}
		= Table.TransformColumnTypes(#"Converted to Table",{{"Column1", type date}})
		
	{rename the column: Dates}
	{formula bar:}
		= Table.RenameColumns(#"Changed Type",{{"Column1", "Dates"}})
		
4] {Then go to the Advanced Editor for the M-code}

	let
	    Source = {1..100},
	    #"Converted to Table" = Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
	    #"Changed Type" = Table.TransformColumnTypes(#"Converted to Table",{{"Column1", type date}}),
	    #"Renamed Columns" = Table.RenameColumns(#"Changed Type",{{"Column1", "Dates"}})
	in
	    #"Renamed Columns"
	    
5] {edit the M-code, to have the list start and end appropriately}

	let
	    startdate = Number.From(Date.StartOfYear(DateTime.Date(DateTime.FixedLocalNow()))),
	    enddate = Number.From(Date.EndOfYear(DateTime.Date(DateTime.FixedLocalNow()))),
	    Source = {startdate..enddate},
	    #"Converted to Table" = Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
	    #"Changed Type" = Table.TransformColumnTypes(#"Converted to Table",{{"Column1", type date}}),
	    #"Renamed Columns" = Table.RenameColumns(#"Changed Type",{{"Column1", "Dates"}})
	in
	    #"Renamed Columns"	    	
	    
	    
	    
	 {NOTE: that the Number.From() function converts the dates to numbers}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_PowerQuery</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Functions_built-in</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_PowerQuery</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Functions_built-in</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/powerquery-m/power-query-m-function-reference

Functions by category
======================
Accessing data functions
Binary functions
Combiner functions
Comparer functions
Date functions
DateTime functions
DateTimeZone functions
Duration functions
Error handling
Expression functions
Function values
List functions
Lines functions
Logical functions
Number functions
Record functions
Replacer functions
Splitter functions
Table functions
Text functions
Time functions
Type functions
Uri functions
Value functions</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_PowerQuery</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LIST_object</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_PowerQuery</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LIST_object</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>List Object = ordered sequence of values 
M language classifies lists, records and tables as structured values
List objects use Curly braces


To create a simple List
=================================================================================
Home =&gt; Get Data =&gt; Blank Query

		= {2,5,"a","c"}
		
		
To create a list from 1 to 365
-------------------------
Home =&gt; Get Data =&gt; Blank Query
		
		= {1..365}
		= {1,3,5..365}	&lt;== This creates a list from 1 to 365, but with just odd numbers 		
		
To create a list of single characters
-------------------------
Home =&gt; Get Data =&gt; Blank Query		
				
		= Text.ToList("hello world")
		
To create a list of dates from today to 10 days from now
-------------------------
Home =&gt; Get Data =&gt; Blank Query			
		'List.Dates(start,count,steps)
		= List.Dates(DateTime.Date(DateTime.FixedLocalNow()),10,#duration(1,0,0,0))
		
'DateTime.Date = gets the DATE for Now()
'Duration Function, for 1 day: #duration(1,0,0,0)
'		#duration(days as number, hours as number, minutes as number, seconds as number) as duration


To create a LIST object by referencing a column in a table
============================================================
1] via a Table name
   ---------------------------------------------------------------
   to get a list from query:
   create a blank query and reference the
   	a) query name:
   		"Population by Zip Code"
   	b) the column name in the query:
   		[Zip Code]
   		
   	Like this:
   = #"Population by Zip Code"[Zip Code]

2] via a query step name {using a Short cut to get the M-code}
   ---------------------------------------------------------------
	- Starting from an existing query 
	=&gt; select a column (e.g. ZipCode column where the last step of query is named "Changed Type") 
	=&gt; {right-click} =&gt; {select from right click menu:} Drill Down 
	=&gt; {it opens a new step in the query, and in the address bar we see: "= #"Changed type"[Zip Code]"}
		{note this is the previous step of the query, and the name of the column}
	{NOTE: that code is a quick short cut to the 'list' by referencing the 'step' and the 'column'}
	
	
	SO, if you create a blank query, and then put in this M-code, you get a LIST object 
		= #"Changed Type"[Zip Code]
		</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_PowerQuery</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>RECORD_object</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_PowerQuery</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>RECORD_object</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>M language classifies lists, records and tables as structured values
Record objects use square brackets, with commas seperating fields

To create a record object:
---------------------------
1) Create a blank query with a single record
2) in the formula bar type:
	= [City = "Los Angeles", State = "California"]
3) [Enter]
4) To convert the RECORD object into a LIST object, put curly brackets around the square brackets
	= {[City = "Los Angeles", State = "California"]}
5) Now to convert the LIST object to a TABLE object:
	{note I see 2 'Tranform' menu items, use the 2nd one
	=&gt; {2nd Transform menu} =&gt; [To Table] =&gt; To Table {window} =&gt; {accept defaults} [Ok]

	{now you see the following in the formula bar:
	= Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error)
	
6) now expand out the table:
	{You see a 'table' with one 'column' named [Column1], and it has one 'record' but you can't see the details (gold colored)
	{Click the split-arrows in the top right of the column} =&gt; [ ] Use original Column names as prefix 
	=&gt; [OK]
	(you see 2 columns: Column1.City and Column1.State, with the data in the first row}
	
7) {At this point you see a query with 3 steps: 
	Source
	Converted to Table
	Expanded Column1

	In the Source step, you see this in the formula bar:
	= {[City = "Los Angeles", State = "California"]}
	To add records, modify the formula bar in the first step:
	= {[City = "Los Angeles", State = "California"],[City = "Santa Barbi", State = "California"]}
	
 8) Now when you jump to the last step, you will see 2 records
 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_PowerQuery</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Table_object</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_PowerQuery</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Table_object</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>M language classifies lists, records and tables as structured values</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_newADUser.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_newADUser.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'create a temporary user in Active Directory
#'This requires the ActiveDirectory PowerShell module from RSAT

Param(
    [Parameter(Mandatory, HelpMessage = "Enter the user name like 'Al Fredo'")]
    [String]$Name,
    [string]$Title,
    [string]$Description,
    [string]$Department
)

Write-Host "Creating temporary AD Account for $Name." -ForegroundColor Cyan
#'split the name into first and last name
$first = $name.split(' ')[0]
$last = $name.split(' ')[1]

#'create the samaccountname
if ($last.Length -gt 13) {
    $accountname = "$($first[0])$($last.Substring(0,13))"		#'In case the name is too long
}
else {
    $accountname = "$($first[0])$last"   
}
$upn = "$accountname@company.pri"

#'create a password
#'use these characters as the source
#'no o(scar) or l(arry) characters to avoid confusing with zero and one.
$seed = "abcdefghijkmnpqrstuvwxyz0192837465)!(@*#'&amp;$^"
#'get 9 random characters
$random9 = $seed.ToCharArray() | get-random -count 9
#'join back to a string
$randomstring = $random9 -join ""

#'this is a regular expression pattern to match on any character from a to z
[regex]$rx = "[a-z]"
#'get the first matching alphabet character
$firstalpha = $rx.match($randomstring).value
#'replace the first alphabet character with its upper case version
$plaintext = $randomstring.Replace($firstalpha, $firstalpha.toUpper())

#'convert the password to a secure string for the New-ADUser cmdlet
$password = ConvertTo-SecureString -String $plaintext -AsPlainText -Force

#'define a hashtable of parameter values to splat to New-ADUser
$new = @{
    DisplayName           = $Name
    GivenName             = $first
    Surname               = $last
    Name                  = $accountName
    samaccountname        = $accountName
    UserPrincipalName     = $upn
    enabled               = $True
    AccountExpirationDate = (Get-Date).AddDays(180).Date			#' 180 day temp user
    AccountPassword       = $password
    path                  = "OU=Employees,DC=company,DC=pri"
    Title                 = $Title
    Department            = $Department
    Description           = $Description
    ErrorAction           = "Stop"
}

Try {
    New-ADUser @new
    Write-Host "Created user $accountname that expires $($new.AccountExpirationDate). Password is $plaintext." -ForegroundColor Green
}
Catch {
    $wsh = new-object -com wscript.shell
    $msg = "Failed to create user $Name. $($_.exception.message)"
    #'display a popup warning and force user to click ok
    $wsh.Popup($msg, -1, "New User", 0 + 48)
}
Finally {
    Write-Host "Finished $($myinvocation.MyCommand)" -ForegroundColor Cyan
}


&lt;#'
demo usage

$p = @{
    Name = "Matilda Fuzziwick" 
    Title = "Shipping Clerk" 
    Department = "Sales"
    Description = "Seasonal hire"
}
 
.\Create-newADUser.ps1 @p
 
get-aduser mfuzziwick -Properties title,department,description

#'try to create the user again

#'reset demo
 get-aduser mfuzziwick | remove-aduser -confirm:$false

#'&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>userAccountControl_field_in_AD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>userAccountControl_field_in_AD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://powershelltutorial.net/ActiveDirectory/

'The User Account Control attribute requires an integer data type
'you can see it in the Attribute Editor tab of the User's properties

Ads Constant								Hex Value	Decimal Value
ADS_UF_SCRIPT								0x0001	1
ADS_UF_ACCOUNTDISABLE						0x0002	2
ADS_UF_HOMEDIR_REQUIRED						0x0008	8
ADS_UF_LOCKOUT								0x0010	16
ADS_UF_PASSWD_NOTREQD						0x0020	32
ADS_UF_PASSWD_CANT_CHANGE					0x0040	64
ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED		0x0080	128
ADS_UF_TEMP_DUPLICATE_ACCOUNT				0x0100	256
ADS_UF_NORMAL_ACCOUNT						0x0200	512
ADS_UF_INTERDOMAIN_TRUST_ACCOUNT			0x0800	2048
ADS_UF_WORKSTATION_TRUST_ACCOUNT			0x1000	4096
ADS_UF_SERVER_TRUST_ACCOUNT					0x2000	8192
ADS_UF_DONT_EXPIRE_PASSWD					0x10000	65536
ADS_UF_MNS_LOGON_ACCOUNT					0x20000	131072
ADS_UF_SMARTCARD_REQUIRED					0x40000	262144
ADS_UF_TRUSTED_FOR_DELEGATION				0x80000	524288
ADS_UF_NOT_DELEGATED						0x100000	1048576
ADS_UF_USE_DES_KEY_ONLY						0x200000	2097152
ADS_UF_DONT_REQUIRE_PREAUTH					0x400000	4194304
ADS_UF_PASSWORD_EXPIRED						0x800000	8388608
ADS_UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION	0x1000000	16777216

example user with value 546

#'So the value of 546 represents an answer to an equation. 
#'It is the decimal values (Flags) added together that gives us the value for the attribute. 
#'
#' 
#'I’ve introduced a term called a Constant. 
#'A constant is a variable with one major difference.
 
#' A variable’s value can be changed where a Constant’s value always stays the same throughout the script. 
#'
#'Using the Decimal Value column in the table let’s look at what type of Control has been set on FirstName’s Account. 
#'By process of elimination we figure the puzzle out like this:
#'
#'1. Looking at FirstName’s control value of 546, 
#'    what is the highest attribute number we can start with? 
#'    Should be 512… correct? So we know this is a NORMAL_ACCOUNT (basically a user account). 
#'    Subtract 512 from 546 and we have 34 left over.
#'
#'2. With 34 left over, what is the next attribute number we can apply? 
#'    Should be PASSWD_NOTREQD which has a decimal value of 32. 
#'    Subtract 32 from 34 and we should have a value of 2 left over.
#'
#'3. What’s the next value that is assigned? ACCOUNTDISABLE has a decimal value of 2. 
#'    Subtract 2 from 2 and we have no value left over.
#'
#'So, according to the userAccountControl attribute; 
#'    FirstName LastName is a Normal account that doesn’t require a password and is currently disabled.

'Just by looking at the ACCOUNTDISABLE flag, 
'	it should be apparent that we can enable the account by removing a decimal value of 2 
'	from the current userAccountControl attribute. 

$objUser = [ADSI]“LDAP://CN=FirstName LastName,OU=TestOUUsers,OU=TestOU,DC=MyDomain,DC=msft”
$objUser.put(“userAccountControl”, 544)
$objUser.SetInfo()

#'Important: The userAccessControl attribute holds only one integer, 
#'    which is the sum of all the integer values for each Control Flag 
#'    that you wish to set. Keep this in mind when changing this attribute. 
#'Let’s say you have a user account with the attribute set to 8388608 (Password Expired). 
#'    Your boss has asked that you disable the account but he also wants to make sure 
#'    the password stays expired should someone at the help desk get duped into re-enabling the account. 
#'In this case you would want to set the userAccessControl attribute to 8388610. 
#'Can you see why changing the attribute to a value of just 2 would be an issue? 
#'If you disabled the account using the value of 2 (ACCOUNTDISABLE) you have removed the value of 8388608
#'     and now the Password is not expired. 
#'Hope that makes sense… You can get into a lot of trouble setting attributes, so be careful and thorough.
#'


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_InstalledSoftware_32_and_64_v0.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_InstalledSoftware_32_and_64_v0.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get_InstalledSoftware_32_and_64_v0.ps1

#'This Powershell script list all the installed application on both 32 and 64 bit applications, 
#'	particularly useful for people managing both 32-bit and 64-bit applications.
 
#'	This code also contains an EXCLUSION array where you can exclude list of program that you don't want to show.
#'
#'The function allows -ComputerName parameter so you can connect to any machines
#'Application architecture detection (32-bit or 64-bit) using Win32_processor
#'Output is Powershell console and GridView

#'https://gallery.technet.microsoft.com/scriptcenter/PowerShell-Installed-70d0c0f4

#'===================================================================================USAGE
Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================


Function Get-SoftwareList
{
Param(
[Parameter(Mandatory=$true)]
[string[]]$Computername)

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")

[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 
$donotwrite = $false

if($AppName.length -gt "0"){

 Foreach($exclude in $excludeArray) 
                        {
                        if($AppName.StartsWith($exclude) -eq $TRUE)
                            {
                            $donotwrite = $true
                            break
                            }
                        }
            if ($donotwrite -eq $false) 
                        {                        
            $Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "64-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
                        }





}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 
 $donotwrite = $false
         
                             



if($AppName.length -gt "0"){
 Foreach($exclude in $excludeArray) 
                        {
                        if($AppName.StartsWith($exclude) -eq $TRUE)
                            {
                            $donotwrite = $true
                            break
                            }
                        }
            if ($donotwrite -eq $false) 
                        {                        
            $Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
                        }
           }

 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

"#"*80
"Installed Software Application Report"
"Numner of Installed Application count : $($object.count)"
"Generated $(get-date)"
"Generated from $(gc env:computername)"
"#"*80

$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
$object|Out-GridView 


}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v3.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v3.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v3.ps1
#' The exclusion array has been replaced by the inclusion array (for finding Adobe software)
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v3
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $true
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

#'                             Foreach($exclude in $excludeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $true
#'                                                        break
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - START
                             Foreach($include in $includeArray) 
                                                    {
                                                    if($AppName.StartsWith($include) -eq $TRUE)
                                                        {
                                                        $donotwrite = $false
                                                        }
                                                    }
                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $true
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){
#'Foreach($exclude in $excludeArray) 
#'                        {
#'                        if($AppName.StartsWith($exclude) -eq $TRUE)
#'                            {
#'                            $donotwrite = $true
#'                            break
#'                            }
#'                        }

                        #'=================================================================  INCLUSION ARRAY - START
                            Foreach($include in $includeArray) 
                                                {
                                                if($AppName.StartsWith($include) -eq $TRUE)
                                                    {
                                                    $donotwrite = $false
                                                    }
                                                }
                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v4.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v4.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v4.ps1
#' All Applications, with the default Exclusion Array
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v4
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                             Foreach($exclude in $excludeArray) 
                                                    {
                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
                                                        {
                                                        $donotwrite = $true
                                                        break
                                                        }
                                                    }


                            #'=================================================================  INCLUSION ARRAY - START
    #'                         Foreach($include in $includeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($include) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $false
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                        Foreach($exclude in $excludeArray) 
                                                {
                                                if($AppName.StartsWith($exclude) -eq $TRUE)
                                                    {
                                                    $donotwrite = $true
                                                    break
                                                    }
                                                }


                        #'=================================================================  INCLUSION ARRAY - START
#'                            Foreach($include in $includeArray) 
#'                                                {
#'                                                if($AppName.StartsWith($include) -eq $TRUE)
#'                                                    {
#'                                                    $donotwrite = $false
#'                                                    }
#'                                                }

                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v5.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v5.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v5.ps1
#' All Applications, withOUT the default Exclusion Array, the inclusion array is being ignored
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v5
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

#'$excludeArray = ("Security Update for Windows",
#'"Update for Windows",
#'"Update for Microsoft .NET",
#'"Security Update for Microsoft",
#'"Hotfix for Windows",
#'"Hotfix for Microsoft .NET Framework",
#'"Hotfix for Microsoft Visual Studio 2007 Tools",
#'"Hotfix")

$excludeArray = ("whateverXXX")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                             Foreach($exclude in $excludeArray) 
                                                    {
                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
                                                        {
                                                        $donotwrite = $true
                                                        break
                                                        }
                                                    }


                            #'=================================================================  INCLUSION ARRAY - START
    #'                         Foreach($include in $includeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($include) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $false
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                        Foreach($exclude in $excludeArray) 
                                                {
                                                if($AppName.StartsWith($exclude) -eq $TRUE)
                                                    {
                                                    $donotwrite = $true
                                                    break
                                                    }
                                                }


                        #'=================================================================  INCLUSION ARRAY - START
#'                            Foreach($include in $includeArray) 
#'                                                {
#'                                                if($AppName.StartsWith($include) -eq $TRUE)
#'                                                    {
#'                                                    $donotwrite = $false
#'                                                    }
#'                                                }

                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Classes_and_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_Object_using_Hash_table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Classes_and_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_Object_using_Hash_table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#
#' Demo 1 -- Create a new object, by defining the method 'Create-Object'
#' This is the most common method of creating objects
#' Create a Hash table then populate all the properties at once
#'-----------------------------------------------------------------------------#
function Create-Object ($Schema, $Table, $Comment)
{
  #' Build a hash table with the properties
  #' using the [ordered] tag means they will retain the order in which they are defined
  $properties = [ordered]@{ Schema = $Schema
                   Table = $Table
                   Comment = $Comment
                 }

  #' Start by creating an object of type PSObject using "New-Object"
  #' The class name is the 'TypeName' property, in this case use a generic built-in class
  #'  "New-Object" creates an object based on a Class
  
  $object = New-Object –TypeName PSObject -Property $properties

  #' Return the newly created object
  return $object
}


#' Now call the function (i.e. "Create-Object")

$myObject = Create-Object -Schema "MySchema" -Table "MyTable" -Comment "MyComment"
$myObject         #' &lt;=== This will echo back the three properties, and their values

#' Display in text. Note because it is an object need to wrap in $() to access a property
#' use string interpolation (i.e. $(xxx)  ) to reference the "Schema" property of the object 

"My Schema = $($myObject.Schema)"

$myObject.Schema = "New Schema"      #'&lt;=== update the property w/ a new value
$myObject.Comment = "New Comment"
$myObject							 #' &lt;=== This will echo back the three properties, and their values</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Classes_and_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Crreate_Object_adding_one_Member_at_time</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Classes_and_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Crreate_Object_adding_one_Member_at_time</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#'
#' Demo 2 -- Create a new object by adding properties one at a time (to SINGLE or MULTIPLE objects)
#' In the previous demo a property hash table was used to generate the object
#' Behind the scenes it does the equivalent of what this function does
#'-----------------------------------------------------------------------------#'
function Create-Object ($Schema, $Table, $Comment)
{
  #' Start by creating an EMPTY generic object of type PSObject
  $object = New-Object –TypeName psobject     

  #' SIMPLE syntac
  #' {as an Argument to a method (i.e. Add-Member) , this works for creation of ONE object}
  #' after creating it, then add the FIRST Member
  #' Add-Member by passing in input object 
  Add-Member -InputObject $object `
             –MemberType NoteProperty `			#'&lt;=== This is generic property
             –Name Schema `						#'&lt;=== this is the name of the property
             –Value $Schema						#'&lt;=== This is the value of the property


  #' ALTERNATE syntax, pipe the object as an input to Add-Member 
  #' {Pipe the object as input into the Method, could work for a COLLECTION of objects}
  #' Thus you could add a property to ALL the members of a collection  
  #' NOTE that with this syntax, 'object' could itself be a collection of objects
  #
  $object | Add-Member –MemberType NoteProperty `
                       –Name Table `
                       –Value $Table

  #' SECOND Member
  $object | Add-Member -MemberType NoteProperty `
                       -Name Comment `
                       -Value $Comment

  return $object
}

#'USAGE:

#'Create a new object
$myObject = Create-Object -Schema "MySchema" -Table "MyTable" -Comment "MyComment"
$myObject							 #' &lt;=== This will echo back the three properties, and their values

#' Display in text. Note because it is an object need to wrap in $() to access a property
"My Schema = $($myObject.Schema)"

$myObject.Schema = "New Schema"      #'&lt;=== update the property w/ a new value
$myObject.Comment = "New Comment"    #'&lt;=== update the property w/ a new value
$myObject							 #' &lt;=== This will echo back the three properties, and their values</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Classes_and_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>ENUM___requires_v5_PowerShell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Classes_and_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>ENUM___requires_v5_PowerShell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'ENUM___requires_v5_PowerShell



#'region Enum

#'-----------------------------------------------------------------------------#'
#' Show Enums in PS
#'   gives you intellisense when using the enum
#'   and to see if a dynamic value is a valid value for the enum
#'-----------------------------------------------------------------------------#'

#' Define the valid values for the enum
Enum MyTwitters
{
  Pluralsight
  ArcaneCode
  N4IXT
}

#' Note when typing the last : will trigger intellisense!
#' Note that the enum is in Square Brackets
$tweet = [MyTwitters]::ArcaneCode
$tweet

#' See if they picked something valid
[enum]::IsDefined(([MyTwitters]), $tweet)         #' This will return "True"

#' Set it to something invalid and see if it passes as an enum
$tweet = 'Invalid'
[enum]::IsDefined(([MyTwitters]), $tweet)

#'endregion Enum
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CIM_Computer_Info_v2____with__BIOSReleaseDate</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CIM_Computer_Info_v2____with__BIOSReleaseDate</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Usage===========================================================================
#'         &gt; Get-MachineInfo -ComputerName 10.11.56.176 -Protocol Dcom -Verbose
#'===========================================================================

function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1
            #'----------------------------------
            #'CIM_BIOSElement
            #'CIM_BIOSFeature
            #'CIM_BIOSFeatureBIOSElements
            #'CIM_BIOSLoadedInNV
            #'Get-CimClass win32_bios

            #'Get-CimClass CIM_BIOSElement | select -First 1 -ExpandProperty CimClassProperties | Select InstallDate
            $BIOS_params = @{'ClassName'='CIM_BIOSElement'
                             'CimSession'=$session}
            $BIOS = Get-CimInstance @BIOS_params | Select-Object -first 1

            $BIOS | select -First 1 -ExpandProperty ReleaseDate 

            #'----------------------------------
  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                        #'----------------------------------
                       'BIOSReleaseDate' = $BIOS | select -First 1 -ExpandProperty ReleaseDate 
                        #'----------------------------------
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            # Did we specify protocol fallback?
            # If so, try again. If we specified logging,
            # we won't log a problem here - we'll let
            # the logging occur if this fallback also
            # fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #if logging

                Get-MachineInfo @params
            } #if protocolfallback

            # if we didn't specify fallback, but we
            # did specify logging, then log the error,
            # because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } # if write to log

        } #try/catch
 
    } #foreach
} #PROCESS

END {}

} #function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-DiskUsage______xml_Get-CimInstance</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-DiskUsage______xml_Get-CimInstance</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'USAGE: does local machine if there is no computername provided
&gt;Get-DiskUsage gives you the info
'This is actually the master function, 
&gt;Update-DiskXML
'This is used by the master function to create an XML file if it doesn't exist
&gt;New-DiskXML
=================================================================

#'SupportsShouldProcess turns on the WhatIf process
'So if you run it with the -WhatIf 


#'Get-DiskUsage : to retrieve the disk information and writes an object to the pipeline. 
------------------------------------------------------------------------
Function Get-DiskUsage {
[cmdletbinding()]
Param(
[Parameter(Position = 0,ValueFromPipeline)]
[string[]]$Computername = $env:Computername)

Begin {
    #define a hashtable of parameter values for Get-CimInstance
    $pm = @{
        Classname = 'Win32_logicaldisk'
        Filter = "drivetype=3" 
        ComputerName = $Null
        ErrorAction = 'stop'
    }
}

Process {
    foreach ($computer in $Computername) {
        Try {
            #set the next computername
            $pm.Computername = $Computer
            $d = Get-CimInstance @pm
            $d | Select @{Name="Date";Expression={(Get-Date).ToShortDateString()}},
                PSComputername,DeviceID,Size,Freespace,
                @{Name="PercentFree";Expression = {($_.freespace/$_.size)*100 -as [int]}} 
        }
        Catch {
            Write-Warning "[$computer] $($_.exception.message)"
        }
        
        
    }
}

End {
    #not used
}
}


' New-DiskXML: 
'	 creates an empty XML document that meets our requirements. 

Function New-DiskXML {
[cmdletbinding(SupportsShouldProcess)]
Param(
[Parameter(Position = 0, Mandatory, 
HelpMessage = "Enter the filename and path for the new disk XML file")]
[string]$Path
)

[xml]$doc = New-Object System.Xml.XmlDocument

#create declaration
$dec = $doc.CreateXmlDeclaration("1.0","UTF-8",$null)

#append to document
$doc.AppendChild($dec) | Out-Null

#create the outer node
$node = $doc.CreateNode("element","snapshots",$null)

$doc.AppendChild($node) | Out-Null

if ($PSCmdlet.ShouldProcess($path)) {
    $doc.Save($path)
}

}

'The function needs a parameter for the XML file and a group of computernames. 
'If the XML file doesn’t exist,
'	 we wrote another function, New-DiskXML, 
'	 to create an empty XML document that meets our requirements. 
'The Update-DiskXml command calls Get-DiskUsage 
'	to get drive information and then creates snapshot information which it appends to the main document.
Function Update-DiskXML {
[cmdletbinding(SupportsShouldProcess)]
Param(
[Parameter(Position = 0, Mandatory, 
HelpMessage = "Enter the filename and path for the disk XML file")]
[string]$Path,
[Parameter(ValueFromPipeline)]
[string[]]$Computername = $env:COMPUTERNAME
)

Begin {

    if (-Not (Test-Path -Path $path)) {
        #create the file if it doesn't exist
        New-DiskXML -Path $path
    }

    #resolve and convert the path to a filesystem
    $cpath = Convert-Path -Path $path

    #open the XML document
    [xml]$doc = Get-Content -Path $cpath

    #select the Snapshots node
    $snapshots = $doc.ChildNodes[1]  #or $doc.SelectSingleNode("snapshots")

    #property names
    $props = "Date","PSComputername","DeviceID","Size","Freespace","PercentFree"
}
Process {
    $data = Get-DiskUsage $Computername
    foreach ($item in $data) {
        $snap = $doc.CreateNode("element","snapshot",$null)

        #create an entry for each
        $props | foreach {
            $e = $doc.CreateElement($_)
            $e.InnerText = $item.$_
            $snap.AppendChild($e) | Out-Null
        }        
        $snapshots.AppendChild($snap) | Out-Null
    }    
}

End {

    if ($PSCmdlet.ShouldProcess($cpath)) {
        $doc.save($cpath)
 }
}

}

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_Reboot_Restart</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-PendingReboot</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_Reboot_Restart</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-PendingReboot</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gallery.technet.microsoft.com/scriptcenter/Get-PendingReboot-Query-bdb79542

https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/10/determine-pending-reboot-statuspowershell-style-part-1/
https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/11/determine-pending-reboot-statuspowershell-style-part-2/ 


'USAGE:
$Servers = Get-Content C:\DATA\2018_05_09__RespondToPing.txt
#'$Servers = Get-Content C:\DATA\TEST.txt
Get-PendingReboot -Computer $Servers -ErrorLog C:\DATA\2018_05_09__PendingRebootReport_ERRORS.txt | Export-Csv C:\DATA\2018_05_09__PendingRebootReport.csv -NoTypeInformation 



============================================================================


Function Get-PendingReboot
{
&lt;#
.SYNOPSIS
    Gets the pending reboot status on a local or remote computer.

.DESCRIPTION
    This function will query the registry on a local or remote computer and determine if the
    system is pending a reboot, from Microsoft updates, Configuration Manager Client SDK, Pending Computer 
    Rename, Domain Join or Pending File Rename Operations. For Windows 2008+ the function will query the 
    CBS registry key as another factor in determining pending reboot state.  "PendingFileRenameOperations" 
    and "Auto Update\RebootRequired" are observed as being consistant across Windows Server 2003 &amp; 2008.
	
    CBServicing = Component Based Servicing (Windows 2008+)
    WindowsUpdate = Windows Update / Auto Update (Windows 2003+)
    CCMClientSDK = SCCM 2012 Clients only (DetermineIfRebootPending method) otherwise $null value
    PendComputerRename = Detects either a computer rename or domain join operation (Windows 2003+)
    PendFileRename = PendingFileRenameOperations (Windows 2003+)
    PendFileRenVal = PendingFilerenameOperations registry value; used to filter if need be, some Anti-
                     Virus leverage this key for def/dat removal, giving a false positive PendingReboot

.PARAMETER ComputerName
    A single Computer or an array of computer names.  The default is localhost ($env:COMPUTERNAME).

.PARAMETER ErrorLog
    A single path to send error data to a log file.

.EXAMPLE
    PS C:\&gt; Get-PendingReboot -ComputerName (Get-Content C:\ServerList.txt) | Format-Table -AutoSize
	
    Computer CBServicing WindowsUpdate CCMClientSDK PendFileRename PendFileRenVal RebootPending
    -------- ----------- ------------- ------------ -------------- -------------- -------------
    DC01           False         False                       False                        False
    DC02           False         False                       False                        False
    FS01           False         False                       False                        False

    This example will capture the contents of C:\ServerList.txt and query the pending reboot
    information from the systems contained in the file and display the output in a table. The
    null values are by design, since these systems do not have the SCCM 2012 client installed,
    nor was the PendingFileRenameOperations value populated.

.EXAMPLE
    PS C:\&gt; Get-PendingReboot
	
    Computer           : WKS01
    CBServicing        : False
    WindowsUpdate      : True
    CCMClient          : False
    PendComputerRename : False
    PendFileRename     : False
    PendFileRenVal     : 
    RebootPending      : True
	
    This example will query the local machine for pending reboot information.
	
.EXAMPLE
    PS C:\&gt; $Servers = Get-Content C:\Servers.txt
    PS C:\&gt; Get-PendingReboot -Computer $Servers | Export-Csv C:\PendingRebootReport.csv -NoTypeInformation
	
    This example will create a report that contains pending reboot information.

.LINK
    Component-Based Servicing:
    http://technet.microsoft.com/en-us/library/cc756291(v=WS.10).aspx
	
    PendingFileRename/Auto Update:
    http://support.microsoft.com/kb/2723674
    http://technet.microsoft.com/en-us/library/cc960241.aspx
    http://blogs.msdn.com/b/hansr/archive/2006/02/17/patchreboot.aspx

    SCCM 2012/CCM_ClientSDK:
    http://msdn.microsoft.com/en-us/library/jj902723.aspx

.NOTES
    Author:  Brian Wilhite
    Email:   bcwilhite (at) live.com
    Date:    29AUG2012
    PSVer:   2.0/3.0/4.0/5.0
    Updated: 27JUL2015
    UpdNote: Added Domain Join detection to PendComputerRename, does not detect Workgroup Join/Change
             Fixed Bug where a computer rename was not detected in 2008 R2 and above if a domain join occurred at the same time.
             Fixed Bug where the CBServicing wasn't detected on Windows 10 and/or Windows Server Technical Preview (2016)
             Added CCMClient property - Used with SCCM 2012 Clients only
             Added ValueFromPipelineByPropertyName=$true to the ComputerName Parameter
             Removed $Data variable from the PSObject - it is not needed
             Bug with the way CCMClientSDK returned null value if it was false
             Removed unneeded variables
             Added PendFileRenVal - Contents of the PendingFileRenameOperations Reg Entry
             Removed .Net Registry connection, replaced with WMI StdRegProv
             Added ComputerPendingRename
#&gt;

[CmdletBinding()]
param(
	[Parameter(Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
	[Alias("CN","Computer")]
	[String[]]$ComputerName="$env:COMPUTERNAME",
	[String]$ErrorLog
	)

Begin {  }##'End Begin Script Block
Process {
  Foreach ($Computer in $ComputerName) {
	Try {
	    ##'Setting pending values to false to cut down on the number of else statements
	    $CompPendRen,$PendFileRename,$Pending,$SCCM = $false,$false,$false,$false
                        
	    ##'Setting CBSRebootPend to null since not all versions of Windows has this value
	    $CBSRebootPend = $null
						
	    ##'Querying WMI for build version
	    $WMI_OS = Get-WmiObject -Class Win32_OperatingSystem -Property BuildNumber, CSName -ComputerName $Computer -ErrorAction Stop

	    ##'Making registry connection to the local/remote computer
	    $HKLM = [UInt32] "0x80000002"
	    $WMI_Reg = [WMIClass] "\\$Computer\root\default:StdRegProv"
						
	    ##'If Vista/2008 &amp; Above query the CBS Reg Key
	    If ([Int32]$WMI_OS.BuildNumber -ge 6001) {
		    $RegSubKeysCBS = $WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\")
		    $CBSRebootPend = $RegSubKeysCBS.sNames -contains "RebootPending"		
	    }
							
	    ##'Query WUAU from the registry
	    $RegWUAURebootReq = $WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\")
	    $WUAURebootReq = $RegWUAURebootReq.sNames -contains "RebootRequired"
						
	    ##'Query PendingFileRenameOperations from the registry
	    $RegSubKeySM = $WMI_Reg.GetMultiStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\Session Manager\","PendingFileRenameOperations")
	    $RegValuePFRO = $RegSubKeySM.sValue

	    ##'Query JoinDomain key from the registry - These keys are present if pending a reboot from a domain join operation
	    $Netlogon = $WMI_Reg.EnumKey($HKLM,"SYSTEM\CurrentControlSet\Services\Netlogon").sNames
	    $PendDomJoin = ($Netlogon -contains 'JoinDomain') -or ($Netlogon -contains 'AvoidSpnSet')

	    ##'Query ComputerName and ActiveComputerName from the registry
	    $ActCompNm = $WMI_Reg.GetStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName\","ComputerName")            
	    $CompNm = $WMI_Reg.GetStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\","ComputerName")

	    If (($ActCompNm -ne $CompNm) -or $PendDomJoin) {
	        $CompPendRen = $true
	    }
						
	    ##'If PendingFileRenameOperations has a value set $RegValuePFRO variable to $true
	    If ($RegValuePFRO) {
		    $PendFileRename = $true
	    }

	    ##'Determine SCCM 2012 Client Reboot Pending Status
	    ##'To avoid nested 'if' statements and unneeded WMI calls to determine if the CCM_ClientUtilities class exist, setting EA = 0
	    $CCMClientSDK = $null
	    $CCMSplat = @{
	        NameSpace='ROOT\ccm\ClientSDK'
	        Class='CCM_ClientUtilities'
	        Name='DetermineIfRebootPending'
	        ComputerName=$Computer
	        ErrorAction='Stop'
	    }
	    ##'Try CCMClientSDK
	    Try {
	        $CCMClientSDK = Invoke-WmiMethod @CCMSplat
	    } Catch [System.UnauthorizedAccessException] {
	        $CcmStatus = Get-Service -Name CcmExec -ComputerName $Computer -ErrorAction SilentlyContinue
	        If ($CcmStatus.Status -ne 'Running') {
	            Write-Warning "$Computer`: Error - CcmExec service is not running."
	            $CCMClientSDK = $null
	        }
	    } Catch {
	        $CCMClientSDK = $null
	    }

	    If ($CCMClientSDK) {
	        If ($CCMClientSDK.ReturnValue -ne 0) {
		        Write-Warning "Error: DetermineIfRebootPending returned error code $($CCMClientSDK.ReturnValue)"          
		    }
		    If ($CCMClientSDK.IsHardRebootPending -or $CCMClientSDK.RebootPending) {
		        $SCCM = $true
		    }
	    }
            
	    Else {
	        $SCCM = $null
	    }

	    ##'Creating Custom PSObject and Select-Object Splat
	    $SelectSplat = @{
	        Property=(
	            'Computer',
	            'CBServicing',
	            'WindowsUpdate',
	            'CCMClientSDK',
	            'PendComputerRename',
	            'PendFileRename',
	            'PendFileRenVal',
	            'RebootPending'
	        )}
	    New-Object -TypeName PSObject -Property @{
	        Computer=$WMI_OS.CSName
	        CBServicing=$CBSRebootPend
	        WindowsUpdate=$WUAURebootReq
	        CCMClientSDK=$SCCM
	        PendComputerRename=$CompPendRen
	        PendFileRename=$PendFileRename
	        PendFileRenVal=$RegValuePFRO
	        RebootPending=($CompPendRen -or $CBSRebootPend -or $WUAURebootReq -or $SCCM -or $PendFileRename)
	    } | Select-Object @SelectSplat

	} Catch {
	    Write-Warning "$Computer`: $_"
	    ##'If $ErrorLog, log the file to a user specified location/path
	    If ($ErrorLog) {
	        Out-File -InputObject "$Computer`,$_" -FilePath $ErrorLog -Append
	    }				
	}			
  }##'End Foreach ($Computer in $ComputerName)			
}##'End Process

End {  }##'End End

}##'End Function Get-PendingReboot</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>$ErrorActionPreference</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>$ErrorActionPreference</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$ErrorActionPreference

'Possible Values
-----------------
Continue
SilentlyContinue
Stop
Inquire

'Sets the error behaviour for the current scope - applies to all commands run within that scope

'Can change within the shell, a script, a function, etc.

'All cmdlets accept the -ErrorAction parameter

'Alias is -EA

'Overrides the $ErrorActionPreference got that cmdlet

'Most terminating errors will only terminate the current cmdlet, the script can keep running

' "-EA Stop" or $ErrorActionPreference="Stop"  will terminate the current scope, passing the error the calling scope
'											   which will stop the entire script


--------------------------------------------------------------
$ErrorActionPreference = "Continue"
$contents = Get-Content c:\nonExistantFile.txt	#' -ea "silentlycontinue"
Write-Host "Another command" -ForegroundColor green</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>breakpoints</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>breakpoints</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Breakpoint in code: can test variable values when it goes into DEBUG mode

function Get-DriveInfo {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True,
                   ValueFromPipelineByPropertyName=$True,
                   ValueFromPipeline=$True)]
        [string[]]$ComputerName
    )
    PROCESS {

        Write-Debug "[PROCESS] Beginning"
        ForEach ($comp in $ComputerName) {

            Write-Debug "[PROCESS] on $comp"
            $session = New-CimSession -ComputerName $comp
            $params = @{'CimSession'=$session
                        'ClassName'='Win32_LogicalDisk'}
            $drives = Get-CimInstance @params

            Write-Debug "[PROCESS] CIM query complete"
            if ($drives.DriveType -ne 5) {
                [pscustomobject]@{'ComputerName'=$comp
                                  'Letter'=$drives.deviceid
                                  'Size'=$drives.size
                                  'Free'=$drives.freespace}
            }

        } #foreach

    } #process
} #function

Set-PSBreakpoint -Line 23 -Script ($MyInvocation.MyCommand.Source)
"localhost","localhost" | Get-DriveInfo</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ExtendingOutputTypes </Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Add_a_Member</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ExtendingOutputTypes </Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Add_a_Member</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}

            # create a default display property set
            [string[]]$props = 'ComputerName','OSVersion','Cores','RAM'
            $ddps = New-Object -TypeName System.Management.Automation.PSPropertySet `
                               DefaultDisplayPropertySet, $props
            $pssm = [System.Management.Automation.PSMemberInfo[]]$ddps
            $obj | Add-Member -MemberType MemberSet `
                              -Name PSStandardMembers `
                              -Value $pssm

            ###Adding additional members###
            #adding a property set
            $obj | Add-Member -MemberType PropertySet `
                              -Name OS `
                              -Value 'Computername','OSVersion','OSBuild','Arch'

            #adding an alias
            $obj | Add-Member -MemberType AliasProperty `
                              -Name Free `
                              -Value SysDriveFreeSpace

            #adding a script method
            $obj | Add-Member -MemberType ScriptMethod `
                              -Name Ping `
                              -Value { Test-NetConnection $this.computername }

            #adding a script property
            $obj | Add-Member -MemberType ScriptProperty `
                              -Name TopProcesses `
                              -Value { 
                                Get-Process -ComputerName $this.computername |
                                Sort-Object -Property WorkingSet -Descending |
                                Select-Object -first 5
                                }
                                
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            # Did we specify protocol fallback?
            # If so, try again. If we specified logging,
            # we won't log a problem here - we'll let
            # the logging occur if this fallback also
            # fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #if logging

                Get-MachineInfo @params
            } #if protocolfallback

            # if we didn't specify fallback, but we
            # did specify logging, then log the error,
            # because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } # if write to log

        } #try/catch
 
    } #foreach
} #PROCESS

END {}

} #function

Get-MachineInfo -ComputerName localhost</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ExtendingOutputTypes </Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>script_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ExtendingOutputTypes </Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>script_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' example - see the bottom for notes
function Get-MachineInfo {
&lt;#'
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#'&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
                       
                       #'&lt;========= This is where you would 'add' things to the object
                       
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            #' Did we specify protocol fallback?
            #' If so, try again. If we specified logging,
            #' we won't log a problem here - we'll let
            #' the logging occur if this fallback also
            #' fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #'if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #'if logging

                Get-MachineInfo @params
            } #'if protocolfallback

            #' if we didn't specify fallback, but we
            #' did specify logging, then log the error,
            #' because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } #' if write to log

        } #'try/catch
 
    } #'foreach
} #'PROCESS

END {}

} #'function

===========================================================================================

#' this is the bit we'll change
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj



#' here's the change
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}

            #' create a default display property set                          #'  &lt;==========display property set
            [string[]]$props = 'ComputerName','OSVersion','Cores','RAM'
            $ddps = New-Object -TypeName System.Management.Automation.PSPropertySet `
                               DefaultDisplayPropertySet, $props
            $pssm = [System.Management.Automation.PSMemberInfo[]]$ddps
            $obj | Add-Member -MemberType MemberSet `
                              -Name PSStandardMembers `
                              -Value $pssm

            Write-Output $obj

--------------------------------------------------
'USAGE of predefined group of properties:
&gt; $a | Select Computername,OSVersion,OSBuild,Arch
'shortens to this:
&gt; $a | Select OS
---------------------------------------------

#' more member types...
#'adding an alias, after the object is defined
$obj | Add-Member -MemberType AliasProperty `
                    -Name Free `
                    -Value SysDriveFreeSpace
                    
'USAGE
-------                    
&gt; $a.SysDriveFreeSpace

--------------------------------------------------------------

#'adding a script method, after the object is defined
$obj | Add-Member -MemberType ScriptMethod `
                    -Name Ping `
                    -Value { Test-NetConnection $this.computername }
                    
'USAGE of a Method
--------------
&gt;$a.ping()                    
                    
---------------------------------------------------------------
#'adding a script property, after the object is defined
$obj | Add-Member -MemberType ScriptProperty `
                    -Name TopProcesses `
                    -Value { 
                    Get-Process -ComputerName $this.computername |
                    Sort-Object -Property WorkingSet -Descending |
                    Select-Object -first 5
                    }
'USAGE of property
----------------
&gt;$a.TopProcesses


#' insert a custom name
$obj.psobject.TypeNames.Insert(0,"myMachineInfo")   &lt;=== The authors said this was flaky



#' extending with update-typedata
$myType = "myMachineInfo"

Update-TypeData -TypeName $myType -DefaultDisplayPropertySet 'ComputerName','OSVersion','Cores','RAM' -force

Update-TypeData -TypeName $myType -MemberType AliasProperty -MemberName Free `
                                  -Value SysDriveFreeSpace -force 

Update-TypeData -TypeName $myType -MemberType ScriptMethod -MemberName Ping `
                                  -Value { 
                                    Test-NetConnection $this.computername 
                                   } -force 

Update-TypeData -TypeName $myType -MemberType ScriptProperty -MemberName `
                              TopProcesses -Value { 
                              Get-Process -ComputerName $this.computername |
                              Sort-Object -Property WorkingSet -Descending |
                              Select-Object -first 5
                              } -force



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FOLDERS_Blocked_Inheritance</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FOLDERS_Blocked_Inheritance</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://www.petri.com/identify-folders-with-blocked-inheritance-using-powershell
'AreAccessRulesProtected is a boolean property. If the value is true, then inheritance has been disabled. 
cls
dir 'C:\Program Files' -Directory | get-acl | 
Select @{Name="Path";Expression={Convert-Path $_.Path}},AreAccessRulesProtected |
Format-table -AutoSize
#' If the value is true, then inheritance has been disabled

--------------

'Because the AreAccessRulesProtected property is a boolean, you don’t need to use the –eq operator, 
'	so it’s a simple matter to filter out folders that have blocked inheiritance
dir c:\work -Directory -recurse | get-acl | 
Where {$_.AreAccessRulesProtected} | 
Select @{Name="Path";Expression={Convert-Path $_.Path}},AreAccessRulesProtected |
format-table -AutoSize
'These are the folders under C:\Work that have inheritance disabled.
'If I want to find folders that have inheritance enabled, then I can use the –NOT operator in my filter.

-----------------
'This on the other had is the folders w/ blocked inheritance:
cls
dir 'C:\Program Files' -Directory -recurse | get-acl | 
Where  {-not $_.AreAccessRulesProtected} | 
Select @{Name="Path";Expression={Convert-Path $_.Path}},AreAccessRulesProtected |
format-table -AutoSize


====================================================
'Let’s say you want to re-enable inheritance once you’ve identified folders with blocked inheritance. The following outlines a simple way to do so.

'First, we need the access control list for a folder.
&gt;$acl = get-acl c:\work\demo2
'To modify, we can use the SetAccessRuleProtection() method, which takes a few parameters.

------------
'This will let you see the overloads
$acl.SetAccessRuleProtection.OverloadDefinitions
-----------

'The parameter values are both boolean. 
'The second parameter indicates if you want to save existing rules, and I generally do.

&gt;$acl.SetAccessRuleProtection($False,$True)

'All I’ve done is set the property on the ACL object. It hasn’t been applied to the folder. 
'To accomplish that, I need to use Set-ACL.

&gt;set-acl -Path c:\work\demo2 -AclObject $acl

==============================================================
'To make life easier, I have a function called Set-Inheritance.

#requires -version 3.0
 
Function Set-Inheritance {
 
[cmdletbinding(SupportsShouldProcess)]
 
	Param(
		[Parameter(Position=0,Mandatory,HelpMessage="Enter the file or folder path",
		 ValueFromPipeline=$True,ValueFromPipelineByPropertyName)]
	[ValidateNotNullOrEmpty()]
	[Alias("PSPath")]
	[string]$Path,
	[switch]$NoInherit,
	[switch]$NoPreserve,
	[switch]$Passthru
)

'With this function, I can easily reset inheritance with a one-line command:
&gt;dir c:\work -Directory -recurse | get-acl | Where {$_.AreAccessRulesProtected} | set-inheritance -whatif

'If I intentionally want to disable or block inheritance, I can do that as well.
&gt;Set-Inheritance C:\work\demo1 -NoInherit

'Be careful about using the –NoPreserve parameter with my function. If you use it all existing permissions will be wiped out</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PATH__Test-Path__Split-Path__Join-Path</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PATH__Test-Path__Split-Path__Join-Path</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'PATH__Test-Path__Split-Path__Join-Path



'Resolve-Path
================
'Resolve-Path will give you the full path to a location. 
'The important thing is that it will expand wildcard lookups for you. 
'You will get an array of values if there are more than one matche.

Resolve-Path -Path 'c:\users\*\documents'

'OUTPUT
---------
Path
----
C:\users\kevin.marquette\Documents
C:\users\Public\Documents
That will enumerate all the local users document folders.





'Test-Path
==========
If( Test-Path -Path $Path )
{
    Do-Stuff -Path $Path
}


'Split-Path
==========
'Split-Path will take a full path to a file and gives you the parent folder path.

PS:&gt; Split-Path -Path 'c:\users\kevin.marquette\documents'
'OUTPUT
---------
c:\users\kevin.marquette


'If you need the file or folder at the end of the path, you can use the -Leaf argument to get it.

PS:&gt; Split-Path -Path 'c:\users\kevin.marquette\documents' -Leaf
'OUTPUT
---------
documents


'Join-Path
==========
'Join-Path can join folder and file paths together.
'You don’t have to worry about how to handle the backslash becuse this takes care of it for you. 
'If your variables both have backslashes in them, it sorts that out too.


PS:&gt; Join-Path -Path $env:temp -ChildPath testing
'OUTPUT
---------
C:\Users\kevin.marquete\AppData\Local\Temp\testing

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Permissions_Set</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Permissions_Set</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
===================================================================================================
https://blogs.msdn.microsoft.com/johan/2008/10/01/powershell-editing-permissions-on-a-file-or-folder/

$thePath = '\\win10vm\ALL_Share\win7_to_Win10\'

#' 1] Copy the folder 'StartLayout' to C:\ 

$fromPath_StartLayout = $thePath + 'StartLayout'
$toPath_StartLayout = "C:\StartLayout"
Copy-Item $fromPath_StartLayout -Destination C:\ -Recurse

#' 2] Set permissions on the folder to allow Domain Users READ 

$Acl = Get-Acl $toPath_StartLayout
$Ar = New-Object  system.security.accesscontrol.filesystemaccessrule("Domain Users","Modify","Allow")
$Acl.SetAccessRule($Ar)
Set-Acl $toPath_StartLayout $Acl

---------------------------------------------------------------------------------------------------
'if you want Folder_A to have the exact same permissions as Folder_B, 
'then you simply copy the Access Control List (ACL) of Folder_B and "paste" it onto Folder_A.

$Acl = Get-Acl "C:\Folder_B"
Set-Acl "C:\Folder_A" $Acl


===================================================================================================
https://stackoverflow.com/questions/26543127/powershell-setting-advanced-ntfs-permissions

'Now, if you want to assign multiple access rights to a given trustee, you can either do that with individual ACEs:

$acl  = Get-Acl $path
$ace1 = New-Object Security.AccessControl.FileSystemAccessRule 'DOMAIN\user',
        'ListDirectory', 'ContainerInherit, ObjectInherit', 'InheritOnly',
        'Allow'
$acl.AddAccessRule($ace1)
$ace2 = New-Object Security.AccessControl.FileSystemAccessRule 'DOMAIN\user',
        'ReadAttributes', 'ContainerInherit, ObjectInherit', 'InheritOnly',
        'Allow'
$acl.AddAccessRule($ace2)

'Or by providing the permissions as a comma-separated string:

$acl = Get-Acl $path
$ace = New-Object Security.AccessControl.FileSystemAccessRule 'DOMAIN\user',
       'ListDirectory, ReadAttributes, ...', 'ContainerInherit,  ObjectInherit',
       'InheritOnly', 'Allow'
$acl.AddAccessRule($ace)
============================================================================================
https://stackoverflow.com/questions/3282656/setting-inheritance-and-propagation-flags-with-set-acl-and-powershell
# Get the ACL for an existing folder
$existingAcl = Get-Acl -Path 'C:\DemoFolder'

# Set the permissions that you want to apply to the folder
$permissions = $env:username, 'Read,Modify', 'ContainerInherit,ObjectInherit', 'None', 'Allow'

# Create a new FileSystemAccessRule object
$rule = New-Object -TypeName System.Security.AccessControl.FileSystemAccessRule -ArgumentList $permissions

# Modify the existing ACL to include the new rule
$existingAcl.SetAccessRule($rule)

# Apply the modified access rule to the folder
$existingAcl | Set-Acl -Path 'C:\DemoFolder'

'Each of the values in the $permissions variable list pertain to the parameters of this constructor for the FileSystemAccessRule class.
https://docs.microsoft.com/en-us/dotnet/api/system.security.accesscontrol.filesystemaccessrule.-ctor?redirectedfrom=MSDN&amp;view=netframework-4.7.2#System_Security_AccessControl_FileSystemAccessRule__ctor_System_String_System_Security_AccessControl_FileSystemRights_System_Security_AccessControl_InheritanceFlags_System_Security_AccessControl_PropagationFlags_System_Security_AccessControl_AccessControlType_</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions_String</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Comparing_Strings</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions_String</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Comparing_Strings</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'In general, you can work with the same comparison operators as for numerical values to determine differences between strings. 
'Primarily, this includes -eq and -ne, as well as -like, which supports wildcards.

'String objects also offer methods for this purpose. 
'If the first string is “bigger” than the second string (that is, 
'if it comes first in the sort order), the cmdlet returns 1; 
'if the first string is smaller, the result is ‑1.


("Hello world").CompareTo("Hello" + " " + "world")

'In the above example, CompareTo returns 0 because the strings are identical. In contrast, the comparable call with Equals returns True:

("Hello world").Equals("Hello" + " " + "world")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Advanced_Functions_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Advanced_Functions_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># Advanced functions also allow parameters with extra helping hints
function Get-AValue ()
{
  [CmdletBinding()]                       # &lt;===== Needed to indicate this is an advanced function
  param (                                 # &lt;=====  Begin the parameter block

         [Parameter( Mandatory = $true,
                     HelpMessage = 'Please enter value one.'
                     )]
         [int] $one,                      # &lt;===== Strong typing is optional

         
         [Parameter( Mandatory = $false,
                     HelpMessage = 'Please enter value two.'
                     )]
         [int] $two = 42                  # &lt;===== Since this is optional, you can provide a default value

        )  # End the parameter block

  begin { }

  process { 
            return $one * $two
          }

  end { }

}

# Example 1 pass in values
Get-AValue -one 33 -two 42

# Example 2 pass in value for one, take default for two
Get-AValue -one 33 

# Example 3 no params, will prompt for one and take default for two
Get-AValue 

# Example 4, use a string for one (generates error)
Get-AValue -one "x"

#endregion Functions

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PARAMETER_validation_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PARAMETER_validation_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>PARAMETER_validation_examples


function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateCount(1, 5)]
		[string[]]$Name,			'&lt;=== This is asking for a collection of strings
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateRange(1, 5)]
		[int]$Count = 1,
		
		[Parameter()]
		[ValidateNotNull()]
		[ValidateRange(512MB, 1024MB)]
		[int]$MemoryStartupBytes,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('1', '2')]
		[int]$Generation = 2,
		
		[Parameter()]
		[ValidateScript({
			if (Test-Connection -ComputerName $_ -Quiet -Count 1)
			{
				throw "The computer [$_] is offline. Try another"
			}
			else
			{
				$true
			}
		})]
		[ValidatePattern('^C:\\')]
		[string]$Path = 'C:\somebogusfolder',
		
		[Parameter()]
		[AllowNull()]
		[string]$OperatingSystem,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[string]$NullParamTest,
		
		[Parameter()]
		[AllowNull()]
		[string]$AllowNullParam
	)
}

'When you run this the (Mandatory) declaration will cause it to challenge you for the Parm, if it is not supplied
New-VirtualMachine
'It would responde by challenging you for the name:    &gt;Name[0]:

New-VirtualMachine -Name 'MYNEWVM'
'In this case it would just take the name

#region Get-Help to find Mandatory parameters in cmdlets

## Using help optional parmameters and their values are shown in brackets
==========================================================================

## No mandatory params
(Get-Help -Name Get-Service -Detailed).syntax			'&lt;=== This requests help on the syntax

## Only Path is mandatory
(Get-Help -Name Get-Content -Detailed).syntax

#endregion

#region Get-Command to find Mandatory parameters in cmdlets

(Get-Command -Name 'Get-Content').Parameters.Path.Attributes

#endregion</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_HASH_table</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>splatting</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_HASH_table</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>splatting</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'Define a hashtable of parameter names and values
#' NOTE USE: $ for variable  &lt;====
$cimParams = @{
    Classname   = "Win32_LogicalDisk"
    Filter      = "drivetype = 3" 
    ErrorAction = "Stop"
    
 #'USAGE
 #' NOTE USE: @ for variable  &lt;====
 $disks = Get-CimInstance @cimparams</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Help</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>example</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Help</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>example</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'You do not have to use all-uppercase letters, but the period preceding each help keyword 
'	(.SYNOPSIS, .DESCRIPTION) must be in the first column. 
 



# completed...
function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Write-Verbose "Connecting to $computer over $protocol"
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option
  
        Write-Verbose "Querying from $computer"
        $os_params = @{'ClassName'='Win32_OperatingSystem'
                       'CimSession'=$session}
        $os = Get-CimInstance @os_params

        $cs_params = @{'ClassName'='Win32_ComputerSystem'
                       'CimSession'=$session}
        $cs = Get-CimInstance @cs_params

        $sysdrive = $os.SystemDrive
        $drive_params = @{'ClassName'='Win32_LogicalDisk'
                          'Filter'="DeviceId='$sysdrive'"
                          'CimSession'=$session}
        $drive = Get-CimInstance @drive_params

        $proc_params = @{'ClassName'='Win32_Processor'
                         'CimSession'=$session}
        $proc = Get-CimInstance @proc_params |
                Select-Object -first 1

  
        Write-Verbose "Closing session to $computer"
        $session | Remove-CimSession
  
        Write-Verbose "Outputting for $computer"
        $obj = [pscustomobject]@{'ComputerName'=$computer
                   'OSVersion'=$os.version
                   'SPVersion'=$os.servicepackmajorversion
                   'OSBuild'=$os.buildnumber
                   'Manufacturer'=$cs.manufacturer
                   'Model'=$cs.model
                   'Procs'=$cs.numberofprocessors
                   'Cores'=$cs.numberoflogicalprocessors
                   'RAM'=($cs.totalphysicalmemory / 1GB)
                   'Arch'=$proc.addresswidth
                   'SysDriveFreeSpace'=$drive.freespace}
        Write-Output $obj
 
    } #foreach
} #PROCESS

END {}

} #function



# prettier...
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.

.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.

.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.

.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.

.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.

.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.

.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.

.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;



# more sections...
&lt;#
.INPUTS
System.String

.NOTES
version     : 1.0.0
last updated: 1 February, 2017

.LINK
https://powershell.org/forums/
.LINK
Get-CimInstance
.LINK
Get-WmiObject

#&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Input</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Import-Clixml</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Input</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Import-Clixml</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'The Export-CliXml command is used to save full objects to a file
'	 and then import them again with Import-CliXml. 
'This is for objects with nested values or complex datatypes. 
'The raw data will be a verbose serialized object in XML.
'The nice thing is that you can save a an object to the file and when you import it, 
' 	you will get that object back.

Get-Date | Export-Clixml date.clicml
$date = Import-Clixml .\date.clicml
$date.GetType()
'OUTPUT
=======================
IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     DateTime                                 System.ValueType

'This serialized format is not intened for be viewd or edited directly. 
'Here is what the date.clixml file looks like:

&lt;Objs Version="1.1.0.1" xmlns="http://schemas.microsoft.com/powershell/2004/04"&gt;
    &lt;Obj RefId="0"&gt;
        &lt;DT&gt;2017-03-17T00:00:00.3522798-07:00&lt;/DT&gt;
        &lt;MS&gt;
            &lt;Obj N="DisplayHint" RefId="1"&gt;
                &lt;TN RefId="0"&gt;
                    &lt;T&gt;Microsoft.PowerShell.Commands.DisplayHintType&lt;/T&gt;
                    &lt;T&gt;System.Enum&lt;/T&gt;
                    &lt;T&gt;System.ValueType&lt;/T&gt;
                    &lt;T&gt;System.Object&lt;/T&gt;
                &lt;/TN&gt;
                &lt;ToString&gt;DateTime&lt;/ToString&gt;
                &lt;I32&gt;2&lt;/I32&gt;
            &lt;/Obj&gt;
        &lt;/MS&gt;
    &lt;/Obj&gt;
&lt;/Objs&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Logging__forSecurity</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>enable_Auditing_and_Logging</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Logging__forSecurity</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>enable_Auditing_and_Logging</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>enable_Auditing_and_Logging

Practical PowerShell Security: Enable Auditing and Logging with DSC
https://blogs.technet.microsoft.com/ashleymcglone/2017/03/29/practical-powershell-security-enable-auditing-and-logging-with-dsc/

#'Requirements
#'    We are assuming that the target system already has WMF 5.x installed or upgraded. Each of these enhancement will require the following settings:
#'
#'    Script block logging
#'        HKLM:\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
#'            EnableScriptBlockLogging, 1
#'            EnableScriptBlockInvocationLogging, 1
#'        It may also be a good idea to increase the log size. The Microsoft-Windows-PowerShell/Operational log is 15MB by default.
#'    System-wide transcription
#'        Create a directory to hold transcripts
#'            Set permissions on the directory to prevent tampering. (I chose SDDL for the shortest code here.)
#'            Trim the transcript directory contents on an interval to avoid filling the drive (if local).
#'            We are going to use a local directory for now. Lee recommends pointing it to a share off-box.
#'        HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription
#'            EnableTranscripting, 1
#'            IncludeInvocationHeader,1
#'            OutputDirectory, [Path]
#'    Protected event logging (can be used together with Windows Event Forwarding)
#'        Requires Windows 10 or Windows Server 2016
#'        Requires a document encryption certificate
#'        HKLM:\Software\Policies\Microsoft\Windows\EventLog\ProtectedEventLogging
#'            EnableProtectedEventLogging, 1
#'            EncryptionCertificate, [Certificate]

Now that we have an outline of the settings required, we can move those into a DSC configuration. 
You can view the code on my GitHub account here: https://github.com/GoateePFE/BlogScripts/blob/master/PSSecDSC.ps1

That script does this:
#'Script Block Logging
#'    Two registry resources set the values.
#'    Then for good measure we use a script resource to increase the size of the PowerShell event log.
#'Transcription
#'    Three registry resources set the values.
#'    We need a file resource to create the directory to hold the transcript files.
#'    Then two script resources set the permissions on the directory and remove any old files. We probably could have used an external resource to set the directory permissions, but I want to keep this using in-box resources for simplicity. Keeping the transcript directory clean requires that you set the DSC Local Configuration Manager (LCM) to ApplyAndAutocorrect.
#'    NOTE: Remove the file and script resources if you send the transcripts to a remote UNC share path.
#'    NOTE: If you use a local path, have fun trying to read the transcript files. Also, the trim files script resource will likely generate warnings trying to clear old files.
#'Protected Event Logging
#'    I’m going to skip this one due to a couple reasons:
#'    Right now we do not have a way to request a certificate in a configuration, and then pass that data to another resource in the same configuration. Writing a custom resource for that wouldn’t be practical, because I’m trying to keep this to in-box DSC resources for now.
#'    Most customers already have an event collection tool (SIEM). If not, then explore the xWindowsEventForwarding resource module.
#'Fit and Finish
#'    Notice that the configuration has the following parameters:
#'    TranscriptPath – Directory where you want to put the transcript files. Can be local or UNC path.
#'    TranscriptDays – How many days of transcripts do you wish to retain?
#'    EventLogSizeInMB – Size to set for the PowerShell log to hold the additional content generated.
#'BONUS
#'    For completeness I threw in a configuration to disable the transcription and logging.
#'    I also threw in a couple lines to query the event logs for your new events.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Logging__forSecurity</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PSSecDSC.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Logging__forSecurity</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PSSecDSC.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://github.com/GoateePFE/BlogScripts/blob/master/PSSecDSC.ps1

That script does this:
#'Script Block Logging
#'    Two registry resources set the values.
#'    Then for good measure we use a script resource to increase the size of the PowerShell event log.
#'Transcription
#'    Three registry resources set the values.
#'    We need a file resource to create the directory to hold the transcript files.
#'    Then two script resources set the permissions on the directory and remove any old files. We probably could have used an external resource to set the directory permissions, but I want to keep this using in-box resources for simplicity. Keeping the transcript directory clean requires that you set the DSC Local Configuration Manager (LCM) to ApplyAndAutocorrect.
#'    NOTE: Remove the file and script resources if you send the transcripts to a remote UNC share path.
#'    NOTE: If you use a local path, have fun trying to read the transcript files. Also, the trim files script resource will likely generate warnings trying to clear old files.
#'Protected Event Logging
#'    I’m going to skip this one due to a couple reasons:
#'    Right now we do not have a way to request a certificate in a configuration, and then pass that data to another resource in the same configuration. Writing a custom resource for that wouldn’t be practical, because I’m trying to keep this to in-box DSC resources for now.
#'    Most customers already have an event collection tool (SIEM). If not, then explore the xWindowsEventForwarding resource module.
#'Fit and Finish
#'    Notice that the configuration has the following parameters:
#'    TranscriptPath – Directory where you want to put the transcript files. Can be local or UNC path.
#'    TranscriptDays – How many days of transcripts do you wish to retain?
#'    EventLogSizeInMB – Size to set for the PowerShell log to hold the additional content generated.
#'BONUS
#'    For completeness I threw in a configuration to disable the transcription and logging.
#'    I also threw in a couple lines to query the event logs for your new events.

==================================================================
&lt;##############################################################################
Ashley McGlone
Microsoft Premier Field Engineer
March 2017
http://aka.ms/GoateePFE
This is a sample DSC script for implementing the PowerShell logging and
transcription features described in Lee Holmes' white paper "PowerShell Loves the Blue Team".
https://blogs.msdn.microsoft.com/powershell/2015/06/09/powershell-the-blue-team
For reference, here are the registry keys involved:
HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription
EnableTranscripting,1
OutputDirectory,[Path]
IncludeInvocationHeader,1
HKLM:\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
EnableScriptBlockLogging,1
EnableScriptBlockInvocationLogging,1
(not implemented below)
HKLM:\Software\Policies\Microsoft\Windows\EventLog\ProtectedEventLogging
EnableProtectedEventLogging,1
EncryptionCertificate,[Certificate]
LEGAL DISCLAIMER
This Sample Code is provided for the purpose of illustration only and is not
intended to be used in a production environment.  THIS SAMPLE CODE AND ANY
RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.  We grant You a
nonexclusive, royalty-free right to use and modify the Sample Code and to
reproduce and distribute the object code form of the Sample Code, provided
that You agree: (i) to not use Our name, logo, or trademarks to market Your
software product in which the Sample Code is embedded; (ii) to include a valid
copyright notice on Your software product in which the Sample Code is embedded;
and (iii) to indemnify, hold harmless, and defend Us and Our suppliers from and
against any claims or lawsuits, including attorneys’ fees, that arise or result
from the use or distribution of the Sample Code.
##########################################################################sdg#&gt;

Configuration EnablePowerShellLogging
{
Param(
    [string]
    $TranscriptPath = 'C:\PSTranscripts',
    [ValidateRange(1,365)]
    [int]
    $TranscriptDays = 14,
    [ValidateRange(1,1024)]
    [int]
    $EventLogSizeInMB = 50
)

    Import-DscResource -ModuleName PSDesiredStateConfiguration

    Node localhost
    {

        ### Script Block Logging ##############################################

        Registry ScriptBlockLogging
        {
            Key       = 'HKLM:\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging'
            ValueName = 'EnableScriptBlockLogging'
            ValueData = 1
            ValueType = 'String'
            Ensure    = 'Present'
        }

        # Enable this setting to log start / stop events. Not usually recommended, as it causes
        # a significant impact on log volume
        &lt;#
        Registry ScriptBlockInvocationLogging
        {
            Key       = 'HKLM:\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging'
            ValueName = 'EnableScriptBlockInvocationLogging'
            ValueData = 1
            ValueType = 'String'
            Ensure    = 'Present'
        }
        #&gt;

        Script PowerShellLogSize
        {
            GetScript = {
                Return @{
                    Result = Get-WinEvent -ListLog Microsoft-Windows-PowerShell/Operational | Out-String
                }
            }
            TestScript = {
                $Log = Get-WinEvent -ListLog Microsoft-Windows-PowerShell/Operational
                If ($Log.LogMode -ne 'Circular' -or $Log.MaximumSizeInBytes -lt ($using:EventLogSizeInMB * 1MB)) {
                    Write-Verbose 'Event log [Microsoft-Windows-PowerShell/Operational] is NOT in desired state.'
                    Return $false
                } Else {   
                    Write-Verbose 'Event log [Microsoft-Windows-PowerShell/Operational] is in desired state.'
                    Return $true
                }
            }
            SetScript = {
                Write-Verbose 'Applying settings to event log [Microsoft-Windows-PowerShell/Operational].'
                wevtutil set-log Microsoft-Windows-PowerShell/Operational /retention:false /maxsize:$($using:EventLogSizeInMB * 1MB)
            }
        }

        ### Transcription #####################################################

        ### Remove this resource if sending transcripts to a remote share.
        File TranscriptsDirectory
        {
            DestinationPath = $TranscriptPath
            Type            = 'Directory'
            Ensure          = 'Present'
        }

        ### Remove this resource if sending transcripts to a remote share.
        Script TranscriptsDirectoryPermissions
        {
            GetScript = {
                $acl = Get-Acl $using:TranscriptPath
                Return @{
                    Result = $acl.Sddl
                }
            }
            TestScript = {
                $acl = Get-Acl $using:TranscriptPath
                Write-Verbose "Transcript directory permissions: $($acl.Sddl)"
                If ($acl.Sddl -ne 'O:BAG:DUD:PAI(D;OICIIO;FA;;;CO)(A;OICI;0x100196;;;WD)(A;OICI;FA;;;BA)') {
                    Write-Verbose 'Transcript directory permissions are NOT in desired state.'
                    Return $false
                } Else {   
                    Write-Verbose 'Transcript directory permissions are in desired state.'
                    Return $true
                }
            }
            SetScript = {
                Write-Verbose 'Applying transcript directory permissions.'
                # Remove inherited permissions.
                # Allow Administrators full control.
                # Allow Everyone Write and ReadAttributes.
                # Deny CreatorOwner Full Control.
                $acl = Get-Acl $using:TranscriptPath
                $acl.SetSecurityDescriptorSddlForm('O:BAG:DUD:PAI(D;OICIIO;FA;;;CO)(A;OICI;0x100196;;;WD)(A;OICI;FA;;;BA)')
                $acl | Set-Acl $using:TranscriptPath -Verbose
            }
            DependsOn = '[File]TranscriptsDirectory'
        }

        ### Remove this resource if sending transcripts to a remote share.
        ### NOTE: This will generate errors due to permissions of the local transcript directory.
        Script TranscriptsDirectoryTrim
        {
            GetScript = {
                Return @{
                    Result = $using:TranscriptPath
                }
            }
            TestScript = {
                $ErrorActionPreference = 'Stop'
                Try {
                    $OldContent = Get-ChildItem $using:TranscriptPath -Recurse | Where-Object {$_.LastWriteTime -lt (Get-Date).AddDays($using:TranscriptDays * -1)}
                }
                Catch {
                    Write-Warning 'Access denied to some of the transcript files.'
                }
                If ($OldContent) {
                    Write-Verbose "Transcript directory contains content older than $($using:TranscriptDays) days."
                    Return $false
                } Else {   
                    Write-Verbose "Transcript directory DOES NOT contain content older than $($using:TranscriptDays) days."
                    Return $true
                }
            }
            SetScript = {
                $ErrorActionPreference = 'Stop'
                Try {
                    Get-ChildItem $using:TranscriptPath -Recurse | Where-Object {$_.LastWriteTime -lt (Get-Date).AddDays($using:TranscriptDays * -1)} | Remove-Item -Force -Confirm:$false -Verbose
                }
                Catch {
                    Write-Warning 'Access denied to some of the transcript files.'
                }
            }
            DependsOn = '[File]TranscriptsDirectory'
        }

        Registry Transcription
        {
            Key       = 'HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription'
            ValueName = 'EnableTranscripting'
            ValueData = 1
            ValueType = 'String'
            Ensure    = 'Present'
        }

        # Remove this setting to descrease transcript file size
        Registry TranscriptionInvocationHeader
        {
            Key       = 'HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription'
            ValueName = 'IncludeInvocationHeader'
            ValueData = 1
            ValueType = 'String'
            Ensure    = 'Present'
        }

        Registry TranscriptionPath
        {
            Key       = 'HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription'
            ValueName = 'OutputDirectory'
            ValueData = $TranscriptPath
            ValueType = 'String'
            Ensure    = 'Present'
        }

    }

}

cd c:\temp
EnablePowerShellLogging
Start-DscConfiguration -Path C:\temp\EnablePowerShellLogging -Wait -Verbose -Force

###############################################################################
break

Get-DscConfiguration

dir 'HKLM:\Software\Policies\Microsoft\Windows\PowerShell' -Recurse

###############################################################################
break

Configuration DisablePowerShellLogging
{
Param(
    $Paths = @('HKLM:\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging',`
    'HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription')
)

    Import-DscResource -ModuleName PSDesiredStateConfiguration

    Node localhost
    {
        # Currently the registry resource does not support deleting an entire
        # key. So we will delete each key with a script resource.
        Script RemovePowerShellLogging
        {
            GetScript = {
                Return @{
                    Result = Get-Item -Path $Using:Paths -ErrorAction SilentlyContinue | Out-String
                }
            }
            TestScript = {
                If (Get-Item -Path $Using:Paths -ErrorAction SilentlyContinue) {
                    Write-Verbose "Registry keys for PowerShell logging and/or transcription found."
                    Return $false
                } Else {   
                    Write-Verbose "Registry keys for PowerShell logging and/or transcription NOT found."
                    Return $true
                }
            }
            SetScript = {
                Get-Item -Path $Using:Paths |
                    Remove-Item -Force -Confirm:$false -Verbose
            }
        }

    }

}

cd c:\temp
DisablePowerShellLogging
Start-DscConfiguration -Path C:\temp\DisablePowerShellLogging -Wait -Verbose -Force

break

dir 'HKLM:\Software\Policies\Microsoft\Windows\PowerShell' -Recurse

###############################################################################
break

# Note that the PowerShell policy is cached when the ISE or Console is opened.
# Run these commands in a fresh session to see the effect.
"Catch me if you can"

# Commands run, notice the scriptblock ID
Get-WinEvent -FilterHashtable @{ ProviderName="Microsoft-Windows-PowerShell"; Id = 4104 } -MaxEvents 5 | ft Message -Wrap
Get-WinEvent -FilterHashtable @{ ProviderName="Microsoft-Windows-PowerShell"; Id = 4104 } -MaxEvents 5 | ? Message -like "*catch*" | ft Message -Wrap

# Commands started, notice the scriptblock ID
Get-WinEvent -FilterHashtable @{ ProviderName="Microsoft-Windows-PowerShell"; Id = 4105 } -MaxEvents 5 | ft TimeCreated,Message -Wrap

# Commands stopped, notice the scriptblock ID
Get-WinEvent -FilterHashtable @{ ProviderName="Microsoft-Windows-PowerShell"; Id = 4106 } -MaxEvents 5 | ft TimeCreated,Message -Wrap

# View the transcript output
# NOTE: Access denied if on a local path instead of UNC path
Get-ChildItem 'C:\PSTranscripts' -Recurse</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_LogParser</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_LogParser</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_LogParser

http://logparserplus.com

HELP:  &gt;logparser.exe /h


As a quick reminder, Log Parser supports the following built-in input formats:

IIS Log File Input Formats
=========================
IISW3C: parses IIS log files in the W3C Extended Log File Format.
	This works with 'iCheckpoint'
	NOTE: -w3c did not work with 'iCheckpoint'
	https://www.microsoft.com/technet/prodtechnol/WindowsServer2003/Library/IIS/676400bc-8969-4aa7-851a-9319490a9bbb.mspx?mfr=true	
	http://words.strivinglife.com/post/A-brief-overview-of-IIS-60-and-the-W3C-extended-log-format/
	
IIS: parses IIS log files in the Microsoft IIS Log File Format.
	https://www.microsoft.com/technet/prodtechnol/WindowsServer2003/Library/IIS/be22e074-72f8-46da-bb7e-e27877c85bca.mspx?mfr=true
	
BIN: parses IIS log files in the Centralized Binary Log File Format.
IISODBC: returns database records from the tables logged to by IIS when configured to log in the ODBC Log Format.
HTTPERR: parses HTTP error log files generated by Http.sys.
URLSCAN: parses log files generated by the URLScan IIS filter.

Generic Text File Input Formats
=========================
CSV: parses comma-separated values text files.
TSV: parses tab-separated and space-separated values text files.
XML: parses XML text files.
W3C: parses text files in the W3C Extended Log File Format.
NCSA: parses web server log files in the NCSA Common, Combined, and Extended Log File Formats.
TEXTLINE: returns lines from generic text files.
TEXTWORD: returns words from generic text files.

System Information Input Formats
=========================
EVT: returns events from the Windows Event Log and from Event Log backup files (.evt files).
FS: returns information on files and directories.
REG: returns information on registry values.
ADS: returns information on Active Directory objects.

Special-purpose Input Formats
=========================
NETMON: parses network capture files created by NetMon.
ETW: parses Enterprise Tracing for Windows trace log files and live sessions.
COM: provides an interface to Custom Input Format COM plug-ins.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>functions_for_LogParser_statements_Examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>functions_for_LogParser_statements_Examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

aliases
===========
#'In the following command, 
#'	I’ve assigned the TypeEvent alias to the EventTypeName field, 
#'	the DateGenerated alias to the TimeGenerated field, 
#'	and the SecurityID alias to the SID field:
#'You can use the alias anywhere in the query after the point it has been assigned. 
#'If the alias includes spaces or special characters, as in Customer's Address, 
#'    you should enclose it in brackets, just like you do with column names. 


&gt;logparser -i:evt -resolveSIDs:on -o:nat -rtp:20 "select  extract_token(EventTypeName, 0, ' '), to_date(TimeGenerated), SID into stdout from system"


extract_token
============ 
#'lets you extract a substring from a value. 
#'The function takes three arguments. 
#'The first is the original value, in this case, the EventTypeName field. 
#'The second argument is a 0-based index that indicates what part of the value to return. 
#'	If 0 is specified, 
#'		the function starts at the beginning of the value and returns all data up to the character specified in the third argument, in this case, a single space. 
#'		For instance, the function as it is used in the example above will return word Information from the value Information event.
#'
&gt;logparser -i:evt -resolveSIDs:on -o:nat -rtp:20 "select  extract_token(EventTypeName, 0, ' '), to_date(TimeGenerated), SID into stdout from system"

to_date  
========
#'returns only the date portion of a Timestamp value. 
#'Because I use the function on the TimeGenerated field, 
#'	the query will return only the dates from that field’s values, 
#'	rather then the date and time. 
#'the EventTypeName field returns only a single word and the TimeGenerated field returns only the date.

&gt;logparser -i:evt -resolveSIDs:on -o:nat -rtp:20 "select  extract_token(EventTypeName, 0, ' '), to_date(TimeGenerated), SID into stdout from system"
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>help</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>help</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Microsoft (R) Log Parser Version 2.2.10
Copyright (C) 2004 Microsoft Corporation. All rights reserved.

Usage:   LogParser [-i:&lt;input_format&gt;] [-o:&lt;output_format&gt;] &lt;SQL query&gt; |
                   file:&lt;query_filename&gt;[?param1=value1+...]
                   [&lt;input_format_options&gt;] [&lt;output_format_options&gt;]
                   [-q[:ON|OFF]] [-e:&lt;max_errors&gt;] [-iw[:ON|OFF]]
                   [-stats[:ON|OFF]] [-saveDefaults] [-queryInfo]

         LogParser -c -i:&lt;input_format&gt; -o:&lt;output_format&gt; &lt;from_entity&gt;
                   &lt;into_entity&gt; [&lt;where_clause&gt;] [&lt;input_format_options&gt;]
                   [&lt;output_format_options&gt;] [-multiSite[:ON|OFF]]
                   [-q[:ON|OFF]] [-e:&lt;max_errors&gt;] [-iw[:ON|OFF]]
                   [-stats[:ON|OFF]] [-queryInfo]

 -i:&lt;input_format&gt;   :  one of IISW3C, NCSA, IIS, IISODBC, BIN, IISMSID,
                        HTTPERR, URLSCAN, CSV, TSV, W3C, XML, EVT, ETW,
                        NETMON, REG, ADS, TEXTLINE, TEXTWORD, FS, COM (if
                        omitted, will guess from the FROM clause)
 -o:&lt;output_format&gt;  :  one of CSV, TSV, XML, DATAGRID, CHART, SYSLOG,
                        NEUROVIEW, NAT, W3C, IIS, SQL, TPL, NULL (if omitted,
                        will guess from the INTO clause)
 -q[:ON|OFF]         :  quiet mode; default is OFF
 -e:&lt;max_errors&gt;     :  max # of parse errors before aborting; default is -1
                        (ignore all)
 -iw[:ON|OFF]        :  ignore warnings; default is OFF
 -stats[:ON|OFF]     :  display statistics after executing query; default is
                        ON
 -c                  :  use built-in conversion query
 -multiSite[:ON|OFF] :  send BIN conversion output to multiple files
                        depending on the SiteID value; default is OFF
 -saveDefaults       :  save specified options as default values
 -restoreDefaults    :  restore factory defaults
 -queryInfo          :  display query processing information (does not
                        execute the query)


Examples:
 LogParser "SELECT date, REVERSEDNS(c-ip) AS Client, COUNT(*) FROM file.log
            WHERE sc-status&lt;&gt;200 GROUP BY date, Client" -e:10
 LogParser file:myQuery.sql?myInput=C:\temp\ex*.log+myOutput=results.csv
 LogParser -c -i:BIN -o:W3C file1.log file2.log "ComputerName IS NOT NULL"

Help:
 -h GRAMMAR                  : SQL Language Grammar
 -h FUNCTIONS [ &lt;function&gt; ] : Functions Syntax
 -h EXAMPLES                 : Example queries and commands
 -h -i:&lt;input_format&gt;        : Help on &lt;input_format&gt;
 -h -o:&lt;output_format&gt;       : Help on &lt;output_format&gt;
 -h -c                       : Conversion help</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogParser_Expressions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogParser_Expressions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ALL
&lt;field_expr&gt; &lt;rel_op&gt; ALL ( &lt;value_rows&gt; ) | ( &lt;field_expr_list&gt; ) &lt;rel_op&gt; ALL ( &lt;value_rows&gt; )
The ALL operator compares a given field-expression with a list of values, returning TRUE if all values in the list satisfy the comparison operation, or FALSE if not all values satisfy the comparison.
ANY
&lt;field_expr&gt; &lt;rel_op&gt; ANY ( &lt;value_rows&gt; ) | ( &lt;field_expr_list&gt; ) &lt;rel_op&gt; ANY ( &lt;value_rows&gt; )
The ANY operator compares a given field-expression with a list of values, returning TRUE if any value in the list satisfies the comparison operation, or FALSE if no values satisfy the comparison.
BETWEEN
&lt;field_expr&gt; [ NOT ] BETWEEN &lt;field_expr&gt; AND &lt;field_expr&gt;
The BETWEEN operator determines if a given field-expression belongs to a specified interval.
sc-status BETWEEN 400 AND 499
Returns requests with a status code from 400 to 499, inclusive.
IN
&lt;field_expr&gt; [ NOT ] IN ( &lt;value_rows&gt; ) | ( &lt;field_expr_list&gt; ) [ NOT ] IN ( &lt;value_rows&gt; )
The IN and NOT IN operators determine whether or not a given field-expression or list of field-expressions matches any element in a list of values.
EXTRACT_EXTENSION(cs-uri-stem) NOT IN ('jpg';'png';'gif';'ico')
When used in a WHERE clause, excludes requests for common image formats.
See Removing potential bots from query results for an example using a nested query.
LIKE
&lt;field_expr&gt; [ NOT ] LIKE &lt;like_mask&gt;
Determines whether or not a given character string matches a specified pattern. A pattern can include regular characters and wildcard characters. During pattern matching, regular characters must yield a case-insensitive match with the characters specified in the character string. Wildcard characters, however, can be matched with arbitrary fragments of the character string. Using wildcard characters makes the LIKE operator more flexible than using the = and != string comparison operators. _ (underscore) matches any single character, while % (percent) matches any string of zero or more characters.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogParser_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogParser_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://logparserplus.com/Functions#function_TRIM

Function listing


ADD
ADD( addend1 &lt;any type&gt;, addend2 &lt;any type&gt; )
Calculates the sum of two values. Returns a value of the same type as its arguments.
Type: arithmetical

See also: SUB DIV MUL
AVG
AVG( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the average among all the values, or only the DISTINCT values, of the specified field-expression.
Type: aggregate

BIT_AND
BIT_AND( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Calculates the bitwise AND of two values.
Type: arithmetical

See also: BIT_NOT BIT_OR BIT_SHL BIT_SHR BIT_XOR
BIT_NOT
BIT_NOT( arg &lt;INTEGER&gt; )
Calculates the bitwise NOT of a value.
Type: arithmetical

See also: BIT_AND BIT_OR BIT_SHL BIT_SHR BIT_XOR
BIT_OR
BIT_OR( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Calculates the bitwise OR of two values.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_SHL BIT_SHR BIT_XOR
BIT_SHL
BIT_SHL( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Shifts a value left by a specified number of bits.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_OR BIT_SHR BIT_XOR
BIT_SHR
BIT_SHR( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Shifts a value right by a specified number of bits.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_OR BIT_SHL BIT_XOR
BIT_XOR
BIT_XOR( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Calculates the bitwise XOR of two values.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_OR BIT_SHL BIT_SHR
CASE
CASE &lt;field_expression&gt; WHEN &lt;field_expression&gt; THEN &lt;field_expression&gt; [ ... ] [ ELSE &lt;field_expression&gt; ] END
Compares the argument of the CASE statement with the arguments of the WHEN statements, returning the argument of a THEN statement when a match is found. If no match is found, returns the argument of the ELSE statement, or NULL if no ELSE statement is provided.
Type: miscellaneous

COALESCE
COALESCE( arg1 &lt;any type&gt;, arg2 &lt;any type&gt; [, ....] )
Returns the first non-NULL value among its arguments.
Type: miscellaneous

COMPUTER_NAME
COMPUTER_NAME()
Returns the NetBIOS name of the local computer.
Type: system information

COUNT
COUNT( [ DISTINCT | ALL ] * ) | ( [ DISTINCT | ALL ] &lt;field_expr_list&gt; )
Returns the number of items in a group.
Type: aggregate
COUNT(DISTINCT cs-uri-stem) AS [Distinct Requests]
Returns a count of how many distinct files were requested.
DIV
DIV( dividend &lt;INTEGER | REAL&gt;, divisor &lt;INTEGER | REAL&gt; )
Calculates the quotient of two values.
Type: arithmetical
DIV(sc-bytes, 1024) AS [KB Sent]
Converts bytes sent from the server to the client to Kilobytes (KB).
DIV(DIV(sc-bytes, 1024), 1024) AS [MB Sent]
Converts bytes sent from the server to the client to Megabytes (MB).
See also: MUL ADD SUB
EXP
EXP( argument &lt;INTEGER | REAL&gt; )
Calculates e (the Natural logarithm base) raised to the power of the specified argument.
Type: arithmetical

See also: EXP10
EXP10
EXP10( argument &lt;INTEGER | REAL&gt; )
Calculates 10 raised to the power of the specified argument.
Type: arithmetical

See also: EXP
EXTRACT_EXTENSION
EXTRACT_EXTENSION( filepath &lt;STRING&gt; )
Returns the file extension portion of a file path.
Type: string manipulation
EXTRACT_EXTENSION(cs-uri-stem) AS [File Extension]
Extracts the file extension for requests. Returns nothing for those without an extension.
EXTRACT_EXTENSION(cs-uri-stem) NOT IN ('jpg';'png';'gif';'ico')
When used in a WHERE clause, excludes requests for common image formats.
See also: EXTRACT_FILENAME EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_FILENAME
EXTRACT_FILENAME( filepath &lt;STRING&gt; )
Returns the filename portion of a file path.
Type: string manipulation
EXTRACT_FILENAME(cs-uri-stem) AS [File Requested]
Extracts the file name for requests.
See also: EXTRACT_EXTENSION EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_PATH
EXTRACT_PATH( filepath &lt;STRING&gt; )
Returns the directory path portion of a file path.
Type: string manipulation
EXTRACT_PATH(cs-uri-stem) AS [Path Requested]
Extracts the path of a request. The trailing slash (/) is removed.
See also: EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_PREFIX
EXTRACT_PREFIX( argument &lt;STRING&gt;, index &lt;INTEGER&gt;, separator &lt;STRING&gt; )
Returns a substring beginning at the first character and up to, but not including, the specified instance of the separator.
Type: string manipulation

See also: EXTRACT_SUFFIX EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_SUFFIX
EXTRACT_SUFFIX( argument &lt;STRING&gt;, index &lt;INTEGER&gt;, separator &lt;STRING&gt; )
Returns a substring beginning after the specified instance of the separator and up to the end of the string.
Type: string manipulation

See also: EXTRACT_PREFIX EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_TOKEN
EXTRACT_TOKEN( argument &lt;STRING&gt;, index &lt;INTEGER&gt; [ , separator &lt;STRING&gt; ] )
Splits the string into substrings at each point where the separator occurs, and returns the substring with the specified index.
Type: string manipulation
EXTRACT_TOKEN(cs(Referer), 2, '/') AS [Referring Domain]
Returns full domain of the site referring traffic to this resource.
See also: EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_VALUE
EXTRACT_VALUE
EXTRACT_VALUE( argument &lt;STRING&gt;, key &lt;STRING&gt; [ , separator &lt;STRING&gt; ] )
Parses "key=value" pairs in the string, returning the value corresponding to the specified key.
Type: string manipulation

See also: EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN
FLOOR
FLOOR( argument &lt;REAL&gt; )
Returns the integral part of the specified argument.
Type: arithmetical

See also: ROUND QNTFLOOR_TO_DIGIT QNTROUND_TO_DIGIT
GROUPING
GROUPING( &lt;field_expr&gt; )
Returns a value of 1 when the row is added by the ROLLUP operator of the GROUP BY clause, or 0 when the row is not the result of ROLLUP. GROUPING is used to distinguish the NULL values returned by ROLLUP from standard NULL values. The NULL returned as the result of a ROLLUP operation is a special use of NULL. It acts as a value placeholder in the result set and means "all".
Type: aggregate

HASHMD5_FILE
HASHMD5_FILE( filePath &lt;STRING&gt; )
Calculates the MD5 hash of the content of a file and returns its hexadecimal representation.
Type: miscellaneous

HASHSEQ
HASHSEQ( value &lt;STRING&gt; )
Returns a unique, sequential integer for each distinct value of the argument.
Type: miscellaneous

HEX_TO_ASC
HEX_TO_ASC( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of a series of bytes into a string where the bytes belonging to the 0x20-0x7F range have been converted to ASCII characters.
Type: string manipulation

See also: HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_INT HEX_TO_PRINT
HEX_TO_HEX16
HEX_TO_HEX16( hexString &lt;STRING&gt; [ , bigEndian &lt;INTEGER&gt; ] )
Converts the hexadecimal representation of a series of bytes into another hexadecimal representation in which bytes are grouped into 16-bit WORDs.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_INT HEX_TO_PRINT
HEX_TO_HEX32
HEX_TO_HEX32( hexString &lt;STRING&gt; [ , bigEndian &lt;INTEGER&gt; ] )
Converts the hexadecimal representation of a series of bytes into another hexadecimal representation in which bytes are grouped into 32-bit DWORDs.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX8 HEX_TO_INT HEX_TO_PRINT
HEX_TO_HEX8
HEX_TO_HEX8( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of a series of bytes into another hexadecimal representation in which bytes are grouped into 8-bit octets.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_INT HEX_TO_PRINT
HEX_TO_INT
HEX_TO_INT( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of an integer into the integer itself.
Type: conversion

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_PRINT
HEX_TO_PRINT
HEX_TO_PRINT( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of a series of bytes into a string where the bytes corresponding to printable ASCII characters have been converted to the characters themselves.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_INT
IN_ROW_NUMBER
IN_ROW_NUMBER()
Returns the current input record number.
Type: miscellaneous

See also: OUT_ROW_NUMBER
INDEX_OF
INDEX_OF( string &lt;STRING&gt;, searchStr &lt;STRING&gt; )
Returns the character position where the first occurrence of a search substring occurs in a string.
Type: string manipulation

See also: LAST_INDEX_OF
INT_TO_IPV4
INT_TO_IPV4( ipV4Address &lt;INTEGER&gt; )
Converts a 32-bit integer into the string representation of an IPV4 address.
Type: conversion

See also: IPV4_TO_INT
IPV4_TO_INT
IPV4_TO_INT( ipV4Address &lt;STRING&gt; )
Converts the string representation of an IPV4 address into a 32-bit integer.
Type: conversion

See also: INT_TO_IPV4
LAST_INDEX_OF
LAST_INDEX_OF( string &lt;STRING&gt;, searchStr &lt;STRING&gt; )
Returns the character position where the last occurrence of a search substring occurs in a string.
Type: string manipulation

See also: INDEX_OF
LOG
LOG( argument &lt;INTEGER | REAL&gt; )
Calculates the Natural logarithm of the specified argument.
Type: arithmetical

See also: LOG10
LOG10
LOG10( argument &lt;INTEGER | REAL&gt; )
Calculates the base-10 logarithm of the specified argument.
Type: arithmetical

See also: LOG
LTRIM
LTRIM( string &lt;STRING&gt; )
Removes whitespace characters from the beginning of a string.
Type: string manipulation

See also: RTRIM TRIM
MAX
MAX( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the maximum value among all the values of the specified field-expression.
Type: aggregate
MAX(sc-bytes) AS [Maximum Bytes Sent]
Returns the maximum number of bytes sent from the server to the client, across all requests.
See also: MIN
MIN
MIN( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the minimum value among all the values of the specified field-expression.
Type: aggregate
MIN(sc-bytes) AS [Minimum Bytes Sent]
Returns the minimum number of bytes sent from the server to the client, across all requests.
See also: MAX
MOD
MOD( dividend &lt;INTEGER | REAL&gt;, divisor &lt;INTEGER | REAL&gt; )
Calculates the remainder of the division of two numbers.
Type: arithmetical

MUL
MUL( multiplicand &lt;INTEGER | REAL&gt;, multiplier &lt;INTEGER | REAL&gt; )
Calculates the product of two values.
Type: arithmetical
MUL(PROPCOUNT(*), 100)
When used with another field and a simple GROUP BY, returns the percentage of requests by that field. See example query HTTP status codes and percentage of total.
See also: DIV ADD SUB
OUT_ROW_NUMBER
OUT_ROW_NUMBER()
Returns the current output record number.
Type: miscellaneous

See also: IN_ROW_NUMBER
PROPCOUNT
PROPCOUNT( * ) [ ON ( &lt;on_field_expr_list&gt; ) ] | ( &lt;field_expr_list&gt; ) [ ON ( &lt;on_field_expr_list&gt; ) ]
Returns the ratio of the COUNT aggregate function calculated on a group to the COUNT aggregate function calculated on a hierarchically higher group.
Type: aggregate

PROPSUM
PROPSUM( &lt;field_expr&gt; ) [ ON ( &lt;on_field_expr_list&gt; ) ]
Returns the ratio of the SUM aggregate function calculated on a group to the SUM aggregate function calculated on a hierarchically higher group.
Type: aggregate

QNTFLOOR_TO_DIGIT
QNTFLOOR_TO_DIGIT( value &lt;INTEGER&gt;, digits &lt;INTEGER&gt; )
Truncates a number to a specified number of significant digits, masking the remaining digits to zero.
Type: arithmetical

See also: QNTROUND_TO_DIGIT FLOOR ROUND
QNTROUND_TO_DIGIT
QNTROUND_TO_DIGIT( value &lt;INTEGER&gt;, digits &lt;INTEGER&gt; )
Rounds a number to a specified number of significant digits, masking the remaining digits to zero.
Type: arithmetical

See also: QNTFLOOR_TO_DIGIT FLOOR ROUND
QUANTIZE
QUANTIZE( argument &lt;INTEGER | REAL | TIMESTAMP&gt;, quantization &lt;INTEGER | REAL&gt; )
Truncates a value to the nearest multiple of another value.
Type: arithmetical
QUANTIZE(TO_TIMESTAMP(date, time), 3600)
Returns date/times to the hour. (In other words, drops the minutes.)
REPLACE_CHR
REPLACE_CHR( string &lt;STRING&gt;, searchCharacters &lt;STRING&gt;, replaceString &lt;STRING&gt; )
Replaces each occurrence of a character in a given set of characters with a string.
Type: string manipulation

REPLACE_IF_NOT_NULL
REPLACE_IF_NOT_NULL( argument &lt;any type&gt;, replaceValue &lt;any type&gt; )
Returns the second argument when the first argument is not NULL, and NULL otherwise.
Type: miscellaneous

REPLACE_STR
REPLACE_STR( string &lt;STRING&gt;, searchString &lt;STRING&gt;, replaceString &lt;STRING&gt; )
Replaces each occurrence of a substring with a string.
Type: string manipulation

RESOLVE_SID
RESOLVE_SID( sid &lt;STRING&gt; [ , computerName &lt;STRING&gt; ] )
Resolves a SID and returns its full account name.
Type: system information

REVERSEDNS
REVERSEDNS( ipAddress &lt;STRING&gt; )
Resolves an IP address and returns the corresponding host name.
Type: system information
REVERSEDNS(c-ip)
Returns the host name for the client's IP address.
ROT13
ROT13( string &lt;STRING&gt; )
Encodes or decodes a string using the ROT13 algorithm.
Type: string manipulation

ROUND
ROUND( argument &lt;REAL&gt; )
Returns the integer closest to the specified argument.
Type: arithmetical

See also: FLOOR QNTFLOOR_TO_DIGIT QNTROUND_TO_DIGIT
RTRIM
RTRIM( string &lt;STRING&gt; )
Removes whitespace characters from the end of a string.
Type: string manipulation

See also: LTRIM TRIM
SEQUENCE
SEQUENCE( [ startValue &lt;INTEGER&gt; ] )
Returns a unique sequential integer associated with the current input record number.
Type: miscellaneous

SQR
SQR( argument &lt;INTEGER | REAL&gt; )
Calculates the square of the specified argument.
Type: arithmetical

SQRROOT
SQRROOT( argument &lt;INTEGER | REAL&gt; )
Calculates the square root of the specified argument.
Type: arithmetical

STRCAT
STRCAT( string1 &lt;STRING&gt;, string2 &lt;STRING&gt; )
Appends one string to another.
Type: string manipulation

STRCNT
STRCNT( string &lt;STRING&gt;, token &lt;STRING&gt; )
Returns the number of occurrences of a substring in a string.
Type: string manipulation
STRCNT(cs-uri-stem, '/') AS [Request Depth]
Returns the depth of a requested file.
STRLEN
STRLEN( string &lt;STRING&gt; )
Returns the length of a string.
Type: string manipulation

STRREPEAT
STRREPEAT( string &lt;STRING&gt;, count &lt;INTEGER&gt; )
Creates a string by repeating a substring a given number of times.
Type: string manipulation

STRREV
STRREV( string &lt;STRING&gt; )
Reverses the characters in a string.
Type: string manipulation

SUB
SUB( minuend &lt;any type&gt;, subtrahend &lt;any type&gt; )
Calculates the difference of two values.
Type: arithmetical
TO_DATE(SUB(TO_LOCALTIME(SYSTEM_TIMESTAMP()), TIMESTAMP('0000-01-08', 'yyyy-MM-dd')))
Gets the date seven days ago, based on the current local date/time.
See also: ADD DIV MUL
SUBSTR
SUBSTR( string &lt;STRING&gt;, start &lt;INTEGER&gt; [ , length &lt;INTEGER&gt; ])
Returns a substring beginning at a specified location and having a specified length. The &lt;start&gt; of &lt;string&gt; begins at 0.
Type: string manipulation

SUM
SUM( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the sum of all the values, or only the DISTINCT values, of the specified field-expression.
Type: aggregate
SUM(sc-bytes) AS [Total Bytes Sent]
Returns the total number of bytes sent from the server to the client.
SYSTEM_DATE
SYSTEM_DATE()
Returns the current system date in Universal Time Coordinates (UTC) time.
Type: system information

See also: SYSTEM_TIME SYSTEM_TIMESTAMP
SYSTEM_TIME
SYSTEM_TIME()
Returns the current system time of the day in Universal Time Coordinates (UTC) time.
Type: system information

See also: SYSTEM_DATE SYSTEM_TIMESTAMP
SYSTEM_TIMESTAMP
SYSTEM_TIMESTAMP()
Returns the current system date and time in Universal Time Coordinates (UTC) time.
Type: system information
TO_LOCALTIME(SYSTEM_TIMESTAMP) AS [CurrentLocalTime]
Get the current date and time, converted to local time.
SUB(TO_LOCALTIME(SYSTEM_TIMESTAMP()), TIMESTAMP('0000-01-01 00:03', 'yyyy-MM-dd HH:mm'))
Get the local time 3 minutes ago.
See also: SYSTEM_DATE SYSTEM_TIME
SYSTEM_UTCOFFSET
SYSTEM_UTCOFFSET()
Returns the current system timezone and daylight saving offset relative to Universal Time Coordinates (UTC) time.
Type: system information

TO_DATE
TO_DATE( timestamp &lt;TIMESTAMP&gt; )
Converts a full timestamp into a date-only timestamp.
Type: conversion

See also: TO_TIME
TO_HEX
TO_HEX( argument &lt;INTEGER | STRING&gt; )
Returns the hexadecimal representation of an integer or of the characters in a string.
Type: conversion

TO_INT
TO_INT( argument &lt;any type&gt; )
Converts a value of the REAL, STRING, or TIMESTAMP data type into a value of the INTEGER data type.
Type: conversion

TO_LOCALTIME
TO_LOCALTIME( timestamp &lt;TIMESTAMP&gt; )
Converts a timestamp from Universal Time Coordinates (UTC) time into local time.
Type: conversion
TO_LOCALTIME(TO_TIMESTAMP(date, time)) AS [LocalTime]
Create a timestamp from the date and time of a request and convert it to local time.
See also: TO_UTCTIME
TO_LOWERCASE
TO_LOWERCASE( string &lt;STRING&gt; )
Returns a string where all alphabetic characters have been converted to lowercase.
Type: string manipulation

See also: TO_UPPERCASE
TO_REAL
TO_REAL( argument &lt;any type&gt; )
Converts a value of the INTEGER, STRING, or TIMESTAMP data type into a value of the REAL data type.
Type: conversion

TO_STRING
TO_STRING( argument &lt;INTEGER | REAL&gt; ) | ( timestamp &lt;TIMESTAMP&gt;, format &lt;STRING&gt; )
Converts a value of the REAL or INTEGER data type into a value of the STRING data type.
Type: conversion
TO_STRING(TO_LOCALTIME(TO_TIMESTAMP(date, time)), 'yyyy-MM-dd') AS [Day]
Converts the date and time of a request to local time, and then outputs the day as a string (2010-03-22).
TO_TIME
TO_TIME( timestamp &lt;TIMESTAMP&gt; )
Converts a full timestamp into a time-only timestamp.
Type: conversion
TO_TIME(TO_LOCALTIME(QUANTIZE(TO_TIMESTAMP(date, time), 3600))) AS [Hour]
Create a timestamp from the date and time of a request, drops the minutes from the time, converts it to local time, and pulls just the time.
See also: TO_LOCALTIME TO_DATE
TO_TIMESTAMP
TO_TIMESTAMP( dateTime1 &lt;TIMESTAMP&gt;, dateTime2 &lt;TIMESTAMP&gt; ) | ( string &lt;STRING&gt;, format &lt;STRING&gt; ) ( seconds &lt;INTEGER | REAL&gt; )
Parses a string representing a timestamp and returns a value of the TIMESTAMP data type. See also Microsoft Log Parser timestamp formats by James Skemp. There seems to be no difference between using TO_TIMESTAMP() and just TIMESTAMP().
Type: conversion
TO_TIMESTAMP(date, time)
Converts the date and time of a request into a timestamp, for use with other functions.
TO_TIMESTAMP('2009-02-06', 'yyyy-MM-dd')
Creates a timestamp of the date February 6, 2009.
TO_TIMESTAMP('2010-02-15 10:15', 'yyyy-MM-dd HH:mm')
Creates a timestamp of February 25, 2010, at 10:15 in the morning.
TO_TIMESTAMP('24 Jun 2011 13:22:21', 'dd MMM yyyy HH:mm:ss')
Creates a timestamp of a date/time in 'short' format.
TO_UPPERCASE
TO_UPPERCASE( string &lt;STRING&gt; )
Returns a string where all alphabetic characters have been converted to uppercase.
Type: string manipulation

See also: TO_LOWERCASE
TO_UTCTIME
TO_UTCTIME( timestamp &lt;TIMESTAMP&gt; )
Converts a timestamp from local time into Universal Time Coordinates (UTC) time.
Type: conversion

See also: TO_LOCALTIME
TRIM
TRIM( string &lt;STRING&gt; )
Removes whitespace characters from the beginning and end of a string.
Type: string manipulation

See also: LTRIM RTRIM
URLESCAPE
URLESCAPE( url &lt;STRING&gt; [ , codepage &lt;INTEGER&gt; ] )
Converts a string to the URL-encoded form suitable for transmission as an HTTP query string.
Type: string manipulation

See also: URLUNESCAPE
URLUNESCAPE
URLUNESCAPE( url &lt;STRING&gt; [ , codepage &lt;INTEGER&gt; ] )
Converts a URL-encoded string into its plain, unencoded form.
Type: string manipulation

See also: URLESCAPE
WIN32_ERROR_DESCRIPTION
WIN32_ERROR_DESCRIPTION( win32ErrorCode &lt;INTEGER&gt; )
Returns the text message associated with a numeric Windows error code.
Type: miscellaneous</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Use Logparser and Powershell to produce a single CSV output from IIS logs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Use Logparser and Powershell to produce a single CSV output from IIS logs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://gallery.technet.microsoft.com/office/Use-Logparser-and-59eaa5e5
#' Use Logparser and Powershell to produce a single CSV output from IIS logs

============================
I wanted to combine powershell and logparser to get me a single csv file of user activity on my ASPX website.

The following script acheives that by doing the following

It connects to a root IIS log repository. 
	Although the script looks at a single location, 
	it would be fairly simple to collect the logs from several servers first 
	(renaming them, possibly with the server name appended to give them a unique name) 
My IIS logs are generated fresh each day (the default) 
	so I used the create date to determine what day each log relates to.
I considered a week to be a reasonable block of time to track activity.  
	Therefore, I loop over the list of files and copy them into a week by week folder (named YYYY-WW)
Logparser then comes into action, 
	producing a single csv file for each set of logs for the week (i.e. for each folder)
You can modify the SELECT statement as needed, 
	but I was only interested in who hit which page, 
	where it was in the site and what their average and maximum rendering time was
Logparser will output some paths that I dont want in the report.  
	As my site is a SharePoint site, I'm not interested (in this instance) 
	so I strip them out of the file via the $unwantedPaths parameter.
The prepared files are then grouped into one single output file (Logs.csv) that I can pivot and present in Excel
 

Feel free to change structure and final output to suit your needs 
	- the script should give the basic building blocks to get a decent usage report out quickly.  
	The other advantage is that it will only do work if new data exists.  
	So, if you delete the output directories or files or new logs exist then you'll get new output.

It should go without saying that you'll need to have installed logparser on your machine before running this file.
==================================
Function CopyLogFile ($LogFile, [ref]$FoldersToProcess) { 
 
     
    $YearWeekOfFile = get-date ($LogFile.CreationTime) -UFormat %Y-%V 
    $savePath = Join-Path -Path $weeklyLogRootFolder -ChildPath $YearWeekOfFile 
    CreateFolderIfNotExists $savePath 
     
    $logFileDestinationPath = Join-Path -Path $savePath -ChildPath $LogFile.Name 
     
    if ((Test-Path $logFileDestinationPath) -eq $false) { 
        Copy-Item -Path $LogFile.FullName -Destination $logFileDestinationPath 
        $FoldersToProcess.value += $savePath 
    } 
     
     
} 
Function CreateFolderIfNotExists ($FolderPath) { 
 
    if ((Test-Path $FolderPath) -eq $false) { 
        New-Item -Path $FolderPath -Type Directory 
    } 
 
} 
 
Function PathIsWanted ($RequestPath) { 
    $pathIsWanted = $true 
    foreach($path in $unwantedPaths) { 
        if ($RequestPath -like "$($path)*") { 
            $pathIsWanted = $false 
            break 
        } 
    } 
    $pathIsWanted 
} 
 
#Modify this section with your own values 
 
$rawLogFileRoot = "\\SERVER\c$\inetpub\logs\LogFiles\FOLDER" 
$unwantedPaths = "/_layouts/", "/apps/", "/Lists/", "/_catalogs/", "/_vti_bin/", "/themes", "/Workflow" 
$weeklyLogRootFolder = "C:\temp\logs\" 
$outputCSVLocation = "C:\temp\logs\csvOutput\" 
 
#End of variables to be modified 
 
 
#You may need to modify the exe path of Logparser.exe as well as the SELECT script you wish to run 
#I only wanted aspx pages from my site 
$logParserExe = "C:\Program Files (x86)\Log Parser 2.2\LogParser.exe" 
$logParserSQL =  "`"SELECT '{0}' AS Date, cs-username, STRCAT(EXTRACT_PATH(cs-uri-stem),'/') AS RequestPath, " 
$logParserSQL += "EXTRACT_FILENAME(cs-uri-stem) AS RequestedFile, COUNT(*) AS TotalHits, Max(time-taken) AS MaxTime, " 
$logParserSQL += "AVG(time-taken) AS AvgTime INTO {2} FROM {1}\*.log WHERE cs-username  IS NOT NULL AND " 
$logParserSQL += "SUBSTR(STRREV(EXTRACT_FILENAME(cs-uri-stem)),0,5) = 'xpsa.'   GROUP BY cs-username, cs-uri-stem ORDER BY TotalHits DESC`"" 
#  "STRREV(EXTRACT_FILENAME(cs-uri-stem)),0,5) = 'xpsa.'" gives us aspx pages only 
$logParserParams = "-i:IISW3C" , "-o:CSV" 
 
 
CreateFolderIfNotExists $weeklyLogRootFolder 
CreateFolderIfNotExists $outputCSVLocation 
 
$FoldersToProcess = @() 
 
$rawLogFiles = Get-ChildItem $rawLogFileRoot 
 
 
foreach ($logFile in $rawLogFiles) { 
    CopyLogFile -logFile $logFile -FoldersToProcess ([ref] $FoldersToProcess) 
} 
$FoldersToProcess = $FoldersToProcess | select -uniq 
 
#Log Parsing section 
if ($FoldersToProcess -ne $null) { 
 
    foreach ($folderToProcess in $FoldersToProcess) { 
        $yearWeekName = $folderToProcess.Replace($weeklyLogRootFolder, '') 
        $outputCSV = Join-Path -Path $outputCSVLocation -ChildPath ($yearWeekName + ".csv") 
        $logParserParamsInput = ([string]::Format($logParserSQL, $yearWeekName, $folderToProcess, $outputCSV)), $logParserParams[0], $logParserParams[1] 
         
        Start-Process -NoNewWindow -FilePath $logParserExe -ArgumentList $logParserParamsInput -wait 
 
        #Now process the CSV file - removing unwanted page entries 
        $data = Import-Csv -Path $outputCSV | ?{$unwantedPaths -notcontains $_.RequestPath}  
        $data | Where-Object { (PathIsWanted $_.RequestPath) -eq $true } | Export-CSV -Path $outputCSV -NoTypeInformation 
         
    } 
} 
 
 
$outputFile = $null 
$outputFilePath = Join-Path -Path $outputCSVLocation -ChildPath "Logs.csv" 
 
 
$resultFiles = Get-Childitem $outputCSVLocation  
$firstItem = $true 
if ($resultFiles -ne $null) { 
    foreach ($resultFile in ($resultFiles | ?{$_.Name -ne "Logs.csv"})) { 
        if ($firstItem) { 
            Copy-Item $resultFile.FullName $outputFilePath 
            $firstItem = $false 
        } 
        else { 
            get-content $resultFile.FullName | Select -Skip 1 | Add-Content $outputFilePath 
        } 
    } 
} 
 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Comparison_Operators</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Comparison_Operators</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'The following operators are all Case-Insensitive by default:

&gt;help about_comparison_operators  {tons of info in this help section}


 -eq             Equal
 -ceq 			'is a comparison operator that will test if one numeric or string expression is equal to another
						'ceq is a case-sensitive match and will ignore wildcards.
 -ne             Not equal
 -ge             Greater than or equal
 -gt             Greater than
 -lt             Less than
 -le             Less than or equal
 -like           Wildcard comparison
 -notlike        Wildcard comparison
 -match          Regular expression comparison
 -notmatch       Regular expression comparison
 -replace        Replace operator
 -contains       Containment operator
 -notcontains    Containment operator
 -shl            Shift bits left (PowerShell 3.0)
 -shr            Shift bits right – preserves sign for signed values.(PowerShell 3.0)
 -in             Like –contains, but with the operands reversed.(PowerShell 3.0)
 -notin          Like –notcontains, but with the operands reversed.(PowerShell 3.0)
'To perform a Case-Sensitive comparison just prefix any of the above with "c"
'for example -ceq for case-sensitive Equals or -creplace for case-sensitive replace.

'Similarly prefixing with "i" will explicitly make the operator case insensitive.

'Types
 -is     Is of a type
 -isnot  Is not of a type
 -as     As a type, no error if conversion fails

'Logical operators
 -and    Logical And
 -or     Logical Or
 -not    logical not
  !      logical not

'Bitwise operators 
 -band   Bitwise and
 -bor    Bitwise or
 
 
 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Automatic_Variables__created_and_maintained_by_Windows_PowerShell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Automatic_Variables__created_and_maintained_by_Windows_PowerShell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://msdn.microsoft.com/en-us/powershell/reference/4.0/microsoft.powershell.core/about/about_automatic_variables

$_

'Same as $PSItem. Contains the current object in the pipeline object. 
'You can use this variable in commands that perform an action on every object or on selected objects in a pipeline.

$FOREACH

'Contains the enumerator (not the resulting values) of a ForEach loop

$HOME

'Contains the full path of the user's home directory. 

$HOST

'Contains an object that represents the current host application for Windows PowerShell.

$MYINVOCATION

'Contains an information about the current command, such as the name, parameters, parameter values, 
'and information about how the command was started, called, or "invoked," 
'such as the name of the script that called the current command.

$PROFILE

'Contains the full path of the Windows PowerShell profile for the current user and the current host application. 

$PSCMDLET

'Contains an object that represents the cmdlet or advanced function that is being run.

$PSCOMMANDPATH

'Contains the full path and file name of the script that is being run. 

$PSITEM

'Same as $_. Contains the current object in the pipeline object. 

$PSSCRIPTROOT

'Contains the directory from which a script is being run.

$PSVERSIONTABLE

'Contains a read-only hash table that displays details about the version of Windows PowerShell that is running in the current session. 

$PWD

'Contains a path object that represents the full path of the current directory.

$THIS

'In a script block that defines a script property or script method, the $This variable refers to the object that is being extended.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-PendingReboot</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-PendingReboot</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gallery.technet.microsoft.com/scriptcenter/Get-PendingReboot-Query-bdb79542

https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/10/determine-pending-reboot-statuspowershell-style-part-1/
https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/11/determine-pending-reboot-statuspowershell-style-part-2/ 


'USAGE:
$Servers = Get-Content C:\DATA\2018_04_20__RespondToPing.txt 
Get-PendingReboot -Computer $Servers | Export-Csv C:\DATA\PendingRebootReport.csv -NoTypeInformation 

============================================================================


Function Get-PendingReboot
{
&lt;#
.SYNOPSIS
    Gets the pending reboot status on a local or remote computer.

.DESCRIPTION
    This function will query the registry on a local or remote computer and determine if the
    system is pending a reboot, from Microsoft updates, Configuration Manager Client SDK, Pending Computer 
    Rename, Domain Join or Pending File Rename Operations. For Windows 2008+ the function will query the 
    CBS registry key as another factor in determining pending reboot state.  "PendingFileRenameOperations" 
    and "Auto Update\RebootRequired" are observed as being consistant across Windows Server 2003 &amp; 2008.
	
    CBServicing = Component Based Servicing (Windows 2008+)
    WindowsUpdate = Windows Update / Auto Update (Windows 2003+)
    CCMClientSDK = SCCM 2012 Clients only (DetermineIfRebootPending method) otherwise $null value
    PendComputerRename = Detects either a computer rename or domain join operation (Windows 2003+)
    PendFileRename = PendingFileRenameOperations (Windows 2003+)
    PendFileRenVal = PendingFilerenameOperations registry value; used to filter if need be, some Anti-
                     Virus leverage this key for def/dat removal, giving a false positive PendingReboot

.PARAMETER ComputerName
    A single Computer or an array of computer names.  The default is localhost ($env:COMPUTERNAME).

.PARAMETER ErrorLog
    A single path to send error data to a log file.

.EXAMPLE
    PS C:\&gt; Get-PendingReboot -ComputerName (Get-Content C:\ServerList.txt) | Format-Table -AutoSize
	
    Computer CBServicing WindowsUpdate CCMClientSDK PendFileRename PendFileRenVal RebootPending
    -------- ----------- ------------- ------------ -------------- -------------- -------------
    DC01           False         False                       False                        False
    DC02           False         False                       False                        False
    FS01           False         False                       False                        False

    This example will capture the contents of C:\ServerList.txt and query the pending reboot
    information from the systems contained in the file and display the output in a table. The
    null values are by design, since these systems do not have the SCCM 2012 client installed,
    nor was the PendingFileRenameOperations value populated.

.EXAMPLE
    PS C:\&gt; Get-PendingReboot
	
    Computer           : WKS01
    CBServicing        : False
    WindowsUpdate      : True
    CCMClient          : False
    PendComputerRename : False
    PendFileRename     : False
    PendFileRenVal     : 
    RebootPending      : True
	
    This example will query the local machine for pending reboot information.
	
.EXAMPLE
    PS C:\&gt; $Servers = Get-Content C:\Servers.txt
    PS C:\&gt; Get-PendingReboot -Computer $Servers | Export-Csv C:\PendingRebootReport.csv -NoTypeInformation
	
    This example will create a report that contains pending reboot information.

.LINK
    Component-Based Servicing:
    http://technet.microsoft.com/en-us/library/cc756291(v=WS.10).aspx
	
    PendingFileRename/Auto Update:
    http://support.microsoft.com/kb/2723674
    http://technet.microsoft.com/en-us/library/cc960241.aspx
    http://blogs.msdn.com/b/hansr/archive/2006/02/17/patchreboot.aspx

    SCCM 2012/CCM_ClientSDK:
    http://msdn.microsoft.com/en-us/library/jj902723.aspx

.NOTES
    Author:  Brian Wilhite
    Email:   bcwilhite (at) live.com
    Date:    29AUG2012
    PSVer:   2.0/3.0/4.0/5.0
    Updated: 27JUL2015
    UpdNote: Added Domain Join detection to PendComputerRename, does not detect Workgroup Join/Change
             Fixed Bug where a computer rename was not detected in 2008 R2 and above if a domain join occurred at the same time.
             Fixed Bug where the CBServicing wasn't detected on Windows 10 and/or Windows Server Technical Preview (2016)
             Added CCMClient property - Used with SCCM 2012 Clients only
             Added ValueFromPipelineByPropertyName=$true to the ComputerName Parameter
             Removed $Data variable from the PSObject - it is not needed
             Bug with the way CCMClientSDK returned null value if it was false
             Removed unneeded variables
             Added PendFileRenVal - Contents of the PendingFileRenameOperations Reg Entry
             Removed .Net Registry connection, replaced with WMI StdRegProv
             Added ComputerPendingRename
#&gt;

[CmdletBinding()]
param(
	[Parameter(Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
	[Alias("CN","Computer")]
	[String[]]$ComputerName="$env:COMPUTERNAME",
	[String]$ErrorLog
	)

Begin {  }##'End Begin Script Block
Process {
  Foreach ($Computer in $ComputerName) {
	Try {
	    ##'Setting pending values to false to cut down on the number of else statements
	    $CompPendRen,$PendFileRename,$Pending,$SCCM = $false,$false,$false,$false
                        
	    ##'Setting CBSRebootPend to null since not all versions of Windows has this value
	    $CBSRebootPend = $null
						
	    ##'Querying WMI for build version
	    $WMI_OS = Get-WmiObject -Class Win32_OperatingSystem -Property BuildNumber, CSName -ComputerName $Computer -ErrorAction Stop

	    ##'Making registry connection to the local/remote computer
	    $HKLM = [UInt32] "0x80000002"
	    $WMI_Reg = [WMIClass] "\\$Computer\root\default:StdRegProv"
						
	    ##'If Vista/2008 &amp; Above query the CBS Reg Key
	    If ([Int32]$WMI_OS.BuildNumber -ge 6001) {
		    $RegSubKeysCBS = $WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\")
		    $CBSRebootPend = $RegSubKeysCBS.sNames -contains "RebootPending"		
	    }
							
	    ##'Query WUAU from the registry
	    $RegWUAURebootReq = $WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\")
	    $WUAURebootReq = $RegWUAURebootReq.sNames -contains "RebootRequired"
						
	    ##'Query PendingFileRenameOperations from the registry
	    $RegSubKeySM = $WMI_Reg.GetMultiStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\Session Manager\","PendingFileRenameOperations")
	    $RegValuePFRO = $RegSubKeySM.sValue

	    ##'Query JoinDomain key from the registry - These keys are present if pending a reboot from a domain join operation
	    $Netlogon = $WMI_Reg.EnumKey($HKLM,"SYSTEM\CurrentControlSet\Services\Netlogon").sNames
	    $PendDomJoin = ($Netlogon -contains 'JoinDomain') -or ($Netlogon -contains 'AvoidSpnSet')

	    ##'Query ComputerName and ActiveComputerName from the registry
	    $ActCompNm = $WMI_Reg.GetStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName\","ComputerName")            
	    $CompNm = $WMI_Reg.GetStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\","ComputerName")

	    If (($ActCompNm -ne $CompNm) -or $PendDomJoin) {
	        $CompPendRen = $true
	    }
						
	    ##'If PendingFileRenameOperations has a value set $RegValuePFRO variable to $true
	    If ($RegValuePFRO) {
		    $PendFileRename = $true
	    }

	    ##'Determine SCCM 2012 Client Reboot Pending Status
	    ##'To avoid nested 'if' statements and unneeded WMI calls to determine if the CCM_ClientUtilities class exist, setting EA = 0
	    $CCMClientSDK = $null
	    $CCMSplat = @{
	        NameSpace='ROOT\ccm\ClientSDK'
	        Class='CCM_ClientUtilities'
	        Name='DetermineIfRebootPending'
	        ComputerName=$Computer
	        ErrorAction='Stop'
	    }
	    ##'Try CCMClientSDK
	    Try {
	        $CCMClientSDK = Invoke-WmiMethod @CCMSplat
	    } Catch [System.UnauthorizedAccessException] {
	        $CcmStatus = Get-Service -Name CcmExec -ComputerName $Computer -ErrorAction SilentlyContinue
	        If ($CcmStatus.Status -ne 'Running') {
	            Write-Warning "$Computer`: Error - CcmExec service is not running."
	            $CCMClientSDK = $null
	        }
	    } Catch {
	        $CCMClientSDK = $null
	    }

	    If ($CCMClientSDK) {
	        If ($CCMClientSDK.ReturnValue -ne 0) {
		        Write-Warning "Error: DetermineIfRebootPending returned error code $($CCMClientSDK.ReturnValue)"          
		    }
		    If ($CCMClientSDK.IsHardRebootPending -or $CCMClientSDK.RebootPending) {
		        $SCCM = $true
		    }
	    }
            
	    Else {
	        $SCCM = $null
	    }

	    ##'Creating Custom PSObject and Select-Object Splat
	    $SelectSplat = @{
	        Property=(
	            'Computer',
	            'CBServicing',
	            'WindowsUpdate',
	            'CCMClientSDK',
	            'PendComputerRename',
	            'PendFileRename',
	            'PendFileRenVal',
	            'RebootPending'
	        )}
	    New-Object -TypeName PSObject -Property @{
	        Computer=$WMI_OS.CSName
	        CBServicing=$CBSRebootPend
	        WindowsUpdate=$WUAURebootReq
	        CCMClientSDK=$SCCM
	        PendComputerRename=$CompPendRen
	        PendFileRename=$PendFileRename
	        PendFileRenVal=$RegValuePFRO
	        RebootPending=($CompPendRen -or $CBSRebootPend -or $WUAURebootReq -or $SCCM -or $PendFileRename)
	    } | Select-Object @SelectSplat

	} Catch {
	    Write-Warning "$Computer`: $_"
	    ##'If $ErrorLog, log the file to a user specified location/path
	    If ($ErrorLog) {
	        Out-File -InputObject "$Computer`,$_" -FilePath $ErrorLog -Append
	    }				
	}			
  }##'End Foreach ($Computer in $ComputerName)			
}##'End Process

End {  }##'End End

}##'End Function Get-PendingReboot</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>HELP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>HELP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Example of getting help for 'Get-Command'
&gt; Get-Help Get-Command

&gt;Update-Help  {to get the updates}

#region Cmdlets

	# Get-Command - Retrieves a list of all system commands
	Get-Command
	
	# Can expand by searching for just a verb or noun
	Get-Command -verb "get"
	Get-Command -noun "service"
	
	# Get-Help can be used to explain a command 
	Get-Help Get-Command
	Get-Help Get-Command -examples		#show all the examples
	Get-Help Get-Command -detailed
	Get-Help Get-Command -full
	Get-Help Get-Command -Online   # PS 3 - VERY good for reading - This brings up default browser, and help on the command
	
	# Most commands can also be passed a -? paramter to get help
	Get-Command -?

#endregion Cmdlets



Get-Help 'cmdlet displays information
'The cmdlet has also an Aliases set in the shell by default as 'help' and 'man'. 

'We can also limit to what type of information we may want with the –Category parameter

  help -Category Cmdlet -Name *service*
  
  'One can select what parts of a help file we want to see by specifying the parameter for the level of information one wants

–Detailed 		'parameter is given it will show Parameter information and Examples.
–Full 			'parameter is given it will show a more detailed list of info for Parameters.
–Examples 		'parameter is given only examples are shown.
-full 			'option is used we get additional information on the parameters:

'Syntax

Required for required options or values ==&gt; they will not be enclosed in any bracket.
Options or values enclosed in [ ] are optional
Values are represent with the type they take between &lt; &gt;
Those values that can be lists are represented as &lt;type[ ]&gt; 
Those that have a predefined list of options it can take are represented as &lt; option1 | option2 | option3&gt;


'With PowerShell v3 the
 –ShowWindow 			'parameter was added to open a separate window that can be used as reference while one works construction a command
 
&gt; help about      	'This will list all conceptual topics.


Get-Verb 			'cmdlet to get the list of approved verbs for PowerShell. 

Get-Command 		'gets the commands from Windows PowerShell modules 

=======================================================================


' Using help optional parmameters and their values are shown in brackets
==========================================================================

' No mandatory params
(Get-Help -Name Get-Service -Detailed).syntax			'&lt;=== This requests help on the syntax

' Only Path is mandatory
(Get-Help -Name Get-Content -Detailed).syntax

'Get-Command to find Mandatory parameters in cmdlets
'Note can run this up to each period "." in the ISE to see what that part does
(Get-Command -Name 'Get-Content').Parameters.Path.Attributes

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Hosts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Hosts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Host									$Host.Name					$ShellId				HostId
====                                    ==========                  ===========				================
PowerShell								ConsoleHost					Microsoft.PowerShell	Microsoft.PowerShell
PowerShell ISE							Windows PowerShell ISE Host	Microsoft.PowerShell	Microsoft.PowerShellISE
Visual Studio Package Manager Console	Package Manager Host		Microsoft.PowerShell	NuGet

'Other PowerShell hosts could potentially have different $ShellId values 
'(for example, some of the freely available PowerShell IDEs include 
'PowerGUI, PowerShell Analyzer, and PowerShell Plus</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>msg_POP-UP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>msg_POP-UP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'use VBScript-style objects, need to look at the VBScript documentation
$wsh = new-object -com wscript.shell
$wsh.Popup("Isn't this fun?",10,"PowerShell Automation",0+64)
'OUTPUT
=======
{pop-up message:   Isn't this fun?}

'PARMS for the method:
'1. The message
'2. Number of seconds to wait for the user to hit a button   { -1 means wait for user input}
'3. The title
'4. The icon/button values
			'BUTTON
			-------
			"OK"                = 0
			"OKCancel"          = 1
			"AbortRetryIgnore"  = 2
			"YesNo"             = 4
			"YesNoCancel"       = 3
			"RetryCancel"       = 5
			
			'ICON
			------
			"Stop"         = 16
			"Question"     = 32
			"Exclamation"  = 48
			"Information"  = 64
			
==============================================================================
'For "YesNo" = 4
6=Yes {user answer}
7=no  {user answer}
$yn = $wsh.Popup("Failed to do something. Do you want to try again?",-1,"Script Error",4+32)
			</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Selecting_Objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Selecting_Objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'The Select-Object cmdlets allows us to select from a collection of objects the ones we want when we specify the index position of the item. 
'Just like all programing languages we start our count with 0.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -Index 0,1,2,3,4 

'The Select-Object cmdlets allows us to select from a collection of objects the ones we want when we specify the index position of the item. 
'	Just like all programing languages we start our count with 0.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -Index 0,1,2,3,4 

'We can also use the range notation, 
'	this will return an array of number for the range and we can pass those to the index parameter.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -Index (0..4)

'Select the first number of objects, the last number of objects or even skip a certain number.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -first 5 

'The select-object cmdlets also allows us to create and rename an objects property, 
'	this is very useful when the property name is not to descriptive and when we are passing from one comdlet to another 
'	where the next cmdlet accepts and processes objects by Property Name. 
'	The way it works is that we create a hash with 2 values in it, 
'	one is Name which is the name we want for the property and the other is expressions 
'	which is a script block whose returning value will be set as the value of the property we named.

PS &gt; Get-Process | Select-Object -Property name,@{name = 'PID'; expression = {$_.id}} 				'&lt;== NOT CLEAR where the renameing is being done

'One thing that we have to be very careful with when using Select-Object 
'	is that when we select property names using it actually generates a new object 
'	of the same type with only those properties that we selected and strips out the rest. </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Object_CUSTOM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Clone_or_copy_an_object</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Object_CUSTOM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Clone_or_copy_an_object</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'If you need a true copy of an object, you can clone it.

$third = [PSCustomObject]@{Key=3}
$fourth = $third.psobject.copy()
$fourth.Key = 4

'Clone creates a shallow copy of the object. 
'They have different instances now and $third.key is 3 and $fourth.Key is 4 in this example.

'I call this a shallow copy because if you have nested objects. 
'(where the properties contain other objects). 
'Only the top level values are copied. 
'The child objects will reference each other.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Object_CUSTOM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CREATE_custom_Objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Object_CUSTOM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CREATE_custom_Objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://technet.microsoft.com/en-us/library/hh750381.aspx


#'The Full-Form Way
======================
#'Assuming I have an object in the variable $os, and another in $bios, 
#' I could combine selected pieces of information from them like this:
--------------------
$object = New-Object –TypeNamePSObject
$object | Add-Member –MemberTypeNoteProperty –Name OSBuild –Value $os.BuildNumber
$object | Add-Member –MemberTypeNoteProperty –Name OSVersion –Value $os.Version
$object | Add-Member –MemberTypeNoteProperty –Name BIOSSerial –Value $bios.SerialNumber
Write-Output $object

#'PassThru: A Brief Shortcut
===========================
#'You can make that first approach a bit more concise by telling 
#'	Add-Member to put the object back into the pipeline:
#'When you end a line with a pipe character, 
#'    Windows PowerShell knows to go to the next physical line to look for the next command in the pipeline. 
#' Essentially, it’s a way of breaking up a long command into multiple physical lines. 
#' That trick, combined with the –PassThru switch, makes this a series of three distinct commands.
---------------------------
$object = New-Object –TypeNamePSObject
$object | Add-Member –MemberTypeNoteProperty –Name OSBuild –Value $os.BuildNumber –PassThru |
Add-Member –MemberTypeNoteProperty –Name OSVersion –Value $os.Version –PassThru |
Add-Member –MemberTypeNoteProperty –Name BIOSSerial –Value $bios.SerialNumber
Write-Output $object

#'Hashtable
========================
#'Using the New-Object feature is a more concise approach. 
#'This lets you create a hashtable (or associative array) that contains 
#'    the property names and values you want to add to the newly created object. 
#'These properties are each automatically created as a NoteProperty:
-------------------------
$properties = @{'OSBuild'=$os.BuildNumber;
                'OSVersion'=$os.version;
                'BIOSSerial'=$bios.SerialNumber}
$object = New-Object –TypeNamePSObject –Prop $properties
Write-Output $object

#'parenthetical expression to make it even shorter. However, 
#'	I think this makes it a bit more difficult to read:

$object = New-Object –TypeNamePSObject –Prop
(@{'OSBuild'=$os.BuildNumber;
                'OSVersion'=$os.version;
                'BIOSSerial'=$bios.SerialNumber})
Write-Output $object

#'Going a Bit Further
==========================
#'You’ll notice that in all these examples, 
#'    I save the custom object to a variable ($object) before writing it to the pipeline. 
#'The reason for this is simple. You might want to manipulate the object a bit more. 
#'For example, you might want to give your object a custom type name:
#'Doing this lets you create a custom default formatting layout for displaying your object.
----------------------------

$object.PSObject.TypeNames.Insert(0,'My.Custom.Name')


#'Less readable and harder to teach
====================================
#'assuming that my $os and $bios variables contain the raw objects I want to extract information from:
#'It’s basically generating custom properties using a syntax unique to that cmdlet (and shared by the Format cmdlets). 
----------------------------------

$os | Select-Object –Property @{n='OSVersion';e={$_.Version}},
@{n='OSBuild';e={$_.BuildNumber}},
@{n='BIOSSerial';e={$bios.SerialNumber}}

#'Another way:
======================================
#'You’re creating an empty hashtable, 
#'    then adding information by referring to properties that don’t exist. 
#'When you first try to access OSBuild, for example, 
#'    Windows PowerShell realizes that no such property exists in the $info object 
#'    (which was an empty hashtable). 
#'It implicitly creates the property and assigns your value. Crazy stuff—but it works.
-----------------------------------------

$info = @{}
$info.OSBuild=$os.BuildNumber
$info.OSVersion=$os.version
$info.BIOSSerial=$bios.SerialNumber
$object = New-Object –TypeNamePSObject –Prop $info
Write-Output $object</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Object_CUSTOM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>properties_accessingThem</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Object_CUSTOM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>properties_accessingThem</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'I already mentioned that you an access property values directly.

$myObject.Name

'You can use a string for the property name and it will still work.

$myObject.'Name'

'We can take this one more step and use a variable for the property name.

$property = 'Name'
$myObject.$property</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Object_CUSTOM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PSCustomObject</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Object_CUSTOM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PSCustomObject</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'https://kevinmarquette.github.io/2016-10-28-powershell-everything-you-wanted-to-know-about-pscustomobject/

'Creating a PSCustomObject
===========================
$myObject = [PSCustomObject]@{
    Name     = 'Kevin'
    Language = 'Powershell'
    State    = 'Texas'
}


'You can then access and use the values like you would a normal object.
----------------------------------------------------------------------
$myObject.Name


'Using a hashtable
===================
$myHashtable = @{
    Name     = 'Kevin'
    Language = 'Powershell'
    State    = 'Texas'
}
$myObject = [pscustomobject]$myHashtable</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_f_Group_Objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_f_Group_Objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
-------------------------------------------------------------------------GROUP

'Group-Object outputs a new type of object
Get-Vegetable | Group-Object -Property color
'OUTPUT
Count Name                      Group                                                                                                                                    
----- ----                      -----                                                                                                                                    
    2 yellow                    {Vegetable, Vegetable}                                                                                                                   
    3 red                       {Vegetable, Vegetable, Vegetable}                                                                                                        
    6 green                     {Vegetable, Vegetable, Vegetable, Vegetable...}                                                                                          
    1 orange                    {Vegetable}                                                                                                                              
    2 purple                    {Vegetable, Vegetable}                                                                                                                   
    1 brown                     {Vegetable}                                                                                                                              
    1 white                     {Vegetable}     
    
    'You can even see they MemberType of the new type of object:
&gt;Get-Vegetable | Group-Object -Property color | Get-Member
'OUTPUT
   TypeName: Microsoft.PowerShell.Commands.GroupInfo

Name        MemberType Definition                                                      
----        ---------- ----------                                                      
Equals      Method     bool Equals(System.Object obj)                                  
GetHashCode Method     int GetHashCode()                                               
GetType     Method     type GetType()                                                  
ToString    Method     string ToString()                                               
Count       Property   int Count {get;}                                                
Group       Property   System.Collections.ObjectModel.Collection[psobject] Group {get;}
Name        Property   string Name {get;}                                              
Values      Property   System.Collections.ArrayList Values {get;}   

'you can then work with that new object type, and sort it
Get-Vegetable | Group color | sort count -Descending
'OUTPUT:
Count Name                      Group                                                                                                                                    
----- ----                      -----                                                                                                                                    
    6 green                     {Vegetable, Vegetable, Vegetable, Vegetable...}                                                                                          
    3 red                       {Vegetable, Vegetable, Vegetable}                                                                                                        
    2 yellow                    {Vegetable, Vegetable}                                                                                                                   
    2 purple                    {Vegetable, Vegetable}                                                                                                                   
    1 orange                    {Vegetable}                                                                                                                              
    1 brown                     {Vegetable}                                                                                                                              
    1 white                     {Vegetable} 

'Now to actually see the names of the vegetables in the first of those new objects 

&gt;Get-Vegetable | Group color | sort count -Descending | select -first 1 -ExpandProperty group
'OUTPUT:
UPC     Count Name          State    Color     
---     ----- ----          -----    -----     
4722        1 cucumber      Raw      green     
4518       13 peas          Steamed  green     
4190       14 broccoli      Steamed  green     
4061       15 zucchini      Raw      green     
4483       16 spinach       Raw      green     
4723       16 pepper        Sauteed  green    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ODBC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Modifying ODBC Settings with WMI and PowerShell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ODBC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Modifying ODBC Settings with WMI and PowerShell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://www.sqldataplatform.com/Blog/Post/9/Modifying-ODBC-Settings-with-WMI-and-PowerShell

#' This modifies an existing ODBC Setting

#'  The most important part of this script is the #Define Key to Modify section. 
#'  The $ValueName is the registry value you want to change, 
#'  in this case the "Server" value since we are moving databases to a new server. 
#'  The $Value is the new name of the server, for our example here it's SQLPROD1. 
#'  The $Key is the location of the registry key where you will change the ODBC values. 
#'  MYODBCNAME in the Key is the name of your DSN. 
#'  Create a new ODBC DSN connection and use the above script to modify it. 


#====================================================================================

#' Define Constants 

$HKEY_Local_Machine =2147483650 #This is the HKEY_Local_Machine well known value 

#' Get Class to call static methods on 

$regClass = [WMIClass]"ROOT\DEFAULT:StdRegProv" #WMIClass is a Type Accelerator 

#' Define key to modify 

$ValueName = "Server" #The registry value you want to change 

$Values = @('SQLPROD1') #SQLPROD1 is the name of the new server 

$Key = "SOFTWARE\odbc\odbc.ini\MYODBCNAME" #Location of the Key, MYODBCNAME is the DSN name. 

#' Create Value entry 

$results = $regClass.SetStringValue($HKEY_LOCAL_MACHINE, $Key, $ValueName, $Values) 

If ($results.Returnvalue -eq 0) {"Value Set"} 


#====================================================================================
#'  
#'  Now that we know how to change the ODBC on our local machine, 
#'  now we can change it on a remote PC. 
#'  This follows the same steps as our first script but now we need to add come credentials to authenticate to the target client machine. 
#'  Make sure the account you are using has elevated permissions on the remote machine. 

#Define credentials to connect to remote machine 

$Password = ConvertTo-SecureString "P@ssw0rD" -AsPlainText -Force 

$credential = New-Object System.Management.Automation.PSCredential "MyDomain\administrator", $Password 

# Define Constants 

$HKEY_Local_Machine =2147483650 #This is the HKEY_Local_Machine well known value 

# Get Class to call static methods on with credential - targets remote computername 

$regClass = get-wmiobject -list "StdRegProv" -namespace root\default -computername STL-W7User1 -credential $credential 

# Define key to modify 

$ValueName = "Server" #The registry value you want to change 

$Values = @('SQLPRD1') #Name of the new server 

$Key = "SOFTWARE\odbc\odbc.ini\MYODBCNAME" #MYODBCNAME is the DSN name. 

# Create Value entry 

$results = $regClass.SetStringValue($HKEY_LOCAL_MACHINE, $Key, $ValueName, $Values) 

If ($results.Returnvalue -eq 0) {"Value Set"} 

#'===============================================================================

#'  Here we have passed credentials to the remote machine so we can execute the script. 
#'  You will also notice the addition of –computername 
#'  under the #Define Constants section, 
#'  this is the target computer name STL-W7User1. 
#'  Setup a new ODBC on a remote PC and test again. 
#'  
#'  Now that we know how to change the ODBC connection for both local and remote PCs, 
#'  but how can we change it for more than a single remote PC, 
#'  for let's say 20 PC's? We are going to build an array, 
#'  a simple text file that has all the computer names you want to change the ODBC connection on. 
#'  After we build our array we will iterate through the array using foreach: 
#'  


#Define credentials to connect to remote machine 

$Password = ConvertTo-SecureString "P@ssw0rD" -AsPlainText -Force 

$credential = New-Object System.Management.Automation.PSCredential "MyDomain\administrator", $Password 

# Define Constants 

$HKEY_Local_Machine =2147483650 #This is the HKEY_Local_Machine well known value 

# Define array 

$strComputers = Get-Content -Path "C:\MyScripts\Computers.txt" 

# Get Class to call static methods on with credential – calls array 

$regClass = get-wmiobject -list "StdRegProv" -namespace root\default -computername $strComputers -credential $credential 

# Define key to modify 

$ValueName = "Server" #The registry value you want to change 

$Values = @('SQLPRD1') #Name of the new server 

$Key = "SOFTWARE\odbc\odbc.ini\MYODBCNAME" #MYODBCNAME is the DSN name. 

# Create Value entry 

Foreach ($objectName in $regClass) 

$results = $objectName.SetStringValue($HKEY_LOCAL_MACHINE, $Key, $ValueName, $Values) 

If ($results.Returnvalue -eq 0) {"Value Set"} 


#'  This script follows all the steps from the last script 
#'  but this time we are calling our text file to feed the computer names to build our array. 
#'  Under #Create Value Entry we use Foreach to iterate through the computer names, 
#'  this way all remote computers defined in your list will have their ODBC changed. 
#'  For the text file, I just created a simple txt file with each computer name in it. 
#'  I am calling the directory C:\MyScripts\ with the file name Computers.txt in the #Define Array section. 

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Outlook</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_Mail_Profiles</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Outlook</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_Mail_Profiles</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://social.technet.microsoft.com/Forums/office/en-US/ec1e6f56-b7de-457f-9b66-7616100370ba/getitemproperty-hkcusoftwaremicrosoftoffice150outlookprofiles-gives-no-result?forum=winserverpowershell

'To see the list of MAIL profiles:
&gt; dir HKCU:\Software\Microsoft\Office\15.0\outlook\Profiles | select -ExpandProperty PSChildName

'When I look at it on my machine, it looks like the profiles key only has child keys and no values. 
'To get a list of the subkeys, you would use Get-ChildItem instead of Get-ItemProperty. 
'That being said, you should still be able to use Get-ItemProperty to get what you're after by adding an extra \* to the path:
HKCU:\Software\Microsoft\Office\15.0\outlook\Profiles\*\*</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Outlook</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Outlook_Add-ins</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Outlook</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Outlook_Add-ins</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/visualstudio/vsto/registry-entries-for-vsto-add-ins#LoadBehavior
LoadBehavior values

0 = Unloaded, Do not load automatically
1 = Loaded, Do not load automatically
2 = Unloaded, Load at startup
3 = Loaded, Load at startup
8 = Unloaded, Load on demand
9 = Loaded, Load on demand
16= Loaded, Load first time, then load on demand



'This shows you what add-ins are present, and what their LoadBehavior is
-------------------------------------------------------------------------
$searchScopes = "HKCU:\SOFTWARE\Microsoft\Office\Outlook\Addins","HKLM:\SOFTWARE\Wow6432Node\Microsoft\Office\Outlook\Addins"
'Original list of fields
$Results = $searchScopes | % {Get-ChildItem -Path $_ | % {Get-ItemProperty -Path $_.PSPath} | Select-Object @{n="Name";e={Split-Path $_.PSPath -leaf}},FriendlyName,Description,LoadBevior} | Sort-Object -Unique -Property name
'With just name and load behaviour
$Results = $searchScopes | % {Get-ChildItem -Path $_ | % {Get-ItemProperty -Path $_.PSPath} | Select-Object @{n="Name";e={Split-Path $_.PSPath -leaf}},LoadBehavior} | Sort-Object -Unique -Property name
 
'OUTPUT
----------
Name                                 LoadBehavior
----                                 ------------
AccessAddin.DC                                  2
Adobe.Contribute.OfficePlugin                   0
ColleagueImport.ColleagueImportAddin            3
PDFMOutlook.PDFMOutlook                         3
SEPOutlookAddin.OutlookAddin                    3 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_OutPut</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CSV_append</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_OutPut</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CSV_append</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

-----------------------------------------------------------------------
'Use 'append' parameter of Export-Csv
'The command uses the -Path parameter to specify the output file 
'	and the -Append parameter to add the new script data to the end of the output file, 
'	instead of replacing the existing file contents.
$ScriptFiles = Get-ChildItem D:\* -Include *.ps1 -Recurse | Where-Object {$_.creationtime -gt "01/01/2011"}
$ScriptFiles = $ScriptFiles | Select-Object -Property Name, CreationTime, LastWriteTime, IsReadOnly
$ScriptFiles | Export-Csv -Append -Path "\\Archive01\Scripts\Scripts.csv"
-----------------------------------------------------------------------
$filename = "$(Get-Date -Format "yyyy_M_d_h_m_s")-ComputerStatusSummary.csv"
$wsus.GetSummariesPerComputerTarget($updatescope,$computerscope) | SELECT @{L='ComputerTarget';E={($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).FullDomainName}}, @{L='NeededCount';E={($_.DownloadedCount + $_.NotInstalledCount)}},DownloadedCount,NotApplicableCount,NotInstalledCount,InstalledCount | Export-Csv -Append -NoType -Path "$Env:userprofile\Desktop\PS\$filename"
-----------------------------------------------------------------------





'Create a new custom object and add it to the object array that Import-Csv creates.

$fileContent = Import-csv $file -header "Date", "Description"
$newRow = New-Object PsObject -Property @{ Date = 'Text4' ; Description = 'Text5' }
$fileContent += $newRow

'This worked great for me except that it changed the ordering of my columns.
'After I appended the line using the above answer I had to use
 $Import = $Import | Select-Object...
 
 ------------------------------------------------------------------
 
'to only add a new line to the file, try the following, 
'	where $YourNewDate and $YourDescription contain the desired values.
$NewLine = "{0},{1}" -f $YourNewDate,$YourDescription
$NewLine | add-content -path $file

'Or,

"{0},{1}" -f $YourNewDate,$YourDescription | add-content -path $file

'This will just tag the new line to the end of the .csv, and will not work 
'	for creating new .csv files where you will need to add the header.

 ------------------------------------------------------------------
 
#'this bit creates the CSV if it does not already exist
$headers = "Name", "Primary Type"
$psObject = New-Object psobject
foreach($header in $headers)
{
 Add-Member -InputObject $psobject -MemberType noteproperty -Name $header -Value ""
}
$psObject | Export-Csv $csvfile -NoTypeInformation

#'this bit appends a new row to the CSV file
$bName = "My Name"
$bPrimaryType = "My Primary Type"
    $hash = @{
             "Name" =  $bName
             "Primary Type" = $bPrimaryType
              }

$newRow = New-Object PsObject -Property $hash
Export-Csv $csvfile -inputobject $newrow -append -Force

------------------------------------------------------------------------
$table=@"
First name,Surname,Phone,Age
Larry,Jones,   555-0000,  15
Bob, Barker,666-8888,   56
Jane,Doe, 888-9876,    63
"@
 
#export to a csv file
$table | Set-Content E:\a.csv
 
#append a row to an existing file
Add-Content E:\a.csv "Joe,Richard,111-2345,78"
 
The following data shows the output form the Import-Csv cmdlet.
Import-Csv E:\a.csv
 
First name                 Surname           Phone              Age                                      
----------                 -------           -----              ---                                      
Larry                      Jones             555-0000           15                                       
Bob                        Barker            666-8888           56                                       
Jane                       Doe               888-9876           63                                        
Joe                        Richard           111-2345           78 

------------------------------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_OutPut</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Export-CliXml</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_OutPut</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Export-CliXml</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--------------------------------------------------------------------------
'gps - Get-Process cmdlet

gps | Export-Clixml c:\fso\gps.xml

' I then use the Import-CliXML cmdlet to import the XML file 
'	and store the process objects in the $gps variable. 
' Next, I pipe the process objects to the Where-Object cmdlet 
'	(? Is an alias for Where-Object) where I look for process names that match word. 
' The commands that accomplish all this are shown here:

$gps = Import-Clixml C:\fso\gps.xml

$gps | ? { $_.name -match 'word' }

'One thing to keep in mind when working with Import-CliXML and Export-CliXML 
'	is that the created objects are deserialized. 
' This means that the methods normally available to the System.Diagnostics.Process objects 
'	are not available. Other than that, 
'	they look and behave exactly like normal objects. 
'I can pipe the XML to the Get-Member object to see what is available and what is not available.
' The command to do this is shown here:

Import-Clixml C:\fso\gps.xml | get-member
----------------------------------------------------------------
'The Export-CliXml command is used to save full objects to a file
'	 and then import them again with Import-CliXml. 
'This is for objects with nested values or complex datatypes. 
'The raw data will be a verbose serialized object in XML.
'The nice thing is that you can save a an object to the file and when you import it, 
' 	you will get that object back.

Get-Date | Export-Clixml date.clicml
$date = Import-Clixml .\date.clicml
$date.GetType()
'OUTPUT
=======================
IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     DateTime                                 System.ValueType

'This serialized format is not intened for be viewd or edited directly. 
'Here is what the date.clixml file looks like:

&lt;Objs Version="1.1.0.1" xmlns="http://schemas.microsoft.com/powershell/2004/04"&gt;
    &lt;Obj RefId="0"&gt;
        &lt;DT&gt;2017-03-17T00:00:00.3522798-07:00&lt;/DT&gt;
        &lt;MS&gt;
            &lt;Obj N="DisplayHint" RefId="1"&gt;
                &lt;TN RefId="0"&gt;
                    &lt;T&gt;Microsoft.PowerShell.Commands.DisplayHintType&lt;/T&gt;
                    &lt;T&gt;System.Enum&lt;/T&gt;
                    &lt;T&gt;System.ValueType&lt;/T&gt;
                    &lt;T&gt;System.Object&lt;/T&gt;
                &lt;/TN&gt;
                &lt;ToString&gt;DateTime&lt;/ToString&gt;
                &lt;I32&gt;2&lt;/I32&gt;
            &lt;/Obj&gt;
        &lt;/MS&gt;
    &lt;/Obj&gt;
&lt;/Objs&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Parameters</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>MultipleParameterSets </Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Parameters</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>MultipleParameterSets </Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'NOTE: Parameter set names in v5 now appear to be case-sensitive. 

'When using a parameter set, using the key word for a PARM that is unique to the set locks you into that set

-----------Example 1------------

#' assign to parameter set
[Parameter(ParameterSetName="query")]	'If you don't use a ParameterSetName, then the Parm is all sets
[string]$query



#' membership in multiple sets, for One Parm
[Parameter(ParameterSetName="one")]
[Parameter(ParameterSetName="two")]
[string]$something

-------------------------------------



#' default parameter set
[CmdletBinding(DefaultParameterSetName="whatever")]


-----------------------------------
' This scoops up all the un-explicit parm values in the command line:

# values from remaining
[Parameter(ValueFromRemainingArguments=$True)]
[string]$Extras</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Parameters</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>simple examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Parameters</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>simple examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
------------------------------------------------------------------------------------------
#'ScriptWithParameter.ps1
#'get a breakdown of error sources in the System eventlog
#'NOTE: the DEFAULT values are given
Param(
    [string]$Log = "System",
    [string]$Computername = $env:COMPUTERNAME,
    [int32]$Newest = 500,
    [string]$ReportTitle = "Event Log Report",
    [Parameter(Mandatory,HelpMessage = "Enter the path for the HTML file.")]
    [string]$Path
)

#'get event log data and group it
$data = Get-Eventlog -logname $Log -EntryType Error -Newest $newest -ComputerName $Computername |
    Group-object -Property Source -NoElement 

#'create an HTML report
$footer = "&lt;h5&gt;&lt;i&gt;report run $(Get-Date)&lt;/i&gt;&lt;/h5&gt;"
$css = "http://jdhitsolutions.com/sample.css"
$precontent = "&lt;H1&gt;$Computername&lt;/H1&gt;&lt;H2&gt;Last $newest error sources from $Log&lt;/H2&gt;"

$data |Sort-Object -Property Count, Name -Descending |
    Select-Object Count, Name | 
    ConvertTo-Html -Title $ReportTitle -PreContent $precontent  -PostContent $footer -CssUri $css |
    Out-File $Path
-------------------------------------------------------------------------------------------





===================================================================

Param
(
    [parameter()]
    $ParameterName
)
-------------------------

'It is mandatory (required).
'It takes input from the pipeline.
'It takes an array of strings as input.
Param
(
    [parameter(Mandatory=$true,
    		   ValueFromPipeline=$true)]
    [String[]]
    $ComputerName
)

---------------------'Position

Param
(
    [parameter(Position=0)]
    [String[]]
    $ComputerName
)

-------------------'Parameter Set Name
'example 1
Param
(
    [parameter(Mandatory=$true,
    ParameterSetName="Computer")]
    [String[]]
    $ComputerName,

    [parameter(Mandatory=$true,
    ParameterSetName="User")]
    [String[]]
    $UserName,

    [parameter(Mandatory=$false)]
    [Switch]
    $Summary
)

'example 2
Param
(
    [parameter(Mandatory=$true,
    ParameterSetName="Computer")]
    [String[]]
    $ComputerName,

    [parameter(Mandatory=$true,
    ParameterSetName="User")]
    [String[]]
    $UserName,

    [parameter(Mandatory=$false, ParameterSetName="Computer")]
    [parameter(Mandatory=$true, ParameterSetName="User")]
    [Switch]
    $Summary
)

-------------------'ValueFromPipeline Argument
'declares a ComputerName parameter that is mandatory 
'	and accepts an object that is passed to the function from the pipeline.
Param
(
    [parameter(Mandatory=$true,
    ValueFromPipeline=$true)]
    [String[]]
    $ComputerName
)
-------------------'ValueFromPipelineByPropertyName Argument
'the parameter accepts input from a property of a pipeline object. 
'The object property must have the same name or alias as the parameter.
Param
(
    [parameter(Mandatory=$true,
    ValueFromPipelineByPropertyName=$true)]
    [String[]]
    $ComputerName
)

----------------'HelpMessage Argument
'a brief description of the parameter or its value. 
'Windows PowerShell displays this message in the prompt 
'	that appears when a mandatory parameter value is missing from a command. 

Param
(
    [parameter(mandatory=$true,
    HelpMessage="Enter one or more computer names separated by commas.")]
    [String[]]
    $ComputerName
)
----------------'Alias Attribute
' There is no limit to the number of aliases that you can assign to a parameter.
Param
(
    [parameter(Mandatory=$true)]
    [alias("CN","MachineName")]
    [String[]]
    $ComputerName
)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_poswsus</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Install-WSUSServer.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_poswsus</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Install-WSUSServer.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' TO install only the console
#'			. .\Install-WSUSServer.ps1 –ConsoleOnly -verbose
===========================================================================================
This script allows you to install a WSUS server locally or remotely using a variety of configuration options. 
	You can also just install the WSUS Administration Console without having to install the entire server! 
	This script makes use of psexec.exe, 
		which is available to download from this link: 
		http://download.sysinternals.com/Files/SysinternalsSuite.zip. 
	This file must be in the same location as the script, 
		otherwise the script will not run.

The script also requires either the x86 or x64 installation file, 
	which the script will download for you if you allow it to and have an available internet connection 
		from the location you are running the script. 
Keep in mind that the installation files must be in the same location as the script 
	and you also need to keep the installation file's original name.

Also, be sure to check out my companion script: Uninstall-WSUSServer.ps1 as well!
============================================================================================
&lt;#  
.SYNOPSIS  
    Downloads (if needed) and performs an unattended installation of WSUS Server with SP2 on a local or remote system. Requires psexec.exe to be in the same
    location as the script in order to run properly.

.DESCRIPTION
    Downloads (if needed) and performs an unattended installation of WSUS Server with SP2 on a local or remote system. Requires psexec.exe to be in the same
    location as the script in order to run properly. Also optional to have the installation files in the same location as the script, otherwise the files will
    be downloaded from the internet.
     
.PARAMETER Computername
    Name of computer to install WSUS server on.

.PARAMETER ConsoleOnlyServer
    Switch used to only install the console without installing the server application.

.PARAMETER StoreUpdatesLocally
    Switch used to determine if updates will be downloaded and saved to system locally.

.PARAMETER ContentDirectory
    Path to the local content folder holding update files. Default location is: %rootdrive%\WSUS\WSUSContent where the root drive is the largest local drive on the system.

.PARAMETER InternalDatabasePath
    Path to install the internal database
    
.PARAMETER CreateDatabase
    Create a database on the SQL server. Will not create database and attempt to use existing database if switch not used.

.PARAMETER WebsitePort
    Determine the port of the WSUS Site. Accepted Values are "80" and "8530". 

.PARAMETER SQLInstance
    Name of the SQL Instance to connect to for database
    
.PARAMETER IsFrontEndServer
    This server will be a front end server in an NLB

.NOTES  
    Name: Install-WSUSServer
    Author: Boe Prox
    DateCreated: 29NOV2011 
           
.LINK  
    https://learn-powershell.net
    
.EXAMPLE
Install-WSUSServer.ps1 -ConsoleOnly

Description
-----------
Installs the WSUS Console on the local system

.EXAMPLE
Install-WSUSServer.ps1 -ConsoleOnly -Computername Server1

Description
-----------
Installs the WSUS Console on the remote system Server1

.EXAMPLE
Install-WSUSServer.ps1 -Computername TestServer -StoreUpdatesLocally -ContentDirectory "D:\WSUS" -InternalDatabasePath "D:\" -CreateDatabase

Description
-----------
Installs WSUS server on TestServer and stores content locally on D:\WSUS and installs an internal database on D:\

.EXAMPLE
Install-WSUSServer.ps1 -Computername A24 -StoreUpdatesLocally -ContentDirectory "D:\WSUS" -SQLInstance "Server1\Server1" -CreateDatabase

Description
-----------
Installs WSUS server on TestServer and stores content locally on D:\WSUS and creates a database on Server1\Server1 SQL instance

.EXAMPLE
Install-WSUSServer.ps1 -Computername A24 -StoreUpdatesLocally -ContentDirectory "D:\WSUS" -SQLInstance "Server1\Server1"

Description
-----------
Installs WSUS server on TestServer and stores content locally on D:\WSUS and uses an existing WSUS database on Server1\Server1 SQL instance
#&gt; 
[cmdletbinding(
    DefaultParameterSetName = 'Console',
    SupportsShouldProcess = $True
)]
Param (
    [parameter(ValueFromPipeLine = $True)]
    [string]$Computername = $Env:Computername,
    [parameter(ParameterSetName = 'Console')]
    [switch]$ConsoleOnly,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [switch]$StoreUpdatesLocally,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [string]$ContentDirectory,
    [parameter(ParameterSetName = 'InternalDatabase')]
    [string]$InternalDatabasePath, 
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [ValidateSet("80","8530")]
    [string]$WebsitePort,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [switch]$CreateDatabase,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [string]$SQLInstance,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [switch]$IsFrontEndServer    
    
)
Begin {
    If (-NOT (Test-Path psexec.exe)) {
        Write-Warning ("Psexec.exe is not in the current directory! Please copy psexec to this location: {0} or change location to where psexec.exe is currently at.`nPsexec can be downloaded from the following site:`
        http://download.sysinternals.com/Files/SysinternalsSuite.zip" -f $pwd)
        Break
    }
    
    #Source Files for X86 and X64
    Write-Verbose "Setting source files"
    $x86 = Join-Path $pwd "WSUS30-KB972455-x86.exe"
    $x64 = Join-Path $pwd "WSUS30-KB972455-x64.exe"
        
    #Menu items for later use if required
    Write-Verbose "Building scriptblock for later use"
    $sb = {$title = "WSUS File Required"
    $message = "The executable you specified needs to be downloaded from the internet. Do you wish to allow this?"
    $yes = New-Object System.Management.Automation.Host.ChoiceDescription "&amp;Yes", `
        "Download the file."
    $no = New-Object System.Management.Automation.Host.ChoiceDescription "&amp;No", `
        "Do not download the file. I will download it myself."    
    $options = [System.Management.Automation.Host.ChoiceDescription[]]($yes, $no)
    Write-Verbose "Launching menu for file download"
    $Host.ui.PromptForChoice($title, $message, $options, 0)}             
    
    Write-Verbose "Adding URIs for installation files"
    #URI of specified files if needed to download        
    $WSUS_X86 = "http://download.microsoft.com/download/B/0/6/B06A69C3-CF97-42CF-86BF-3C59D762E0B2/WSUS30-KB972455-x86.exe"
    $WSUS_X64 = "http://download.microsoft.com/download/B/0/6/B06A69C3-CF97-42CF-86BF-3C59D762E0B2/WSUS30-KB972455-x64.exe"
    
    #Define Quiet switch first
    $arg = "/q "
    
    #Process parameters
    If ($PSBoundParameters['ConsoleOnly']) {
        Write-Verbose "Setting argument to Console Install Only"
        $arg += "CONSOLE_INSTALL=1 "
    }
    If ($PSBoundParameters['StoreUpdatesLocally']){
        $arg += "CONTENT_LOCAL=1 "
        If ($PSBoundParameters['ContentDirectory']) {
            $arg += "CONTENT_DIR=$ContentDirectory "
        }
    }
    If ($PSBoundParameters['WebsitePort']) {
            Switch ($WebsitePort) {
            "80" {
                $arg += "DEFAULT_WEBSITE=1 "
            }
            "8530" {
                $arg += "DEFAULT_WEBSITE=0 "
            }
            Default {
                $arg += "DEFAULT_WEBSITE=1 "
            }
        }
    }
    If ($PSBoundParameters['InternalDatabasePath']) {
        $arg += "WYUKON_DATA_DIR=$InternalDatabasePath "
    }
    If ($PSBoundParameters['CreateDatabase']) {
        $arg += "CREATE_DATABASE=1 "
    } ElseIf ($PSCmdlet.ParameterSetName -ne 'Console') {
        #Use default database
        $arg += "CREATE_DATABASE=0 "
    }
    If ($PSBoundParameters['SQLInstance']) {
        $arg += "SQLINSTANCE_NAME=$SQLInstance "
    }
    If ($PSBoundParameters['IsFrontEndServer']) {
        $arg += "FRONTEND_SETUP=1 "
    }
}
Process {
    Try {
        $OSArchitecture = Get-WmiObject Win32_OperatingSystem -ComputerName $Computername | Select -Expand OSArchitecture -EA Stop
    } Catch {
        Write-Warning ("{0}: Unable to perform lookup of operating system!`n{1}" -f $Computername,$_.Exception.Message)
    }  
    If ($OSArchitecture -eq "64-bit") {
        Write-Verbose ("{0} using 64-bit" -f $Computername)
        If (-NOT (Test-Path $x64)) {
            Write-Verbose ("{0} not found, download from internet" -f $x64)
            switch (&amp;$sb) {
                0 {
                    If ($pscmdlet.ShouldProcess($WSUS_X64,"Download File")) {
                        Write-Verbose "Configuring webclient to download file"
                        $wc = New-Object Net.WebClient
                        $wc.UseDefaultCredentials = $True              
                        Write-Host -ForegroundColor Green -BackgroundColor Black ("Downloading from {0} to {1} prior to installation. This may take a few minutes" -f $WSUS_X64,$x64)
                        Try {
                            $wc.DownloadFile($WSUS_X64,$x64)                                                                                    
                        } Catch {
                            Write-Warning ("Unable to download file!`nReason: {0}" -f $_.Exception.Message)
                            Break
                        } 
                    }                   
                }
                1 {
                    #Cancel action
                    Break
                }                
            }
        } 
        #Copy file to root drive
        If (-NOT (Test-Path ("\\$Computername\c$\{0}" -f (Split-Path $x64 -Leaf)))) {
            Write-Verbose ("Copying {0} to {1}" -f $x64,$Computername)
            If ($pscmdlet.ShouldProcess($Computername,"Copy File")) {                                
                Try {
                    Copy-Item -Path $x64 -Destination "\\$Computername\c$" -EA Stop
                } Catch {
                    Write-Warning ("Unable to copy {0} to {1}`nReason: {2}" -f $x64,$Computername,$_.Exception.Message)
                }
            }
        } Else {Write-Verbose ("{0} already exists on {1}" -f (Split-Path $x64 -Leaf),$Computername)}
        #Perform the installation
        Write-Verbose ("Begin installation on {0} using specified options" -f $Computername)
        If ($pscmdlet.ShouldProcess($Computername,"Install WSUS")) {
            .\psexec.exe -accepteula -i -s \\$Computername cmd /c ("C:\{0} $arg" -f (Split-Path $x64 -Leaf))                                
        }
    } Else {
        Write-Verbose ("{0} using 32-bit" -f $Computername)
        If (-NOT (Test-Path $x86)) {
            Write-Verbose ("{0} not found, download from internet" -f $x86)
            switch (&amp;$sb) {
                0 {
                    If ($pscmdlet.ShouldProcess($WSUS_X86,"Download File")) {
                        Write-Verbose "Configuring webclient to download file"
                        $wc = New-Object Net.WebClient
                        $wc.UseDefaultCredentials = $True              
                        Write-Host -ForegroundColor Green -BackgroundColor Black ("Downloading from {0} to {1} prior to installation. This may take a few minutes" -f $WSUS_X86,$x86)
                        Try {
                            $wc.DownloadFile($WSUS_X86,$x86)                                                                                          
                        } Catch {
                            Write-Warning ("Unable to download file!`nReason: {0}" -f $_.Exception.Message)
                            Break
                        }
                    }                    
                }
                1 {
                    #Cancel action
                    Break
                }                                
            }
        }
        #Copy file to root drive
        If (-NOT (Test-Path ("\\$Computername\c$\{0}" -f (Split-Path $x86 -Leaf)))) {
            Write-Verbose ("Copying {0} to {1}" -f $x86,$Computername) 
            If ($pscmdlet.ShouldProcess($Computername,"Copy File")) {
                Try {
                    Copy-Item -Path $x86 -Destination "\\$Computername\c$" -EA Stop
                } Catch {
                    Write-Warning ("Unable to copy {0} to {1}`nReason: {2}" -f $x86,$Computername,$_.Exception.Message)
                }
            }
        } Else {Write-Verbose ("{0} already exists on {1}" -f $x86,$Computername)}
        #Perform the installation
        Write-Verbose ("Begin installation on {0} using specified options" -f $Computername)
        If ($pscmdlet.ShouldProcess($Computername,"Install WSUS")) {
            .\psexec.exe -accepteula -i -s \\$Computername cmd /c ("C:\{0} $arg" -f (Split-Path $x86 -Leaf))
        }
    }   
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>profile_Locations</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>profile_Locations</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Question How can I find the path to Windows PowerShell profile locations on my computer?

' Answer Use the –Force parameter from Format-List to display the hidden properties and values:

$PROFILE | Format-List -Force</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Sample_Profile_3__MenuModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Sample_Profile_3__MenuModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' MenuModule.psm1
#' ed wilson

Function Get-Fonts
{
#'modified function based upon comment by Tome Tanasovski made on blog
#'
 Param($fontSize = 16,  
 $milliSecs = 500 
) 
$font = $psISE.Options.FontName 
$size = $psISE.Options.FontSize 
$lastfont = $psISE.Options.FontName
[windows.media.fonts]::systemTypeFaces |
Select-Object -Property fontFamily |
ForEach-Object { 
 if ($_.fontFamily.source -ne $psISE.Options.FontName) 
  { 
   $_.fontFamily.source 
   $psISE.Options.FontName = $_.fontFamily.source 
   $psISE.Options.FontSize = $fontSize 
   Start-Sleep -Milliseconds $millisecs 
  } #'end if
} #'end foreach-object 
$psise.options.FontName = $font 
$psISE.Options.FontSize = $size 
} #'end function get-fonts

Function Get-PsIseColorValues
{
 #' wes-8-28-10
 [windows.media.colors] | Get-Member -Static -MemberType property |  
 ForEach-Object {  
 $psISE.Options.OutputPaneTextBackgroundColor =
   ([windows.media.colors]::$($_.name)).tostring()  
 "$($_.name) `t $([windows.media.colors]::$($_.name))"}
 } #'end function Get-PsISEColorValues
 
 Function Set-PsISE
 {
  #' Set-PsISEcolorsAndFont.ps1
 #' fonts
 $psISE.Options.FontName = 'Kartika' 
 $psISE.Options.FontSize = 16
 # output pane
 $psISE.Options.OutputPaneBackgroundColor = '#FFFFEFD5' 
 $psISE.Options.OutputPaneTextBackgroundColor = '#FFFFEFD5' 
 $psISE.Options.OutputPaneForegroundColor = '#FF000000' 
 #' command pane
 $psISE.Options.CommandPaneBackgroundColor = '#FFFAEBD7' 
 #' script pane
 $psISE.Options.ScriptPaneBackgroundColor = '#FFFAEBD7' 
 #' tokens
 $psISE.Options.TokenColors.item('Command') = '#FFA0522D' 
 $psISE.Options.TokenColors.item('Operator') = '#FFA0522D' 
 $psISE.Options.TokenColors.item('Unknown') = '#FFFFFFFF' 
 $psISE.Options.TokenColors.item('Member') = '#FFFFFFFF' 
 $psISE.Options.TokenColors.item('Position') = '#FFFFFFFF' 
 $psISE.Options.TokenColors.item('GroupEnd') = '#FFFFFFFF' 
 $psISE.Options.TokenColors.item('GroupStart') = '#FFFFFFFF' 
 $psISE.Options.TokenColors.item('LineContinuation') = '#FFFFFFFF' 
 $psISE.Options.TokenColors.item('NewLine') = '#FFFFFFFF' 
 $psISE.Options.TokenColors.item('StatementSeparator') = '#FFFFFFFF' 
 $psISE.Options.TokenColors.item('Comment') = '#FFAEAEAE' 
 $psISE.Options.TokenColors.item('String') = '#A2BC13' 
 $psISE.Options.TokenColors.item('Keyword') = '#FFFFDE00' 
 $psISE.Options.TokenColors.item('Attribute') = '#FF84A7C1' 
 $psISE.Options.TokenColors.item('Type') = '#FF84A7C1' 
 $psISE.Options.TokenColors.item('Variable') = '#EE9A00' 
 $psISE.Options.TokenColors.item('CommandParameter') = '#FFFFDE00' 
 $psISE.Options.TokenColors.item('CommandArgument') = '#FFFFFFFF' 
 $psISE.Options.TokenColors.item('Number') = '#FF4169E1' 
 $psISE.Options.TokenColors.item('LoopLabel') = '#FF4169E1' 
} #'end function Set-PsISE 

Function Add-MenuItems
{
 #'add-menuitems.ps1
#' wes-9-4-10
#' this also adds support for Snippets
$RestoreRoot = $psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add( 
   "Restore",$null,$null) 
$RestoreRoot.Submenus.Add("RestoreALLDefaults",  
 {$psISE.Options.RestoreDefaults()}, "Ctrl+Alt+R") | out-null
$RestoreRoot.SubMenus.Add("RestoreTokenColorDefaults",  
 {$psISE.Options.RestoreDefaultTokenColors()}, "Ctrl+Alt+T") | out-null

$GetOptions = $psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add( 
   "GetOptions",$null,$null)  
$GetOptions.SubMenus.Add("GetFonts", { Get-fonts -milliseconds 100 },$null) | out-null
$GetOptions.SubMenus.Add("GetColors", { Get-PsIseColorValues },$null) | out-null
#'these lines add snippet support
$CodeSnippets = $psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add( 
"CodeSnippets",$null,$null)
$CodeSnippets.Submenus.Add("BrowseSnippet",
{Get-CodeSnippetV2 -initialDirectory $snipHome}, "Ctrl+Alt+B") | out-null
$CodeSnippets.SubMenus.Add("AddSnippet",
{Get-CodeSnippetV2 -initialDirectory $snipHome -add}, "Ctrl+Alt+A") |out-null
#'end snippet support
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add("MyCustomISE", { Set-PsISE },$null) | out-null
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add("ClearMenu",  
   { $psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Clear() }, $null) |out-null
} #'end function Add-MenuItems</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>.NET registry classes</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>.NET registry classes</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
====================================================================================================
https://social.technet.microsoft.com/Forums/office/en-US/0835c303-2edd-4c06-bbc9-5c7952402d0c/powershell-to-get-the-registry-key-value-from-remote-server-with-txt-file?forum=winserverpowershell
Here is how to get remote key values.
---------------------------------------------------
$key = 'SYSTEM\CurrentControlSet\Control\Lsa'
$valuename = 'Security Packages'
$computers = Get-Content Servers.txt
foreach ($computer in $computers) {
	$reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $computer)
	$regkey = $reg.opensubkey($key)
	$regkey.getvalue($valuename)
}
-------------------------------------------------
'My working example for this key: 
'Computer\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\AccessProviders
'	   Name; MartaExtension, Type: REG_SZ, Data: ntmarta.dll

$key = 'SYSTEM\CurrentControlSet\Control\Lsa\AccessProviders'
$valuename = 'MartaExtension'
	$reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', 'IT-103520')
	$regkey = $reg.opensubkey($key)
	$regkey.getvalue($valuename)


====================================================================================================
You can use .net registry classes See this link:https://msdn.microsoft.com/en-us/library/microsoft.win32.registrykey.aspx

2) You can use .net registry classes See this link: http://msdn.microsoft.com/en-us/library/microsoft.win32.registrykey.aspx

$registry = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', 'RemoteComputerName')
$registryKey= $registry.OpenSubKey("Software")

====================================================================================================
https://itfordummies.net/2016/09/06/read-remote-registry-powershell/

'you need use the “Microsoft.Win32.RegistryKey” .Net class.

'First, prepare some variables for later use :

		$ComputerName = 'DC2-Core'
		$Hive = 'LocalMachine'
		$KeyPath = 'SOFTWAREMicrosoftNotepadDefaultFonts'
		$Value = 'iPointSize'

'Then, create the RegistryKey object :

$reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey("$hive", "$ComputerName")

'Use the “OpenRemoteBaseKey” method :

$key = $reg.OpenSubKey("$KeyPath")


'And finally, get the value :

$key.GetValue($Value)

-----------------------------------

So here are, all the lines together:

$ComputerName = 'DC2-Core'
$Hive = [Microsoft.Win32.RegistryHive]::LocalMachine
$KeyPath = 'SOFTWAREMicrosoftNotepadDefaultFonts'
$Value = 'iPointSize'

$reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($Hive, $ComputerName)
$key = $reg.OpenSubKey($KeyPath)

$key.GetValue($Value)
====================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Registry</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Registry</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Registry

"Registry Keys" are like folders

"registry key property" are the non-folders, inside the existing folders

"registry key property values" is the value of the "registry key property"

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>if_you_need_users_SID</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>if_you_need_users_SID</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'If you need user's SID and browse remote HKEY_USERS folder, you can follow this script :

'&lt;# Replace following domain.name with yours and userAccountName with remote username #&gt;
$userLogin = New-Object System.Security.Principal.NTAccount(“domain.name“,”userAccountName“)
$userSID = $userLogin.Translate([System.Security.Principal.SecurityIdentifier])

'&lt;# We will open HKEY_USERS and with accurate user’s SID from remoteComputer #&gt;
$remoteRegistry = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey(‘Users’,”remoteComputer“)

'&lt;# We will then retrieve LocalName value from Control Panel / International subkeys #&gt;

$key = $userSID.value+”\Control Panel\International”
$openKey = $remoteRegistry.OpenSubKey($key)

'&lt;# We can now retrieve any values #&gt;

$localName = $openKey.GetValue(‘LocaleName’)
Source : http://techsultan.com/how-to-browse-remote-registry-in-powershell/</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Testing for the Presence of a Registry Key and Value</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Testing for the Presence of a Registry Key and Value</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://www.jonathanmedd.net/2014/02/testing-for-the-presence-of-a-registry-key-and-value.html

#' Test for existance of key (returns True if the path exists)
Invoke-Command -ComputerName IT-103520 -ScriptBlock { Test-Path HKLM:\Software\Microsoft\WindowsStore }

#' The test above does not test for values within a key THIS DOES NOT WORK, IT RETURNS FALSE INFORMATION
Invoke-Command -ComputerName IT-103520 -ScriptBlock { Test-Path HKLM:\Software\Microsoft\WindowsStore\RemoveWindowsStore}

============================================================================================================================USAGE: on local machine
#' This tests for the string value "zJunk" 
#' under the key path "HKLM:\Software\Microsoft\WindowsStore"
#' But it does not examine the actual string value for "zJunk"
function Test-RegistryValue_4 {
								param (							
										 [parameter(Mandatory=$true)]
										 [ValidateNotNullOrEmpty()]$Path,							
										[parameter(Mandatory=$true)]
										 [ValidateNotNullOrEmpty()]$Value
										)							
                                $c = 0
                                Get-Item -Path $Path | Select-Object -ExpandProperty property | ForEach-Object { 
                                                                                                                    if ($_ -match $Value) 
                                                                                                                        { $c=1 ; return $true} 
                                                                                                                }
                                if ($c -eq 0) 
                                    {return $false}
						
							}
====USAGE: on local machine

Test-RegistryValue_4 -Path 'HKLM:\Software\Microsoft\WindowsStore' -Value 'zJunk'

#' Returns False if the key is NOT there, and True if it is (even if the key itself does not have a value)
====================================================================================================
============================================================================================================================USAGE: on Remote machine

Invoke-Command -ComputerName IT-103520 -ScriptBlock {

                                                        function Test-RegistryValue_4 {
								                                                        param (							
										                                                         [parameter(Mandatory=$true)]
										                                                         [ValidateNotNullOrEmpty()]$Path,							
										                                                        [parameter(Mandatory=$true)]
										                                                         [ValidateNotNullOrEmpty()]$Value
										                                                        )							
                                                                                        $c = 0
                                                                                        Get-Item -Path $Path | Select-Object -ExpandProperty property | ForEach-Object { 
                                                                                                                                                                            if ($_ -match $Value) 
                                                                                                                                                                                { $c=1 ; return $true} 
                                                                                                                                                                        }
                                                                                        if ($c -eq 0) 
                                                                                            {return $false}
						
							                                                        };
                                                        Test-RegistryValue_4 -Path 'HKLM:\Software\Microsoft\WindowsStore' -Value Junk
                                                        #'Test-RegistryValue_4 -Path 'HKLM:\Software\Microsoft\WindowsStore' -Value RemoveWindowsStore
                                                    }

=================================================================


							
============================================================================================================================							</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting__Invoke-Command</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Include local variables in a command run on a remote computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting__Invoke-Command</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Include local variables in a command run on a remote computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command?view=powershell-6

#'    This example shows how to include the values of local variables 
#'        in a command run on a remote computer. 
#'        The command uses the Using scope modifier to identify a local variable in a remote command. 
#'        By default, all variables are assumed to be defined in the remote session. 
#'        The Using scope modifier was introduced in Windows PowerShell 3.0. 
#'        For more information about the Using scope modifier, see about_Remote_Variables (http://go.microsoft.com/fwlink/?LinkID=252653).


#'    The first command stores the name of the Microsoft-Windows-Forwarding/Operational event log in the $MWFO_Log variable.
#'
PS C:\&gt; $MWFO_Log = "Microsoft-Windows-Forwarding/Operational"

#'    The second command uses the Invoke-Command cmdlet to run a Get-EventLog command 
#'        on the Server01 remote computer that gets the 10 newest events from the Microsoft-Windows-Forwarding/Operational event log on Server01. 
#'        The value of the LogName parameter is the $MWFO_Log variable, 
#'            which is prefixed by the Using scope modifier to indicate that it was created in the local session, not in the remote session.

PS C:\&gt; Invoke-Command -ComputerName Server01 -ScriptBlock {Get-EventLog -LogName $Using:MWFO_Log -Newest 10}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting__Invoke-Command</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>return_value_from_Invoke-Command</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting__Invoke-Command</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>return_value_from_Invoke-Command</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'https://stackoverflow.com/questions/8549184/how-to-capture-the-return-value-of-a-scriptblock-invoked-with-powershells-invok

#' This looks promising

$script = {
    # Call exe and combine all output streams so nothing is missed
    $output = ping badhostname *&gt;&amp;1

    # Save lastexitcode right after call to exe completes
    $exitCode = $LASTEXITCODE

    # Return the output and the exitcode using a hashtable
    New-Object -TypeName PSCustomObject -Property @{Host=$env:computername; Output=$output; ExitCode=$exitCode}
}

# Capture the results from the remote computers
$results = Invoke-Command -ComputerName host1, host2 -ScriptBlock $script

$results | select Host, Output, ExitCode | Format-List

------------------------------------------------------------------------------------------------------

'https://stackoverflow.com/questions/1210942/catching-return-code-of-a-command-with-invoke-command-powershell-2

#'Remote script:

try {
    ... go do stuff ...
} catch {
    return 1
    exit
}
return 2
exit


#'Local script:

function RunRemote {
    param ([string]$remoteIp, [string]$localScriptName)
    $res = Invoke-Command -computername $remoteIp -UseSSL -Credential $mycreds -SessionOption $so -FilePath $localScriptName
    return $res
}

$status = RunRemote $ip_name ".\Scripts\myRemoteScript.ps1"
echo "Return status was $status"

#' $so, -UseSSL and $mycreds aren't needed if you're fully inside a trust group. This seems to work for me... good luck!
--------------------------------------------------------------------------------

'https://social.technet.microsoft.com/Forums/en-US/9a55ea6f-d20a-436a-924d-399d84962574/get-a-return-value-from-invokecommand?forum=winserverpowershell
$Result = Invoke-Command -ComputerName &lt;&lt;Server&gt;&gt; -ScriptBlock {

Import-Module SQLPS -DisableNameChecking

$DBState = Invoke-SQLCmd "Select state_desc from master.sys.databases where name = '&lt;&lt;DBName&gt;&gt;'" -ServerInstance "DMZWG1" -UserName sa -Password &lt;&lt;Password&gt;&gt;

Return $DBState # you shouldn't even need Return
}

$Result


------------------------------------------------------
#'Invoke-Command returns to you what is printed to the end of the pipeline.
#'If you want to return a variable you should Return &lt;variable&gt; like:

$ret = Invoke-Command -ScriptBlock { $var="test string"; return $var; }
#'where $ret contains now the value test string.
------------------------------------------------------ MULTIPLE values

#'When you got multiple variables you want to return, then you can join them into a single variable, e.g. like this:

$str1 = "test"
$str2 = "123"
$combinedObjs = New-Object PSObject -Property @{1 = $str1; 2 = $str2}

#'Now you can combine it all

$ret = Invoke-Command -ScriptBlock { 
  $str1 = "test";
  $str2 = "123";
  $combinedObjs =  @{val1 = $str1; val2 = $str2};
  Return $combinedObjs;
}

#'now $ret contains

Name                           Value
----                           -----
val1                           test
val2                           123

#'and you can access them by calling $ret.val1 or $ret.val2

--------------------------------------------------------------------------------
https://stackoverflow.com/questions/49361404/append-to-a-variable-from-invoke-command

#' Add some output to the very end of given scriptblock, e.g.

    @{  BodyContent = $BodyContent
        ErrorStat   = $ErrorStat
    }
#' If you use e.g.

$result = Invoke-Command -ScriptBlock { 

    ###  original script block body here

    @{  BodyContent = $BodyContent
        ErrorStat   = $ErrorStat
    }
}  -ComputerName $server -Credential $user -ErrorAction Stop

#' then you can check

$result.BodyContent
$result.ErrorStat
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>custom_Get-MachineInfo_with_Help_and_ErrorHandling_and_LogFile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>custom_Get-MachineInfo_with_Help_and_ErrorHandling_and_LogFile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            # Did we specify protocol fallback?
            # If so, try again. If we specified logging,
            # we won't log a problem here - we'll let
            # the logging occur if this fallback also
            # fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #if logging

                Get-MachineInfo @params
            } #if protocolfallback

            # if we didn't specify fallback, but we
            # did specify logging, then log the error,
            # because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } # if write to log

        } #try/catch
 
    } #foreach
} #PROCESS

END {}

} #function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Limit_which_IP_Addresses_powershell_is_listening_on</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Limit_which_IP_Addresses_powershell_is_listening_on</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'This gets the listner info
&gt; winrm e winrm/config/listener



&gt;New-WSManInstance winrm/config/Listener SelectorSet@{Address="IP:192.168.100.2";

'Remove a listener
&gt;Remove-WSManInstance -ResourceUri winrm/config/Listener -SelectorSet 
    Address=test.fabrikam.com;Transport=http

'Create a new listener
&gt;New-WSManInstance winrm/config/Listener -SelectorSet @{Address="IP:xxx.xxx.xxx.xxxx";Transport="HTTPS"} -ValueSet @{HostName='xxxxxxxxxxxx.xxxxxxxxxxx.xxxx';CertificateThumbprint='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'}

'Check listener configuration:
&gt; winrm e winrm/config/listener

'Disable a listener on the local computer
'Important: The ValueSet parameter is case-sensitive when matching the properties specified.
&gt; set-wsmaninstance -ResourceUri winrm/config/listener -SelectorSet @{address="*";transport="https"} -ValueSet @{Enabled="false"}

'THIS DID NOT WORK, it may have problems with specifying a single IP address
&gt; set-wsmaninstance -ResourceUri winrm/config/listener -SelectorSet @{address="169.254.53.69";transport="http"} -ValueSet @{Enabled="false"}


'Disable a listener on a remote computer
Set-WSManInstance -ResourceUri winrm/config/listener -ComputerName "SERVER02" -SelectorSet @{address="*";transport="https"} -ValueSet @{Enabled="false"}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>TrustedHosts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>TrustedHosts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

http://windowsitpro.com/windows/modify-trustedhosts-powershell


'to set TrustedHosts to every machine in your domain namespace use:

&gt;Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value '*.savilltech.net'

'To set to have no trusted hosts use:

Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value ''

'To avoid the prompt to make the change add -Force, for example:

Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value '' -Force


'To read the list:
 &gt;ls WSMan:\localhost\Client\TrustedHosts
 'OR
 &gt;Get-WSManInstance -ResourceURI winrm/config/client | select -ExpandProperty TrustedHosts
 =================================
 Set-Item WSMan:\localhost\Client\TrustedHosts -value 192.168.1.13
#'This sets the value to 192.168.1.13, it also overwrites any existing values
  

#' If you want to set a subnet you can use the PowerShell wildcard character
Set-Item WSMan:\localhost\Client\TrustedHosts -value 192.168.1.*  
  
#' both the examples above will overwrite the current value of the trustedhosts property
#' to add to instead of overwriting you need to use the concatenate dynamic parameter available in the WSMAN provider
#' Thanks to @alexandair for that bit of info

set-item WSMan:\localhost\Client\TrustedHosts -Value "192.168.0.*" -Concatenate
 =================================
 'multiple machines
 
 'a] 
 &gt;winrm set winrm/config/client '@{TrustedHosts="machineA,machineB"}'
 'if anyone gets an Error: Invalid use of command line ... response, try removing the single quotation marks
  
 'b] 
 &gt; Set-Item WSMan:\localhost\Client\TrustedHosts -Value 'machineA,machineB'

'to append to the list, the -Concatenate parameter can be used

Set-Item WSMan:\localhost\Client\TrustedHosts -Value 'machineC' -Concatenate

'c]
PS C:\&gt; $current=(get-item WSMan:\localhost\Client\TrustedHosts).value
PS C:\&gt; $current+=",testdsk23,alpha123"
PS C:\&gt; set-item WSMan:\localhost\Client\TrustedHosts –value $current
  =================================
 
 'The function has a single parameter – the computername that defaults to the local machine.
 function get-trustedhost {

	[CmdletBinding()]
	
	param (
	
			[string]$computername = $env:COMPUTERNAME
			
			)
	
	if (Test-Connection -ComputerName $computername -Quiet -Count 1) {
	
			Get-WSManInstance -ResourceURI winrm/config/client -ComputerName $computername | select -ExpandProperty TrustedHosts
	
	}
	
	else {
	
	Write-Warning -Message “$computername is unreachable”
	
	}

}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_RestorePoint</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_RestorePoint</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_RestorePoint</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_RestorePoint</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_RestorePoint

'As far as I know a restorepoint is a copy of the registry at a specific date and time. 
'Restoring it will set things back to those settings.


'The other critical point to know when using Checkpoint-Computer cmdlet 
'	is that you can only create a restore point with this cmdlet once every 24 hours. 

'The first thing you might need to do is enable system restore:

&gt; Enable-ComputerRestore -drive "c:\"

'To view existing restore points, use the Get-ComputerRestorePoint cmdlet:

&gt; Get-ComputerRestorePoint | Out-GridView

create one using the Checkpoint-Computer cmdlet:

&gt; Checkpoint-Computer -description "My first checkpoint" -restorepointtype "Modify_Settings"

&gt;Get-ComputerRestorePoint | format-list

'To restore:
&gt; Restore-Computer -RestorePoint 59  '( do the restore, which will automatically reboot the computer:)


APPLICATION_INSTALL  (The default restore point type is APPLICATION_INSTALL)
An application has been installed.

APPLICATION_UNINSTALL
An application has been uninstalled.

DEVICE_DRIVER_INSTALL
A device driver has been installed.

MODIFY_SETTINGS
An application has had features added or removed.

CANCELLED_OPERATION
An application needs to delete the restore point it created. For example, an application would use this flag when a user cancels an installation.



What exactly does System Restore restore and not restore?
==========================================================
Restored:

Registry (note: some current values will persist)
Profiles (local only—roaming user profiles not impacted by restore)
COM+ DB
WFP.dll cache
WMI DB
IIS Metabase
Files with extensions listed in the Monitored File Extensions list
Not Restored:

DRM settings
SAM hives (does not restore passwords)
WPA settings (Windows authentication information is not restored)
Contents of the My Documents folder(s)
Specific directories/files listed in the Monitored File Extensions list
Any file with an extension not listed in the Monitored File Extensions list
Items listed in both Filesnottobackup and KeysnottoRestore (HKLM-&gt;System-&gt;ControlSet001-&gt;Control-&gt;BackupRestore-&gt;Filesnottobackup and keysnottorestore)
User-created data stored in the user profile
Contents of redirected folders</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Security</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_and_Set__Execution_Policy</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Security</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_and_Set__Execution_Policy</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Get-ExecutionPolicy

#-----------------------------------------------------------------------------#
# Note: In order to alter Execution Policy, you must be running as Admin
#-----------------------------------------------------------------------------#

&lt;# 
  Four possible values:
  Restricted   - No scripts can be run. User can only use PS interactively.
  AllSigned    - All scripts must be code signed
  RemoteSigned - All scripts marked as unsafe (i.e. downloaded from the
                 internet or network share) must be signed. Local scripts
                 can be run without signing.
  Unrestricted - All scripts can be run, regardless of where it came from
                 and whether or not they are signed. 

  In addition these can have scope.
  MachinePolicy - Applies to all users on the machine. Must be set via 
                  Group Policy.
  UserPolicy    - Applies to the current user. Again, must be done via
                  Group Policy.
  Process       - Applies only to the current process. Once the process 
                  completes (i.e. the PS window is closed) the previous
                  setting is restored.
  CurrentUser   - Setting is only valid for this user. 
  LocalMachine  - Setting is valid for all users of this computer. 

  Best practice suggests only enabling script execution if you need it. 
  Then, set to RemoteSigned so you can run the scripts you develop but
  will have some protection from malicious scripts from the web.
#&gt;

# With Restricted Policy, can't run script
Set-ExecutionPolicy -ExecutionPolicy Restricted -Scope CurrentUser 
. 'C:\PS\Beginning PowerShell Scripting for Developers\demo\bpsd-m06-do-something.ps1'

# With RemoteSigned we can run our script
Set-Location 'C:\PS\Beginning PowerShell Scripting for Developers\demo\'
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 
. '.\bpsd-m06-do-something.ps1'

# With Unrestricted we can run anything
Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser 

Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope LocalMachine
$doSomething = 'C:\PS\Beginning PowerShell Scripting for Developers\demo\bpsd-m06-do-something.ps1'
. $doSomething
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Serialize</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Persist_to_XML_file_and_then_recover_from_file</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Serialize</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Persist_to_XML_file_and_then_recover_from_file</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#'
#' Demo 11 - Serializing an Object
#'           i.e. Persist the values inside an object between executions of script
#'-----------------------------------------------------------------------------#'

  #' Create a simple object
  $mySiteProperties = [ordered]@{ 
                                  WebSite = 'ArcaneCode'
                                  URL = 'http://arcanecode.com'
                                  Twitter = '@ArcaneCode'
                                }

  #' Convert the set of properties to an object
  $mySite = New-Object –TypeName PSObject -Property $mySiteProperties
  
  #' Show the object
  $mySite
  
  #' Save the object to a file and 
  $savedDataFile = 'C:\JUNK\mySite.xml'
  $mySite | Export-Clixml $savedDataFile

  #'==========OUPUT FILE ==========================================================
  &lt;Objs Version="1.1.0.1" xmlns="http://schemas.microsoft.com/powershell/2004/04"&gt;
  &lt;Obj RefId="0"&gt;
    &lt;TN RefId="0"&gt;
      &lt;T&gt;System.Management.Automation.PSCustomObject&lt;/T&gt;
      &lt;T&gt;System.Object&lt;/T&gt;
    &lt;/TN&gt;
    &lt;MS&gt;
      &lt;S N="WebSite"&gt;ArcaneCode&lt;/S&gt;
      &lt;S N="URL"&gt;http://arcanecode.com&lt;/S&gt;
      &lt;S N="Twitter"&gt;@ArcaneCode&lt;/S&gt;
    &lt;/MS&gt;
  &lt;/Obj&gt;
&lt;/Objs&gt;
#'==========OUPUT FILE ==========================================================

#' This opens it up in PowerShell IDE
  psedit $savedDataFile 

  #' Now grab the saved object and recreate in a different variable
  $newMySite = Import-Clixml $savedDataFile
  $newMySite

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SQL</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>from_PowerShell_TrainingClass</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SQL</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>from_PowerShell_TrainingClass</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' create a connection
```PowerShell
$conn = New-Object -Type System.Data.SqlClient.SqlConnection
$conn.ConnectionString = 'Server=SQL1;Database=MyDB;Trusted_Connection=True;'
$conn.Open()
```
#'You can leave the connection open for your entire script; 
'	`be sure to run $conn.Close() when you’re done, though. 
'	It’s not a tragedy to not close the connection; 
'	when your script ends, the connection object will vanish, 
'	and SQL Server will automatically close the connection a bit later. 


'We always put our query in a variable, because that makes it easy to output the query text by using Write-Verbose. 
'	That’s a great way to debug queries that aren’t working, 
'	since you get to see the actual query text with all the variables “filled-in.” 



#' for an Instance Connection:
Server=SERVER\INSTANCE;Database=DATABASE;Trusted_Connected=True;


#' INSERT model
INSERT INTO &lt;tablename&gt;
    (Column1, Column2, Column3)
    VALUES (Value1, Value2, Value3)


#' INSERT example
$ComputerName = "SERVER2"
$OSVersion = "Win2012R2"
$query = "INSERT INTO OSVersion (ComputerName,OS) VALUES('$ComputerName','$OSVersion')"



#' DELETE model
DELETE FROM &lt;tablename&gt; WHERE &lt;criteria&gt;


#' DELETE example
$query = "DELETE FROM OSVersions WHERE ComputerName = '$ComputerName'"



#' UPDATE model
UPDATE &lt;tablename&gt;
   SET &lt;column&gt; = &lt;value&gt;, &lt;column&gt; = &lt;value&gt;
   WHERE &lt;criteria&gt;


#' UPDATE example
$query = "UPDATE DiskSpaceTracking `
          SET FreeSpaceOnSysDrive = $freespace `
          WHERE ComputerName = '$ComputerName'"



#' SELECT model
SELECT &lt;column&gt;,&lt;column&gt;
       FROM &lt;tablename&gt;
       WHERE &lt;criteria&gt;
       ORDER BY &lt;column&gt;


#' SELECT example
$query = "SELECT DiskSpace,DateChecked `
          FROM DiskSpaceTracking `
          WHERE ComputerName = '$ComputerName' `
          ORDER BY DateChecked DESC"



#' CREATE TABLE model
CREATE TABLE &lt;tablename&gt; (
    &lt;column&gt; &lt;type&gt;,
    &lt;column&gt; &lt;type&gt;
)



#' Set up to run a query '&lt;==================================================== RUN QUERY
$command = New-Object -Type System.Data.SqlClient.SqlCommand
$command.Connection = $conn
$command.CommandText = $query



#' Run INSERT/UPDATE/DELETE '&lt;==================================================== RUN ExecuteNonQuery
$command.ExecuteNonQuery()



#' Run SELECT '&lt;===================================================  SELECT
$reader = $command.ExecuteReader()



#' Read through rows
while ($reader.read()) {
  #'do something with the data
}



#' Full example   '&lt;===========================================================  FULL EXAMPLE     
$conn = New-Object -Type System.Data.SqlClient.SqlConnection
$conn.ConnectionString = 'Server=SQL1;Database=MyDB;Trusted_Connection=True;'
$conn.Open()

$query = "SELECT ComputerName,DiskSpace,DateTaken FROM DiskTracking"

$command = New-Object -Type System.Data.SqlClient.SqlCommand
$command.Connection = $conn
$command.CommandText = $query
$reader = $command.ExecuteReader()

while ($reader.read()) {
    [psobject]$props = @{'ComputerName' = $reader.GetValue(0)
                         'DiskSpace' = $reader.GetValue(1)
                         'DateTaken' = $reader.GetValue(2)
                        }
}

$conn.Close()



#' Let it figure out ordinals for you
while ($reader.read()) {
    [psobject]$props = @{
    'ComputerName' = $reader.GetValue($reader.getordinal("computername"))
    'DiskSpace' = $reader.GetValue($reader.getordinal("diskspace"))
    'DateTaken' = $reader.GetValue($reader.getordinal("datetaken"))
    }
}




#' Invoke-Sqlcmd    '&lt;===========================================================  SQLCMD
Invoke-Sqlcmd "Select Computername,Diskspace,DateTaken from DiskTracking" `
-Database MyDB



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_AdAccountManagementAutomator.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_AdAccountManagementAutomator.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function New-EmployeeOnboardUser {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to perform all routine
		tasks that must be done when onboarding a new employee user account.
	.EXAMPLE
		PS&gt; New-EmployeeOnboardUser -FirstName 'adam' -MiddleInitial D -LastName Bertram -Title 'Dr. Awesome'
	
		This example creates an AD username based on company standards into a company-standard OU and adds the user
		into the company-standard main user group.
	.PARAMETER FirstName
	 	The first name of the employee
	.PARAMETER MiddleInitial
		The middle initial of the employee
	.PARAMETER LastName
		The last name of the employee
	.PARAMETER Title
		The current job title of the employee
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Firstname,
		[string]$MiddleInitial,
		[string]$LastName,
		[string]$Location = 'OU=Corporate Users',
		[string]$Title
	)
	process {
		## Not the best use of storing the password clear text
		## Google/Bing on using stored secure strings on the file system as a way to get around this
		$DefaultPassword = 'p@$$w0rd12'
		$DomainDn = (Get-AdDomain).DistinguishedName
		$DefaultGroup = 'Gigantic Corporation Inter-Intra Synergy Group'
			
		$Username = "$($FirstName.SubString(0, 1))$LastName"
		## Check if an existing user already has the first intial/last name username taken
		try {
            if (Get-ADUser $Username) {
				## If so, check to see if the first initial/middle initial/last name is taken.
				$Username = "$($FirstName.SubString(0, 1))$MiddleInitial$LastName"
				if (Get-AdUser $Username) {
					throw "No acceptable username schema could be created"
				}
			}
		} catch {
            Write-Error $_.Exception.Message
        }
		$NewUserParams = @{
            'UserPrincipalName' = $Username
            'Name' = $Username
            'GivenName' = $FirstName
            'Surname' = $LastName
            'Title' = $Title
            'SamAccountName' = $Username
            'AccountPassword' = (ConvertTo-SecureString $DefaultPassword -AsPlainText -Force)
            'Enabled' = $true
            'Initials' = $MiddleInitial
            'Path' = "$Location,$DomainDn"
            'ChangePasswordAtLogon' = $true
        }
			
		New-AdUser @NewUserParams
		Add-ADGroupMember $Username $DefaultGroup
        $Username
	}
}

function Set-MyAdUser {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to modify
		one or more Active Directory attributes on a single Active Directory user account.
	.EXAMPLE
		PS&gt; Set-MyAdUser -Username adam -Attributes @{'givenName' = 'bob'; 'DisplayName' = 'bobby bertram'; 'Title' = 'manager'}
	
		This example changes the givenName to bob, the display name to 'bobby bertram' and the title to 'manager' for the username 'adam'
	.PARAMETER Username
	 	An Active Directory username to modify
	.PARAMETER Attributes
		A hashtable with keys as Set-AdUser parameter values and values as Set-AdUser parameter argument values
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Username,
		[hashtable]$Attributes
	)
	process {
		try {
			## Attempt to find the username
			$UserAccount = Get-AdUser -Identity $Username
			if (!$UserAccount) {
				## If the username isn't found throw an error and exit
				#Write-Error "The username '$Username' does not exist"
				throw "The username '$Username' does not exist"
			}
			
			## The $Attributes parameter will contain only the parameters for the Set-AdUser cmdlet other than
			## Password.  If this is in $Attributes it needs to be treated differently.
			if ($Attributes.ContainsKey('Password')) {
				$UserAccount | Set-ADAccountPassword -Reset -NewPassword (ConvertTo-SecureString -AsPlainText $Attributes.Password -Force)
				## Remove the password key because we'll be passing this hashtable directly to Set-AdUser later
				$Attributes.Remove('Password')
			}
			
			$UserAccount | Set-AdUser @Attributes
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}

function Set-MyAdComputer {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to modify
		one or more Active Directory attributes on a single Active Directory computer account.
	.EXAMPLE
		PS&gt; Set-MyAdComputer -Computername adampc -Attributes @{'Location' = 'Phoenix'; 'Description' = 'is a little problematic'}
	
		This example changes the location to Phoenix and the description of the AD computer adampc to 'is a little problematic'
	.PARAMETER Computername
	 	An Active Directory computer account to modify
	.PARAMETER Attributes
		A hashtable with keys as Set-AdComputer parameter values and values as Set-AdComputer parameter argument values
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Computername,
		[hashtable]$Attributes
	)
	process {
		try {
			## Attempt to find the Computername
			$Computer = Get-AdComputer -Identity $Computername
			if (!$Computer) {
				## If the Computername isn't found throw an error and exit
				#Write-Error "The Computername '$Computername' does not exist"
				throw "The Computername '$Computername' does not exist"
			}
			
			## The $Attributes parameter will contain only the parameters for the Set-AdComputer cmdlet
			$Computer | Set-AdComputer @Attributes
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}

function New-EmployeeOnboardComputer {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to perform all routine
		tasks that must be done when onboarding a new AD computer account.
	.EXAMPLE
		PS&gt; New-EmployeeOnboardComputer -FirstName 'adam' -MiddleInitial D -LastName Bertram -Title 'Dr. Awesome'
	
		This example creates an AD username based on company standards into a company-standard OU and adds the user
		into the company-standard main user group.
	.PARAMETER Computername
	 	The name of the computer to create in AD
	.PARAMETER Location
		The AD distinguishedname of the OU that the computer account will be created in
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Computername,
		[string]$Location
	)
	process {
		try {
			if (Get-AdComputer $Computername) {
				#Write-Error "The computer name '$Computername' already exists"
				throw "The computer name '$Computername' already exists"
			}
			
			$DomainDn = (Get-AdDomain).DistinguishedName
			$DefaultOuPath = "$Location,$DomainDn"
			
			New-ADComputer -Name $Computername -Path $DefaultOuPath
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WindowsUpdate_Module</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WindowsUpdate_Module</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'WindowsUpdate.psm1
#'https://github.com/adbertram/Random-PowerShell-Work/blob/master/Software%20Updates/WindowsUpdate.psm1

Set-StrictMode -Version Latest

function Get-WindowsUpdate {
	&lt;#
		.SYNOPSIS
			This function retrieves a list of Microsoft updates based on a number of different criteria for a remote
			computer. It will retrieve these updates over a PowerShell remoting session. It uses the update source set
			at the time of query. If it's set to WSUS, it will only return updates that are advertised to the computer
			by WSUS.
	
		.EXAMPLE
			PS&gt; Get-WindowsUpdate -ComputerName FOO
		.PARAMETER ComputerName
			 A mandatory string parameter representing the FQDN of a computer. This is only mandatory is Session is
			 not used.
		.PARAMETER Credential
			 A optoional pscredential parameter representing an alternate credential to connect to the remote computer.
		.PARAMETER Session
			 A mandatory PSSession parameter representing a PowerShell remoting session created with New-PSSession. This
			 is only mandatory if ComputerName is not used.
		
		.PARAMETER Installed
			 A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			 updates on this criteria.
		.PARAMETER Hidden
			 A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			 updates on this criteria.
		.PARAMETER Assigned
			A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			updates on this criteria.
		.PARAMETER RebootRequired
			A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			updates on this criteria.
	#&gt;
	[OutputType([System.Management.Automation.PSObject])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory, ParameterSetName = 'ByComputerName')]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName,

		[Parameter(ParameterSetName = 'ByComputerName')]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential,

		[Parameter(Mandatory, ParameterSetName = 'BySession')]
		[ValidateNotNullOrEmpty()]
		[System.Management.Automation.Runspaces.PSSession]$Session,
        
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('MicrosoftUpdate')]
		[string]$Source,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$Installed = 'False',

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$Hidden,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$Assigned,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$RebootRequired
	)
	begin {
		$ErrorActionPreference = 'Stop'
		if (-not $Session) {
			$sessParams = @{
				ComputerName = $ComputerName
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$sessParams.Credential = $Credential
			}
			$Session = New-PSSession @sessParams
		}
	}
	process {
		try {
			$criteriaParams = @{}

			## Had to set these to string values because if they're boolean they will have a $false value even if
			## they aren't set.  I needed to check for a $null value.ided
			@('Installed', 'Hidden', 'Assigned', 'RebootRequired').where({ (Get-Variable -Name $_).Value }).foreach({
					$criteriaParams[$_] = if ((Get-Variable -Name $_).Value -eq 'True') {
						$true 
					} else {
						$false 
					}
				})
			$query = NewUpdateCriteriaQuery @criteriaParams
			Write-Verbose -Message "Using the update criteria query: [$($Query)]..."
			$searchParams = @{
				Session = $Session
				Query   = $query
			}
			if ($PSBoundParameters.ContainsKey('Source')) {
				$searchParams.Source = $Source
			}
			SearchWindowsUpdate @searchParams
		} catch {
			Write-Error $_.Exception.Message
		} finally {
			## Only clean up the session if it was generated from within this function. This is because updates
			## are stored in a variable to be used again by other functions, if necessary.
			if (($PSCmdlet.ParameterSetName -eq 'ByComputerName') -and (Test-Path Variable:\session)) {
				$session | Remove-PSSession
			}
		}
	}
}

function Install-WindowsUpdate {
	&lt;#
		.SYNOPSIS
			This function retrieves all updates that are targeted at a remote computer, download and installs any that it
			finds. Depending on how the remote computer's update source is set, it will either read WSUS or Microsoft Update
			for a compliancy report.
			Once found, it will download each update, install them and then read output to detect if a reboot is required
			or not.
	
		.EXAMPLE
			PS&gt; Install-WindowsUpdate -ComputerName FOO.domain.local
		.EXAMPLE
			PS&gt; Install-WindowsUpdate -ComputerName FOO.domain.local,FOO2.domain.local			
		
		.EXAMPLE
			PS&gt; Install-WindowsUpdate -ComputerName FOO.domain.local,FOO2.domain.local -ForceReboot
		.PARAMETER ComputerName
			 A mandatory string parameter representing one or more computer FQDNs.
		.PARAMETER Credential
			 A optional pscredential parameter representing an alternate credential to connect to the remote computer.
		
		.PARAMETER ForceReboot
			 An optional switch parameter to set if any updates on any computer targeted needs a reboot following update
			 install. By default, computers are NOT rebooted automatically. Use this switch to force a reboot.
		
		.PARAMETER AsJob
			 A optional switch parameter to set when activity needs to be sent to a background job. By default, this function 
			 waits for each computer to finish. However, if this parameter is used, it will start the process on each
			 computer and immediately return a background job object to then monitor yourself with Get-Job.
	#&gt;
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string[]]$ComputerName,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('MicrosoftUpdate')]
		[string]$Source,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[switch]$ForceReboot,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[switch]$AsJob
	)
	begin {
		$ErrorActionPreference = 'Stop'

		$scheduledTaskName = 'Windows Update Install'

	}
	process {
		try {
			$getParams = @{}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$getParams.Credential = $Credential
			}
			if ($PSBoundParameters.ContainsKey('Source')) {
				$getParams.Source = $Source
			}
			@($ComputerName).foreach({
					$getParams.ComputerName = $_
					if (-not (Get-WindowsUpdate @getParams)) {
						Write-Verbose -Message 'No updates needed to install. Skipping computer...'
					} else {
						$installProcess = {
							param($ComputerName, $TaskName, $Credential, $ForceReboot)
							$VerbosePreferences = 'Continue'
							try {
								$sessParams = @{ ComputerName = $ComputerName }
								if ($Credential) {
									$sessParams.Credential = $Credential
								}
							
								$session = New-PSSession @sessParams

								$scriptBlock = {
									$updateSession = New-Object -ComObject 'Microsoft.Update.Session'
									$objSearcher = $updateSession.CreateUpdateSearcher()
									if ($using:Source -eq 'MicrosoftUpdate') {
										$objSearcher.ServerSelection = 3
									}
									if ($updates = ($objSearcher.Search('IsInstalled=0'))) {
										$updates = $updates.Updates

										$downloader = $updateSession.CreateUpdateDownloader();
										$downloader.Updates = $updates;
										$downloadResult = $downloader.Download();
										if ($downloadResult.ResultCode -ne 2) {
											exit $downloadResult.ResultCode;
										}

										$installer = New-Object -ComObject Microsoft.Update.Installer;
										$installer.Updates = $updates;
										$installResult = $installer.Install();
										if ($installResult.RebootRequired) {
											exit 7;
										} else {
											$installResult.ResultCode
										}
									} else {
										exit 6;
									}
								}
							
								$taskParams = @{
									Session     = $session
									Name        = $TaskName
									Scriptblock = $scriptBlock
									PassThru    = $true
								}
								Write-Verbose -Message 'Creating scheduled task...'
								if (-not ($task = NewWindowsUpdateScheduledTask @taskParams)) {
									throw "Failed to create scheduled task."
								}

								Write-Verbose -Message "Starting scheduled task [$($task.TaskName)]..."

								$icmParams = @{
									Session      = $session
									ScriptBlock  = { Start-ScheduledTask -TaskName $args[0] }
									ArgumentList = $task.TaskName
									Verbose      = $true
								}
								Invoke-Command @icmParams
                                
								$waitParams = @{
									ComputerName = $_
								}
								if ($Credential) {
									$waitParams.Credential = $Credential
								}
								Wait-ScheduledTask @waitParams -Name $task.TaskName

								$installResult = GetWindowsUpdateInstallResult -Session $session

								if ($installResult -eq 'NoUpdatesNeeded') {
									Write-Verbose -Message "No updates to install"
								} elseif ($installResult -eq 'RebootRequired') {
									if ($ForceReboot) {
										Restart-Computer -ComputerName $ComputerName -Force -Wait;
									} else {
										Write-Warning "Reboot required but -ForceReboot was not used."
									}
								} else {
									throw "Updates failed. Reason: [$($installResult)]"
								}
							
							} catch {
								$PSCmdlet.ThrowTerminatingError($_)
							} finally {
								Remove-ScheduledTask @getParams -Name $TaskName
							}
						}

						$blockArgs = $_, $scheduledTaskName, $Credential, $ForceReboot.IsPresent
						if ($AsJob.IsPresent) {
							Start-Job -ScriptBlock $installProcess -Name "$_ - Windows Update Install" -ArgumentList $blockArgs
						} else {
							Invoke-Command -ScriptBlock $installProcess -ArgumentList $blockArgs
						}
					}
				})
		} catch {
			Write-Error $_.Exception.Message
		} finally {
			# Remove any sessions created. This is done when processes aren't invoked under a PS job
			$sessParams = @{
				ComputerName = $ComputerName
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$sessParams.Credential = $Credential
			}
			@(Get-PSSession @sessParams).foreach({
					Remove-PSSession -Session $_
				})
		}
	}
}

function GetWindowsUpdateInstallResult {
	[OutputType([string])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[System.Management.Automation.Runspaces.PSSession]$Session,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[string]$ScheduledTaskName = 'Windows Update Install'
	)

	$sb = { (Get-ScheduledTask -TaskName $args[0] | Get-ScheduledTaskInfo).LastTaskResult }
	$resultCode = Invoke-Command -Session $Session -ScriptBlock $sb -ArgumentList $ScheduledTaskName
	switch -exact ($resultCode) {
		0   {
			'Installed'
			break
		}
		1   {
			'InProgress'
			break
		}
		2   {
			'Installed'
			break
		}
		3   {
			'InstalledWithErrors'
			break
		}
		4   {
			'Failed'
			break
		}
		5   {
			'Aborted'
			break
		}
		6   {
			'NoUpdatesNeeded'
			break
		}
		7   {
			'RebootRequired'
			break
		}
		267009 {
			'TimedOut'
			break
		}
		default {
			"Unknown exit code [$($_)]"
		}
	}
}

function NewUpdateCriteriaQuery {
	[OutputType([string])]
	[CmdletBinding()]
	param
	(
		[Parameter()]
		[bool]$Installed,

		[Parameter()]
		[bool]$Hidden,

		[Parameter()]
		[bool]$Assigned,

		[Parameter()]
		[bool]$RebootRequired
	)

	$conversion = @{
		Installed      = 'IsInstalled'
		Hidden         = 'IsHidden'
		Assigned       = 'IsAssigned'
		RebootRequired = 'RebootRequired'
	}

	$queryElements = @()
	$PSBoundParameters.GetEnumerator().where({ $_.Key -in $conversion.Keys }).foreach({
			$queryElements += '{0}={1}' -f $conversion[$_.Key], [int]$_.Value
		})
	$queryElements -join ' and '
}

function SearchWindowsUpdate {
	[OutputType()]
	[CmdletBinding()]
	param
	(
		[Parameter()]
		[string]$Query,
        
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[string]$Source,

		[Parameter()]
		[System.Management.Automation.Runspaces.PSSession]$Session
	)

	$scriptBlock = {
		$objSession = New-Object -ComObject 'Microsoft.Update.Session'
		$objSearcher = $objSession.CreateUpdateSearcher()
		if ($using:Source -eq 'MicrosoftUpdate') {
			$objServiceManager = New-Object -ComObject "Microsoft.Update.ServiceManager"
			$objSearcher.ServerSelection = 3
			$objServiceManager.Services | Where-Object { $_.Name -eq 'Microsoft Update' } | Foreach {
				$objSearcher.ServiceID = $_.ServiceID
			}
		}
		if ($updates = ($objSearcher.Search($args[0]))) {
			$updates = $updates.Updates
			## Save the updates needed to the file system for other functions to pick them up to download/install later.
			$updates | Export-CliXml -Path "$env:TEMP\Updates.xml"
			$updates
		}
		
	}
	Invoke-Command -Session $Session -ScriptBlock $scriptBlock -ArgumentList $Query
}

function NewWindowsUpdateScheduledTask {
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[System.Management.Automation.Runspaces.PSSession]$Session,

		[Parameter(Mandatory)]
		[string]$Name,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[scriptblock]$Scriptblock,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[switch]$PassThru
	)

	if (TestWindowsUpdateScheduledTask -Session $Session -Name $Name) {
		Write-Verbose -Message "A windows update install task already exists. Removing..."
		Remove-ScheduledTask -ComputerName $Session.ComputerName -Name $Name
	}

	$createStartSb = {
		$action = New-ScheduledTaskAction -Execute 'powershell.exe' -Argument $args[1]
		$principal = New-ScheduledTaskPrincipal -UserId $args[3] -LogonType Password
		$settings = New-ScheduledTaskSettingsSet -StartWhenAvailable -Hidden
		$task = New-ScheduledTask -Action $action -Settings $settings -Principal $principal
		$regTask = Register-ScheduledTask -InputObject $task -TaskName $args[0]
		if ($args[2].IsPresent) {
			$regTask
		}
	}

	$psArgs = '-NonInteractive -NoProfile -Command "{0}"' -f $Scriptblock.ToString()

	$icmParams = @{
		Session      = $Session
		ScriptBlock  = $createStartSb
		ArgumentList = $Name, $psArgs, $PassThru
	}
	if ($PSBoundParameters.ContainsKey('Credential')) {
		$icmParams.ArgumentList += $Credential.UserName	
	} else {
		$icmParams.ArgumentList += 'SYSTEM'
	}
	
	Invoke-Command @icmParams
	
}

function TestWindowsUpdateScheduledTask {
	[OutputType([bool])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[System.Management.Automation.Runspaces.PSSession]$Session,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$Name
	)
	$testScriptBlock = {
		if (Get-ScheduledTask -TaskName $args[0] -ErrorAction Ignore) {
			$true
		} else {
			$false
		}
	}

	Invoke-Command -Session $Session -ScriptBlock $testScriptBlock -ArgumentList $Name
}

function Wait-WindowsUpdate {
	&lt;#
		.SYNOPSIS
			This function looks for any currently running background jobs that were created by Install-WindowsUpdate
			and continually waits for all of them to finish before returning control to the console.
	
		.EXAMPLE
			PS&gt; Wait-WindowsUpdate
		
		.PARAMETER Timeout
			 An optional integer parameter representing the amount of seconds to wait for the job to finish.
	
	#&gt;
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[int]$Timeout = 3600
	)
	process {
		try {
			if ($updateJobs = (Get-Job -Name '*Windows Update Install*').where({ $_.State -eq 'Running'})) {
				$timer = Start-Timer
				while ((Microsoft.PowerShell.Core\Get-Job -Id $updateJobs.Id | Where-Object { $_.State -eq 'Running' }) -and ($timer.Elapsed.TotalSeconds -lt $Timeout)) {
					Write-Verbose -Message "Waiting for all Windows Update install background jobs to complete..."
					Start-Sleep -Seconds 3
				}
				Stop-Timer -Timer $timer
			}
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}

function Remove-ScheduledTask {
	&lt;#
		.SYNOPSIS
			This function looks for a scheduled task on a remote system and, once found, removes it.
	
		.EXAMPLE
			PS&gt; Remove-ScheduledTask -ComputerName FOO -Name Task1
		
		.PARAMETER ComputerName
			 A mandatory string parameter representing a FQDN of a remote computer.
		.PARAMETER Name
			 A mandatory string parameter representing the name of the scheduled task. Scheduled tasks can be retrieved
			 by using the Get-ScheduledTask cmdlet.
		.PARAMETER Credential
			 Specifies a user account that has permission to perform this action. The default is the current user.
			 
			 Type a user name, such as 'User01' or 'Domain01\User01', or enter a variable that contains a PSCredential
			 object, such as one generated by the Get-Credential cmdlet. When you type a user name, you will be prompted for a password.
	
	#&gt;
	[OutputType([void])]
	[CmdletBinding(SupportsShouldProcess)]
	param
	(
		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential	
	)
	begin {
		$ErrorActionPreference = 'Stop'
	}
	process {
		try {
			$icmParams = @{
				ComputerName = $ComputerName
				ArgumentList = $Name
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$icmParams.Credential = $Credential
			}
			
			$sb = { 
				if ($task = Get-ScheduledTask -TaskName $args[0] -ErrorAction Ignore) {
					$task | Unregister-ScheduledTask -Confirm:$false
				}
			}

			if ($PSCmdlet.ShouldProcess("Remove scheduled task [$($Name)] from [$($ComputerName)]", '----------------------')) {
				Invoke-Command @icmParams -ScriptBlock $sb	
			}
		} catch {
			Write-Error -Message $_.Exception.Message
		}
	}
}

function Wait-ScheduledTask {
	&lt;#
		.SYNOPSIS
			This function looks for a scheduled task on a remote system and, once found, checks to see if it's running.
			If so, it will wait until the task has completed and return control.
	
		.EXAMPLE
			PS&gt; Wait-ScheduledTask -ComputerName FOO -Name Task1 -Timeout 120
		
		.PARAMETER ComputerName
			 A mandatory string parameter representing a FQDN of a remote computer.
		.PARAMETER Name
			 A mandatory string parameter representing the name of the scheduled task. Scheduled tasks can be retrieved
			 by using the Get-ScheduledTask cmdlet.
		.PARAMETER Timeout
			 A optional integer parameter representing how long to wait for the scheduled task to complete. By default,
			 it will wait 3600 seconds.
		.PARAMETER Credential
			 Specifies a user account that has permission to perform this action. The default is the current user.
			 
			 Type a user name, such as 'User01' or 'Domain01\User01', or enter a variable that contains a PSCredential
			 object, such as one generated by the Get-Credential cmdlet. When you type a user name, you will be prompted for a password.
	
	#&gt;
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[int]$Timeout = 3600, ## seconds

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential
	)
	begin {
		$ErrorActionPreference = 'Stop'
	}
	process {
		try {
			$sessParams = @{
				ComputerName = $ComputerName
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$sessParams.Credential = $Credential
			}
			$session = New-PSSession @sessParams

			$scriptBlock = {
				$VerbosePreference = 'Continue'
				$timer = [Diagnostics.Stopwatch]::StartNew()
				while (((Get-ScheduledTask -TaskName $args[0]).State -ne 'Ready') -and ($timer.Elapsed.TotalSeconds -lt $args[1])) {
					Write-Verbose -Message "Waiting on scheduled task [$($args[0])]"
					Start-Sleep -Seconds 3
				}
				$timer.Stop()
				Write-Verbose -Message "We waited [$($timer.Elapsed.TotalSeconds)] seconds on the task [$($args[0])]"
			}

			Invoke-Command -Session $session -ScriptBlock $scriptBlock -ArgumentList $Name, $Timeout
		} catch {
			Write-Error -Message $_.Exception.Message
		} finally {
			if (Test-Path Variable:\session) {
				$session | Remove-PSSession
			}
		}
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Validation</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Validation</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Validation</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Validation</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Validation



AllowNull() - allows the parameter to accept a null value 
AllowEmptyString() - allows the parameter to accept an empty string (“”) 
AllowEmptyCollection() - allows an array parameter to accept an empty collection 


 
ValidateCount(min,max) - specifies a minimum and maximum number of values, in an array, that the parameter will accept 

ValidateLength(min,max) - specifies the maximum string length the parameter will accept. You can specify a minimum and maximum value, and if the parameter accepts a collection then this is applied to all members of the collection 

ValidatePattern(pattern) - specifies a regular expression that any string input must match in order to be accepted 

ValidateRange(min,max) - specifies a range of numeric values that any input must fall between, inclusive of the minimum and maximum specified 

ValidateScript({script block}) - specifies a script block; within the script, uses $_ to refer to the proposed value for the parameter, and return $true to accept it or $false to reject it 

ValidateSet(val,val,val…) - covered earlier, this specifies a set of legal values for the parameter 

ValidateNotNull() - the parameter will not accept null values 

ValidateNotNullOrEmpty() - the parameter will not accept null values or empty strings (“”) 
 

 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Validation</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Simple_Examples_Validation</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Validation</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Simple_Examples_Validation</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-5.1

------------------------------AllowNull Validation Attribute
Param
(
    [parameter(Mandatory=$true)]
    [AllowNull()]
    [String]
    $ComputerName
)

------------------------------AllowEmptyString 

Param
(
    [parameter(Mandatory=$true)]
    [AllowEmptyString()]
    [String]
    $ComputerName
)
------------------------------AllowEmptyCollection 
'allows the value of a mandatory parameter to be an empty collection (@()).
Param
(
    [parameter(Mandatory=$true)]
    [AllowEmptyCollection()]
    [String[]]
    $ComputerName
)

------------------------------ValidateCount
'the minimum and maximum number of parameter values that a parameter accepts. 
Param
(
    [parameter(Mandatory=$true)]
    [ValidateCount(1,5)]
    [String[]]
    $ComputerName
)

------------------------------ValidateLength
'specifies the minimum and maximum number of characters in a parameter or variable value. 
Param
(
    [parameter(Mandatory=$true)]
    [ValidateLength(1,10)]
    [String[]]
    $ComputerName
)
------------------------------ValidatePattern
' a regular expression that is compared to the parameter or variable value
' example, the parameter value must be a four-digit number, and each digit must be a number 0 to 9.
Param
(
    [parameter(Mandatory=$true)]
    [ValidatePattern("[0-9][0-9][0-9][0-9]")]
    [String[]]
    $ComputerName
)


------------------------------ValidateRange
' specifies a numeric range for each parameter or variable value
Param
(
    [parameter(Mandatory=$true)]
    [ValidateRange(0,10)]
    [Int]
    $Attempts
)
------------------------------ValidateScript
'specifies a script that is used to validate a parameter or variable value. 
' Windows PowerShell pipes the value to the script, and generates an error if the script
'	returns "false" or if the script throws an exception.
'the value that is being validated is mapped to the $ variable. 
Param
(
    [parameter()]
    [ValidateScript({$_ -ge (get-date)})]
    [DateTime]
    $EventDate
)


------------------------------ValidateSet
'specifies a set of valid values for a parameter or variable
Param
(
    [parameter(Mandatory=$true)]
    [ValidateSet("Low", "Average", "High")]
    [String[]]
    $Detail
)
------------------------------ValidateNotNull
'specifies that the parameter value cannot be null ($null)
Param
(
    [parameter(Mandatory=$true)]
    [ValidateNotNull()]
    # $ID
)
------------------------------ValidateNotNullOrEmpty
' specifies that the parameter value cannot be null ($null) and cannot be an empty string ("")
Param
(
    [parameter(Mandatory=$true)]
    [ValidateNotNullOrEmpty()]
    [String[]]
    $UserName
)
------------------------------


------------------------------


------------------------------


------------------------------


------------------------------
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Variables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Variables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Variables


# Access the variables via Variables provider =&gt; list of the variables and their values

$zvar = 0  # add a variable so we can show it
Clear-Host
Set-Location variable:
Get-ChildItem

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Get-Variable                     # Without params it shows all variables

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

'Variables in PowerShell are maded with a $ in the front 
'EXAMPLE:
&gt; $BITSSrv = Get-Service -Name BITS

'now get it's members:
&gt; $BITSSrv | Get-Member -MemberType Method

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
'Lets stop the service:

PS C:\&gt; $BITSSrv.Stop()
PS C:\&gt; $BITSSrv.Status
'Running

PS C:\&gt; $BITSSrv.Refresh()

PS C:\&gt; $BITSSrv.Status
'Stopped

'As it can be seen I forgot that when the object is in a variable 
'it is just a representation at the moment it was saved. 
'Let look at Parenthetical execution go get around this, 
'when we wrap the command around ( ) we can use the properties and methods of the object it returns directly. 

PS C:\&gt; (Get-Service -Name BITS).Start()			'&lt;=== Parenthesis around the piece of code, in order to run 'Start' method on the whole thing
PS C:\&gt; (Get-Service -Name BITS).Status
Running</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_Variables_from_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_Variables_from_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;#-----------------------------------------------------------------------------
  Beginning PowerShell Scripting for Developers
  Using Variables in PowerShell

  Author: Robert C. Cain | @ArcaneCode | arcanecode@gmail.com
          http://arcanecode.com
 
  This module is Copyright (c) 2015 Robert C. Cain. All rights reserved.
  The code herein is for demonstration purposes. No warranty or guarentee
  is implied or expressly granted. 
  This module may not be reproduced in whole or in part without the express
  written consent of the author. 
-----------------------------------------------------------------------------#&gt;


#-----------------------------------------------------------------------------#
# Variables
#-----------------------------------------------------------------------------#
#region Variables

Clear-Host

# All variables start with a $. Show a simple assignment
$hi = "Hello World"

# Print the value
$hi

# This is a shortcut to Write-Host
Write-Host $hi

# Variables are objects. Show the type
$hi.GetType()

# Display all the members of this variable (object) - This gives list of "extension methods"
$hi | Get-Member

# Use some of those members
$hi.ToUpper()
$hi.ToLower()
$hi.Length

# Types are mutable, this changes it from string to INT
Clear-Host
$hi = 5
$hi.GetType()

$hi | Get-Member    #Now it would have a different set of "extension methods"

# Variables can be strongly typed 
Clear-Host 
[System.Int32]$myint = 42            #EXPLICITY type it for strong typing
$myint
$myint.GetType()

$myint = "This won't work"           #Will throw an error, b/c it is strongly typed as INT

# There are shortcuts for most .net types
Clear-Host
[int] $myotherint = 42               #[int] is a "alias" for [System.Int32]
$myotherint.GetType()

[string] $mystring="PowerShell"
$mystring.GetType()

# Others include short, float, decimal, single, bool, byte, etc

# Not just variables have types - so do static values
"PowerShell Rocks".GetType()

# Accessing methods on objects
"PowerShell Rocks".ToUpper()
"PowerShell Rocks".Contains("PowerShell")

# For nonstrings you need to wrap in () so PS will evaluate as an object, from which we can use "GetType()"
(33).GetType()  


# Comparisons
$var = 33

$var -gt 30
$var -lt 30
$var -eq 33

# List is:
#   -eq        Equals
#   -ne        Not equal to
#   -lt        Less Than
#   -gt        Greater then
#   -le        Less than or equal to
#   -ge        Greater then or equal to

#   -in        See if value in an array
#   -notin     See if a value is missing from an array
#   -Like      Like wildcard pattern matching
#   -NotLike   Not Like 
#   -Match     Matches based on regular expressions
#   -NotMatch  Non-Matches based on regular expressions

# Calculations are like any other language
$var = 3 * 11  # Also uses +, -, and / 
$var

# Supports post unary operators ++ and --
$var++  
$var

# And pre unary operators as well
++$var 
$var

Clear-Host
$var = 33
$post = $var++
$post
$var

Clear-Host
$var = 33
$post = ++$var
$post
$var



# Be cautious of Implicit Type Conversions
"42" -eq 42
42 -eq "42"

# Whatever is on the right is converted to the data type on the left
# Can lead to some odd conversions
42 -eq "042"   # True because the string on the right is coverted to an int
"042" -eq 42   # False because int on the right is converted to a string

##


#-----------------------------------------------------------------------------#
# Built in variables
#-----------------------------------------------------------------------------#
# Automatic Variables
Clear-Host

# False and true
$false
$true

# Null
$NULL

# Current directory
$pwd

# Users Home Directory
$Home  

# Info about a users scripting environment
$host

# Process ID
$PID

# Info about the current version of Powershell
$PSVersionTable

$_   # Current Object
Set-Location "C:\ps\01 - intro"
Get-ChildItem | Where-Object {$_.Name -like "*.ps1"}

#endregion Variables

##



#-----------------------------------------------------------------------------#
# Using the *-Variable cmdlets
#-----------------------------------------------------------------------------#
Clear-Host

# Normal variable usage
$normal = 33
$normal

$text = "In The Morning"
$text


# Long version of $var = 33
New-Variable -Name var -Value 33
$var

# Note if you try to use New-Variable and it already exists, you get an error
# Try again with $var already existing
New-Variable -Name var -Value 99
$var

# Displays the variable and it's value
Get-Variable var -valueonly

Get-Variable var

Get-Variable   # Without params it shows all variables

# Assign a new value to an existing variable
# $var = "In The Morning"
Set-Variable -Name var -Value "In The Morning"
$var

# Clear the contents of a variable
# Same as $var = $null
Clear-Variable -Name var
$var   

# Variable is now set to null, this sets it to empty, even it though it still exists
$var -eq $null

# Even though null, it still exists
Get-Variable var   


# Wipe out a variable, now it will not exist
Remove-Variable -Name var
# Now var is gone, if you try to remove or clear again an error occurs
# (note if you try to access it by just doing a $var the var is recreated)

Get-Variable var   # Now produces an error


##


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>HashTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>HashTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#-----------------------------------------------------------------------------#
# Hash tables - use a text based key (rather than an integer in arrays) as the key
#               use squiggly brace {} ( rather than () as in Array)
#               prefix the brace with "@"
#               Use semicolon between the records  
#-----------------------------------------------------------------------------#

$hash = @{"Key"         = "Value"; 
          "PowerShell"  = "PowerShell.com"; 
          "Arcane Code" = "arcanecode.com"}
          
$hash                  # Display all values
$hash["PowerShell"]    # Get a single value from the key

$hash."Arcane Code"    # Get single value using object syntax, short-cut: period (.) followed by Key in quotes

# You can use variables as keys
$mykey = "PowerShell"
$hash.$mykey         # Using variable as a property
$hash.$($mykey)      # Evaluating as an expression, in this example this is the same as the previous line
$hash.$("Power" + "Shell")

# Adding and removing values
$hash                                     # Here's what's there to start
$hash["Pluralsight"] = "pluralsight.com"  # Add value using new key
$hash                                     # Show the additional row

$hash.Remove("Arcane Code")        # Remove by passing in key
$hash

# See if key exists
$hash.Contains("Pluralsight")      # Should be there =&gt; True
$hash.Contains("Arcane Code")      # Gone since we just removed it =&gt; False

# See if value exists
$hash.ContainsValue("PowerShell.com")  # Will be there  =&gt; True
$hash.ContainsValue("arcanecode.com")  # Not there since it was removed  =&gt; False

# List keys and values
$hash.Keys
$hash.Values

# Find if a key or value is present
$hash.Keys -contains "PowerShell"

$hash.Values -contains "PowerShell.com"


##
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_WMI</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WMIExplorer.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_WMI</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WMIExplorer.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'  https://gallery.technet.microsoft.com/scriptcenter/89c759b7-20b4-49e8-98a8-3c8fbdb2dd69
#' WmiExplorer.ps1  
#'  
#' A GUI WMI explorer and WMI Method Help generator  
#'  
#' /\/\o\/\/ 2006  
#' www.ThePowerShellGuy.com  
#'  
#' load Forms NameSpace  
[void][System.Reflection.Assembly]::LoadWithPartialName("System.windows.forms")   
   
#'region BuildTheForm build in C# then translated to powershell  
#'region Make the form  
$frmMain = new-object Windows.Forms.form    
$frmMain.Size = new-object System.Drawing.Size @(800,600)    
$frmMain.text = "/\/\o\/\/'s PowerShell WMI Explorer"   
#'endregion Make the form  
#'region Define Used Controls  
$MainMenu = new-object System.Windows.Forms.MenuStrip  
$statusStrip = new-object System.Windows.Forms.StatusStrip  
$FileMenu = new-object System.Windows.Forms.ToolStripMenuItem  
$ToolMenu = new-object System.Windows.Forms.ToolStripMenuItem('&amp;tools')  
$miQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;Query (run)')  
$miSelectQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;SelectQuery')  
$miSelectQuery.add_Click({$sq | out-propertyGrid;$wmiSearcher.Query = $sq})  
[void]$ToolMenu.DropDownItems.Add($miSelectQuery)  
$miRelatedObjectQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;RelatedObjectQuery')  
$miRelatedObjectQuery.add_Click({$roq | out-propertyGrid;$wmiSearcher.Query = $roq})  
[void]$ToolMenu.DropDownItems.Add($miRelatedObjectQuery)  
$miRelationshipQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;RelationshipQuery')  
$miRelationshipQuery.add_Click({$rq | out-propertyGrid ;$wmiSearcher.Query = $rq})  
[void]$ToolMenu.DropDownItems.Add($miRelationshipQuery)  
$oq = new-object System.Management.ObjectQuery  
$eq = new-object System.Management.EventQuery  
$sq = new-object System.Management.SelectQuery  
$roq = new-object System.Management.RelatedObjectQuery  
$rq = new-object System.Management.RelationshipQuery  
$wmiSearcher = [wmisearcher]''  
[void]$ToolMenu.DropDownItems.Add($miQuery)  
$miQuery.add_Click({  
    $wmiSearcher | out-propertyGrid  
    $moc = $wmiSearcher.get()  
    $DT =  new-object  System.Data.DataTable  
    $DT.TableName = $lblClass.text  
    $Col =  new-object System.Data.DataColumn  
    $Col.ColumnName = "WmiPath"  
    $DT.Columns.Add($Col)  
    $i = 0  
    $j = 0 ;$lblInstances.Text = $j; $lblInstances.Update()  
    $MOC |  
    ForEach-Object {  
        $j++ ;$lblInstances.Text = $j; $lblInstances.Update()  
        $MO = $_  
         
        #' Make a DataRow  
        $DR = $DT.NewRow()  
        $Col =  new-object System.Data.DataColumn  
        $DR.Item("WmiPath") = $mo.__PATH  
        $MO.psbase.properties |  
        ForEach-Object {  
         
            $prop = $_  
             
            If ($i -eq 0)  {  
     
                #' Only On First Row make The Headers  
                 
                $Col =  new-object System.Data.DataColumn  
                $Col.ColumnName = $prop.Name.ToString()  
   
                $prop.psbase.Qualifiers |  
                ForEach-Object {  
                    If ($_.Name.ToLower() -eq "key") {  
                        $Col.ColumnName = $Col.ColumnName + "*"  
                    }  
                }  
                $DT.Columns.Add($Col)   
            }  
             
            #' fill dataRow   
             
            if ($prop.value -eq $null) {  
                $DR.Item($prop.Name) = "[empty]"  
            } ElseIf ($prop.IsArray) {  
                $DR.Item($prop.Name) =[string]::Join($prop.value ,";")  
            } Else {  
                $DR.Item($prop.Name) = $prop.value  
                #'Item is Key try again with *  
                trap{$DR.Item("$($prop.Name)*") = $prop.Value.tostring();continue}  
            }  
        } #'end ForEach  
        #' Add the row to the DataTable  
         
        $DT.Rows.Add($DR)  
        $i += 1  
    }  
    $DGInstances.DataSource = $DT.psObject.baseobject    
    $status.Text = "Retrieved $j Instances"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
})#'$miQuery.add_Click  
 
$miQuit = new-object System.Windows.Forms.ToolStripMenuItem('&amp;quit')  
$miQuit.add_Click({$frmMain.close()})   
$SplitContainer1 = new-object System.Windows.Forms.SplitContainer  
$splitContainer2 = new-object System.Windows.Forms.SplitContainer  
$splitContainer3 = new-object System.Windows.Forms.SplitContainer  
$grpComputer = new-object System.Windows.Forms.GroupBox  
$grpNameSpaces = new-object System.Windows.Forms.GroupBox  
$grpClasses = new-object System.Windows.Forms.GroupBox  
$grpClass = new-object System.Windows.Forms.GroupBox  
$grpInstances = new-object System.Windows.Forms.GroupBox  
$grpStatus = new-object System.Windows.Forms.GroupBox  
$txtComputer = new-object System.Windows.Forms.TextBox  
$btnConnect = new-object System.Windows.Forms.Button  
$btnInstances = new-object System.Windows.Forms.Button  
$tvNameSpaces = new-object System.Windows.Forms.TreeView  
$lvClasses = new-object System.Windows.Forms.ListView  
$clbProperties = new-object System.Windows.Forms.CheckedListBox  
$clbProperties.CheckOnClick = $true  
$lbMethods = new-object System.Windows.Forms.ListBox  
$label1 = new-object System.Windows.Forms.Label  
$label2 = new-object System.Windows.Forms.Label  
$lblServer = new-object System.Windows.Forms.Label  
$lblPath = new-object System.Windows.Forms.Label  
$lblNameSpace = new-object System.Windows.Forms.Label  
$label6 = new-object System.Windows.Forms.Label  
$lblClass = new-object System.Windows.Forms.Label  
$label10 = new-object System.Windows.Forms.Label  
$lblClasses = new-object System.Windows.Forms.Label  
$label12 = new-object System.Windows.Forms.Label  
$lblProperties = new-object System.Windows.Forms.Label  
$label8 = new-object System.Windows.Forms.Label  
$lblMethods = new-object System.Windows.Forms.Label  
$label14 = new-object System.Windows.Forms.Label  
$lblInstances = new-object System.Windows.Forms.Label  
$label16 = new-object System.Windows.Forms.Label  
$dgInstances = new-object System.Windows.Forms.DataGridView  
$TabControl = new-object System.Windows.Forms.TabControl  
$tabPage1 = new-object System.Windows.Forms.TabPage  
$tabInstances = new-object System.Windows.Forms.TabPage  
$rtbHelp = new-object System.Windows.Forms.RichTextBox  
$tabMethods = new-object System.Windows.Forms.TabPage  
$rtbMethods = new-object System.Windows.Forms.RichTextBox  
#'endregion Define Used Controls         
#'region Suspend the Layout  
$splitContainer1.Panel1.SuspendLayout()  
$splitContainer1.Panel2.SuspendLayout()  
$splitContainer1.SuspendLayout()  
$splitContainer2.Panel1.SuspendLayout()  
$splitContainer2.Panel2.SuspendLayout()  
$splitContainer2.SuspendLayout()  
$grpComputer.SuspendLayout()  
$grpNameSpaces.SuspendLayout()  
$grpClasses.SuspendLayout()  
$splitContainer3.Panel1.SuspendLayout()  
$splitContainer3.Panel2.SuspendLayout()  
$splitContainer3.SuspendLayout()  
$grpClass.SuspendLayout()  
$grpStatus.SuspendLayout()  
$grpInstances.SuspendLayout()  
$TabControl.SuspendLayout()  
$tabPage1.SuspendLayout()  
$tabInstances.SuspendLayout()  
$FrmMain.SuspendLayout()  
#'endregion Suspend the Layout  
#'region Configure Controls  
[void]$MainMenu.Items.Add($FileMenu)  
[void]$MainMenu.Items.Add($ToolMenu)  
$MainMenu.Location = new-object System.Drawing.Point(0, 0)  
$MainMenu.Name = "MainMenu"  
$MainMenu.Size = new-object System.Drawing.Size(1151, 24)  
$MainMenu.TabIndex = 0  
$MainMenu.Text = "Main Menu"  
#'  
#' statusStrip1  
#'  
$statusStrip.Location = new-object System.Drawing.Point(0, 569)  
$statusStrip.Name = "statusStrip"  
$statusStrip.Size = new-object System.Drawing.Size(1151, 22);  
$statusStrip.TabIndex = 1  
$statusStrip.Text = "statusStrip"  
$splitContainer1.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer1.Location = new-object System.Drawing.Point(0, 24)  
$splitContainer1.Name = "splitContainer1"  
$splitContainer1.Panel1.Controls.Add($splitContainer2)  
$splitContainer1.Panel2.Controls.Add($splitContainer3)  
$splitContainer1.Size = new-object System.Drawing.Size(1151, 545)  
$splitContainer1.SplitterDistance = 372  
$splitContainer1.TabIndex = 2  
$splitContainer2.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$splitContainer2.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer2.Location = new-object System.Drawing.Point(0, 0)  
$splitContainer2.Name = "splitContainer2"  
$splitContainer2.Orientation = [System.Windows.Forms.Orientation]::Horizontal  
$splitContainer2.Panel1.BackColor = [System.Drawing.SystemColors]::Control  
$splitContainer2.Panel1.Controls.Add($grpNameSpaces)  
$splitContainer2.Panel1.Controls.Add($btnConnect)  
$splitContainer2.Panel1.Controls.Add($grpComputer)  
$splitContainer2.Panel2.Controls.Add($grpClasses)  
$splitContainer2.Size = new-object System.Drawing.Size(372, 545)  
$splitContainer2.SplitterDistance = 302  
$splitContainer2.TabIndex = 0  
#'  
#' fileMenu  
#'  
[void]$fileMenu.DropDownItems.Add($miQuit)  
$fileMenu.Name = "fileMenu"  
$fileMenu.Size = new-object System.Drawing.Size(35, 20)  
$fileMenu.Text = "&amp;File"  
$grpComputer.Anchor = "top, left, right"  
$grpComputer.Controls.Add($txtComputer)  
$grpComputer.Location = new-object System.Drawing.Point(12, 3)  
$grpComputer.Name = "grpComputer"  
$grpComputer.Size = new-object System.Drawing.Size(340, 57)  
$grpComputer.TabIndex = 0  
$grpComputer.TabStop = $false  
$grpComputer.Text = "Computer"  
$txtComputer.Anchor = "top, left, right"  
$txtComputer.Location = new-object System.Drawing.Point(7, 20)  
$txtComputer.Name = "txtComputer"  
$txtComputer.Size = new-object System.Drawing.Size(244, 20)  
$txtComputer.TabIndex = 0  
$txtComputer.Text = "."  
 
$btnConnect.Anchor = "top, right"  
$btnConnect.Location = new-object System.Drawing.Point(269, 23);  
$btnConnect.Name = "btnConnect"  
$btnConnect.Size = new-object System.Drawing.Size(75, 23)  
$btnConnect.TabIndex = 1  
$btnConnect.Text = "Connect"  
$btnConnect.UseVisualStyleBackColor = $true  
#'  
#' grpNameSpaces  
#'  
$grpNameSpaces.Anchor = "Bottom, top, left, right"  
$grpNameSpaces.Controls.Add($tvNameSpaces)  
$grpNameSpaces.Location = new-object System.Drawing.Point(12, 67)  
$grpNameSpaces.Name = "grpNameSpaces"  
$grpNameSpaces.Size = new-object System.Drawing.Size(340, 217)  
$grpNameSpaces.TabIndex = 2  
$grpNameSpaces.TabStop = $false  
$grpNameSpaces.Text = "NameSpaces"  
#'  
#' grpClasses  
#'  
$grpClasses.Anchor = "Bottom, top, left, right"  
$grpClasses.Controls.Add($lvClasses)  
$grpClasses.Location = new-object System.Drawing.Point(12, 14)  
$grpClasses.Name = "grpClasses"  
$grpClasses.Size = new-object System.Drawing.Size(340, 206)  
$grpClasses.TabIndex = 0  
$grpClasses.TabStop = $False  
$grpClasses.Text = "Classes"  
#'  
#' tvNameSpaces  
#'  
$tvNameSpaces.Anchor = "Bottom, top, left, right"  
$tvNameSpaces.Location = new-object System.Drawing.Point(7, 19)  
$tvNameSpaces.Name = "tvNameSpaces"  
$tvNameSpaces.Size = new-object System.Drawing.Size(325, 184)  
$tvNameSpaces.TabIndex = 0  
#'  
#' tvClasses  
#'  
$lvClasses.Anchor = "Bottom, top, left, right"  
$lvClasses.Location = new-object System.Drawing.Point(7, 19)  
$lvClasses.Name = "tvClasses"  
$lvClasses.Size = new-object System.Drawing.Size(325, 172)  
$lvClasses.TabIndex = 0  
$lvClasses.UseCompatibleStateImageBehavior = $False  
$lvClasses.ShowItemToolTips = $true  
$lvClasses.View = 'Details'  
$colName = $lvClasses.Columns.add('Name')  
$colname.Width = 160  
$colPath = $lvClasses.Columns.add('Description')  
$colname.Width = 260  
$colPath = $lvClasses.Columns.add('Path')  
$colname.Width = 260  
#'  
#' splitContainer3  
#'  
$splitContainer3.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$splitContainer3.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer3.Location = new-object System.Drawing.Point(0, 0)  
$splitContainer3.Name = "splitContainer3"  
$splitContainer3.Orientation = [System.Windows.Forms.Orientation]::Horizontal  
#'  
#' splitContainer3.Panel1  
#'  
$splitContainer3.Panel1.Controls.Add($grpStatus)  
$splitContainer3.Panel1.Controls.Add($grpClass)  
#'  
#' splitContainer3.Panel2  
#'  
$splitContainer3.Panel2.Controls.Add($TabControl)  
$splitContainer3.Size = new-object System.Drawing.Size(775, 545)  
$splitContainer3.SplitterDistance = 303  
$splitContainer3.TabIndex = 0  
#'  
#' grpClass  
#'  
$grpClass.Anchor = "Bottom, top, left, right"  
$grpClass.Controls.Add($lblInstances)  
$grpClass.Controls.Add($label16)  
$grpClass.Controls.Add($lblMethods)  
$grpClass.Controls.Add($label14)  
$grpClass.Controls.Add($lblProperties)  
$grpClass.Controls.Add($label8)  
$grpClass.Controls.Add($lblClass)  
$grpClass.Controls.Add($label10)  
$grpClass.Controls.Add($lbMethods)  
$grpClass.Controls.Add($clbProperties)  
$grpClass.Controls.Add($btnInstances)  
$grpClass.Location = new-object System.Drawing.Point(17, 86)  
$grpClass.Name = "grpClass"  
$grpClass.Size = new-object System.Drawing.Size(744, 198)  
$grpClass.TabIndex = 0  
$grpClass.TabStop = $False  
$grpClass.Text = "Class"  
#'  
#' btnInstances  
#'  
$btnInstances.Anchor = "Bottom, Left"  
$btnInstances.Location = new-object System.Drawing.Point(6, 169);  
$btnInstances.Name = "btnInstances";  
$btnInstances.Size = new-object System.Drawing.Size(96, 23);  
$btnInstances.TabIndex = 0;  
$btnInstances.Text = "Get Instances";  
$btnInstances.UseVisualStyleBackColor = $true  
#'  
#' grpStatus  
#'  
$grpStatus.Anchor = "Top,Left,Right"  
$grpStatus.Controls.Add($lblClasses)  
$grpStatus.Controls.Add($label12)  
$grpStatus.Controls.Add($lblNameSpace)  
$grpStatus.Controls.Add($label6)  
$grpStatus.Controls.Add($lblPath)  
$grpStatus.Controls.Add($lblServer)  
$grpStatus.Controls.Add($label2)  
$grpStatus.Controls.Add($label1)  
$grpStatus.Location = new-object System.Drawing.Point(17, 3)  
$grpStatus.Name = "grpStatus"  
$grpStatus.Size = new-object System.Drawing.Size(744, 77)  
$grpStatus.TabIndex = 1  
$grpStatus.TabStop = $False  
$grpStatus.Text = "Status"  
#'  
#' label1  
#'  
$label1.AutoSize = $true  
$label1.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label1.Location = new-object System.Drawing.Point(7, 20)  
$label1.Name = "label1"  
$label1.Size = new-object System.Drawing.Size(62, 16)  
$label1.TabIndex = 0  
$label1.Text = "Server :"  
#'  
#' label2  
#'  
$label2.AutoSize = $true  
$label2.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label2.Location = new-object System.Drawing.Point(7, 41)  
$label2.Name = "label2"  
$label2.Size = new-object System.Drawing.Size(51, 16)  
$label2.TabIndex = 1  
$label2.Text = "Path  :"  
#'  
#' lblServer  
#'  
$lblServer.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblServer.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblServer.Location = new-object System.Drawing.Point(75, 20)  
$lblServer.Name = "lblServer"  
$lblServer.Size = new-object System.Drawing.Size(144, 20)  
$lblServer.TabIndex = 2  
#'  
#' lblPath  
#'  
$lblPath.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblPath.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblPath.Location = new-object System.Drawing.Point(75, 40)  
$lblPath.Name = "lblPath"  
$lblPath.Size = new-object System.Drawing.Size(567, 20)  
$lblPath.TabIndex = 3  
#'  
#' lblNameSpace  
#'  
$lblNameSpace.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblNameSpace.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblNameSpace.Location = new-object System.Drawing.Point(337, 20)  
$lblNameSpace.Name = "lblNameSpace"  
$lblNameSpace.Size = new-object System.Drawing.Size(144, 20)  
$lblNameSpace.TabIndex = 5  
#'  
#' label6  
#'  
$label6.AutoSize = $true  
$label6.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label6.Location = new-object System.Drawing.Point(229, 20)  
$label6.Name = "label6"  
$label6.Size = new-object System.Drawing.Size(102, 16)  
$label6.TabIndex = 4  
$label6.Text = "NameSpace :"  
#'  
#' lblClass  
#'  
$lblClass.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblClass.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblClass.Location = new-object System.Drawing.Point(110, 26)  
$lblClass.Name = "lblClass"  
$lblClass.Size = new-object System.Drawing.Size(159, 20)  
$lblClass.TabIndex = 11  
#'  
#' label10  
#'  
$label10.AutoSize = $true  
$label10.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label10.Location = new-object System.Drawing.Point(6, 26)  
$label10.Name = "label10"  
$label10.Size = new-object System.Drawing.Size(55, 16)  
$label10.TabIndex = 10  
$label10.Text = "Class :"  
#'  
#' lblClasses  
#'  
$lblClasses.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblClasses.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblClasses.Location = new-object System.Drawing.Point(595, 21)  
$lblClasses.Name = "lblClasses"  
$lblClasses.Size = new-object System.Drawing.Size(47, 20)  
$lblClasses.TabIndex = 9  
#'  
#' label12  
#'  
$label12.AutoSize = $true  
$label12.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label12.Location = new-object System.Drawing.Point(487, 21)  
$label12.Name = "label12"  
$label12.Size = new-object System.Drawing.Size(76, 16)  
$label12.TabIndex = 8  
$label12.Text = "Classes  :"  
#'  
#' clbProperties  
#'  
$clbProperties.Anchor = "Bottom, top,left"  
$clbProperties.FormattingEnabled = $true  
$clbProperties.Location = new-object System.Drawing.Point(510, 27)  
$clbProperties.Name = "clbProperties"  
$clbProperties.Size = new-object System.Drawing.Size(220, 160)  
$clbProperties.TabIndex = 1  
#'  
#' lbMethods  
#'  
$lbMethods.Anchor = "Bottom, top, Left"  
$lbMethods.FormattingEnabled = $true  
$lbMethods.Location = new-object System.Drawing.Point(280, 27)  
$lbMethods.Name = "lbMethods"  
$lbMethods.Size = new-object System.Drawing.Size(220, 160)  
$lbMethods.TabIndex = 2  
#'  
#' lblProperties  
#'  
$lblProperties.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblProperties.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblProperties.Location = new-object System.Drawing.Point(110, 46)  
$lblProperties.Name = "lblProperties"  
$lblProperties.Size = new-object System.Drawing.Size(119, 20)  
$lblProperties.TabIndex = 13  
#'  
#' label8  
#'  
$label8.AutoSize = $true  
$label8.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label8.Location = new-object System.Drawing.Point(6, 46)  
$label8.Name = "label8"  
$label8.Size = new-object System.Drawing.Size(88, 16)  
$label8.TabIndex = 12  
$label8.Text = "Properties :"  
#'  
#' lblMethods  
#'  
$lblMethods.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblMethods.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblMethods.Location = new-object System.Drawing.Point(110, 66)  
$lblMethods.Name = "lblMethods"  
$lblMethods.Size = new-object System.Drawing.Size(119, 20)  
$lblMethods.TabIndex = 15  
#'  
#' label14  
#'  
$label14.AutoSize = $true  
$label14.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label14.Location = new-object System.Drawing.Point(6, 66)  
$label14.Name = "label14"  
$label14.Size = new-object System.Drawing.Size(79, 16)  
$label14.TabIndex = 14  
$label14.Text = "Methods  :"  
#'  
#' lblInstances  
#'  
$lblInstances.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblInstances.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblInstances.Location = new-object System.Drawing.Point(110, 86)  
$lblInstances.Name = "lblInstances"  
$lblInstances.Size = new-object System.Drawing.Size(119, 20)  
$lblInstances.TabIndex = 17  
#'  
#' label16  
#'  
$label16.AutoSize = $true  
$label16.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label16.Location = new-object System.Drawing.Point(6, 86)  
$label16.Name = "label16"  
$label16.Size = new-object System.Drawing.Size(82, 16)  
$label16.TabIndex = 16  
$label16.Text = "Instances :"  
#'  
#' grpInstances  
#'  
$grpInstances.Anchor = "Bottom, top, left, right"  
$grpInstances.Controls.Add($dgInstances)  
$grpInstances.Location = new-object System.Drawing.Point(17, 17)  
$grpInstances.Name = "grpInstances"  
$grpInstances.Size = new-object System.Drawing.Size(744, 202)  
$grpInstances.TabIndex = 0  
$grpInstances.TabStop = $False  
$grpInstances.Text = "Instances"  
#'  
#' dgInstances  
#'  
$dgInstances.Anchor = "Bottom, top, left, right"  
$dgInstances.ColumnHeadersHeightSizeMode = [System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode]::AutoSize  
$dgInstances.Location = new-object System.Drawing.Point(10, 19)  
$dgInstances.Name = "dgInstances"  
$dgInstances.Size = new-object System.Drawing.Size(728, 167)  
$dgInstances.TabIndex = 0  
$dginstances.ReadOnly = $true  
#' TabControl  
#'  
$TabControl.Controls.Add($tabPage1)  
$TabControl.Controls.Add($tabInstances)  
$TabControl.Controls.Add($tabMethods)  
$TabControl.Dock = [System.Windows.Forms.DockStyle]::Fill  
$TabControl.Location = new-object System.Drawing.Point(0, 0)  
$TabControl.Name = "TabControl"  
$TabControl.SelectedIndex = 0  
$TabControl.Size = new-object System.Drawing.Size(771, 234)  
$TabControl.TabIndex = 0  
#'  
#' tabPage1  
#'  
$tabPage1.Controls.Add($rtbHelp)  
$tabPage1.Location = new-object System.Drawing.Point(4, 22)  
$tabPage1.Name = "tabPage1"  
$tabPage1.Padding = new-object System.Windows.Forms.Padding(3)  
$tabPage1.Size = new-object System.Drawing.Size(763, 208)  
$tabPage1.TabIndex = 0  
$tabPage1.Text = "Help"  
$tabPage1.UseVisualStyleBackColor = $true  
#'  
#' tabInstances  
#'  
$tabInstances.Controls.Add($grpInstances)  
$tabInstances.Location = new-object System.Drawing.Point(4, 22)  
$tabInstances.Name = "tabInstances"  
$tabInstances.Padding = new-object System.Windows.Forms.Padding(3)  
$tabInstances.Size = new-object System.Drawing.Size(763, 208)  
$tabInstances.TabIndex = 1  
$tabInstances.Text = "Instances"  
$tabInstances.UseVisualStyleBackColor = $true  
#'  
#' richTextBox1  
#'  
$rtbHelp.Dock = [System.Windows.Forms.DockStyle]::Fill  
$rtbHelp.Location = new-object System.Drawing.Point(3, 3)  
$rtbHelp.Name = "richTextBox1"  
$rtbHelp.Size = new-object System.Drawing.Size(757, 202)  
$rtbHelp.TabIndex = 0  
$rtbHelp.Text = ""  
#'  
#' tabMethods  
#'  
$tabMethods.Location = new-object System.Drawing.Point(4, 22)  
$tabMethods.Name = "tabMethods"  
$tabMethods.Padding = new-object System.Windows.Forms.Padding(3)  
$tabMethods.Size = new-object System.Drawing.Size(763, 208)  
$tabMethods.TabIndex = 2  
$tabMethods.Text = "Methods"  
$tabMethods.UseVisualStyleBackColor = $true  
 
        $rtbMethods.Dock = [System.Windows.Forms.DockStyle]::Fill  
        $rtbMethods.Font = new-object System.Drawing.Font("Lucida Console",8 )  
        $rtbMethods.DetectUrls = $false  
        $tabMethods.controls.add($rtbMethods)  
         
#'endregion Configure Controls  
#' Configure  Main Form  
#'region frmMain  
 
#'  
$frmMain.AutoScaleDimensions = new-object System.Drawing.SizeF(6, 13)  
$frmMain.AutoScaleMode = [System.Windows.Forms.AutoScaleMode]::Font  
$frmMain.ClientSize = new-object System.Drawing.Size(1151, 591)  
$frmMain.Controls.Add($splitContainer1)  
$frmMain.Controls.Add($statusStrip)  
$frmMain.Controls.Add($MainMenu)  
$frmMain.MainMenuStrip = $mainMenu  
$FrmMain.Name = "frmMain"  
$FrmMain.Text = "/\/\o\/\/ PowerShell WMI Browser"  
$mainMenu.ResumeLayout($false)  
$mainMenu.PerformLayout()  
$MainMenu.ResumeLayout($false)  
$MainMenu.PerformLayout()  
$splitContainer1.Panel1.ResumeLayout($false)  
$splitContainer1.Panel2.ResumeLayout($false)  
$splitContainer1.ResumeLayout($false)  
$splitContainer2.Panel1.ResumeLayout($false)  
$splitContainer2.Panel2.ResumeLayout($false)  
$splitContainer2.ResumeLayout($false)  
$grpComputer.ResumeLayout($false)  
$grpComputer.PerformLayout()  
$grpNameSpaces.ResumeLayout($false)  
$grpClasses.ResumeLayout($false)  
$splitContainer3.Panel1.ResumeLayout($false)  
$splitContainer3.Panel2.ResumeLayout($false)  
$splitContainer3.ResumeLayout($false)  
$grpClass.ResumeLayout($false)  
$grpClass.PerformLayout()  
$grpStatus.ResumeLayout($false)  
$grpStatus.PerformLayout()  
$grpInstances.ResumeLayout($false)  
$TabControl.ResumeLayout($false)  
$tabPage1.ResumeLayout($false)  
$tabInstances.ResumeLayout($false)  
$frmMain.ResumeLayout($false)  
$FrmMain.PerformLayout()  
$status = new-object System.Windows.Forms.ToolStripStatusLabel  
$status.BorderStyle = 'SunkenInner'  
$status.BorderSides = 'All'  
$status.Text = "Not Connected"  
[void]$statusStrip.Items.add($status)  
$slMessage = new-object System.Windows.Forms.ToolStripStatusLabel  
$slMessage.BorderStyle = 'SunkenInner'  
$slMessage.BorderSides = 'All'  
$slMessage.Text = ""  
[void]$statusStrip.Items.add($slMessage)  
#'endregion frmMain  
#'endregion  
#'region Helper Functions  
Function out-PropertyGrid {  
  Param ($Object,[switch]$noBase,[Switch]$array)  
  $PsObject = $null  
  if ($object) {  
      $PsObject = $object  
  }Else{  
     if ($Array.IsPresent) {  
         $PsObject = @()  
         $input |ForEach-Object {$PsObject += $_}  
     }Else{  
         $input |ForEach-Object {$PsObject = $_}  
     }  
  }  
  if ($PsObject){  
      $form = new-object Windows.Forms.Form   
      $form.Size = new-object Drawing.Size @(600,600)   
      $PG = new-object Windows.Forms.PropertyGrid   
      $PG.Dock = 'Fill'   
      $form.text = "$psObject"   
      if ($noBase.IsPresent) {"no";  
          $PG.selectedobject = $psObject   
      }Else{  
          $PG.selectedobject = $psObject.PsObject.baseobject   
      }   
      $form.Controls.Add($PG)   
      $Form.Add_Shown({$form.Activate()})    
      $form.showdialog()  
  }  
} #'Function out-PropertyGrid  
Function Update-Status {  
  $script:computer = $Script:NameSpaces.__SERVER  
  $txtComputer.Text = $script:computer  
  $lblPath.Text = $Script:NameSpaces.__PATH                                 
  $lblProperties.Text = $Script:NameSpaces.__PROPERTY_COUNT                                 
  $lblClass.Text = $Script:NameSpaces.__RELPATH                                     
  $lblServer.Text = $script:Computer  
  $lblnamespace.Text = $Script:NameSpaces.__NAMESPACE  
} #' Function Update-Status  
Function Set-StatusBar ([Drawing.Color]$Color,$Text) {  
  $status.BackColor = $color  
  $status.Text = $text  
  $statusstrip.Update()    
}  
#'endregion Helper Functions  
#'################### Main ###############################  
#'region Global Variables  
$FontBold = new-object System.Drawing.Font("Microsoft Sans Serif",8,[Drawing.FontStyle]'Bold' )  
$fontNormal = new-object System.Drawing.Font("Microsoft Sans Serif",8,[Drawing.FontStyle]'Regular')  
$fontCode = new-object System.Drawing.Font("Lucida Console",8 )  
#' Create Script Variables for WMI Connection  
$Script:ConnectionOptions = new-object System.Management.ConnectionOptions  
$script:WmiConnection = new-object system.management.ManagementScope  
$script:WmiClass = [wmiClass]''  
#' NamespaceCaching , Make HashTable to store Treeview Items  
$script:nsc = @{}  
#' Make DataSet for secondary Cache  
$Script:dsCache = new-object data.dataset  
if (-not ${Global:WmiExplorer.dtClasses}){  
    ${Global:WmiExplorer.dtClasses} = new-object data.datatable  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Path',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Namespace',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('name',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Description',[string]))  
    ${Global:WmiExplorer.dtClasses}.tablename = 'Classes'  
}  
#'endregion  
#'region Control Handlers  
#' Add Delegate Scripts to finetune the WMI Connection objects to the events of the controls  
$slMessage.DoubleClickEnabled = $true  
$slMessage.add_DoubleClick({$error[0] | out-PropertyGrid})  
$lblNameSpace.add_DoubleClick({$script:WmiConnection | out-PropertyGrid})  
$lblserver.add_DoubleClick({$Script:ConnectionOptions | out-PropertyGrid})  
$lblClass.add_DoubleClick({$script:WmiClass | out-PropertyGrid})  
 
$btnConnect.add_click({ConnectToComputer})  
$TVNameSpaces.add_DoubleClick({GetClassesFromNameSpace})  
$lvClasses.Add_DoubleClick({GetWmiClass})  
$btnInstances.add_Click({GetWmiInstances})  
$dgInstances.add_DoubleClick({OutputWmiInstance})  
$lbMethods.Add_DoubleClick({GetWmiMethod})  
$clbProperties.add_Click({  
  trap{Continue}  
  $DGInstances.Columns.Item(($this.SelectedItem)).visible = -not $clbProperties.GetItemChecked($this.SelectedIndex)  
})  
$TVNameSpaces.add_AfterSelect({  
    if ($this.SelectedNode.name -ne $Computer){  
        $lblPath.Text = "$($script:WmiConnection.path.path.replace('\root',''))\$($this.SelectedNode.Text)"   
    }  
   
    $lblProperties.Text = $Script:NameSpaces.__PROPERTY_COUNT                                 
    $lblServer.Text = $Script:NameSpaces.__SERVER  
    $lblnamespace.Text = $this.SelectedNode.Text  
    if ($this.SelectedNode.tag -eq "NotEnumerated") {  
        (new-object system.management.managementClass(  
                "$($script:WmiConnection.path.path.replace('\root',''))\$($this.SelectedNode.Text):__NAMESPACE")  
        ).PSbase.getInstances() | Sort-Object $_.name |  
        ForEach-Object {  
          $TN = new-object System.Windows.Forms.TreeNode  
          $TN.Name = $_.name  
          $TN.Text = ("{0}\{1}" -f $_.__NameSpace,$_.name)  
          $TN.tag = "NotEnumerated"  
          $this.SelectedNode.Nodes.Add($TN)  
        }  
         
        #' Set tag to show this node is already enumerated  
        $this.SelectedNode.tag = "Enumerated"  
    }  
    $mp = ("{0}\{1}" -f $script:WmiConnection.path.path.replace('\root','') , $this.SelectedNode.text)  
    $lvClasses.Items.Clear()  
    if($Script:nsc.Item("$mp")){ #' in Namespace cache  
        $lvClasses.BeginUpdate()  
        $lvClasses.Items.AddRange(($nsc.Item( "$mp")))  
        $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
        $lvClasses.EndUpdate()  
        $lblClasses.Text = $lvClasses.Items.count  
    } else {  
        if(${Global:WmiExplorer.dtClasses}.Select("Namespace='$mp'")){ #' In DataTable Cache  
            $status.BackColor = 'beige'  
            $status.Text = "$mp : Classes in Cache, DoubleClick NameSpace to retrieve Classes"  
        } else {  
            $status.BackColor = 'LightSalmon'  
            $status.Text = "$mp : Classes not recieved yet, DoubleClick NameSpace to retrieve Classes"  
        }  
    }  
}) #' $TVNameSpaces.add_AfterSelect  
#'endregion  
#'region Processing Functions  
#'region ConnectToComputer  
#' Connect to Computer  
Function ConnectToComputer {  
     
    $computer = $txtComputer.Text  
    Set-StatusBar 'beige' "Connecting to : $computer"  
     
    #' Try to Connect to Computer  
    &amp;{  
        trap {  
            Set-StatusBar 'Red' "Connecting to : $computer Failed"  
            $slMessage.Text = "$_.message"  
            Continue  
        }  
        &amp;{  
            #' Connect to WMI root  
             
            $script:WmiConnection.path = "\\$computer\root"  
            $script:WmiConnection.options = $Script:ConnectionOptions  
            $script:WmiConnection.Connect()  
             
            #' Get Avaiable NameSpaces  
     
            $opt = new-object system.management.ObjectGetOptions  
            $opt.UseAmendedQualifiers = $true  
            $Script:NameSpaces = new-object System.Management.ManagementClass(  
                $script:WmiConnection,[Management.ManagementPath]'__Namespace',$opt  
            )  
            Update-Status  
            #' Create a TreeNode for the WMI Root found  
            $computer = $txtComputer.Text  
            $TNRoot = new-object System.Windows.Forms.TreeNode("Root")  
            $TNRoot.Name = $Computer  
            $TNRoot.Text = $lblPath.Text  
            $TNRoot.tag = "Enumerated"  
             
            #' Create NameSpaces List  
             
            $Script:NameSpaces.PSbase.getInstances() | Sort-Object $_.name |  
            ForEach-Object {  
                $TN = new-object System.Windows.Forms.TreeNode  
                $TN.Name = $_.name  
                $TN.Text = ("{0}\{1}" -f $_.__NameSpace,$_.name)  
                $TN.tag = "NotEnumerated"  
                [void]$TNRoot.Nodes.Add($TN)  
            }  
            #' Add to Treeview  
            $tvNameSpaces.Nodes.clear()  
            [void]$TVNamespaces.Nodes.Add($TNRoot)  
             
            #' update StatusBar  
            Set-StatusBar 'YellowGreen' "Connected to : $computer"  
        }  
    }  
} #' ConnectToComputer  
#'endregion  
#'region GetClasseFromNameSpace  
#' Get Classes on DoubleClick on Namespace in TreeView  
Function GetClassesFromNameSpace {  
  if ($this.SelectedNode.name -ne $script:computer){  
    #' Connect to WMI Namespace  
         
    $mp = ("{0}\{1}" -f $script:WmiConnection.path.path.replace('\root','') , $this.SelectedNode.text)  
      #' Update Status  
         
      $lvClasses.BeginUpdate()  
      $lvClasses.Items.Clear()  
      $i = 0 ;$lblClasses.Text = $i; $lblclasses.Update()  
    if($Script:nsc.Item("$mp")){ #'in Namespace Cache, so just attach to ListView again  
         
        $lvClasses.Items.AddRange(($nsc.Item( "$mp")))  
        #' $lvClasses.Items.AddRange(([System.Windows.Forms.ListViewItem[]]($nsc.Item( "$mp") |  
            #' where {$_.name -like 'win32_*'})))  
        $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
        $i = $lvClasses.Items.count  
    } else { #'Not In NameSpace Cache  
      if(${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'")){ #' In DataTable cache, so get from there  
        $status.Text = "loading cache from $($this.SelectedNode.name)"  
        $statusStrip.Update()  
        ${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'") |  
        foreach {  
            $i++  
            $LI = New-Object system.Windows.Forms.ListViewItem  
            $li.Name = $_.name  
            $li.Text = $_.name  
            $li.SubItems.add($_.description)  
            $li.SubItems.add($_.path)  
            $li.ToolTipText = ($_.description)  
            $lvClasses.Items.add($li)  
            $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
            $lblClasses.Text = $lvClasses.Items.count  
        }  
      } else { #' Not in any Cache , Load WMI Classes  
        Set-StatusBar 'Khaki' "Getting Classes from $($this.SelectedNode.name)"  
        $mc = new-object System.Management.ManagementClass($mp,$opt)  
        $eo = New-Object system.management.EnumerationOptions  
        $eo.EnumerateDeep = $true  
        $eo.UseAmendedQualifiers = $true  
        $Mc.psbase.GetSubclasses($eo) |  
        ForEach-Object  {  
            $i++ ; if ($i%10 -eq 0){$lblClasses.Text = $i;$lblclasses.Update() }  
            Trap{$script:Description = "[Empty]";continue}  
            $script:description = $_.psbase.Qualifiers.item("description").value  
            ${Global:WmiExplorer.dtClasses}.Rows.Add($_.__path,$mp,$_.name,$description)  
            $LI = New-Object system.Windows.Forms.ListViewItem  
            $li.Name = $_.name  
            $li.Text = $_.name  
            $li.SubItems.add($description)  
            $li.SubItems.add($_.__path)  
            $li.ToolTipText = $description  
            $lvClasses.Items.add($li)  
        }  
        $status.Text = "Ready, Retrieved $i Classes from $mp"  
      } #'if(${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'"))  
      $lvClasses.Sorting = 'Ascending'  
      $lvClasses.Sort()  
      $script:nsc.Add($mp,(([System.Windows.Forms.ListViewItem[]]($lvClasses.Items)).clone()))  
       
    }  
    $lvClasses.EndUpdate()  
    $this.selectedNode.BackColor = 'AliceBlue'  
    $lblClasses.Text = $i;$lblclasses.Update()  
    $status.BackColor = 'YellowGreen'  
    $statusStrip.Update()  
  } #'if($Script:nsc.Item("$mp"))  
     
} #' GetClassesFromNameSpace  
#'endregion  
#'region GetWmiClass  
Function GetWmiClass {  
    #' Update Status  
     
    $status.Text = "Retrieving Class"  
    $status.BackColor = 'Khaki'  
    $statusstrip.Update()  
    $lblClass.Text =  $this.SelectedItems |ForEach-Object {$_.name}  
    $lblPath.text = $this.SelectedItems |ForEach-Object {"$($_.SubItems[2].text)"}  
     
    #' Add HelpText  
     
    $rtbHelp.Text = ""  
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext("$($lblClass.Text)`n`n")  
    $rtbHelp.selectionFont  = $fontNormal  
    $rtbHelp.appendtext(($this.SelectedItems |ForEach-Object {"$($_.SubItems[1].text)"}))  
    $rtbHelp.appendtext("`n")  
    $path = $lblPath.text  
     
    $opt = new-object system.management.ObjectGetOptions  
    $opt.UseAmendedQualifiers = $true  
     
    $script:WmiClass = new-object system.management.ManagementClass($path,$opt)  
    #' Add Property Help  
     
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext("`n$($lblClass.Text) Properties :`n`n")  
    $rtbHelp.selectionFont  = $fontNormal  
     
    $i = 0 ;$lblProperties.Text = $i; $lblProperties.Update()  
    $clbproperties.Items.Clear()  
    $clbProperties.Items.add('WmiPath',$False)  
             
    $script:WmiClass.psbase.properties |  
    ForEach-Object {  
        $i++ ;$lblProperties.Text = $i; $lblProperties.Update()  
        $clbProperties.Items.add($_.name,$true)  
        $rtbHelp.selectionFont  = $fontBold  
        $rtbHelp.appendtext("$($_.Name) :`n" )  
        &amp;{  
            Trap {$rtbHelp.appendtext("[Empty]");Continue}  
            $rtbHelp.appendtext($_.psbase.Qualifiers["description"].value)  
        }  
        $rtbHelp.appendtext("`n`n")  
    } #' ForEach-Object  
     
    #' Create Method Help  
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext( "$($lblClass.Text) Methods :`n`n" )  
    $i = 0 ;$lblMethods.Text = $i; $lblMethods.Update()  
    $lbmethods.Items.Clear()  
     
    $script:WmiClass.psbase.Methods |  
    ForEach-Object {  
        $i++ ;$lblMethods.Text = $i; $lblMethods.Update()  
        $lbMethods.Items.add($_.name)  
        $rtbHelp.selectionFont  = $fontBold  
        $rtbHelp.appendtext("$($_.Name) :`n")  
        &amp;{  
            Trap {$rtbHelp.Text += "[Empty]"}  
            $rtbHelp.appendtext($_.Qualifiers["description"].value)  
        }  
        $rtbHelp.appendtext("`n`n" )  
    } #'ForEach-Object  
      
    $tabControl.SelectedTab = $tabpage1  
    $status.Text = "Retrieved Class"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
} #' GetWmiClass  
#'endregion  
#'region GetWmiInstances  
Function GetWmiInstances {  
    $status.Text = "Getting Instances for $($lblClass.text)"  
    $status.BackColor = 'Red'  
    $statusstrip.Update()  
    $tabControl.SelectedTab = $tabInstances  
    $MC = new-object system.management.ManagementClass $lblPath.text  
    $MOC = $MC.PSbase.getInstances()  
     
    #'trap{"Class Not found";break}  
     
    $DT =  new-object  System.Data.DataTable  
    $DT.TableName = $lblClass.text  
    $Col =  new-object System.Data.DataColumn  
    $Col.ColumnName = "WmiPath"  
    $DT.Columns.Add($Col)  
    $i = 0  
    $j = 0 ;$lblInstances.Text = $j; $lblInstances.Update()  
    $MOC | ForEach-Object {  
        $j++ ;$lblInstances.Text = $j; $lblInstances.Update()  
        $MO = $_  
         
        #' Make a DataRow  
        $DR = $DT.NewRow()  
        $Col =  new-object System.Data.DataColumn  
         
        $DR.Item("WmiPath") = $mo.__PATH  
        $MO.psbase.properties |  
        ForEach-Object {  
            $prop = $_  
            If ($i -eq 0)  {  
     
                #' Only On First Row make The Headers  
                 
                $Col =  new-object System.Data.DataColumn  
                $Col.ColumnName = $prop.Name.ToString()  
                $prop.psbase.Qualifiers | ForEach-Object {  
                    If ($_.Name.ToLower() -eq "key") {  
                        $Col.ColumnName = $Col.ColumnName + "*"  
                    }  
                }  
                $DT.Columns.Add($Col)   
            }  
             
            #' fill dataRow   
             
            if ($prop.value -eq $null) {  
                $DR.Item($prop.Name) = "[empty]"  
            }  
            ElseIf ($prop.IsArray) {  
                                $ofs = ";"  
                $DR.Item($prop.Name) ="$($prop.value)"  
                                $ofs = $null  
            }  
            Else {  
                $DR.Item($prop.Name) = $prop.value  
                #'Item is Key try again with *  
                trap{$DR.Item("$($prop.Name)*") = $prop.Value.tostring();continue}  
            }  
        }  
        #' Add the row to the DataTable  
        $DT.Rows.Add($DR)  
        $i += 1  
    }  
    $DGInstances.DataSource = $DT.psObject.baseobject  
        $DGInstances.Columns.Item('WmiPath').visible =  $clbProperties.GetItemChecked(0)   
    $status.Text = "Retrieved $j Instances"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
} #' GetWmiInstances  
#'endregion  
#'region OutputWmiInstance  
Function OutputWmiInstance {  
    if ( $this.SelectedRows.count -eq 1 ) {  
        if (-not $Script:InstanceTab) {$Script:InstanceTab = new-object System.Windows.Forms.TabPage  
            $Script:InstanceTab.Name = 'Instance'  
            $Script:rtbInstance = new-object System.Windows.Forms.RichTextBox  
            $Script:rtbInstance.Dock = [System.Windows.Forms.DockStyle]::Fill  
            $Script:rtbInstance.Font = $fontCode  
            $Script:rtbInstance.DetectUrls = $false  
            $Script:InstanceTab.controls.add($Script:rtbInstance)  
            $TabControl.TabPages.add($Script:InstanceTab)  
        }  
        $Script:InstanceTab.Text = "Instance = $($this.SelectedRows | ForEach-Object {$_.DataboundItem.wmiPath.split(':')[1]})" 
        $Script:rtbInstance.Text = $this.SelectedRows |ForEach-Object {$_.DataboundItem |Format-List  * | out-String -width 1000 } 
        $tabControl.SelectedTab = $Script:InstanceTab  
    }  
}  #' OutputWmiInstance  
#'endregion  
#'region GetWmiMethod  
Function GetWmiMethod {  
    $WMIMethod = $this.SelectedItem  
    $WmiClassName = $script:WmiClass.__Class  
    $tabControl.SelectedTab = $tabMethods  
    #'$rtbmethods.ForeColor = 'Green'  
    $rtbMethods.Font  = new-object System.Drawing.Font("Microsoft Sans Serif",8)  
    $rtbMethods.text = ""  
    $rtbMethods.selectionFont  = $fontBold  
     
    $rtbMethods.AppendText(("{1} Method : {0} `n" -f $this.SelectedItem , $script:WmiClass.__Class))  
    $rtbMethods.AppendText("`n")  
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("OverloadDefinitions:`n")  
    $rtbMethods.AppendText("$($script:WmiClass.$WMIMethod.OverloadDefinitions)`n`n")  
    $Qualifiers=@()  
    $script:WmiClass.psbase.Methods[($this.SelectedItem)].Qualifiers | ForEach-Object {$qualifiers += $_.name}  
    #'$rtbMethods.AppendText( "$qualifiers`n" )  
    $static = $Qualifiers -Contains "Static"   
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText( "Static : $static`n" )  
    If ($static) {   
         $rtbMethods.AppendText( "A Static Method does not an Instance to act upon`n`n" )  
         $rtbMethods.AppendText("`n")  
     
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Sample Of Connecting to a WMI Class`n`n")  
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $SB = new-Object text.stringbuilder  
         $SB = $SB.Append('$Computer = "') ; $SB = $SB.AppendLine(".`"")  
         $SB = $SB.Append('$Class = "') ; $SB = $SB.AppendLine("$WmiClassName`"")    
         $SB = $SB.Append('$Method = "') ; $SB = $SB.AppendLine("$WmiMethod`"`n")  
         $SB = $SB.AppendLine('$MC = [WmiClass]"\\$Computer\' + "$($script:WmiClass.__NAMESPACE)" + ':$Class"')    
         #'$SB = $SB.Append('$MP.Server = "') ; $SB = $SB.AppendLine("$($MP.Server)`"")    
         #'$SB = $SB.Append('$MP.NamespacePath = "') ; $SB = $SB.AppendLine("$($script:WmiClass.__NAMESPACE)`"")    
         #'$SB = $SB.AppendLine('$MP.ClassName = $Class')  
         $SB = $SB.AppendLine("`n")     
         #'$SB = $SB.AppendLine('$MC = new-object system.management.ManagementClass($MP)')    
         $rtbMethods.AppendText(($sb.tostring()))  
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Getting information about the methods`n`n")  
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText(  
             '$mc' + "`n" +  
             '$mc | Get-Member -membertype Method' + "`n" +  
             "`$mc.$WmiMethod"  
         )  
    } Else {  
         $rtbMethods.AppendText( "This is a non Static Method and needs an Instance to act upon`n`n" )  
         $rtbMethods.AppendText( "The Example given will use the Key Properties to Connect to a WMI Instance : `n`n" )  
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Example Of Connecting to an Instance`n`n")  
     
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $SB = new-Object text.stringbuilder  
         $SB = $SB.AppendLine('$Computer = "."')  
         $SB = $SB.Append('$Class = "') ; $SB = $SB.AppendLine("$WmiClassName.`"")    
         $SB = $SB.Append('$Method = "') ; $SB = $SB.AppendLine("$WMIMethod`"")  
         $SB = $SB.AppendLine("`n#' $WmiClassName. Key Properties :")    
         $Filter = ""    
         $script:WmiClass.psbase.Properties | ForEach-Object {    
           $Q = @()  
           $_.psbase.Qualifiers | ForEach-Object {$Q += $_.name}   
           $key = $Q -Contains "key"   
           If ($key) {    
             $CIMType = $_.psbase.Qualifiers["Cimtype"].Value    
             $SB = $SB.AppendLine("`$$($_.Name) = [$CIMType]")    
             $Filter += "$($_.name) = `'`$$($_.name)`'"     
           }    
         }    
         $SB = $SB.Append("`n" + '$filter=');$SB = $SB.AppendLine("`"$filter`"")    
         $SB = $SB.AppendLine('$MC = get-WMIObject $class -computer $Computer -Namespace "' +  
             "$($script:WmiClass.__NAMESPACE)" + '" -filter $filter' + "`n")  
         $SB = $SB.AppendLine('#' $MC = [Wmi]"\\$Computer\Root\CimV2:$Class.$filter"')   
         $rtbMethods.AppendText(($sb.tostring()))  
    }   
    $SB = $SB.AppendLine('$InParams = $mc.psbase.GetMethodParameters($Method)')  
    $SB = $SB.AppendLine("`n")  
    #' output Method Parameter Help  
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("`n`n$WmiClassName. $WMIMethod Method :`n`n")   
    $q = $script:WmiClass.PSBase.Methods[$WMIMethod].Qualifiers | foreach {$_.name}  
    if ($q -contains "Description") {  
         $rtbMethods.AppendText(($script:WmiClass.psbase.Methods[$WMIMethod].psbase.Qualifiers["Description"].Value))  
    }   
   
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("`n`n$WMIMethod Parameters :`n")   
  #' get the Parameters   
    
  $inParam = $script:WmiClass.psbase.GetMethodParameters($WmiMethod)  
  $HasParams = $False   
  if ($true) {   
    trap{$rtbMethods.AppendText('[None]') ;continue}    
    $inParam.PSBase.Properties | foreach {   
      $Q = $_.Qualifiers | foreach {$_.name}  
      #' if Optional Qualifier is not present then Parameter is Mandatory   
      $Optional = $q -contains "Optional"  
      $CIMType = $_.Qualifiers["Cimtype"].Value   
      $rtbMethods.AppendText("`nName = $($_.Name) `nType = $CIMType `nOptional = $Optional")  
      #' write Parameters to Example script   
      if ($Optional -eq $TRUE) {$SB = $SB.Append('#' ')}   
      $SB = $SB.Append('$InParams.');$SB = $SB.Append("$($_.Name) = ");$SB = $SB.AppendLine("[$CIMType]")   
      if ($q -contains "Description") {$rtbMethods.AppendText($_.Qualifiers["Description"].Value)}  
      $HasParams = $true    
    }   
  }  
  #' Create the Rest of the Script  
  $rtbMethods.selectionFont  = $fontBold  
  $rtbMethods.AppendText("`n`nTemplate Script :`n")   
  #' Call diferent Overload as Method has No Parameters   
  If ($HasParams -eq $True) {   
      $SB = $SB.AppendLine("`n`"Calling $WmiClassName. : $WMIMethod with Parameters :`"")   
      $SB = $SB.AppendLine('$inparams.PSBase.properties | select name,Value | format-Table')   
      $SB = $SB.AppendLine("`n" + '$R = $mc.PSBase.InvokeMethod($Method, $inParams, $Null)')   
  }Else{   
      $SB = $SB.AppendLine("`n`"Calling $WmiClassName. : $WMIMethod `"")   
      $SB = $SB.AppendLine("`n" + '$R = $mc.PSBase.InvokeMethod($Method,$Null)')   
  }   
  $SB = $SB.AppendLine('"Result :"')   
  $SB = $SB.AppendLine('$R | Format-list' + "`n`n")  
  #' Write Header of the Sample Script :   
   
  $rtbMethods.SelectionColor = 'Green'  
  $rtbMethods.SelectionFont = $fontCode  
  $rtbMethods.AppendText(@"  
#' $WmiClassName. $WMIMethod-Method Template Script"   
#' Created by PowerShell WmiExplorer  
#' /\/\o\/\/ 2006  
#' www.ThePowerShellGuy.com  
#'  
#' Fill InParams values before Executing   
#' InParams that are Remarked (#) are Optional  
"@  
  )  
  $rtbMethods.SelectionColor = 'Black'  
  #'$rtbMethods.SelectionFont = $fontCode  
  $rtbMethods.AppendText("`n`n" + $SB)  
  $rtbMethods.SelectionFont = new-object System.Drawing.Font("Lucida Console",6 )  
  $rtbMethods.AppendText("`n`n Generated by the PowerShell WMI Explorer  /\/\o\/\/ 2006" )  
         
} #' GetWmiMethod  
#'endregion  
#'endregion  
#' Show the Form  
$FrmMain.Add_Shown({$FrmMain.Activate()})  
   
trap {Write-Host $_ ;$status.Text = "unexpected error";$slMessage.Text = "$_.message";continue}  
&amp; {  
    [void]$FrmMain.showdialog()  
}  
#' Resolve-Error $Error[0] | out-string</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_XML</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>RollYourOwn_xml_data</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_XML</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>RollYourOwn_xml_data</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># get some data
$data = Get-Hotfix -ComputerName $env:computername | 
Select Caption,InstalledOn,InstalledBy,HotfixID,Description



# create name map
$map = [ordered]@{
    'update-id' = 'HotFixID'
    'update-type' = 'Description'
    'install-date' = 'InstalledOn'
    'install-by' = 'InstalledBy'
    caption = 'Caption'
}



# new XML doc
[xml]$Doc = New-Object System.Xml.XmlDocument



# doc properties
$dec = $Doc.CreateXmlDeclaration("1.0","UTF-8",$null)
$doc.AppendChild($dec) | Out-Null



# append info
$text = @"

Hotfix Inventory
$(Get-Date)

"@

$doc.AppendChild($doc.CreateComment($text)) | Out-Null



# create node
$root = $doc.CreateNode("element","Computer",$null)
$name = $doc.CreateElement("Name")
$name.InnerText = $env:computername
$root.AppendChild($name) | Out-Null



# updates
$hf = $doc.CreateNode("element","Updates",$null)



# add items
foreach ($item in $data) {
    $h = $doc.CreateNode("element","Update",$null)
    #create the entry values from the mapping hash table
    $map.GetEnumerator() | foreach {
      $e = $doc.CreateElement($_.Name)
      $e.innerText = $item.$($_.value)
      #append to Update
      $h.AppendChild($e) | Out-Null
    }
    #append the element
    $hf.AppendChild($h) | Out-Null
}



# finish up
$root.AppendChild($hf) | Out-Null
$doc.AppendChild($root) | Out-Null
$doc.Save("c:\work\hotfix.xml")



# final XML
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--
Hotfix Inventory
02/06/2017 15:11:44
--&gt;
&lt;Computer&gt;
  &lt;Name&gt;CLI01&lt;/Name&gt;
  &lt;Updates&gt;
    &lt;Update&gt;
      &lt;update-id&gt;KB2899189_Microsoft-Windows-CameraCodec-Package&lt;/update-id&gt;
      &lt;update-type&gt;Update&lt;/update-type&gt;
      &lt;install-date&gt;12/11/2013 00:00:00&lt;/install-date&gt;
      &lt;install-by&gt;NT AUTHORITY\SYSTEM&lt;/install-by&gt;
      &lt;caption&gt;http://support.microsoft.com/kb/2899189&lt;/caption&gt;
    &lt;/Update&gt;
    &lt;Update&gt;
      &lt;update-id&gt;KB2693643&lt;/update-id&gt;
      &lt;update-type&gt;Update&lt;/update-type&gt;
      &lt;install-date&gt;11/26/2013 00:00:00&lt;/install-date&gt;
      &lt;install-by&gt;CLI01\Jeff&lt;/install-by&gt;
      &lt;caption&gt;
      &lt;/caption&gt;
    &lt;/Update&gt;
...
  &lt;/Updates&gt;
&lt;/Computer&gt;

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Button</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>01_btn_DeleteRecord_using_StoredProcedure_on_ChildForm__SQL_SP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Button</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>01_btn_DeleteRecord_using_StoredProcedure_on_ChildForm__SQL_SP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_01_SP_206_DELETE_COI_for_MSA_ID_return_1_if_OK.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 1/7/2016
	By: glenn garson
	************************************************************************************
*/



USE [COI]
GO


create Procedure prj_01_SP_206_DELETE_COI_for_MSA_ID_return_1_if_OK(
		@COI_for_MSA_ID as INT
	)

	as
-- START DEBUGGING SECTION -------------------	
		
	PRINT '4) Input @COI_for_MSA_ID: [' + CAST(@COI_for_MSA_ID AS varchar(5)) + ']'
	
-- END DEBUGGING SECTION -------------------


-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

		
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 1]
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

IF (@COI_for_MSA_ID is not null) 
		BEGIN
				DELETE
				FROM  [T102_COI_for_MSA]
				WHERE (	
						(T102_COI_for_MSA.COI_for_MSA_ID = @COI_for_MSA_ID)
					   )

 							

				IF @@ERROR &lt;&gt; 0
					BEGIN
						PRINT 'Darn It! there was a problem Deleting the  record from T102_COI_for_MSA'
						RETURN 0
					END
				ELSE
					BEGIN

						PRINT 'YEAH!, The LNK  was deleted from T102_COI_for_MSA'
						RETURN 1						
					END


	
		END
ELSE
		BEGIN
				PRINT 'Huh?, The PK for the record was  not supplied!'
				RETURN(0)

		END	
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Events_on_ComboBox_and_other_Controls</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>COMBOBOX_NotInList_addToBackEndTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Events_on_ComboBox_and_other_Controls</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>COMBOBOX_NotInList_addToBackEndTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>COMBOBOX_NotInList_addToBackEndTable

'Especially for drop-down Combo box pulling from another table 
'The general idea is that you create a subform that's bound to your link table, 
'and make one of the fields in the subform a combo box bound to the child record ID that's in your link table. 
'Fill the combo box using records in the child table.

'Then you handle the NotInList event on the combo box to prompt the user to add the record to the child table 
'(or whatever is appropriate for your application).

http://fontstuff.com/access/acctut20.htm

Limit To List Property
'If you set the Limit To List Property of a combo box to Yes any input from the user 
'	that does not match an item on the list prompts the NotInList event to fire. 
'	What happens next is up to you. You can leave it at that. 
'	Access will display its standard message (see example above) and the form absolutely 
'	refuses to accept any input into the combo box other than one which matches an item on the list. 
'	But you still have a number of options...

'1] In form design view open the properties window of the combo box (by right-clicking on it and choosing Properties).
'2]Click the Event tab and double-click the On Not in List property text box. 
'	You will see the text [Event Procedure] appear in the text box.
'3] Click the build button (  The "Build" button. ) to open the form's code module in the Visual Basic Editor with an empty code procedure...

'	The first line of the procedure declares two parameters (shown between the brackets) 
'	that you can make use of in your code:

		 Private Sub cboGender_NotInList(NewData As String, Response As Integer)

NewData 
'holds the text that the user entered into the combo box and that was rejected, 
'	causing the event to fire. You can make use of this, for example, 
'	to read back the unacceptable entry to the user in a custom message. 
'	Alternatively, you could offer to add it to the list by writing it into the list's source table. 
'	This parameter is treated as a String (a piece of text) regardless of the field's data type.

Response 
'represents an instruction to Access on how to proceed. 
'	There are three possible values represented by constants 
'	(all VBA constants can be referred to by name or by their numerical value 
'		which is why this parameter is an Integer): 
		acDataErrContinue 
		'	(return to the combo box and open the list), 
		acDataErrDisplay 
		'	(show the standard message), 
		acDataErrAdded 
		'	(the item has been added to the list).
---------------------------------------------
'Offer to Accept the Entry By Adding It to the List 

Private Sub cboJobTitle_NotInList(NewData As String,  
   Response As Integer)
    On Error GoTo cboJobTitle_NotInList_Err
    Dim intAnswer As Integer
    Dim strSQL As String
    intAnswer = MsgBox("The job title " &amp; Chr(34) &amp; NewData &amp; _
        Chr(34) &amp; " is not currently listed." &amp; vbCrLf &amp; _
        "Would you like to add it to the list now?" _
        , vbQuestion + vbYesNo, "Acme Oil and Gas")
    If intAnswer = vbYes Then
        strSQL = "INSERT INTO tblJobTitles([JobTitle]) " &amp; _
                 "VALUES ('" &amp; NewData &amp; "');"
        DoCmd.SetWarnings False
        DoCmd.RunSQL strSQL
        DoCmd.SetWarnings True
        MsgBox "The new job title has been added to the list." _
            , vbInformation, "Acme Oil and Gas"
        Response = acDataErrAdded
    Else
        MsgBox "Please choose a job title from the list." _
            , vbInformation, "Acme Oil and Gas"
        Response = acDataErrContinue
    End If
cboJobTitle_NotInList_Exit:
    Exit Sub
cboJobTitle_NotInList_Err:
    MsgBox Err.Description, vbCritical, "Error"
    Resume cboJobTitle_NotInList_Exit
End Sub

'Finally, I used acDataErrAdded to tell Access that I have added the item to the combo box's Row Source. 
'	When it receives this information it requeries the combo box to refresh the list 
'	then compares the entry with it again. 
'If everything is OK the form accepts the entry and allows the user to move on.

-----------------------------------------------------------------		   
'Refuse the Entry and Include It in the Message
Private Sub cboGender_NotInList(NewData As String,
   Response As Integer)
    MsgBox "You can not enter " &amp; Chr(34) &amp; NewData &amp; Chr(34) &amp; _
    " here. Enter M for Male or F for Female." &amp; vbCrLf &amp; _
    "If you do not know the person's gender please leave " &amp; _
    "the box empty.", vbExclamation, "Acme Oil and Gas"
    Response = acDataErrContinue
End Sub
'Note that the code makes use of the character code Chr(34) to insert quote marks into the message..
----------------------------------------
'Refuse the Entry with a Custom Message
Private Sub cboGender_NotInList(NewData As String,
   Response As Integer)
    MsgBox "Sorry, I can not accept that entry." &amp; vbCrLf &amp; _
        "Please choose an item from the list." _
        , vbExclamation, "Acme Oil and Gas"
    Response = acDataErrContinue
End Sub		    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Button_To_Filter_Records_On_a_Form</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Button_To_Filter_Records_On_a_Form</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords>filter records</Keywords>
        <Imports />
        <Code>
=============This one counts the results from the various parts of the Where, and bases the filter on those counts

Private Sub cmdFilterRecords_Click()
On Error GoTo Err_cmdFilterRecords_Click
     Dim strX As String
     strX = BuildFilter

    'For filtering the form itself use:
     Me.Form.RecordSource = strX

     Me.Requery
     
Exit_cmdFilterRecords_Click:
    Exit Sub

Err_cmdFilterRecords_Click:
    MsgBox Err.Description
    Resume Exit_cmdFilterRecords_Click

End Sub


Private Function BuildFilter() As Variant
    
    On Error GoTo ErrorHandler
    
    '=========================
    Dim varWhere As Variant

    varWhere = Null  ' Main filter

    If Me.txt_FilterBy &gt; "" Then
        varWhere = varWhere &amp; "[dbo_T201_Trucker.A1_Trucking_Company_Name] LIKE" &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Number] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Company_Address_1] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Company_Address_2] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Contact_Notes] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Company_Address_3] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' "
        
    End If
    
    Dim countArray(5) As Variant
	'dbo_T201_Trucker is the linked SQL table
     countArray(0) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Name]", "q_T201_Trucker", varWhere)
     countArray(1) = DCount("[dbo_T201_Trucker.A1_Trucking_Number]", "q_T201_Trucker", varWhere)
     countArray(2) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_1]", "q_T201_Trucker", varWhere)
     countArray(3) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_2]", "q_T201_Trucker", varWhere)
     countArray(4) = DCount("[dbo_T201_Trucker.A1_Trucking_Contact_Notes]", "q_T201_Trucker", varWhere)
     countArray(5) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_3]", "q_T201_Trucker", varWhere)
     
     Dim iCount_max As Variant

     iCount_max = MaxInList(countArray(0), countArray(1), countArray(2), countArray(3), countArray(4), countArray(5))
     
    If IsNull(varWhere) Or iCount_max = 0 Then
        varWhere = "SELECT dbo_T201_Trucker.* FROM dbo_T201_Trucker"
        
        If iCount_max = 0 Then
            MsgBox "No records were found that met your criteria"
        End If
    Else
        varWhere = "SELECT dbo_T201_Trucker.* FROM dbo_T201_Trucker WHERE" &amp; varWhere

    End If

    BuildFilter = varWhere
        '=========================
    Exit Function
            
ErrorHandler:
        Select Case Err.Number

            Case 3075  '
                MsgBox "There was a problem. You may have had an illegal character in your search string (e.g. an apostrophe). Remove the part with any non-alphatical characters and try again"
                BuildFilter = "SELECT dbo_T201_Trucker.* FROM dbo_T201_Trucker"

                Exit Function
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Function


Function MaxInList(ParamArray ArrayList() As Variant)
    'Function will return the maximum value from a list of values
       
    Dim n As Integer
    Dim iValue As Variant
     
    'Set the variable iValue - initialize to the first item or value in list.
    iValue = ArrayList(0)
    
    'Checks each item or value in the list to find the largest.
    For n = 0 To UBound(ArrayList)
    'Determines the largest value.
    If ArrayList(n) &gt; iValue Then
        iValue = ArrayList(n)
    End If
    
    Next n
    
    MaxInList = iValue
   
End Function

====================for the query, I just had it pull all the fields from the table, but really just need the ones being counted =======================================
'ACCESS QUERY:  q_T201_Trucker
SELECT 
	dbo_T201_Trucker.Trucker_ID, 
	dbo_T201_Trucker.TruckerInsuranceRates_ID, 
	dbo_T201_Trucker.A1_Trucking_Company_Name, 
	dbo_T201_Trucker.A1_BOOL_ActiveOwnerOperator, 
	dbo_T201_Trucker.A1_Trucking_Number, 
	dbo_T201_Trucker.A1_Status_Note, 
	dbo_T201_Trucker.A1_Last_Used, 
	dbo_T201_Trucker.A1_Trucking_Company_Email, 
	dbo_T201_Trucker.A1_Trucking_Company_Phone_Number, 
	dbo_T201_Trucker.A1_Trucking_Company_Address_1, 
	dbo_T201_Trucker.A1_Trucking_Company_Address_2, 
	dbo_T201_Trucker.A1_Trucking_Company_Address_3, 
	dbo_T201_Trucker.A1_Trucking_ZipCode, 
	dbo_T201_Trucker.A1_Trucking_Contact_Notes, 
	dbo_T201_Trucker.A1_Is_a_Broker_bool, 
	dbo_T201_Trucker.A2_BOOL_First_Notice_Sent, 
	dbo_T201_Trucker.A2_BOOL_Second_Notice_Sent, 
	dbo_T201_Trucker.A2_Date_First_Notice_Sent, 
	dbo_T201_Trucker.A2_Date_Second_Notice_Sent, 
	dbo_T201_Trucker.A2_Cut_Off_Date, 
	dbo_T201_Trucker.A3_UserName_CreatedBy, 
	dbo_T201_Trucker.A3_ComputerName_CreatedBy, 
	dbo_T201_Trucker.A3_DateTime_CreatedBy, 
	dbo_T201_Trucker.A1_HasExplorerTruckingNumber
FROM dbo_T201_Trucker;

=======This works but does not count================================================================================================================
'Button_To_Filter_Records_On_a_Form


'1] The button:

Private Sub cmdFilterRecords_Click()


On Error GoTo Err_cmdFilterRecords_Click


     Dim strX As String
     strX = BuildFilter

	'For filtering the form itself use:
     Me.Form.RecordSource = strX
     
     'For a subform use: ================================
     Me!vw_T1_T2_sf.Form.RecordSource = strX
	 '================================ Where 'vw_T1_T2_sf' is the subform

     Me.Requery

Exit_cmdFilterRecords_Click:
    Exit Sub

Err_cmdFilterRecords_Click:
    MsgBox Err.Description
    Resume Exit_cmdFilterRecords_Click

End Sub



Private Function BuildFilter() As Variant
    Dim varWhere As Variant

    varWhere = Null  ' Main filter
    
    If Me.txt_FilterBy &gt; "" Then
        varWhere = varWhere &amp; " T1_Project_Header.Project_DescriptiveName LIKE" &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "

        varWhere = varWhere &amp; " T1_Project_Header.Key_Words LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "

        varWhere = varWhere &amp; " T1_Project_Header.Person_Requesting_Project LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
    
        varWhere = varWhere &amp; " T1_Project_Header.Project_Number LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
    
        varWhere = varWhere &amp; " T1_Project_Header.Key_People LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " AND "  'The "AND" gets removed in the following steps
        
    End If
    
    
    
    'txtApplicationNumber
    ' Check if there is a filter to return...
    If IsNull(varWhere) Then
        varWhere = "SELECT T1_Project_Header.* FROM T1_Project_Header"
    Else
        varWhere = "SELECT T1_Project_Header.* FROM T1_Project_Header WHERE" &amp; varWhere
        
        ' strip off last "AND" in the filter
        If Right(varWhere, 5) = " AND " Then
            varWhere = Left(varWhere, Len(varWhere) - 5)
        End If
    End If
    
    BuildFilter = varWhere
    
End Function


============IF you want to deal with a zero record count returned then use DCount:

Private Function BuildFilter() As Variant
    
    On Error GoTo ErrorHandler
    
    '=========================
    Dim varWhere As Variant

    varWhere = Null  ' Main filter

    If Me.txt_FilterBy &gt; "" Then
        varWhere = varWhere &amp; "[dbo_T01_TruckerPacket.01_Trucking_Company_Name] LIKE" &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
        
        varWhere = varWhere &amp; " [dbo_T01_TruckerPacket.01_Trucking_Number] LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T01_TruckerPacket.01_Trucking_Company_Address_1] LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
         varWhere = varWhere &amp; " [dbo_T01_TruckerPacket.01_Trucking_Company_Address_2] LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T01_TruckerPacket.01_Trucking_Company_Address_3] LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' "
        
    End If

     Dim iCount
     iCount = DCount("[dbo_T01_TruckerPacket.01_Trucking_Company_Name]", "q_TruckerPacket_00", varWhere)   &lt;&lt;&lt;&lt;&lt;&lt;&lt;=========== DCount!!!!

    If IsNull(varWhere) Or iCount = 0 Then
        varWhere = "SELECT dbo_T01_TruckerPacket.* FROM dbo_T01_TruckerPacket"
        
        If iCount = 0 Then
            MsgBox "No records were found that met your criteria"
        End If
    Else
        varWhere = "SELECT dbo_T01_TruckerPacket.* FROM dbo_T01_TruckerPacket WHERE" &amp; varWhere

    End If

    BuildFilter = varWhere
        '=========================
    Exit Function
            
ErrorHandler:
        Select Case Err.Number

            Case 0  '
                        
                           
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Filter_Combo_Box_Based_on_Another_ComboBox</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Filter_Combo_Box_Based_on_Another_ComboBox</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>How to Filter Combo Box Values Based on Another Combo Box
https://www.youtube.com/watch?v=8pMSkNGlF54

My example: DataGovernance
-----------------

1] {Main Form:} F_001_PickSchemaTable_EditFieldDefinition

3 drop-downs
-------------
a) cmbDatabases
=================
	{RowSource}
	SELECT [q_Databases].[DatabaseName] 
	FROM q_Databases ORDER BY [DatabaseName]; 
	
	{After Update Event}
	Private Sub cmbDatabases_AfterUpdate()
	    Me.cmbPickSchemaGivenDatabase.Requery
	End Sub	

b) cmbPickSchemaGivenDatabase
===============================
	{RowSource}
	SELECT 
			q_Database_Schema_ALL.schema_id
			, "[" &amp; [q_Database_Schema_All].[DatabaseName] &amp; "].[" &amp; [q_Database_Schema_All].[schemaName] &amp; "]" AS Database_SchemaName 
	FROM q_Database_Schema_ALL 
	WHERE 
		(
			(
				(q_Database_Schema_ALL.DatabaseName)=forms!F_001_PickSchemaTable_EditFieldDefinition!cmbDatabases    
			)
		); 

	
	{After Update Event}
	Private Sub cmbPickSchemaGivenDatabase_AfterUpdate()
	    Me.cmb_PickTable.Requery
	End Sub	
		
c) cmb_PickTable
==================
	{RowSource}
	SELECT 
			q_SchemaID_Table.schema_id
			, q_SchemaID_Table.tableName
			, q_SchemaID_Table.TABLE_object_id 
	FROM q_SchemaID_Table
	WHERE 
		(
			(
				(q_SchemaID_Table.schema_id)=forms!F_001_PickSchemaTable_EditFieldDefinition!cmbPickSchemaGivenDatabase
			) 
			And 
			(
				(q_SchemaID_Table.DatabaseName)=forms!F_001_PickSchemaTable_EditFieldDefinition!cmbDatabases
			)
		) 
	ORDER BY q_SchemaID_Table.tableName; 
	
	{After Update Event}
	Private Sub cmb_PickTable_AfterUpdate()
	    Me.sf_001_TableColumnDefinition.Requery
	End Sub

1 SubForm
-----------------
	
d) sf_001_TableColumnDefinition
=================================	
	{Record Source}
	SELECT * 
	FROM Reporting_T222_Columns_for_Tables_in_Databases 
	WHERE TABLE_object_id = forms!F_001_PickSchemaTable_EditFieldDefinition!cmb_PickTable; 


3 Queries
-------------------

e) q_Databases
=================================
SELECT DISTINCT 
	q_Database_Schema_ALL.DatabaseName
FROM q_Database_Schema_ALL;


f) q_Database_Schema_ALL
=================================
SELECT DISTINCT 
	Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.DatabaseName
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.schemaName
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.schema_id
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.isTable_Current
FROM Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database
WHERE (
		(
			(Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.isTable_Current)=True
		)
	  );


g) q_SchemaID_Table
=================================
SELECT DISTINCT 
	Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.schema_id
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.tableName
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.TABLE_object_id
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.isTable_Current
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.DatabaseName
FROM Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database
WHERE (
		(
			(Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.isTable_Current)=True
		)
	  )
ORDER BY Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.tableName;
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>openArgs_MultipleParms</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>openArgs_MultipleParms</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


http://www.access-programmers.co.uk/forums/showthread.php?t=210530
'calling code
'concatenates the values of the cbo's delimited by the "|"
DoCmd.OpenReport "rptResults", acViewPreview, , , acDialog, Me.cbo1ID &amp; "|" &amp; Me.cbo2ID &amp; "|" &amp; Me.cbo3ID

'form open
Private Sub Report_Open(Cancel As Integer)
  varSplitString = Split(Me.OpenArgs, "|")
  Me.[EngagementID].Value = varSplitString(0)
  Me.[LocationID].Value = varSplitString(1)
  Me.[ProviderID].Value = varSplitString(2)
End Sub


=================================================================================


&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Child form catches and uses the OpenArgs:  Set focus, then puts the parm into the .Text of the Textbox

Private Sub Form_Open(Cancel As Integer)
    On Error GoTo ErrorHandler
    
    '=========================
    If Me.OpenArgs &lt;&gt; vbNull Then
        
        varSplitString = Split(Me.OpenArgs, "|")
        Debug.Print "Form_Open - sf_SubContract - varSplitString(0): " &amp; Trim(varSplitString(0))	'&lt;===========================
        Me.txt_Vendor_ID.SetFocus
        Me.txt_Vendor_ID.Text = varSplitString(0)
        Debug.Print "Form_Open - sf_SubContract - varSplitString(1): " &amp; Trim(varSplitString(1))	'&lt;===========================
         Me.Vendor.SetFocus
        Me.Vendor.Value = varSplitString(1)
        Debug.Print "Form_Open - sf_SubContract - varSplitString(2): " &amp; Trim(varSplitString(2))	'&lt;===========================
        Me.txt_Job_Number.SetFocus
        Me.txt_Job_Number.Value = varSplitString(2)
    
    End If
    
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number

'            Case 3075  '
'                MsgBox "There was a problem. You may have had an illegal character in your search string (e.g. an apostrophe). Remove the part with any non-alphatical characters and try again"
'                BuildFilter = "SELECT dbo_T101_Vendor.* FROM dbo_T101_Vendor"
'
'                Exit Sub
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Sub



&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Parent form: uses openArgs on new record

Public Sub cmd_Add_or_Edit_SubContract_Window_Click()   'NOTE: Changed Name of SUB!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    On Error GoTo ErrorHandler
    
    '=========================
    '===================================
    DoCmd.RunCommand acCmdSaveRecord
    '===================================
    ' note that this subroutine has been designated a PUBLIC subroutine
    ' so that the popup form can call this sub.
    If Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Open SubContract Form" Then
    

        Dim sX As String
        Dim sX2 As String
        Dim sX3 As String
        sX = Me.Vendor_ID
        sX2 = [Vendor_Name].Value
        sX3 = [Vendor].Value
        Debug.Print "sX : " &amp; sX
        Debug.Print "sX2 : " &amp; sX2
        Debug.Print "sX3 : " &amp; sX3
        
        Dim sWHERE As String
        sWHERE = "[Vendor_ID]= " &amp; Vendor_ID.Value
        Debug.Print "sWhere: " &amp; sWHERE
        
        Dim JobNumber As String
        
        JobNumber = InputBox("Enter Job Number that you want to create or find (e.g. 01234-000):", "Job Number")
                         
            Select Case fn_TheSubContractNumberIs_0_ok_1_NotRightLength_2_Missing(JobNumber)
                Case 0 'Job Number is OK
        
                     'Check for number of Records with the job name supplied by the user (via msgbox), if none then open as add only, if there are some, ask if they want to add one, or edit existing ones.
                    '-----------------------------
                    
                    Dim varWhereVendorJob As Variant
                    varWhereVendorJob = Null
'                                        varWhereVendorJob = varWhereVendorJob &amp; "(([q_T101_innerJoin_T104.Vendor_ID]=58) AND ([q_T101_innerJoin_T104.Job_Number] Like '*03883-000*'))"
                    varWhereVendorJob = varWhereVendorJob &amp; "(([q_T101_innerJoin_T104.Vendor_ID]=" &amp; Trim(sX) &amp; ") AND ([q_T101_innerJoin_T104.Job_Number] Like '*" &amp; Trim(JobNumber) &amp; "*'))"
                    
                     Debug.Print "varWhereVendorJob: " &amp; varWhereVendorJob
                    
                    Dim iCount_VendorJob
                    iCount_VendorJob = DCount("[q_T101_innerJoin_T104.Vendor_ID]", "q_T101_innerJoin_T104", varWhereVendorJob)
                    '-----------------------------
                    If iCount_VendorJob &gt; 0 Then
                    
                        DoCmd.OpenForm "sf_SubContract", acNormal, , sWHERE
                        Form_sf_SubContract.Caption = "(" &amp; Trim(sX3) &amp; ") " &amp; sX2
                        Form_sf_SubContract.Vendor_ID_parent = Me.Vendor_ID
                        Form_sf_SubContract.Vendor.Value = sX3
                        Form_sf_SubContract.AllowAdditions = False
                        Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Close SubContract Form"
                    Else
                        DoCmd.OpenForm "sf_SubContract", , , , acAdd, , Me.Vendor_ID &amp; "|" &amp; [Vendor].Value &amp; "|" &amp; Trim(JobNumber)   '&lt;===============  OpenArgs
                        Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Close SubContract Form"
                    End If
                    
                    '-----------------------------
        
        
                Case 1
                    MsgBox ("It looks like Job Number is the wrong length (e.g. 01234-000). You need to fix this before you can proceed")
        
                Case 2
        
                     MsgBox ("Job_Number is REQUIRED. If you want try again")

        
                Case Else
                    MsgBox ("Woops, there was a problem. The wrong value came back from fn_TheSubContractNumberIs_0_ok_1_NotRightLength_2_Missing")
    
            End Select

    Else
        DoCmd.Close acForm, "sf_SubContract"
        Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Open SubContract Form"
    End If
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number
                
            Case Else
                MsgBox "Error (f_Vendor): " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>OptionFrame_with_RadioButtons_to_Show_SubForms</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>OptionFrame_with_RadioButtons_to_Show_SubForms</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Goal let user select whether to show the main form, or one of the subforms
'    where the subforms correspond to related tables of the main table on the main form
'
'1] with control Wizard on, put option Frame onto form
'    then in the wizard created three values:
'        1 = Demograhics Only
'        2 = Show Episodes
'        3 = Show Services


Private Sub optionFrame_Forms_AfterUpdate()
   Select Case optionFrame_Forms.Value
      Case 1
        Me.Form.Visible = True
        Me.F002_Episode.Visible = False
        Me.F003_Service.Visible = False
      Case 2
        Me.Form.Visible = True
        Me.F002_Episode.Visible = True
        Me.F003_Service.Visible = False
      Case 3
        Me.Form.Visible = True
        Me.F002_Episode.Visible = False
        Me.F003_Service.Visible = True
   End Select
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_StoredProc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>001_SP_Parm_In_Out_and_ReturnValue</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_StoredProc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>001_SP_Parm_In_Out_and_ReturnValue</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>001_SP_Parm_In_Out_and_ReturnValue


-- gg009_DMC_Pension_UpdateClaim_WithDate.sql


-- This SP will:

--		
--		1] Update the [DMC_Claim_t]:
--			Update the PensionDate back to Null, so that another user can begin work on the record
--			Add in the user and time that it was updated to the ClaimNote
--		2] Update the [DMC_Claim_MileStone_t]
--			Set CMS_1a = 4 {Completed}
--		

/*
	************************************************************************************
	NOTE: 
	Uses: 
	************************************************************************************
*/

SET NOCOUNT ON
Use Firstparty
go

	-- This setting may help performance and error reporting back to VBA.

alter PROCEDURE gg009_DMC_Pension_UpdateClaim_WithDate(
	@sClaim_PK as NVARCHAR(25),
	@sPensionDate as VARCHAR(10) ,							
	@ClaimNote AS NVARCHAR(1000), 
	@MessageFromSQL AS NVARCHAR(1000) OUTPUT
	)
	AS
	
	-- START DEBUGGING SECTION -------------------	
	
			PRINT 'gg009-Input  @sClaim_PK: ' +  @sClaim_PK
			PRINT 'gg009-Input  @sPensionDate: ' +  @sPensionDate
			PRINT 'gg009-Input  @ClaimNote: ' + 	 @ClaimNote	
			PRINT 'gg009-Input  @MessageFromSQL: ' + 	 @MessageFromSQL	

-- END DEBUGGING SECTION -------------------	
	

-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
   DECLARE @CONTINUE BIT	
   DECLARE @Claim_MileStone_PK INT
   DECLARE @Claim_PK INT
   DECLARE @dPensionDate DATE
  
	SELECT @CONTINUE = 1	
	SELECT @Claim_MileStone_PK = 0
	SELECT @MessageFromSQL = @MessageFromSQL + '[MessageFromSQL start in gg009]: '	
	SELECT @Claim_PK =CAST(@sClaim_PK as INT)
	SELECT @dPensionDate = CAST(@sPensionDate as DATE)   -- CONVERT(CHAR(10), @sPensionDate, 112) 
	PRINT 'Input @dPensionDate: ' +  CAST(@dPensionDate AS NVARCHAR(25))
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 1] Update the [DMC_Claim_t], Update the ClaimNote w/ the HEC Confirm Number, and Contact Info that was given to HEC
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	BEGIN TRANSACTION DMC_UpdateClaimAndMilestone_tr

-- START TEST 
  		PRINT 'gg009- TEST-1' +  @MessageFromSQL 
-- END TEST

	UPDATE DMC_Claim_t
	SET ClaimNote = @ClaimNote, Pension_Date = @dPensionDate, Hold_Started_DateTime = null	
	WHERE Claim_PK = @Claim_PK

-- START TEST 
  		PRINT 'gg009- TEST-2' +  @MessageFromSQL 
-- END TEST

	-- Check for errors
	-- ||||||||||||||||||
	IF @@ERROR &lt;&gt; 0
		BEGIN
		--
		-- Rollback the transaction and return to the caller
		--
		SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: Unable to update the ClaimNote for Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))		
		ROLLBACK TRANSACTION DMC_UpdateClaimAndMilestone_tr
		RETURN 1	-- Error in First Step
		END


-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 2] Update the [DMC_Claim_MileStone_t], Set CMS_1a = 4 {Complete}
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	UPDATE DMC_Claim_MileStone_t
	SET CMS_1a = 4
	WHERE Claim_FK = @Claim_PK

-- START TEST 
  		PRINT 'gg009- TEST-3' +  @MessageFromSQL 
-- END TEST


	-- Check for errors
	-- ||||||||||||||||||
	IF @@ERROR &lt;&gt; 0
		BEGIN
		--
		-- Rollback the transaction and return to the caller
		--
		SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: Unable to update the ClaimNote_MileStone for Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))		
		ROLLBACK TRANSACTION DMC_UpdateClaimAndMilestone_tr
		RETURN 2	-- Error in Second Step
		END


		SELECT @MessageFromSQL = @MessageFromSQL + '-- The MileStone (CMS_1a = 4) has been updated for Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))	


	COMMIT TRANSACTION DMC_UpdateClaimAndMilestone_tr

-- START TEST 
  		PRINT 'gg009- TEST-4' +  @MessageFromSQL 
-- END TEST
	


	--**************************************************************************
		PRINT '-----------------------------------------------------------------'
  		PRINT 'At the end of gg009' +  @MessageFromSQL 
	--**************************************************************************	

	RETURN 0
	
	go








</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_StoredProc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>002_SP_Parm_In_and_RecordSet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_StoredProc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>002_SP_Parm_In_and_RecordSet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>002_SP_Parm_In_and_RecordSet



-- gg010_DMC_GetClaims_Given_SSN.sql


-- Returns a List of Claims from DMC_Claim_t Where:
--		a) Full SSN = input parm
-- 

/*
	************************************************************************************
	NOTE:

	************************************************************************************
	Use: 
*/

SET NOCOUNT ON
Use Firstparty
go

	-- This setting may help performance and error reporting back to VBA.

Create PROCEDURE gg010_DMC_GetClaims_Given_SSN(
	@SSN_Full AS NVARCHAR(9)
	)
	AS
	
	-- START DEBUGGING SECTION -------------------	
	
			PRINT 'Input @SSN_Full: ' + 	 @SSN_Full
	
-- END DEBUGGING SECTION -------------------	
	
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
   DECLARE @COUNT INT
   
   
   SELECT @COUNT=0
	
--  **************************************************************************
--  1] Get the Count of records with this same SSN, and the records themselves.
--  **************************************************************************					
	SELECT @COUNT = (
					Select COUNT(*)
					FROM DMC_Claim_t
					WHERE [SSN_Full]=@SSN_Full
					)


	Select 
	[Veteran_Name],
	--[SSN_Original],
	--[Claim_No],
	--[Claim_Loc],
	[Eligibility],
	[SC_Eff_Date],
	[FacilityName],
	--[FacilityNumber],
	--[DateReportWasRun],
	--[SSMA_TimeStamp],
	[DateTimeUploaded],
	--[Pension_01],
	--[SC_01],
	[SSN_Full],
	--[Hold_UserName],
	--[Hold_Started_DateTime],
	[Claim_DONE_01],
	[Pension_Date],
	[ClaimNumberForThisSSN],
	[DateTimeUploaded],
	[ClaimNote]
      
	FROM DMC_Claim_t
	WHERE [SSN_Full]=@SSN_Full
		
	RETURN @COUNT  

		
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_StoredProc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LongListOfExamples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_StoredProc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LongListOfExamples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Compare Database





Public Function fn_RunSP_UpdatePensionDate(iClaim_PK As Integer, _
                                            sPensionDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg009_DMC_Pension_UpdateClaim_WithDate"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sPensionDate", adVarChar, adParamInput, 10, sPensionDate)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_UpdatePensionDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function






Public Function fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet(sTransactionNumber As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sTransactionNumber: " &amp; sTransactionNumber
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg008_DMC_Pension_GetClaim_GivenHECTransactionNumber"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sTransactionNumber", adVarChar, adParamInput, 18, sTransactionNumber)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'
    
    Set fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    If iReturnValue &gt; 1 Then
            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg008_DMC_Pension_GetClaim_GivenHECTransactionNumber =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
    End If
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            MsgBox ("More than one Claim was returned that matched that Confirmation Number" &amp; vbCrLf &amp; "You need to use the COMPLETE and EXACT confirmation number")
'            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
            Debug.Print "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)

        Case Else
            Debug.Print "fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function


Public Function fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg006_DMC_Pension_GetClaimForHECDate_PlaceHold"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'    If iReturnValue = 50 Then
'        Err.Raise vbObjectError + 111
'    End If
'
    
    Set fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=50, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; No records left for that facility"
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function


'
Public Function fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    

    
'ALTER PROCEDURE gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN(
'    @SSN_Full AS NVARCHAR(9),
'    @sClaim_TEMP_PK as NVARCHAR(25),
'    @Hold_UserName AS nvarchar(255),
'    @MessageFromSQL AS NVARCHAR(1000) OUTPUT
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Private Sub ClearCommandParameters(ByRef oCMD As ADODB.Command)
    Dim lngX As Long
    For lngX = (oCMD.Parameters.Count - 1) To 0 Step -1
        oCMD.Parameters.Delete lngX
    Next

End Sub
'
'
'Public Function fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet(sFullSSN As String) As recordset




Public Function fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet(sFullSSN As String) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sFullSSN: " &amp; sFullSSN
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'=============================================================================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg010_DMC_GetClaims_Given_SSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)

    End With
'=============================================================================
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
    
'    If iReturnValue = 0 Then
'        Err.Raise vbObjectError + 111
'    End If
        
    
    Set fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
'        Case vbObjectError + 111
''            Err.Raise vbObjectError + 111
'            MsgBox ("There were No Records in the database already with that SSN!")
        Case Else
            Debug.Print "fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function




Public Function fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable(sSSN As String) As Integer
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sSSN: " &amp; sSSN
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

'    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg005_DMC_CountOccuranceOfSSN_In_DMC_Claim_t"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN)
'===================================================================================
        .Execute

'===================================================================================

    End With
    
    
    iReturnValue = objCmd.Parameters("RETURN_VALUE")
    
    fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable = iReturnValue
        
    
    
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objConn = Nothing
    Set objCmd = Nothing
'    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function

'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet
'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet



Public Function fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg001_DMC_Pension_GetClaimForSSN_PlaceHOLDonTEMPclaim" 'gg001_DMC_Pension_GetClaimForSSN_PlaceHOLDonTEMPclaim
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================


'===================================================================================


'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
    

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 50 Then
        Err.Raise vbObjectError + 111
    End If
        
    
    Set fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function


Public Sub RunSP_PP_ReportProblems(iPP_WorkList_PK As Integer, _
                                            sFullSSN As String, _
                                            sWorkList_Note As String, _
                                            sArchived_UserName As String, _
                                            sArchived_DateTime As String _
                                            )
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gig_PP_ReportProblem"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        'Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("@PP_WorkList_PK", adInteger, adParamInput, 0, iPP_WorkList_PK)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)
        .Parameters.Append .CreateParameter("@WorkList_Note", adVarChar, adParamInput, 1000, sWorkList_Note)
        .Parameters.Append .CreateParameter("@Archived_UserName", adVarChar, adParamInput, 255, sArchived_UserName)
        .Parameters.Append .CreateParameter("@Archived_DateTime", adVarChar, adParamInput, 255, sArchived_DateTime)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working

         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
    
    End With
    
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Sub
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "RunSP_PP_ReportProblems ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "RunSP_PP_ReportProblems ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Sub


Public Sub RunSP_MarkPrePayDone_ArchiveIt(iPP_WorkList_PK As Integer, _
                                            sFullSSN As String, _
                                            sWorkList_HoldReason As String, _
                                            sWorkList_Note As String, _
                                            sArchived_UserName As String, _
                                            sArchived_DateTime As String, _
                                            sHold_ProblemReported_Notes As String, _
                                            sHoldProblemResolved_DateTime As String, _
                                            sHoldProblemResolved_Notes As String, _
                                            sAction_Taken As String _
                                            ) 'As ADODB.recordset

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

'    Dim objRs As New ADODB.recordset
    Dim sConnect As String
'    Dim iIN As Integer
'    Dim iOUT As Integer
'    Dim sX As String
'    Dim iX As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gig_MarkPrePayDone_ArchiveIt"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        'Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("@PP_WorkList_PK", adInteger, adParamInput, 0, iPP_WorkList_PK)
'        .Parameters.Append .CreateParameter("@Date_Last_Updated", adVarChar, adParamInput, 255, sDate_Last_Updated)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)
        .Parameters.Append .CreateParameter("@WorkList_HoldReason", adVarChar, adParamInput, 255, sWorkList_HoldReason)
        .Parameters.Append .CreateParameter("@WorkList_Note", adVarChar, adParamInput, 1000, sWorkList_Note)
        .Parameters.Append .CreateParameter("@Archived_UserName", adVarChar, adParamInput, 255, sArchived_UserName)
        .Parameters.Append .CreateParameter("@Archived_DateTime", adVarChar, adParamInput, 255, sArchived_DateTime)
        .Parameters.Append .CreateParameter("@Hold_ProblemReported_Notes", adVarChar, adParamInput, 1000, sHold_ProblemReported_Notes)
        .Parameters.Append .CreateParameter("@HoldProblemResolved_DateTime", adVarChar, adParamInput, 255, sHoldProblemResolved_DateTime)
        .Parameters.Append .CreateParameter("@HoldProblemResolved_Notes", adVarChar, adParamInput, 1000, sHoldProblemResolved_Notes)
        .Parameters.Append .CreateParameter("@Action_Taken", adVarChar, adParamInput, 255, sAction_Taken)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
   

    End With
    
    
'        objRs.CursorLocation = adUseClient
'        objRs.CursorType = adOpenDynamic
'        objRs.LockType = adLockOptimistic
'        objRs.Open objCmd
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
    

'    Set RunSP_gig_GetPrePayInfo_PlaceTempHoldOnPrePay_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Sub
    
ErrHandler:
    'clean up
'    If objRs.State = adStateOpen Then
'        objRs.Close
'    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
'    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Sub



Public Function RunSP_gig_GetPrePayInfo_PlaceTempHoldOnPrePay_ReturnRecordSet(iFacility_FK As Long, sHold_UserName As String, iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "iFacility_FK: " &amp; iFacility_FK
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
'    Dim iIN As Integer
'    Dim iOUT As Integer
'    Dim sX As String
'    Dim iX As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gig_GetPrePayInfo_PlaceTempHoldOnPrePay"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_FK", adInteger, adParamInput, 0, iFacility_FK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================


'===================================================================================


'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
    

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 50 Then
        Err.Raise vbObjectError + 111
    End If
        
    
    Set RunSP_gig_GetPrePayInfo_PlaceTempHoldOnPrePay_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function



Public Function fRun_SQLString_NoParms_ReturnDisconnectedRecordSet(sSQL As String) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
'    Dim objCmd As New ADODB.Command
    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    Dim iX As Integer
    

            
    ' Connect to the data source.
'=========================
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    objCmd.ActiveConnection = objConn
        
'=======================================

' Setting the cursor location to client side is important
' to get a disconnected recordset.
objRs.CursorLocation = adUseClient
objRs.Open sSQL, objConn, ADODB.adOpenForwardOnly, ADODB.adLockBatchOptimistic

' Disconnect the recordset.
Set objRs.ActiveConnection = Nothing



'======================================
    ' Execute once and display...
'    Set objRs = objCmd.Execute
        

    For iX = 0 To objRs.Fields.Count - 1
        Debug.Print "Field " &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
    Next iX
        
    Set fRun_SQLString_NoParms_ReturnDisconnectedRecordSet = objRs
    
    'clean up
'    objRs.Close
'    objConn.Close
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
'    MsgBox "Done!"
    
    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing


    
    If Err &lt;&gt; 0 Then
        MsgBox "ERROR: fRun_SQLString_NoParms_ReturnDisconnectedRecordSet: " &amp; Err.Number &amp; ", " &amp; Err.Description
    End If

End Function

Public Sub RunStoredProcedure_NoParms_NoReturnInfo(sNameOfStoredProc As String)

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim objParm1 As New ADODB.Parameter
    Dim objRs As New ADODB.recordset
    Dim stConnect As String
    
    ' Set CommandText equal to the stored procedure name.
    objCmd.CommandText = sNameOfStoredProc
    objCmd.CommandType = adCmdStoredProc
            
    ' Connect to the data source.
'    Set objConn = GetNewConnection

'========================= OPTION to use a connection string
    stConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open stConnect
'==========================
    objCmd.ActiveConnection = objConn
    
    ' Execute once
    objCmd.Execute
                
    'clean up

    objConn.Close

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
'    MsgBox "Done!"
    Exit Sub

ErrHandler:
    'clean up

    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        MsgBox Err.Source &amp; "--&gt;" &amp; Err.Description, , "Error"
    Else
        MsgBox "Done!, but it went to the ErrHandler!"
    End If


End Sub





Public Function fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    
    
'ALTER PROCEDURE gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord(
'    @SSN_Full AS NVARCHAR(9),
'    @sClaim_TEMP_PK as NVARCHAR(25),
'    @Hold_UserName AS nvarchar(255),
'    @MessageFromSQL AS NVARCHAR(1000) OUTPUT
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function










Public Function fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t(sClaim_TEMP_PK As String) As Integer
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg004_DMC_Delete_Claim_From_Claim_TEMP_t"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        
         .Execute
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Public Function fn_RunStoredProcedure_NoParms_ReturnRecordSet(sNameOfStoredProc As String) As recordset
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    ' Set CommandText equal to the stored procedure name.
    objCmd.CommandText = "CustOrdersOrders"
    objCmd.CommandType = adCmdStoredProc
            
    ' Connect to the data source.
'=========================
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    objCmd.ActiveConnection = objConn
        
    ' Automatically fill in parameter info from stored procedure.
    objCmd.Parameters.Refresh
    
    ' Set the param value.

    
    ' Execute once and display...
    Set objRs = objCmd.Execute
        

    Do While Not objRs.EOF
        Debug.Print vbTab &amp; objRs(0) &amp; vbTab &amp; objRs(1) &amp; vbTab &amp; _
                    objRs(2) &amp; vbTab &amp; objRs(3)
        objRs.MoveNext
    Loop
        
    RunStoredProcedure_NoParms_ReturnRecordSet = objRs
    
    'clean up
    objRs.Close
    objConn.Close
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    MsgBox "Done!"
    
    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        MsgBox Err.Source &amp; "--&gt;" &amp; Err.Description, , "Error"
    End If

End Function
'
'
'
'
'
'Public Sub BAD_RunSP_MarkClaim_SentRequestToHEC(iClaim_PK As Integer, _
'                                            sClaimNote As String _
'                                            )
'
'    On Error GoTo ErrHandler:
'
'    Dim objConn As New ADODB.Connection
'    Dim objCmd As New ADODB.Command
'
'    Dim sConnect As String
'
'    ' Connect to the data source.
''========================= OPTION to use a connection string
'    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
'    objConn.Open sConnect
'
'    With objCmd
'        ' Set CommandText equal to the stored procedure name.
'        .CommandText = "gg007_DMC_Pension_Date_UpdateClaim_RequestSentToHEC"
'        .CommandType = adCmdStoredProc
'
'        .ActiveConnection = objConn
''=============================================================================
'
'        .Parameters.Append .CreateParameter("@Claim_PK", adInteger, adParamInput, 0, iClaim_PK)
'        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
'        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'        '--------
'         .Execute
'         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
'
'
'    End With
'
'
'        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
'
'
'    objConn.Close
'    Set objConn = Nothing
'    Set objCmd = Nothing
'
''    MsgBox "Done!"
'
'    Exit Sub
'
'ErrHandler:
'
'    If objConn.State = adStateOpen Then
'        objConn.Close
'    End If
'
'    Set objConn = Nothing
'    Set objCmd = Nothing
'    Set objParm1 = Nothing
'
'    If Err &lt;&gt; 0 Then
'        Debug.Print "RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
'
'        MsgBox "RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
'    End If
'
'End Sub



Public Function OLD_fn_RunSP_MarkClaim_SentRequestToHEC(iClaim_PK As Integer, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg007_DMC_Pension_Date_UpdateClaim_RequestSentToHEC"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_MarkClaim_SentRequestToHEC = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function





Public Function fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate(iClaim_PK As Integer, _
                                            sPensionDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg007A_DMC_Pension_PensionDate_Either_gg007_OR_gg009"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK_IN", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sPensionDate_IN", adVarChar, adParamInput, 10, sPensionDate)
        .Parameters.Append .CreateParameter("@ClaimNote_IN", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        
    objConn.Close
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function


'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet
'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet



Public Function fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg011_DMC_SC_GetClaimForSSN_PlaceHOLDonTEMPclaim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================


'===================================================================================


'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
    

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 50 Then
        Err.Raise vbObjectError + 111
    End If
        
    
    Set fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function








Public Function fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function




'
Public Function fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function




Public Function fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg016_DMC_SC_GetClaimForHECDate_PlaceHold"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'    If iReturnValue = 50 Then
'        Err.Raise vbObjectError + 111
'    End If
'
    
    Set fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=50, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; No records left for that facility"
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function




Public Function fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate(iClaim_PK As Integer, _
                                            sSCDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg017A_DMC_SC_SCDate_Either_gg017_OR_gg019"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK_IN", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sSCDate_IN", adVarChar, adParamInput, 10, sSCDate)
        .Parameters.Append .CreateParameter("@ClaimNote_IN", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        
    objConn.Close
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function






Public Function fn_RunSP_UpdateSCDate(iClaim_PK As Integer, _
                                            sSCDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg019_DMC_SC_UpdateClaim_WithDate"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sSCDate", adVarChar, adParamInput, 10, sSCDate)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_UpdateSCDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_UpdateSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_UpdateSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function







Public Function fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet(sTransactionNumber As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sTransactionNumber: " &amp; sTransactionNumber
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg018_DMC_SC_GetClaim_GivenHECTransactionNumber"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sTransactionNumber", adVarChar, adParamInput, 18, sTransactionNumber)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'
    
    Set fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    If iReturnValue &gt; 1 Then
            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg008_DMC_Pension_GetClaim_GivenHECTransactionNumber =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
    End If
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            MsgBox ("More than one Claim was returned that matched that Confirmation Number" &amp; vbCrLf &amp; "You need to use the COMPLETE and EXACT confirmation number")
'            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
            Debug.Print "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)

        Case Else
            Debug.Print "fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function





Public Function fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                bSortBy_SC_First As Boolean, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    Dim iSortBy_SC_First As Integer
    
'========================================
' Translate input values

    If bSortBy_SC_First = True Then
        iSortBy_SC_First = 1
    Else
        iSortBy_SC_First = 0
    End If
    
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg020_DMC_GetNewOrIncompleteClaim_ToValidate"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)
        .Parameters.Append .CreateParameter("@SortBy_SC_First", adInteger, adParamInput, 0, iSortBy_SC_First)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")    '( 1 means there were no problems, 0 means there were problems)
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 0 Then
        Err.Raise vbObjectError + 111
    End If
'
    
    Set fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=0 in: fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet, from: gg020_DMC_GetNewOrIncompleteClaim_ToValidate =&gt; There was a problem"
        Case Else
            Debug.Print "fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function



Public Function fn_Tickle_ClaimPK_Hold(sClaim_PK As String, _
                                        sUserName As String, _
                                        sNumberOfDays As String) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg000A_TickleOutHOLD_Claim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sUserName", adVarChar, adParamInput, 255, sUserName)
        .Parameters.Append .CreateParameter("@sNumberOfDays", adVarChar, adParamInput, 2, sNumberOfDays)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_Tickle_ClaimPK_Hold = iReturnValue   '0 if there was a problem, 1 if it was ok

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_Tickle_ClaimPK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_Tickle_ClaimPK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function





Public Function fn_Tickle_Claim_TEMP_PK_Hold(sClaim_TEMP_PK As String, _
                                        sUserName As String, _
                                        sNumberOfDays As String) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg000B_TickleOutHOLD_ClaimTEMP"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@sUserName", adVarChar, adParamInput, 255, sUserName)
        .Parameters.Append .CreateParameter("@sNumberOfDays", adVarChar, adParamInput, 2, sNumberOfDays)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_Tickle_Claim_TEMP_PK_Hold = iReturnValue   '0 if there was a problem, 1 if it was ok

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_Tickle_Claim_TEMP_PK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_Tickle_Claim_TEMP_PK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function








Public Function fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet(sClaim_PK As String, _
                                                                   sClaim_TEMP_PK As String) _
                                                                   As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sClaim_PK: " &amp; sClaim_PK
    Debug.Print "sClaim_TEMP_PK: " &amp; sClaim_TEMP_PK
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer

    

    
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg000C_DMC_CountBillsToValidateForTheClaim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sClaim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")    '( 1 means there were no problems, 0 means there were problems)
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue &gt; 0 Then
    ' @@ERROR should be 0 if everything is ok.
        Err.Raise vbObjectError + 111
    End If
'
    
    Set fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet = objRs
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=0 in: fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet, from: gg020_DMC_GetNewOrIncompleteClaim_ToValidate =&gt; There was a problem"
        Case Else
            Debug.Print "fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function









Public Function fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Long
    
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim lReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        lReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord = lReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Public Function fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Long
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim lReturnValue As Long
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        lReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN = lReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Public Function fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim(sClaim_PK As String, _
                                                                            sHold_UserName As String, _
                                                                            iTimeLimitForHoldInMinutes As Integer) _
                                                                            As ADODB.recordset
    On Error GoTo ErrHandler:
    
     Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "sClaim_PK: " &amp; sClaim_PK
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer

     ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 25, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
        
'===================================================================================

    End With
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")    '( This is the DMC_Bills_PK)
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue (DMC_Bills_PK):" &amp; iReturnValue
    
'    If iReturnValue &gt; 0 Then
'    ' @@ERROR should be 0 if everything is ok.
'        Err.Raise vbObjectError + 111
'    End If
'
    
    Set fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim = objRs
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
'        Case vbObjectError + 111
''            Err.Raise vbObjectError + 111
'            Debug.Print "Return Code=0 in: fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim, from: gg020_DMC_GetNewOrIncompleteClaim_ToValidate =&gt; There was a problem"
        Case Else
            Debug.Print "fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function







Public Function fn_gg022_Bill_and_Milestone_UpdateServiceDates( _
                                            sBill_PK As String, _
                                            sFirstDateServiced As String, _
                                            sLastDateServiced As String, _
                                            sBillNote As String, _
                                            sHold_UserName As String _
                                            ) As Integer
                                            
' create PROCEDURE gg022_Bill_and_Milestone_UpdateServiceDates(
'    @sBills_PK as NVARCHAR(25),
'    @sFirstDateServiced as VARCHAR(10) ,
'    @sLastDateServiced as VARCHAR(10) ,
'    @BillNote AS NVARCHAR(1000),
'    @Hold_UserName AS NVARCHAR(25),
'    @MessageFromSQL AS NVARCHAR(1000) OUTPUT
'    )
                                            
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg022_Bill_and_Milestone_UpdateServiceDates"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sBill_PK", adVarChar, adParamInput, 25, sBill_PK)
        .Parameters.Append .CreateParameter("@sFirstDateServiced", adVarChar, adParamInput, 10, sFirstDateServiced)
        .Parameters.Append .CreateParameter("@sLastDateServiced", adVarChar, adParamInput, 10, sLastDateServiced)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sBillNote)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_gg022_Bill_and_Milestone_UpdateServiceDates = iReturnValue '0=No errors, otherwise the number indicates which step had the error

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_gg022_Bill_and_Milestone_UpdateServiceDates ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_gg022_Bill_and_Milestone_UpdateServiceDates ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function

'\\\\\\\


Public Function fn_gg023_DMC_Claim_Validate_Phase_1_Done(lClaim_PK As Long) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(lClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg023_DMC_Claim_Validate_Phase_1_Done"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
'-----
         .Execute
        
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_gg023_DMC_Claim_Validate_Phase_1_Done = iReturnValue       'RETURN(@@ERROR),  @@ERROR should be 0 if everything is ok.

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ACCESS_SQL_CompareAndContrast</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ACCESS_SQL_CompareAndContrast</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'http://sqlserver2000.databases.aspfaq.com/what-are-the-main-differences-between-access-and-sql-server.html

'TRUE/False ===========================

-- DETERMINING TRUE 
 
-- Access: 
[...] WHERE ynColumn = TRUE 
[...] WHERE ynColumn = -1 
 
-- SQL Server: 
[...] WHERE ynColumn &lt;&gt; 0 
 
'------------------------------ 
 
'-- DETERMINING FALSE 
 
'-- Access: 
[...] WHERE ynColumn = FALSE 
[...] WHERE ynColumn = 0 
 
'-- SQL Server: 
[...] WHERE ynColumn = 0


'Switching from Date/Time to DATETIME  ============

'When passing dates into Access from ASP or an application, you use pound signs (#) for surrounding dates. SQL Server, on the other hand, uses apostrophes ('). So the following query conversion would be required: 

'-- Access: 
[...] WHERE dtColumn &gt;= #2001-11-05# 
 
'-- SQL Server: 
[...] WHERE dtColumn &gt;= '20011105' 

'--------------------------------------------------

'In addition, Access allows you to store date and time independently. SQL Server, including SQL Server 2005 ("Yukon"), 
'does not allow this (see Article #2206 for more info). To see if a date equals 2001-11-05 in SQL Server, you would have to convert the stored value 
'(which includes time) to a date only. Here is how a typical query would have to change: 

'-- Access: 
[...] WHERE dtColumn = #11/05/2001# 
 
'-- SQL Server: 
[...] WHERE CONVERT(CHAR(8), dtColumn, 112) = '20011105' 
 
-- if dtColumn has an index, this will be more efficient: 
[...] WHERE dtColumn &gt;= '20011105' 
    AND dtColumn &lt; '20011106'

'If you want to retrieve the current date and time, the syntax is slightly different: 

'-- Access: 
SELECT Now() 
SELECT Date() &amp; " " &amp; Time() 
 
'-- SQL Server: 
SELECT GETDATE() 
SELECT CURRENT_TIMESTAMP 

'If you want just the time: 

'-- Access: 
SELECT Time() 
 
'-- SQL Server: 
SELECT CONVERT(CHAR(8), GETDATE(), 108) 
SELECT LTRIM(STUFF(RIGHT(CONVERT(CHAR(19), GETDATE(), 0), 7), 6, 0, ' ')) 

'If you want just today's date, there are other options: 

'-- Access: 
SELECT Date() 
 
'-- SQL Server: 
SELECT GETDATE() - {fn CURRENT_TIME} 
SELECT {fn CURDATE()} -- not friendly with certain languages 
SELECT CONVERT(CHAR(8), GETDATE(), 112)

'To get tomorrow's date, here is how your queries would look: 

'-- Access: 
SELECT DateAdd("d",1,date()) 
 
'-- SQL Server: 
SELECT CONVERT(CHAR(8), GETDATE()+1, 112) 
'--or 
SELECT DATEADD(DAY, 1, CONVERT(CHAR(8), GETDATE(), 112)) 

'To get the date and time 24 hours from now: 
 
'-- Access: 
SELECT cstr(DateAdd("d",1,date())) &amp; " " &amp; cstr(time()) 
 
'-- SQL Server: 
SELECT DATEADD(day, 1, GETDATE()) 
 
'To get the first day of the current month: 
 
'-- Access: 
SELECT DateAdd("d",1-day(date()),date()) 
 
'-- SQL Server: 
SELECT CONVERT(CHAR(10),GETDATE()+1-DAY(GETDATE()),101) 
 
'To get the number of days in the current month: 
 
'-- Access: 
SELECT DAY(DATEADD("m", 1, 1-DAY(date()) &amp; date())-1) 
 
'-- SQL Server: 
SELECT DAY(DATEADD(MONTH, 1, 1-DAY(GETDATE())+GETDATE())-1) 
 
'To get the current millisecond: 
 
'-- This is impossible in Access, but just for fun: 
SELECT "Pick a number between 1 and 1000" :-) 
 
'-- SQL Server: 
SELECT DATEPART(millisecond, GETDATE()) 
 
'To get the current weekday: 
 
'-- Access: 
SELECT weekdayname(weekday(date())) 
 
'-- SQL Server: 
SELECT DATENAME(WEEKDAY, GETDATE()) 

'==================


'This function converts NUMERIC data that may be stored in string format to INTEGER format for comparison and computation.
 Remember that SQL Server is much more strongly typed than VBA in Access, so you may find yourself using CAST a lot more than you expected. 
 
'-- Access: 
SELECT CINT(column) 
 
'-- SQL Server: 
SELECT CAST(column AS INT) 
 
'INSTR(data, expression) -&gt; CHARINDEX(expression, data) 
'This function returns an integer representing the character where the search expression is found within the data parameter. Note that the order of these parameters is reversed! 
 
'-- Access: 
SELECT INSTR("franky goes to hollywood","goes") 
 
'-- SQL Server: 
SELECT CHARINDEX('goes','franky goes to hollywood') 
 
'ISDATE(data) 
This function returns 1 if the supplied parameter is a valid date, and 0 if it is not. Aside from delimiters, the syntax is identical. 
 
'-- Access: 
SELECT ISDATE(#12/01/2001#) 
 
'-- SQL Server: 
SELECT ISDATE('12/01/2001') 
 
'ISNULL(data) 
This function works a bit differently in the two products. In Access, it returns 1 if the supplied parameter is NULL, and 0 if it is not. In SQL Server, there are two parameters, and the function works more like a CASE statement. The first parameter is the data you are checking; the second is what you want returned IF the first parameter is NULL (many applications outside the database haven't been designed to deal with NULL values very gracefully). The following example will return a 1 or 0 to Access, depending on whether 'column' is NULL or not; the code in SQL Server will return the column's value if it is not NULL, and will return 1 if it is NULL. The second parameter usually matches the datatype of the column you are checking. 
 
'-- Access: 
SELECT ISNULL(column) FROM tbl 
 
'-- SQL Server: 
SELECT ISNULL(column,1) FROM tbl 
 
'A more intuitive function to use in SQL Server is the ANSI standard COALESCE() function. Not only does it allow you to substitute a value when a NULL is found, it will allow you to step through a series of possible values, and stop at the first non-NULL. 
 
SELECT COALESCE(NULL, DateUpdated, DateAdded, GETDATE()) FROM tbl 
 
ISNUMERIC(data) 
'This function returns 1 if the supplied parameter is numeric, and 0 if it is not. The syntax is identical. 
 
SELECT ISNUMERIC(column) 
 
LEFT(data, n) 
'This function returns the leftmost n characters of data. The syntax is identical. 
 
SELECT LEFT(column,5) 
 
LEN(data) 
'This function returns the number of characters in data. The syntax is identical. 
 
SELECT LEN(column) 
 
LCASE(data) -&gt; LOWER(data) 
'This function converts data to lower case. 
 
'-- Access: 
SELECT LCASE(column) 
 
'-- SQL Server: 
SELECT LOWER(column) 
 
LTRIM(data) 
'This function removes white space from the left of data. The syntax is identical. 
 
SELECT LTRIM(column) 
 
REPLACE(data, expression1, expression2) 
'This function scans through data, replacing all instances of expression1 with expression2. 
 
SELECT REPLACE(column, 'bob', 'frank') 
 
RIGHT(data, n) 
'This function returns the rightmost n characters of data. The syntax is identical. 
 
SELECT RIGHT(column,8) 
 
RTRIM(data) 
'This function removes white space from the right of data. The syntax is identical. 
 
SELECT RTRIM(column) 
 
CSTR(data) -&gt; STR(data) 
'This function converts data to string format. 
 
'-- Access: 
SELECT CSTR(column) 
 
'-- SQL Server: 
'-- if column is NUMERIC: 
SELECT STR(column) 
'-- if column is not NUMERIC: 
SELECT CAST(column AS VARCHAR(n)) 
 
MID(data, start, length) -&gt; SUBSTRING(data, start, length) 
'This function returns 'length' characters, starting at 'start'. 
 
'-- Access: 
SELECT MID("franky goes to hollywood",1,6) 
 
'-- SQL Server: 
SELECT SUBSTRING('franky goes to hollywood',1,6) 
 
UCASE(data) -&gt; UPPER(data) 
'This function converts data to upper case. 
 
'-- Access: 
SELECT UCASE(column) 
 
'-- SQL Server: 
SELECT UPPER(column) 
 
'StrConv 
'This function converts a string into 'proper' case (but does not deal with names like O'Hallaran or vanDerNeuts). There is no direct equivalent for StrConv in SQL Server, but you can do it per word manually: 
 
'-- Access: 
SELECT StrConv("aaron bertrand",3) 
 
'-- SQL Server: 
SELECT LEFT(UPPER('aaron'),1) 
+ LOWER(RIGHT('aaron',LEN('aaron')-1)) 
+ ' ' 
+ LEFT(UPPER('bertrand'),1) 
+ LOWER(RIGHT('bertrand',LEN('bertrand')-1)) 
 
'There is a thread stored at Google dealing with proper casing an entire block of text; you could likely implement something like that in both Access and SQL Server. 
 
TRIM(data) 
'This function combines both LTRIM() and LTRIM(); there is no equivalent in SQL Server. To mimic the functionality, you would combine the two functions: 
 
'-- Access:  
SELECT TRIM(column) 
SELECT LTRIM(RTRIM(column)) 
 
'-- SQL Server: 
SELECT LTRIM(RTRIM(column)) 

































</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Access_SQL_ConversionAndFunctions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Access_SQL_ConversionAndFunctions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Access and  T-SQL differences and conversion



'Converting NULL values
'
'Access:        NZ(Value, ValueToReturnIfNull)
'T-SQL:         COALESCE(Value, ValueToReturnIfNull) -- or --  ISNULL(Value, ValueToReturnIfNull)
'
'Checking for NULLs
'
'Access:      WHERE Value IS NULL   -- or --  WHERE ISNULL(Value)   (note the difference from T-SQL's ISNULL)
'T -SQL:      WHERE Value Is Null
'
'String Segments
'
'Access:       MID(StringVal, StartPos, [length] )   (length is optional)
'T-SQL:        SUBSTRING(StringVal, StartPos, length )    (length is required!)
'
'Finding a String within a String
'
'Access:     SELECT INSTR(start, StringToSearch, StringToFind)
'T-SQL:       SELECT CHARINDEX(start, StringToSearch, StringToFind)
'
'Reverse a String
'
'Access:     SELECT STRREVERSE(StringVal)
'T-SQL:       SELECT REVERSE(StringVal)
'
'Convert a String to Uppercase or Lowercase
'
'Access:      SELECT UCASE(StringVal),  LCASE(StringVal)
'T-SQL:       SELECT UPPER(StringVal), LOWER(StringVal)
'
'Formatting Dates, Booleans, Numerics as Strings
'
'Access:     SELECT Format(Value, FormatSpecification)  (note: this always returns a string value)
'T-SQL:      Do not do this in T-SQL; format data at your front-end application or report
'
'String Literals
'
'Access:      SELECT "This is a string"
'T-SQL:       SELECT 'This is a string'
'
'LIKE pattern matching
'
'matching multiple characters:
'
'Access:      WHERE Column Like "*string*"
'T-SQL:       WHERE Column LIKE '%string%'
'
'matching a single character:
'
'Access:     WHERE Column Like "?string?"
'T-SQL:       WHERE Column LIKE '_string_'
'
'not matching a character or range:
'
'Access:   WHERE Column Like "[!a-z]"
'T-SQL:     WHERE Column LIKE '[^a-z]'
'
'Triming White Space
'
'Access:       Trim (Val)
'T -SQL:       RTrim (LTrim(Val))
'
'Converting DataTypes
'
'Access:       CINT(value),  CDBL(value), CDEC(value),  CSTR(value), CDATE(value), CBOOL(value)
'T-SQL:        CONVERT(DATATYPE, value) -- or -- CAST(value AS datatype)
'
'Conditional Expressions
'
'Access:       IIF(Condition, ReturnIfTrue, ReturnIfValue)
'T-SQL:        CASE WHEN Condition THEN ReturnIfTrue ELSE ReturnIfFalse END
'
'Working with Date Literals
'
'Access:      WHERE SomeDate = #1/1/2005#
'T-SQL:       WHERE SomeDate = '1/1/2005'    (this is an implicit conversion from a string to a date)
'
'Creating New Dates
'
'Access:     DATESERIAL(year,month,date)
'T-SQL:       Use the Date() function  here  -- there is no quick easy way to do this in T-SQL
'
'Creating New Times
'
'Access:     TIMESERIAL(Hour, minute, second)
'T-SQL:       Use the Time() function here  -- there is no quick easy way to do this in T-SQL
'
'Getting Today 's Date and Time
'
'Access:     SELECT now()
'T-SQL:      SELECT getdate()
'
'Getting Today 's Date only (i.e., at midnight)
'
'Access:     SELECT date()
'T-SQL:      Use the DateOnly() function here  :  SELECT dbo.DateOnly(getdate())
'
'Getting Today 's Time Only (at the "base" date, or date with a numeric value of 0)
'
'Access:    SELECT Time()    (this returns the time at 12/30/1899)
'T-SQL:      Use the TimeOnly() function here  :  SELECT dbo.TimeOnly(getdate())  (returns the time at 1/1/1900)
'
'Boolean (True/False) Values
'
'Access:      WHERE Active = True  -- and --  WHERE Active = False
'                    (Active is a Boolean datatype)
'
'T-SQL:       WHERE Active=1   -- and --   WHERE Active=0
'                    (Active is a Bit datatype)
'
'Returning or Setting Boolean Values
'
'Access:    SELECT BooleanExpression
'T-SQL:      CAST(CASE WHEN BooleanExpression THEN 1 ELSE 0 END) AS BIT
'
'FULL OUTER JOINS
'
'(Note: try to avoid these as a general practice)
'
'Access:      SELECT ... FROM tableA LEFT OUTER JOIN tableB ON ...
'                     Union all
'                    SELECT ... FROM tableB LEFT OUTER JOIN tableA ON ... WHERE tableA .PK IS NULL
'
'T-SQL:       SELECT ... FROM tableA FULL OUTER JOIN tableB ON ....
'
'RIGHT OUTER JOINS
'
'Because we all know that using the query designer in Access sometimes results in these, but we should never use them in manually written and maintained SQL:
'
'Access:      SELECT ... FROM tableA RIGHT OUTER JOIN tableB ON ....
'T-SQL:        SELECT ... FROM tableB LEFT OUTER JOIN tableA ON ....
'
'Parameters
'
'Access:      SELECT [Any column name not defined]
'T-SQL:       SELECT @ParamName
'
'Modulo Operator
'
'Access:     SELECT value1 MOD value2
'T-SQL:      SELECT value1 % value2
'
'Dividing Integers to calculate a Percentage or other result with decimal places
'
'Access:    SELECT Int1 / Int2    (this returns a Double value implicitly)
'T-SQL:      SELECT Int1 * 1.0 / Int2   (the multiplication by 1.0 results in a numeric(8,6) being returned)
'
'String Concatenation Operator
'
'Access:      Val1 &amp; Val2  (both will be implicitly converted to strings if they are not already)
'T-SQL:       Val1 + Val2 ( note that explicit conversion to a "string" datatypes is necessary in T-SQL)
'
'Referencing an Expression in a SELECT
'
'Here, we define A+B as a new column X, and we want to reference X in the SELECT:
'
'Access:      SELECT A+B as X, X+C as D FROM ...
'T-SQL:        SELECT X, X+C as D FROM (SELECT A+B as X, C FROM ... ) tmp
'
'Getting a Character from an ASCII code
'
'Access:      SELECT CHR(AsciiCode)
'T-SQL:        SELECT CHAR(AsciiCode)
'
'Getting an ASCII code from a Character
'
'Access:      SELECT ASC(Character)
'T-SQL:        SELECT ASCII(Character)
'
'Date Part Indicators (DateAdd, DateDiff, DatePart)
'
'MS Access and SQL Server both use the same basic date functions (DateAdd, DateDiff, DatePart) but the way you indicate which "date part" you are after differs between the two.
'
'MS Access uses a string expression to indicate the "dart part" in DateAdd, DatePart and DateDiff expressions; SQL Server uses symbols.  Thus, you need to put quotes around the part name in MS Access since it is just a string expression, but you should NOT use quotes in SQL Server -- just enter the value directly.
'
'The Date Part indicators are listed below:
'
'Date Part   SQL Server  MS Access
'Year    year, yy, yyyy  "yyyy"
'Quarter     quarter, qq, q  "q"
'Month   month, mm, m    "m"
'Day of Year     dayofyear, dy, y    "y"
'Day     day, dd, d  "d"
'Week    week, wk, ww    "ww"
'Day of Week     weekday, dw     "w"
'Hour    hour, hh    "h"
'Minute      minute, mi, n   "n"
'Second      second, ss, s   "s"
'Millisecond     millisecond, ms     -
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Min_Max</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Min_Max</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


    Dim countArray(5) As Variant

     countArray(0) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Name]", "q_T201_Trucker", varWhere)
     countArray(1) = DCount("[dbo_T201_Trucker.A1_Trucking_Number]", "q_T201_Trucker", varWhere)
     countArray(2) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_1]", "q_T201_Trucker", varWhere)
     countArray(3) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_2]", "q_T201_Trucker", varWhere)
     countArray(4) = DCount("[dbo_T201_Trucker.A1_Trucking_Contact_Notes]", "q_T201_Trucker", varWhere)
     countArray(5) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_3]", "q_T201_Trucker", varWhere)
     
     Dim iCount_max As Variant
'     iCount_max = MaxInList(countArray)		'&lt;======================================================================This does not work: Type Mismatch
     iCount_max = MaxInList(countArray(0), countArray(1), countArray(2), countArray(3), countArray(4), countArray(5))
     
     

	Function MaxInList(ParamArray ArrayList() As Variant)
	    'Function will return the maximum value from a list of values
	       
	    Dim n As Integer
	    Dim iValue As Variant
	     
	    'Set the variable iValue - initialize to the first item or value in list.
	    iValue = ArrayList(0)
	    
	    'Checks each item or value in the list to find the largest.
	    For n = 0 To UBound(ArrayList)
	    'Determines the largest value.
	    If ArrayList(n) &gt; iValue Then
	        iValue = ArrayList(n)
	    End If
	    
	    Next n
	    
	    MaxInList = iValue
	   
	End Function     
     
     

======================================================================

Option Compare Database
Option Base 0
Option Explicit

Function f_var_Min(ParamArray NumericItems()) As Variant
	If UBound(NumericItems) = -1 Then Exit Function ' No parameters
	Dim vVal As Variant, vNumeric As Variant
	vVal = NumericItems(0)
	For Each vNumeric In NumericItems
	    vVal = IIf(vNumeric &lt; vVal, vNumeric, vVal) ' Keep smaller of 2 values
	Next
	f_var_Min = vVal ' Return final value
End Function

Function f_var_Max(ParamArray NumericItems()) As Variant
	If UBound(NumericItems) = -1 Then Exit Function ' No parameters
	Dim vVal As Variant, vNumeric As Variant
	vVal = NumericItems(0)
	For Each vNumeric In NumericItems
	    vVal = IIf(vNumeric &lt; vVal, vVal, vNumeric) ' Keep larger of 2 values
	Next
	f_var_Max = vVal ' Return final value
End Function

========================================================================================


  Public Function iMax(ParamArray p()) As Variant
  ' Idea from Trevor Best in Usenet MessageID rib5dv45ko62adf2v0d1cot4kiu5t8mbdp@4ax.com
    Dim i As Long
    Dim v As Variant

    v = p(LBound(p))
    For i = LBound(p) + 1 To UBound(p)
      If v &lt; p(i) Then
         v = p(i)
      End If
    Next
    iMax = v
  End Function

  Public Function iMin(ParamArray p()) As Variant
  ' Idea from Trevor Best in Usenet MessageID rib5dv45ko62adf2v0d1cot4kiu5t8mbdp@4ax.com
    Dim i As Long
    Dim v As Variant

    v = p(LBound(p))
    For i = LBound(p) + 1 To UBound(p)
      If v &gt; p(i) Then
         v = p(i)
      End If
    Next
    iMin = v
  End Function
  
  
  'Note "an array of numbers" is critical. iMax(Null,1) returns Null. And iMax(1,2,"foo") returns foo.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Array</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SearchArray_ReportLocationIfFound</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Array</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SearchArray_ReportLocationIfFound</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
////////////////
'NOT Using a loop:
Dim pos, arr, val

arr=Array(1,2,4,5)
val = 4

pos=Application.Match(val, arr, False)

if not iserror(pos) then
   Msgbox val &amp; " is at position " &amp; pos
else
   Msgbox val &amp; " not found!"
end if


////////////////////////////
'Using a loop:

public function GetIndex(byref iaList() as integer, byval iInteger as integer) as integer

dim i as integer

 for i=lbound(ialist) to ubound(ialist)
  if iInteger=ialist(i) then
   GetIndex=i
   exit for
  end if
 next i

end function

///////////// 'Search for Date w/ Match

' Replace with your variable and however you fill the array
Dim DateVariable As Variant, iMatch As Integer
DateVariable = Array("1/1/2008", "1/2/2008", "1/3/2008", "1/4/2008", "1/5/2008", "1/6/2008")
On Error Resume Next
iMatch = WorksheetFunction.Match("1/2/2008", DateVariable, 0)
On Error GoTo 0
If iMatch &gt; 0 Then
    ' Match
    Debug.Print iMatch
Else
    ' No match
End If

'As long as i kept things as text values for the dates ... it worked a treat!

////////////////

Sub test()
    ' Replace with your variable and however you fill the array
    Dim DateVariable As Variant, iMatch As Integer
    DateVariable = Array(#1/1/2008#, #1/2/2008#, #1/3/2008#, #1/4/2008#, #1/5/2008#, #1/6/2008#)
    On Error Resume Next
    iMatch = WorksheetFunction.Match(#1/2/2008#, DateVariable, 0)
    On Error GoTo 0
    If iMatch &gt; 0 Then
        ' Match
        Debug.Print iMatch
    Else
        ' No match
    End If
End Sub




//////'Updated to show using Match (with .Index) to find a value in a dimension of a two-dimensional array:

Dim arr(1 To 10, 1 To 2)
Dim x

For x = 1 To 10
    arr(x, 1) = x
    arr(x, 2) = 11 - x
Next x

Debug.Print Application.Match(3, Application.Index(arr, 0, 1), 0)
Debug.Print Application.Match(3, Application.Index(arr, 0, 2), 0)


////////////////
' Another way using a LOOP

Option Explicit

' Just a little test stub. 
Sub Tester()

    Dim pList(500) As Integer
    Dim i As Integer

    For i = 0 To UBound(pList)

        pList(i) = 500 - i

    Next i

    MsgBox "Value 18 is at array position " &amp; FindInArray(pList, 18) &amp; "."
    MsgBox "Value 217 is at array position " &amp; FindInArray(pList, 217) &amp; "."
    MsgBox "Value 1001 is at array position " &amp; FindInArray(pList, 1001) &amp; "."

End Sub

Function FindInArray(pList() As Integer, value As Integer)

    Dim i As Integer
    Dim FoundValueLocation As Integer

    FoundValueLocation = -1

    For i = 0 To UBound(pList)

        If pList(i) = value Then

            FoundValueLocation = i
            Exit For

        End If

    Next i

    FindInArray = FoundValueLocation

End Function

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Assign_Data_To_Values_and_XValues</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Assign_Data_To_Values_and_XValues</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


//////////////////////////////////////////////////////////////////////

ActiveChart.SeriesCollection(1).Values = "=DataToGraph_Quarterly!$C$2:$C$6"   '&lt;== These are the y-values for each label below
ActiveChart.SeriesCollection(1).XValues = "=DataToGraph_Quarterly!$A$2:$A$6"    '&lt;== These are the axis labels

//////////////////////////////////////////////////////////////////////

    Dim rngYValues As Range
    Set rngYValues = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 3), Worksheets("DataToGraph_Quarterly").Cells(6, 3))

    Dim rngXNames As Range
    Set rngXNames = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 1), Worksheets("DataToGraph_Quarterly").Cells(6, 1))


    ActiveChart.SeriesCollection(1).Values = rngYValues
    ActiveChart.SeriesCollection(1).XValues = rngXNames
//////////////////////////////////////////////////////////////////////







</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>AssignTwoSeries_To_BarGraph_UsingRowColumnNumbers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>AssignTwoSeries_To_BarGraph_UsingRowColumnNumbers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Dim sc As SeriesCollection
Dim i as Long, j as Long

j = 1

For i = 1 To ActiveChart.SeriesCollection.Count
    ActiveChart.SeriesCollection(i).Values = "=Sheet1!R8C" &amp; j &amp; ":R12C" &amp; j
    j = j + 2 '&lt;~~ Adding 2 for Col C
Next</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>BarGraph</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>BarGraph</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>///////////////////////////////////////////////////////////////////////////////////////////
'Invoke the sub:

Private m_sNameOfOutPutWorkSheet_1 As String


	m_sNameOfOutPutWorkSheet_1 = "Dashboard_1"
	
    Dim rngOfChart As Range
    Set rngOfChart = Range(Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(9, 1), Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(17, 12))


    Dim rngYValues As Range
    Set rngYValues = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 3), Worksheets("DataToGraph_Quarterly").Cells(6, 3))

    Dim rngXNames As Range
    Set rngXNames = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 1), Worksheets("DataToGraph_Quarterly").Cells(6, 1))

    CreateABarGraphChart Worksheets(m_sNameOfOutPutWorkSheet_1), rngOfChart, "M2", "Metric # 2", rngYValues, rngXNames
    
///////////////////////////////////////////////////////////////////////////////////////////    


//////////////////////////////////////////

Sub CreateABarGraphChart(wsX As Worksheet, rngOfChart As Range, sChartName As String, sChartTitle As String, rngYValues As Range, rngXNames As Range)
    'rngOfChart is the Range of cells where you want the graph to be located
    
    On Error GoTo ErrorHandler
    
    '=========================
    
    wsX.Shapes.AddChart(xlBar, _
                        Left:=rngOfChart.Left, _
                        Top:=rngOfChart.Top, _
                        Width:=rngOfChart.Width, _
                        Height:=rngOfChart.Height).Select

    ActiveChart.Parent.Name = sChartName
    
    
    ActiveChart.SeriesCollection.NewSeries
    ActiveChart.SeriesCollection(1).Values = rngYValues
    '===============================================================================
    'Apparently it is grabbing some empty cells and turning them into series.
    '   e.g. for: "=DataToGraph_Quarterly!$C$2:$C$5", it creates 4 series, where the first and last are the good ones
    '        so I delete second, then do it again, leaving the original 1st and original 4th series
    Dim iNumberOfSeries As Integer
    iNumberOfSeries = ActiveChart.SeriesCollection.Count
    ActiveChart.SeriesCollection(2).Delete
    ActiveChart.SeriesCollection(2).Delete
    '===============================================================================
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Legend.Delete
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Axes(xlCategory).Select
    ActiveChart.ChartArea.Select
    ActiveChart.SeriesCollection(1).XValues = rngXNames '&lt;== These are the axis labels
    
      With ActiveChart
        .Axes(xlCategory).Select           '&lt;= Bottom Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
    
        
        
    
        .Axes(xlValue).Select           '&lt;= Left Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
    
    End With
    
    With wsX.ChartObjects(sChartName).Chart
        .HasTitle = True
        .ChartTitle.Text = sChartTitle
        .ChartTitle.Font.Size = 7
    End With
    
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number

            Case 0  'raised by subroutine
               
            Case Else
                MsgBox "CreateALineGraphChart - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ChartObjects_use_To_Refer_To_Chart</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ChartObjects_use_To_Refer_To_Chart</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Set ChartObj = ActiveSheet.ChartObjects.Add(Left:=100, Width:=550, Top:=75, Height:=325)
MsgBox ChartObj.Chart.Name
 
 
Set ChartSeries = ChartObj.Chart.SeriesCollection.NewSeries
With ChartSeries
             .Name = "Chart Series 1"
             .Values = Array(1, 2, 3, 4, 5)
             .XValues = Array("alpha", "beta", "gamma", "delta", "epsilon")
End With</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CreateChart_AddNewSeries_Name_values_XValues</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CreateChart_AddNewSeries_Name_values_XValues</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub CreateChart()
Dim ChartObj As ChartObject
Dim ChartSeries as Series
  
Set ChartObj = ActiveSheet.ChartObjects.Add ( Left: = 100, Width: = 550, Top: = 75, Height: = 325)
Set ChartSeries = ChartObj.Chart.SeriesCollection.NewSeries

With ChartSeries
             .Name = "Chart Series 1"
             .Values = Array(1, 2, 3, 4, 5)
             .XValues = Array("alpha", "beta", "gamma", "delta", "epsilon")
End With
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>crude_Create_LineGraph_ProvideData_ScaleSize_ChangeFont_</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>crude_Create_LineGraph_ProvideData_ScaleSize_ChangeFont_</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>    
    
    ActiveSheet.Shapes.AddChart.Select        
    ActiveChart.Charttype = xlLine
    ActiveChart.SeriesCollection.NewSeries

    ActiveChart.SeriesCollection(1).Values = "=DataToGraph_Quarterly!$C$2:$C$5"
'    ActiveChart.ChartTitle.Select
'    Selection.Delete
    ActiveSheet.ChartObjects("Chart 3").Activate

    ActiveChart.Legend.Select
    Selection.Delete
    ActiveSheet.ChartObjects("Chart 3").Activate
    ActiveChart.Axes(xlCategory).Select
    ActiveChart.ChartArea.Select
    ActiveChart.SeriesCollection(1).XValues = "=DataToGraph_Quarterly!$A$2:$A$5"
    ActiveSheet.Shapes("Chart 3").ScaleWidth 0.5658333333, msoFalse, _
        msoScaleFromBottomRight
    ActiveSheet.Shapes("Chart 3").ScaleHeight 0.4861111111, msoFalse, _
        msoScaleFromBottomRight
'    ActiveSheet.Shapes("Chart 3").IncrementLeft -544.8
'    ActiveSheet.Shapes("Chart 3").IncrementTop -165.6
    ActiveSheet.Shapes("Chart 3").ScaleWidth 0.8453608247, msoFalse, _
        msoScaleFromTopLeft
    ActiveSheet.Shapes("Chart 3").ScaleHeight 0.8057142857, msoFalse, _
        msoScaleFromTopLeft
        
    With ActiveChart
        .Axes(xlCategory).Select           '&lt;= Bottom Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With

        
        

        .Axes(xlValue).Select           '&lt;= Left Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With

        With .Parent                                '&lt;== To position the Chart
            .Left = ActiveSheet.Cells(9, 1).Left
            .Top = ActiveSheet.Cells(9, 1).Top
        End With

    End With</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LineGraph_GoodSub</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LineGraph_GoodSub</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
///////////////////////////////////////////////////////////////////////////////////////////
'Invoke the sub:

Private m_sNameOfOutPutWorkSheet_1 As String


	m_sNameOfOutPutWorkSheet_1 = "Dashboard_1"
	
    Dim rngOfChart As Range
    Set rngOfChart = Range(Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(9, 1), Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(17, 12))


    Dim rngYValues As Range
    Set rngYValues = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 3), Worksheets("DataToGraph_Quarterly").Cells(6, 3))

    Dim rngXNames As Range
    Set rngXNames = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 1), Worksheets("DataToGraph_Quarterly").Cells(6, 1))

    CreateALineGraphChart Worksheets(m_sNameOfOutPutWorkSheet_1), rngOfChart, "M2", "Metric # 2", rngYValues, rngXNames
    
///////////////////////////////////////////////////////////////////////////////////////////    

Sub CreateALineGraphChart(wsX As Worksheet, rngOfChart As Range, sChartName As String, sChartTitle As String, rngYValues As Range, rngXNames As Range)    
      'rngOfChart is the Range of cells where you want the graph to be located
    
    On Error GoTo ErrorHandler
    
    '=========================
'    Dim chrtobjX As ChartObject
    
    wsX.Shapes.AddChart(xlLine, _
                        Left:=rngOfChart.Left, _
                        Top:=rngOfChart.Top, _
                        Width:=rngOfChart.Width, _
                        Height:=rngOfChart.Height).Select
                        
    ActiveChart.Parent.Name = sChartName
    
    
    ActiveChart.SeriesCollection.NewSeries
    ActiveChart.SeriesCollection(1).Values = rngYValues
    '===============================================================================
    'Apparently it is grabbing some empty cells and turning them into series.
    '   e.g. for: "=DataToGraph_Quarterly!$C$2:$C$5", it creates 4 series, where the first and last are the good ones
    '        so I delete second, then do it again, leaving the original 1st and original 4th series
    Dim iNumberOfSeries As Integer
    iNumberOfSeries = ActiveChart.SeriesCollection.Count
    ActiveChart.SeriesCollection(2).Delete
    ActiveChart.SeriesCollection(2).Delete
    '===============================================================================

    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Legend.Delete
'    ActiveChart.Legend.Select
'    Selection.Delete
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Axes(xlCategory).Select
    ActiveChart.ChartArea.Select
    ActiveChart.SeriesCollection(1).XValues = rngXNames
        
      With ActiveChart
        .Axes(xlCategory).Select           '&lt;= Bottom Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
   
        .Axes(xlValue).Select           '&lt;= Left Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
    
'        With .Parent                                '&lt;== To position the Chart
'            .Left = ActiveSheet.Cells(9, 1).Left
'            .Top = ActiveSheet.Cells(9, 1).Top
'        End With
    
    End With

    With wsX.ChartObjects(sChartName).Chart
        .HasTitle = True
        .ChartTitle.Text = sChartTitle
        .ChartTitle.Font.Size = 7
    End With
    
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number

            Case 0  'raised by subroutine
               
            Case Else
                MsgBox "CreateALineGraphChart - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub  
    
    
    
    
    
    
    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LineGraph_withGoal</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LineGraph_withGoal</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
////////////////Usage


'===================================================================================================================================
'   R2C3] M6
'    Dim rngOfChart As Range
    Set rngOfChart = Range(Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(20, 25), Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(28, 34))

'    Dim rngYValues As Range
    Set rngYValues = Range(Worksheets("DataToGraph_Quarterly").Cells(m_iRowStartData, 7), Worksheets("DataToGraph_Quarterly").Cells(m_iRowEndData, 7))

    Dim rngYGoal As Range
    Set rngYGoal = Range(Worksheets("DataToGraph_Quarterly").Cells(m_iRowStartData, 16), Worksheets("DataToGraph_Quarterly").Cells(m_iRowEndData, 16))


'    Dim rngXNames As Range
    Set rngXNames = Range(Worksheets("DataToGraph_Quarterly").Cells(m_iRowStartData, 1), Worksheets("DataToGraph_Quarterly").Cells(m_iRowEndData, 1))

'    CreateALineGraphChart Worksheets(m_sNameOfOutPutWorkSheet_1), rngOfChart, "M6", m_sM6_Name, rngYValues, rngXNames
    CreateALineGraphChart_WithGoal Worksheets(m_sNameOfOutPutWorkSheet_1), rngOfChart, "M6", m_sM6_Name, rngYValues, rngXNames, rngYGoal
''===================================================================================================================================



////////////////////////////////////////////////////////////////////

Sub CreateALineGraphChart_WithGoal(wsX As Worksheet, rngOfChart As Range, sChartName As String, sChartTitle As String, rngYValues As Range, rngXNames As Range, rngYGoal As Range)
    'rngOfChart is the Range of cells where you want the graph to be located
    
    On Error GoTo ErrorHandler
    
    '=========================
   
    wsX.Shapes.AddChart(xlLine, _
                        Left:=rngOfChart.Left, _
                        Top:=rngOfChart.Top, _
                        Width:=rngOfChart.Width, _
                        Height:=rngOfChart.Height).Select
                        


     '\\\\\\
    ActiveChart.Parent.Name = sChartName
    
    
    ActiveChart.SeriesCollection.NewSeries
    ActiveChart.SeriesCollection(1).Values = rngYValues
    ActiveChart.SeriesCollection.NewSeries
    ActiveChart.SeriesCollection(2).Values = rngYGoal
    ActiveChart.SeriesCollection(2).Format.Line.ForeColor.RGB = vbRed
    '===============================================================================
    'Apparently it is grabbing some empty cells and turning them into series.
    '   e.g. for a values and Goal series it creates 5 series, where the first and second are the good ones
    '        so I delete the fifth, fourth and third series (this gets rid of empty space on the right side of the chart)
    Dim iNumberOfSeries As Integer
    iNumberOfSeries = ActiveChart.SeriesCollection.Count
    ActiveChart.SeriesCollection(5).Delete
    ActiveChart.SeriesCollection(4).Delete
    ActiveChart.SeriesCollection(3).Delete
    '===============================================================================
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Legend.Delete
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Axes(xlCategory).Select
    ActiveChart.ChartArea.Select
    ActiveChart.SeriesCollection(1).XValues = rngXNames
    
    With ActiveChart
        .Axes(xlCategory).Select           '&lt;= Bottom Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With

        .Axes(xlValue).Select           '&lt;= Left Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
    
        
    
    End With
    
    With wsX.ChartObjects(sChartName).Chart
        .HasTitle = True
        .ChartTitle.Text = sChartTitle
        .ChartTitle.Font.Size = 7
    End With
    
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number

            Case 0  'raised by subroutine
               
            Case Else
                MsgBox "CreateALineGraphChart - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Specify_XValues_as_a_Range</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Specify_XValues_as_a_Range</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub CreateChart()
Dim ChartObj As ChartObject
Dim ChartSeries as Series

Set ChartObj = ActiveSheet.ChartObjects.Add(Left:=100, Width:=550, Top:=75, Height:=325)

Set ChartSeries = ChartObj.Chart.SeriesCollection.NewSeries
With ChartSeries
             .Name = "Chart Series 1"
             .Values = Sheets("Sheet1").Range("A1:A10")
             .XValues = Sheets("Sheet1").Range("B1:B10")
End With
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Specify_XValues_as_Array_or_String</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Specify_XValues_as_Array_or_String</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub try()
Dim label_values() As String
Dim individual_label_value As Variant
Dim counter As Long
Dim ChartObj As ChartObject
Dim ChartSeries As Series
  

'Get the number of lables that you will need to have for the chart Ex. say 7
ReDim label_values(4) As String
 counter = 1

For counter = 0 To 4
     label_values(counter) = "MySeries " &amp; counter + 1
Next counter


Set ChartObj = ActiveSheet.ChartObjects.Add(Left:=100, Width:=550, Top:=75, Height:=325)
Set ChartSeries = ChartObj.Chart.SeriesCollection.NewSeries

With ChartSeries
     .Name = "Chart Series 1"
     .Values = Array(1, 2, 3, 4, 5)
     .XValues = label_values
End With
End Sub


'There is a restriction on the maximum number of characters that can be added as .XValues in above code. 

'If you wanted to specify those values as static values using an Array, you’d end up having to restrict the number of lables you can accomodate in the chart. If you exceed this value, the application will throw the following error:

Run-time error '1004'
Unable to set the XValues Property of the Series Class </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Two_Sets_Of_Points_Two_Lines</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Two_Sets_Of_Points_Two_Lines</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'After creating the chart

ActiveSheet.Shapes.AddChart.Select  
'this adds the chart and selects it in the same statement
ActiveChart.Charttype = xlXYScatter

'you then add the first set of points

ActiveChart.SeriesCollection.NewSeries
ActiveChart.SeriesCollection(1).Name = "=Sheet1!$C$1"
ActiveChart.SeriesCollection(1).XValues = "=Sheet1!$A$3:$A$12"    '&lt;== These are the axis labels
ActiveChart.SeriesCollection(1).Values = "=Sheet1!$C$3:$C$12"	'&lt;== These are the y-values for each label 

'and use the same method to add the second set

ActiveChart.SeriesCollection.NewSeries
ActiveChart.SeriesCollection(2).Name = "Sheet1!$E$1"
ActiveChart.SeriesCollection(2).XValues = "=Sheet1!$D$3:$D$12"    '&lt;== These are the axis labels
ActiveChart.SeriesCollection(2).Values = "=Sheet1!$E$3:$E$12"	'&lt;== These are the y-values for each label 

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>VBA_EXCEL_CHART_Readme</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>VBA_EXCEL_CHART_Readme</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>VBA_EXCEL_CHART_Readme


////////////////////////////////////////////////////////////
'Referencing a chart using index:

dim sChartName As String 
sChartName = "whatever"

wsX.Shapes.AddChart(xlLine, _
                    Left:=rngOfChart.Left, _
                    Top:=rngOfChart.Top, _
                    Width:=rngOfChart.Width, _
                    Height:=rngOfChart.Height).Select

ActiveChart.Parent.Name = sChartName


dim sChartTitle As String
wsX.ChartObjects(sChartName).Chart.ChartTitle.HasTitle = True
wsX.ChartObjects(sChartName).Chart.ChartTitle.Text = sChartTitle

///////////////////////////////////////////////////////////


'Referencing a chart using name:

wsX.ChartObjects(1).Chart.HasTitle = True
wsX.ChartObjects(1).Chart.ChartTitle.Text = sChartTitle

/////////////// Series and SeriesColletion //////////////////////////////////////////////
'when you use and index with a SeriesCollection object it becomes a Series object
' So:
ActiveChart.SeriesCollection(2) 'is in fact a 'Series' object

/////////////SeriesCollection Object Members///////////////////////////////////////////////
Methods

  Name Description 
 Add -	Adds one or more new series to the SeriesCollection collection. 
 Extend -	Adds new data points to an existing series collection. 
 Item -	Returns a single object from a collection. 
 NewSeries -	Creates a new series. Returns a Series object that represents the new series. 
 Paste -	Pastes data from the Clipboard into the specified series collection. 

Properties

  Name Description 
 Application-	 When used without an object qualifier, this Property returns an Application object that represents the Microsoft Excel application. When used with an object qualifier, this property returns an Application object that represents the creator of the specified object (you can use this property with an OLE Automation object to return the application of that object). Read-only. 
 Count -	Returns a Long value that represents the number of objects in the collection. 
 Creator -	Returns a 32-bit integer that indicates the application in which this object was created. Read-only Long. 
 Parent -	Returns the parent object for the specified object. Read-only. 

/////////////Series Object Members///////////////////////////////////////////////

Methods

  Name Description 
 ApplyDataLabels -	Applies data labels to a series. 
 ClearFormats -	 Clears the formatting of the object. 
 Copy -	 If the series has a picture fill, then this method copies the picture to the Clipboard. 
 DataLabels -	 Returns an object that represents either a single data label (a DataLabel object) or a collection of all the data labels for the series (a DataLabels collection). 
 Delete -	 Deletes the object. 
 ErrorBar -	 Applies error bars to the series. Variant. 
 Paste -	 Pastes a picture from the Clipboard as the marker on the selected series. 
 Points -	 Returns an object that represents a single point (a Point object) or a collection of all the points (a Points collection) in the series. Read-only 
 Select -	 Selects the object. 
 Trendlines -	 Returns an object that represents a single trendline (a Trendline object) or a collection of all the trendlines (a Trendlines collection) for the series. 

Properties

  Name Description 
 Application -	 When used without an object qualifier, this property returns an Application object that represents the Microsoft Excel application. When used with an object qualifier, this property returns an Application object that represents the creator of the specified object (you can use this property with an OLE Automation object to return the application of that object). Read-only. 
 ApplyPictToEnd -	 True if a picture is applied to the end of the point or all points in the series. Read/write Boolean. 
 ApplyPictToFront -	 True if a picture is applied to the front of the point or all points in the series. Read/write Boolean. 
 ApplyPictToSides -	 True if a picture is applied to the sides of the point or all points in the series. Read/write Boolean. 
 AxisGroup -	 Returns or sets the group for the specified series. Read/write 
 BarShape -	 Returns or sets the shape used with the 3-D bar or column chart. Read/write XlBarShape. 
 BubbleSizes -	 Returns or sets a string that refers to the worksheet cells containing the x-value, y-value and size data for the bubble chart. When you return the cell reference, it will return a string describing the cells in A1-style notation. To set the size data for the bubble chart, you must use R1C1-style notation. Applies only to bubble charts. Read/write Variant. 
 ChartType -	 Returns or sets the chart type. Read/write XlChartType. 
 Creator -	 Returns a 32-bit integer that indicates the application in which this object was created. Read-only Long. 
 ErrorBars -	 Returns an ErrorBars object that represents the error bars for the series. Read-only. 
 Explosion -	 Returns or sets the explosion value for a pie-chart or doughnut-chart slice. Returns 0 (zero) if there's no explosion (the tip of the slice is in the center of the pie). Read/write Long. 
 Format -	 Returns the ChartFormat object. Read-only. 
 Formula -	 Returns or sets a String value that represents the object's formula in A1-style notation and in the language of the macro. 
 FormulaLocal -	 Returns or sets the formula for the object, using A1-style references in the language of the user. Read/write String. 
 FormulaR1C1 -	 Returns or sets the formula for the object, using R1C1-style notation in the language of the macro. Read/write String. 
 FormulaR1C1Local -	 Returns or sets the formula for the object, using R1C1-style notation in the language of the user. Read/write String. 
 Has3DEffect -	 True if the series has a three-dimensional appearance. Read/write Boolean. 
 HasDataLabels -	 True if the series has data labels. Read/write Boolean. 
 HasErrorBars -	 True if the series has error bars. This property isn’t available for 3-D charts. Read/write Boolean. 
 HasLeaderLines -	 True if the series has leader lines. Read/write Boolean. 
 InvertColor -	 Returns or sets the fill color for negative data points in a series. Read/write 
 InvertColorIndex -	 Returns or sets the fill color for negative data points in a series. Read/write 
 InvertIfNegative -	 True if Microsoft Excel inverts the pattern in the item when it corresponds to a negative number. Read/write Boolean. 
 LeaderLines -	 Returns a LeaderLines object that represents the leader lines for the series. Read-only. 
 MarkerBackgroundColor -	 Sets the marker background color as an RGB value or returns the corresponding color index value. Applies only to line, scatter, and radar charts. Read/write Long. 
 MarkerBackgroundColorIndex -	 Returns or sets the marker background color as an index into the current color palette, or as one of the following XlColorIndex constants: xlColorIndexAutomatic or xlColorIndexNone. Applies only to line, scatter, and radar charts. Read/write Long. 
 MarkerForegroundColor -	 Sets the marker foreground color as an RGB value or returns the corresponding color index value. Applies only to line, scatter, and radar charts. Read/write Long. 
 MarkerForegroundColorIndex -	 Returns or sets the marker foreground color as an index into the current color palette, or as one of the following XlColorIndex constants: xlColorIndexAutomatic or xlColorIndexNone. Applies only to line, scatter, and radar charts. Read/write Long. 
 MarkerSize -	 Returns or sets the data-marker size, in points (point: Unit of measure referring to the height of a printed character. A point equals 1/72 of an inch, or approximately 1/28 of a centimeter.). Can be a value from 2 through 72. Read/write Long. 
 MarkerStyle -	 Returns or sets the marker style for a point or series in a line chart, scatter chart, or radar chart. Read/write XlMarkerStyle. 
 Name -	 Returns or sets a String value representing the name of the object. 
 Parent -	 Returns the parent object for the specified object. Read-only. 
 PictureType -	 Returns or sets a XlChartPictureType value that represents the way pictures are displayed on a column or bar picture chart. 
 PictureUnit2 -	 Returns or sets the unit for each picture on the chart if the PictureType property is set to xlStackScale (if not, this property is ignored). Read/write Double. 
 PlotColorIndex -	 Returns an index value that is used internally to associate series formatting with chart elements. Read-only 
 PlotOrder -	 Returns or sets the plot order for the selected series within the chart group. Read/write Long. 
 Shadow -	 Returns or sets a Boolean value that determines if the object has a shadow. 
 Smooth -	 True if curve smoothing is turned on for the line chart or scatter chart. Applies only to line and scatter charts. Read/write. 
 Type -	 Returns or sets a Long value that represents the series type. 
 Values -	 Returns or sets a Variant value that represents a collection of all the values in the series. 
 XValues -	 Returns or sets an array of x values for a chart series. The XValues property can be set to a range on a worksheet or to an array of values, but it cannot be a combination of both. Read/write Variant. 



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Classes_Records_Collections</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Array_vs_Collection_vs_Dictionary</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Classes_Records_Collections</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Array_vs_Collection_vs_Dictionary</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Array_vs_Collection_vs_Dictionary
////////////////////////////////////
'FROM: http://www.pcreview.co.uk/forums/array-vs-collection-t3625027.html

///////////////////////////////////////////////////////////////////////

'  An array can be used to simply store a series of related values. However,
'  the only way of getting a value from an array is to use the positional index
'  into the array.
'
'  For example, consider the following code
 
  '''''''''''' Array Example
  Dim Arr(1 To 4)
  Arr(1) = "a"
  Arr(2) = "b"
  Arr(3) = "c"
  Arr(4) = "d"
  Debug.Print Arr(3) ' displays "c"
 
  Here, the only way to get an element from the array is to use the index
  number (3 in this example).
 
  '''''''''''''' Collection Example
  Dim Coll As Collection
  Set Coll = New Collection
  Coll.Add 11, "My1"
  ' value is first parameter, key is second parameter. key must be a (unique) string
  Coll.Add 12, "My2"
  Coll.Add 13, "My3"
  Coll.Add 14, "My4"
  ' access by array index only
  Debug.Print Coll(3) ' displays 13
  Debug.Print Coll("My3") 'displays 13
 
'  Here, you can access an element in the collection by its sequential index
'  number (3 in this example) or by the unique key assigned to the item in the
'  collection ("My3" in this example). Sadly, given a collection, there is no
'  way to get a list of the keys (e.g., get the list "My1", "My2",....).
'  However, the Dictionary object gives you all the functionality of a
'  Collection but also allows you to retreive a list of the keys. For example,
 
  Dim Dict As Dictionary
  Dim S() As Variant
  Dim N As Long
  Set Dict = New Dictionary
  Dict.Add "My1", 1
  ' order of key and valuie is reversed re: Collection. Key first, value second. Key must be string.
  Dict.Add "My2", 2
  Dict.Add "My3", 3
 
  ' access by positional index
  Debug.Print Dict(2) ' returns 2
  ' access by key value
  Debug.Print Dict("My2") ' returns 2
  ' get all keys into an array
  S = Dict.Keys
  For N = LBound(S) To UBound(S)
    ' list all the keys
    Debug.Print "Key: " &amp; S(N)
  Next N
 
'  In order to use a Dictionary object, you must set a reference to the
'  "Microsoft Scripting Runtime" library. In VBA, go to the Tools menu, choose
'  References, and scroll down the list until you find "Microsoft Scripting
'  Runtime ". Check the box next to that entry."
'
'  See also http://www.cpearson.com/Excel/Collec...ctionaries.htm for
'  tons of code regarding Dictionaries and Collections and how to convert
'  between the two and converting on or the other to arrays and/or ranges.
 

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Collections_and_Dictionary</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Array_vs_Collection_vs_Dictionary</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Collections_and_Dictionary</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Array_vs_Collection_vs_Dictionary</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Array_vs_Collection_vs_Dictionary
////////////////////////////////////
'FROM: http://www.pcreview.co.uk/forums/array-vs-collection-t3625027.html

///////////////////////////////////////////////////////////////////////

'  An array can be used to simply store a series of related values. However,
'  the only way of getting a value from an array is to use the positional index
'  into the array.
'
'  For example, consider the following code
 
  '''''''''''' Array Example
  Dim Arr(1 To 4)
  Arr(1) = "a"
  Arr(2) = "b"
  Arr(3) = "c"
  Arr(4) = "d"
  Debug.Print Arr(3) ' displays "c"
 
  Here, the only way to get an element from the array is to use the index
  number (3 in this example).
 
  '''''''''''''' Collection Example
  Dim Coll As Collection
  Set Coll = New Collection
  Coll.Add 11, "My1"
  ' value is first parameter, key is second parameter. key must be a (unique) string
  Coll.Add 12, "My2"
  Coll.Add 13, "My3"
  Coll.Add 14, "My4"
  ' access by array index only
  Debug.Print Coll(3) ' displays 13
  Debug.Print Coll("My3") 'displays 13
 
'  Here, you can access an element in the collection by its sequential index
'  number (3 in this example) or by the unique key assigned to the item in the
'  collection ("My3" in this example). Sadly, given a collection, there is no
'  way to get a list of the keys (e.g., get the list "My1", "My2",....).
'  However, the Dictionary object gives you all the functionality of a
'  Collection but also allows you to retreive a list of the keys. For example,
 
 
   'REFERENCE: Microsoft Scripting Runtime
  Dim Dict As Dictionary
  Dim S() As Variant
  Dim N As Long
  Set Dict = New Dictionary
  Dict.Add "My1", 1
  ' order of key and valuie is reversed re: Collection. Key first, value second. Key must be string.
  Dict.Add "My2", 2
  Dict.Add "My3", 3
 
  ' access by positional index
  Debug.Print Dict(2) ' returns 2
  ' access by key value
  Debug.Print Dict("My2") ' returns 2
  ' get all keys into an array
  S = Dict.Keys
  For N = LBound(S) To UBound(S)
    ' list all the keys
    Debug.Print "Key: " &amp; S(N)
  Next N
 
'  In order to use a Dictionary object, you must set a reference to the
'  "Microsoft Scripting Runtime" library. In VBA, go to the Tools menu, choose
'  References, and scroll down the list until you find "Microsoft Scripting
'  Runtime ". Check the box next to that entry."
'
'  See also http://www.cpearson.com/Excel/Collec...ctionaries.htm for
'  tons of code regarding Dictionaries and Collections and how to convert
'  between the two and converting on or the other to arrays and/or ranges.
 

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Collections_and_Dictionary</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Create_Dictionary</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Collections_and_Dictionary</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Create_Dictionary</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' Each item is associated with a unique key. 
'The key is used to retrieve an individual item and is usually a integer or a string, 
'but can be anything except an array.

Dim dict As Scripting.Dictionary
Dim rng As Excel.Range
Dim sRangeName As String
Set dict = New Scripting.Dictionary
sRangeName = "RangeName"
Set rng = Range(sRangeName)
dict.Add sRangeName, rng


as is the retrieval of items:

dict.Item(sRangeName)

///////////3 usefull Methods of a Dictionary////////////////////////////////////////////

'boolean to let you know whether or not the key k has been added to the dictionary.
dict.Exists(k)


dict.Keys

'Return an array containing all keys in the dictionary, 
'which can then be iterated over. 
'This for me is where the collection really falls down,
' as while it’s certainly possible to iterate over the items in a collection, 
' the key cannot be returned from the item – which means it’s not available
'EXAMPLE:
For iKey = LBound(mdicValues.Keys) To UBound(mdicValues.Keys)
        sKey = mdicValues.Keys(iKey)
        Set objRegex = mdicValues(sKey)
        sTest = clsRow.Item(sKey)
        Debug.Print objRegex.Pattern, sTest
        ' if any test fails, return false
        If Not objRegex.Test(sTest) Then
            bResult = False
            Exit For
        End If
    Next iKey

dict.RemoveAll
'As the name suggests, clean out all key-item pairs in the dictionary.


////////////////another way to create a Dictionary/////////////////////////////////////////
'Items, which can be any form of data, are stored in the array. 


'The following code illustrates how to create a Dictionary object:



Dim d                   'Create a variable
Set d = CreateObject(Scripting.Dictionary)
d.Add "a", "Athens"     'Add some keys and items
d.Add "b", "Belgrade"
d.Add "c", "Cairo"
...
 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_COLOR</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ColorChooser_Dialog</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_COLOR</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ColorChooser_Dialog</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'Usage:
Sub btn_TitleLine_1_Color()			'&lt;===== Assign a button to this
    Dim rX As Range
    Set rX = Worksheets("Parameters").Cells(24, 2)
    PickColorPutVBcolorIntoCell rX
End Sub

Sub PickColorPutVBcolorIntoCell(rngX As Range)	'&lt;==== Cannot assign a button to this b/c it  has a parameter
    
    Dim vX As Variant
    
    vX = PickNewColor(rngX)
    'MsgBox ("The color is: " &amp; CStr(vX))
    
    rngX.Interior.Color = vX
    rngX.Value = vX
    
End Sub


Function PickNewColor(rngX As Range) As Double              ', Optional i_OldColor As Double = xlNone
    
    Dim i_OldColor As Double
    i_OldColor = rngX.Interior.Color
    
    Const BGColor As Long = 13160660  'background color of dialogue
    Const ColorIndexLast As Long = 32 'index of last custom color in palette
    
    Dim myOrgColor As Double          'original color of color index 32
    Dim myNewColor As Double          'color that was picked in the dialogue
    Dim myRGB_R As Integer            'RGB values of the color that will be
    Dim myRGB_G As Integer            'displayed in the dialogue as
    Dim myRGB_B As Integer            '"Current" color
    
    'save original palette color, because we don't really want to change it
    myOrgColor = ActiveWorkbook.Colors(ColorIndexLast)
    
    If i_OldColor = xlNone Then
        'get RGB values of background color, so the "Current" color looks empty
        Color2RGB BGColor, myRGB_R, myRGB_G, myRGB_B
    Else
        'get RGB values of i_OldColor
        Color2RGB i_OldColor, myRGB_R, myRGB_G, myRGB_B
    End If
    
    'call the color picker dialogue
    If Application.Dialogs(xlDialogEditColor).Show(ColorIndexLast, _
         myRGB_R, myRGB_G, myRGB_B) = True Then
        '"OK" was pressed, so Excel automatically changed the palette
        'read the new color from the palette
        PickNewColor = ActiveWorkbook.Colors(ColorIndexLast)
        'reset palette color to its original value
        ActiveWorkbook.Colors(ColorIndexLast) = myOrgColor
    Else
        '"Cancel" was pressed, palette wasn't changed
        'return old color (or xlNone if no color was passed to the function)
        PickNewColor = i_OldColor
    End If
End Function 






///////////////////////////ORIGINAL //////////////////////////////////////
'FROM: http://www.mrexcel.com/forum/excel-questions/547126-excel-colors-dialog-visual-basic-applications.html



'Picks new color
Function PickNewColor(Optional i_OldColor As Double = xlNone) As Double
Const BGColor As Long = 13160660  'background color of dialogue
Const ColorIndexLast As Long = 32 'index of last custom color in palette

Dim myOrgColor As Double          'original color of color index 32
Dim myNewColor As Double          'color that was picked in the dialogue
Dim myRGB_R As Integer            'RGB values of the color that will be
Dim myRGB_G As Integer            'displayed in the dialogue as
Dim myRGB_B As Integer            '"Current" color
  
  'save original palette color, because we don't really want to change it
  myOrgColor = ActiveWorkbook.Colors(ColorIndexLast)
  
  If i_OldColor = xlNone Then
    'get RGB values of background color, so the "Current" color looks empty
    Color2RGB BGColor, myRGB_R, myRGB_G, myRGB_B
  Else
    'get RGB values of i_OldColor
    Color2RGB i_OldColor, myRGB_R, myRGB_G, myRGB_B
  End If
  
  'call the color picker dialogue
  If Application.Dialogs(xlDialogEditColor).Show(ColorIndexLast, _
     myRGB_R, myRGB_G, myRGB_B) = True Then
    '"OK" was pressed, so Excel automatically changed the palette
    'read the new color from the palette
    PickNewColor = ActiveWorkbook.Colors(ColorIndexLast)
    'reset palette color to its original value
    ActiveWorkbook.Colors(ColorIndexLast) = myOrgColor
  Else
    '"Cancel" was pressed, palette wasn't changed
    'return old color (or xlNone if no color was passed to the function)
    PickNewColor = i_OldColor
  End If
End Function

'Converts a color to RGB values
Sub Color2RGB(ByVal i_Color As Long, _
              o_R As Integer, o_G As Integer, o_B As Integer)
  o_R = i_Color Mod 256
  i_Color = i_Color \ 256
  o_G = i_Color Mod 256
  i_Color = i_Color \ 256
  o_B = i_Color Mod 256
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Conditional_Formatting</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>TwoDifferentConditions_to_a_range</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Conditional_Formatting</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>TwoDifferentConditions_to_a_range</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://stackoverflow.com/questions/13661965/conditional-formatting-using-excel-vba-code


Sub ResetFormatting()
' ----------------------------------------------------------------------------------------
' Written by..: Julius Getz Mørk
' Purpose.....: If conditional formatting ranges are broken it might cause a huge increase
'               in duplicated formatting rules that in turn will significantly slow down
'               the spreadsheet.
'               This macro is designed to reset all formatting rules to default.
' ---------------------------------------------------------------------------------------- 

On Error GoTo ErrHandler

' Make sure we are positioned in the correct sheet
WS_PROMO.Select

' Disable Events
Application.EnableEvents = False

' Delete all conditional formatting rules in sheet
Cells.FormatConditions.Delete

' CREATE ALL THE CONDITIONAL FORMATTING RULES:

' (1) Make negative values red
With Cells(1, 1).FormatConditions.add(xlCellValue, xlLess, "=0")
    .Font.Color = -16776961
    .StopIfTrue = False
End With

' (2) Highlight defined good margin as green values
With Cells(1, 1).FormatConditions.add(xlCellValue, xlGreater, "=CP_HIGH_MARGIN_DEFINITION")
    .Font.Color = -16744448
    .StopIfTrue = False
End With

' (3) Make article strategy "D" red
With Cells(1, 1).FormatConditions.add(xlCellValue, xlEqual, "=""D""")
    .Font.Bold = True
    .Font.Color = -16776961
    .StopIfTrue = False
End With

' (4) Make article strategy "A" blue
With Cells(1, 1).FormatConditions.add(xlCellValue, xlEqual, "=""A""")
    .Font.Bold = True
    .Font.Color = -10092544
    .StopIfTrue = False
End With

' (5) Make article strategy "W" green
With Cells(1, 1).FormatConditions.add(xlCellValue, xlEqual, "=""W""")
    .Font.Bold = True
    .Font.Color = -16744448
    .StopIfTrue = False
End With

' (6) Show special cost in bold green font
With Cells(1, 1).FormatConditions.add(xlCellValue, xlNotEqual, "=0")
    .Font.Bold = True
    .Font.Color = -16744448
    .StopIfTrue = False
End With

' (7) Highlight duplicate heading names. There can be none.
With Cells(1, 1).FormatConditions.AddUniqueValues
    .DupeUnique = xlDuplicate
    .Font.Color = -16383844
    .Interior.Color = 13551615
    .StopIfTrue = False
End With

' (8) Make heading rows bold with yellow background
With Cells(1, 1).FormatConditions.add(Type:=xlExpression, Formula1:="=IF($B8=""H"";TRUE;FALSE)")
    .Font.Bold = True
    .Interior.Color = 13434879
    .StopIfTrue = False
End With

' Modify the "Applies To" ranges
Cells.FormatConditions(1).ModifyAppliesToRange Range("O8:P507")
Cells.FormatConditions(2).ModifyAppliesToRange Range("O8:O507")
Cells.FormatConditions(3).ModifyAppliesToRange Range("B8:B507")
Cells.FormatConditions(4).ModifyAppliesToRange Range("B8:B507")
Cells.FormatConditions(5).ModifyAppliesToRange Range("B8:B507")
Cells.FormatConditions(6).ModifyAppliesToRange Range("E8:E507")
Cells.FormatConditions(7).ModifyAppliesToRange Range("A7:AE7")
Cells.FormatConditions(8).ModifyAppliesToRange Range("B8:L507")


ErrHandler:
Application.EnableEvents = False

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CustomObject_With_Dictionary_asAProperty</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>StoreDictionaryInCustomObject_ReadWorksheetData_HoldInMatrix</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CustomObject_With_Dictionary_asAProperty</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>StoreDictionaryInCustomObject_ReadWorksheetData_HoldInMatrix</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1] Mod_Two					'Second Button: Process the Data (i.e. runs sub: "Two_Main")  &lt;== This holds the controlling sub: Two_Main
'2] Mod_General				'General Subs
'3] Mod_Functions	 		'Used by Main
'4] Mod_One(NOT INCLUDED)	'First Button: Get Original Data (Choose File, then choose Sheet 
'5] c_R1_Record				'Class that defines the Highest Level Record
'6] c_R2_Record				'Class that defines the next-Highest Level Record
'This example only focuses on the first two levels
////////////////////////////////////////////////
'The sub 'Build_Output_Array' is the one that:
'a) Creates the local level dictionaries to populate into the Custom Objects (i.e. oR1_record and oR2_record)    
	Dim oR1_record As New c_R1_record
    Dim oR2_record As New c_R2_Record
'b) Then those are stored in form module level object:  m_dict_OUTPUTs   
	Private m_dict_OUTPUTs As Scripting.Dictionary		

///////////DATA on sheet: R2_to_R1_Mapping//////////////////////////////

	R1(i) ==&gt;					1		2
R2(i)							Revenue	Expenses
1	Per Member Per Month (PMPM)	1	
2	Grant and Other Revenue		1	
3	Salary and Benefits					1
4	Operations							1
5	Support to Others					1
6	Reserve Spending					1

//////////////////////////////////////////




//////////////1] Mod_Two/////////////////
Option Explicit
Option Base 0

Private m_l_R2_to_R1_Max_Column As Long 'Column where the last cell is located (right side) of:  R2_to_R1
Private m_l_R2_to_R1_Max_Row As Long    'Row where the last cell is located (bottom) of:  R2_to_R1
Private m_l_R3_to_R2_Max_Column As Long 'Column where the last cell is located (right side) of:  R3_to_R2
Private m_l_R3_to_R2_Max_Row As Long    'Row where the last cell is located (bottom) of: R3_to_R2
Private m_l_IN_to_R3_Max_Column As Long 'Column where the last cell is located (right side) of:  IN_to_R3
Private m_l_IN_to_R3_Max_Row As Long    'Row where the last cell is located (bottom) of: IN_to_R3

Private m_arrMAP_R2_to_R1() As Variant       'Matrix Mapping the data from:  R2_to_R1
Private m_arMAP_R3_to_R2() As Variant       'Matrix Mapping the data from:  R3_to_R2
Private m_arrMAP_IN_to_R3() As Variant       'Matrix Mapping the data from:  IN_to_R3

'Requires REFERENCE: Microsoft Scripting Runtime

Private m_dict_OUTPUTs As Scripting.Dictionary     'This is the Output Data, with the 'R1_PK' as the key
'Dictionary Key:    IN_PK   As Integer             'This is the key that ties the levels together, from the Mapping table

'==============================================================================



Sub Two_Main()
    On Error GoTo ErrorHandler
    
    '=========================
    GetTheMatrixSizes
    PopulateTheMappingMatrix "R2_to_R1_Mapping", m_l_R2_to_R1_Max_Row, m_l_R2_to_R1_Max_Column, m_arrMAP_R2_to_R1
    mod_General.PutArrayOnWorkSheet m_arrMAP_R2_to_R1, "Junk", 1, 1
    PopulateTheMappingMatrix "R3_to_R2_Mapping", m_l_R3_to_R2_Max_Row, m_l_R3_to_R2_Max_Column, m_arMAP_R3_to_R2
    PopulateTheMappingMatrix "IN_to_R3_Mapping", m_l_IN_to_R3_Max_Row, m_l_IN_to_R3_Max_Column, m_arrMAP_IN_to_R3
'    mod_General.PutArrayOnWorkSheet m_arrMAP_IN_to_R3, "Junk", 1, 1
    
    
    '1] Build the Output Array
    Set m_dict_OUTPUTs = New Dictionary
    Build_Output_Array
    
    
    '===================START TEST Print of data ==============================
   Dim keyX As Variant
   Dim keyY As Variant
   
   For Each keyX In m_dict_OUTPUTs
        Debug.Print ("=================")
        Debug.Print (CStr(m_dict_OUTPUTs(keyX).R1_i) &amp; " : " &amp; m_dict_OUTPUTs(keyX).R1_Caption)
        

        For Each keyY In m_dict_OUTPUTs(keyX).dict_R2s
            Debug.Print ("=================")
            Debug.Print ("      " &amp; CStr(m_dict_OUTPUTs(keyX).dict_R2s(keyY).R2_i) &amp; " : " &amp; m_dict_OUTPUTs(keyX).dict_R2s(keyY).R2_Caption)
        Next keyY
            
    Next keyX
    
    '===================START TEST Print of data ==============================
    
    
    
    MsgBox ("Done!")
    '=========================
      Exit Sub
            
ErrorHandler:
        Select Case Err.Number
            Case 0  'raised by subroutine
                MsgBox ("A Subroutine raised an error that must be fixed BEFORE proceeding")
            Case Else
                MsgBox "Two_Main - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub



Sub PopulateTheMappingMatrix(sSheetName As String, lNoOfRows As Long, lNoOfColumns As Long, ByRef arrMatrixToPopulate() As Variant)
    On Error GoTo ErrorHandler
    
    '=========================
    Dim rngX As Range

    Set rngX = Range(Worksheets(sSheetName).Range("A1"), Worksheets(sSheetName).Cells(lNoOfRows, lNoOfColumns))
    arrMatrixToPopulate() = rngX


    '=========================
      Exit Sub
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "PopulateTheMappingMatrix - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub

Sub GetTheMatrixSizes()
    On Error GoTo ErrorHandler
    
    '=========================
    '1] R2_to_R1
    m_l_R2_to_R1_Max_Column = fn_lLastColumn("R2_to_R1_Mapping")
    m_l_R2_to_R1_Max_Row = fn_lLastRow("R2_to_R1_Mapping")

     '2] R3_to_R2
    m_l_R3_to_R2_Max_Column = fn_lLastColumn("R3_to_R2_Mapping")
    m_l_R3_to_R2_Max_Row = fn_lLastRow("R3_to_R2_Mapping")
   
     '3] IN_to_R3
    m_l_IN_to_R3_Max_Column = fn_lLastColumn("IN_to_R3_Mapping")
    m_l_IN_to_R3_Max_Row = fn_lLastRow("IN_to_R3_Mapping")
   
    '=========================
      Exit Sub
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "GetTheMatrixSizes - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub


Sub Build_Output_Array()
    On Error GoTo ErrorHandler
    
    '=========================

    Dim iRowCounter As Integer
    Dim iColumnCounter As Integer
    Dim iCellInRangeCounter As Integer
    Dim rngHeaderOfData As Range    'This is the value in Row: 1
    Dim rngColumnOfData As Range    'this is the set of data values located underneath the header, starting a row: 3
    Dim iDataStartsAtColumn_for_R2_to_R1  As Integer   'The Column R1(i) index begin at this column
    Dim iNumberOfRowsOfData_for_R2_to_R1  As Integer
    Dim c As Range
    Dim oR1_record As New c_R1_record
    Dim oR2_record As New c_R2_Record

'   Get the data from: R2_to_R1
    iDataStartsAtColumn_for_R2_to_R1 = 3
    iNumberOfRowsOfData_for_R2_to_R1 = CInt(m_l_R2_to_R1_Max_Row)
    
    
    For iColumnCounter = iDataStartsAtColumn_for_R2_to_R1 To m_l_R2_to_R1_Max_Column
    '===============================================================================
        Set oR1_record = New c_R1_record
        
'        Set rngHeaderOfData = Worksheets("R2_to_R1_Mapping").Range("A1").Offset(0, iDataStartsAtColumn_for_R2_to_R1 - 1)
        Set rngHeaderOfData = Worksheets("R2_to_R1_Mapping").Range("A1").Offset(0, iColumnCounter - 1)

        Set rngColumnOfData = rngHeaderOfData.Offset(2, 0).Resize(iNumberOfRowsOfData_for_R2_to_R1, 1).SpecialCells(xlCellTypeConstants)
        
'        oR1_record.R1_PK = rngHeaderOfData.Value
'        oR1_record.R1_Caption = rngHeaderOfData.Offset(1, 0).Value
'        oR1_record.R1_i = iColumnCounter - iDataStartsAtColumn_for_R2_to_R1 + 1
'
'        Set oR1_record.dict_R2s = New Dictionary

        With oR1_record
            .R1_PK = rngHeaderOfData.Value
            .R1_Caption = rngHeaderOfData.Offset(1, 0).Value
            .R1_i = iColumnCounter - iDataStartsAtColumn_for_R2_to_R1 + 1
            Set .dict_R2s = New Dictionary
        End With

        iCellInRangeCounter = 0
        Set c = Nothing
        
        For Each c In rngColumnOfData.Cells
        
            iCellInRangeCounter = iCellInRangeCounter + 1

            Set oR2_record = New c_R2_Record
            Dim iR2_PK As Integer
            iR2_PK = Worksheets("R2_to_R1_Mapping").Range("A" &amp; CStr(c.Row)).Value
            
            oR2_record.R2_i = iCellInRangeCounter
            oR2_record.R2_PK = iR2_PK
            oR2_record.R2_Caption = Worksheets("R2_to_R1_Mapping").Range("B" &amp; CStr(c.Row)).Value
            oR2_record.R2_Multiplier = c.Value          'This comes from the cell located directly below the 'rngHeaderOfData' cell
            '======================================================================
            
            
            
            'Code for inner Loops if neccessary
            
            
            

             '======================================================================
            'oR1_record.dict_R2s.Add iCellInRangeCounter, oR2_record
            oR1_record.dict_R2s.Add iR2_PK, oR2_record
        Next c
        
        m_dict_OUTPUTs.Add rngHeaderOfData.Value, oR1_record    'Key: is the R1_PK
    '===============================================================================
    Next iColumnCounter
    
    
    '=========================
      Exit Sub
            
            
            
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "Build_Output_Array - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
                Err.Raise 0
                
        End Select
    End Sub



/////////////2] Mod_General/////////////////

Sub PutArrayOnWorkSheet(arrData() As Variant, SheetName As String, intStartRow As Integer, intStartCol As Integer)
    On Error GoTo ErrorHandler
    
    '=========================
    Dim oWorksheet As Worksheet
    Dim rngCopyTo As Range
    Set oWorksheet = ActiveWorkbook.Worksheets(SheetName)

    ' size of array
    Dim intEndRow As Integer
    Dim intEndCol As Integer
    intEndRow = UBound(arrData, 1)
    intEndCol = UBound(arrData, 2)

    Set rngCopyTo = oWorksheet.Range(oWorksheet.Cells(intStartRow, intStartCol), oWorksheet.Cells(intEndRow, intEndCol))
    rngCopyTo.Value = arrData

    '=========================
      Exit Sub
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "GetTheMatrixSizes - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub

////////// 3] Mod_Functions ///////////////

Function fn_WorkSheetExists(wsName As String) As Boolean
    On Error Resume Next
    fn_WorkSheetExists = Worksheets(wsName).Name = wsName
End Function


Function fn_lLastRow(sWorkSheetName As String) As Long
    Dim lX As Long
    

    Dim wsX As Worksheet
    
    Set wsX = Sheets(sWorkSheetName)
    lX = wsX.Cells(Rows.Count, 1).End(xlUp).Row
    
    fn_lLastRow = lX
    
'    MsgBox (CStr(lX))
    
End Function

Function fn_lLastColumn(sWorkSheetName As String) As Long
    On Error GoTo ErrorHandler
    
    '=========================
    Dim lX As Long

'    Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Select


    lX = Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Column
    
    fn_lLastColumn = lX
    
         '=========================
      Exit Function
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
     
End Function



Function fn_MappingsAreValid() As String
    'Validity is defined as:
    '      a) There is 1 or less entries per row of data
    
    Dim sX As String
    Dim sX_accumulated As String
    
    sX = ""
    sX_accumulated = ""
    
    '1] R2_to_R1
    sX = sX &amp; fn_CheckForOneAndOnlyOneValuePerRow("R2_to_R1_Mapping", m_l_R2_to_R1_Max_Row, m_l_R2_to_R1_Max_Column)

    If Len(Trim(sX)) &gt; 0 Then
        sX = "These rows in R2_to_R1_Mapping had more than one value: " &amp; sX
        sX_accumulated = sX
        sX = ""
    Else
    
    End If
    
    '2] R3_to_R2
    
    sX = sX &amp; fn_CheckForOneAndOnlyOneValuePerRow("R3_to_R2_Mapping", m_l_R3_to_R2_Max_Row, m_l_R3_to_R2_Max_Column)

    If Len(Trim(sX)) &gt; 0 Then
        sX = "These rows in R3_to_R2_Mapping had more than one value: " &amp; sX
        sX_accumulated = sX_accumulated &amp; " | " &amp; sX
        sX = ""
    Else
    
    End If
    
    
        '3] IN_to_R3
    
    sX = sX &amp; fn_CheckForOneAndOnlyOneValuePerRow("IN_to_R3_Mapping", m_l_IN_to_R3_Max_Row, m_l_IN_to_R3_Max_Column)

    If Len(Trim(sX)) &gt; 0 Then
        sX = "These rows in IN_to_R3_Mapping had more than one value: " &amp; sX
        sX_accumulated = sX_accumulated &amp; " | " &amp; sX
        sX = ""
    Else
    
    End If

    fn_MappingsAreValid = sX_accumulated
    
End Function


Function fn_CheckForOneAndOnlyOneValuePerRow(sNameOfWorkSheet As String, lRows As Long, lColumns As Long) As String
    On Error GoTo ErrorHandler
    
    '=========================
    
    Dim sX As String
    Dim lRowCounter As Long
    Dim lnonEmptyColumnCount As Long
    
    sX = ""
           
    For lRowCounter = 3 To lRows
        Dim rng As Range
        Dim ws As Worksheet
        Set ws = Sheets(sNameOfWorkSheet)
        Set rng = ws.Cells(lRowCounter, 3).Resize(, lColumns - 2)
        lnonEmptyColumnCount = WorksheetFunction.CountA(rng)
 
        If lnonEmptyColumnCount &gt; 1 Then
            sX = sX &amp; "[" &amp; Trim(Worksheets(sNameOfWorkSheet).Range("A1").Cells(lRowCounter, 2).Value) &amp; "] , "
        Else
'            sX = sX
        End If
        
    Next lRowCounter

    fn_CheckForOneAndOnlyOneValuePerRow = sX
    '=========================
      Exit Function
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "GetTheMatrixSizes - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Function

    
///////////// 5] c_R1_Record /////////////

Option Explicit

'CLASS: c_R1_Record
'Dictionary Key:    R1_PK   As Integer             'This is the key that ties the levels together, from the Mapping table

Public R1_i As Long                     'This is a simple counter starting at 1
Public R1_PK As Long                    'This is the key that ties the levels together, from the Mapping table
Public Total_1 As Double                'This is the total of the (Total_2  times R2_Multiplier) from the R2_Records
Public R1_Caption As String             'This is the caption from the Mapping table
Public dict_R2s As Scripting.Dictionary 'This is the dictionary of R2_Record objects


///////////// 6] c_R2_Record /////////////

Option Explicit

'CLASS: c_R2_Record
'Dictionary Key:    R2_PK   As Integer             'This is the key that ties the levels together, from the Mapping table


Public R2_i As Long                     'This is a simple counter starting at 1
Public R2_PK As Long                    'This is the key that ties the levels together, from the Mapping table
Public Total_2 As Double                'This is the total of the (Total_3  times R3_Multiplier) from the R3_Records
Public R2_Caption As String             'This is the caption from the Mapping table
Public R2_Multiplier As Double          'Used in R1 Record to calculate the Total_1
Public dict_R3s As Scripting.Dictionary 'This is the dictionary of R3_Record objects

//////////////////////////////////////////
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_DropDown</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Change_Event</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_DropDown</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Change_Event</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


I tested mine by clicking the ComboBox control on the Forms toolbar, 
	then clicking on the sheet to add it. 
I then created the DropDown1_Change sub on Sheet 1 with this code in it. 
Then I went back to the Combobox, right-clicked and chose Assign Macro and picked the relevant Macro I'd just created. 
Then I right-clicked and picked Format Control, and chose the input range of A1:A3. 
I then put some values in A1, A2 and A3. 
Then when I clicked on the ComboBox and chose one of those values, a Message box appeared with the value.

 
 sub DropDown1_Change     '&lt;== Seems to be missing parms
 
 	Dim DD As Shape

	Set DD = ActiveSheet.Shapes(Application.Caller)

	MsgBox DD.ControlFormat.List(DD.ControlFormat.ListIndex)
	
 end sub
 
 
 'NOTE this did not work yet according to someone who tried to use it.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_DropDown</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Read_value_from_dropDown</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_DropDown</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Read_value_from_dropDown</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


Sub btn_TEST()

    With Worksheets("DataToGraph_Quarterly").Shapes("dd_M1").ControlFormat
        MsgBox "Index chosen = " &amp; .Value       '&lt;==  values are 1-based
        MsgBox "Item chosen = " &amp; .List(.Value)	'&lt;== This is what the user sees when they look at the Drop Down 
    End With
       
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Formatting</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Header_Footer_VBA_Codes</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Formatting</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Header_Footer_VBA_Codes</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Sub Date_Time()
    ActiveSheet.PageSetup.CenterHeader = "&amp;D  &amp;B&amp;ITime:&amp;I&amp;B&amp;T"
End Sub 

'The following special formatting and Visual Basic for Applications (VBA) codes 
'can be included as a part of the header and footer properties (LeftHeader, CenterHeader, RightHeader, LeftFooter, CenterFooter, and RightFooter).

Format code Description 
&amp;L Left aligns the characters that follow. 
&amp;C Centers the characters that follow. 
&amp;R Right aligns the characters that follow. 
&amp;E Turns double-underline printing on or off. 
&amp;X Turns superscript printing on or off. 
&amp;Y Turns subscript printing on or off. 
&amp;B Turns bold printing on or off. 
&amp;I Turns italic printing on or off. 
&amp;U Turns underline printing on or off. 
&amp;S Turns strikethrough printing on or off. 
&amp;"fontname" Prints the characters that follow in the specified font. Be sure to include the double quotation marks. 
&amp;nn Prints the characters that follow in the specified font size. Use a two-digit number to specify a size in points. 
&amp;color Prints the characters in the specified color. User supplies a hexidecimal color value. 
&amp;"+" Prints the characters that follow in the Heading font of the current theme. Be sure to include the double quotation marks. 
&amp;"-" Prints the characters that follow in the Body font of the current theme. Be sure to include the double quotation marks. 
&amp;Kxx.Syyy Prints the characters that follow in the specified color from the current theme. xx is a two-digit number from 1 to 12 that specifies the theme color to use. Snnn specifies the shade (tint) of that theme color. Specify S as + to produce a lighter shade; specify S as - to produce a darker shade. nnn is a three-digit whole number that specifies a percentage from 0 to 100.
If the values that specify the theme color or shade are not within the described limits, Excel will use the nearest valid value.  

VBA code Description 
&amp;D Prints the current date. 
&amp;T Prints the current time. 
&amp;F Prints the name of the document. 
&amp;A Prints the name of the workbook tab. 
&amp;P Prints the page number. 
&amp;P+number Prints the page number plus the specified number. 
&amp;P-number Prints the page number minus the specified number. 
&amp;&amp; Prints a single ampersand. 
&amp;N Prints the total number of pages in the document.  
&amp;Z Prints the file path. 
&amp;G Inserts an image. 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Formatting</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Headers_and_Footers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Formatting</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Headers_and_Footers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Where To Put VBA Code

'If you are using Excel97, you can include the VBA code to set up your page headers and footers in the Workbook's
'BeforePrint event procedure.  .

Private Sub Workbook_BeforePrint(Cancel As Boolean)

Dim WS As Worksheet
For Each WS in Worksheets
    WS.PageSetup.LeftHeader = ThisWorkbook.FullName &amp; " " &amp; _
        Worksheets("Sheet2").Range("A5").Value
Next WS
End Sub



//////////////////////
'Cell Values In The Header
'the following code will put the value of cell B5 on Sheet2 into the header of the activesheet.

ActiveSheet.PageSetup.LeftHeader = _    
    Format(Worksheets("Sheet2").Range("B5").Value)
    
///////////////////////////////    
'Full File Name In The Header
'The following code will place the full file name, including the path, into the header of the active worksheet.

ActiveSheet.PageSetup.LeftHeader = ThisWorkbook.FullName   

/////////////////////////// 
'Fonts And Font Sizes

'You can insert control codes to customize the font, font attributes (bold, italics, etc),
'and font size. The control code used in the header string is the ampersand &amp;.   
'The code below will create put the follow formatted text in the header.

'Some Bold Courier New Size 10 Text

Worksheets("Sheet2").PageSetup.LeftHeader = _
"Some&amp;B&amp;""Courier New""&amp;10 Bold Courier New Size 10&amp;B&amp;""Arial"" Text"

'Note that since the font name must be enclosed in quotes in the header string itself, 
'you must use two double quotes in VBA.
////////////////////////////
 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_GeneralWorkSheet</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>FinalRow</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_GeneralWorkSheet</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>FinalRow</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' Gets the final row of a worksheet.

'1] Go to the very last row of the worksheet, in the first column
'2] Then go back up to the first occupied cell

'For an empty sheet the FinalRow is = 1


Sub TEST()
    Dim FinalRow As Integer
    Sheet1.Select
    FinalRow = Cells(Rows.Count, 1).End(xlUp).Row
    MsgBox ("FinalRow: " &amp; CStr(FinalRow))
    
End Sub

///////////////////////////////////////////////////////

Function fn_lLastRow(sWorkSheetName As String) As Long
    Dim lX As Long
    

    Dim wsX As Worksheet
    
    Set wsX = Sheets(sWorkSheetName)
    lX = wsX.Cells(Rows.Count, 1).End(xlUp).Row
    
    fn_lLastRow = lX
    
'    MsgBox (CStr(lX))
    
End Function

Function fn_lLastColumn(sWorkSheetName As String) As Long

    Dim lX As Long

    Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Select


    lX = Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Column
    
    fn_lLastColumn = lX
    
'    MsgBox (CStr(lX))
     
End Function


//////////////////////////////////
' FROM: http://stackoverflow.com/questions/4872512/last-not-empty-cell-in-row-excel-vba
'    do not use Select
'    cater for the last cell in row 1 being used
'    cater for the entire row being empty
'    cater for the entire row being full

'The Find method in the second code is a far more direct method of establishing the first non-blank cell
'----------------------------------------------------
'This Line:

Set rng1 = ws.Rows(1).Find("*", ws.[a1], xlValues, , xlByColumns, xlPrevious)

'says, start in cell A1 of Sheet "DTCa" then look backwards
'(ie from the last cell in row 1) in row1 by column looking for anything (the *).
'This method either find the last non blank or returns Nothing , ie an empty row
'------------------------------------------------------


Sub Method1()
    Dim ws As Worksheet
    Dim rng1 As Range
    Set ws = Sheets("DTCs")
    If ws.Cells(1, Columns.Count) = vbNullString Then
        Set rng1 = ws.Cells(1, Columns.Count).End(xlToLeft)
        If rng1.Column &lt;&gt; 1 Then
            'return last used cell
            MsgBox "rng1 contains " &amp; rng1.Address(0, 0)
        Else
            If Application.WorksheetFunction.CountA(ws.Rows(1)) = Columns.Count Then
                'row is completely full
                MsgBox ws.Name &amp; " row1 is completely full", vbCritical
                'row is completely empty
            ElseIf ws.[a1] = vbNullString Then MsgBox ws.Name &amp; " row1 is completely empty", vbCritical
            Else
                'true last used cell is A1
                MsgBox "rng1 contains " &amp; rng1.Address(0, 0)
            End If
        End If
    Else
        'last cell is non-blank
        MsgBox ws.Cells(1, Columns.Count) &amp; " contains a value@,vbcritical"
    End If
End Sub

Sub Method2()
    Dim ws As Worksheet
    Dim rng1 As Range
    Set ws = Sheets("DTCs")
    Set rng1 = ws.Rows(1).Find("*", ws.[a1], xlValues, , xlByColumns, xlPrevious)
    If Not rng1 Is Nothing Then
        MsgBox "rng1 contains " &amp; rng1.Address(0, 0)
    Else
        MsgBox ws.Name &amp; " row1 is completely empty", vbCritical
    End If
End Sub


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_MISC</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Paste_Options</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_MISC</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Paste_Options</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Does PasteSpecial do something that xlPasteAll doesn't

'Yes it does

'It gives you the flexibility to choose the way you want your data to be pasted

'the different options are

Paste:=xlPasteAll =&gt; Does the same function as paste
Paste:=xlPasteFormulas =&gt; Pastes only the formulas
Paste:=xlPasteValues =&gt; Pastes only the values
Paste:=xlPasteFormats =&gt; Pastes only the formats
Paste:=xlPasteComments =&gt; Pastes only the comments
Paste:=xlPasteValidation =&gt; Pastes only the validation
Paste:=xlPasteAllExceptBorders =&gt; Pastes everything except the borders in the cell

and so on... 


////////////////////////////////////////

Range("E16").PasteSpecial Paste:=xlPasteAll 
'would be like:
Range("E16").Paste 

////////////Sample of code ///////////////

    Sub COPYCELL()
    Dim wbk As Workbook
     
    strFirstFile = "c:\hack.xls"
    strSecondFile = "c:\vbf.xls"
     
    Set wbk = Workbooks.Open(strFirstFile)
    With wbk.Sheets("Data")
        .Range("G14").Copy
    End With
     
    Set wbk = Workbooks.Open(strSecondFile)
    With wbk.Sheets("MyDate")
        .Range("E16").PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, SkipBlanks:= _
            False, Transpose:=False
    End With
     
    End Sub
    
    
////////////////////////////////

These shoudl be the same:
----------------------------1
With wbk.Sheets("Data")
    Range("G14").Copy
End With

Set wbk = Workbooks.Open(strSecondFile)
With wbk.Sheets("MyDate")
    Range("E16").PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, SkipBlanks:= _
        False, Transpose:=False
End With
---------------------------2
wbk.Sheets("Data").Range("G14").Copy

wbk.Sheets("MyDate").Range("E16").PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, SkipBlanks:= _
        False, Transpose:=False
-----------------------------        
    
    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_MISC</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Personal.xlsb___Macros</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_MISC</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Personal.xlsb___Macros</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub Paste_Unformatted_Text()
'
' Paste_Unformatted_Text Macro
'
' Keyboard Shortcut: Ctrl+Shift+V
'
    
    ActiveSheet.PasteSpecial Format:="Text", Link:=False, DisplayAsIcon:=False
    
    'Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
End Sub

Sub GreyBackground_Bold_Framed()
'
' GreyBackground_Bold_Framed Macro
'

'
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorDark1
        .TintAndShade = -0.249977111117893
        .PatternTintAndShade = 0
    End With
    Selection.Font.Bold = True
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    With Selection.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlInsideVertical)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlInsideHorizontal)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
End Sub

Sub Mark_YellowBackGround_RedFont()
'
' Mark_YellowBackGround_RedFont Macro
'
' Keyboard Shortcut: Ctrl+Shift+M
'
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .Color = 65535
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Font
        .Color = -16776961
        .TintAndShade = 0
    End With
    Selection.Font.Bold = True
End Sub
Sub UnMark()
'
' UnMark Macro
'
' Keyboard Shortcut: Ctrl+Shift+U
'
    With Selection.Interior
        .Pattern = xlNone
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Font
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
    End With
    Selection.Font.Bold = False
End Sub

Sub AlternateMark_PurpleBackGround_YellowFont()
'
' AlternateMark_PurpleBackGround_YellowFont Macro
'
' Keyboard Shortcut: Ctrl+Shift+A
'
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .Color = 10498160
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Font
        .Color = -16711681
        .TintAndShade = 0
    End With
    Selection.Font.Bold = False
End Sub


Sub PasteValues()
'
' PasteValues Macro
'
' Keyboard Shortcut: Ctrl+Shift+T
'
    Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
End Sub
Sub Mark_Normalize()
'
' Mark_Normalize Macro
'
' Keyboard Shortcut: Ctrl+Shift+N
'
    Selection.Font.Bold = False
    With Selection.Interior
        .Pattern = xlNone
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Font
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
    End With
End Sub
Sub UnMark()
'
' UnMark Macro
'
' Keyboard Shortcut: Ctrl+Shift+N
'
    With Selection.Interior
        .Pattern = xlNone
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Font
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
    End With
    Selection.Font.Bold = False
End Sub

Sub PasteValuesTranspose()
'
' PasteValuesTranspose Macro
'
' Keyboard Shortcut: Ctrl+t
'
    Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _
        :=False, Transpose:=True
End Sub


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_MISC</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Personal.xlsb_2016_04_14</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_MISC</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Personal.xlsb_2016_04_14</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub PasteValuesTranspose()
'
' PasteValuesTranspose Macro
'
' Keyboard Shortcut: Ctrl+t
'
    Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _
        :=False, Transpose:=True
End Sub

Sub Paste_Unformatted_Text()
'
' Paste_Unformatted_Text Macro
'
' Keyboard Shortcut: Ctrl+Shift+V
'
    
    ActiveSheet.PasteSpecial Format:="Text", Link:=False, DisplayAsIcon:=False
    
    'Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
End Sub

Sub AlternateMark_PurpleBackGround_YellowFont()
'
' AlternateMark_PurpleBackGround_YellowFont Macro
'
' Keyboard Shortcut: Ctrl+Shift+A
'
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .Color = 10498160
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Font
        .Color = -16711681
        .TintAndShade = 0
    End With
    Selection.Font.Bold = False
End Sub

Sub UnMark()
'
' UnMark Macro
'
' Keyboard Shortcut: Ctrl+Shift+N
'
    With Selection.Interior
        .Pattern = xlNone
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Font
        .ColorIndex = xlAutomatic
        .TintAndShade = 0
    End With
    Selection.Font.Bold = False
End Sub

Sub Mark_YellowBackGround_RedFont()
'
' Mark_YellowBackGround_RedFont Macro
'
' Keyboard Shortcut: Ctrl+Shift+M
'
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .Color = 65535
        .TintAndShade = 0
        .PatternTintAndShade = 0
    End With
    With Selection.Font
        .Color = -16776961
        .TintAndShade = 0
    End With
    Selection.Font.Bold = True
End Sub


Sub GreyBackground_Bold_Framed()
'
' GreyBackground_Bold_Framed Macro
'

'
    With Selection.Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorDark1
        .TintAndShade = -0.249977111117893
        .PatternTintAndShade = 0
    End With
    Selection.Font.Bold = True
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    With Selection.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlInsideVertical)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With Selection.Borders(xlInsideHorizontal)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
End Sub




</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_MISC</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Select_Just_Filled_Cells_andCheckThem</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_MISC</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Select_Just_Filled_Cells_andCheckThem</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Check all cells versus just cells that are filled



'must select cell A1 for it to work
Sub CheckAllCells()
' Slow version of the macro shown on page 360
Dim TheRange As Range
Dim oCell As Range

    StartTime = Now
    Ctr = 0
    Set TheRange = Range("A1:Z20000")
    For Each oCell In TheRange
        If oCell.Text = "Your Text" Then
            '//
            Ctr = Ctr + 1
        End If
    Next oCell
    EndTime = Now
    
    Msg = "Checked " &amp; TheRange.Cells.Count &amp; " cells. Found " &amp; Ctr &amp; " matches. Duration = " &amp; Format(EndTime - StartTime, "h:mm:ss")
    MsgBox Msg
    
End Sub

Sub CheckSpecialCellsOnly()
    ' Based on Page 360

Dim TheRange As Range
Dim oCell As Range

    StartTime = Now
    Ctr = 0
    
    Set TheRange = Range("A1:Z20000").SpecialCells(xlCellTypeConstants, xlTextValues)
    
    For Each oCell In TheRange
        If oCell.Text = "Your Text" Then
            '//
            Ctr = Ctr + 1
        End If
    Next oCell
    EndTime = Now
    
    Msg = "Checked " &amp; TheRange.Cells.Count &amp; " cells. Found " &amp; Ctr &amp; " matches. Duration = " &amp; Format(EndTime - StartTime, "h:mm:ss")
    MsgBox Msg

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_RANGE_Manipulation_Maneuvering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Copy_Paste</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_RANGE_Manipulation_Maneuvering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Copy_Paste</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Sub CopyRange()
   Sheets("Sheet1").Range("C4:E4").Copy _
     Destination:=Sheets("Sheet1").Range("G10")
End Sub


'If Destination argument is omitted, Microsoft Excel copies the range to the Clipboard.

'If you only want to copies value of the range (simulate copy paste specials value), you may use the following code:

Sub CopyPasteValue()
   Sheets("Sheet1").Range("C4:E4").Copy
   Sheets("Sheet1").Range("G10").PasteSpecial _
     Paste:=xlPasteValues
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name> gets list of all Outlook Items (Emails, Contacts, Tasks, etc.)</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name> gets list of all Outlook Items (Emails, Contacts, Tasks, etc.)</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

' VBA Script to get list of All Emails
' Use Tools-&gt;Macro-&gt;Security to allow Macros to run, then restart Outlook
' Run Outlook, Press Alt+F11 to open VBA
' Programming by Greg Thatcher, http://www.GregThatcher.com
' Uses new "Table" Object (available in Outlook 2007 and later -- won't work in Outlook 2003)
Public Sub GetListOfEmails()
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim Report As String
    Dim Folders As Outlook.Folders
    Dim Folder As Outlook.Folder
    Dim reply As Integer
    
    Set Session = Application.Session
    
    reply = MsgBox(Prompt:="This could take a VERY long time, and you won't be able to use Outlook while it runs -- are you sure you want to list all emails from all folders?", _
            Buttons:=vbYesNoCancel, Title:="Run Long Macro")
    If reply = vbYes Then
        Set Folders = Session.Folders
        ' Call RecurseFolders(Folders(1), vbTab, Report)
        For Each Folder In Folders
            Call RecurseFolders(Folder, vbTab, Report)
            Report = Report &amp; "---------------------------------------------------------------------------" &amp; vbCrLf
        Next
    Else
        reply = MsgBox(Prompt:="Would you like to just list all emails from your Inbox?", _
            Buttons:=vbYesNoCancel, Title:="Run Long Macro")
        If reply = vbYes Then
            Call RecurseFolders(Session.GetDefaultFolder(olFolderInbox), vbTab, Report)
        Else
            Exit Sub
        End If
        
    End If
    
    Dim retValue As Boolean
    retValue = CreateReportAsEmail("List of Emails", Report)
    
Exiting:
        Set Session = Nothing
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub


Private Sub RecurseFolders(CurrentFolder As Outlook.Folder, Tabs, Report As String)
    Dim Table As Outlook.Table
    Dim Row As Outlook.Row
    Dim rowValues() As Variant
    Dim SubFolders As Outlook.Folders
    Dim SubFolder As Outlook.Folder
    
    Report = Report &amp; "Folder Name: " &amp; CurrentFolder.Name &amp; " (Store: " &amp; CurrentFolder.Store.DisplayName &amp; ")" &amp; vbCrLf
    
    Set Table = CurrentFolder.GetTable
    Do While Table.EndOfTable = False
        Set Row = Table.GetNextRow
        rowValues = Row.GetValues
        Report = Report &amp; Tabs
        Report = Report &amp; "Subject: " &amp; rowValues(1)
        Report = Report &amp; vbTab &amp; "MessageClass: " &amp; rowValues(4)
        ' Report = Report &amp; vbTab &amp; "Creation Time: " &amp; rowValues(2)
        Report = Report &amp; vbTab &amp; "Last Modification Time: " &amp; rowValues(3)
        'Report = Report &amp; vbTab &amp; "EntryID: " &amp; rowValues(0)
        Report = Report &amp; vbCrLf
    Loop
    
    Set SubFolders = CurrentFolder.Folders
    For Each SubFolder In SubFolders
        Call RecurseFolders(SubFolder, Tabs &amp; vbTab, Report)
    Next SubFolder

End Sub

' VBA Function which displays a report inside an email
Public Function CreateReportAsEmail(Title As String, Report As String)
    On Error GoTo On_Error

    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As AddressEntry
    Dim Inbox As Outlook.Folder

    CreateReportAsEmail = True

    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")

    Set MyAddress = Session.CurrentUser.AddressEntry
    mail.Recipients.Add (MyAddress.Address)
    mail.Recipients.ResolveAll

    mail.Subject = Title
    mail.Body = Report

    mail.Save
    mail.Display


Exiting:
        Set Session = Nothing
        Exit Function
On_Error:
    CreateReportAsEmail = False
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>GetListOfFolders</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>GetListOfFolders</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Public Sub GetListOfFolders()
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim Report As String
    Dim Folders As Outlook.Folders
    Dim Folder As Outlook.Folder
    Dim reply As Integer
    
    Set Session = Application.Session
    
    Set Folders = Session.Folders
    For Each Folder In Folders
        Call RecurseFolders(Folder, vbTab, Report)
        Report = Report &amp; "---------------------------------------------------------------------------" &amp; vbCrLf
    Next
    Dim retValue As Boolean
    retValue = CreateReportAsEmail("List of Folders", Report)
    
Exiting:
        Set Session = Nothing
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub


Private Sub RecurseFolders(CurrentFolder As Outlook.Folder, Tabs, Report As String)
    Dim Table As Outlook.Table
    Dim Row As Outlook.Row
    Dim rowValues() As Variant
    Dim SubFolders As Outlook.Folders
    Dim SubFolder As Outlook.Folder
    
    Report = Report &amp; Tabs &amp; "Folder Name: " &amp; CurrentFolder.Name &amp; " (Store: " &amp; CurrentFolder.Store.DisplayName &amp; ")" &amp; vbCrLf
    
    Set SubFolders = CurrentFolder.Folders
    For Each SubFolder In SubFolders
        Call RecurseFolders(SubFolder, Tabs &amp; vbTab, Report)
    Next SubFolder

End Sub

' VBA Function which displays a report inside an email
Public Function CreateReportAsEmail(Title As String, Report As String)
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As addressEntry
    Dim Inbox As Outlook.Folder
    
    CreateReportAsEmail = True
    
    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")
    
    Set MyAddress = Session.CurrentUser.addressEntry
    mail.Recipients.Add (MyAddress.Address)
    mail.Recipients.ResolveAll
    
    mail.Subject = Title
    mail.Body = Report
    
    mail.Save
    mail.Display
    
    
Exiting:
        Set Session = Nothing
        Exit Function
On_Error:
    CreateReportAsEmail = False
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_VBE_VBA_Extensibility</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_VBE_VBA_Extensibility</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_VBE_VBA_Extensibility

http://www.cpearson.com/Excel/vbe.aspx

VBIDE
=====
'Reference (for VBIDE): "Microsoft Visual Basic for Applications Extensibility 5.3"
'	The VBIDE is the object library that defines all the objects and values that make up VBProject and the Visual Basic Editor.

'You can add the reference programmatically with code like:

    ThisWorkbook.VBProject.References.AddFromGuid _
        GUID:="{0002E157-0000-0000-C000-000000000046}", _
        Major:=5, Minor:=3	
        
VBE 
=====
'refers to the Visual Basic Editor, which includes all the windows and projects that make up the editor.     

VBProject
=========
'A VBProject contains all the code modules and components of a single workbook. 
'One workbook has exactly one VBProject. 
'The VBProject is made up of 1 or more VBComponent objects.

VBComponent
============
'A VBComponent is one object within the VBProject
'A VBComponent is a:
	' regular code module, 
	' a UserForm, 
	' a class module, 
	' any one of the Sheet modules, 
	' or the ThisWorkbook module 
'(together, the Sheet modules and the ThisWorkbook module are called Document type modules). 
'A VBComponent is of one of the following types, identified by the Type property.
'The following constants are used to identify the type. The numeric value of each constant is shown in parentheses.
	vbext_ct_ClassModule (2):	'A class module to create your own objects. See Class Modules for details about classes and objects.
	vbext_ct_Document (100): 	'One of the Sheet modules or the ThisWorkbook module.
	vbext_ct_MSForm (3): 		'A UserForm. The visual component of a UserForm in the VBA Editor is called a Designer.
	vbext_ct_StdModule (1): 	'A regular code module. Most of the procedures on this page will work with these types of components.

CodeModule
===========
'A CodeModule is the VBA source code of a VBComponent.
' You use the CodeModule object to access the code associated with a VBComponent. 
'A VBComponent has exactly one CodeModule which contains all the code for that component.

CodePane
========
'A CodePane is an open editing window of a CodeModule. When you are typing code, you are entering code into the CodePane.

Referencing VBIDE Objects
=========================
'The code below illustrate various ways to reference Extensibility objects.
Dim VBAEditor As VBIDE.VBE
Dim VBProj As VBIDE.VBProject
Dim VBComp As VBIDE.VBComponent
Dim CodeMod As VBIDE.CodeModule

Set VBAEditor = Application.VBE
----------------------------------------
Set VBProj = VBAEditor.ActiveVBProject
' or
Set VBProj = Application.Workbooks("Book1.xls").VBProject
----------------------------------------
Set VBComp = ActiveWorkbook.VBProject.VBComponents("Module1")
' or
Set VBComp = VBProj.VBComponents("Module1")
----------------------------------------
Set CodeMod = ActiveWorkbook.VBProject.VBComponents("Module1").CodeModule
' or
Set CodeMod = VBComp.CodeModule
----------------------------------------

Procedure
==========
' means a Sub, Function, Property Get, Property Let, or Property Set procedure.

'The Extensibility library defines four procedures types, identified by the following constants. 
'The numeric value of each constant is shown within parentheses.

vbext_pk_Get (3). 	'A Property Get procedure.
vbext_pk_Let (1). 	'A Property Let procedure.
vbext_pk_Set (2). 	'A Property Set procedure.
vbext_pk_Proc (0). 	'A Sub or Function procedure.



'The VBA editor is said to be "in sync" if the ActiveVBProject is the same as the VBProject that contains the ActiveCodePane.
'You can test whether the editor in in sync with code like the following.

Function IsEditorInSync() As Boolean
'=======================================================================
' IsEditorInSync
' This tests if the VBProject selected in the Project window, and
' therefore the ActiveVBProject is the same as the VBProject associated
' with the ActiveCodePane. If these two VBProjects are the same,
' the editor is in sync and the result is True. If these are not the
' same project, the editor is out of sync and the result is True.
'=======================================================================
    With Application.VBE
    IsEditorInSync = .ActiveVBProject Is _
        .ActiveCodePane.CodeModule.Parent.Collection.Parent
    End With
End Function

'You can force synchronization with code like the following. 
'This will set the ActiveVBProject to the project associated with the ActiveCodePane.

Sub SyncVBAEditor()
'=======================================================================
' SyncVBAEditor
' This syncs the editor with respect to the ActiveVBProject and the
' VBProject containing the ActiveCodePane. This makes the project
' that conrains the ActiveCodePane the ActiveVBProject.
'=======================================================================
With Application.VBE
If Not .ActiveCodePane Is Nothing Then
    Set .ActiveVBProject = .ActiveCodePane.CodeModule.Parent.Collection.Parent
End </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Searching For Text In A Module</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Searching For Text In A Module</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'The CodeModule object has a Find method that you can use to search for text within the code module. 
'The Find method accepts ByRef Long parameters. 
'Upon input, these parameters specify the range of lines and column to search. 
'On output, these values will point to the found text. 
'To find the second and subsequent occurence of the text, you need to set the parameters to refer to the text following the found line and column. 
'The Find method returns True or False indicating whether the text was found. 
'The code below will search all of the code in Module1 and print a Debug message for each found occurrence. 
'Note the values set with the SL, SC, EL, and EC variables. The code loops until the Found variable is False.

    Sub SearchCodeModule()
        Dim VBProj As VBIDE.VBProject
        Dim VBComp As VBIDE.VBComponent
        Dim CodeMod As VBIDE.CodeModule
        Dim FindWhat As String
        Dim SL As Long ' start line
        Dim EL As Long ' end line
        Dim SC As Long ' start column
        Dim EC As Long ' end column
        Dim Found As Boolean
        
        Set VBProj = ActiveWorkbook.VBProject
        Set VBComp = VBProj.VBComponents("Module1")
        Set CodeMod = VBComp.CodeModule
        
        FindWhat = "findthis"
        
        With CodeMod
            SL = 1
            EL = .CountOfLines
            SC = 1
            EC = 255
            Found = .Find(target:=FindWhat, StartLine:=SL, StartColumn:=SC, _
                EndLine:=EL, EndColumn:=EC, _
                wholeword:=True, MatchCase:=False, patternsearch:=False)
            Do Until Found = False
                Debug.Print "Found at: Line: " &amp; CStr(SL) &amp; " Column: " &amp; CStr(SC)
                EL = .CountOfLines
                SC = EC + 1
                EC = 255
                Found = .Find(target:=FindWhat, StartLine:=SL, StartColumn:=SC, _
                    EndLine:=EL, EndColumn:=EC, _
                    wholeword:=True, MatchCase:=False, patternsearch:=False)
            Loop
        End With
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>