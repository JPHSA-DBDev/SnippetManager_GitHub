<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Calculated_Tables__physical_and_virtual</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_DAX_Calculated_Tables__physical_and_virtual</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Calculated_Tables__physical_and_virtual</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_DAX_Calculated_Tables__physical_and_virtual</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_DAX_Calculated_Tables__physical_and_virtual

'DAX functions with table arguments can typically accept either physical tables (i.e.
' ‘Sales by Store’) or calculated, virtual tables (with functions like FILTER, VALUES,

'examples
---------------

	'SYNTAX for SUMX
		SUMX(
				&lt;table&gt;
				, &lt;expression&gt;
			)


physical =
			SUMX(
					'theTable',
					'theTable',[theColumn]
				)
				
virtual =
			SUMX(
					FILTER(
							'theTable',
							'theTable',[theColumn] &gt; 3
						   )
					'theTable',[theColumn]
				)
				
						</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Filtering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>TREATAS_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Filtering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>TREATAS_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'to use a filter on one table, like the filter used on another table there are Alternatives to TREATAS 
'suchas : relatiohships, Intersect, TREATAS, Contains

'One reason you might not be able to create a needed relationship is that it would result in
'	multiple paths between two tables, and thus crreate ambigouity.
'SO we use a 'virtual relationship' (e.g. TREATAS) to allow us to do the calculation, speed does suffer in this case.
-------------------------------------------------------------------------------------------
'In the following example, the model contains two unrelated product tables. 
'	If a user applies a filter to DimProduct1[ProductCategory] 
'	selecting Bikes, Seats, Tires, the same filter, Bikes, Seats, Tires is applied to DimProduct2[ProductCategory].

CALCULATE(
			SUM(Sales[Amount]), 
			TREATAS(VALUES(DimProduct1[ProductCategory]), DimProduct2[ProductCategory])
		 )
		 
		 
-------------------------------------------------------------------------------------------

'  TREATAS can be used as an alternative syntax to apply 
'  a filter in CALCULATE/CALCULATETABLE
DEFINE
    MEASURE Sales[Sales Trendy Colors] =
        CALCULATE (
            [Sales Amount],
            'Product'[Color] IN { "Red", "White", "Blue" }
        )
    MEASURE Sales[Sales Trendy Colors 2] =
        CALCULATE (
            [Sales Amount],
            TREATAS ( { "Red", "White", "Blue" }, 'Product'[Color] )
        )
EVALUATE
SUMMARIZECOLUMNS (
    'Product'[Brand],
    "Sales Trendy Colors", [Sales Trendy Colors],
    "Sales Trendy Colors 2", [Sales Trendy Colors 2]
)

-------------------------------------------------------------------------------------------
'  TREATAS changes the data lineage of a table and it is
'  used to convert values to the desired filtering column.
DEFINE
    MEASURE Sales[NumOfCustomersInStoreCity] =
        VAR StoreCities = VALUES ( Store[City] )
        RETURN
            CALCULATE (
                COUNTROWS ( Customer ),
                TREATAS ( StoreCities, Customer[City] )
            )
    MEASURE Sales[NumOfCustomersInStoreCountry] =
        VAR StoreCountries = VALUES ( Store[CountryRegion] )
        RETURN
            CALCULATE (
                COUNTROWS ( Customer ),
                TREATAS ( StoreCountries, Customer[CountryRegion] )
            )
EVALUATE
SELECTCOLUMNS (
    VALUES ( Store[Continent] ),
    "Continent", Store[Continent],
    "NumOfStores", CALCULATE ( COUNTROWS ( Store ) ),
    "NumOfCustomersInStoreCity", [NumOfCustomersInStoreCity],
    "NumOfCustomersInStoreCountry", [NumOfCustomersInStoreCountry]
)

-------------------------------------------------------------------------------------------

'  TREATAS can be used with tables with multiple columns,
'  in that case you need to provide the new lineage for each 
'  column of the table.
DEFINE
    MEASURE Sales[NumOfCustomersInStoreCity] =
        VAR StoreCities = SUMMARIZE ( Store, Store[CountryRegion], Store[City] )
        RETURN
            CALCULATE (
                COUNTROWS ( Customer ),
                TREATAS ( StoreCities, Customer[CountryRegion], Customer[City] )
            )
    MEASURE Sales[NumOfCustomersInStoreCountry] =
        VAR StoreCountries = VALUES ( Store[CountryRegion] )
        RETURN
            CALCULATE (
                COUNTROWS ( Customer ),
                TREATAS ( StoreCountries, Customer[CountryRegion] )
            )
EVALUATE
SELECTCOLUMNS (
    VALUES ( Store[Continent] ),
    "Continent", Store[Continent],
    "NumOfStores", CALCULATE ( COUNTROWS ( Store ) ),
    "NumOfCustomersInStoreCity", [NumOfCustomersInStoreCity],
    "NumOfCustomersInStoreCountry", [NumOfCustomersInStoreCountry]
)

================================================================================

DAX STUDIO EXAMPLE:
===================
'for 2 tables: Date and Advertising, with no existing relationship between them
'Advertising: granularity, or rows, is Month and year
'Date: granularity, or rows, are Dates, with Month and Year columns

'for this measure:

Total Advertising = 
CALCULATE (
    SUM ( Advertising[AdvertisingAmount] ),
    TREATAS (
        SUMMARIZE ( 'Date', 'Date'[Year], 'Date'[MonthNumber] ),
        Advertising[Year],
        Advertising[Month Number]
    )
)

'MICROSOFT DOCUMENTATION says: 
'		The number of columns specified must match the number of columns in the table expression and be in the same order.
'So, the SUMMARIZE phrase lists the two columns:  'Date'[Year], 'Date'[MonthNumber]
'	those 2 columns correspond to Advertising[Year] and Advertising[Month Number] reespectively

1] 'the TREATAS clause
--------------------------
EVALUATE 
TREATAS (
        SUMMARIZE ( 'Date', 'Date'[Year], 'Date'[MonthNumber] ),			'--&lt;== use this filter 
        Advertising[Year],													'--&lt;== apply it to these columns
        Advertising[Month Number]											'--&lt;== apply it to these columns
    )

OUTPUT
=====================
YEAR    Month Number
2014	1
2014	2
2014	3
2014	4
2014	5
2014	6
2014	7
2014	8
2014	9
2014	10
2014	11
2014	12
    
2] 'Use the TREATAS clause, as a FILTER, in a CALCULATE statement and applied to the Advertising table

EVALUATE 
{
	 CALCULATE (
	    SUM ( Advertising[AdvertisingAmount] ),
	    TREATAS (
	        SUMMARIZE ( 'Date', 'Date'[Year], 'Date'[MonthNumber] ),
	        Advertising[Year],
	        Advertising[Month Number]
	    )
	)
}
    
OUTPUT  {with no external filter context}
=====================    
220 		'{a scalar}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_ITERATOR_and_AGGREGATOR_functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_ITERATOR_and_AGGREGATOR_functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://elias-nordlinder.medium.com/dax-series-4-iterators-and-aggregators-dba4314c0292


NOTE:
'the only differences between the Iterators, such as SUMX, and the aggregator, 
' such as SUM, is the table parameter as the first parameter in the iterator (‘Sales’).
'When the Expression only is a column, such as ‘Sales’[Quantity] the two can be used interchangeable

'As long as you want to write an expression that is not a single column, you must use an iterator.
===================================================================================================
'Iteration functions 
--------------------
' take in (at least) two parameters to work, which means that they do not work by only sending in a column. 
' The first parameter 
		'that iterators works on are the table that they need to “scan”.
' The second parameter
	'They need the virtual table that the expression, which is the second parameter, should iterate over.
	'The second parameter is often an expression that the iterator will evaluate for each row in the table.

'	move row-by-row through the table
'	does a calculation, or retrieves some data	
'	Then aggregates it when it is all done

e.g.
	 X = SUMX(
				Sales,
				Sales[Order Quantity]
			  )
'the iterator SUMX require the table, Sales, and the Expression, 
'	which in this case is just the column, to compute the order quantity.



'They work like calculated columns 
'	so Interation functions, which are aggregation functions, are similar to calculated columns

SUMX
COUNTX
AVERAGEX
MINX
MAXX
RANKX

===================================================================================================
'Aggregator Functions
---------------------
'Aggregators are functions that aggregate values of a column in a table and return a single value.
e.g.
	Y = SUM(Sales[Order Quantity])


'They could work while only taking in one parameter, i.e. a column

SUM' Total Quantity = SUM ( ‘Sales’[Quantity] )
MAX' Max Sales = MAX ( ‘Sales’[Quantity] )
MIN' Min Sales = MIN ( ‘Sales’[Quantity] )
AVERAGE' Average Sales = AVERAGE ( ‘Sales’[Quantity] )


=========================================================================MORE details about ITERATORS

'The second parameter can be a single column like " Sales[Order Quantity] ", 
'	but it can also be a specific expression like the example below.
Total Sales = 
SUMX (
    Sales,
    Sales[Order Quantity] * Sales[Unit Price] * (1 - Sales[Discount Applied] )
    )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATE_CALCULATETABLE___Reviser_Functions_FilterContext</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATE_CALCULATETABLE___Reviser_Functions_FilterContext</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'CALCULATE_CALCULATETABLE___Reviser_Functions_FilterContext

https://www.youtube.com/c/CSGProChannel/videos

REVISERs are the only thing in DAX that change the filters
'Filter Revisers create a new Revised Filter Context, AND THEN they run a Sub Expression within it
'The Sub Expression is what runs AFTER the filters have been revised
'Think of the Sub Expression as frozen, once the new filters are ready it is unfrozen and runs

Three Revisers
===============

' A CALCULATE statement is a function that gives you the behaviour of a measure without having to add
'	a measure, i.e. an anonymous Measure.

SYNTAX: CALCULATE(
					&lt;Scaler Expression&gt; 
					[,&lt;Table Value&gt;[,&lt;Table Value&gt;[,]]]]]
				 )

&lt;Table Value&gt; ' is a Table of Values, or virtual/temp table

1] 'ex. of CALCULATE without a &lt;Table Value&gt;:, so the only filter is the Row context which in the simplest example would
'				  be a single column table with one value
'	So the result would be evaluated under each rows 'current row context', 
'		and that is transistioned to the 'Revised Filter Context'
CALCULATE(
			SUMX(
				theTable,
				TheTable[theColumn]
				)
		)
2] 'A measure is a pre-built CALCULATE statement with a predifined Sub Expression, e.g. SUMX is the Sub Expression		
[MEASURE] =
	SUMX(
				theTable,
				TheTable[theColumn]
				)
		)

3] '
CALCULATETABLE(
				VALUES(TheTable[theColumn])
			  )

-----------------------------------------------------------------

'Without Reviser (e.g. without CALCULATE) =&gt; same value on each row for SUMX, i.e. in each row Context

1] 'without Context Transition, i.e. without a Reviser

	AVERAGEX(
			VALUES(TheTable[theColumn]),
			SUMX(
				  TheTable,
				  TheTable[theColumn]
				)
			 )
-------------------------		 
'With Reviser (e.g. with CALCULATE) =&gt;  value on each row is calculated individually for SUMX, i.e. in each row Context

2] 'With context transition, i.e. with a reviser

	AVERAGEX(
			VALUES(TheTable[theColumn]),
			CALCULATE(
						SUMX(
							theTable,
							TheTable[theColumn]
							)
					)				
			 )
-------------------------

3] using a Measure, which is essenntially a named CALCULATE fumction, and is a reviser

	'Define the Measure
	
	[MEASURE] =
		SUMX(
					theTable,
					TheTable[theColumn]
					)
			)

	AVERAGEX(
			VALUES(TheTable[theColumn]),
			[MEASURE]
			 )
			 
=====================================CALCULATE with a FILTER statement 'which is a &lt;Table Value&gt;	consisting of 1 column, and one cell
'NOTE: the Sub Expression is not evaluated until the Filter is evaluated at each Context (e.g. Row)
'		in this example the result for FILTER is the same at each row b/c  "some Category" is hard-coded.
CALCULATE(
			SUMX(											'&lt;=== Argument #1: Expression
				theTable,
				TheTable[theColumn1] * TheTable[theColumn2]
				),
			FILTER(											'&lt;=== Argument #2: Table of valuies
					VALUES(TheTable[aCategoricalColumn] ).
					TheTable[aCategoricalColumn] = "some Category"
				  )
		)
'==&gt; returns a scaler value
			
------------- heristic example: with CALCULATETABLE, not really a usefull business example

CALCULATETABLE(
			FILTER(											'&lt;=== Argument #1: Table Expression
					VALUES(TheTable[aCategoricalColumn] ).
					TheTable[aCategoricalColumn] = "some Category"
				  ),
			FILTER(											'&lt;=== Argument #2: Table of valuies
					VALUES(TheTable[aCategoricalColumn] ).
					TheTable[aCategoricalColumn] = "some Category"
				  )
		)
'==&gt; returns a table w/ one column table: column:"aCategoricalColumn", cell value: "some Category"		</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'SYNTAX
CALCULATE(
			&lt;expression&gt;
			[, &lt;filter1&gt; 
			[, &lt;filter2&gt; 
			[, …]
			]])

RETURNS
----------
'a scaler value

NOTE:
'WITHOUT a filter parameter, the Row Context is passed in as a Filter context, so the expression parameter is evaluated
' on each row, under the row context
'WITH a filter parameter, all the external filters (and Row Context) are replaced by the filter parameter.

'CALCULATE allows you to evaluate an expresson in a modified Filter context
'example: I want to see Total Sales, BUT not for the Current Filter, rather for "Last Year", 
'		so take whatever the current year is and modify it to give me last years total sales
' or even though I am on the row for Australia, I want the total sales for the U.S.

'CALCULATE also performs "CONTEXT TRANSITION" i.e. Row Context is converted to Filter Context

-------------------------------------------------------------------------------------

	&lt;expression&gt;
	'CALCULATE: The is some expression, Measure, or scaler Function, that would be operating in the present filter context
	'CALCULATETABLE: The is some table, or Table Function, that would be operating in the present filter context
	
	
	 &lt;filter1&gt; 
	'The filter replaces the present filter context with a new filter context, and THEN the &lt;expression&gt; is resolved
	'you can’t use a measure in the filtering part of a CALCULATE function; you can only refer to columns
	
	'CALCULATE filter expressions accept both boolean &amp; table functions (individually or
		'at the same time!), but all filter arguments are automatically converted into a table
		
	'Any time you use write a function that contains a logical statement (IN, &gt;,&lt;, =, etc.) you’re creating a
		'table (internally processed with FILTER &amp; ALL)
		
	'the FILTER function can be used to create a virtual table &lt;filter&gt; for CALCULATE
-------------------------------------------------------------------------------------	
	

'There's also the CALCULATETABLE function. 
'	It performs exactly the same functionality, except it modifies the filter context applied to an expression that returns a table object.



MODIFIERS:'modifiers are evaluated before the &lt;filter1&gt;  parameter(s)
--------------------------
	REMOVEFILTERS 'from a table, or a column
	'Remove all filters, or filters from one or more columns of a table, or from all columns of a single table.
	ALL, ALLEXCEPT, ALLNOBLANKROW, ALLSELECTED, 
	'Remove filters from one or more columns, or from all columns of a single table.
	KEEPFILTERS 'for an expression, that can be a logical statement, table, or table expression
	'Add filter without removing existing filters on the same columns.
	'e.g.
	 
			Measure1 = 
				CALCULATE ( 
							[Sales Amount], 
							KEEPFILTERS( Product[Color] IN {"Green","Red"} )
						   )
	
	
	
	USERELATIONSHIP
	'Engage an inactive relationship between related columns, in which case the active relationship will automatically become inactive.
	CROSSFILTER
	'Modify filter direction (from both to single, or from single to both) or disable a relationship.
	
	


'The expression used as the first parameter is essentially the same as a measure.
'the 'filters' over-ride existing filters that are already being applied.

Filters can be:
-----------------
'	Boolean filter expressions
'	Table filter expressions
'	Filter modification functions
'When there are multiple filters, they're evaluated by using the AND logical operator. 
'That means all conditions must be TRUE at the same time.

BOOLEAN FILTER EXPRESSIONS
--------------------------
'A Boolean expression filter is an expression that evaluates to TRUE or FALSE. There are several rules that they must abide by:
'	They can reference only a single column.
'	They cannot reference measures.
'	They cannot use a nested CALCULATE function.
'	They cannot use functions that scan or return a table, including aggregation functions.

'Table filter expression


'EXAMPLE
'you might already have a MEASURE:  
	Number of Products = COUNTROWS('Product')
'but you could create a second measure that only looks at that calculation when the unit cost is &gt; $100
	Number of Products OVER 100 = CALCULATE([Number of Products], 'Product'[UnitCost] &gt; 100)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>HASONEFILTER_for_Measure_in_RowContext_and_Totals_row</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>HASONEFILTER_for_Measure_in_RowContext_and_Totals_row</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>HASONEFILTER_for_Measure_in_RowContext_and_Totals_row

======================================================================================================
1] 'Measure tht works in Row Context, but not in Zero Row filters (on Totals row)

Applications_Received = COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])

2] 'Measure that works in just the Totals Row, or zero Row Context
	' the SUMMARIZE builds a 3 row table for calculations
	' the SELECTCOLUMNS lets you use the virtual table like a realtable
	' the SELECTCOLUMNS renames the virtual column to somethng that you can use, and just picks out the column to Aggregate
	' finally SUMX adds up the values

TotalApplicationsForAllCampaings = 

var campaigns = 	
	SUMMARIZE( 
				Map_DealerCode_Campaign,
				Map_DealerCode_Campaign[Campaign],
				"theCount", COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])
			  )
VAR renamedCampaignCols = SELECTCOLUMNS( campaigns, "campaigns[theCount]", [theCount] )

var TotalForAllCampaings = SUMX(renamedCampaignCols, [theCount])

RETURN
TotalForAllCampaings

3] 'Measure that is used in the table, and works in both Row Context and Totals row

Total_Applications = 
var Total_Applications = 
	IF(
		HASONEFILTER(Map_DealerCode_Campaign[Campaign]),
        MEASURES_1[Applications_Received],
		MEASURES_1[TotalApplicationsForAllCampaings]
	  )	

RETURN
Total_Applications

======================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SELECTCOLUMNS_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SELECTCOLUMNS_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

SELECTCOLUMNS(
				Info
				, "StateCountry", [State]&amp;", "&amp;[Country]
				)

----------------------------------------------------------------
EVALUATE
    SELECTCOLUMNS(
        Customers,										//'Source table
        "Customer Name",'Customers'[Customer Name],		//'Column from the Source table
        "Sales Amount", [Sales Amount],					//'a MEASURE
        "Profit Margin %", [Profit Margin %]			//'a MEASURE
        )
        
-----------------------------------------------------------------Calculated Table:

theCalculatedTable = 
					SELECTCOLUMNS(
								    FILTER(
								        'Employee Lookup',
								        'Employee Lookup'[staff_id] IN {6,16,31}
								    	  ),
								    "Employee ID", 
								    'Employee Lookup'[staff_id],
								    "Manager Name &amp; Store",
								    'Employee Lookup'[first_name] &amp; " " &amp; 'Employee Lookup'[last_name] &amp; "-" &amp; 'Employee Lookup'[location]
							   	)
        
----------------------------------------------------------------
Calendar 4 =
			VAR BaseCalendar =
			    CALENDAR ( DATE ( 2016, 1, 1 ), DATE ( 2018, 12, 31 ) )
		
			VAR RenamedCalendar =
			    SELECTCOLUMNS ( 
			    				BaseCalendar, 
			    				"Calendar[Date]", [Date] 
			    				)
		
			VAR Calendar_1 =
			    SELECTCOLUMNS (
						        RenamedCalendar,
						        "Date", 'Calendar'[Date],
						        "Year", YEAR ( Calendar[Date] ),
						        "Month Number", MONTH ( Calendar[Date] ),
						        "Month", FORMAT ( Calendar[Date], "mmmm" ),
						        "Year Month", FORMAT ( Calendar[Date], "mmm yy" 
						        )
			    )
			
			VAR Calendar_2 =
			    ADDCOLUMNS ( 
			    				Calendar_1, 
			    				"Year Month Number", [Year] * 12 + [Month Number] - 1 
			    			)
			
			RETURN
			    Calendar_2



============================================= 'turns a virtual table into a table


EVALUATE 
var campaigns = 
	
	SUMMARIZE( 
				Map_DealerCode_Campaign,
				Map_DealerCode_Campaign[Campaign],
				"whatever", COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])
			  )
VAR renamedCampaignCols = 
			SELECTCOLUMNS( 
							campaigns, 
							"campaigns[whatever]", [whatever] 
						  )

RETURN
renamedCampaignCols

============================================= 'Useing a virtual 
EVALUATE 
var campaigns = 
	
	SUMMARIZE( 
				Map_DealerCode_Campaign,
				Map_DealerCode_Campaign[Campaign],
				"whatever", COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])
			  )
VAR renamedCampaignCols = SELECTCOLUMNS( campaigns, "campaigns[whatever]", [whatever] )

var theTotal = SUMX(SELECTCOLUMNS( campaigns, "campaigns[whatever]", [whatever] ), [Whatever] )


var theTotal2 = SUMX(renamedCampaignCols, [Whatever])

RETURN
{theTotal2}			'You can use either theTotal, or theTotal2 here and it works in DAX Studio


================================='One of the Data columns (i.e. 'Customers'[Customer Name]) , and A Measure (i.e. [Sales Amount]
'WITHOUT a filter

EVALUATE
    ADDCOLUMNS(
        SELECTCOLUMNS(
            'Customers',
            "Customer Name", 'Customers'[Customer Name]
            ),
        "Sales Amount", [Sales Amount]
        )


================================='One of the Data columns (i.e. 'Customers'[Customer Name]) , and A Measure (i.e. [Sales Amount]
'WITH a filter
EVALUATE
	//' CALCULATETABLE lets us add the filter for [Brand Name]
    CALCULATETABLE(
        ADDCOLUMNS(
            SELECTCOLUMNS(
            	//'The Row header is Customer
                'Customers',
                "Customer Name", 'Customers'[Customer Name]
                ),
            //'ADD a column for the Measure
            "Sales Amount", [Sales Amount]
            ),
        'Products'[Brand Name] = "Contoso"
        )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SELECTCOLUMNS_syntax</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SELECTCOLUMNS_syntax</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'SELECTCOLUMNS returns a table with selected columns from the table plus any new columns 
'	specified by the DAX expression(s)
'SELECTCOLUMNS starts from a blank table

'SELECTCOLUMNS is an Iterator function
'	so when used with CALCULATE or CALCULATETABLE a context transition will occur
' if there are multiple/duplicate rows then there would be  multiple/duplicate in the output
'	and as such no aggregation of multple columns is taking place


'ADDCOLUMNS and SELECTCOLUMNS are nearly identical and behave similarly with an
'	exception, SELECTCOLUMNS starts from a blank table whereas ADDCOLUMNS starts
'	with the entire original table and tacks on columns


'Usefull for creating Calculated Tables

SELECTCOLUMNS(
				&lt;table&gt;									//' source of the selected columns
				, &lt;name&gt;, &lt;scalar_expression&gt; 			//' Selects these columns from &lt;table&gt; to keep.		
				[, &lt;name&gt;, &lt;scalar_expression&gt;]…
				) 

table	'Any DAX expression that returns a table, physical or virtual (e.g. from FILTER)
		'There will be one row in the output for each row that of the Table
		' if there are multiple/duplicate rows then there would be  multiple/duplicate in the output
name	'The name given to the column, enclosed in double quotes.
		' b/c it is working within a row context it can access the column name directly
expression	'Any expression that returns a scalar value like a column reference, integer, or string value.
			'can be columns from the source table, or measures
			'This works b/c SELECTCOLUMNS is an Iterator, and processes each row individually
			
'It is also doing a context transition, b/c every reference to a MEASURE is rewritten to expand the MEASURE
'	surrounded by a CALCULATE, and when you execute a CALCULATE in a Row context you have a context transition
'	Caution: may end up with inflated results from duplicate data</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SUMX</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SUMX</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'If you do not need to filter the column, use the SUM function.
'Returns the sum of an expression evaluated for each row in a table:   
	SUMX(&lt;table&gt;, &lt;expression&gt;)
'Only the numbers in the column are counted. Blanks, logical values, and text are ignored.
  
SYNTAX
	SUMX(
			&lt;table&gt;
			, &lt;expression&gt;
		)
		
		 
	&lt;table&gt; 
	'	can be a virtual table, e.g. resulting from a FILTER statement
	'	The table containing the rows for which the expression will be evaluated.
	 &lt;expression&gt;
	 'The expression to be evaluated for each row of the table.
	'The second argument is a column that contains the numbers you want to sum, or an expression that evaluates to a column. 
	'where:  expression=The expression to be evaluated for each row of the table.
	
Return value
'A decimal number.	
	
-------------------------------------------------------------

'The following example 
'		first filters the table, InternetSales, on the expression, ShippingTerritoryID = 5, 
'		and then returns the sum of all values in the column, Freight. 
'In other words, the expression returns the sum of freight charges for only the specified sales area.
SUMX(
		FILTER(
				InternetSales, 
				InternetSales[SalesTerritoryID]=5
				),
		[Freight])  



----------------------------------------------------------
SUMX (
    VALUES ( 'Date'[Calendar Year Month Number] ),
    IF (												
        AND (
            [Sales Amount] &lt;&gt; 0,
            [Sales LY] &lt;&gt; 0
        ),
        [Sales Amount] - [Sales LY]
    )
'EXAMPLE
	'The following example 
	'	first filters the table, [InternetSales], on the expression, { ShippingTerritoryID = 5 } 
	'	and then returns the sum of all values in the column, Freight. 
	'In other words, the expression returns the sum of freight charges for only the specified sales area.
	= SUMX(
			FILTER(
					InternetSales
					, InternetSales[SalesTerritoryID]=5
					)
			,[Freight]
			) 	
'EXAMPLE:

	2018 sales = SUMX(
						    FILTER(								'&lt;== The filter comes 1st in SUMX
						        Sales,
						        YEAR(Sales[SalesDate])=2018
						    ),
						    [Price]*[Quantity]
						)
'EXAMPLE: using a RELATED table in the FILTER statement
	American sales = SUMX(
							    FILTER(
							        Sales,
							        RELATED(Country[CountryName])="USA"
							    ),
							    [Price]*[Quantity]
'EXAMPLE 1:2 combining 2 filters, one of them in a RELATED table
	2018 American sales = SUMX(
								    FILTER(
								        Sales,
								        AND(											--&lt;==' AND function insteasd of &amp;&amp; 
								            RELATED(Country[CountryName])="USA",          
								            YEAR(Sales[SalesDate])=2018
								        )
								    ),
								    [Price]*[Quantity]
								)
'	2:2 - Here’s the same measure, but using the &amp;&amp; symbols:	
	2018 American sales using &amp;&amp; = SUMX(
									    FILTER(
									        Sales,
									        RELATED(Country[CountryName])="USA" &amp;&amp;			--&lt;==' &amp;&amp; insteasd of AND function
									        YEAR(Sales[SalesDate])=2018
									    ),
									    [Price]*[Quantity]
									)		
' EXAMPLE: Combining Conditions by Nesting Functions
2018 American sales using nesting = SUMX(
										    FILTER(
										        FILTER(
										            Sales,
										            RELATED(Country[CountryName])="USA"
										        ),
										        YEAR(Sales[SalesDate])=2018
										    ),
										    [Price]*[Quantity]
										)
					</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Misc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>VAR_Variables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Misc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>VAR_Variables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'PseudoCode:
myFormula = VAR = VariableName1 = &lt;some valid DAX formula&gt;
            VAR = VariableName2 = &lt;some other valid DAX formula&gt;
            RETURN &lt;another valid DAX formula that can use VariableName1 
                       and VariableName2 as part of the expression&gt;
                       
'Example:

[ABC Class] =
				VAR MySales = Products[ProductSales]
				VAR ProductsWithSalesBiggerThanMine =									'&lt;==== Table Variable
				    FILTER ( ALL ( Products ), Products[ProductSales] &gt;= MySales )
				VAR CumulatedSales =
				    CALCULATE ( SUM ( Sales[SalesAmount] ), ProductsWithSalesBiggerThanMine )
				VAR CumulatedPercentage =
				    CumulatedSales / SUM ( Sales[SalesAmount] )
				RETURN
				    SWITCH (
						        TRUE (),
						        CumulatedPercentage &lt;= 0.7, "A",
						        CumulatedPercentage &lt;= 0.9, "B",
						        "C"
						    )                       
                       
'It is possible to set scalar values as variables but it is also possible to assign tables as variables.

'Scalar Value Example
---------------------
VAR myScalarValue = SUM(Sales[Extended Amount]) 

'Table Example
------------------
VAR myTable = FILTER(Customer,Customer[Post Code] = 50210) 
'The above variable myTable returns a virtual table 
'that can be used anywhere that a table is used in a DAX formula, such as a filter inside a CALCULATE function.              

'Once the variable has been assigned a value, that value cannot change during the execution of the RETURN portion of the formula. 
'From that perspective, the variables act more like constants than regular variables in a traditional programming language context.


-----------------------------------------------------------------DEFINE clause
'You can declare DAX variables in the DEFINE clause of a query like so:
DEFINE
    VAR MyMonth = "January"
    VAR FilteredMonths =
        FILTER ( VALUES ( Sales[Month] ), Sales[Month] = MyMonth )
EVALUATE
CALCULATETABLE ( Sales, FilteredMonths )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Relationhships</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_DAX_Relationhships</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Relationhships</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_DAX_Relationhships</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_DAX_Relationhships

'Two types of Table Relationships
	Physical:
	--------- 
	'are manually created, and visible in your data model
	' have cardinality
	' can be active or inactive, which can both be accesssed using DAX functions
	'	(e.g. RELATED, RELATEDTABLE, or USERELATIONSHIP)
	'Better performance than Virtual relationship
	
	Virtual: 
	--------
	'are temporary, and defined in DAX expressions
	'often used to connect tables w/ different levels of granularity
	'Can be accessed using DAX (e.g. TREATAS)
	
	

'relationships operate more efficiently than lookup functions

'Good to use Star schema: Dimension tables surround a Fact Table  
'							where Dimension is 1-to-many with the Fact table</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Relationhships</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>RELATEDTABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Relationhships</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>RELATEDTABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>RELATEDTABLE
'Evaluates a table expression in a context modified by the given filters.
'The RELATEDTABLE function will travel through the existing relationship between tables, 
'	and will populate a list of rows (sub-table) from the give table

'RELATEDTABLE is a shortcut for CALCULATETABLE (with no logical expression) and performs a
'	context transition from row context to filter context, in order to return only the rows
' which satisfy the filter condition

'SYNTAX
RELATEDTABLE(&lt;tableName&gt;)

tableName	
'The name of an existing table using standard DAX syntax. It cannot be an expression.
'Must reference a table on the "many" side of a many-to-one relationship

NOTE
=====
'The RELATEDTETABLE function changes the context in which the data is filtered, 
'	and evaluates the expression in the new context that you specify.
'RELATEDTETABLE is commonly used with aggregators like COUNTROWS, SUMX, AVERAGEX, etc

'This function is a shortcut for CALCULATETABLE function with no logical expression.


This is not backed by testing: Row context propogation: Iterators vs (Revisers &amp; FILTER)
========================
'Iterator functions (SUMX, RANKX, etc.) use row context to evaluate row level calculations so they don't 
'	need to use RELATED or RELATEDTABLE functions
'CALCULATE and FILTER creates/modifies Filter Context) and therefore the Row context doesn't 
'	automatically propagate through table relationships so they need to use RELATED or RELATEDTABLE functions


EXAMPLES
=================

SUMX( 
		RELATEDTABLE('InternetSales_USD')  
    	 , [SalesAmount_USD]
    ) 

'Calculated Column (aggregation)
' the related table is tied to this calculated column's table by the Product ID, so I think it is creating a virtual table of rows with the same Product IT
'	to be used as the &lt;table&gt; by SUMX, and then the column 'Food Inventory'[quantity_start_of_day] in the Virtual Table is summed up.
Number of Food Items Made = 
							SUMX(
							    RELATEDTABLE(								//'&lt;== This is doing the context transition for the SUMX on each row
										        'Food Inventory'
										    ),
									   'Food Inventory'[quantity_start_of_day]
									)        </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Profile_function_toRemoveLocalUserProfile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Profile_function_toRemoveLocalUserProfile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gallery.technet.microsoft.com/scriptcenter/Remove-UserProfile-Remove-96e27a3b

#'This script contains a function (Remove-UserProfile) which is used to remove user profiles, 
#'    and additional contents of the C:\Users directory (if specified) on a local computer.  
#' Parameters exist to "Exclude" one or more user profiles from being removed, 
#'    remove only profiles "Before" a date when they have not been accessed, 
#'    and to invoke a "DirectoryCleanup" to remove additional files/folders (i.e. non-profiles) within the C:\Users directory.  
#'    Per profile, the profile object itself and all associated registry keys are removed 
#'        if the profile meets the criteria defined via the cmdlet's parameters.
#'
#'This cmdlet requires adminisrative privileges to run effectively. 
#'    Furthermore, this cmdlet is not intended to be used on Virtual Desktop Infrastructure (VDI) environments 
#'    or others which utilize persistent storage on alternate disks, 
#'    or any configurations which utilize another directory other than C:\Users to store user profiles.  
#'This cmdlet is designed to function with PowerShell versions 2 and above.

'USAGE
-------
#'Remove all non-active and non-system designated user profiles from the local computer. 
Remove-UserProfile 
 
#'Remove all non-active and non-system designated user profiles not used within the past month, displaying verbose output as well. 
Remove-UserProfile -Before (Get-Date).AddMonths(-1) -Verbose 
 
#'Remove all non-active and non-system designated user profiles except "labadmin" and "desktopuser", and remove additional non-profile files/folders within C:\Users as well. 
Remove-UserProfile -Exclude @("labadmin", "desktopuser") -DirectoryCleanup 
 
#'Invoke Remove-UserProfile on a Remote Computer 
$scriptBlock = { 
    function Remove-UserProfile 
    { 
        ... 
    } 
 
    Remove-UserProfile 
} 
 
Invoke-Command -ComputerName "GWS-F20" -ScriptBlock $scriptBlock 
 
#'Invoke Remove-UserProfile on Many Remote Computers, Passing in Arguments 
#'This Example Utilizes Windows Workflow Foundation Technology, Available in PowerShell V3 and Above 
$scriptBlock = { 
    function Remove-UserProfile 
    { 
        ... 
    } 
 
    Remove-UserProfile -Exclude $args 
} 
 
$compArray = @() 
Get-Content -Path "\\path\to\computers.txt" | ForEach-Object { $compArray += $_ } 
 
$excludedList = @("labadmin", "desktopuser") 
 
Invoke-Command -ComputerName $compArray -ScriptBlock $scriptBlock -ArgumentList $excludedList -ThrottleLimit 50

==================================================================================================================

#PowerShell Script Containing Function Used to Remove User Profiles &amp; Additional Remnants of C:\Users Directory
#Developer: Andrew Saraceni (saraceni@wharton.upenn.edu)
#Date: 12/22/14

#Requires -Version 2.0

function Remove-UserProfile
{
    &lt;#
    .SYNOPSIS
    Removes user profiles and additional contents of the C:\Users 
    directory if specified.
    .DESCRIPTION
    Gathers a list of profiles to be removed from the local computer, 
    passing on exceptions noted via the Exclude parameter and/or 
    profiles newer than the date specified via the Before parameter.  
    If desired, additional files and folders within C:\Users can also 
    be removed via use of the DirectoryCleanup parameter.

    Once gathered, miscellaneous items are first removed from the 
    C:\Users directory if specified, followed by the profile objects 
    themselves and all associated registry keys per profile.  A listing 
    of current items within the C:\Users directory is returned 
    following the profile removal process.
    .PARAMETER Exclude
    Specifies one or more profile names to exclude from the removal 
    process.
    .PARAMETER Before
    Specifies a date from which to remove profiles before that haven't 
    been accessed since that date.
    .PARAMETER DirectoryCleanup
    Removes additional files/folders (i.e. non-profiles) within the 
    C:\Users directory.
    .EXAMPLE
    Remove-UserProfile
    Remove all non-active and non-system designated user profiles 
    from the local computer.
    .EXAMPLE
    Remove-UserProfile -Before (Get-Date).AddMonths(-1) -Verbose
    Remove all non-active and non-system designated user profiles 
    not used within the past month, displaying verbose output as well.
    .EXAMPLE
    Remove-UserProfile -Exclude @("labadmin", "desktopuser") -DirectoryCleanup
    Remove all non-active and non-system designated user profiles 
    except "labadmin" and "desktopuser", and remove additional 
    non-profile files/folders within C:\Users as well.
    .NOTES
    Even when not specifying the Exclude parameter, the following 
    profiles are not removed when utilizing this cmdlet:
    C:\Windows\ServiceProfiles\NetworkService 
    C:\Windows\ServiceProfiles\LocalService 
    C:\Windows\system32\config\systemprofile 
    C:\Users\Public
    C:\Users\Default

    Aside from the original profile directory (within C:\Users) 
    itself, the following registry items are also cleared upon 
    profile removal via WMI:
    "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\{SID of User}"
    "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileGuid\{GUID}" SidString = {SID of User}
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\{SID of User}"

    Additionally, any currently loaded/in use profiles will not be 
    removed.  Regarding miscellaneous non-profile items, hidden items 
    are not enumerated or removed from C:\Users during this process.

    This cmdlet requires adminisrative privileges to run effectively.
      
    This cmdlet is not intended to be used on Virtual Desktop 
    Infrastructure (VDI) environments or others which utilize 
    persistent storage on alternate disks, or any configurations 
    which utilize another directory other than C:\Users to store 
    user profiles.
    #&gt;
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,Mandatory=$false)]
        [String[]]$Exclude,
        [Parameter(Position=1,Mandatory=$false)]
        [DateTime]$Before,
        [Parameter(Position=2,Mandatory=$false)]
        [Switch]$DirectoryCleanup
    )

    Write-Verbose "Gathering List of Profiles on $env:COMPUTERNAME to Remove..."

    $userProfileFilter = "Loaded = 'False' AND Special = 'False'"
    $cleanupExclusions = @("Public", "Default")

    if ($Exclude)
    {
        foreach ($exclusion in $Exclude)
        {
            $userProfileFilter += "AND NOT LocalPath LIKE '%$exclusion'"
            $cleanupExclusions += $exclusion
        }
    }

    if ($Before)
    {
        $userProfileFilter += "AND LastUseTime &lt; '$Before'"

        $keepUserProfileFilter = "Special = 'False' AND LastUseTime &gt;= '$Before'"
        $profilesToKeep = Get-WmiObject -Class Win32_UserProfile -Filter $keepUserProfileFilter -ErrorAction Stop

        foreach ($profileToKeep in $profilesToKeep)
        {
            try
            {
                $userSID = New-Object -TypeName System.Security.Principal.SecurityIdentifier($($profileToKeep.SID))
                $userName = $userSID.Translate([System.Security.Principal.NTAccount])
                
                $keepUserName = $userName.Value -replace ".*\\", ""
                $cleanupExclusions += $keepUserName
            }
            catch [System.Security.Principal.IdentityNotMappedException]
            {
                Write-Warning "Cannot Translate SID to UserName - Not Adding Value to Exceptions List"
            }
        }
    }

    $profilesToDelete = Get-WmiObject -Class Win32_UserProfile -Filter $userProfileFilter -ErrorAction Stop

    if ($DirectoryCleanup)
    {
        $usersChildItem = Get-ChildItem -Path "C:\Users" -Exclude $cleanupExclusions

        foreach ($usersChild in $usersChildItem)
        {
            if ($profilesToDelete.LocalPath -notcontains $usersChild.FullName)
            {    
                try
                {
                    Write-Verbose "Additional Directory Cleanup - Removing $($usersChild.Name) on $env:COMPUTERNAME..."
                    
                    Remove-Item -Path $($usersChild.FullName) -Recurse -Force -ErrorAction Stop
                }
                catch [System.InvalidOperationException]
                {
                    Write-Verbose "Skipping Removal of $($usersChild.Name) on $env:COMPUTERNAME as Item is Currently In Use..."
                }
            }
        }
    }

    foreach ($profileToDelete in $profilesToDelete)
    {
        Write-Verbose "Removing Profile $($profileToDelete.LocalPath) &amp; Associated Registry Keys on $env:COMPUTERNAME..."
                
        Remove-WmiObject -InputObject $profileToDelete -ErrorAction Stop
    }

    $finalChildItem = Get-ChildItem -Path "C:\Users" | Select-Object -Property Name, FullName, LastWriteTime
                
    return $finalChildItem
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_DEBUG_ERROR_TroubleShooting</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_DEBUG_ERROR_TroubleShooting</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_DEBUG_ERROR_TroubleShooting



&gt;$ErrorActionPreference    ' Returns the Error Action setting
						   'When it hits a error or non-error condition it will keep running, but send it to the console
						   ' The error message will show up in the red text	
						   
						   'Example, use this after some command option to suppress the error: -ErrorAction SilentlyContinue						   
						   &gt;Do-Something -ErrorAction SilentlyContinue
						   
						   'OR you can just set it in general, or globally, and then add the option after a command to run that command different from the global
						   
						   &gt;$ErrorActionPreference = 'SilentlyContinue'
						   
&gt;$VerbosePreference		'Returns the Verbose setting value
						' -Verbose since $VerbosePreference defaults to SilentlyContinue
						
						'For an advanced function you can turn on the Verbose setting:
						&gt;Do-Something -Verbose
						
						'To set the Global setting:
						&gt;$VerbosePreference = 'Continue'
						
DEBUG						
						&gt;Do-Something -Debug   {It throws you into the double greater than sign 'debug' mode
						&gt;&gt;
						To get out of it, just type 'exit' at the command line
						
				
#region During production we'll silence everything and instead, assign to a variable

		'Set the globals:
		$ErrorActionPreference = 'SilentlyContinue'
		$WarningPreference = 'SilentlyContinue'
		$VerbosePreference = 'SilentlyContinue'
		$DebugPreference = 'SilentlyContinue'
		
		## A VM already exists so instead of confusing the user let's just log to fictional file instead
		## This puts the warning into the Warning variable: VMAlreadyExists, but put it into a file rather than to the console
		New-VirtualMachine -VMName 'AlreadyExists' -WarningVariable VMAlreadyExists
		if ($VMAlreadyExists) {
		    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "WARNING: $VMAlreadyExists"
		}
		
		## Here we create an 'error' variable, and save it to a log file
		New-VirtualMachine -VMName 'SQLInjectAttackName' -ErrorVariable err
		if ($err) {
		    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "ERR: $($err.Exception.Message)"
		}
		
		## Check out the log
		Get-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log'

#endregion		</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Write-Error_Write-Warning_Write-Verbose_Write-Debug</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Write-Error_Write-Warning_Write-Verbose_Write-Debug</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'EXAMPLE

function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[string]$VMName
	)
	
    switch ($VMName) {  										 
        'SQLInjectAttackName' {													&lt;===== So if VMName = 'SQLInjectAttackName'
            Write-Error -Message "OMG! Someone's trying to H@x0r our base!"		'Then do this
			#' NOTE: this is a non-terminating Error
        }

        'AlreadyExists' {
            Write-Warning -Message "You got a problem. This VM already exists so you can't add it, dummy"
        }

        'DoesNotExistAlready' {
            Write-Verbose -Message 'The VM does not already exist. You may proceed to add a new one with that name'
        }

        'FlakyIssue' {
            $ThatVariable = 'notright'					#'  &lt;==== This variable gets set inorder to demo suspended mode with the "-debug" Parameter
            Write-Debug -Message 'I will add this VM on host 123, blade 4564 on the molecule H2S squared'
        }
    }
}
======================================================================================
'Demo results--------
======================================================================================ERROR

##' Check what the $ErrorActionPreference variable is set at to see what kind of behavior to expect
$ErrorActionPreference
'OUTPUT
--------
'Continue				'&lt;==== This means when it hits a terminating or non-terminating error it is just going to keep going
						'&lt;==== 		so it will send the error output to the console and then continue
##' A major error occurs!!
&gt;New-VirtualMachine -VMName 'SQLInjectAttackName'

'OUTPUT (in Red)
----------------
#'New-VirtualMachine : OMG! Someone's trying to H@x0r our base!
#'At line:1 char:1
#'+ New-VirtualMachine -VMName 'SQLInjectAttackName'
#'+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
#'    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,New-VirtualMachine

======================================================================================

##' During debugging maybe I don't care for now if it throws an error. Override default behaviour in just this function
&gt;New-VirtualMachine -VMName 'SQLInjectAttackName' -ErrorAction SilentlyContinue
'OUTPUT
--------
'{none}
======================================================================================ERROR
&gt;$ErrorActionPreference = 'SilentlyContinue'			'&lt;===== Set it globally
&gt;$ErrorActionPreference
'OUTPUT
------------
'SilentlyContinue

##' Override it locally during this command
&gt;New-VirtualMachine -VMName 'AlreadyExists' -WarningAction Stop
'OUTPUT (in Red)
----------------
#'New-VirtualMachine : OMG! Someone's trying to H@x0r our base!
#'At line:1 char:1
#'+ New-VirtualMachine -VMName 'SQLInjectAttackName'
#'+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
#'    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,New-VirtualMachine
======================================================================================Warning

&gt;$WarningPreference				'&lt;===== global Warning preference
'OUTPUT
-------------
'Continue				'&lt;==== This means when it hits a terminating or non-terminating error it is just going to keep going
						'&lt;==== 		so it will send the error output to the console and then continue


&gt;New-VirtualMachine -VMName 'AlreadyExists'						
'OUTPUT   (in Orange)
------------
'WARNING: You got a problem. This VM already exists so you can't add it, dummy	

					
##' Override global behaviour w/ 'Stop' value for the Warningaction parameter
&gt;New-VirtualMachine -VMName 'AlreadyExists' -WarningAction Stop		
'OUTPUT  (first line is orange, then the rest is Red)
-------
#'WARNING: You got a problem. This VM already exists so you can't add it, dummy
#'Write-Warning : The running command stopped because the preference variable "WarningPreference" or common parameter is set to Stop: 
#'You got a problem. This VM already exists so you can't add it, dummy
#'At line:15 char:13
#'+             Write-Warning -Message "You got a problem. This VM alread ...
#'+             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : OperationStopped: (:) [Write-Warning], ParentContainsErrorRecordException
#'    + FullyQualifiedErrorId : ActionPreferenceStop,Microsoft.PowerShell.Commands.WriteWarningCommand

======================================================================================Verbose
&gt;$VerbosePreference
'OUPUT
-----------
'SilentlyContinue
			
#' So by default this does not have any output
&gt;New-VirtualMachine -VMName 'DoesNotExistAlready'

#' Forgot -Verbose since $VerbosePreference defaults to SilentlyContinue
&gt;New-VirtualMachine -VMName 'DoesNotExistAlready' -Verbose
'OUTPUT   (in Blue)
----------
'VERBOSE: The VM does not already exist. You may proceed to add a new one with that name

'and you can set Global value to show Verbose messages:
&gt;$VerbosePreference = 'Continue'
======================================================================================Debug
'This is the line with the "Write-Debug" command
&gt;New-VirtualMachine -VMName 'FlakyIssue'
'OUTPUT
------------
'{none}

#' Setting a breakpoint to further investigate the variable
New-VirtualMachine -VMName 'FlakyIssue' -Debug
'In the IDE it throws up a pop-up:
'---------------------------------
'	Continue with this operation? 
'		[YES]
'		[Yes to All]
'		[Halt Command]
'		[Suspend]
'---------------------------------
#' IF you choose [Suspend] then it stops processing and throws you to the command line
'		it is supposed to be a double '&gt;&gt;' rather than a single '&gt;' BUT I did nto see that
'		To get out of the Suspended mode I typed 'Exit'
'	While in the 'DEBUG' suspended mode you can text the value of variables
&gt;$ThatVariable
'OUTPUT (from debug mode)
------------------------
'notright

======================================================================================PRODUCTION
'In production you can silence all the noise:
$ErrorActionPreference = 'SilentlyContinue'
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'
$DebugPreference = 'SilentlyContinue'


#' A VM already exists so instead of confusing the user let's just log to fictional file instead
'	This outputs the message to a variable "VMAlreadyExists", then appends that to a file
'NOTE: no "$" in front of the variable name, on the first line
&gt;New-VirtualMachine -VMName 'AlreadyExists' -WarningVariable VMAlreadyExists
if ($VMAlreadyExists) {
    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "WARNING: $VMAlreadyExists"
}
'OR output it to a new variable called "err"
New-VirtualMachine -VMName 'SQLInjectAttackName' -ErrorVariable err
if ($err) {
    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "ERR: $($err.Exception.Message)"
}

#' Check out the log
Get-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PARAMETER_ValidateScript</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PARAMETER_ValidateScript</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'ValidateScript tests for true before it continues


function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateCount(1, 5)]
		[string[]]$Name,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateRange(1, 5)]
		[int]$Count = 1,
		
		[Parameter()]
		[ValidateNotNull()]
		[ValidateRange(512MB, 1024MB)]
		[int]$MemoryStartupBytes,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('1', '2')]
		[int]$Generation = 2,
		
		[Parameter()]
		[ValidateScript({
	        if (-not (Test-Path -Path $_ -PathType Container))
	        {
		        throw "The folder [$_] does not exist. Try another"
	        }
	        else
	        {
		        $true
            }
        })]
		[ValidatePattern('^C:\\')]
		[string]$Path = 'C:\somebogusfolder',
	
		[Parameter()]
		[AllowNull()]
		[string]$OperatingSystem,

		[Parameter(Mandatory)]
		[AllowNull()]
		[string]$AllowNullParam
	)
}

#region ValidateScript
New-VirtualMachine -Name 'MYNEWVM' -Path 'C:\somebogusfolder' ## fails if detects exception, $true otherwise

#region Make the output prettier

#[ValidateScript({
#	if (-not (Test-Path -Path $_ -PathType Container))
#	{
#		throw "The folder [$_] does not exist. Try another"
#	}
#	else
#	{
#		$true
#	}
#})]

#endregion

#region Other ValidateScript examples
#[ValidateScript({
#	if (Test-Connection -ComputerName $_ -Quiet -Count 1)
#	{
#		throw "The computer [$_] is offline. Try another"
#	}
#	else
#	{
#		$true
#	}
#})]
#endregion

#endregion

#region ValidatePattern
New-VirtualMachine -Name 'MYNEWVM' -Path 'Z:\'
'C:\somefolder' -match '^C:\\'
#endregion

#region ValidateSet
New-VirtualMachine -Name 'MYNEWVM' -Generation

help New-VirtualMachine
#endregion

#region ValidateRange
New-VirtualMachine -Name 'MYNEWVM' -MemoryStartupBytes 128MB
New-VirtualMachine -Name 'MYNEWVM' -Count 10
#endregion

#region ValidateCount
New-VirtualMachine -Name 'MYNEWVM','MYOTHERVM'
#endregion

#region Null attributes
New-VirtualMachine -Name 'MYNEWVM' -NullParamTest $null
New-VirtualMachine -Name 'MYNEWVM' -NullParamTest ''
## Change param to [ValidateNotNull]
New-VirtualMachine -Name 'MYNEWVM' -NullParamTest ''

New-VirtualMachine -Name 'MYNEWVM' -AllowNullParam '' ## Only applies to mandatory parameters
#endregion</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PARAMETER_validation_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PARAMETER_validation_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>PARAMETER_validation_examples


function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateCount(1, 5)]
		[string[]]$Name,			'&lt;=== This is asking for a collection of strings
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateRange(1, 5)]
		[int]$Count = 1,
		
		[Parameter()]
		[ValidateNotNull()]
		[ValidateRange(512MB, 1024MB)]
		[int]$MemoryStartupBytes,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('1', '2')]
		[int]$Generation = 2,
		
		[Parameter()]
		[ValidateScript({
			if (Test-Connection -ComputerName $_ -Quiet -Count 1)
			{
				throw "The computer [$_] is offline. Try another"
			}
			else
			{
				$true
			}
		})]
		[ValidatePattern('^C:\\')]
		[string]$Path = 'C:\somebogusfolder',
		
		[Parameter()]
		[AllowNull()]
		[string]$OperatingSystem,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[string]$NullParamTest,
		
		[Parameter()]
		[AllowNull()]
		[string]$AllowNullParam
	)
}

'When you run this the (Mandatory) declaration will cause it to challenge you for the Parm, if it is not supplied
New-VirtualMachine
'It would responde by challenging you for the name:    &gt;Name[0]:

New-VirtualMachine -Name 'MYNEWVM'
'In this case it would just take the name

#region Get-Help to find Mandatory parameters in cmdlets

## Using help optional parmameters and their values are shown in brackets
==========================================================================

## No mandatory params
(Get-Help -Name Get-Service -Detailed).syntax			'&lt;=== This requests help on the syntax

## Only Path is mandatory
(Get-Help -Name Get-Content -Detailed).syntax

#endregion

#region Get-Command to find Mandatory parameters in cmdlets

(Get-Command -Name 'Get-Content').Parameters.Path.Attributes

#endregion</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Switch</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Switch</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


'EXAMPLE

function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[string]$VMName
	)
	
    switch ($VMName) {  										 
        'SQLInjectAttackName' {													&lt;===== So if VMName = 'SQLInjectAttackName'
            Write-Error -Message "OMG! Someone's trying to H@x0r our base!"		'Then do this
        }

        'AlreadyExists' {
            Write-Warning -Message "You got a problem. This VM already exists so you can't add it, dummy"
        }

        'DoesNotExistAlready' {
            Write-Verbose -Message 'The VM does not already exist. You may proceed to add a new one with that name'
        }

        'FlakyIssue' {
            $ThatVariable = 'notright'
            Write-Debug -Message 'I will add this VM on host 123, blade 4564 on the molecule H2S squared'
        }
    }
}

/////////////////////////////////////////////////////////////


# Switch statement for multiple conditions
Clear-Host
$var = 42                   # Also test with 43 and 49
switch  ($var)
{
  41 {"Forty One"}
  42 {"Forty Two"}
  43 {"Forty Three"}
  default {"default"}
}



# Will match all lines that match
Clear-Host
$var = 42
switch  ($var)
{
  42 {"Forty Two"}
  "42" {"Forty Two String"}
  default {"default"}
}
# Note type coercion will cause both 42 lines to have a match


# To stop processing once a block is found use break
# The semicolon (;) let's you put more than one command on the line
# the "break" ends processing within the brackets, or script block, and jumps to the code right after the brackets
Clear-Host
$var = 42
switch  ($var)
{
  42 {"Forty Two - 1"; break}
  42 {"Forty Two - 2"             #You can break the previous line into multiple lines w/out semicolons as well
       break
       }
  "42" {"Forty Two String"; break}
  default {"default"}
}
# Note, if you want to put multiple commands on a single line, use a ; to separate them


# Switch works with collections, looping and executing for each match
Clear-Host
switch (3,1,2,42)       # So it will go through the options for each item in this collection, and produce results for each.
{
  1 {"One"}
  2 {"Two"}
  3 {"Three"}
  default {"The default answer"}
}


# String compares are case insensitive by default
Clear-Host
switch ("PowerShell")
{
  "powershell" {"lowercase"}
  "POWERSHELL" {"uppercase"}
  "PowerShell" {"mixedcase"}
}



# Use the -casesenstive switch to make it so
Clear-Host
switch -casesensitive ("PowerShell")
{
  "powershell" {"lowercase"}
  "POWERSHELL" {"uppercase"}
  "PowerShell" {"mixedcase"}
}


# Supports wildcards
Clear-Host
switch -Wildcard ("Pluralsight")
{
  "plural*" {"*"}
  "?luralsight" {"?"}
  "Pluralsi???" {"???"}
}

# Note it will also support regex matches

#endregion Logic Branching

##
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SSRS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_List_of_Objects_on_SSRS_Server</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SSRS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_List_of_Objects_on_SSRS_Server</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$ReportServerUri = "http://bcc-explorerdb/reportserver/reportservice2010.asmx";
$Proxy = New-WebServiceProxy -Uri $ReportServerUri -Namespace SSRS.ReportingService2005 -UseDefaultCredential ;

$items = $Proxy.ListChildren("/", $true);

$items | sort-object Type, Name;
'ID                    : c4acd466-c1cb-46ba-8a0b-66fb7687d6a0
'Name                  : Current Job List
'Path                  : /Job Cost/Current Job List
'VirtualPath           : 
'TypeName              : Report
'Size                  : 64009
'SizeSpecified         : True
'Description           : 
'Hidden                : False
'HiddenSpecified       : False
'CreationDate          : 5/9/2016 10:05:51 AM
'CreationDateSpecified : True
'ModifiedDate          : 5/9/2016 10:05:51 AM
'ModifiedDateSpecified : True
'CreatedBy             : BCC\deweyh
'ModifiedBy            : BCC\deweyh
'ItemMetadata          : {}

$items | select Type, Path, ID, Name | sort-object Type, Name;

$items | select Name, Path, TypeName, CreationDate, CreatedBy | sort-object Type, Name  | Format-Table -AutoSize

$items | select Name, Path, TypeName, CreationDate, CreatedBy | sort-object Type, Name  | Export-Csv c:\JUNK\SSRS_Reports_2016_11_07.csv


</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>