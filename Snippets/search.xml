<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ACCESS_2010</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>SwitchboardManager</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ACCESS_2010</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>SwitchboardManager</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


'Switchboard manager' can be added to Quick access toolbar. Switchboard manager is 'Commands Not in the ribbon' category.

here is how you can add it.

1. Open Access
2. Click on File on left top corner of the screen.
3. Click on 'Options' just about Exit on left side of the screen.
4. once 'Acces options' dialog opens up
5. select 'Quick Access Toolbar' on left side of the dialog
6.  select ''Commands Not in the ribbon' on 'Choose Commands From" combobox on top of the dialog
7. select 'Switchboard Manager' and click 'Add' button on center of the 'Access options' dialog
8. click Okay on 'Access options'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ACCESS_SQL</Category>
        <Language>SQLSERVER7 SQL</Language>
        <Public>false</Public>
        <Name>SELECT_CASE__SWITCH</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ACCESS_SQL</Category>
          <Language>SQLSERVER7 SQL</Language>
          <Public>false</Public>
          <Name>SELECT_CASE__SWITCH</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--what is the equivalent of this for SQL in Access:

Select Case OpeningBalance
   Case 0 To 5000
        commission = 20
   Case 5001 To 10000
        commission = 30
   Case 10001 To 20000
        commission = 40
   Case Else
        commission = 50
End Select


--If you want to display a calculated field as commission:

SELECT
    Switch(
        OpeningBalance &lt; 5001, 20,
        OpeningBalance &lt; 10001, 30,
        OpeningBalance &lt; 20001, 40,
        OpeningBalance &gt;= 20001, 50
        ) AS commission
FROM YourTable;

--If you want to store that calculated value to a field named commission:

UPDATE YourTable
SET commission =
    Switch(
        OpeningBalance &lt; 5001, 20,
        OpeningBalance &lt; 10001, 30,
        OpeningBalance &lt; 20001, 40,
        OpeningBalance &gt;= 20001, 50
        );
        
////////////////////////////////////////////////
SELECT
    LIST_Lookups_BAD.LK_ID, 
	Switch(
        [LIST_Lookups_BAD]![LK_ID]&lt;&gt;3, LIST_Lookups_BAD.LK_ID,
		( (Mid([LIST_Lookups_BAD]![Value],1,1)="7") AND ([LIST_Lookups_BAD]![LK_ID] = 3)), LIST_Lookups_BAD.LK_ID,
		([LIST_Lookups_BAD]![LK_ID] = 3), 37

        ) AS LK_ID_NEW, 
	LIST_Lookups_BAD.Value, 
	LIST_Lookups_BAD.ValueLabel

FROM LIST_Lookups_BAD;                </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>AD_Active_Directory</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Find and manage empty Active Directory groups</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>AD_Active_Directory</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Find and manage empty Active Directory groups</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Usage at bottom of the script

#requires -version 2
&lt;#
.SYNOPSIS
  Find and manage empty Active Directory groups.
.DESCRIPTION
  This script allows you to find and manage empty security and distribution groups withing your AD environment. This script also allows
  for the management of found groups. Management of empty groups includes one or more of the following options:
    - Reporting
    - Deleting
.PARAMETER SearchScope
  Optional. Specifies an Active Directory Path to search under. This is primarily used to narrow down your search within a certain OU and it's children.
  Search Scope must be specfied in LDAP format. If not specified, the default search scope is the root of the domain.
  Example: -SearchScope "OU=GROUPS,DC=testlab,DC=com"
.PARAMETER ReportFilePath
  Optional. This is the location where the report of empty groups will be saved to. If this parameter is not specified, the default location
  the report is saved to is C:\EmptyGroups.csv.
  Note: When specifying the file path, you MUST include the file name with the extension of .csv. Example: 'C:\MyReport.csv'.
.PARAMETER DeleteObjects
  Optional. If this parameter is specified, this script will delete the empty groups found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT delete any empty groups found.
.INPUTS
  None.
.OUTPUTS
  Report of empty groups found. See ReportFilePath parameter for more information.
.NOTES
  Version:        1.0
  Author:         Luca Sturlese
  Creation Date:  16.07.2016
  Purpose/Change: Initial script development
.EXAMPLE
  Execution of script using default parameters. Default execution performs reporting of empty AD gruops only, not deleting any objects.
  By default the report is saved in C:\.
  .\Find-ADEmptyGroups.ps1
.EXAMPLE
  Reporting and deleting all empty groups found within the GROUPS OU. Store the report in C:\Reports.
  .\Find-ADEmptyGroups.ps1 -SeachScope "OU=GROUPS,DC=testlab,DC=com" -ReportFilePath 'C:\Reports\DeletedGroups.csv' -DeleteObjects
#&gt;

#---------------------------------------------------------[Script Parameters]------------------------------------------------------

Param (
  [Parameter(Mandatory = $false)][string]$SearchScope,
  [Parameter(Mandatory = $false)][string]$ReportFilePath = 'C:\EmptyGroups.csv',
  [Parameter(Mandatory = $false)][switch]$DeleteObjects = $false
)

#---------------------------------------------------------[Initialisations]--------------------------------------------------------

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'

#Import Modules &amp; Snap-ins
Import-Module ActiveDirectory

#----------------------------------------------------------[Declarations]----------------------------------------------------------



#-----------------------------------------------------------[Functions]------------------------------------------------------------

Function Find-Objects {
  Param ()

  Begin {
    Write-Host "Finding empty groups based on search scope specified..."
  }

  Process {
    Try {
      If($SearchScope) {
        $global:Results = Get-ADGroup -Filter { Members -notlike "*" } -SearchBase $SearchScope | Select-Object Name, GroupCategory, DistinguishedName
      } Else {
        $global:Results = Get-ADGroup -Filter { Members -notlike "*" } | Select-Object Name, GroupCategory, DistinguishedName
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }

    End {
      If ($?) {
        Write-Host 'Completed Successfully.'
        Write-Host ' '
      }
    }
  }
}

Function Create-Report {
  Param ()

  Begin {
    Write-Host "Creating report of empty groups in specified path [$ReportFilePath]..."
  }

  Process {
    Try {
      #Check file path to ensure correct
      If ($ReportFilePath -notlike '*.csv') {
        $ReportFilePath = Join-Path -Path $ReportFilePath -ChildPath '\EmptyGroups.csv'
      }

      # Create CSV report
      $global:Results | Export-Csv $ReportFilePath -NoTypeInformation
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Delete-Objects {
  Param ()

  Begin {
    Write-Host 'Deleting empty groups...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Remove-ADGroup -Identity $Item.DistinguishedName -Confirm:$false
        Write-Host "$($Item.Name) - Deleted"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

#-----------------------------------------------------------[Execution]------------------------------------------------------------

Find-Objects
Create-Report

If ($DeleteObjects) {
  Delete-Objects
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>AD_Active_Directory</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Find and manage empty Active Directory OUs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>AD_Active_Directory</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Find and manage empty Active Directory OUs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Usage at the bottom of the script


#requires -version 2
&lt;#
.SYNOPSIS
  Find and manage empty Active Directory OUs.
.DESCRIPTION
  This script allows you to find and manage empty organizational units within your AD environment. This script also allows
  for the management of found OUs. Management of empty OUs includes one or more of the following options:
    - Reporting
    - Deleting
.PARAMETER SearchScope
  Optional. Specifies an Active Directory Path to search under. This is primarily used to narrow down your search within a certain OU and it's children.
  Search Scope must be specfied in LDAP format. If not specified, the default search scope is the root of the domain.
  Example: -SearchScope "OU=MGT,DC=testlab,DC=com"
.PARAMETER ReportFilePath
  Optional. This is the location where the report of empty OUs will be saved to. If this parameter is not specified, the default location
  the report is saved to is C:\EmptyOUs.csv.
  Note: When specifying the file path, you MUST include the file name with the extension of .csv. Example: 'C:\MyReport.csv'.
.PARAMETER DeleteObjects
  Optional. If this parameter is specified, this script will delete the empty OUs found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT delete any empty OUs found.
  Note: If the OU to be deleted has been marked with PreventFromAccidentialDeletion, then this script will return an error.
.INPUTS
  None.
.OUTPUTS
  Report of empty OUs found. See ReportFilePath parameter for more information.
.NOTES
  Version:        1.0
  Author:         Luca Sturlese
  Creation Date:  16.07.2016
  Purpose/Change: Initial script development
.EXAMPLE
  Execution of script using default parameters. Default execution performs reporting of empty OUs only, not deleting any objects.
  By default the report is saved in C:\.
  .\Find-ADEmptyOU.ps1
.EXAMPLE
  Reporting and deleting all empty OUs found within the MGT OU. Store the report in C:\Reports.
  .\Find-ADEmptyOU.ps1 -SeachScope "OU=MGT,DC=testlab,DC=com" -ReportFilePath 'C:\Reports\DeletedOUs.csv' -DeleteObjects
#&gt;

#---------------------------------------------------------[Script Parameters]------------------------------------------------------

Param (
  [Parameter(Mandatory = $false)][string]$SearchScope,
  [Parameter(Mandatory = $false)][string]$ReportFilePath = 'C:\EmptyOUs.csv',
  [Parameter(Mandatory = $false)][switch]$DeleteObjects = $false
)

#---------------------------------------------------------[Initialisations]--------------------------------------------------------

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'

#Import Modules &amp; Snap-ins
Import-Module ActiveDirectory

#----------------------------------------------------------[Declarations]----------------------------------------------------------



#-----------------------------------------------------------[Functions]------------------------------------------------------------

Function Find-Objects {
  Param ()

  Begin {
    Write-Host "Finding empty OUs based on search scope specified..."
  }

  Process {
    Try {
      If($SearchScope) {
        $global:Results = Get-ADOrganizationalUnit -Filter * -SearchBase $SearchScope | ForEach-Object { If ( !( Get-ADObject -Filter * -SearchBase $_ -SearchScope OneLevel) ) { $_ } } | Select-Object Name, DistinguishedName
      } Else {
        $global:Results = Get-ADOrganizationalUnit -Filter * | ForEach-Object { If ( !( Get-ADObject -Filter * -SearchBase $_ -SearchScope OneLevel) ) { $_ } } | Select-Object Name, DistinguishedName
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }

    End {
      If ($?) {
        Write-Host 'Completed Successfully.'
        Write-Host ' '
      }
    }
  }
}

Function Create-Report {
  Param ()

  Begin {
    Write-Host "Creating report of empty OUs in specified path [$ReportFilePath]..."
  }

  Process {
    Try {
      #Check file path to ensure correct
      If ($ReportFilePath -notlike '*.csv') {
        $ReportFilePath = Join-Path -Path $ReportFilePath -ChildPath '\EmptyOUs.csv'
      }

      # Create CSV report
      $global:Results | Export-Csv $ReportFilePath -NoTypeInformation
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Delete-Objects {
  Param ()

  Begin {
    Write-Host 'Deleting empty OUs...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Remove-ADOrganizationalUnit -Identity $Item.DistinguishedName -Confirm:$false
        Write-Host "$($Item.Name) - Deleted"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

#-----------------------------------------------------------[Execution]------------------------------------------------------------

Find-Objects
Create-Report

If ($DeleteObjects) {
  Delete-Objects
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>AD_Active_Directory</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Find and manage inactive Active Directory computer objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>AD_Active_Directory</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Find and manage inactive Active Directory computer objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Usage at bottom of script

#requires -version 2
&lt;#
.SYNOPSIS
  Find and manage inactive Active Directory computer objects.
.DESCRIPTION
  This script allows you to specify the criteria required to identify inactive computer objects within your AD environment. This script also allows
  for the management of found computers. Management of computer objects includes one or more of the following options:
    - Reporting
    - Disabling computer objects
    - Deleting computer objects
.PARAMETER SearchScope
  Optional. Determines the search scope of what type of computer object you would like to include in the inactive computers search. Options available are:
   - All                        : Default option. All computer including never logged on computer objects.
   - OnlyInactiveComputers      : Only inactive computers. These are computers that have logged on in the past but have not logged on since DaysInactive.
   - OnlyNeverLoggedOn          : Only never logged on objects. This option excludes computers that have logged on before.
   Note: If not specified, the default search scope is All (i.e. all inactive and never logged on computer objects).
.PARAMETER DaysInactive
  Optional. The number of days a computer hasn't logged into the domain for in order to classify it as inactive. The default option is 90
  days, which means any computer that hasn't logged into the domain for 90 days or more is considered inactive and therefore managed by this
  script.
.PARAMETER ReportFilePath
  Optional. This is the location where the report of inactive computer objects will be saved to. If this parameter is not specified, the default location
  the report is saved to is C:\InactiveComputers.csv.
  Note: When specifying the file path, you MUST include the file name with the extension of .csv. Example: 'C:\MyReport.csv'.
.PARAMETER DisableObjects
  Optional. If this parameter is specified, this script will disable the inactive computer objects found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT disable any inactive computers found.
.PARAMETER DeleteObjects
  Optional. If this parameter is specified, this script will delete the inactive computer objects found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT delete any inactive computers found.
.INPUTS
  None.
.OUTPUTS
  Report of inactive computer objects found. See ReportFilePath parameter for more information.
.NOTES
  Version:        1.0
  Author:         Luca Sturlese
  Creation Date:  16.07.2016
  Purpose/Change: Initial script development
.EXAMPLE
  Execution of script using default parameters. Default execution performs reporting of inactive AD computers only, not disabling or deleting any objects.
  By default the report is saved in C:\.
  .\Find-ADInactiveComputers.ps1
.EXAMPLE
  Reporting and disabling all inactive computer objects, except never logged on objects. Storing the report in C:\Reports.
  .\Find-ADInactiveComputers.ps1 -SeachScope OnlyInactiveComputers -ReportFilePath 'C:\Reports\DisabledComputers.csv' -DisableObjects
.EXAMPLE
  Find &amp; delete all inactive computer objects that haven't logged in for the last 30 days. Include never logged on objects in this search.
  .\Find-ADInactiveComputers.ps1 -SeachScope All -DaysInactive 30 -DeleteObjects
#&gt;

#---------------------------------------------------------[Script Parameters]------------------------------------------------------

Param (
  [Parameter(Mandatory = $false)][string][ValidateSet('All', 'OnlyInactiveComputers', 'OnlyNeverLoggedOn')]$SearchScope = 'All',
  [Parameter(Mandatory = $false)][int]$DaysInactive = 90,
  [Parameter(Mandatory = $false)][string]$ReportFilePath = 'C:\Inactivecomputers.csv',
  [Parameter(Mandatory = $false)][switch]$DisableObjects = $false,
  [Parameter(Mandatory = $false)][switch]$DeleteObjects = $false
)

#---------------------------------------------------------[Initialisations]--------------------------------------------------------

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'

#Import Modules &amp; Snap-ins
Import-Module ActiveDirectory

#----------------------------------------------------------[Declarations]----------------------------------------------------------

#Set Inactive Date:
$InactiveDate = (Get-Date).Adddays(-($DaysInactive))

#-----------------------------------------------------------[Functions]------------------------------------------------------------

Function Find-Objects {
  Param ()

  Begin {
    Write-Host "Finding inactive computer objects based on search scope specified [$SearchScope]..."
  }

  Process {
    Try {
      Switch ($SearchScope) {
        'All' {
          $global:Results = Get-ADComputer -Filter { (LastLogonDate -lt $InactiveDate -or LastLogonDate -notlike "*") -and (Enabled -eq $true) } -Properties LastLogonDate | Select-Object Name, LastLogonDate, DistinguishedName
        }

        'OnlyInactiveComputers' {
          $global:Results = Get-ADComputer -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true } -Properties LastLogonDate | Select-Object Name, LastLogonDate, DistinguishedName
        }

        'OnlyNeverLoggedOn' {
          $global:Results = Get-ADComputer -Filter { LastLogonDate -notlike "*" -and Enabled -eq $true } -Properties LastLogonDate | Select-Object Name, LastLogonDate, DistinguishedName
        }

        Default {
          Write-Host -BackgroundColor Red "Error: An unknown error occcurred. Can't determine search scope. Exiting."
          Break
        }
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }

    End {
      If ($?) {
        Write-Host 'Completed Successfully.'
        Write-Host ' '
      }
    }
  }
}

Function Create-Report {
  Param ()

  Begin {
    Write-Host "Creating report of inactive computers in specified path [$ReportFilePath]..."
  }

  Process {
    Try {
      #Check file path to ensure correct
      If ($ReportFilePath -notlike '*.csv') {
        $ReportFilePath = Join-Path -Path $ReportFilePath -ChildPath '\InactiveComputers.csv'
      }

      # Create CSV report
      $global:Results | Export-Csv $ReportFilePath -NoTypeInformation
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Disable-Objects {
  Param ()

  Begin {
    Write-Host 'Disabling inactive computers...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Set-ADComputer -Identity $Item.DistinguishedName -Enabled $false
        Write-Host "$($Item.Name) - Disabled"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Delete-Objects {
  Param ()

  Begin {
    Write-Host 'Deleting inactive computers...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Remove-ADComputer -Identity $Item.DistinguishedName -Confirm:$false
        Write-Host "$($Item.Name) - Deleted"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

#-----------------------------------------------------------[Execution]------------------------------------------------------------

Find-Objects
Create-Report

If ($DisableObjects) {
  Disable-Objects
}

If ($DeleteObjects) {
  Delete-Objects
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ASPNET_C#_Events_and_InterceptingParameters</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>ItemUpdating_e.NewValues</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ASPNET_C#_Events_and_InterceptingParameters</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>ItemUpdating_e.NewValues</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;!--

From: http://www.codeguru.com/vb/controls/vb_listview/article.php/c16137/DataBinding-a-DropDownList-in-a-FormView.htm

This example does CRUD on the Orders Table, but has a drop-down that gets a list of values from the Customers table
	in the NorthWind Database
	


If you use Eval as shown above then you will have to set the value when it changes in the FormViewIttemUpdate event (see Listing 1). 
If you switch Eval to Bind for the SelectedValue then no code-behind is required.

If you want to set the selected value for write, programmatically, implement the ItemUpdating event handler.

Listing 1: VB version
--&gt;
Protected Sub FormView1_ItemUpdating(ByVal sender As Object, _
  ByVal e As System.Web.UI.WebControls.FormViewUpdateEventArgs) _
  Handles FormView1.ItemUpdating
 
  Dim control As DropDownList = FormView1.FindControl("CustomerIDDropDownList")
  e.NewValues("CustomerID") = control.SelectedValue
 
End Sub
&lt;!--

--&gt;


&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head runat="server"&gt;
	&lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;form id="form1" runat="server"&gt;
	&lt;div&gt;
		&lt;asp:FormView ID="FormView1" runat="server" DataKeyNames="OrderID" DataSourceID="SqlDataSource1"
			DefaultMode="Edit"&gt;
			&lt;EditItemTemplate&gt;
				OrderID:
				&lt;asp:Label ID="OrderIDLabel1" runat="server" Text='&lt;%# Eval("OrderID") %&gt;' /&gt;
				&lt;br /&gt;

				CustomerID:

				&lt;asp:DropDownList 
					ID="CustomerIDDropDownList" 
					runat="server" 
					DataValueField='CustomerID'
					DataSourceID="CustomerDataSource" 
					DataTextField="CompanyName" 
					SelectedValue='&lt;%# Bind("CustomerID") %&gt;' /&gt;

				&lt;asp:SqlDataSource 
					ID="CustomerDataSource" 
					runat="server" 
					ConnectionString="&lt;%$ ConnectionStrings:NorthwindConnectionString1 %&gt;"
					SelectCommand="SELECT [CustomerID], [CompanyName] FROM [Customers]"&gt;
				&lt;/asp:SqlDataSource&gt;

				&lt;br /&gt;
				
				...
				
				
			&lt;/EditItemTemplate&gt;
			&lt;InsertItemTemplate&gt;

				...
				
			&lt;/InsertItemTemplate&gt;
			&lt;ItemTemplate&gt;
			
			&lt;/ItemTemplate&gt;
		&lt;/asp:FormView&gt;
		&lt;asp:SqlDataSource ID="SqlDataSource1" runat="server" ConnectionString="&lt;%$ ConnectionStrings:NorthwindConnectionString1 %&gt;"
			SelectCommand="SELECT * FROM [Orders]" DeleteCommand="DELETE FROM [Orders] WHERE [OrderID] = @OrderID"
			InsertCommand="INSERT INTO [Orders] ([CustomerID], 
											[EmployeeID], 
											[OrderDate], 
											[RequiredDate], 
											[ShippedDate], 
											[ShipVia], 
											[Freight], 
											[ShipName], 
											[ShipAddress], 
											[ShipCity], 
											[ShipRegion], 
											[ShipPostalCode], 
											[ShipCountry]) 
										VALUES (@CustomerID, 
												@EmployeeID, 
												@OrderDate, 
												@RequiredDate, 
												@ShippedDate, 
												@ShipVia, 
												@Freight, 
												@ShipName, 
												@ShipAddress, 
												@ShipCity, 
												@ShipRegion, 
												@ShipPostalCode, 
												@ShipCountry)" UpdateCommand="UPDATE [Orders] SET [CustomerID] = @CustomerID, 
										[EmployeeID] = @EmployeeID, 
										[OrderDate] = @OrderDate,
										[RequiredDate] = @RequiredDate, 
										[ShippedDate] = @ShippedDate, 
										[ShipVia] = @ShipVia, 
										[Freight] = @Freight, 
										[ShipName] = @ShipName, 
										[ShipAddress] = @ShipAddress, 
										[ShipCity] = @ShipCity,
										[ShipRegion] = @ShipRegion, 
										[ShipPostalCode] = @ShipPostalCode, 
										[ShipCountry] = @ShipCountry
								WHERE [OrderID] = @OrderID"&gt;
			&lt;DeleteParameters&gt;
				&lt;asp:Parameter Name="OrderID" Type="Int32" /&gt;
			&lt;/DeleteParameters&gt;
			&lt;UpdateParameters&gt;
				&lt;asp:Parameter Name="CustomerID" Type="String" /&gt;
				&lt;asp:Parameter Name="EmployeeID" Type="Int32" /&gt;
				&lt;asp:Parameter Name="OrderDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="RequiredDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="ShippedDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="ShipVia" Type="Int32" /&gt;
				&lt;asp:Parameter Name="Freight" Type="Decimal" /&gt;
				&lt;asp:Parameter Name="ShipName" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipAddress" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipCity" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipRegion" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipPostalCode" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipCountry" Type="String" /&gt;
				&lt;asp:Parameter Name="OrderID" Type="Int32" /&gt;
			&lt;/UpdateParameters&gt;
			&lt;InsertParameters&gt;
				&lt;asp:Parameter Name="CustomerID" Type="String" /&gt;
				&lt;asp:Parameter Name="EmployeeID" Type="Int32" /&gt;
				&lt;asp:Parameter Name="OrderDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="RequiredDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="ShippedDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="ShipVia" Type="Int32" /&gt;
				&lt;asp:Parameter Name="Freight" Type="Decimal" /&gt;
				&lt;asp:Parameter Name="ShipName" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipAddress" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipCity" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipRegion" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipPostalCode" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipCountry" Type="String" /&gt;
			&lt;/InsertParameters&gt;
		&lt;/asp:SqlDataSource&gt;
	&lt;/div&gt;
	&lt;/form&gt;			
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ASPNET_C#_Logging_and_Debugging</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>1_PreRender_PageVisit</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ASPNET_C#_Logging_and_Debugging</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>1_PreRender_PageVisit</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>      protected void Page_PreRenderComplete(object sender, EventArgs e)
            {

            //===============
            string sNoteForLog = Session["UserLogin"].NullSafeToString() + " {PRJ_0038 NEW HIRE} --------- Page Visit - START ------------,&lt;br&gt;";
            //===============
            string sSupervisorName = "UnInitialized";
            string sCMName = "UnInitialized";
            string sFORM_0010_T0_PK = "UnInitialized";
            string sDateTime_Created = "UnInitialized";
            string sDateTime_Updated = "UnInitialized";

            switch (fv_CM_PatientAudit.CurrentMode)
                {

                case (FormViewMode.Edit):


                    Label lbl_EDIT_Supervisor_Name = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_EDIT_Supervisor_Name");
                    sSupervisorName = lbl_EDIT_Supervisor_Name.Text;

                    Label lbl_EDIT_CM_Name = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_EDIT_CM_Name");
                     sCMName = lbl_EDIT_CM_Name.Text;

                    Label lbl_EDIT_FORM_0010_T0_PK = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_EDIT_FORM_0010_T0_PK");
                     sFORM_0010_T0_PK = lbl_EDIT_FORM_0010_T0_PK.Text;

                    Label lbl_EDIT_a_DateTime_Created = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_EDIT_a_DateTime_Created");
                     sDateTime_Created = lbl_EDIT_a_DateTime_Created.Text;


                    Label lbl_EDIT_a_DateTime_Updated = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_EDIT_a_DateTime_Updated");
                     sDateTime_Updated = lbl_EDIT_a_DateTime_Updated.Text;

                    break;


                case (FormViewMode.Insert):
                    Label lbl_INSERT_Supervisor_Name = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_INSERT_Supervisor_Name");
                     sSupervisorName = lbl_INSERT_Supervisor_Name.Text;


                    Label lbl_INSERT_CM_Name = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_INSERT_CM_Name");
                     sCMName = lbl_INSERT_CM_Name.Text;


                    Label lbl_INSERT_FORM_0010_T0_PK = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_INSERT_FORM_0010_T0_PK");
                     sFORM_0010_T0_PK = lbl_INSERT_FORM_0010_T0_PK.Text;


                    Label lbl_INSERT_a_DateTime_Created = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_INSERT_a_DateTime_Created");
                     sDateTime_Created = lbl_INSERT_a_DateTime_Created.Text;



                    Label lbl_INSERT_a_DateTime_Updated = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_INSERT_a_DateTime_Updated");
                     sDateTime_Updated = lbl_INSERT_a_DateTime_Updated.Text;


                    break;

                case (FormViewMode.ReadOnly):

                   Label lbl_ITEM_Supervisor_Name = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_ITEM_Supervisor_Name");
                     sSupervisorName = lbl_ITEM_Supervisor_Name.Text;



                    Label lbl_ITEM_CM_Name = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_ITEM_CM_Name");
                     sCMName = lbl_ITEM_CM_Name.Text;



                    Label lbl_ITEM_FORM_0010_T0_PK = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_ITEM_FORM_0010_T0_PK");
                     sFORM_0010_T0_PK = lbl_ITEM_FORM_0010_T0_PK.Text;



                    Label lbl_ITEM_a_DateTime_Created = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_ITEM_a_DateTime_Created");
                     sDateTime_Created = lbl_ITEM_a_DateTime_Created.Text;



                    Label lbl_ITEM_a_DateTime_Updated = (Label)fv_CM_PatientAudit.fn_ReturnControl_givenControlID("lbl_ITEM_a_DateTime_Updated");
                     sDateTime_Updated = lbl_ITEM_a_DateTime_Updated.Text;

                    break;

                default:

                    Debug.WriteLine("Page_PreRenderComplete: The Session['Mode'] was Neither: Edit, New, View, nor INSERT");


                    break;
                }

            //===============
            sNoteForLog = sNoteForLog + "1] sSupervisorName= " + sSupervisorName + " ,&lt;br&gt; ";
            //===============
            //===============
            sNoteForLog = sNoteForLog + "2] sCMName= " + sCMName + " ,&lt;br&gt; ";
            //===============
            //===============
            sNoteForLog = sNoteForLog + "3] sFORM_0010_T0_PK = " + sFORM_0010_T0_PK + " ,&lt;br&gt; ";
            //===============
            //===============
            sNoteForLog = sNoteForLog + "4] sDateTime_Created= " + sDateTime_Created + " ,&lt;br&gt; ";
            //===============
            //===============
            sNoteForLog = sNoteForLog + "5] sDateTime_Updated= " + sDateTime_Updated + " ,&lt;br&gt; ";
            //===============

            //===========================
            sNoteForLog = sNoteForLog + Session["UserLogin"].NullSafeToString() + " {PRJ_0038 NEW HIRE} --------- Page Visit END ==============";
            Specific_SQL.InsertNoteTo_T00_WriteUsageLog_ForWebFrontEnds(sNoteForLog);
            //==========================

            }
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ASPNET_C#_Validation</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>Custom_Method_BulletList</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ASPNET_C#_Validation</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>Custom_Method_BulletList</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;!-- 
Markup:
		&lt;asp:BulletedList			&lt;== This is where the validation messages go
 		&lt;asp:FormView				&lt;== 				
 		&lt;InsertItemTemplate&gt;		&lt;== Validating the Insert fields

Code-Behind Method:
		sMessageIfTheRequiredFieldsAreNotValid	&lt;== Stores the message
		fn_bTheRequiredFieldsAreValid			&lt;= Method to validate the fields
		fv_NewHire_DetailsForm_OnItemInserting	&lt;== Assigned in Markup, and this is where the validation is called
		fv_NewHire_DetailsForm_ItemCommand	&lt;== Clear the bullet item in the cancel event


Bullet List located above the FormView 

--&gt;

    &lt;asp:BulletedList ID="BulletedList_Message" runat="server"&gt;
    &lt;/asp:BulletedList&gt;
    
&lt;!-- InsertItemTemplate 
		where the fields are
--&gt;    
    &lt;asp:FormView ID="fv_NewHire_DetailsForm" runat="server" DataKeyNames="T30_PK" DataSourceID="SqlDataSource_FormDetails"
        CssClass="cssFormView_DetailsForm" OnItemUpdating="fv_NewHire_DetailsForm_ItemUpdating"
        OnItemCommand="fv_NewHire_DetailsForm_ItemCommand" OnLoad="fv_NewHire_DetailsForm_Load"
        OnModeChanged="fv_NewHire_DetailsForm_ModeChanged" OnModeChanging="fv_NewHire_DetailsForm_ModeChanging"
        OnItemInserting="fv_NewHire_DetailsForm_OnItemInserting" 
        OnDataBinding="fv_NewHire_DetailsForm_DataBinding"
        OnItemInserted="fv_NewHire_DetailsForm_OnItemInserted"&gt;
            
  .........          
            
   &lt;InsertItemTemplate&gt;
        &lt;asp:LinkButton ID="INSERT_LinkButton_1_INSERTButton" runat="server" CausesValidation="True"
            CommandName="Insert" Text="Insert" /&gt;
        &lt;asp:LinkButton ID="INSERT_LinkButton_2_UpdateCancelButton" runat="server" CausesValidation="False"
            CommandName="Cancel" Text="Cancel" /&gt;
        &lt;br&gt;
        &lt;br /&gt;
        &lt;span id="Span1" cssclass="CenterTheTablesInThisSpan" runat="server"&gt;
            &lt;br /&gt;
            &lt;label class="clsTableLabel"&gt;
                Notes &lt;/label&gt;&lt;br /&gt;&lt;br /&gt;&lt;asp:Table CssClass="cssTable_Notes" ID="INSERT_Table_Notes" runat="server" CellPadding="5"
                GridLines="both" HorizontalAlign="Center"&gt;

                &lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
									Notes from HR:
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                        &lt;asp:TextBox ID="txt_HR_Note" runat="server" Text='&lt;%# Bind("HR_Note") %&gt;' /&gt;
                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
									Note for For OtherRoles When UPDATING (From Supervisor):
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                        &lt;asp:TextBox ID="txt_NoteForOtherRoles_WhenUpdating_From_Supervisor" runat="server"
                            Text='&lt;%# Bind("NoteForOtherRoles_WhenUpdating_From_Supervisor") %&gt;' /&gt;
                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;/asp:Table&gt;&lt;br /&gt;&lt;label class="clsTableLabel"&gt;HR: Required &lt;/label&gt;&lt;br /&gt;&lt;br /&gt;&lt;asp:Table CssClass="cssTable_HR_Required" ID="INSERT_Table_HR_Required" runat="server"
                CellPadding="5" GridLines="both" HorizontalAlign="Center"&gt;

                &lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
									StartDate:
               

               
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                        &lt;asp:Calendar ID="INSERT_Calendar_StartDate_ID" runat="server" SelectedDate='&lt;%# Bind("StartDate") %&gt;'&gt;
                        &lt;/asp:Calendar&gt;
                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
						First Name:
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                        &lt;asp:TextBox ID="INSERT_txt_FirstName" runat="server" Text='&lt;%# Bind("FirstName") %&gt;' /&gt;
                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
									Middle Name:
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                        &lt;asp:TextBox ID="txt_MiddleName" runat="server" Text='&lt;%# Bind("MiddleName") %&gt;' /&gt;
                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
									Last Name:
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                        &lt;asp:TextBox ID="INSERT_txt_LastName" runat="server" Text='&lt;%# Bind("LastName") %&gt;' /&gt;
                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
									Supervisor Name (T9_FK):
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                        &lt;%--&lt;asp:Label ID="lbl_Supervisor_T9_FK" runat="server" Text='&lt;%# Bind("Supervisor_T9_FK") %&gt;' /&gt;--%&gt;
                        &lt;asp:DropDownList ID="INSERT_dd_Supervisor_T9_FK" runat="server" DataValueField="Supervisor_T9_FK"
                            OnDataBound="dd_Supervisor_T9_FK_DataBound"
                            DataSourceID="SqlDataSource_DropDown_Supervisor_T9_FK" DataTextField="Name" SelectedValue='&lt;%# Bind("Supervisor_T9_FK") %&gt;' /&gt;

                        &lt;asp:SqlDataSource ID="SqlDataSource_DropDown_Supervisor_T9_FK" runat="server" ConnectionString="&lt;%$ ConnectionStrings:DB2_CRMConnectionString1 %&gt;"
                            SelectCommand="SELECT T9_PK as [Supervisor_T9_FK], Name      
										FROM [DB2_CRM].[dbo].[T9_CCWNC_Employees]"&gt;
                        &lt;/asp:SqlDataSource&gt;

                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
									CareManager?:
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                        &lt;asp:DropDownList ID="INSERT_dd_CareManager_e00" runat="server" DataValueField="CareManager_e00"
                            DataSourceID="SqlDataSource_DropDown_CareManager_e00" DataTextField="EnumDescription"
                            SelectedValue='&lt;%# Bind("CareManager_e00") %&gt;' /&gt;

                        &lt;asp:SqlDataSource ID="SqlDataSource_DropDown_CareManager_e00" runat="server" ConnectionString="&lt;%$ ConnectionStrings:DB2_CRMConnectionString1 %&gt;"
                            SelectCommand="SELECT [EnumValue] AS CareManager_e00 ,[EnumDescription]      
												FROM [DB2_CRM].[dbo].[Enum]
												WHERE [EnumNameSpace_FK]=0"&gt;
                        &lt;/asp:SqlDataSource&gt;

                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
									Include this employee in the list?:
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                        &lt;asp:DropDownList ID="INSERT_dd_Include_e00" runat="server" DataValueField="Include_e00"
                            DataSourceID="SqlDataSource_DropDown_Include_e00" DataTextField="EnumDescription"
                            SelectedValue='&lt;%# Bind("Include_e00") %&gt;' /&gt;

                        &lt;asp:SqlDataSource ID="SqlDataSource_DropDown_Include_e00" runat="server" ConnectionString="&lt;%$ ConnectionStrings:DB2_CRMConnectionString1 %&gt;"
                            SelectCommand="SELECT [EnumValue] AS Include_e00 ,[EnumDescription]      
												FROM [DB2_CRM].[dbo].[Enum]
												WHERE [EnumNameSpace_FK]=0"&gt;
                        &lt;/asp:SqlDataSource&gt;

                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
										N.C. Drivers License Number:
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;

                        &lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                            &lt;asp:TextBox ID="txt_NCDriversLicenseNumber" runat="server" Text='&lt;%# Bind("NCDriversLicenseNumber") %&gt;' /&gt;
                        &lt;/asp:TableCell&gt;

                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;asp:TableRow&gt;

                    &lt;asp:TableCell CssClass="cssTableCell_FieldName"&gt;
										SSN (Last4):
                    &lt;/asp:TableCell&gt;&lt;asp:TableCell CssClass="cssTableCell_data"&gt;

                        &lt;asp:TableCell CssClass="cssTableCell_data"&gt;
                            &lt;asp:TextBox ID="txt_SSNLast4" runat="server" Text='&lt;%# Bind("SSNLast4") %&gt;' /&gt;
                        &lt;/asp:TableCell&gt;

                    &lt;/asp:TableCell&gt;&lt;/asp:TableRow&gt;&lt;/asp:Table&gt;
                    
                    

 
        &lt;asp:LinkButton ID="INSERT_LinkButton_4_Cancel" runat="server" CausesValidation="False"
            CommandName="Cancel" Text="Cancel" /&gt;
    &lt;/InsertItemTemplate&gt;    
    
    
    
.....................................................................................

    
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Diagnostics;
using System.Collections;  //for DictionaryEntry
using System.Globalization; // for date/time: CultureInfo

namespace WA0005_NewHire.ForNewHireRoles
{
    public partial class NewHire_DetailsForm : System.Web.UI.Page
    {



        string sMessageIfTheRequiredFieldsAreNotValid = "";
    
           private bool fn_bTheRequiredFieldsAreValid()
        {
            bool bx = false;
            int iProblemCounter = 0;

            try
            {
                //string[] formats = { "MM/dd/yyyy" };
                //DateTime parsedDateTime = DateTime.TryParseExact("1/1/0001", formats, new CultureInfo("en-US"),DateTimeStyles.None, out parsedDateTime);

                System.Web.UI.WebControls.Calendar Calendar_StartDate = (System.Web.UI.WebControls.Calendar)fv_NewHire_DetailsForm.FindControl("INSERT_Calendar_StartDate_ID");
                if ((DateTime)Calendar_StartDate.SelectedDate != Convert.ToDateTime("1/1/0001"))
                {
                    iProblemCounter = iProblemCounter + 0;
                }
                else
                {
                    iProblemCounter = iProblemCounter + 1;
                    BulletedList_Message.Items.Add(iProblemCounter.ToString() + "] You Must select a start date.");
                }
                TextBox txt_FirstName = (TextBox)fv_NewHire_DetailsForm.FindControl("INSERT_txt_FirstName");
                if (txt_FirstName.Text.Length &gt; 2)
                {
                    iProblemCounter = iProblemCounter + 0;
                }
                else
                {
                    iProblemCounter = iProblemCounter + 1;
                    BulletedList_Message.Items.Add(iProblemCounter.ToString() + "] Missing First Name.");
                }
                TextBox txt_LastName = (TextBox)fv_NewHire_DetailsForm.FindControl("INSERT_txt_LastName");
                if (txt_LastName.Text.Length &gt; 2)
                {
                    iProblemCounter = iProblemCounter + 0;
                }
                else
                {
                    iProblemCounter = iProblemCounter + 1;
                    BulletedList_Message.Items.Add(iProblemCounter.ToString() + "] Missing Last Name.");
                }


                DropDownList dd_Supervisor_T9_FK = (DropDownList)fv_NewHire_DetailsForm.FindControl("INSERT_dd_Supervisor_T9_FK");
                //if (dd_Supervisor_T9_FK.Text != "--- select Supervisor ---")
                if (dd_Supervisor_T9_FK.SelectedIndex != 0)
                {
                    iProblemCounter = iProblemCounter + 0;
                }
                else
                {
                    iProblemCounter = iProblemCounter + 1;
                    BulletedList_Message.Items.Add(iProblemCounter.ToString() + "] You must specify the Supervisor of the New Hire.");
                }

                DropDownList dd_CareManager_e00 = (DropDownList)fv_NewHire_DetailsForm.FindControl("INSERT_dd_CareManager_e00");
                //if (dd_Supervisor_T9_FK.Text != "--- select Supervisor ---")
                if (dd_CareManager_e00.SelectedIndex != 0)
                {
                    iProblemCounter = iProblemCounter + 0;
                }
                else
                {
                    iProblemCounter = iProblemCounter + 1;
                    BulletedList_Message.Items.Add(iProblemCounter.ToString() + "] You must indicate whether the New Hire is a Care Manager");
                }

                DropDownList dd_Include_e00 = (DropDownList)fv_NewHire_DetailsForm.FindControl("INSERT_dd_Include_e00");
                //if (dd_Supervisor_T9_FK.Text != "--- select Supervisor ---")
                if (dd_Include_e00.SelectedIndex != 0)
                {
                    iProblemCounter = iProblemCounter + 0;
                }
                else
                {
                    iProblemCounter = iProblemCounter + 1;
                    BulletedList_Message.Items.Add(iProblemCounter.ToString() + "] You must indicate whether to include the New Hire on the list");
                }







                if (iProblemCounter == 0)
                {
                    bx = true;
                }

            }
            catch (Exception e)
            {

                Debug.WriteLine("fn_ReturnFirstXLettersOfString - An error occurred! Better check the code!" + e.ToString());
            }

            return bx;
        }


       protected void fv_NewHire_DetailsForm_OnItemInserting(Object sender, FormViewInsertEventArgs e)
        {
            bool bRequiredFieldsAreValid;
            bRequiredFieldsAreValid = fn_bTheRequiredFieldsAreValid();

            if (bRequiredFieldsAreValid)
            {
                System.Web.UI.WebControls.Calendar Calendar_StartDate = (System.Web.UI.WebControls.Calendar)fv_NewHire_DetailsForm.FindControl("INSERT_Calendar_StartDate_ID");
                System.TimeSpan NinetyDays = new System.TimeSpan(90, 0, 0, 0);
                e.Values["NinetyDayReviewDate"] = Calendar_StartDate.SelectedDate.Add(NinetyDays);


                int iX = 0;
                foreach (DictionaryEntry entry in e.Values)
                {

                    Debug.Print("Counter: " + iX.ToString() + "====================================");
                    Debug.Print("entry.Key: " + entry.Key.ToString());
                    Debug.Print("entry.Value: " + entry.Value.ToString());

                }
            }
            else
            {
                e.Cancel = true;
            }




        }




        protected void fv_NewHire_DetailsForm_ItemCommand(object sender, FormViewCommandEventArgs e)
        {


            switch (e.CommandName)
            {
                case "Edit":
                    Session["Mode"] = "Edit";
                    Debug.WriteLine("Edit - Mode just clicked");
                    break;
                case "New":
                    Session["Mode"] = "New";
                    Debug.WriteLine("New - Mode just clicked");
                    break;
                case "Cancel":
                    BulletedList_Message.Items.Clear();
                    Session["Mode"] = "View";
                    Debug.WriteLine("Cancel - Mode just clicked");
                    break;
                case "Update":
                    Session["Mode"] = "View";
                    Debug.WriteLine("Update - Mode just clicked");
                    break;
                case "Insert":
                    Session["Mode"] = "View";
                    Debug.WriteLine("Insert - Mode just clicked");
                    break;
                case "Delete":
                    Session["Mode"] = "View";
                    Debug.WriteLine("Delete - Mode just clicked");
                    break;
                default:
                    Session["Mode"] = "Unknown - Mode just clicked";
                    Debug.WriteLine("e.CommandName: " + e.CommandName);
                    break;
            }




        }
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ASPNET_FORMVIEW</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>DropDown_in_GridView_Example_1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ASPNET_FORMVIEW</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>DropDown_in_GridView_Example_1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;!--

From: http://www.codeguru.com/vb/controls/vb_listview/article.php/c16137/DataBinding-a-DropDownList-in-a-FormView.htm

This example does CRUD on the Orders Table, but has a drop-down that gets a list of values from the Customers table
	in the NorthWind Database
	
By using 'Bind' rather than 'eval' in the 'SelectedValue' of the DropDown, no Code-behind is required. 		

--&gt;
&lt;asp:DropDownList ID="CustomerIDDropDownList" runat="server"
  DataValueField='CustomerID' DataSourceID="CustomerIDDataSource" 
  DataTextField="CompanyName" 
  SelectedValue='&lt;%# Eval("CustomerID") %&gt;'
/&gt;

&lt;!--
If you use Eval as shown above then you will have to set the value when it changes in the FormViewIttemUpdate event (see Listing 1). 
If you switch Eval to Bind for the SelectedValue then no code-behind is required.

If you want to set the selected value for write, programmatically, implement the ItemUpdating event handler.

Listing 1:
--&gt;
Protected Sub FormView1_ItemUpdating(ByVal sender As Object, _
  ByVal e As System.Web.UI.WebControls.FormViewUpdateEventArgs) _
  Handles FormView1.ItemUpdating
 
  Dim control As DropDownList = FormView1.FindControl("CustomerIDDropDownList")
  e.NewValues("CustomerID") = control.SelectedValue
 
End Sub
&lt;!--
Use Bind for the DropDownList SelectedValue and the code in Listing 1 is not needed.
If you use Eval then remember that the DropDownList is in a template of the FormView, 
	so you have to get the actual DropDownList by calling FindControl and setting the updated value to the e.NewValues property. 



This uses the Connection string in the Web.config:
--&gt;

&lt;configuration&gt;

....

  &lt;connectionStrings&gt;
    &lt;add name="NorthwindConnectionString1" connectionString="Data Source=SQL-SERVER\DEV;Initial Catalog=Northwind;Integrated Security=True"
      providerName="System.Data.SqlClient" /&gt;
  &lt;/connectionStrings&gt;

....

&lt;/configuration&gt; 

&lt;!--
This is the entire, working Markup:
--&gt;

&lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="junk.aspx.cs" Inherits="WA0005_NewHire.junk" %&gt;

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head runat="server"&gt;
	&lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;form id="form1" runat="server"&gt;
	&lt;div&gt;
		&lt;asp:FormView ID="FormView1" runat="server" DataKeyNames="OrderID" DataSourceID="SqlDataSource1"
			DefaultMode="Edit"&gt;
			&lt;EditItemTemplate&gt;
				OrderID:
				&lt;asp:Label ID="OrderIDLabel1" runat="server" Text='&lt;%# Eval("OrderID") %&gt;' /&gt;
				&lt;br /&gt;

				CustomerID:

				&lt;asp:DropDownList 
					ID="CustomerIDDropDownList" 
					runat="server" 
					DataValueField='CustomerID'
					DataSourceID="CustomerDataSource" 
					DataTextField="CompanyName" 
					SelectedValue='&lt;%# Bind("CustomerID") %&gt;' /&gt;

				&lt;asp:SqlDataSource 
					ID="CustomerDataSource" 
					runat="server" 
					ConnectionString="&lt;%$ ConnectionStrings:NorthwindConnectionString1 %&gt;"
					SelectCommand="SELECT [CustomerID], [CompanyName] FROM [Customers]"&gt;
				&lt;/asp:SqlDataSource&gt;

				&lt;br /&gt;
				EmployeeID:
				&lt;asp:TextBox ID="EmployeeIDTextBox" runat="server" Text='&lt;%# Bind("EmployeeID") %&gt;' /&gt;
				&lt;br /&gt;
				OrderDate:
				&lt;asp:TextBox ID="OrderDateTextBox" runat="server" Text='&lt;%# Bind("OrderDate") %&gt;' /&gt;
				&lt;br /&gt;
				RequiredDate:
				&lt;asp:TextBox ID="RequiredDateTextBox" runat="server" Text='&lt;%# Bind("RequiredDate") %&gt;' /&gt;
				&lt;br /&gt;
				ShippedDate:
				&lt;asp:TextBox ID="ShippedDateTextBox" runat="server" Text='&lt;%# Bind("ShippedDate") %&gt;' /&gt;
				&lt;br /&gt;
				ShipVia:
				&lt;asp:TextBox ID="ShipViaTextBox" runat="server" Text='&lt;%# Bind("ShipVia") %&gt;' /&gt;
				&lt;br /&gt;
				Freight:
				&lt;asp:TextBox ID="FreightTextBox" runat="server" Text='&lt;%# Bind("Freight") %&gt;' /&gt;
				&lt;br /&gt;
				ShipName:
				&lt;asp:TextBox ID="ShipNameTextBox" runat="server" Text='&lt;%# Bind("ShipName") %&gt;' /&gt;
				&lt;br /&gt;
				ShipAddress:
				&lt;asp:TextBox ID="ShipAddressTextBox" runat="server" Text='&lt;%# Bind("ShipAddress") %&gt;' /&gt;
				&lt;br /&gt;
				ShipCity:
				&lt;asp:TextBox ID="ShipCityTextBox" runat="server" Text='&lt;%# Bind("ShipCity") %&gt;' /&gt;
				&lt;br /&gt;
				ShipRegion:
				&lt;asp:TextBox ID="ShipRegionTextBox" runat="server" Text='&lt;%# Bind("ShipRegion") %&gt;' /&gt;
				&lt;br /&gt;
				ShipPostalCode:
				&lt;asp:TextBox ID="ShipPostalCodeTextBox" runat="server" Text='&lt;%# Bind("ShipPostalCode") %&gt;' /&gt;
				&lt;br /&gt;
				ShipCountry:
				&lt;asp:TextBox ID="ShipCountryTextBox" runat="server" Text='&lt;%# Bind("ShipCountry") %&gt;' /&gt;
				&lt;br /&gt;
				&lt;asp:LinkButton ID="UpdateButton" runat="server" CausesValidation="True" CommandName="Update"
					Text="Update" /&gt;
				&lt;asp:LinkButton ID="UpdateCancelButton" runat="server" CausesValidation="False" CommandName="Cancel"
					Text="Cancel" /&gt;
			&lt;/EditItemTemplate&gt;
			&lt;InsertItemTemplate&gt;
				CustomerID:
				&lt;asp:TextBox ID="CustomerIDTextBox" runat="server" Text='&lt;%# Bind("CustomerID") %&gt;' /&gt;
				&lt;br /&gt;
				EmployeeID:
				&lt;asp:TextBox ID="EmployeeIDTextBox" runat="server" Text='&lt;%# Bind("EmployeeID") %&gt;' /&gt;
				&lt;br /&gt;
				OrderDate:
				&lt;asp:TextBox ID="OrderDateTextBox" runat="server" Text='&lt;%# Bind("OrderDate") %&gt;' /&gt;
				&lt;br /&gt;
				RequiredDate:
				&lt;asp:TextBox ID="RequiredDateTextBox" runat="server" Text='&lt;%# Bind("RequiredDate") %&gt;' /&gt;
				&lt;br /&gt;
				ShippedDate:
				&lt;asp:TextBox ID="ShippedDateTextBox" runat="server" Text='&lt;%# Bind("ShippedDate") %&gt;' /&gt;
				&lt;br /&gt;
				ShipVia:
				&lt;asp:TextBox ID="ShipViaTextBox" runat="server" Text='&lt;%# Bind("ShipVia") %&gt;' /&gt;
				&lt;br /&gt;
				Freight:
				&lt;asp:TextBox ID="FreightTextBox" runat="server" Text='&lt;%# Bind("Freight") %&gt;' /&gt;
				&lt;br /&gt;
				ShipName:
				&lt;asp:TextBox ID="ShipNameTextBox" runat="server" Text='&lt;%# Bind("ShipName") %&gt;' /&gt;
				&lt;br /&gt;
				ShipAddress:
				&lt;asp:TextBox ID="ShipAddressTextBox" runat="server" Text='&lt;%# Bind("ShipAddress") %&gt;' /&gt;
				&lt;br /&gt;
				ShipCity:
				&lt;asp:TextBox ID="ShipCityTextBox" runat="server" Text='&lt;%# Bind("ShipCity") %&gt;' /&gt;
				&lt;br /&gt;
				ShipRegion:
				&lt;asp:TextBox ID="ShipRegionTextBox" runat="server" Text='&lt;%# Bind("ShipRegion") %&gt;' /&gt;
				&lt;br /&gt;
				ShipPostalCode:
				&lt;asp:TextBox ID="ShipPostalCodeTextBox" runat="server" Text='&lt;%# Bind("ShipPostalCode") %&gt;' /&gt;
				&lt;br /&gt;
				ShipCountry:
				&lt;asp:TextBox ID="ShipCountryTextBox" runat="server" Text='&lt;%# Bind("ShipCountry") %&gt;' /&gt;
				&lt;br /&gt;
				&lt;asp:LinkButton ID="InsertButton" runat="server" CausesValidation="True" CommandName="Insert"
					Text="Insert" /&gt;
				&lt;asp:LinkButton ID="InsertCancelButton" runat="server" CausesValidation="False" CommandName="Cancel"
					Text="Cancel" /&gt;
			&lt;/InsertItemTemplate&gt;
			&lt;ItemTemplate&gt;
				OrderID:
				&lt;asp:Label ID="OrderIDLabel" runat="server" Text='&lt;%# Eval("OrderID") %&gt;' /&gt;
				&lt;br /&gt;
				CustomerID:
				&lt;asp:Label ID="CustomerIDLabel" runat="server" Text='&lt;%# Bind("CustomerID") %&gt;' /&gt;
				&lt;br /&gt;
				EmployeeID:
				&lt;asp:Label ID="EmployeeIDLabel" runat="server" Text='&lt;%# Bind("EmployeeID") %&gt;' /&gt;
				&lt;br /&gt;
				OrderDate:
				&lt;asp:Label ID="OrderDateLabel" runat="server" Text='&lt;%# Bind("OrderDate") %&gt;' /&gt;
				&lt;br /&gt;
				RequiredDate:
				&lt;asp:Label ID="RequiredDateLabel" runat="server" Text='&lt;%# Bind("RequiredDate") %&gt;' /&gt;
				&lt;br /&gt;
				ShippedDate:
				&lt;asp:Label ID="ShippedDateLabel" runat="server" Text='&lt;%# Bind("ShippedDate") %&gt;' /&gt;
				&lt;br /&gt;
				ShipVia:
				&lt;asp:Label ID="ShipViaLabel" runat="server" Text='&lt;%# Bind("ShipVia") %&gt;' /&gt;
				&lt;br /&gt;
				Freight:
				&lt;asp:Label ID="FreightLabel" runat="server" Text='&lt;%# Bind("Freight") %&gt;' /&gt;
				&lt;br /&gt;
				ShipName:
				&lt;asp:Label ID="ShipNameLabel" runat="server" Text='&lt;%# Bind("ShipName") %&gt;' /&gt;
				&lt;br /&gt;
				ShipAddress:
				&lt;asp:Label ID="ShipAddressLabel" runat="server" Text='&lt;%# Bind("ShipAddress") %&gt;' /&gt;
				&lt;br /&gt;
				ShipCity:
				&lt;asp:Label ID="ShipCityLabel" runat="server" Text='&lt;%# Bind("ShipCity") %&gt;' /&gt;
				&lt;br /&gt;
				ShipRegion:
				&lt;asp:Label ID="ShipRegionLabel" runat="server" Text='&lt;%# Bind("ShipRegion") %&gt;' /&gt;
				&lt;br /&gt;
				ShipPostalCode:
				&lt;asp:Label ID="ShipPostalCodeLabel" runat="server" Text='&lt;%# Bind("ShipPostalCode") %&gt;' /&gt;
				&lt;br /&gt;
				ShipCountry:
				&lt;asp:Label ID="ShipCountryLabel" runat="server" Text='&lt;%# Bind("ShipCountry") %&gt;' /&gt;
				&lt;br /&gt;
				&lt;asp:LinkButton ID="EditButton" runat="server" CausesValidation="False" CommandName="Edit"
					Text="Edit" /&gt;
				&lt;asp:LinkButton ID="DeleteButton" runat="server" CausesValidation="False" CommandName="Delete"
					Text="Delete" /&gt;
				&lt;asp:LinkButton ID="NewButton" runat="server" CausesValidation="False" CommandName="New"
					Text="New" /&gt;
			&lt;/ItemTemplate&gt;
		&lt;/asp:FormView&gt;
		&lt;asp:SqlDataSource ID="SqlDataSource1" runat="server" ConnectionString="&lt;%$ ConnectionStrings:NorthwindConnectionString1 %&gt;"
			SelectCommand="SELECT * FROM [Orders]" DeleteCommand="DELETE FROM [Orders] WHERE [OrderID] = @OrderID"
			InsertCommand="INSERT INTO [Orders] ([CustomerID], 
											[EmployeeID], 
											[OrderDate], 
											[RequiredDate], 
											[ShippedDate], 
											[ShipVia], 
											[Freight], 
											[ShipName], 
											[ShipAddress], 
											[ShipCity], 
											[ShipRegion], 
											[ShipPostalCode], 
											[ShipCountry]) 
										VALUES (@CustomerID, 
												@EmployeeID, 
												@OrderDate, 
												@RequiredDate, 
												@ShippedDate, 
												@ShipVia, 
												@Freight, 
												@ShipName, 
												@ShipAddress, 
												@ShipCity, 
												@ShipRegion, 
												@ShipPostalCode, 
												@ShipCountry)" UpdateCommand="UPDATE [Orders] SET [CustomerID] = @CustomerID, 
										[EmployeeID] = @EmployeeID, 
										[OrderDate] = @OrderDate,
										[RequiredDate] = @RequiredDate, 
										[ShippedDate] = @ShippedDate, 
										[ShipVia] = @ShipVia, 
										[Freight] = @Freight, 
										[ShipName] = @ShipName, 
										[ShipAddress] = @ShipAddress, 
										[ShipCity] = @ShipCity,
										[ShipRegion] = @ShipRegion, 
										[ShipPostalCode] = @ShipPostalCode, 
										[ShipCountry] = @ShipCountry
								WHERE [OrderID] = @OrderID"&gt;
			&lt;DeleteParameters&gt;
				&lt;asp:Parameter Name="OrderID" Type="Int32" /&gt;
			&lt;/DeleteParameters&gt;
			&lt;UpdateParameters&gt;
				&lt;asp:Parameter Name="CustomerID" Type="String" /&gt;
				&lt;asp:Parameter Name="EmployeeID" Type="Int32" /&gt;
				&lt;asp:Parameter Name="OrderDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="RequiredDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="ShippedDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="ShipVia" Type="Int32" /&gt;
				&lt;asp:Parameter Name="Freight" Type="Decimal" /&gt;
				&lt;asp:Parameter Name="ShipName" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipAddress" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipCity" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipRegion" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipPostalCode" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipCountry" Type="String" /&gt;
				&lt;asp:Parameter Name="OrderID" Type="Int32" /&gt;
			&lt;/UpdateParameters&gt;
			&lt;InsertParameters&gt;
				&lt;asp:Parameter Name="CustomerID" Type="String" /&gt;
				&lt;asp:Parameter Name="EmployeeID" Type="Int32" /&gt;
				&lt;asp:Parameter Name="OrderDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="RequiredDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="ShippedDate" Type="DateTime" /&gt;
				&lt;asp:Parameter Name="ShipVia" Type="Int32" /&gt;
				&lt;asp:Parameter Name="Freight" Type="Decimal" /&gt;
				&lt;asp:Parameter Name="ShipName" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipAddress" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipCity" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipRegion" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipPostalCode" Type="String" /&gt;
				&lt;asp:Parameter Name="ShipCountry" Type="String" /&gt;
			&lt;/InsertParameters&gt;
		&lt;/asp:SqlDataSource&gt;
	&lt;/div&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ASPNET_FORMVIEW</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>Mode_Check_to_see_which_one_the_form_is_in</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ASPNET_FORMVIEW</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>Mode_Check_to_see_which_one_the_form_is_in</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;!--

 I did this in the New Hire Web app and it worked, but there is another option, see below

--&gt;

      protected void Page_PreRenderComplete(object sender, EventArgs e)
        {


            switch (fv_NewHire_DetailsForm.CurrentMode)
            {
                case (FormViewMode.Edit):
                    DisableControlsIn_Edit_Mode_BasedOnUsersMembershipInSecurityGroup();
                    break;
                case (FormViewMode.Insert):
                    DisableControlsIn_New_Mode_BasedOnUsersMembershipInSecurityGroup();
                    break;
                case (FormViewMode.ReadOnly):
                    DisableControlsIn_ItemView_Mode_BasedOnUsersMembershipInSecurityGroup();
                    break;
                default:
                    //if (Session["Mode"] == "Insert")
                    //{// The first time it comes through this method, after inserting, the Insert controls are still present on the page 
                    //    Session["Mode"] = "View";
                    //    Debug.WriteLine("Page_PreRenderComplete: The Session['Mode'] was 'Insert', it was flipped to 'View'");
                    //}
                    //else
                    //{
                    Debug.WriteLine("Page_PreRenderComplete: The Session['Mode'] was Neither: Edit, New, View, nor INSERT");
                    //}

                    break;
            }



        }
&lt;!--
from: http://codeverge.com/asp.net.presentation-controls/in-what-event-do-i-check-for-fo/456043
You can do this in DataBound() event of your FormView.  For example:
--&gt;

    protected void FormView1_DataBound(object sender, EventArgs e)
    {
        if (FormView1.CurrentMode == FormViewMode.Edit || FormView1.CurrentMode == FormViewMode.Insert)
        {
            ...
        }
    }
&lt;!--
Note that I'm using the CurrentMode instead of DefaultMode.  Also, use the logical-OR (||) instead of bit-wise OR.  
Although the latter works in this case, you won't get the short-circuit behavior of logical-OR.

--&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ASPNET_FORMVIEW</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>ModeChanged_EVENT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ASPNET_FORMVIEW</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>ModeChanged_EVENT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.formview.modechanged%28v=vs.100%29.aspx

&lt;%@ Page language="C#" %&gt;

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;script runat="server"&gt;

  void EmployeeFormView_ModeChanged(Object sender, EventArgs e)
  {

    // Display the current mode in the header row.
    switch (EmployeeFormView.CurrentMode)
    {
      case FormViewMode.Edit:
        EmployeeFormView.HeaderText = "Edit Mode";
        EmployeeFormView.HeaderStyle.BackColor = System.Drawing.Color.Red;
        break;
      case FormViewMode.ReadOnly:
        EmployeeFormView.HeaderText = "Read-Only Mode";
        EmployeeFormView.HeaderStyle.BackColor = System.Drawing.Color.Green;
        break;
      default:
        EmployeeFormView.HeaderText = "Unsupported mode.";
        EmployeeFormView.HeaderStyle.BackColor = System.Drawing.Color.Yellow;
        break;
    }

  }

&lt;/script&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml" &gt;
  &lt;head runat="server"&gt;
    &lt;title&gt;FormView ModeChanged Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id="form1" runat="server"&gt;

      &lt;h3&gt;FormView ModeChanged Example&lt;/h3&gt;

      &lt;asp:formview id="EmployeeFormView"
        datasourceid="EmployeeSource"
        allowpaging="true"
        datakeynames="EmployeeID"
        headertext="Read-Only Mode" 
        headerstyle-backcolor="Green"
        emptydatatext="No employees found."
        onmodechanged="EmployeeFormView_ModeChanged"  
        runat="server"&gt;

        &lt;itemtemplate&gt;
          &lt;table&gt;
            &lt;tr&gt;
              &lt;td rowspan="6"&gt;
                &lt;asp:image id="EmployeeImage"
                  imageurl='&lt;%# Eval("PhotoPath") %&gt;'
                  alternatetext='&lt;%# Eval("LastName") %&gt;' 
                  runat="server"/&gt;
              &lt;/td&gt;
              &lt;td colspan="2"&gt;
                  &amp;nbsp; 
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;Name:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;%# Eval("FirstName") %&gt; &lt;%# Eval("LastName") %&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;Title:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;%# Eval("Title") %&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;Hire Date:&lt;/b&gt;                 
              &lt;/td&gt;
              &lt;td&gt;
                &lt;%# Eval("HireDate","{0:d}") %&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr style="height:150" valign="top"&gt;
              &lt;td&gt;
                &lt;b&gt;Address:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;%# Eval("Address") %&gt;&lt;br/&gt;
                &lt;%# Eval("City") %&gt; &lt;%# Eval("Region") %&gt;
                &lt;%# Eval("PostalCode") %&gt;&lt;br/&gt;
                &lt;%# Eval("Country") %&gt;   
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td colspan="2"&gt;
                &lt;asp:linkbutton id="Edit"
                  text="Edit"
                  commandname="Edit"
                  runat="server"/&gt; 
              &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/table&gt;       
        &lt;/itemtemplate&gt;
        &lt;edititemtemplate&gt;
          &lt;table&gt;
            &lt;tr&gt;
              &lt;td rowspan="6"&gt;
                &lt;asp:image id="EmployeeEditImage"
                  imageurl='&lt;%# Eval("PhotoPath") %&gt;'
                  alternatetext='&lt;%# Eval("LastName") %&gt;' 
                  runat="server"/&gt;
              &lt;/td&gt;
              &lt;td colspan="2"&gt;
                  &amp;nbsp; 
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;&lt;asp:Label runat="server" 
                  AssociatedControlID="FirstNameUpdateTextBox" 
                  Text="Name" /&gt;:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;asp:textbox id="FirstNameUpdateTextBox"
                  text='&lt;%# Bind("FirstName") %&gt;'
                  accesskey="n" tabindex="1" runat="server"/&gt;
                &lt;asp:textbox id="LastNameUpdateTextBox"
                  text='&lt;%# Bind("LastName") %&gt;'
                  accesskey="l" tabindex="2" runat="server"/&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;&lt;asp:Label runat="server" 
                  AssociatedControlID="TitleUpdateTextBox" 
                  Text="Title" /&gt;:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;asp:textbox id="TitleUpdateTextBox"
                  text='&lt;%# Bind("Title") %&gt;'
                  accesskey="t" tabindex="3" runat="server"/&gt; 
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;b&gt;&lt;asp:Label runat="server" 
                  AssociatedControlID="HireDateUpdateTextBox" 
                  Text="Hire Date" /&gt;:&lt;/b&gt;
              &lt;td&gt;
                &lt;asp:textbox id="HireDateUpdateTextBox"
                  text='&lt;%# Bind("HireDate", "{0:d}") %&gt;'
                  accesskey="h" tabindex="4" runat="server" /&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr style="height:150" valign="top"&gt;
              &lt;td&gt;
                &lt;b&gt;&lt;asp:Label runat="server" 
                  AssociatedControlID="AddressUpdateTextBox" 
                  Text="Address" /&gt;:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;asp:textbox id="AddressUpdateTextBox"
                  text='&lt;%# Bind("Address") %&gt;'
                  accesskey="a" tabindex="5" runat="server"/&gt;
                &lt;br/&gt;
                &lt;asp:textbox id="CityUpdateTextBox"
                  text='&lt;%# Bind("City") %&gt;'
                  accesskey="c" tabindex="6" runat="server"/&gt; 
                &lt;asp:textbox id="RegionUpdateTextBox"
                  text='&lt;%# Bind("Region") %&gt;'
                  width="40"
                  accesskey="r" tabindex="7" runat="server"/&gt;
                &lt;asp:textbox id="PostalCodeUpdateTextBox"
                  text='&lt;%# Bind("PostalCode") %&gt;'
                  width="60"
                  accesskey="p" tabindex="8" runat="server"/&gt;
                &lt;br/&gt;
                &lt;asp:textbox id="CountryUpdateTextBox"
                  text='&lt;%# Bind("Country") %&gt;'
                  accesskey="u" tabindex="9" runat="server"/&gt; 
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td colspan="2"&gt;
                &lt;asp:linkbutton id="UpdateButton"
                  text="Update" tabindex="10" 
                  commandname="Update"
                  runat="server"/&gt;
                &lt;asp:linkbutton id="CancelButton"
                  text="Cancel" tabindex="11" 
                  commandname="Cancel"
                  runat="server"/&gt; 
              &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/table&gt;       
        &lt;/edititemtemplate&gt;

      &lt;/asp:formview&gt;

      &lt;!-- This example uses Microsoft SQL Server and connects  --&gt;
      &lt;!-- to the Northwind sample database. Use an ASP.NET     --&gt;
      &lt;!-- expression to retrieve the connection string value   --&gt;
      &lt;!-- from the Web.config file.                            --&gt;
      &lt;asp:sqldatasource id="EmployeeSource"
        selectcommand="Select [EmployeeID], [LastName], [FirstName], [Title], [Address], [City], [Region], [PostalCode], [Country], [HireDate], [PhotoPath] From [Employees]"
        updatecommand="Update [Employees] Set [LastName]=@LastName, [FirstName]=@FirstName, [Title]=@Title, [Address]=@Address, [City]=@City, [Region]=@Region, [PostalCode]=@PostalCode, [Country]=@Country Where [EmployeeID]=@EmployeeID"
        connectionstring="&lt;%$ ConnectionStrings:NorthWindConnectionString%&gt;" 
        runat="server"/&gt;

    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ASPNET_FORMVIEW</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>ModeChanging_EVENT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ASPNET_FORMVIEW</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>ModeChanging_EVENT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>From: http://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.formview.modechanging%28v=vs.100%29.aspx

&lt;%@ Page language="C#" %&gt;

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;script runat="server"&gt;

  void EmployeeFormView_ModeChanging(Object sender, FormViewModeEventArgs e)
  {

    // Use the NewMode property to determine the mode to which the 
    // FormView control is transitioning.
    switch (e.NewMode)
    {
      case FormViewMode.Edit:
        // Hide the pager row and clear the Label control
        // when transitioning to edit mode.
        EmployeeFormView.AllowPaging = false;
        MessageLabel.Text = "";
        break;
      case FormViewMode.ReadOnly:
        // Display the pager row and confirmation message
        // when transitioning to edit mode.
        EmployeeFormView.AllowPaging = true;
        if (e.CancelingEdit)
        {
          MessageLabel.Text = "Update canceled.";
        }
        else
        {
          MessageLabel.Text = "Update completed.";
        }
        break;
      case FormViewMode.Insert:
        // Cancel the mode change if the FormView
        // control attempts to transition to insert 
        // mode.
        e.Cancel = true;
        break;
      default:
        MessageLabel.Text = "Unsupported mode.";
        break;
    }

  }

&lt;/script&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml" &gt;
  &lt;head runat="server"&gt;
    &lt;title&gt;FormViewModeEventArgs Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id="form1" runat="server"&gt;

      &lt;h3&gt;FormViewModeEventArgs Example&lt;/h3&gt;

      &lt;asp:formview id="EmployeeFormView"
        datasourceid="EmployeeSource"
        allowpaging="true"
        datakeynames="EmployeeID"
        emptydatatext="No employees found."
        onmodechanging="EmployeeFormView_ModeChanging"  
        runat="server"&gt;

        &lt;itemtemplate&gt;
          &lt;table&gt;
            &lt;tr&gt;
              &lt;td rowspan="6"&gt;
                &lt;asp:image id="EmployeeImage"
                  imageurl='&lt;%# Eval("PhotoPath") %&gt;'
                  alternatetext='&lt;%# Eval("LastName") %&gt;' 
                  runat="server"/&gt;
              &lt;/td&gt;
              &lt;td colspan="2"&gt;
                  &amp;nbsp; 
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;Name:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;%# Eval("FirstName") %&gt; &lt;%# Eval("LastName") %&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;Title:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;%# Eval("Title") %&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;Hire Date:&lt;/b&gt;                 
              &lt;/td&gt;
              &lt;td&gt;
                &lt;%# Eval("HireDate","{0:d}") %&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr style="height:150" valign="top"&gt;
              &lt;td&gt;
                &lt;b&gt;Address:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;%# Eval("Address") %&gt;&lt;br/&gt;
                &lt;%# Eval("City") %&gt; &lt;%# Eval("Region") %&gt;
                &lt;%# Eval("PostalCode") %&gt;&lt;br/&gt;
                &lt;%# Eval("Country") %&gt;   
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td colspan="2"&gt;
                &lt;asp:linkbutton id="Edit"
                  text="Edit"
                  commandname="Edit"
                  runat="server"/&gt; 
              &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/table&gt;       
        &lt;/itemtemplate&gt;
        &lt;edititemtemplate&gt;
          &lt;table&gt;
            &lt;tr&gt;
              &lt;td rowspan="6"&gt;
                &lt;asp:image id="EmployeeEditImage"
                  imageurl='&lt;%# Eval("PhotoPath") %&gt;'
                  alternatetext='&lt;%# Eval("LastName") %&gt;' 
                  runat="server"/&gt;
              &lt;/td&gt;
              &lt;td colspan="2"&gt;
                  &amp;nbsp; 
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;&lt;asp:Label runat="server" 
                  AssociatedControlID="FirstNameUpdateTextBox" 
                  Text="Name" /&gt;:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;asp:textbox id="FirstNameUpdateTextBox"
                  text='&lt;%# Bind("FirstName") %&gt;'
                  accesskey="n" tabindex="1" runat="server"/&gt;
                &lt;asp:textbox id="LastNameUpdateTextBox"
                  text='&lt;%# Bind("LastName") %&gt;'
                  accesskey="l" tabindex="2" runat="server"/&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;b&gt;&lt;asp:Label runat="server" 
                  AssociatedControlID="TitleUpdateTextBox" 
                  Text="Title" /&gt;:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;asp:textbox id="TitleUpdateTextBox"
                  text='&lt;%# Bind("Title") %&gt;'
                  accesskey="t" tabindex="3" runat="server"/&gt; 
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;b&gt;&lt;asp:Label runat="server" 
                  AssociatedControlID="HireDateUpdateTextBox" 
                  Text="Hire Date" /&gt;:&lt;/b&gt;
              &lt;td&gt;
                &lt;asp:textbox id="HireDateUpdateTextBox"
                  text='&lt;%# Bind("HireDate", "{0:d}") %&gt;'
                  accesskey="h" tabindex="4" runat="server" /&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr style="height:150" valign="top"&gt;
              &lt;td&gt;
                &lt;b&gt;&lt;asp:Label runat="server" 
                  AssociatedControlID="AddressUpdateTextBox" 
                  Text="Address" /&gt;:&lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;asp:textbox id="AddressUpdateTextBox"
                  text='&lt;%# Bind("Address") %&gt;'
                  accesskey="a" tabindex="5" runat="server"/&gt;
                &lt;br/&gt;
                &lt;asp:textbox id="CityUpdateTextBox"
                  text='&lt;%# Bind("City") %&gt;'
                  accesskey="c" tabindex="6" runat="server"/&gt; 
                &lt;asp:textbox id="RegionUpdateTextBox"
                  text='&lt;%# Bind("Region") %&gt;'
                  width="40"
                  accesskey="r" tabindex="7" runat="server"/&gt;
                &lt;asp:textbox id="PostalCodeUpdateTextBox"
                  text='&lt;%# Bind("PostalCode") %&gt;'
                  width="60"
                  accesskey="p" tabindex="8" runat="server"/&gt;
                &lt;br/&gt;
                &lt;asp:textbox id="CountryUpdateTextBox"
                  text='&lt;%# Bind("Country") %&gt;'
                  accesskey="u" tabindex="9" runat="server"/&gt; 
              &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td colspan="2"&gt;
                &lt;asp:linkbutton id="UpdateButton"
                  text="Update" tabindex="10" 
                  commandname="Update"
                  runat="server"/&gt;
                &lt;asp:linkbutton id="CancelButton"
                  text="Cancel" tabindex="11" 
                  commandname="Cancel"
                  runat="server"/&gt; 
              &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/table&gt;       
        &lt;/edititemtemplate&gt;

      &lt;/asp:formview&gt;

      &lt;br/&gt;&lt;br/&gt;

      &lt;asp:label id="MessageLabel"
          forecolor="Red"
          runat="server"/&gt;

      &lt;!-- This example uses Microsoft SQL Server and connects  --&gt;
      &lt;!-- to the Northwind sample database. Use an ASP.NET     --&gt;
      &lt;!-- expression to retrieve the connection string value   --&gt;
      &lt;!-- from the Web.config file.                            --&gt;
      &lt;asp:sqldatasource id="EmployeeSource"
        selectcommand="Select [EmployeeID], [LastName], [FirstName], [Title], [Address], [City], [Region], [PostalCode], [Country], [HireDate], [PhotoPath] From [Employees]"
        updatecommand="Update [Employees] Set [LastName]=@LastName, [FirstName]=@FirstName, [Title]=@Title, [Address]=@Address, [City]=@City, [Region]=@Region, [PostalCode]=@PostalCode, [Country]=@Country Where [EmployeeID]=@EmployeeID"
        connectionstring="&lt;%$ ConnectionStrings:NorthWindConnectionString%&gt;" 
        runat="server"/&gt;

    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ASPNET_FORMVIEW</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>Open_FormView_in_EDIT_or_Insert_MODE_determinedByData</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ASPNET_FORMVIEW</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>Open_FormView_in_EDIT_or_Insert_MODE_determinedByData</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
&lt;!--
http://codeverge.com/asp.net.presentation-controls/open-formview-in-insert-mode/473774

you can set the DefaultMode property of the FormView to Insert.

Another technique could be that if you want to view you can pass in a querystring to the second page that passes the id of item to view. 
if the querystring's omitted then you could place it directly in Insert mode.

in the second webform, in the Page_Load event, you check if the querystring != null. 
If it is you don't change the defaultmode (set to readonly in design time) and if it's null then you can set it there to Insert.
--&gt;
VB:  If Request.QueryString("rsrecno") = Null Then
OR:  If Request.QueryString("rsrecno") = ""



&lt;!-- 
From: http://stackoverflow.com/questions/9978929/open-a-formview-in-insert-mode-only-when-its-empty

You need to wait until the FormView has been databound before doing that check, 
otherwise you'll always get "true" 
(because it does have zero items until you bind it to whatever data source is providing it with said items). 
You could do this in the databound event, preferably:
--&gt;

SomeFormView_Databound (ByVal sender As Object, ByVal e As EventArgs) Handles SomeFormView.DataBound
{
    If SomeFormView.DataItemCount = 0 Then
        SomeFormView.ChangeMode(FormViewMode.Insert)
    Else
        SomeFormView.ChangeMode(FormViewMode.Edit)
    End If
}

&lt;!-- 
from: http://stackoverflow.com/questions/11869130/accesing-controls-of-a-formview-getting-null-references
Although the default mode is set "Edit", the form view won't switch to that mode until the control is DataBound.

There is also the possibility that your data source is not returning any data. 
This will result in the EditItemTemplate being empty which might explain your null reference errors.
Try checking for a Edit_FV.DataItemCount &gt; 0 before switching into Edit mode.
--&gt; 


&lt;!-- 
from:  http://forums.asp.net/t/1519280.aspx?FormView+ChangeMode+is+not+working+

On the other hand someone else said this:
--&gt; 

protected void Page_Load(object sender, EventArgs e)   
    {   
         if(!IsPostBack)
          {
              FormView1.ChangeMode(FormViewMode.Edit); 
              FormView1.DefaultMode = FormViewMode.Edit;
          }  
    }  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ASPNET_GRIDVIEW</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>2_TextBox_Filter_DECLARATIVE_readSqlDataSource_Buttons_With_CodeBehind__CodeBehind</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ASPNET_GRIDVIEW</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>2_TextBox_Filter_DECLARATIVE_readSqlDataSource_Buttons_With_CodeBehind__CodeBehind</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>using System;
using System.Diagnostics;
using System.Web.UI.WebControls;
using gigCommon;

namespace WA006_CM_PatientCoordinator
    {
    public partial class MyListOfCareManagers : System.Web.UI.Page
        {

        #region Page_Events //========================================================================================

        protected void Page_Load(object sender, EventArgs e)
            {

            if (!IsPostBack)
                {

                }
            }

        #endregion  //Page_Events=====================================================================================

        #region General //==========================================================================================

        #endregion //GENERAL==========================================================================================

        #region PositionDropDown_Events //=============================================================================

        #endregion // PositionDropDown_Events //========================================================================

        #region Buttons //=====================================================================================

        public void GridView1_RowCommand(object sender, GridViewCommandEventArgs e)
            {

            // Convert the row index stored in the CommandArgument
            // property to an Integer.
            int index = Convert.ToInt32(e.CommandArgument);

            // 1] Get the CM_T9_PK from the appropriate
            //      cell in the GridView control.
            GridViewRow selectedRow = GridView1_ID.Rows[index];

            //Employee_T9_PK =============================================================
            TableCell cellEmployee_T9_PK = selectedRow.Cells[1];
            string sEmployee_T9_PK = cellEmployee_T9_PK.Text;
            //Set the Session Variable;
            int iX;
            if (int.TryParse(sEmployee_T9_PK, out iX))
                {
                Session["CM_T9_PK"] = iX;
                }


            //Supervisor_T9_PK =============================================================
            // 2] Get the Supervisor_T9_PK from the appropriate
            //      cell in the GridView control.
            TableCell cellSupervisor_T9_PK = selectedRow.Cells[5];
            string sSupervisor_T9_PK = cellSupervisor_T9_PK.Text;
            //Set the Session Variable;
            iX = 0;
            if (int.TryParse(sSupervisor_T9_PK, out iX))
                {
                Session["Supervisor_T9_PK"] = iX;
                }

            switch (e.CommandName)
                {
                case "GoTo_New_PatientAudit_RowCommand":

                    //-----------------------------------------------------------------------------------------
                    // INSERT Record
                    Debug.WriteLine("GridView1_RowCommand is: GoTo_New_PatientAudit_RowCommand");



                    //2] Insert new record, get back PK 
                    //===============
                    string sNoteForLog = Session["UserLogin"].NullSafeToString() + " {PRJ_1034 Patient Audit} --------- INSERT-START ------------,&lt;br&gt;";
                    sNoteForLog = sNoteForLog + "1] Supervisor T9_PK = " + sSupervisor_T9_PK.Trim() + " ,&lt;br&gt; ";
                    sNoteForLog = sNoteForLog + "1] Employee T9_PK = " + sEmployee_T9_PK.Trim() + " ,&lt;br&gt; ";
                    //===============

                    string sNewRecordPK = Specific_SQL.fn_sFORM_0010_T0_PK_given_CM_and_Supervisor_PK(sSupervisor_T9_PK.Trim(), sEmployee_T9_PK.Trim()).ToString();

                    //===========================
                    sNoteForLog = sNoteForLog + Session["UserLogin"].NullSafeToString() + " {PRJ_1034 Patient Audit} ============== INSERT-END ==============";
                    Specific_SQL.InsertNoteTo_T00_WriteUsageLog_ForWebFrontEnds(sNoteForLog);
                    //==========================

                    //3] Get Hash of PK

                    String sHashX = General_String_Extensions.fn_ComputeStringOfHash(sNewRecordPK);

                    // 4] Once the Session Variables are set go to the page: New_EDIT_CM_PatientAudit.aspx
                    Response.Redirect("New_EDIT_CM_PatientAudit.aspx?FORM_0010_T0_PK=" + sNewRecordPK + "&amp;key=" + sHashX);
                    // Then on destination page need to compare Hash of sNewRecordPK to key
                    break;
                //-----------------------------------------------------------------------------------------
                // EDIT Existing Records
                case "GoTo_ListOf_ExistingPatientAudits":

                    Debug.WriteLine("GridView1_RowCommand is: GoTo_ListOf_ExistingPatientAudits");

                    Response.Redirect("ListOfPatientAudits_ForSpecificCareManager.aspx?a_CM_Name_T9PK=" + sEmployee_T9_PK + "&amp;a_Supervisor_T9PK=" + sSupervisor_T9_PK);
                    break;

                default:
                    Console.WriteLine("The value is something else");
                    break;
                }



            }

        
        #endregion //Buttons ==========================================================================================

        #region SqlDataSource //==========================================================================================


        #endregion //SqlDataSource ==========================================================================================


        }
    }</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>BROWSERs</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>UserAgent_in_IE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>BROWSERs</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>UserAgent_in_IE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>this will tell you your user string:
http://www.useragentstring.com/
as well as this:
https://www.whatismybrowser.com/detect/what-is-my-user-agent

===================================================
This is my Windows 7 string for IE:
Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko
Use this for Windows 10
Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko
====================================================
https://www.howtogeek.com/113439/how-to-change-your-browsers-user-agent-without-installing-any-extensions/
Microsoft Edge and Internet Explorer have user agent switchers in their developer tools, and theyre nearly identical. To open them, click the settings menu and select F12 Developer Tools or just press F12 on your keyboard.
 
The developer tools will open in a separate pane at the bottom of the window. Click the Emulation tab and choose a user agent from the User agent string box. You can also select the Custom option in the User agent string list and type a custom user agent into the box. You can find extensive lists of user agents on various websites, such as this one.
This setting is temporary. It only applies to the current tab, and only while the F12 Developer Tools pane is open.
============================================
// Match user agent string with operating systems 
Windows 3.11 =&gt; Win16,
Windows 95 =&gt; (Windows 95)|(Win95)|(Windows_95),
Windows 98 =&gt; (Windows 98)|(Win98),
Windows 2000 =&gt; (Windows NT 5.0)|(Windows 2000),
Windows XP =&gt; (Windows NT 5.1)|(Windows XP),
Windows Server 2003 =&gt; (Windows NT 5.2),
Windows Vista =&gt; (Windows NT 6.0),
Windows 7 =&gt; (Windows NT 6.1),
Windows 8 =&gt; (Windows NT 6.2),
Windows 10 =&gt; (Windows NT 10.0),
Windows NT 4.0 =&gt; (Windows NT 4.0)|(WinNT4.0)|(WinNT)|(Windows NT),
Windows ME =&gt; Windows ME,
Open BSD =&gt; OpenBSD,
Sun OS =&gt; SunOS,
Linux =&gt; (Linux)|(X11),
Mac OS =&gt; (Mac_PowerPC)|(Macintosh),
QNX =&gt; QNX,
BeOS =&gt; BeOS,
OS/2 =&gt; OS/2,
Search Bot=&gt;(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp)|(MSNBot)|(Ask Jeeves/Teoma)|(ia_archiver)
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Bulk_Insert</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>BCP_ReadMe</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Bulk_Insert</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>BCP_ReadMe</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--So, for example, in order to minimize logging for bulk activities, such as those used by BCP.exe, 
--you can temporarily switch from Full recovery mode to Bulklogged mode, 
--while retaining the ability to back up the transaction log. 

--One downside of Bulk-logged mode, however, is that you lose the ability to restore to a 
--point in time if there are any bulk transactions, though you
--can still restore the entire transaction log in Bulk-logged mode

--Alternatively, you can set the database to Simple mode, in which bulk operations are also minimally logged. 
--By definition, the Simple mode does not support point in time recovery, since the transaction log cannot be backed up, 
--and is truncated  each time a checkpoint is issued for the database.
 
--However, this "truncate on checkpoint" 
--process does have the benefit that the log is continually freed of committed transactions, and will not grow indefinitely

--The dangers of rampant log file growth can be mitigated to some extent by
--committing bulk update, inserts or delete transactions in batches, say every
--100,000 records. In BCP, for example, you can control the batch size using the
--batch size flag. This is a good practice regardless of recovery model, as it means
--that the committed transaction can be removed from the log file, either via a log
--backup or a checkpoint truncate.

--if recovering to a point in time is important, then your databases will
--need to be in Full recovery mode. In this case, I'd recommend switching to Bulk
--logged mode for bulk operations, performing a full backup after bulk loading the
--data and then subsequently switching back to Full recovery and continuing log
--backups from that point.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CrystalReports_v11</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>Alternating_Row_Color_in_Details</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CrystalReports_v11</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>Alternating_Row_Color_in_Details</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.baass.com/blog/crystal-reporting-tips-alternate-line-shading

Go to Report &gt; Section Expert (or right-click on the left, section area)
Click on Details on the left and switch to the Color tab on the right
Click on the formula button:

Copy/type the following formula in:


select RecordNumber mod 2
case 0: crWhite
case 1: color(222,222,222)

Click Save and Close
Click OK to close the Section Expert window


========================================== for Groups

select GroupNumber mod 2
case 0: crWhite
case 1: crYellow</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CSS_ListItems</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>readMe_CSS_ListItems</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CSS_ListItems</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>readMe_CSS_ListItems</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>readMe_CSS_ListItems

another alternative to "" is "\002022"

=========================================

li{
   list-style:square;
}


==============================================
The dot can be replaced using an image:

ul, li {
    list-style-img: url(path/to/image.png);
}


==============================================


To change the color of the defaults is more awkward, since the color is taken from the list-item itself, 
so the content must be wrapped in another element to change the color:

The list-markers with #f90 and the text will be #000.

&lt;ul&gt;
    &lt;li&gt;&lt;span&gt;List item text&lt;/span&gt;
&lt;/ul&gt;

With the following CSS:

li {
    color: #f90;
}

li span {
    color: #000;
}


=================================================

You could also use CSS generated-content, assuming your users have compliant browsers:

ul,li {
    /* removes the defaults */
    list-style-type: none;
}

li {
    /* every li element increments the counter 'newListMarker',
       only relevant if you're using an incrementing counter, such
       as with an ol */
    counter-increment: newListMarker;
}

li::before {
    content: counter(newListMarker);
    color: #0f0;
}


==============================================

Which code in CSS allows me to set only the color of the bullets?

The most common way to do this is something along these lines:

ul {
    list-style: none;
    padding:0;
    margin:0;
}

li { 
    padding-left: 1em; 
    text-indent: -.7em;
}

li:before {
    content: " ";
    color: red; /* or whatever color you prefer */
}


instead of " " also possible:
 content: "4"; font-family:"Webdings";
  which will result in a nice &gt; or for a nice  content: ""; font-family:"Arial Black"; 
  
===================================================================================================

you can make your own png image/pattern here,
 http://www.patternify.com/ then copy / paste your code and customize your bullets =) stills elegant?

  li{
    list-style-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAE0lEQVQIW2NkYGD4D8RwwEi6AACaVAQBULo4sgAAAABJRU5ErkJggg==");
}

========================================================================================

I found you can color the bullets by just using "color:#ddd;" on the "li" item itself.

li{
    color:#ff0000;    
    list-style:square;                
}
a {
    text-decoration: none;
    color:#00ff00;
}

a:hover {
    background-color: #ddd;
}


=============================================================================


3 down vote
	

I simply solve this problem like this, which should work in all browsers:

&lt;ul&gt;
  &lt;li&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span&gt;Bat&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

ul li{
    color: red
}

ul li span{
    color: blue;
}


=============================================================================
A variation of Lea Verou solution with perfect indentation in multi-line entries could be something like this:

ul{
    list-style: none;
    position: relative;
    padding: 0;
    margin: 0;
}

li{
    padding-left: 1.5em; 
}

li:before {
    position: absolute;
    content: "";
    color: red;
    left: 0;
}

=============================================================================

here's a different way of making unordered lists, with borders: http://jsfiddle.net/vX4K8/7/

HTML============

&lt;ul&gt;
    &lt;li&gt;Foo&lt;/li&gt;
    &lt;li&gt;Bar&lt;/li&gt;
    &lt;li&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/li&gt;
        &lt;ul&gt;
        &lt;li&gt;Son&lt;/li&gt;
        &lt;li&gt;Of&lt;/li&gt;
            &lt;ul&gt;
            &lt;li&gt;Foo&lt;/li&gt;
            &lt;li&gt;Bar&lt;/li&gt;
            &lt;li&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/ul&gt;
&lt;/ul&gt;

CSS===========

ul {
list-style: none;
margin: 0;
}

ul:first-child {
   padding: 0;
}

li {
    line-height: 180%;
    border-bottom: 1px dashed #CCC;
    margin-left: 14px;
    text-indent: -14px;
}

li:last-child {
    border: none;
}

li:before {
    content: "";
    border-left: 4px solid #CCC;
    padding-left: 10px;
}

===============================================

does not work in chrome nor fox!!!!!!!!

CSS

ul {
    color: red;
}

li {
    color: black;
}

The bullet colour is defined on the ul tag and then we switch the li colour back.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Logical_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Logical_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/logical-functions-dax

'IF/SWITCH cant return tables: 
'Another subtlety that I noted in my research is that IF and SWITCH can only return scalar values and NOT tables.


AND
FALSE
		
==================================================================================================================
IF:			IF(logical_test&gt;,&lt;value_if_true&gt;, value_if_false)  
=======================================================================================================
'Checks if a condition provided as the first argument is met. Returns one value if the condition is TRUE, 
		'	and returns another value if the condition is FALSE: 
		  
		'IF(logical_test&gt;,&lt;value_if_true&gt;, value_if_false)
		'value_if_true:		If omitted, TRUE is returned.
		'value_if_false :	If omitted, FALSE is returned.  
		---------------------------------------------------
		=
			IF (
			    [StateProvinceCode] = "CA"
			        &amp;&amp; ( [MaritalStatus] = "M"
			        || [NumberChildrenAtHome] &gt; 1 ),
			    [City]
			)
		---------------------------------------------------
            IF (
                AND (
	                    CurrentSales &lt;&gt; 0,
	                    PreviousSales &lt;&gt; 0
		             ),
	                CurrentSales - PreviousSales
            	)
        ---------------------------------------------------    			
		Homeowner = if([HomeOwnerFlag] = 0, "Not Homeowner", "Homeowner")
		
		=IF([Calls]&lt;200,"low",IF([Calls]&lt;300,"medium","high"))  
		
		'the condition in the IF function checks for the value of the columns [MaritalStatus] AND [NumberChildrenAtHome], 
		'	and outputs the city if either condition is met AND if the customer is in California. 
		'	Otherwise, it outputs the empty string.

=IF([StateProvinceCode]= "CA" &amp;&amp; ([MaritalStatus] = "M" || [NumberChildrenAtHome] &gt;1),[City])  		

=======================================================================================================				
IFERROR	'Evaluates an expression and returns a specified value if the expression returns an error; otherwise returns the value of the expression itself.

		=IFERROR(25/0,9999)

=======================================================================================================		
NOT
OR
=======================================================================================================
SWITCH				SWITCH(&lt;expression&gt;, &lt;value&gt;, &lt;result&gt;[, &lt;value&gt;, &lt;result&gt;][, &lt;else&gt;])  
=======================================================================================================
	'Evaluates an expression against a list of values and returns one of multiple possible result expressions.
		'SWITCH checks for exact matches i.e. equals, but not less than or greater than
		---------------------------------------------for "="
			=
			SWITCH (
			    [Month],
			    1, "January",
			    2, "February",
			    3, "March",
			    4, "April",
			    5, "May",
			    6, "June",
			    7, "July",
			    8, "August",
			    9, "September",
			    10, "October",
			    11, "November",
			    12, "December",
			    "Unknown month number"
			)
		-----------------------------------------------	for &lt; or &gt;
		'https://powerpivotpro.com/2015/03/the-diabolical-genius-of-switch-true/
		'SWITCH() is still testing for equivalence!  
		'	By providing the first argument as TRUE(), now each subsequent test is going to be checking for TRUE().
		'And since each of our inequality tests results in either TRUE() or FALSE() as a value, 
		'	the test case that evaluate to TRUE() is the one that gets matched, 
		'	and therefore the one that gets used.  For instance, if [Measure]&lt;1 evaluates to TRUE(), then expr1 gets returned.
		'you STILL have to sequence your overlapping test cases carefully
		
		SWITCH(
          TRUE(),
          [MyMeasure]&lt;1,expr1,
          [MyMeasure]&lt;2,expr2,
          [MyMeasure]&lt;3,expr3,
         )
=======================================================================================================
TRUE
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Misc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>debugging_formatting</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Misc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>debugging_formatting</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>web formatter: http://www.daxformatter.com/

New Line in DAX editor: [Shift]-[Enter]

'To debug this:

[ABC Class] =
				VAR MySales = Products[ProductSales]
				VAR ProductsWithSalesBiggerThanMine =									'&lt;==== Table Variable
				    FILTER ( ALL ( Products ), Products[ProductSales] &gt;= MySales )
				VAR CumulatedSales =
				    CALCULATE ( SUM ( Sales[SalesAmount] ), ProductsWithSalesBiggerThanMine )
				VAR CumulatedPercentage =
				    CumulatedSales / SUM ( Sales[SalesAmount] )
				RETURN
				    SWITCH (
						        TRUE (),
						        CumulatedPercentage &lt;= 0.7, "A",
						        CumulatedPercentage &lt;= 0.9, "B",
						        "C"
						    )
'Change the return to return each variable one at a time.
'and display the output in a Card visualizer
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Misc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>VAR_Variables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Misc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>VAR_Variables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'PseudoCode:
myFormula = VAR = VariableName1 = &lt;some valid DAX formula&gt;
            VAR = VariableName2 = &lt;some other valid DAX formula&gt;
            RETURN &lt;another valid DAX formula that can use VariableName1 
                       and VariableName2 as part of the expression&gt;
                       
'Example:

[ABC Class] =
				VAR MySales = Products[ProductSales]
				VAR ProductsWithSalesBiggerThanMine =									'&lt;==== Table Variable
				    FILTER ( ALL ( Products ), Products[ProductSales] &gt;= MySales )
				VAR CumulatedSales =
				    CALCULATE ( SUM ( Sales[SalesAmount] ), ProductsWithSalesBiggerThanMine )
				VAR CumulatedPercentage =
				    CumulatedSales / SUM ( Sales[SalesAmount] )
				RETURN
				    SWITCH (
						        TRUE (),
						        CumulatedPercentage &lt;= 0.7, "A",
						        CumulatedPercentage &lt;= 0.9, "B",
						        "C"
						    )                       
                       
'It is possible to set scalar values as variables but it is also possible to assign tables as variables.

'Scalar Value Example
---------------------
VAR myScalarValue = SUM(Sales[Extended Amount]) 

'Table Example
------------------
VAR myTable = FILTER(Customer,Customer[Post Code] = 50210) 
'The above variable myTable returns a virtual table 
'that can be used anywhere that a table is used in a DAX formula, such as a filter inside a CALCULATE function.              

'Once the variable has been assigned a value, that value cannot change during the execution of the RETURN portion of the formula. 
'From that perspective, the variables act more like constants than regular variables in a traditional programming language context.


-----------------------------------------------------------------DEFINE clause
'You can declare DAX variables in the DEFINE clause of a query like so:
DEFINE
    VAR MyMonth = "January"
    VAR FilteredMonths =
        FILTER ( VALUES ( Sales[Month] ), Sales[Month] = MyMonth )
EVALUATE
CALCULATETABLE ( Sales, FilteredMonths )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>EXCEL</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>EXCEL</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Note: the SWITCH function is new in Excel 2016 via Office 365.
=SWITCH(C5,1,"Poor",2,"OK",3,"Good","??")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>LINUX_Misc</Category>
        <Language>DOSBATCH</Language>
        <Public>false</Public>
        <Name>Commands</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>LINUX_Misc</Category>
          <Language>DOSBATCH</Language>
          <Public>false</Public>
          <Name>Commands</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>commands_Misc
============


cd     	::  used for navigation )
cd..   	::  back to previous direcrtory )
cd/    	::  back to root directory )
ls      ::  list content of current directory )
pwd  	::  print working directory )
su 		:: switch user
sudo	::super user do		
		&gt;sudo su	::switch you to the root account



:: Repeating Commands
=====================
!!			:: Repeat last command
			&gt; sudo !!	:: repeat last command, but as sudo
!x			:: Repeat last command that started with x
!?x			:: Repeat last command that has the substring x
!10			:: Repeat 10th command in the history file
!-10		:: Repeat 10th from last command in the history file
^old^new	:: reruns the previous command substituting the first occurance of the string "old" with "new"

!$			:: use this in a command, it is replaced by the last word in the previous command

:: Fetching Parameters
========================
!!*		:: Fetch parameters from last command
!!^		:: Fetch first parameter from last command
!!$		:: Fetch last parameter from last command
!!3		:: Fetch third parameter from last command

:: Modifiers
==============
!!:s/foo/bar/		:: Repeat last command substituting foo for bar
!!:p				:: Print last command without running it

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>LINUX_Misc</Category>
        <Language>DOSBATCH</Language>
        <Public>false</Public>
        <Name>KeyCommands</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>LINUX_Misc</Category>
          <Language>DOSBATCH</Language>
          <Public>false</Public>
          <Name>KeyCommands</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

[Alt]-[F2]			::opens the Run a command window

[Ctrl]-[Alt]-[Fx]	:: where 'x' is the function keys 1 through 6 to get to Virtual consoles, [Ctrl]-[Alt]-[F7] is the graphical session
[Ctrl]-[c]			:: Abort Execution, or [Delete]
[Ctrl]-[d]			:: Log out of a terminal, and close it
[Ctrl]-[q]			:: Unlocks the screen
[Ctrl]-[s]			:: Lock the screen

[Ctrl]-[u]			:: delete a line
[Ctrl]-[w]			:: delete a word
[Ctrl]-[z]			:: Suspends a program, you can then use " &gt;fg programName" to bring the program back to the foreground and continue
[Ctrl]-[\]			:: Quit, like [Ctrl]-[c]

GNOME TERMINAL commands
========================
[Ctrl]-[Shft][N] 	::opens a new window
[Ctrl]-[Shft][T] 	::opens a new tab in the emulator
[Ctrl]-[PageUp] 	::switch between tabs
[Ctrl]-[PageDown] 	::switch between tabs
[Alt]-[x] 			::switch to tab x</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>LINUX_Users_and_Groups</Category>
        <Language>DOSBATCH</Language>
        <Public>false</Public>
        <Name>commands_Users_and_Groups</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>LINUX_Users_and_Groups</Category>
          <Language>DOSBATCH</Language>
          <Public>false</Public>
          <Name>commands_Users_and_Groups</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

::CREATE a USER - NOTE: this is not a user that can use "sudo"
&gt; sudo adduser userOne
:: asks for sudo password, then for password for the new user

:: CREATE a GROUP
&gt; sudo groupadd theGroup

::To SWITCH OVER TO the new user
:: NOTE: if a standard user tries to do anything that requires sudo,  that user will get this message (e.g.)
::		 "userOne is not in the sudoers file. This incident will be reported"
&gt; su userOne

:: TO ADD A USER TO A GROUP (e.g. add 'userOne' to the administrator group) : can add user to any group this way
&gt; sudo adduser userOne sudo

:: To DELETE a user:
&gt; sudo deluser userOne

:: To CHANGE PASSWORD of existing user:
&gt; sudo passwd userOne
:: responds:
Enter new UNIX password:
:: then type the new password, and it will respond that it was updated successfully</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>LOG_file</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Recover_Model</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>LOG_file</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Recover_Model</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--FROM: http://dba.stackexchange.com/questions/29829/why-does-the-transaction-log-keep-growing-or-run-out-of-space



--If you don't care about point-in-time recovery
--If this is a test database, and you don't care about point-in-time recovery, then you should make sure that your database is in SIMPLE recovery mode.

-- To see and then change the recover model to 'Simple'
SELECT name, recovery_model_desc  
   FROM sys.databases  
      WHERE name = 'success' ;  
GO  

ALTER DATABASE success SET RECOVERY SIMPLE;;


--Simple Recovery Model
=====================
--So with the above introduction, it is easiest to talk about Simple Recovery model first. In this model, 
--	you are telling SQL Server: "I am fine with you using your transaction log file for crash and restart recovery..." 
--	(You really have no choice there. Look up ACID properties and that should make sense quickly.) 
--	"...but once you no longer need it for that crash/restart recovery purpose, go ahead and reuse the log file."

--SQL Server listens to this request in Simple Recovery and it only keeps the information it needs to do crash/restart recovery. 
--	Once SQL Server is sure it can recover because data is hardened to the data file (more or less), 
--	the data that has been hardened is no longer necessary in the log and is marked for truncation - which means it gets re-used.

--Full Recovery Model
===================
--With Full Recovery, you are telling SQL Server that you want to be able to recover to a specific point in time, 
--	as long as your log file is available or to a specific point in time that is covered by a log backup. 
--	In this case when SQL Server reaches the point where it would be safe to truncate the log file in Simple Recovery Model, 
--	it will not do that. Instead It lets the log file continue to grow and will allow it to keep growing, 
--	until you take a log backup (or run out of space on your log file drive) under normal circumstances.

--If you just switch into Full Recovery mode, but never take an initial Full Backup, 
--	SQL Server will not honor your request to be in Full Recovery model. 
--	Your transaction log will continue to operate as it has in Simpleuntil you switch to Full Recovery Model AND take your first Full Backup.

--Full Recovery Model without log backups is bad. - MOST common reason for uncontrolled Log Growth
=================================================================================================
--So, that's the most common reason for uncontrolled log growth? Answer: 
--	Being in Full Recovery mode without having any log backups.

-- each new database gets its initial recovery model setting by looking at the model database.

--Model's initial recovery model setting is always Full Recovery Model - until and unless someone changes that. 
--	So you could say the "default Recovery Model" is Full. 
--	Many people are not aware of this and have their databases running in Full Recovery Model with no log backups, 
--	and therefore a transaction log file much larger than necessary. 
--	This is why it is important to change defaults when they don't work for your organization and its needs)

--Second most common reason for Log Growth: Long Running Transactions
=====================================================================

--If you have a transaction that takes a long time or does a lot of changes, the log cannot truncate on checkpoint 
--	for any of the changes that are still in open transactions or that have started since that transaction started.

--This means that a big delete, deleting millions of rows in one delete statement is one transaction 
--	and the log cannot do any truncating until that whole delete is done. 
--	In Full Recovery Model, this delete is logged and that could be a lot of log records. 
--	Same thing with Index optimization work during maintenance windows. 
--	It also means that poor transaction management and not watching for and closing open transactions can really hurt you and your log file.

--What can I do about these long running transactions?
--	Properly sizing your log file to account for the worst case scenario - like your maintenance or known large operations.
--	see this link: http://www.sqlskills.com/blogs/kimberly/8-steps-to-better-transaction-log-throughput/

--	Watching your usage of transactions. 
--	Don't start a transaction in your application server and start having long conversations with SQL Server and risk leaving one open too long.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>LogShipping</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>HowTo_LogShip</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>LogShipping</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>HowTo_LogShip</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- From: http://www.informit.com/articles/article.aspx?p=331402

-- for SQL 2000

--How It Works

--Log shipping implementation is straightforward:

--    Full backup of the database is taken on the primary server and copied to the standby server.

--    Standby server maintains a copy of the database.

--    The database is not operational; it can stay in either read-only mode or no-recovery mode.

--    Transaction log for the "log-shipped" database is backed up on the primary server periodically. Note that only databases that are in FULL recovery mode can be log-shipped.

--    Transaction log backups are placed on a shared drive; standby server's SQL Server Agent account must have access to this shared drive.

--    Transaction log backups are copied to the standby server.

--    Transaction log backups are applied to the database on the standby server in the order that they were taken on the primary server.

--    Either primary server, standby server, or a separate server can be used to monitor log shipping. If you use a separate server for monitoring, 
--		it does NOT have to have Enterprise Edition of SQL Server; any edition (other than MSDE) will do.

--If the primary server becomes unavailable due to disk failure or some other reason, DBA can take the following steps to fail the database over to the standby server:

--    Perform one last backup of the transaction log on the primary server (if possible).

--    Copy all transaction log backups to the standby server and apply them in the same order they were taken on the primary server.

--    The last transaction log backup should be restored by using the WITH RECOVERY clause so that the standby database becomes operational.

--    Transfer any logins that exist on the primary server to the standby server. Only the logins that must have access to the log-shipped database must be transferred.

--    This step might be further complicated if logins with the same name exist on both servers. In such cases, 
--		the DBA needs to ensure that appropriate mappings exist between SQL Server logins and database users on the standby server.

--During the initial configuration of log shipping, you can allow the standby database to assume the primary role. 
--	That means you can ship transaction logs from the standby server to the primary server after you have failed the primary database over. 
--	So if primary server (server A) fails over to standby server (server B), servers can switch roles so that</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>machine_config</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>machine.config</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>machine_config</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>machine.config</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;?xml version="1.0" encoding="us-ascii"?&gt;
&lt;!--
    Please refer to machine.config.comments for a description and
    the default values of each configuration section.

    For a full documentation of the schema please refer to
    http://go.microsoft.com/fwlink/?LinkId=42127

    To improve performance, machine.config should contain only those
    settings that differ from their defaults.
--&gt;
&lt;configuration&gt;
    &lt;configSections&gt;
        &lt;section name="appSettings" type="System.Configuration.AppSettingsSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" restartOnExternalChanges="false" requirePermission="false" /&gt;
        &lt;section name="connectionStrings" type="System.Configuration.ConnectionStringsSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" requirePermission="false" /&gt;
        &lt;section name="mscorlib" type="System.Configuration.IgnoreSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowLocation="false" /&gt;
        &lt;section name="runtime" type="System.Configuration.IgnoreSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowLocation="false" /&gt;
        &lt;section name="assemblyBinding" type="System.Configuration.IgnoreSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowLocation="false" /&gt;
        &lt;section name="satelliteassemblies" type="System.Configuration.IgnoreSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowLocation="false" /&gt;
        &lt;section name="startup" type="System.Configuration.IgnoreSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowLocation="false" /&gt;
        &lt;section name="system.codedom" type="System.CodeDom.Compiler.CodeDomConfigurationHandler, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;section name="system.data" type="System.Data.Common.DbProviderFactoriesConfigurationHandler, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;section name="system.data.dataset" type="System.Configuration.NameValueFileSectionHandler, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" restartOnExternalChanges="false" /&gt;
        &lt;section name="system.data.odbc" type="System.Data.Common.DbProviderConfigurationHandler, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;section name="system.data.oledb" type="System.Data.Common.DbProviderConfigurationHandler, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;section name="system.data.oracleclient" type="System.Data.Common.DbProviderConfigurationHandler, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;section name="system.data.sqlclient" type="System.Data.Common.DbProviderConfigurationHandler, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;section name="system.diagnostics" type="System.Diagnostics.SystemDiagnosticsSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;section name="system.runtime.remoting" type="System.Configuration.IgnoreSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowLocation="false" /&gt;
        &lt;section name="system.windows.forms" type="System.Windows.Forms.WindowsFormsSection, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;section name="windows" type="System.Configuration.IgnoreSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowLocation="false" /&gt;
        &lt;sectionGroup name="system.xml.serialization" type="System.Xml.Serialization.Configuration.SerializationSectionGroup, System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"&gt;
            &lt;section name="schemaImporterExtensions" type="System.Xml.Serialization.Configuration.SchemaImporterExtensionsSection, System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;section name="dateTimeSerialization" type="System.Xml.Serialization.Configuration.DateTimeSerializationSection, System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;section name="xmlSerializer" type="System.Xml.Serialization.Configuration.XmlSerializerSection, System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" /&gt;
        &lt;/sectionGroup&gt;
        &lt;sectionGroup name="system.net" type="System.Net.Configuration.NetSectionGroup, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"&gt;
            &lt;section name="authenticationModules" type="System.Net.Configuration.AuthenticationModulesSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;section name="connectionManagement" type="System.Net.Configuration.ConnectionManagementSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;section name="defaultProxy" type="System.Net.Configuration.DefaultProxySection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;sectionGroup name="mailSettings" type="System.Net.Configuration.MailSettingsSectionGroup, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"&gt;
                &lt;section name="smtp" type="System.Net.Configuration.SmtpSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;/sectionGroup&gt;
            &lt;section name="requestCaching" type="System.Net.Configuration.RequestCachingSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;section name="settings" type="System.Net.Configuration.SettingsSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;section name="webRequestModules" type="System.Net.Configuration.WebRequestModulesSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;/sectionGroup&gt;
        &lt;sectionGroup name="system.transactions" type="System.Transactions.Configuration.TransactionsSectionGroup, System.Transactions, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, Custom=null"&gt;
            &lt;section name="defaultSettings" type="System.Transactions.Configuration.DefaultSettingsSection, System.Transactions, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, Custom=null" /&gt;
            &lt;section name="machineSettings" type="System.Transactions.Configuration.MachineSettingsSection, System.Transactions, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, Custom=null" allowDefinition="MachineOnly" allowExeDefinition="MachineOnly" /&gt;
        &lt;/sectionGroup&gt;
        &lt;sectionGroup name="system.web" type="System.Web.Configuration.SystemWebSectionGroup, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"&gt;
            &lt;section name="anonymousIdentification" type="System.Web.Configuration.AnonymousIdentificationSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="authentication" type="System.Web.Configuration.AuthenticationSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="authorization" type="System.Web.Configuration.AuthorizationSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="browserCaps" type="System.Web.Configuration.HttpCapabilitiesSectionHandler, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="clientTarget" type="System.Web.Configuration.ClientTargetSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="compilation" type="System.Web.Configuration.CompilationSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="customErrors" type="System.Web.Configuration.CustomErrorsSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="deployment" type="System.Web.Configuration.DeploymentSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineOnly" /&gt;
            &lt;section name="deviceFilters" type="System.Web.Mobile.DeviceFiltersSection, System.Web.Mobile, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="globalization" type="System.Web.Configuration.GlobalizationSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="healthMonitoring" type="System.Web.Configuration.HealthMonitoringSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="hostingEnvironment" type="System.Web.Configuration.HostingEnvironmentSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="httpCookies" type="System.Web.Configuration.HttpCookiesSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="httpHandlers" type="System.Web.Configuration.HttpHandlersSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="httpModules" type="System.Web.Configuration.HttpModulesSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="httpRuntime" type="System.Web.Configuration.HttpRuntimeSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="identity" type="System.Web.Configuration.IdentitySection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="machineKey" type="System.Web.Configuration.MachineKeySection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="membership" type="System.Web.Configuration.MembershipSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="mobileControls" type="System.Web.UI.MobileControls.MobileControlsSection, System.Web.Mobile, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="pages" type="System.Web.Configuration.PagesSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="processModel" type="System.Web.Configuration.ProcessModelSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineOnly" allowLocation="false" /&gt;
            &lt;section name="profile" type="System.Web.Configuration.ProfileSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="protocols" type="System.Web.Configuration.ProtocolsSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToWebRoot" /&gt;
            &lt;section name="roleManager" type="System.Web.Configuration.RoleManagerSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="securityPolicy" type="System.Web.Configuration.SecurityPolicySection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="sessionPageState" type="System.Web.Configuration.SessionPageStateSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="sessionState" type="System.Web.Configuration.SessionStateSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="siteMap" type="System.Web.Configuration.SiteMapSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="trace" type="System.Web.Configuration.TraceSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="trust" type="System.Web.Configuration.TrustSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="urlMappings" type="System.Web.Configuration.UrlMappingsSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;section name="webControls" type="System.Web.Configuration.WebControlsSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="webParts" type="System.Web.Configuration.WebPartsSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="webServices" type="System.Web.Services.Configuration.WebServicesSection, System.Web.Services, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;section name="xhtmlConformance" type="System.Web.Configuration.XhtmlConformanceSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;sectionGroup name="caching" type="System.Web.Configuration.SystemWebCachingSectionGroup, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"&gt;
                &lt;section name="cache" type="System.Web.Configuration.CacheSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
                &lt;section name="outputCache" type="System.Web.Configuration.OutputCacheSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
                &lt;section name="outputCacheSettings" type="System.Web.Configuration.OutputCacheSettingsSection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
                &lt;section name="sqlCacheDependency" type="System.Web.Configuration.SqlCacheDependencySection, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" allowDefinition="MachineToApplication" /&gt;
            &lt;/sectionGroup&gt;
        &lt;/sectionGroup&gt;
        &lt;section name="system.webServer" type="System.Configuration.IgnoreSection, System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
    &lt;/configSections&gt;
    &lt;!--
        &lt;appSettings
            file = "" [String]
            &gt;
            &lt;add
                key = "" [String, Collection Key]
                value = "" [String]
            /&gt;

        &lt;/appSettings&gt;
    --&gt;
    &lt;appSettings file=""&gt;
        &lt;clear /&gt;
    &lt;/appSettings&gt;
    &lt;!--
        &lt;system.diagnostics
            &gt;
            &lt;assert
                assertuienabled = "true" [true|false]
                logfilename = "" [String]
            /&gt;
            &lt;performanceCounters
                filemappingsize = "524288" [number]
            /&gt;
            &lt;trace
                autoflush = "false" [true|false]
                indentsize = "4" [number]
                useGlobalLock = "true" [true|false]
                &gt;
            &lt;/trace&gt;
        &lt;/system.diagnostics&gt;
    --&gt;
    &lt;system.diagnostics&gt;
        &lt;assert assertuienabled="true" logfilename="" /&gt;
        &lt;performanceCounters filemappingsize="524288" /&gt;
        &lt;switches&gt;
            &lt;clear /&gt;
        &lt;/switches&gt;
        &lt;trace autoflush="false" indentsize="4" useGlobalLock="true"&gt;
            &lt;listeners&gt;
                &lt;clear /&gt;
                &lt;add initializeData="" type="System.Diagnostics.DefaultTraceListener" name="Default" traceOutputOptions="None"&gt;
                    &lt;filter type="" initializeData="" /&gt;
                &lt;/add&gt;
            &lt;/listeners&gt;
        &lt;/trace&gt;
    &lt;/system.diagnostics&gt;
    &lt;!--
        &lt;system.windows.forms
            jitDebugging = "false" [true|false]
        /&gt;
    --&gt;
    &lt;system.windows.forms jitDebugging="false" /&gt;
    &lt;!--
        &lt;configProtectedData
            defaultProvider = "RsaProtectedConfigurationProvider" [String]
            &gt;
            &lt;providers&gt;
                &lt;add
                    name = "" [String, Required, Collection Key]
                    type = "" [String, Required]
                /&gt;
            &lt;/providers&gt;

        &lt;/configProtectedData&gt;
    --&gt;
    &lt;configProtectedData defaultProvider="RsaProtectedConfigurationProvider"&gt;
        &lt;providers&gt;
            &lt;clear /&gt;
            &lt;add description="Uses RsaCryptoServiceProvider to encrypt and decrypt" keyContainerName="NetFrameworkConfigurationKey" cspProviderName="" useMachineContainer="true" useOAEP="false" name="RsaProtectedConfigurationProvider" type="System.Configuration.RsaProtectedConfigurationProvider,System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;add description="Uses CryptProtectData and CryptUnProtectData Windows APIs to encrypt and decrypt" useMachineProtection="true" keyEntropy="" name="DataProtectionConfigurationProvider" type="System.Configuration.DpapiProtectedConfigurationProvider,System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
        &lt;/providers&gt;
    &lt;/configProtectedData&gt;
    &lt;!--
        &lt;runtime
        /&gt;
    --&gt;
    &lt;runtime /&gt;
    &lt;!--
        &lt;connectionStrings
            &gt;
            &lt;add
                name = "" [String, Required, Collection Key]
                connectionString = "" [String, Required]
                providerName = "System.Data.SqlClient" [String]
            /&gt;

        &lt;/connectionStrings&gt;
    --&gt;
    &lt;connectionStrings&gt;
        &lt;clear /&gt;
        &lt;add name="LocalSqlServer" connectionString="data source=.\SQLEXPRESS;Integrated Security=SSPI;AttachDBFilename=|DataDirectory|aspnetdb.mdf;User Instance=true" providerName="System.Data.SqlClient" /&gt;
    &lt;/connectionStrings&gt;
    &lt;!--
        &lt;system.data
        /&gt;
    --&gt;
    &lt;system.data&gt;
        &lt;DbProviderFactories&gt;
            &lt;add name="Odbc Data Provider" invariant="System.Data.Odbc" description=".Net Framework Data Provider for Odbc" type="System.Data.Odbc.OdbcFactory, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="OleDb Data Provider" invariant="System.Data.OleDb" description=".Net Framework Data Provider for OleDb" type="System.Data.OleDb.OleDbFactory, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="OracleClient Data Provider" invariant="System.Data.OracleClient" description=".Net Framework Data Provider for Oracle" type="System.Data.OracleClient.OracleClientFactory, System.Data.OracleClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlClient Data Provider" invariant="System.Data.SqlClient" description=".Net Framework Data Provider for SqlServer" type="System.Data.SqlClient.SqlClientFactory, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;/DbProviderFactories&gt;
    &lt;/system.data&gt;
    &lt;system.web&gt;
        &lt;!--
            &lt;deployment
                retail = "false" [true|false]
            /&gt;
        --&gt;
        &lt;deployment retail="false" /&gt;
        &lt;!--
            &lt;processModel
                enable = "true" [true|false]
                timeout = "10675199.02:48:05.4775807" [HH:MM:SS]
                idleTimeout = "10675199.02:48:05.4775807" [HH:MM:SS]
                shutdownTimeout = "00:00:05" [HH:MM:SS]
                requestLimit = "2147483647" [number]
                requestQueueLimit = "5000" [number]
                restartQueueLimit = "10" [number]
                memoryLimit = "60" [number]
                webGarden = "false" [true|false]
                cpuMask = "0xffffffff" [number]
                userName = "machine" [String]
                password = "AutoGenerate" [String]
                logLevel = "Errors" [None | All | Errors]
                clientConnectedCheck = "00:00:05" [HH:MM:SS]
                comAuthenticationLevel = "Connect" [None | Call | Connect | Default | Pkt | PktIntegrity | PktPrivacy]
                comImpersonationLevel = "Impersonate" [Default | Anonymous | Delegate | Identify | Impersonate]
                responseDeadlockInterval = "00:03:00" [HH:MM:SS]
                responseRestartDeadlockInterval = "00:03:00" [HH:MM:SS]
                autoConfig = "false" [true|false]
                maxWorkerThreads = "20" [number]
                maxIoThreads = "20" [number]
                minWorkerThreads = "1" [number]
                minIoThreads = "1" [number]
                serverErrorMessageFile = "" [String]
                pingFrequency = "10675199.02:48:05.4775807" [HH:MM:SS]
                pingTimeout = "10675199.02:48:05.4775807" [HH:MM:SS]
                maxAppDomains = "2000" [number]
            /&gt;
        --&gt;
        &lt;processModel enable="true" timeout="Infinite" idleTimeout="Infinite" shutdownTimeout="00:00:05" requestLimit="Infinite" requestQueueLimit="5000" restartQueueLimit="10" memoryLimit="60" webGarden="false" cpuMask="0xffffffff" userName="machine" password="AutoGenerate" logLevel="Errors" clientConnectedCheck="00:00:05" comAuthenticationLevel="Connect" comImpersonationLevel="Impersonate" responseDeadlockInterval="00:03:00" responseRestartDeadlockInterval="00:03:00" autoConfig="true" maxWorkerThreads="20" maxIoThreads="20" minWorkerThreads="1" minIoThreads="1" serverErrorMessageFile="" pingFrequency="Infinite" pingTimeout="Infinite" maxAppDomains="2000" /&gt;
        &lt;!--
            &lt;membership
                defaultProvider = "AspNetSqlMembershipProvider" [String]
                hashAlgorithmType = "" [String]
                userIsOnlineTimeWindow = "15"  [in Minutes][number]
                &gt;
                &lt;providers&gt;
                    &lt;add
                        name = "" [String, Required, Collection Key]
                        type = "" [String, Required]
                    /&gt;
                &lt;/providers&gt;

            &lt;/membership&gt;
        --&gt;
        &lt;membership defaultProvider="AspNetSqlMembershipProvider" userIsOnlineTimeWindow="15" hashAlgorithmType=""&gt;
            &lt;providers&gt;
                &lt;clear /&gt;
                &lt;add connectionStringName="LocalSqlServer" enablePasswordRetrieval="false" enablePasswordReset="true" requiresQuestionAndAnswer="true" applicationName="/" requiresUniqueEmail="false" passwordFormat="Hashed" maxInvalidPasswordAttempts="5" minRequiredPasswordLength="7" minRequiredNonalphanumericCharacters="1" passwordAttemptWindow="10" passwordStrengthRegularExpression="" name="AspNetSqlMembershipProvider" type="System.Web.Security.SqlMembershipProvider, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;/providers&gt;
        &lt;/membership&gt;
        &lt;!--
            &lt;profile
                automaticSaveEnabled = "true" [true|false]
                enabled = "true" [true|false]
                defaultProvider = "AspNetSqlProfileProvider" [String]
                inherits = "" [String]
                &gt;
                &lt;providers&gt;
                    &lt;add
                        name = "" [String, Required, Collection Key]
                        type = "" [String, Required]
                    /&gt;
                &lt;/providers&gt;

            &lt;/profile&gt;
        --&gt;
        &lt;profile enabled="true" defaultProvider="AspNetSqlProfileProvider" inherits="" automaticSaveEnabled="true"&gt;
            &lt;providers&gt;
                &lt;clear /&gt;
                &lt;add connectionStringName="LocalSqlServer" applicationName="/" name="AspNetSqlProfileProvider" type="System.Web.Profile.SqlProfileProvider, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;/providers&gt;
            &lt;properties&gt;
                &lt;clear /&gt;
            &lt;/properties&gt;
        &lt;/profile&gt;
        &lt;!--
            &lt;roleManager
                enabled = "false" [true|false]
                createPersistentCookie = "false" [true|false]
                cacheRolesInCookie = "false" [true|false]
                cookieName = ".ASPXROLES" [String]
                cookieTimeout = "30"  [in Minutes][number]
                cookiePath = "/" [String]
                cookieRequireSSL = "false" [true|false]
                cookieSlidingExpiration = "true" [true|false]
                cookieProtection = "All" [None | Validation | Encryption | All]
                defaultProvider = "AspNetSqlRoleProvider" [String]
                domain = "" [String]
                maxCachedResults = "25" [number]
                &gt;
                &lt;providers&gt;
                    &lt;add
                        name = "" [String, Required, Collection Key]
                        type = "" [String, Required]
                    /&gt;
                &lt;/providers&gt;

            &lt;/roleManager&gt;
        --&gt;
        &lt;roleManager enabled="false" cacheRolesInCookie="false" cookieName=".ASPXROLES" cookieTimeout="30" cookiePath="/" cookieRequireSSL="false" cookieSlidingExpiration="true" cookieProtection="All" defaultProvider="AspNetSqlRoleProvider" createPersistentCookie="false" maxCachedResults="25"&gt;
            &lt;providers&gt;
                &lt;clear /&gt;
                &lt;add connectionStringName="LocalSqlServer" applicationName="/" name="AspNetSqlRoleProvider" type="System.Web.Security.SqlRoleProvider, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
                &lt;add applicationName="/" name="AspNetWindowsTokenRoleProvider" type="System.Web.Security.WindowsTokenRoleProvider, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;/providers&gt;
        &lt;/roleManager&gt;
    &lt;/system.web&gt;
    &lt;system.net&gt;
        &lt;!--
            &lt;authenticationModules
                &gt;
                &lt;add
                    type = "" [String, Required, Collection Key]
                /&gt;

            &lt;/authenticationModules&gt;
        --&gt;
        &lt;authenticationModules&gt;
            &lt;clear /&gt;
            &lt;add type="System.Net.NegotiateClient, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add type="System.Net.KerberosClient, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add type="System.Net.NtlmClient, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add type="System.Net.DigestClient, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add type="System.Net.BasicClient, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;/authenticationModules&gt;
        &lt;!--
            &lt;connectionManagement
                &gt;
                &lt;add
                    address = "" [String, Required, Collection Key]
                    maxconnection = "1" [number, Required]
                /&gt;

            &lt;/connectionManagement&gt;
        --&gt;
        &lt;connectionManagement&gt;
            &lt;clear /&gt;
        &lt;/connectionManagement&gt;
        &lt;!--
            &lt;defaultProxy
                enabled = "true" [true|false]
                useDefaultCredentials = "false" [true|false]
                &gt;
                &lt;bypasslist&gt;
                    &lt;add
                        address = "" [String, Required, Collection Key]
                    /&gt;
                &lt;/bypasslist&gt;

                &lt;module
                    type = "" [String]
                /&gt;
                &lt;proxy
                    autoDetect = "Unspecified" [False | True | Unspecified]
                    scriptLocation = "" 
                    bypassonlocal = "Unspecified" [False | True | Unspecified]
                    proxyaddress = "" 
                    usesystemdefault = "Unspecified" [False | True | Unspecified]
                /&gt;
            &lt;/defaultProxy&gt;
        --&gt;
        &lt;defaultProxy enabled="true" useDefaultCredentials="false"&gt;
            &lt;bypasslist&gt;
                &lt;clear /&gt;
            &lt;/bypasslist&gt;
            &lt;proxy autoDetect="Unspecified" bypassonlocal="Unspecified" usesystemdefault="Unspecified" /&gt;
        &lt;/defaultProxy&gt;
        &lt;!--
            &lt;requestCaching
                defaultPolicyLevel = "BypassCache" [Default | BypassCache | CacheOnly | CacheIfAvailable | Revalidate | Reload | NoCacheNoStore]
                disableAllCaching = "false" [true|false]
                isPrivateCache = "true" [true|false]
                unspecifiedMaximumAge = "1.00:00:00" [HH:MM:SS]
                &gt;
                &lt;defaultHttpCachePolicy
                    maximumAge = "10675199.02:48:05.4775807" [HH:MM:SS]
                    maximumStale = "-10675199.02:48:05.4775808" [HH:MM:SS]
                    minimumFresh = "-10675199.02:48:05.4775808" [HH:MM:SS]
                    policyLevel = "Default" [Default | BypassCache | CacheOnly | CacheIfAvailable | Revalidate | Reload | NoCacheNoStore | CacheOrNextCacheOnly | Refresh, Required]
                /&gt;
                &lt;defaultFtpCachePolicy
                    policyLevel = "Default" [Default | BypassCache | CacheOnly | CacheIfAvailable | Revalidate | Reload | NoCacheNoStore]
                /&gt;
            &lt;/requestCaching&gt;
        --&gt;
        &lt;requestCaching disableAllCaching="false" defaultPolicyLevel="BypassCache" isPrivateCache="true" unspecifiedMaximumAge="1.00:00:00"&gt;
            &lt;defaultHttpCachePolicy maximumAge="10675199.02:48:05.4775807" maximumStale="-10675199.02:48:05.4775808" minimumFresh="-10675199.02:48:05.4775808" policyLevel="Default" /&gt;
            &lt;defaultFtpCachePolicy policyLevel="Default" /&gt;
        &lt;/requestCaching&gt;
        &lt;!--
            &lt;settings
                &gt;
                &lt;httpWebRequest
                    maximumUnauthorizedUploadLength = "-1" [number]
                    maximumErrorResponseLength = "64" [number]
                    maximumResponseHeadersLength = "64" [number]
                    useUnsafeHeaderParsing = "false" [true|false]
                /&gt;
                &lt;ipv6
                    enabled = "false" [true|false]
                /&gt;
                &lt;servicePointManager
                    checkCertificateName = "true" [true|false]
                    checkCertificateRevocationList = "false" [true|false]
                    dnsRefreshTimeout = "120000" [number]
                    enableDnsRoundRobin = "false" [true|false]
                    expect100Continue = "true" [true|false]
                    useNagleAlgorithm = "true" [true|false]
                /&gt;
                &lt;socket
                    alwaysUseCompletionPortsForAccept = "false" [true|false]
                    alwaysUseCompletionPortsForConnect = "false" [true|false]
                /&gt;
                &lt;webProxyScript
                    downloadTimeout = "00:02:00" [HH:MM:SS]
                /&gt;
                &lt;performanceCounters
                    enabled = "false" [true|false]
                /&gt;
            &lt;/settings&gt;
        --&gt;
        &lt;settings&gt;
            &lt;httpWebRequest maximumResponseHeadersLength="64" maximumErrorResponseLength="64" maximumUnauthorizedUploadLength="-1" useUnsafeHeaderParsing="false" /&gt;
            &lt;ipv6 enabled="false" /&gt;
            &lt;servicePointManager checkCertificateName="true" checkCertificateRevocationList="false" dnsRefreshTimeout="120000" enableDnsRoundRobin="false" expect100Continue="true" useNagleAlgorithm="true" /&gt;
            &lt;socket alwaysUseCompletionPortsForAccept="false" alwaysUseCompletionPortsForConnect="false" /&gt;
            &lt;webProxyScript downloadTimeout="00:01:00" /&gt;
            &lt;performanceCounters enabled="false" /&gt;
        &lt;/settings&gt;
        &lt;!--
            &lt;webRequestModules
                &gt;
                &lt;add
                    prefix = "" [String, Required, Collection Key]
                    type = "" 
                /&gt;

            &lt;/webRequestModules&gt;
        --&gt;
        &lt;webRequestModules&gt;
            &lt;clear /&gt;
            &lt;add prefix="https:" type="System.Net.HttpRequestCreator, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add prefix="http:" type="System.Net.HttpRequestCreator, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add prefix="file:" type="System.Net.FileWebRequestCreator, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add prefix="ftp:" type="System.Net.FtpWebRequestCreator, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;/webRequestModules&gt;
        &lt;mailSettings&gt;
            &lt;!--
                &lt;smtp
                    deliveryMethod = "Network" [Network | SpecifiedPickupDirectory | PickupDirectoryFromIis]
                    from = "" [String]
                    &gt;
                    &lt;network
                        defaultCredentials = "false" [true|false]
                        host = "" [String]
                        password = "" [String]
                        port = "25" [number]
                        userName = "" [String]
                    /&gt;
                    &lt;specifiedPickupDirectory
                        pickupDirectoryLocation = "" [String]
                    /&gt;
                &lt;/smtp&gt;
            --&gt;
            &lt;smtp deliveryMethod="Network"&gt;
                &lt;network defaultCredentials="false" port="25" /&gt;
            &lt;/smtp&gt;
        &lt;/mailSettings&gt;
    &lt;/system.net&gt;
    &lt;system.transactions&gt;
        &lt;!--
            &lt;defaultSettings
                distributedTransactionManagerName = "" [String]
                timeout = "00:01:00" [HH:MM:SS]
            /&gt;
        --&gt;
        &lt;defaultSettings distributedTransactionManagerName="" timeout="00:01:00" /&gt;
        &lt;!--
            &lt;machineSettings
                maxTimeout = "00:10:00" [HH:MM:SS]
            /&gt;
        --&gt;
        &lt;machineSettings maxTimeout="00:10:00" /&gt;
    &lt;/system.transactions&gt;
    &lt;system.xml.serialization&gt;
        &lt;!--
            &lt;dateTimeSerialization
                mode = "Roundtrip" [Default | Roundtrip | Local]
            /&gt;
        --&gt;
        &lt;dateTimeSerialization mode="Roundtrip" /&gt;
        &lt;!--
            &lt;schemaImporterExtensions
                &gt;
                &lt;add
                    name = "" [String, Required, Collection Key]
                    type = "" [Required]
                /&gt;

            &lt;/schemaImporterExtensions&gt;
        --&gt;
        &lt;schemaImporterExtensions&gt;
            &lt;clear /&gt;
            &lt;add name="SqlTypesSchemaImporterChar" type="System.Data.SqlTypes.TypeCharSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterNChar" type="System.Data.SqlTypes.TypeNCharSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterVarChar" type="System.Data.SqlTypes.TypeVarCharSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterNVarChar" type="System.Data.SqlTypes.TypeNVarCharSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterText" type="System.Data.SqlTypes.TypeTextSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterNText" type="System.Data.SqlTypes.TypeNTextSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterVarBinary" type="System.Data.SqlTypes.TypeVarBinarySchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterBinary" type="System.Data.SqlTypes.TypeBinarySchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterImage" type="System.Data.SqlTypes.TypeVarImageSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterDecimal" type="System.Data.SqlTypes.TypeDecimalSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterNumeric" type="System.Data.SqlTypes.TypeNumericSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterBigInt" type="System.Data.SqlTypes.TypeBigIntSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterInt" type="System.Data.SqlTypes.TypeIntSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterSmallInt" type="System.Data.SqlTypes.TypeSmallIntSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterTinyInt" type="System.Data.SqlTypes.TypeTinyIntSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterBit" type="System.Data.SqlTypes.TypeBitSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterFloat" type="System.Data.SqlTypes.TypeFloatSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterReal" type="System.Data.SqlTypes.TypeRealSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterDateTime" type="System.Data.SqlTypes.TypeDateTimeSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterSmallDateTime" type="System.Data.SqlTypes.TypeSmallDateTimeSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterMoney" type="System.Data.SqlTypes.TypeMoneySchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterSmallMoney" type="System.Data.SqlTypes.TypeSmallMoneySchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;add name="SqlTypesSchemaImporterUniqueIdentifier" type="System.Data.SqlTypes.TypeUniqueIdentifierSchemaImporterExtension, System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
        &lt;/schemaImporterExtensions&gt;
        &lt;!--
            &lt;xmlSerializer
                checkDeserializeAdvances = "false" [true|false]
                tempFilesLocation = "" [String]
            /&gt;
        --&gt;
        &lt;xmlSerializer checkDeserializeAdvances="false" /&gt;
    &lt;/system.xml.serialization&gt;
    &lt;system.codedom&gt;
        &lt;!-- 
            &lt;compiler 
               language = "[string]" - semicolon separated list of friendly names.  Notice these have to be unique   across all compilers in this section.  They are case insensitive.
               extensions = "[string]" - semicolon separated list of source file extensions (should include the '.'). Notice these have to be unique   across all compilers in this section.  They are case insensitive.
               type = "[Fully qualified type Name]"
               warningLevel = "[integer]" - warning level to pass to the compilers.
               compilerOptions = "[string]" - options to pass to the compilers.
            /&gt;
        --&gt;
        &lt;compilers&gt;
            &lt;compiler language="c#;cs;csharp" extension=".cs" type="Microsoft.CSharp.CSharpCodeProvider, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;compiler language="vb;vbs;visualbasic;vbscript" extension=".vb" type="Microsoft.VisualBasic.VBCodeProvider, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /&gt;
            &lt;compiler language="js;jscript;javascript" extension=".js" type="Microsoft.JScript.JScriptCodeProvider, Microsoft.JScript, Version=8.0.1100.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;compiler language="vj#;vjs;vjsharp" extension=".jsl;.java" type="Microsoft.VJSharp.VJSharpCodeProvider, VJSharpCodeProvider, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
            &lt;compiler language="c++;mc;cpp" extension=".h" type="Microsoft.VisualC.CppCodeProvider, CppCodeProvider, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;
        &lt;/compilers&gt;
    &lt;/system.codedom&gt;
&lt;/configuration&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Recovery_Model</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Recovery_Model</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--Simple Recovery Model
=====================
--So with the above introduction, it is easiest to talk about Simple Recovery model first. In this model, 
--	you are telling SQL Server: "I am fine with you using your transaction log file for crash and restart recovery..." 
--	(You really have no choice there. Look up ACID properties and that should make sense quickly.) 
--	"...but once you no longer need it for that crash/restart recovery purpose, go ahead and reuse the log file."

--SQL Server listens to this request in Simple Recovery and it only keeps the information it needs to do crash/restart recovery. 
--	Once SQL Server is sure it can recover because data is hardened to the data file (more or less), 
--	the data that has been hardened is no longer necessary in the log and is marked for truncation - which means it gets re-used.

--Full Recovery Model
===================
--With Full Recovery, you are telling SQL Server that you want to be able to recover to a specific point in time, 
--	as long as your log file is available or to a specific point in time that is covered by a log backup. 
--	In this case when SQL Server reaches the point where it would be safe to truncate the log file in Simple Recovery Model, 
--	it will not do that. Instead It lets the log file continue to grow and will allow it to keep growing, 
--	until you take a log backup (or run out of space on your log file drive) under normal circumstances.

--If you just switch into Full Recovery mode, but never take an initial Full Backup, 
--	SQL Server will not honor your request to be in Full Recovery model. 
--	Your transaction log will continue to operate as it has in Simpleuntil you switch to Full Recovery Model AND take your first Full Backup.

--Full Recovery Model without log backups is bad. - MOST common reason for uncontrolled Log Growth
=================================================================================================
--So, that's the most common reason for uncontrolled log growth? Answer: 
--	Being in Full Recovery mode without having any log backups.

-- each new database gets its initial recovery model setting by looking at the model database.

--Model's initial recovery model setting is always Full Recovery Model - until and unless someone changes that. 
--	So you could say the "default Recovery Model" is Full. 
--	Many people are not aware of this and have their databases running in Full Recovery Model with no log backups, 
--	and therefore a transaction log file much larger than necessary. 
--	This is why it is important to change defaults when they don't work for your organization and its needs)

--Second most common reason for Log Growth: Long Running Transactions
=====================================================================

--If you have a transaction that takes a long time or does a lot of changes, the log cannot truncate on checkpoint 
--	for any of the changes that are still in open transactions or that have started since that transaction started.

--This means that a big delete, deleting millions of rows in one delete statement is one transaction 
--	and the log cannot do any truncating until that whole delete is done. 
--	In Full Recovery Model, this delete is logged and that could be a lot of log records. 
--	Same thing with Index optimization work during maintenance windows. 
--	It also means that poor transaction management and not watching for and closing open transactions can really hurt you and your log file.

--What can I do about these long running transactions?
--	Properly sizing your log file to account for the worst case scenario - like your maintenance or known large operations.
--	see this link: http://www.sqlskills.com/blogs/kimberly/8-steps-to-better-transaction-log-throughput/

--	Watching your usage of transactions. 
--	Don't start a transaction in your application server and start having long conversations with SQL Server and risk leaving one open too long.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MVC_RAZOR_in-line_helper_methods</Category>
        <Language>ASP</Language>
        <Public>false</Public>
        <Name>Format_amount_based_on_value</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MVC_RAZOR_in-line_helper_methods</Category>
          <Language>ASP</Language>
          <Public>false</Public>
          <Name>Format_amount_based_on_value</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>@{
    ViewBag.Title = "Home Page";
    //Layout = "MyLayout.cshtml";
}


&lt;div class="row"&gt;
    &lt;div class="col-md-6 margin-top-20"&gt;
        &lt;a href="#" class="btn btn-primary btn-large btn-block"&gt;&lt;span class="glyphicon glyphicon-circle-arrow-down"&gt;&lt;/span&gt; Withdrawal&lt;/a&gt;
        &lt;a href="#" class="btn btn-primary btn-large btn-block"&gt;&lt;span class="glyphicon glyphicon-flash"&gt;&lt;/span&gt; Quick Cash $100&lt;/a&gt;
        &lt;a href="#" class="btn btn-primary btn-large btn-block"&gt;&lt;span class="glyphicon glyphicon-question-sign"&gt;&lt;/span&gt; Balance Inquiry&lt;/a&gt;
    &lt;/div&gt;
    &lt;div class="col-md-6 margin-top-20"&gt;
        &lt;a href="#" class="btn btn-primary btn-large btn-block"&gt;&lt;span class="glyphicon glyphicon-print"&gt;&lt;/span&gt; Print Statement&lt;/a&gt;
        &lt;a href="#" class="btn btn-primary btn-large btn-block"&gt;&lt;span class="glyphicon glyphicon-transfer"&gt;&lt;/span&gt; Transfer Funds&lt;/a&gt;
        &lt;a href="#" class="btn btn-primary btn-large btn-block"&gt;&lt;span class="glyphicon glyphicon-circle-arrow-up"&gt;&lt;/span&gt; Deposit&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;


@*
    You are using @Request.Browser.Browser, and that's OK! Email us at support@mvcatm.com if you have any problems. Or send us a tweet @@mvcatm.

    @{var amounts = new List&lt;Decimal&gt;{100, 25.50m, -40, 275.99m};				//-- C# 'm' suffix to make sure they are not treated as doubles
    }

    &lt;ul&gt;
        @foreach(decimal amount in amounts)									//-- C#  and then mix with markup
        {
            &lt;li&gt;@formatAmount(amount)&lt;/li&gt;									//-- add markup into codeblocks
            &lt;text&gt;plain text&lt;/text&gt;											//-- to prevent it from interpreting this as C#: wrap it in &lt;text&gt;
            @:plain text													//-- to prevent it from interpreting this as C#: preceed it with "@"
        }
    &lt;/ul&gt;

    @helper formatAmount(decimal amount)
    {
        var color = "green";													//-- C# 
        if (amount &lt; 0)															//-- C# 
        {
            color = "red";														//-- C# 
        }
        &lt;span style="color:@color"&gt;@String.Format("{0:c}", amount)&lt;/span&gt;		&lt;!-- Markup with @ to switch back to C#, formatting as currency --&gt;
    }
*@
   
@section scripts {
    &lt;script&gt;var testing = true;&lt;/script&gt;
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Outlook</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>about_Outlook</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Outlook</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>about_Outlook</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_Outlook


command switches
https://www.howto-outlook.com/howto/commandlineswitches.htm</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWER_BI</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>Errors_Solutions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWER_BI</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>Errors_Solutions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
1] -------------------------------------------------------
error was something like this:
Details: "An error happened while reading data from the provider: 
	'Could not load file or assembly 
		'System.EnterpriseServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' 
	or one of its dependencies. 
	Either a required impersonation level was not provided, 
		or the provided impersonation level is invalid. (Exception from HRESULT: 0x80070542)'"

Executable:
	C:\Program Files\Microsoft Power BI Desktop RS\bin\PBIDesktop.exe
REF
	https://community.powerbi.com/t5/Issues/SQL-connect-error/idi-p/219982
Solution:
	- Find the executable =&gt; right click =&gt;  choose properties &gt;&gt;&gt; 
		Compatibility tab &gt;&gt;&gt; Change settings for all Users 
	- Faced the same issue recently and "Run as Administrator" mode for PBI Desktop resolves the issue. 

2] -------------------------------------------------------
Error when trying to DirectQuery to SQL server:

"Alternate credentials for Windows authentication is not supported in DirectQuery mode. 
	Use your current windows credentials, 
	supply a database credential or switch to import mode."

Solution:
 go to File-&gt;Options and settings-&gt;Data source settings, 
 then edit your data source [Edit Permissions...]
 and specify a valid Windows credential or database credential. 
 
 After that, click "Refresh" button in the PBIX file.
 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWER_BI</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>from_SQl_Stored_Procedure</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWER_BI</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>from_SQl_Stored_Procedure</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://community.powerbi.com/t5/Desktop/Use-SQL-Store-Procedure-in-Power-BI/td-p/20269
-----------------------------------------------------------------------------------------

Try again using Import mode or just use a SELECT statement directly.
-----------------------------------------------------

you can use openquery. Follwoing syntax will work with both import data and direct query
 

SELECT *
FROM OPENQUERY ([server name],
'EXEC dbname.dbo.spname @parametername = ''R1''');


-------------------------------------
OPENQUERY OPTION and I am now getting the below message:
 
Details: "Microsoft SQL: Server 'sv375002\lt1201' is not configured for DATA ACCESS."
 
You would need to enable direct access on your SQL Server. You can check what it is currently set at by running this:

select server_id, name, is_data_access_enabled from sys.servers

But I would definitely check with your DB team (if you aren't) before switching anything.
To enable you would execute EXEC sp_serveroption '&lt;Your ServerName&gt;', 'DATA ACCESS', TRUE

--------------------------------------------------------------------------------------------

 have discovered that you don't need to change any database settings or use OpenQuery. If you wrap your stored procedure in a variable you can import the data using a sproc (Doesn't work in Direct Query, only import)
 
example:
 
DECLARE @sqlCommand varchar(1000)
SET @sqlCommand = 'dbo.Testproc'
EXEC (@sqlCommand)

--Example w/ Parms:

DECLARE @sqlCommand varchar(1000)
SET @sqlCommand = 'dbo.MyRNorm 100,25,11'
EXEC (@sqlCommand)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWER_BI</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>Theme_seeWhat_is_beingUsed</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWER_BI</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>Theme_seeWhat_is_beingUsed</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>when you import the theme file, 
this file will be imported into pbix file.and this list of Built-in report themes are also be updated in September 2018.

So you could try this way to see the theme being used:

save the pbix file and then rename the .pbix file to a .zip file, 
extract it to a local folder, 
and then check the file path Report\StaticResources\SharedResources

Importing Report Themes
To import a custom Report Theme, select the Switch Theme button from the Home ribbon. Then select Import Theme from the drop-down menu.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Empty_OU</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Empty_OU</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://www.adaxes.com/blog/cleanup-active-directory-with-powershell.html


#requires -version 2
&lt;#
.SYNOPSIS
  Find and manage empty Active Directory OUs.
.DESCRIPTION
  This script allows you to find and manage empty organizational units within your AD environment. This script also allows
  for the management of found OUs. Management of empty OUs includes one or more of the following options:
    - Reporting
    - Deleting
.PARAMETER SearchScope
  Optional. Specifies an Active Directory Path to search under. This is primarily used to narrow down your search within a certain OU and it's children.
  Search Scope must be specfied in LDAP format. If not specified, the default search scope is the root of the domain.
  Example: -SearchScope "OU=MGT,DC=testlab,DC=com"
.PARAMETER ReportFilePath
  Optional. This is the location where the report of empty OUs will be saved to. If this parameter is not specified, the default location
  the report is saved to is C:\EmptyOUs.csv.
  Note: When specifying the file path, you MUST include the file name with the extension of .csv. Example: 'C:\MyReport.csv'.
.PARAMETER DeleteObjects
  Optional. If this parameter is specified, this script will delete the empty OUs found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT delete any empty OUs found.
  Note: If the OU to be deleted has been marked with PreventFromAccidentialDeletion, then this script will return an error.
.INPUTS
  None.
.OUTPUTS
  Report of empty OUs found. See ReportFilePath parameter for more information.
.NOTES
  Version:        1.0
  Author:         Luca Sturlese
  Creation Date:  16.07.2016
  Purpose/Change: Initial script development
.EXAMPLE
  Execution of script using default parameters. Default execution performs reporting of empty OUs only, not deleting any objects.
  By default the report is saved in C:\.
  .\Find-ADEmptyOU.ps1
.EXAMPLE
  Reporting and deleting all empty OUs found within the MGT OU. Store the report in C:\Reports.
  .\Find-ADEmptyOU.ps1 -SeachScope "OU=MGT,DC=testlab,DC=com" -ReportFilePath 'C:\Reports\DeletedOUs.csv' -DeleteObjects
#&gt;

#---------------------------------------------------------[Script Parameters]------------------------------------------------------

Param (
  [Parameter(Mandatory = $false)][string]$SearchScope,
  [Parameter(Mandatory = $false)][string]$ReportFilePath = 'C:\EmptyOUs.csv',
  [Parameter(Mandatory = $false)][switch]$DeleteObjects = $false
)

#---------------------------------------------------------[Initialisations]--------------------------------------------------------

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'

#Import Modules &amp; Snap-ins
Import-Module ActiveDirectory

#----------------------------------------------------------[Declarations]----------------------------------------------------------



#-----------------------------------------------------------[Functions]------------------------------------------------------------

Function Find-Objects {
  Param ()

  Begin {
    Write-Host "Finding empty OUs based on search scope specified..."
  }

  Process {
    Try {
      If($SearchScope) {
        $global:Results = Get-ADOrganizationalUnit -Filter * -SearchBase $SearchScope | ForEach-Object { If ( !( Get-ADObject -Filter * -SearchBase $_ -SearchScope OneLevel) ) { $_ } } | Select-Object Name, DistinguishedName
      } Else {
        $global:Results = Get-ADOrganizationalUnit -Filter * | ForEach-Object { If ( !( Get-ADObject -Filter * -SearchBase $_ -SearchScope OneLevel) ) { $_ } } | Select-Object Name, DistinguishedName
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }

    End {
      If ($?) {
        Write-Host 'Completed Successfully.'
        Write-Host ' '
      }
    }
  }
}

Function Create-Report {
  Param ()

  Begin {
    Write-Host "Creating report of empty OUs in specified path [$ReportFilePath]..."
  }

  Process {
    Try {
      #Check file path to ensure correct
      If ($ReportFilePath -notlike '*.csv') {
        $ReportFilePath = Join-Path -Path $ReportFilePath -ChildPath '\EmptyOUs.csv'
      }

      # Create CSV report
      $global:Results | Export-Csv $ReportFilePath -NoTypeInformation
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Delete-Objects {
  Param ()

  Begin {
    Write-Host 'Deleting empty OUs...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Remove-ADOrganizationalUnit -Identity $Item.DistinguishedName -Confirm:$false
        Write-Host "$($Item.Name) - Deleted"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

#-----------------------------------------------------------[Execution]------------------------------------------------------------

Find-Objects
Create-Report

If ($DeleteObjects) {
  Delete-Objects
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>EmptyGroups_save_to_CSV</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>EmptyGroups_save_to_CSV</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://www.adaxes.com/blog/cleanup-active-directory-with-powershell.html


#requires -version 2
&lt;#
.SYNOPSIS
  Find and manage empty Active Directory groups.
.DESCRIPTION
  This script allows you to find and manage empty security and distribution groups withing your AD environment. This script also allows
  for the management of found groups. Management of empty groups includes one or more of the following options:
    - Reporting
    - Deleting
.PARAMETER SearchScope
  Optional. Specifies an Active Directory Path to search under. This is primarily used to narrow down your search within a certain OU and it's children.
  Search Scope must be specfied in LDAP format. If not specified, the default search scope is the root of the domain.
  Example: -SearchScope "OU=GROUPS,DC=testlab,DC=com"
.PARAMETER ReportFilePath
  Optional. This is the location where the report of empty groups will be saved to. If this parameter is not specified, the default location
  the report is saved to is C:\EmptyGroups.csv.
  Note: When specifying the file path, you MUST include the file name with the extension of .csv. Example: 'C:\MyReport.csv'.
.PARAMETER DeleteObjects
  Optional. If this parameter is specified, this script will delete the empty groups found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT delete any empty groups found.
.INPUTS
  None.
.OUTPUTS
  Report of empty groups found. See ReportFilePath parameter for more information.
.NOTES
  Version:        1.0
  Author:         Luca Sturlese
  Creation Date:  16.07.2016
  Purpose/Change: Initial script development
.EXAMPLE
  Execution of script using default parameters. Default execution performs reporting of empty AD gruops only, not deleting any objects.
  By default the report is saved in C:\.
  .\Find-ADEmptyGroups.ps1
.EXAMPLE
  Reporting and deleting all empty groups found within the GROUPS OU. Store the report in C:\Reports.
  .\Find-ADEmptyGroups.ps1 -SeachScope "OU=GROUPS,DC=testlab,DC=com" -ReportFilePath 'C:\Reports\DeletedGroups.csv' -DeleteObjects
#&gt;

#---------------------------------------------------------[Script Parameters]------------------------------------------------------

Param (
  [Parameter(Mandatory = $false)][string]$SearchScope,
  [Parameter(Mandatory = $false)][string]$ReportFilePath = 'C:\EmptyGroups.csv',
  [Parameter(Mandatory = $false)][switch]$DeleteObjects = $false
)

#---------------------------------------------------------[Initialisations]--------------------------------------------------------

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'

#Import Modules &amp; Snap-ins
Import-Module ActiveDirectory

#----------------------------------------------------------[Declarations]----------------------------------------------------------



#-----------------------------------------------------------[Functions]------------------------------------------------------------

Function Find-Objects {
  Param ()

  Begin {
    Write-Host "Finding empty groups based on search scope specified..."
  }

  Process {
    Try {
      If($SearchScope) {
        $global:Results = Get-ADGroup -Filter { Members -notlike "*" } -SearchBase $SearchScope | Select-Object Name, GroupCategory, DistinguishedName
      } Else {
        $global:Results = Get-ADGroup -Filter { Members -notlike "*" } | Select-Object Name, GroupCategory, DistinguishedName
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }

    End {
      If ($?) {
        Write-Host 'Completed Successfully.'
        Write-Host ' '
      }
    }
  }
}

Function Create-Report {
  Param ()

  Begin {
    Write-Host "Creating report of empty groups in specified path [$ReportFilePath]..."
  }

  Process {
    Try {
      #Check file path to ensure correct
      If ($ReportFilePath -notlike '*.csv') {
        $ReportFilePath = Join-Path -Path $ReportFilePath -ChildPath '\EmptyGroups.csv'
      }

      # Create CSV report
      $global:Results | Export-Csv $ReportFilePath -NoTypeInformation
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Delete-Objects {
  Param ()

  Begin {
    Write-Host 'Deleting empty groups...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Remove-ADGroup -Identity $Item.DistinguishedName -Confirm:$false
        Write-Host "$($Item.Name) - Deleted"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

#-----------------------------------------------------------[Execution]------------------------------------------------------------

Find-Objects
Create-Report

If ($DeleteObjects) {
  Delete-Objects
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>gig-RemotelyQueryUserProfile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>gig-RemotelyQueryUserProfile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function gig-RemotelyQueryUserProfile {
                                 &lt;#
                                   .Synopsis
                                    gets a list of user profiles on a computer
                                   .Description
                                    From: https://4sysops.com/archives/remotely-query-user-profile-information-with-powershell/

                                   .Parameter 
                                    ValueFromPipeline = 
                                   .Parameter 
                                    ComputerName = defaults to local
                                   .Notes
                                   .EXAMPLE: 
                                   Example 1 - {for local} 
                                   gig-RemotelyQueryUser  
                                            
                                            &gt; gig-RemotelyQueryUser -ComputerName WBSQL1   {for remote}
                                    AUTHOR: glenn garson, JPHSA
                                    LASTEDIT: 12/28/2016 13:45:05
                                    KEYWORDS:
                                    HSG: 
                                   .Link
                                     Http://www.ScriptingGuys.com
                                 #'Requires -Version 2.0
                                 #&gt;
								[cmdletbinding()]
                                param (
                                [parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
                                [string[]]$ComputerName = $env:computername
                                )            
 
                                foreach ($Computer in $ComputerName) {
                                 $Profiles = Get-WmiObject -Class Win32_UserProfile -Computer $Computer -ea 0
                                 foreach ($profile in $profiles) {
                                  try {
                                      $objSID = New-Object System.Security.Principal.SecurityIdentifier($profile.sid)
                                      $objuser = $objsid.Translate([System.Security.Principal.NTAccount])
                                      $objusername = $objuser.value
                                  } catch {
                                        $objusername = $profile.sid
                                  }
                                  switch($profile.status){
                                   1 { $profileType="Temporary" }
                                   2 { $profileType="Roaming" }
                                   4 { $profileType="Mandatory" }
                                   8 { $profileType="Corrupted" }
                                   default { $profileType = "LOCAL" }
                                  }
                                  $User = $objUser.Value
                                  $ProfileLastUseTime = ([WMI]"").Converttodatetime($profile.lastusetime)
                                  $OutputObj = New-Object -TypeName PSobject
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ComputerName -Value $Computer.toUpper()
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfileName -Value $objusername
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfilePath -Value $profile.localpath
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfileType -Value $ProfileType
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name IsinUse -Value $profile.loaded
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name IsSystemAccount -Value $profile.special
                                  $OutputObj
  
                                 }
                                }
							}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>InActive_Computers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>InActive_Computers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.adaxes.com/blog/cleanup-active-directory-with-powershell.html


#requires -version 2
&lt;#
.SYNOPSIS
  Find and manage inactive Active Directory computer objects.
.DESCRIPTION
  This script allows you to specify the criteria required to identify inactive computer objects within your AD environment. This script also allows
  for the management of found computers. Management of computer objects includes one or more of the following options:
    - Reporting
    - Disabling computer objects
    - Deleting computer objects
.PARAMETER SearchScope
  Optional. Determines the search scope of what type of computer object you would like to include in the inactive computers search. Options available are:
   - All                        : Default option. All computer including never logged on computer objects.
   - OnlyInactiveComputers      : Only inactive computers. These are computers that have logged on in the past but have not logged on since DaysInactive.
   - OnlyNeverLoggedOn          : Only never logged on objects. This option excludes computers that have logged on before.
   Note: If not specified, the default search scope is All (i.e. all inactive and never logged on computer objects).
.PARAMETER DaysInactive
  Optional. The number of days a computer hasn't logged into the domain for in order to classify it as inactive. The default option is 90
  days, which means any computer that hasn't logged into the domain for 90 days or more is considered inactive and therefore managed by this
  script.
.PARAMETER ReportFilePath
  Optional. This is the location where the report of inactive computer objects will be saved to. If this parameter is not specified, the default location
  the report is saved to is C:\InactiveComputers.csv.
  Note: When specifying the file path, you MUST include the file name with the extension of .csv. Example: 'C:\MyReport.csv'.
.PARAMETER DisableObjects
  Optional. If this parameter is specified, this script will disable the inactive computer objects found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT disable any inactive computers found.
.PARAMETER DeleteObjects
  Optional. If this parameter is specified, this script will delete the inactive computer objects found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT delete any inactive computers found.
.INPUTS
  None.
.OUTPUTS
  Report of inactive computer objects found. See ReportFilePath parameter for more information.
.NOTES
  Version:        1.0
  Author:         Luca Sturlese
  Creation Date:  16.07.2016
  Purpose/Change: Initial script development
.EXAMPLE
  Execution of script using default parameters. Default execution performs reporting of inactive AD computers only, not disabling or deleting any objects.
  By default the report is saved in C:\.
  .\Find-ADInactiveComputers.ps1
.EXAMPLE
  Reporting and disabling all inactive computer objects, except never logged on objects. Storing the report in C:\Reports.
  .\Find-ADInactiveComputers.ps1 -SeachScope OnlyInactiveComputers -ReportFilePath 'C:\Reports\DisabledComputers.csv' -DisableObjects
.EXAMPLE
  Find &amp; delete all inactive computer objects that haven't logged in for the last 30 days. Include never logged on objects in this search.
  .\Find-ADInactiveComputers.ps1 -SeachScope All -DaysInactive 30 -DeleteObjects
#&gt;

#---------------------------------------------------------[Script Parameters]------------------------------------------------------

Param (
  [Parameter(Mandatory = $false)][string][ValidateSet('All', 'OnlyInactiveComputers', 'OnlyNeverLoggedOn')]$SearchScope = 'All',
  [Parameter(Mandatory = $false)][int]$DaysInactive = 90,
  [Parameter(Mandatory = $false)][string]$ReportFilePath = 'C:\Inactivecomputers.csv',
  [Parameter(Mandatory = $false)][switch]$DisableObjects = $false,
  [Parameter(Mandatory = $false)][switch]$DeleteObjects = $false
)

#---------------------------------------------------------[Initialisations]--------------------------------------------------------

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'

#Import Modules &amp; Snap-ins
Import-Module ActiveDirectory

#----------------------------------------------------------[Declarations]----------------------------------------------------------

#Set Inactive Date:
$InactiveDate = (Get-Date).Adddays(-($DaysInactive))

#-----------------------------------------------------------[Functions]------------------------------------------------------------

Function Find-Objects {
  Param ()

  Begin {
    Write-Host "Finding inactive computer objects based on search scope specified [$SearchScope]..."
  }

  Process {
    Try {
      Switch ($SearchScope) {
        'All' {
          $global:Results = Get-ADComputer -Filter { (LastLogonDate -lt $InactiveDate -or LastLogonDate -notlike "*") -and (Enabled -eq $true) } -Properties LastLogonDate | Select-Object Name, LastLogonDate, DistinguishedName
        }

        'OnlyInactiveComputers' {
          $global:Results = Get-ADComputer -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true } -Properties LastLogonDate | Select-Object Name, LastLogonDate, DistinguishedName
        }

        'OnlyNeverLoggedOn' {
          $global:Results = Get-ADComputer -Filter { LastLogonDate -notlike "*" -and Enabled -eq $true } -Properties LastLogonDate | Select-Object Name, LastLogonDate, DistinguishedName
        }

        Default {
          Write-Host -BackgroundColor Red "Error: An unknown error occcurred. Can't determine search scope. Exiting."
          Break
        }
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }

    End {
      If ($?) {
        Write-Host 'Completed Successfully.'
        Write-Host ' '
      }
    }
  }
}

Function Create-Report {
  Param ()

  Begin {
    Write-Host "Creating report of inactive computers in specified path [$ReportFilePath]..."
  }

  Process {
    Try {
      #Check file path to ensure correct
      If ($ReportFilePath -notlike '*.csv') {
        $ReportFilePath = Join-Path -Path $ReportFilePath -ChildPath '\InactiveComputers.csv'
      }

      # Create CSV report
      $global:Results | Export-Csv $ReportFilePath -NoTypeInformation
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Disable-Objects {
  Param ()

  Begin {
    Write-Host 'Disabling inactive computers...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Set-ADComputer -Identity $Item.DistinguishedName -Enabled $false
        Write-Host "$($Item.Name) - Disabled"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Delete-Objects {
  Param ()

  Begin {
    Write-Host 'Deleting inactive computers...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Remove-ADComputer -Identity $Item.DistinguishedName -Confirm:$false
        Write-Host "$($Item.Name) - Deleted"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

#-----------------------------------------------------------[Execution]------------------------------------------------------------

Find-Objects
Create-Report

If ($DisableObjects) {
  Disable-Objects
}

If ($DeleteObjects) {
  Delete-Objects
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Inactive_Users</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Inactive_Users</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://www.adaxes.com/blog/cleanup-active-directory-with-powershell.html



#requires -version 2
&lt;#
.SYNOPSIS
  Find and manage inactive Active Directory users.
.DESCRIPTION
  This script allows you to specify the criteria required to identify inactive users within your AD environment. This script also allows
  for the management of found users. Management of users includes one or more of the following options:
    - Reporting
    - Disabling Users
    - Deleting Users
.PARAMETER SearchScope
  Optional. Determines the search scope of what type of user you would like to include in the inactive user search. Options available are:
   - All                        : Default option. All user types including all standard users, service accounts and never logged on accounts.
   - OnlyInactiveUsers          : Only standard user accounts. This option excludes service accounts and never logged on accounts.
   - OnlyServiceAccounts        : Only server accounts. This option excludes standard user accounts and never logged on accounts.
   - OnlyNeverLoggedOn          : Only never logged on accounts. This option excludes standard user accounts and service accounts.
   - AllExceptServiceAccounts   : All user account types excluding service accounts.
   - AllExceptNeverLoggedOn     : All user account types excluding never logged on accounts.
   Note: If not specified, the default search scope is All (i.e. all user accounts, service accounts and never logged on accounts).
.PARAMETER DaysInactive
  Optional. The number of days a user account hasn't logged into the domain for in order to classify it as inactive. The default option is 90
  days, which means any user account that hasn't logged into the domain for 90 days or more is considered inactive and therefore managed by this
  script.
.PARAMETER ServiceAccountIdentifier
  Optional. The username prefix or postfix that is used to indetify a service account from a standard user account. The default option is 'svc'.
  Determining whether an account is a service account is useful in order to be able to include or exclude service accounts from the search scope.
  Note: For more information see the help information on the parameter SearchScope. 
  Example: All accounts with the prefix or postfix of svc (e.g. svc-MyAccount or MyAccount-svc) are identified as service accounts and can
  therefore be included or exclueded from the search scope.
.PARAMETER ReportFilePath
  Optional. This is the location where the report of inactive users will be saved to. If this parameter is not specified, the default location the
  report is saved to is C:\InactiveUsers.csv.
  Note: When specifying the file path, you MUST include the file name with the extension of .csv. Example: 'C:\MyReport.csv'.
.PARAMETER DisableUsers
  Optional. If this parameter is specified, this script will disable the inactive users found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT disable any inactive users found.
.PARAMETER DeleteUsers
  Optional. If this parameter is specified, this script will delete the inactive users found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT delete any inactive users found.
.INPUTS
  None.
.OUTPUTS
  Report of inactive users found. See ReportFilePath parameter for more information.
.NOTES
  Version:        1.0
  Author:         Luca Sturlese
  Creation Date:  16.07.2016
  Purpose/Change: Initial script development
.EXAMPLE
  Execution of script using default parameters. Default execution performs reporting of inactive AD user only, not disabling or deleting any accounts.
  By default the report is saved in C:\.
  .\Find-ADInactiveUsers.ps1
.EXAMPLE
  Reporting and disabling all user accounts, except never logged on accounts. Storing the report in C:\Reports.
  .\Find-ADInactiveUsers.ps1 -SeachScope AllExceptNeverLoggedOn -ReportFilePath 'C:\Reports\DisabledUsers.csv' -DisableUsers
.EXAMPLE
  Find &amp; delete all inactive users (not service accounts) that haven't logged in for the last 30 days. Include never logged on accounts in this search.
  .\Find-ADInactiveUsers.ps1 -SeachScope AllExceptServiceAccounts -DaysInactive 30 -DeleteUsers
.EXAMPLE
  Delete all user accounts that have never been logged into. Store the report in C:\Reports.
  .\Find-ADInactiveUsers.ps1 -SeachScope OnlyNeverLoggedOn -ReportFilePath 'C:\Reports\NotLoggedOnAccounts.csv' -DeleteUsers
#&gt;

#---------------------------------------------------------[Script Parameters]------------------------------------------------------

Param (
  [Parameter(Mandatory = $false)][string][ValidateSet('All', 'OnlyInactiveUsers', 'OnlyServiceAccounts', 'OnlyNeverLoggedOn', 'AllExceptServiceAccounts', 'AllExceptNeverLoggedOn')]$SearchScope = 'All',
  [Parameter(Mandatory = $false)][int]$DaysInactive = 90,
  [Parameter(Mandatory = $false)][string]$ServiceAccountIdentifier = 'svc',
  [Parameter(Mandatory = $false)][string]$ReportFilePath = 'C:\InactiveUsers.csv',
  [Parameter(Mandatory = $false)][switch]$DisableUsers = $false,
  [Parameter(Mandatory = $false)][switch]$DeleteUsers = $false
)

#---------------------------------------------------------[Initialisations]--------------------------------------------------------

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'

#Import Modules &amp; Snap-ins
Import-Module ActiveDirectory

#----------------------------------------------------------[Declarations]----------------------------------------------------------

#Set Inactive Date:
$InactiveDate = (Get-Date).Adddays(-($DaysInactive))

#-----------------------------------------------------------[Functions]------------------------------------------------------------

Function Find-Accounts {
  Param ()

  Begin {
    Write-Host "Finding inactive user accounts based on search scope specified [$SearchScope]..."
  }

  Process {
    Try {
      #Set Service Account Identifier
      $ServiceAccountIdentifier = '*' + $ServiceAccountIdentifier + '*'

      Switch ($SearchScope) {
        'All' {
          $global:Results = Get-ADUser -Filter { (LastLogonDate -lt $InactiveDate -or LastLogonDate -notlike "*") -and (Enabled -eq $true) } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'OnlyInactiveUsers' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true -and SamAccountName -notlike $ServiceAccountIdentifier } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'OnlyServiceAccounts' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true -and SamAccountName -like $ServiceAccountIdentifier } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'OnlyNeverLoggedOn' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -notlike "*" -and Enabled -eq $true } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'AllExceptServiceAccounts' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true -and SamAccountName -notlike $ServiceAccountIdentifier -or LastLogonDate -notlike "*" } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'AllExceptNeverLoggedOn' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        Default {
          Write-Host -BackgroundColor Red "Error: An unknown error occcurred. Can't determine search scope. Exiting."
          Break
        }
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }

    End {
      If ($?) {
        Write-Host 'Completed Successfully.'
        Write-Host ' '
      }
    }
  }
}

Function Create-Report {
  Param ()

  Begin {
    Write-Host "Creating report of inactive users in specified path [$ReportFilePath]..."
  }

  Process {
    Try {
      #Check file path to ensure correct
      If ($ReportFilePath -notlike '*.csv') {
        $ReportFilePath = Join-Path -Path $ReportFilePath -ChildPath '\InactiveUsers.csv'
      }

      # Create CSV report
      $global:Results | Export-Csv $ReportFilePath -NoTypeInformation
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Disable-Accounts {
  Param ()

  Begin {
    Write-Host 'Disabling inactive users...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Disable-ADAccount -Identity $Item.DistinguishedName
        Write-Host "$($Item.Username) - Disabled"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Delete-Accounts {
  Param ()

  Begin {
    Write-Host 'Deleting inactive users...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Remove-ADUser -Identity $Item.DistinguishedName -Confirm:$false
        Write-Host "$($Item.Username) - Deleted"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

#-----------------------------------------------------------[Execution]------------------------------------------------------------

Find-Accounts
Create-Report

If ($DisableUsers) {
  Disable-Accounts
}

If ($DeleteUsers) {
  Delete-Accounts
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_InstalledSoftware_32_and_64_v0.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_InstalledSoftware_32_and_64_v0.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get_InstalledSoftware_32_and_64_v0.ps1

#'This Powershell script list all the installed application on both 32 and 64 bit applications, 
#'	particularly useful for people managing both 32-bit and 64-bit applications.
 
#'	This code also contains an EXCLUSION array where you can exclude list of program that you don't want to show.
#'
#'The function allows -ComputerName parameter so you can connect to any machines
#'Application architecture detection (32-bit or 64-bit) using Win32_processor
#'Output is Powershell console and GridView

#'https://gallery.technet.microsoft.com/scriptcenter/PowerShell-Installed-70d0c0f4

#'===================================================================================USAGE
Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================


Function Get-SoftwareList
{
Param(
[Parameter(Mandatory=$true)]
[string[]]$Computername)

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")

[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 
$donotwrite = $false

if($AppName.length -gt "0"){

 Foreach($exclude in $excludeArray) 
                        {
                        if($AppName.StartsWith($exclude) -eq $TRUE)
                            {
                            $donotwrite = $true
                            break
                            }
                        }
            if ($donotwrite -eq $false) 
                        {                        
            $Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "64-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
                        }





}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 
 $donotwrite = $false
         
                             



if($AppName.length -gt "0"){
 Foreach($exclude in $excludeArray) 
                        {
                        if($AppName.StartsWith($exclude) -eq $TRUE)
                            {
                            $donotwrite = $true
                            break
                            }
                        }
            if ($donotwrite -eq $false) 
                        {                        
            $Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
                        }
           }

 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

"#"*80
"Installed Software Application Report"
"Numner of Installed Application count : $($object.count)"
"Generated $(get-date)"
"Generated from $(gc env:computername)"
"#"*80

$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
$object|Out-GridView 


}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v3.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v3.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v3.ps1
#' The exclusion array has been replaced by the inclusion array (for finding Adobe software)
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v3
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $true
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

#'                             Foreach($exclude in $excludeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $true
#'                                                        break
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - START
                             Foreach($include in $includeArray) 
                                                    {
                                                    if($AppName.StartsWith($include) -eq $TRUE)
                                                        {
                                                        $donotwrite = $false
                                                        }
                                                    }
                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $true
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){
#'Foreach($exclude in $excludeArray) 
#'                        {
#'                        if($AppName.StartsWith($exclude) -eq $TRUE)
#'                            {
#'                            $donotwrite = $true
#'                            break
#'                            }
#'                        }

                        #'=================================================================  INCLUSION ARRAY - START
                            Foreach($include in $includeArray) 
                                                {
                                                if($AppName.StartsWith($include) -eq $TRUE)
                                                    {
                                                    $donotwrite = $false
                                                    }
                                                }
                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v4.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v4.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v4.ps1
#' All Applications, with the default Exclusion Array
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v4
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                             Foreach($exclude in $excludeArray) 
                                                    {
                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
                                                        {
                                                        $donotwrite = $true
                                                        break
                                                        }
                                                    }


                            #'=================================================================  INCLUSION ARRAY - START
    #'                         Foreach($include in $includeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($include) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $false
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                        Foreach($exclude in $excludeArray) 
                                                {
                                                if($AppName.StartsWith($exclude) -eq $TRUE)
                                                    {
                                                    $donotwrite = $true
                                                    break
                                                    }
                                                }


                        #'=================================================================  INCLUSION ARRAY - START
#'                            Foreach($include in $includeArray) 
#'                                                {
#'                                                if($AppName.StartsWith($include) -eq $TRUE)
#'                                                    {
#'                                                    $donotwrite = $false
#'                                                    }
#'                                                }

                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v5.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v5.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v5.ps1
#' All Applications, withOUT the default Exclusion Array, the inclusion array is being ignored
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v5
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

#'$excludeArray = ("Security Update for Windows",
#'"Update for Windows",
#'"Update for Microsoft .NET",
#'"Security Update for Microsoft",
#'"Hotfix for Windows",
#'"Hotfix for Microsoft .NET Framework",
#'"Hotfix for Microsoft Visual Studio 2007 Tools",
#'"Hotfix")

$excludeArray = ("whateverXXX")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                             Foreach($exclude in $excludeArray) 
                                                    {
                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
                                                        {
                                                        $donotwrite = $true
                                                        break
                                                        }
                                                    }


                            #'=================================================================  INCLUSION ARRAY - START
    #'                         Foreach($include in $includeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($include) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $false
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                        Foreach($exclude in $excludeArray) 
                                                {
                                                if($AppName.StartsWith($exclude) -eq $TRUE)
                                                    {
                                                    $donotwrite = $true
                                                    break
                                                    }
                                                }


                        #'=================================================================  INCLUSION ARRAY - START
#'                            Foreach($include in $includeArray) 
#'                                                {
#'                                                if($AppName.StartsWith($include) -eq $TRUE)
#'                                                    {
#'                                                    $donotwrite = $false
#'                                                    }
#'                                                }

                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CIM_Computer_Info_v2____with__BIOSReleaseDate</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CIM_Computer_Info_v2____with__BIOSReleaseDate</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Usage===========================================================================
#'         &gt; Get-MachineInfo -ComputerName 10.11.56.176 -Protocol Dcom -Verbose
#'===========================================================================

function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1
            #'----------------------------------
            #'CIM_BIOSElement
            #'CIM_BIOSFeature
            #'CIM_BIOSFeatureBIOSElements
            #'CIM_BIOSLoadedInNV
            #'Get-CimClass win32_bios

            #'Get-CimClass CIM_BIOSElement | select -First 1 -ExpandProperty CimClassProperties | Select InstallDate
            $BIOS_params = @{'ClassName'='CIM_BIOSElement'
                             'CimSession'=$session}
            $BIOS = Get-CimInstance @BIOS_params | Select-Object -first 1

            $BIOS | select -First 1 -ExpandProperty ReleaseDate 

            #'----------------------------------
  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                        #'----------------------------------
                       'BIOSReleaseDate' = $BIOS | select -First 1 -ExpandProperty ReleaseDate 
                        #'----------------------------------
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            # Did we specify protocol fallback?
            # If so, try again. If we specified logging,
            # we won't log a problem here - we'll let
            # the logging occur if this fallback also
            # fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #if logging

                Get-MachineInfo @params
            } #if protocolfallback

            # if we didn't specify fallback, but we
            # did specify logging, then log the error,
            # because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } # if write to log

        } #try/catch
 
    } #foreach
} #PROCESS

END {}

} #function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CIM_computer_Info</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CIM_computer_Info</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>From Directions Training:



======================================================================
#' final code
function Get-MachineInfo {
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        #' Establish session protocol
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        #' Connect session
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option
  
        #' Query data
        $os_params = @{'ClassName'='Win32_OperatingSystem'
                       'CimSession'=$session}
        $os = Get-CimInstance @os_params

        $cs_params = @{'ClassName'='Win32_ComputerSystem'
                       'CimSession'=$session}
        $cs = Get-CimInstance @cs_params

        $sysdrive = $os.SystemDrive
        $drive_params = @{'ClassName'='Win32_LogicalDisk'
                          'Filter'="DeviceId='$sysdrive'"
                          'CimSession'=$session}
        $drive = Get-CimInstance @drive_params

        $proc_params = @{'ClassName'='Win32_Processor'
                         'CimSession'=$session}
        $proc = Get-CimInstance @proc_params |
                Select-Object -first 1

  
        #' Close session
        $session | Remove-CimSession
  
        #' Output data
        $props = @{'ComputerName'=$computer
                   'OSVersion'=$os.version
                   'SPVersion'=$os.servicepackmajorversion
                   'OSBuild'=$os.buildnumber
                   'Manufacturer'=$cs.manufacturer
                   'Model'=$cs.model
                   'Procs'=$cs.numberofprocessors
                   'Cores'=$cs.numberoflogicalprocessors
                   'RAM'=($cs.totalphysicalmemory / 1GB)
                   'Arch'=$proc.addresswidth
                   'SysDriveFreeSpace'=$drive.freespace}
        $obj = New-Object -TypeName PSObject -Property $props
        Write-Output $obj                           #' &lt;=== Put HashTable object for output
 
    } #'foreach
} #'PROCESS

END {}

} #'function


====NOTES=====================================================================

#' functional overview of tool - will not execute as-is
        #' Query data
        $os = Get-CimInstance -ClassName Win32_OperatingSystem `
                              -CimSession $session
  
        #' Close session
        $session | Remove-CimSession
  
        #' Output data
        $os | Select-Object -Prop @{n='ComputerName';e={$computer}},
                                Version,ServicePackMajorVersion


#' params into hash table
$params = @{'ClassName'='Win32_OperatingSystem'
            'ComputerName'='CLIENT1'}


#' switch params in hash table
$params = @{'ClassName'='Win32_OperatingSystem'
            'ComputerName'='CLIENT1'
            'Verbose' = $True}



#' splatting hash table of params
Get-CimInstance @params



#' revised snippet - will not execute as-is
        #' Query data
        $os_params = @{'ClassName'='Win32_OperatingSystem'
                       'CimSession'=$session}
        $os = Get-CimInstance @os_params

        $cs_params = @{'ClassName'='Win32_ComputerSystem'
                       'CimSession'=$session}
        $cs = Get-CimInstance @cs_params

        $sysdrive = $os.SystemDrive
        $drive_params = @{'ClassName'='Win32_LogicalDisk'
                          'Filter'="DeviceId='$sysdrive'"
                          'CimSession'=$session}        $drive = Get-CimInstance @drive_params

        $proc_params = @{'ClassName'='Win32_Processor'
                         'CimSession'=$session}
        $proc = Get-CimInstance @proc_params |
                Select-Object -first 1



#' constructing custom object
        #' Output data
        $props = @{'ComputerName'=$computer
                   'OSVersion'=$os.version
                   'SPVersion'=$os.servicepackmajorversion
                   'OSBuild'=$os.buildnumber
                   'Manufacturer'=$cs.manufacturer
                   'Model'=$cs.model
                   'Procs'=$cs.numberofprocessors
                   'Cores'=$cs.numberoflogicalprocessors
                   'RAM'=($cs.totalphysicalmemory / 1GB)
                   'Arch'=$proc.addresswidth
                   'SysDriveFreeSpace'=$drive.freespace}
        $obj = New-Object -TypeName PSObject -Property $props
        Write-Output $obj</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Local_Administrators</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Local_Administrators</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://powershell.org/2013/04/02/get-local-admin-group-members-in-a-new-old-way-3/
==================================================================================
'USAGE:
Get-NetLocalGroup -Group "remote desktop users" -Computername $sessions
--------------------------------------------------------------------------
Function Get-NetLocalGroup {
[cmdletbinding()]

Param(
[Parameter(Position=0)]
[ValidateNotNullorEmpty()]
[object[]]$Computername=$env:computername,
[ValidateNotNullorEmpty()]
[string]$Group = "Administrators",
[switch]$Asjob
)

Write-Verbose "Getting members of local group $Group"

#define the scriptblock
$sb = {
 Param([string]$Name = "Administrators")
$members = net localgroup $Name | 
 where {$_ -AND $_ -notmatch "command completed successfully"} | 
 select -skip 4
New-Object PSObject -Property @{
 Computername = $env:COMPUTERNAME
 Group = $Name
 Members=$members
 }
} #end scriptblock

#define a parameter hash table for splatting
$paramhash = @{
 Scriptblock = $sb
 HideComputername=$True
 ArgumentList=$Group
 }

if ($Computername[0] -is [management.automation.runspaces.pssession]) {
    $paramhash.Add("Session",$Computername)
}
else {
    $paramhash.Add("Computername",$Computername)
}

if ($asjob) {
    Write-Verbose "Running as job"
    $paramhash.Add("AsJob",$True)
}

#run the command
Invoke-Command @paramhash | Select * -ExcludeProperty RunspaceID

} #end Get-NetLocalGroup

=================================================================================
https://powershell.org/2013/04/02/get-local-admin-group-members-in-a-new-old-way-3/

----------
'CMD
net localgroup administrators

'Powershell:
invoke-command {net localgroup administrators} -comp chi-fp01

 ----------
' filtering out blanks, that last line and skipping the header lines.
invoke-command {
 net localgroup administrators | 
 where {$_ -AND $_ -notmatch "command completed successfully"} | 
 select -skip 4
 } -computer chi-fp01
 
 ' write an object to the pipeline and be better at handling output from multiple computers. I came up with a scriptblock like this:
 $members = net localgroup administrators | 
	 where {$_ -AND $_ -notmatch "command completed successfully"} | 
	 select -skip 4
	New-Object PSObject -Property @{
	 Computername = $env:COMPUTERNAME
	 Group = "Administrators"
	 Members=$members
 }

 ----------
 'This will create a simple object with a properties for the computername, group name and members. Heres how I can use it with Invoke-Command.
 
 invoke-command {
$members = net localgroup administrators | 
 where {$_ -AND $_ -notmatch "command completed successfully"} | 
 select -skip 4
New-Object PSObject -Property @{
 Computername = $env:COMPUTERNAME
 Group = "Administrators"
 Members=$members
 }
} -computer chi-fp01,chi-win8-01,chi-ex01 -HideComputerName | 
Select * -ExcludeProperty RunspaceID

----------
'Now I have objects that I can export to XML, convert to HTML or send to a file. But since Ive come this far, I might as well take a few more minutes and turn this into a reusable tool.

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Login__get_LoginInstancesFunction</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Login__get_LoginInstancesFunction</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USAGE:

&gt;Get-LoginInstance -ComputerName "LT-103111" -StartDate (Get-Date).AddDays(-1) -Verbose  | SELECT UserName, LoginTime, SessionType, LoginIpAddress



'Get-LoginInstance - Retrieve Local and Remote Computer Login/Logout Instances
https://gallery.technet.microsoft.com/scriptcenter/Get-LoginInstance-Retrieve-6437b1af

#'This script contains a function (Get-LoginInstance), 
#'    as well as two sub-functions (Get-LoginData and Get-LogoutData), 
#'    which are used to retrieve login and logout events from the Security event log on a local or remote computer, 
#'    and join them together to display login instance data.  
#'    Please use the native help bundled with the cmdlet for more information on ways to utilize/run this function.
#'
#'Additionally, please note that this cmdlet is reliant upon Remote Event Log Management, 
#'    which may need to be enabled on the target machine(s), 
#'    and due to its use of Get-WinEvent, can only work on Vista, 
#'    Server 2008 R2 and later Windows releases for consumer and enterprise markets, respectively.
#'
#'UPDATE - 10/23/14: I've revised the cmdlet to fix a few different areas - 
#'                    please download the latest version of this if you have a previous version of the script.  
#'                    Changes made to the latest version include:
#'
#'New sorting algorithm to ensure all login instances 
#'        (logins and logouts) and logins without corresponding logouts 
#'        appear in final collection, regardless of OS, account domain, etc.
#'Official support of PowerShell versions 2, 3 and 4 - Get-LoginInstance has now been tested and confirmed to work in all of those versions
#'Remove Desktop Window Manager (DWM) logins from final collection if present
#'Minor help file tweaks
=================================================================================
    -------------------------- EXAMPLE 1 --------------------------
    
    PS C:\&gt;Get-LoginInstance
    
    Retrieve all available login instances from the local computer within 
    the past week.
    
    
    
    
    -------------------------- EXAMPLE 2 --------------------------
    
    PS C:\&gt;Get-LoginInstance -ComputerName "GSR-242" -StartDate (Get-Date).AddMonths(-1) -Verbose
    
    Retrieve all available login instances from remote computer "GSR-242" 
    within the past month, displaying verbose output as well.

=================================================================================

#PowerShell Script Containing Function(s) Used to Retrieve Login &amp; Logout Instances from a Local or Remote Computer
#Developer: Andrew Saraceni (saraceni@wharton.upenn.edu)
#Date: 10/23/14

function Get-LoginInstance
{
    &lt;#
    .SYNOPSIS
    Retrieves login and logout instances from a local or remote computer.
    .DESCRIPTION
    Retrieves all interactive and remote-based logins from a specific 
    computer, then obtains all logouts and joins the instances together 
    via processing.  This information is retrieved from the Security 
    event logs on the computer, and thus can only pull data from logs 
    that have yet to turn over.

    Without parameters, a Get-LoginInstance command retrieves all logins 
    and logouts from the local computer within the past week.
    .PARAMETER ComputerName
    Specifies the computer from which to pull the login/logout 
    information.  The default value for this is the local computer.
    .PARAMETER StartDate
    Specifies the earliest (i.e. oldest) date from which to retrieve 
    logins/logouts.  The default value for this is one week before the 
    current date: (Get-Date).AddDays(-7)
    .PARAMETER EndDate
    Specifies the most recent date from which to retrieve logins/logouts.  
    The default value for this is the current date.
    .EXAMPLE
    Get-LoginInstance
    Retrieve all available login instances from the local computer within 
    the past week.
    .EXAMPLE
    Get-LoginInstance -ComputerName "GSR-242" -StartDate (Get-Date).AddMonths(-1) -Verbose
    Retrieve all available login instances from remote computer "GSR-242" 
    within the past month, displaying verbose output as well.
    .NOTES
    This cmdlet makes use of the Get-WinEvent cmdlet, which is only 
    available on Windows Vista, Windows Server 2008 R2 and later consumer 
    and enterprise verisons of Windows, respectively.

    Additionally, Remote Event Log Management will need to be enabled 
    via your firewall.  The following CMD prompt command can enable this 
    on a local computer:

    netsh advfirewall firewall set rule group=remote event log management new enable=yes
    #&gt;
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,Mandatory=$false)]
        [String]$ComputerName = $env:COMPUTERNAME,
        [Parameter(Position=1,Mandatory=$false)]
        [DateTime]$StartDate = (Get-Date).AddDays(-7),
        [Parameter(Position=2,Mandatory=$false)]
        [DateTime]$EndDate = (Get-Date)
    )

    function Get-LoginData
    {
        param($ComputerName,$StartDate,$EndDate)
        
        Write-Verbose "Getting Login Data from $ComputerName..."
        [Int32[]]$loginID = @(4624)

        try
        {
            $loginEvents = Get-WinEvent -ComputerName $ComputerName -FilterHashtable @{ LogName="Security"; ID=$loginID; StartTime=$StartDate; EndTime=$EndDate } -ErrorAction Stop
        }
        catch
        {
            Set-Variable -Name catchError -Value $_
            if ($catchError -match "No events were found that match the specified selection criteria.")
            {
                Write-Warning "No Login Events Found - Ending Login Collection"
            }
        }

        Write-Verbose "Converting Logins to XML &amp; Parsing Data for Better Readability..."
        foreach ($loginEvent in $loginEvents)
        {
            $xmlLoginEvent = [Xml]$loginEvent.ToXml()

            for ($i=0; $i -lt $xmlLoginEvent.Event.EventData.Data.Count; $i++)
            {            
                Add-Member -InputObject $loginEvent -MemberType NoteProperty -Name $xmlLoginEvent.Event.EventData.Data[$i].Name -Value $xmlLoginEvent.Event.EventData.Data[$i]."#Text" -Force
            }
        }

        $revisedLoginEvents = @()
        $xmlLoginEvents = $loginEvents | Where-Object { (($_.LogonType -eq "2") -or ($_.LogonType -eq "10")) -and ($_.TargetDomainName -ne "Window Manager") } | Select-Object -Property *
        foreach ($xmlLoginEvent in $xmlLoginEvents)
        {
            switch ($xmlLoginEvent.LogonType)
            {
                "2" {
                    $xmlLoginEvent.LogonType = "Login-Interactive"
                }
                "10" {
                    $xmlLoginEvent.LogonType = "Login-Remote"
                }
            }
            
            if (($xmlLoginEvent.IpAddress -eq "127.0.0.1") -or ($xmlLoginEvent.IpAddress -eq "::1"))
            {
                $xmlLoginEvent.IpAddress = $null
            }

            if ($xmlLoginEvent.IpPort -eq "0")
            {
                $xmlLoginEvent.IpPort = $null
            }
            
            $revisedLoginEvents += $xmlLoginEvent
        }
        
        return $revisedLoginEvents
    }

    function Get-LogoutData
    {
        param($ComputerName,$StartDate,$EndDate)

        Write-Verbose "Getting Logout Data from $ComputerName..."
        [Int32[]]$logoutID = @(4647)

        try
        {
            $logoutEvents = Get-WinEvent -ComputerName $ComputerName -FilterHashtable @{ LogName="Security"; ID=$logoutID; StartTime=$startDate; EndTime=$endDate } -ErrorAction Stop
        }
        catch
        {
            Set-Variable -Name catchError -Value $_
            if ($catchError -match "No events were found that match the specified selection criteria.")
            {
                Write-Warning "No Logout Events Found - Ending Logout Collection"
            }
        }

        Write-Verbose "Converting Logouts to XML &amp; Parsing Data for Better Readability..."
        foreach ($logoutEvent in $logoutEvents)
        {
            $xmlLogoutEvent = [Xml]$logoutEvent.ToXml()

            for ($i=0; $i -lt $xmlLogoutEvent.Event.EventData.Data.Count; $i++)
            {            
                Add-Member -InputObject $logoutEvent -MemberType NoteProperty -Name $xmlLogoutEvent.Event.EventData.Data[$i].name -Value $xmlLogoutEvent.Event.EventData.Data[$i]."#Text" -Force
            }
        }
        
        $revisedLogoutEvents = @()
        $xmlLogoutEvents = $logoutEvents | Select-Object -Property *
        foreach ($xmlLogoutEvent in $xmlLogoutEvents)
        {
            Add-Member -InputObject $xmlLogoutEvent -MemberType NoteProperty -Name "WorkstationName" -Value $ComputerName -Force

            $revisedLogoutEvents += $xmlLogoutEvent
        }
        
        return $revisedLogoutEvents
    }

    $finalLoginEvents = Get-LoginData -ComputerName $ComputerName -StartDate $StartDate -EndDate $EndDate
    $finalLogoutEvents = Get-LogoutData -ComputerName $ComputerName -StartDate $StartDate -EndDate $EndDate

    Write-Verbose "Creating Final Collection of Revised Login and Logout Instance Data..."
    $loginInstances = @()

    foreach ($finalLoginEvent in $finalLoginEvents)
    {
        $instanceProperties = @{
            ComputerName = $finalLoginEvent.WorkstationName
            UserName = $finalLoginEvent.TargetUserName
            AccountDomain = $finalLoginEvent.TargetDomainName
            LoginTime = $finalLoginEvent.TimeCreated
            LogoutTime = $null
            TargetLogonID = $finalLoginEvent.TargetLogonID
            Days = $null
            Hours = $null
            Minutes = $null
            Seconds = $null
            SessionType = $finalLoginEvent.LogonType
            LoginIpAddress = $finalLoginEvent.IpAddress
            LoginIpPort = $finalLoginEvent.IpPort
            LogonGuid = $finalLoginEvent.LogonGuid
        }

        $loginInstance = New-Object -TypeName PSObject -Property $instanceProperties

        foreach ($finalLogoutEvent in $finalLogoutEvents)
        {
            if (($finalLogoutEvent.WorkstationName -eq $finalLoginEvent.WorkstationName) -and ($finalLogoutEvent.TargetUserName -eq $finalLoginEvent.TargetUserName) -and ($finalLogoutEvent.TargetLogonID -eq $finalLoginEvent.TargetLogonID))
            {
                $loginInstance.LogoutTime = $finalLogoutEvent.TimeCreated
                $loginInstance.Days = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Days
                $loginInstance.Hours = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Hours
                $loginInstance.Minutes = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Minutes
                $loginInstance.Seconds = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Seconds
            }
        }

        $loginInstances += $loginInstance
    }

    $fullLoginInstances = $loginInstances | Where-Object { $_.LogoutTime -ne $null }
    $partialLoginInstances = $loginInstances | Where-Object { $_.LogoutTime -eq $null } | Sort-Object -Property LoginTime -Descending -Unique

    $fullLoginInstanceLoginTimes = $fullLoginInstances | Select-Object -ExpandProperty LoginTime
    $filteredPartialLoginInstances = @()
    
    foreach ($partialLoginInstance in $partialLoginInstances)
    {
        if ($fullLoginInstanceLoginTimes -notcontains $partialLoginInstance.LoginTime)
        {
            $filteredPartialLoginInstances += $partialLoginInstance
        }
    }

    $finalLoginInstances = @($fullLoginInstances) + @($filteredPartialLoginInstances) | Sort-Object -Property LoginTime -Descending -Unique

    return $finalLoginInstances | Select-Object -Property ComputerName, UserName, AccountDomain, LoginTime, LogoutTime, TargetLogonID, Days, Hours, Minutes, Seconds, SessionType, LoginIpAddress, LoginIpPort, LogonGuid
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Profile_delete</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Profile_delete</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'http://www.tomsitpro.com/articles/powershell-manage-user-profiles,2-2.html

&gt;Get-WmiObject -Class Win32_UserProfile | where {$_.LocalPath.split('')[-1] -eq 'Administrator.CLIENT1'} | foreach {$_.Delete()}

'1which will then remove the user profile from the file system as well as the registry.

'Again, if you'd like to extend this to multiple computers you'd simply use the ComputerName parameter on Get-WmiObject.
&gt;Get-WmiObject -Class Win32_UserProfile ComputerName CLIENT1,CLIENT2 | where {$_.LocalPath.split('')[-1] -eq 'Administrator.CLIENT1'} | foreach {$_.Delete()}

========================================================================================================================

https://community.spiceworks.com/how_to/124316-delete-user-profiles-with-powershell
---------------------------
'Step 1: Create the ps1 file
Get-WMIObject -class Win32_UserProfile
---------------------------
'Step 2: Select the profiles older than 5 days
'Pipe the above result to this command, which will filter down to users who have not logged in within the given timescale (5 days shown here)
Where {(!$_.Special) -and ($_.ConvertToDateTime($_.LastUseTime) -lt (Get-Date).AddDays(-5))}
---------------------------
'Step 3: Remove the profiles
'Pipe the above results to this to remove said profiles.
Remove-WmiObject
---------------------------
'Step 4: WhatIf
Don't forget to use the -WhatIf switch if you are unsure!
---------------------------
'Your finished command should look like this:

Get-WMIObject -class Win32_UserProfile | Where {(!$_.Special) -and ($_.ConvertToDateTime($_.LastUseTime) -lt (Get-Date).AddDays(-5))} | Remove-WmiObject

===========================================================

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Profile_function_toRemoveLocalUserProfile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Profile_function_toRemoveLocalUserProfile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gallery.technet.microsoft.com/scriptcenter/Remove-UserProfile-Remove-96e27a3b

#'This script contains a function (Remove-UserProfile) which is used to remove user profiles, 
#'    and additional contents of the C:\Users directory (if specified) on a local computer.  
#' Parameters exist to "Exclude" one or more user profiles from being removed, 
#'    remove only profiles "Before" a date when they have not been accessed, 
#'    and to invoke a "DirectoryCleanup" to remove additional files/folders (i.e. non-profiles) within the C:\Users directory.  
#'    Per profile, the profile object itself and all associated registry keys are removed 
#'        if the profile meets the criteria defined via the cmdlet's parameters.
#'
#'This cmdlet requires adminisrative privileges to run effectively. 
#'    Furthermore, this cmdlet is not intended to be used on Virtual Desktop Infrastructure (VDI) environments 
#'    or others which utilize persistent storage on alternate disks, 
#'    or any configurations which utilize another directory other than C:\Users to store user profiles.  
#'This cmdlet is designed to function with PowerShell versions 2 and above.

'USAGE
-------
#'Remove all non-active and non-system designated user profiles from the local computer. 
Remove-UserProfile 
 
#'Remove all non-active and non-system designated user profiles not used within the past month, displaying verbose output as well. 
Remove-UserProfile -Before (Get-Date).AddMonths(-1) -Verbose 
 
#'Remove all non-active and non-system designated user profiles except "labadmin" and "desktopuser", and remove additional non-profile files/folders within C:\Users as well. 
Remove-UserProfile -Exclude @("labadmin", "desktopuser") -DirectoryCleanup 
 
#'Invoke Remove-UserProfile on a Remote Computer 
$scriptBlock = { 
    function Remove-UserProfile 
    { 
        ... 
    } 
 
    Remove-UserProfile 
} 
 
Invoke-Command -ComputerName "GWS-F20" -ScriptBlock $scriptBlock 
 
#'Invoke Remove-UserProfile on Many Remote Computers, Passing in Arguments 
#'This Example Utilizes Windows Workflow Foundation Technology, Available in PowerShell V3 and Above 
$scriptBlock = { 
    function Remove-UserProfile 
    { 
        ... 
    } 
 
    Remove-UserProfile -Exclude $args 
} 
 
$compArray = @() 
Get-Content -Path "\\path\to\computers.txt" | ForEach-Object { $compArray += $_ } 
 
$excludedList = @("labadmin", "desktopuser") 
 
Invoke-Command -ComputerName $compArray -ScriptBlock $scriptBlock -ArgumentList $excludedList -ThrottleLimit 50

==================================================================================================================

#PowerShell Script Containing Function Used to Remove User Profiles &amp; Additional Remnants of C:\Users Directory
#Developer: Andrew Saraceni (saraceni@wharton.upenn.edu)
#Date: 12/22/14

#Requires -Version 2.0

function Remove-UserProfile
{
    &lt;#
    .SYNOPSIS
    Removes user profiles and additional contents of the C:\Users 
    directory if specified.
    .DESCRIPTION
    Gathers a list of profiles to be removed from the local computer, 
    passing on exceptions noted via the Exclude parameter and/or 
    profiles newer than the date specified via the Before parameter.  
    If desired, additional files and folders within C:\Users can also 
    be removed via use of the DirectoryCleanup parameter.

    Once gathered, miscellaneous items are first removed from the 
    C:\Users directory if specified, followed by the profile objects 
    themselves and all associated registry keys per profile.  A listing 
    of current items within the C:\Users directory is returned 
    following the profile removal process.
    .PARAMETER Exclude
    Specifies one or more profile names to exclude from the removal 
    process.
    .PARAMETER Before
    Specifies a date from which to remove profiles before that haven't 
    been accessed since that date.
    .PARAMETER DirectoryCleanup
    Removes additional files/folders (i.e. non-profiles) within the 
    C:\Users directory.
    .EXAMPLE
    Remove-UserProfile
    Remove all non-active and non-system designated user profiles 
    from the local computer.
    .EXAMPLE
    Remove-UserProfile -Before (Get-Date).AddMonths(-1) -Verbose
    Remove all non-active and non-system designated user profiles 
    not used within the past month, displaying verbose output as well.
    .EXAMPLE
    Remove-UserProfile -Exclude @("labadmin", "desktopuser") -DirectoryCleanup
    Remove all non-active and non-system designated user profiles 
    except "labadmin" and "desktopuser", and remove additional 
    non-profile files/folders within C:\Users as well.
    .NOTES
    Even when not specifying the Exclude parameter, the following 
    profiles are not removed when utilizing this cmdlet:
    C:\Windows\ServiceProfiles\NetworkService 
    C:\Windows\ServiceProfiles\LocalService 
    C:\Windows\system32\config\systemprofile 
    C:\Users\Public
    C:\Users\Default

    Aside from the original profile directory (within C:\Users) 
    itself, the following registry items are also cleared upon 
    profile removal via WMI:
    "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\{SID of User}"
    "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileGuid\{GUID}" SidString = {SID of User}
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\{SID of User}"

    Additionally, any currently loaded/in use profiles will not be 
    removed.  Regarding miscellaneous non-profile items, hidden items 
    are not enumerated or removed from C:\Users during this process.

    This cmdlet requires adminisrative privileges to run effectively.
      
    This cmdlet is not intended to be used on Virtual Desktop 
    Infrastructure (VDI) environments or others which utilize 
    persistent storage on alternate disks, or any configurations 
    which utilize another directory other than C:\Users to store 
    user profiles.
    #&gt;
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,Mandatory=$false)]
        [String[]]$Exclude,
        [Parameter(Position=1,Mandatory=$false)]
        [DateTime]$Before,
        [Parameter(Position=2,Mandatory=$false)]
        [Switch]$DirectoryCleanup
    )

    Write-Verbose "Gathering List of Profiles on $env:COMPUTERNAME to Remove..."

    $userProfileFilter = "Loaded = 'False' AND Special = 'False'"
    $cleanupExclusions = @("Public", "Default")

    if ($Exclude)
    {
        foreach ($exclusion in $Exclude)
        {
            $userProfileFilter += "AND NOT LocalPath LIKE '%$exclusion'"
            $cleanupExclusions += $exclusion
        }
    }

    if ($Before)
    {
        $userProfileFilter += "AND LastUseTime &lt; '$Before'"

        $keepUserProfileFilter = "Special = 'False' AND LastUseTime &gt;= '$Before'"
        $profilesToKeep = Get-WmiObject -Class Win32_UserProfile -Filter $keepUserProfileFilter -ErrorAction Stop

        foreach ($profileToKeep in $profilesToKeep)
        {
            try
            {
                $userSID = New-Object -TypeName System.Security.Principal.SecurityIdentifier($($profileToKeep.SID))
                $userName = $userSID.Translate([System.Security.Principal.NTAccount])
                
                $keepUserName = $userName.Value -replace ".*\\", ""
                $cleanupExclusions += $keepUserName
            }
            catch [System.Security.Principal.IdentityNotMappedException]
            {
                Write-Warning "Cannot Translate SID to UserName - Not Adding Value to Exceptions List"
            }
        }
    }

    $profilesToDelete = Get-WmiObject -Class Win32_UserProfile -Filter $userProfileFilter -ErrorAction Stop

    if ($DirectoryCleanup)
    {
        $usersChildItem = Get-ChildItem -Path "C:\Users" -Exclude $cleanupExclusions

        foreach ($usersChild in $usersChildItem)
        {
            if ($profilesToDelete.LocalPath -notcontains $usersChild.FullName)
            {    
                try
                {
                    Write-Verbose "Additional Directory Cleanup - Removing $($usersChild.Name) on $env:COMPUTERNAME..."
                    
                    Remove-Item -Path $($usersChild.FullName) -Recurse -Force -ErrorAction Stop
                }
                catch [System.InvalidOperationException]
                {
                    Write-Verbose "Skipping Removal of $($usersChild.Name) on $env:COMPUTERNAME as Item is Currently In Use..."
                }
            }
        }
    }

    foreach ($profileToDelete in $profilesToDelete)
    {
        Write-Verbose "Removing Profile $($profileToDelete.LocalPath) &amp; Associated Registry Keys on $env:COMPUTERNAME..."
                
        Remove-WmiObject -InputObject $profileToDelete -ErrorAction Stop
    }

    $finalChildItem = Get-ChildItem -Path "C:\Users" | Select-Object -Property Name, FullName, LastWriteTime
                
    return $finalChildItem
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Write-Error_Write-Warning_Write-Verbose_Write-Debug</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Write-Error_Write-Warning_Write-Verbose_Write-Debug</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'EXAMPLE

function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[string]$VMName
	)
	
    switch ($VMName) {  										 
        'SQLInjectAttackName' {													&lt;===== So if VMName = 'SQLInjectAttackName'
            Write-Error -Message "OMG! Someone's trying to H@x0r our base!"		'Then do this
			#' NOTE: this is a non-terminating Error
        }

        'AlreadyExists' {
            Write-Warning -Message "You got a problem. This VM already exists so you can't add it, dummy"
        }

        'DoesNotExistAlready' {
            Write-Verbose -Message 'The VM does not already exist. You may proceed to add a new one with that name'
        }

        'FlakyIssue' {
            $ThatVariable = 'notright'					#'  &lt;==== This variable gets set inorder to demo suspended mode with the "-debug" Parameter
            Write-Debug -Message 'I will add this VM on host 123, blade 4564 on the molecule H2S squared'
        }
    }
}
======================================================================================
'Demo results--------
======================================================================================ERROR

##' Check what the $ErrorActionPreference variable is set at to see what kind of behavior to expect
$ErrorActionPreference
'OUTPUT
--------
'Continue				'&lt;==== This means when it hits a terminating or non-terminating error it is just going to keep going
						'&lt;==== 		so it will send the error output to the console and then continue
##' A major error occurs!!
&gt;New-VirtualMachine -VMName 'SQLInjectAttackName'

'OUTPUT (in Red)
----------------
#'New-VirtualMachine : OMG! Someone's trying to H@x0r our base!
#'At line:1 char:1
#'+ New-VirtualMachine -VMName 'SQLInjectAttackName'
#'+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
#'    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,New-VirtualMachine

======================================================================================

##' During debugging maybe I don't care for now if it throws an error. Override default behaviour in just this function
&gt;New-VirtualMachine -VMName 'SQLInjectAttackName' -ErrorAction SilentlyContinue
'OUTPUT
--------
'{none}
======================================================================================ERROR
&gt;$ErrorActionPreference = 'SilentlyContinue'			'&lt;===== Set it globally
&gt;$ErrorActionPreference
'OUTPUT
------------
'SilentlyContinue

##' Override it locally during this command
&gt;New-VirtualMachine -VMName 'AlreadyExists' -WarningAction Stop
'OUTPUT (in Red)
----------------
#'New-VirtualMachine : OMG! Someone's trying to H@x0r our base!
#'At line:1 char:1
#'+ New-VirtualMachine -VMName 'SQLInjectAttackName'
#'+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
#'    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,New-VirtualMachine
======================================================================================Warning

&gt;$WarningPreference				'&lt;===== global Warning preference
'OUTPUT
-------------
'Continue				'&lt;==== This means when it hits a terminating or non-terminating error it is just going to keep going
						'&lt;==== 		so it will send the error output to the console and then continue


&gt;New-VirtualMachine -VMName 'AlreadyExists'						
'OUTPUT   (in Orange)
------------
'WARNING: You got a problem. This VM already exists so you can't add it, dummy	

					
##' Override global behaviour w/ 'Stop' value for the Warningaction parameter
&gt;New-VirtualMachine -VMName 'AlreadyExists' -WarningAction Stop		
'OUTPUT  (first line is orange, then the rest is Red)
-------
#'WARNING: You got a problem. This VM already exists so you can't add it, dummy
#'Write-Warning : The running command stopped because the preference variable "WarningPreference" or common parameter is set to Stop: 
#'You got a problem. This VM already exists so you can't add it, dummy
#'At line:15 char:13
#'+             Write-Warning -Message "You got a problem. This VM alread ...
#'+             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : OperationStopped: (:) [Write-Warning], ParentContainsErrorRecordException
#'    + FullyQualifiedErrorId : ActionPreferenceStop,Microsoft.PowerShell.Commands.WriteWarningCommand

======================================================================================Verbose
&gt;$VerbosePreference
'OUPUT
-----------
'SilentlyContinue
			
#' So by default this does not have any output
&gt;New-VirtualMachine -VMName 'DoesNotExistAlready'

#' Forgot -Verbose since $VerbosePreference defaults to SilentlyContinue
&gt;New-VirtualMachine -VMName 'DoesNotExistAlready' -Verbose
'OUTPUT   (in Blue)
----------
'VERBOSE: The VM does not already exist. You may proceed to add a new one with that name

'and you can set Global value to show Verbose messages:
&gt;$VerbosePreference = 'Continue'
======================================================================================Debug
'This is the line with the "Write-Debug" command
&gt;New-VirtualMachine -VMName 'FlakyIssue'
'OUTPUT
------------
'{none}

#' Setting a breakpoint to further investigate the variable
New-VirtualMachine -VMName 'FlakyIssue' -Debug
'In the IDE it throws up a pop-up:
'---------------------------------
'	Continue with this operation? 
'		[YES]
'		[Yes to All]
'		[Halt Command]
'		[Suspend]
'---------------------------------
#' IF you choose [Suspend] then it stops processing and throws you to the command line
'		it is supposed to be a double '&gt;&gt;' rather than a single '&gt;' BUT I did nto see that
'		To get out of the Suspended mode I typed 'Exit'
'	While in the 'DEBUG' suspended mode you can text the value of variables
&gt;$ThatVariable
'OUTPUT (from debug mode)
------------------------
'notright

======================================================================================PRODUCTION
'In production you can silence all the noise:
$ErrorActionPreference = 'SilentlyContinue'
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'
$DebugPreference = 'SilentlyContinue'


#' A VM already exists so instead of confusing the user let's just log to fictional file instead
'	This outputs the message to a variable "VMAlreadyExists", then appends that to a file
'NOTE: no "$" in front of the variable name, on the first line
&gt;New-VirtualMachine -VMName 'AlreadyExists' -WarningVariable VMAlreadyExists
if ($VMAlreadyExists) {
    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "WARNING: $VMAlreadyExists"
}
'OR output it to a new variable called "err"
New-VirtualMachine -VMName 'SQLInjectAttackName' -ErrorVariable err
if ($err) {
    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "ERR: $($err.Exception.Message)"
}

#' Check out the log
Get-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ExtendingOutputTypes </Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Add_a_Member</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ExtendingOutputTypes </Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Add_a_Member</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}

            # create a default display property set
            [string[]]$props = 'ComputerName','OSVersion','Cores','RAM'
            $ddps = New-Object -TypeName System.Management.Automation.PSPropertySet `
                               DefaultDisplayPropertySet, $props
            $pssm = [System.Management.Automation.PSMemberInfo[]]$ddps
            $obj | Add-Member -MemberType MemberSet `
                              -Name PSStandardMembers `
                              -Value $pssm

            ###Adding additional members###
            #adding a property set
            $obj | Add-Member -MemberType PropertySet `
                              -Name OS `
                              -Value 'Computername','OSVersion','OSBuild','Arch'

            #adding an alias
            $obj | Add-Member -MemberType AliasProperty `
                              -Name Free `
                              -Value SysDriveFreeSpace

            #adding a script method
            $obj | Add-Member -MemberType ScriptMethod `
                              -Name Ping `
                              -Value { Test-NetConnection $this.computername }

            #adding a script property
            $obj | Add-Member -MemberType ScriptProperty `
                              -Name TopProcesses `
                              -Value { 
                                Get-Process -ComputerName $this.computername |
                                Sort-Object -Property WorkingSet -Descending |
                                Select-Object -first 5
                                }
                                
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            # Did we specify protocol fallback?
            # If so, try again. If we specified logging,
            # we won't log a problem here - we'll let
            # the logging occur if this fallback also
            # fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #if logging

                Get-MachineInfo @params
            } #if protocolfallback

            # if we didn't specify fallback, but we
            # did specify logging, then log the error,
            # because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } # if write to log

        } #try/catch
 
    } #foreach
} #PROCESS

END {}

} #function

Get-MachineInfo -ComputerName localhost</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ExtendingOutputTypes </Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>script_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ExtendingOutputTypes </Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>script_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' example - see the bottom for notes
function Get-MachineInfo {
&lt;#'
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#'&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
                       
                       #'&lt;========= This is where you would 'add' things to the object
                       
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            #' Did we specify protocol fallback?
            #' If so, try again. If we specified logging,
            #' we won't log a problem here - we'll let
            #' the logging occur if this fallback also
            #' fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #'if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #'if logging

                Get-MachineInfo @params
            } #'if protocolfallback

            #' if we didn't specify fallback, but we
            #' did specify logging, then log the error,
            #' because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } #' if write to log

        } #'try/catch
 
    } #'foreach
} #'PROCESS

END {}

} #'function

===========================================================================================

#' this is the bit we'll change
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj



#' here's the change
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}

            #' create a default display property set                          #'  &lt;==========display property set
            [string[]]$props = 'ComputerName','OSVersion','Cores','RAM'
            $ddps = New-Object -TypeName System.Management.Automation.PSPropertySet `
                               DefaultDisplayPropertySet, $props
            $pssm = [System.Management.Automation.PSMemberInfo[]]$ddps
            $obj | Add-Member -MemberType MemberSet `
                              -Name PSStandardMembers `
                              -Value $pssm

            Write-Output $obj

--------------------------------------------------
'USAGE of predefined group of properties:
&gt; $a | Select Computername,OSVersion,OSBuild,Arch
'shortens to this:
&gt; $a | Select OS
---------------------------------------------

#' more member types...
#'adding an alias, after the object is defined
$obj | Add-Member -MemberType AliasProperty `
                    -Name Free `
                    -Value SysDriveFreeSpace
                    
'USAGE
-------                    
&gt; $a.SysDriveFreeSpace

--------------------------------------------------------------

#'adding a script method, after the object is defined
$obj | Add-Member -MemberType ScriptMethod `
                    -Name Ping `
                    -Value { Test-NetConnection $this.computername }
                    
'USAGE of a Method
--------------
&gt;$a.ping()                    
                    
---------------------------------------------------------------
#'adding a script property, after the object is defined
$obj | Add-Member -MemberType ScriptProperty `
                    -Name TopProcesses `
                    -Value { 
                    Get-Process -ComputerName $this.computername |
                    Sort-Object -Property WorkingSet -Descending |
                    Select-Object -first 5
                    }
'USAGE of property
----------------
&gt;$a.TopProcesses


#' insert a custom name
$obj.psobject.TypeNames.Insert(0,"myMachineInfo")   &lt;=== The authors said this was flaky



#' extending with update-typedata
$myType = "myMachineInfo"

Update-TypeData -TypeName $myType -DefaultDisplayPropertySet 'ComputerName','OSVersion','Cores','RAM' -force

Update-TypeData -TypeName $myType -MemberType AliasProperty -MemberName Free `
                                  -Value SysDriveFreeSpace -force 

Update-TypeData -TypeName $myType -MemberType ScriptMethod -MemberName Ping `
                                  -Value { 
                                    Test-NetConnection $this.computername 
                                   } -force 

Update-TypeData -TypeName $myType -MemberType ScriptProperty -MemberName `
                              TopProcesses -Value { 
                              Get-Process -ComputerName $this.computername |
                              Sort-Object -Property WorkingSet -Descending |
                              Select-Object -first 5
                              } -force



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FOLDERS_Blocked_Inheritance</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FOLDERS_Blocked_Inheritance</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://www.petri.com/identify-folders-with-blocked-inheritance-using-powershell
'AreAccessRulesProtected is a boolean property. If the value is true, then inheritance has been disabled. 
cls
dir 'C:\Program Files' -Directory | get-acl | 
Select @{Name="Path";Expression={Convert-Path $_.Path}},AreAccessRulesProtected |
Format-table -AutoSize
#' If the value is true, then inheritance has been disabled

--------------

'Because the AreAccessRulesProtected property is a boolean, you dont need to use the eq operator, 
'	so its a simple matter to filter out folders that have blocked inheiritance
dir c:\work -Directory -recurse | get-acl | 
Where {$_.AreAccessRulesProtected} | 
Select @{Name="Path";Expression={Convert-Path $_.Path}},AreAccessRulesProtected |
format-table -AutoSize
'These are the folders under C:\Work that have inheritance disabled.
'If I want to find folders that have inheritance enabled, then I can use the NOT operator in my filter.

-----------------
'This on the other had is the folders w/ blocked inheritance:
cls
dir 'C:\Program Files' -Directory -recurse | get-acl | 
Where  {-not $_.AreAccessRulesProtected} | 
Select @{Name="Path";Expression={Convert-Path $_.Path}},AreAccessRulesProtected |
format-table -AutoSize


====================================================
'Lets say you want to re-enable inheritance once youve identified folders with blocked inheritance. The following outlines a simple way to do so.

'First, we need the access control list for a folder.
&gt;$acl = get-acl c:\work\demo2
'To modify, we can use the SetAccessRuleProtection() method, which takes a few parameters.

------------
'This will let you see the overloads
$acl.SetAccessRuleProtection.OverloadDefinitions
-----------

'The parameter values are both boolean. 
'The second parameter indicates if you want to save existing rules, and I generally do.

&gt;$acl.SetAccessRuleProtection($False,$True)

'All Ive done is set the property on the ACL object. It hasnt been applied to the folder. 
'To accomplish that, I need to use Set-ACL.

&gt;set-acl -Path c:\work\demo2 -AclObject $acl

==============================================================
'To make life easier, I have a function called Set-Inheritance.

#requires -version 3.0
 
Function Set-Inheritance {
 
[cmdletbinding(SupportsShouldProcess)]
 
	Param(
		[Parameter(Position=0,Mandatory,HelpMessage="Enter the file or folder path",
		 ValueFromPipeline=$True,ValueFromPipelineByPropertyName)]
	[ValidateNotNullOrEmpty()]
	[Alias("PSPath")]
	[string]$Path,
	[switch]$NoInherit,
	[switch]$NoPreserve,
	[switch]$Passthru
)

'With this function, I can easily reset inheritance with a one-line command:
&gt;dir c:\work -Directory -recurse | get-acl | Where {$_.AreAccessRulesProtected} | set-inheritance -whatif

'If I intentionally want to disable or block inheritance, I can do that as well.
&gt;Set-Inheritance C:\work\demo1 -NoInherit

'Be careful about using the NoPreserve parameter with my function. If you use it all existing permissions will be wiped out</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-MyFile.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-MyFile.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#' USAGE:
&gt; .\Get-MyFile.ps1 -Criteria 'Extension' - Attributes @{'Extension' = 'log'}

#' USAGE:
&gt; .\Get-MyFile.ps1 -Criteria Age -Attributes @{'DaysOld' = 5}



#'=================================================================================================================================
param ([string[]]$Computername = 'localhost', [string]$Criteria, [hashtable]$Attributes)   #' &lt;==== an array of computer names

foreach ($Computer in $Computername) {
	## Enumerate all of the default admin shares
    $CimInstParams = @{'ClassName' = 'Win32_Share'}
    if ($Computer -ne 'localhost') {
	    $CimInstParams.Computername = $Computer    
    }
    $DriveShares = (Get-CimInstance @CimInstParams | where { $_.Name -match '^[A-Z]\$$' }).Name    #' &lt;===List of Drive Shares
	foreach ($Drive in $DriveShares) {
		switch ($Criteria) {
			'Extension' {
                Get-ChildItem -Path "\\$Computer\$Drive" -Filter "*.$($Attributes.Extension)" -Recurse
			}
			'Age' {
				$Today = Get-Date
                $DaysOld = $Attributes.DaysOld
                Get-ChildItem -Path "\\$Computer\$Drive" -Recurse | Where-Object { $_.LastWriteTime -le $Today.AddDays(-$DaysOld)}
			}
			'Name' {
                $Name = $Attributes.Name
				Get-ChildItem -Path "\\$Computer\$Drive" -Filter "*$Name*" -Recurse
			}
            default {
                Write-Error "Unrecognized criteria '$Criteria'"
            }
		}
	}
}
#'=================================================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LIST_Files_in_Folders_and_SubFolders</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LIST_Files_in_Folders_and_SubFolders</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'LIST_Files_in_Folders_and_SubFolders

 'Get all the PDF files in the folder/subfolders of  "D:\xplr" and write as .csv to: "C:\JUNK\directory.csv"
 Get-ChildItem -Path D:\xplr -Include *.pdf -Recurse | Export-Csv -Force -NoTypeInformation C:\JUNK\directory.csv

'Just a list of files and folders in a folder:, but not subfolders
Get-ChildItem -Path E:\music

'This would be the command to see only the directories at the E:\Music level:
Get-ChildItem -Path E:\music Directory

'To see only the files at this level, I change it to use the File switch:
Get-ChildItem -Path E:\music File

'When I use the Recurse switch, I can see the folders in addition to the files inside each of the folders.
' but it is not clean like a database, but rather formatted and broken up by folder
Get-ChildItem -Path E:\music\Santana Recurse

'This sorts it, BUT still not right for a database, b/c it is formatted, and broken up by folders
Get-ChildItem -Path E:\music\Santana -Recurse -File | sort length Descending

'tems that are normally invisible in File Explorer or Cmd.exe are not displayed in the output of a Get-ChildItem command. 
'	To display hidden items, use the Force parameter of Get-ChildItem. For example:
Get-ChildItem -Path C:\Windows -Force

'To find all files that begin with the letter x in the Windows directory, type:
 Get-ChildItem -Path C:\Windows\x*
 
'To find all files whose names begin with x or z, type:
Get-ChildItem -Path C:\Windows\[xz]*

'You can omit files that have any of these numbers in their names by using the Exclude parameter with the pattern *[9516]*:
Get-ChildItem -Path C:\WINDOWS\System32\w*32*.dll -Exclude *[9516]*

'To specify a recursive search for files whose names match a special pattern, use the -Include parameter.
&gt; Get-ChildItem -Path C:\Windows -Include *.dll -Recurse -Exclude [a-y]*.dll

'This one-line command will invoke Windows PowerShell to write a directory listing to a CSV file, 
'which is easy to use in spreadsheets and database programs. 
'It recurses subfolders, and it includes the following information: 
'			full file name, creation time, last modified time, file size, and owner (last modified by).


powershell "Get-ChildItem -Recurse c:\directory\to\scan\ | ForEach-Object {$_ | add-member -name "Owner" -membertype noteproperty -value (get-acl $_.fullname).owner -passthru} | Sort-Object fullname | Select FullName,CreationTime,LastWriteTime,Length,Owner | Export-Csv -Force -NoTypeInformation c:\folder\to\directory.csv"


'to limit to folders add 
	"| ?{ $_.PSIsContainer }" 
	'before 
	"| ForEach-Object" 		'(no quotation marks)
	
'this version uses relative paths (code not tested)
powershell "Get-ChildItem -Recurse . | ?{ $_.PSIsContainer } | ForEach-Object {$_ | add-member -name "Owner" -membertype noteproperty -value (get-acl $_.fullname).owner -passthru} | Sort-Object fullname | Select FullName,CreationTime,LastWriteTime,Length,Owner | Export-Csv -Force -NoTypeInformation .\directory.csv" 	

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


Get-ChildItem -Recurse 'W:\Equipment Titles and Registrations' |
     ForEach-Object {$_ |
                            add-member -name "Owner" -membertype noteproperty -value (get-acl $_.fullname).Owner -passthru       
                    } |   
     ForEach-Object {$_ |
                            add-member -name "TheFileName" -membertype noteproperty -value  $_.name -passthru    
                    } |                                    
       Sort-Object fullname |
        Select FullName,CreationTime,LastWriteTime,Length,Owner,TheFileName |
         Export-Csv -Force -NoTypeInformation c:\directory.csv

'OUTPUT:============================================================================================================
FullName																CreationTime	LastWriteTime	Length	Owner					TheFileName
C:\Junk\Report Project1													11/6/2015 16:47	11/6/2015 16:47			BUILTIN\Administrators	Report Project1
C:\Junk\Report Project1\Report Project1									11/6/2015 16:47	11/6/2015 16:47			BUILTIN\Administrators	Report Project1
C:\Junk\Report Project1\Report Project1.sln								11/6/2015 16:47	11/6/2015 16:47	1342	BUILTIN\Administrators	Report Project1.sln
C:\Junk\Report Project1\Report Project1\Report Project1.rptproj			11/6/2015 16:47	2/6/2014 13:49	204		BUILTIN\Administrators	Report Project1.rptproj
C:\Junk\Report Project1\Report Project1\Report Project1.rptproj.user	11/6/2015 16:47	11/9/2015 7:45	1076	BUILTIN\Administrators	Report Project1.rptproj.user
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Function_PARAMETERS</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Function_PARAMETERS</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>From Directions Training 

#' basic function model
function test {
    Param(
    [string]$ComputerName
    )
}
help test



#' again:
function test {
    [CmdletBinding()]
    Param(
        [string]$ComputerName
    )
}
test



#' starting with...
function Get-MachineInfo {
    Param(
        [string[]]$ComputerName,
        [string]$LogFailuresToPath,
        [string]$Protocol = "Wsman",
        [switch]$ProtocolFallback
    )
 
    foreach ($computer in $computername) {
 
        #' Establish session protocol
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        #' Connect session
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option
  
        #' Query data
        $os = Get-CimInstance -ClassName Win32_OperatingSystem `
                              -CimSession $session
  
        #' Close session
        $session | Remove-CimSession
  
        #' Output data
        $os | Select-Object -Prop @{n='ComputerName';e={$computer}},
                                Version,ServicePackMajorVersion
 
    } #'foreach
 
} #'function



#' moving to...
function Get-MachineInfo {
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True)]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        #' Establish session protocol
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        #' Connect session
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option
  
        #' Query data
        $os = Get-CimInstance -ClassName Win32_OperatingSystem `
                              -CimSession $session
  
        #' Close session
        $session | Remove-CimSession
  
        #' Output data
        $os | Select-Object -Prop @{n='ComputerName';e={$computer}},
                                Version,ServicePackMajorVersion
 
    } #'foreach
} #'PROCESS

END {}

} #'function



#' imagine this run pattern:
Get-MachineInfo -ComputerName ONE,TWO,THREE

#' versus:
"ONE","TWO","THREE" | Get-MachineInfo



#' consider doing this
End {
 #' intentionally empty
}



#' parameter decorator
[Parameter(ValueFromPipeline=$True)]


#' adding ByPropertyName
[Parameter(ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True)]



#' marking mandatory
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )



#' adding validation
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )



#' aliases (more on these later)
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )





</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_GUI_form</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>02_ProcessManager_example</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_GUI_form</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>02_ProcessManager_example</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># Load required assemblies
[void] [System.Reflection.Assembly]::LoadWithPartialName(System.Windows.Forms)
[System.Windows.Forms.Application]::EnableVisualStyles()
 
# Start Creating Functions
Function GetProcesses{
 
    # Reset the columns and content of listview_Processes before adding data to it.
    $listview_Processes.Items.Clear()
    $listview_Processes.Columns.Clear()
   
    # Get a list and create an array of all running processes
    $Processes = Get-Process | Select Id,ProcessName,Handles,NPM,PM,WS,VM,CPU,Path
   
    # Compile a list of the properties stored for the first indexed process "0"
    $ProcessProperties = $Processes[0].psObject.Properties
 
    # Create a column in the listView for each property
    $ProcessProperties | ForEach-Object {
        $listview_Processes.Columns.Add("$($_.Name)") | Out-Null
    }
 
    # Looping through each object in the array, and add a row for each
    ForEach ($Process in $Processes){
 
        # Create a listViewItem, and assign it it's first value
        $ProcessListViewItem = New-Object System.Windows.Forms.ListViewItem($Process.Id)
 
        # For each properties, except for 'Id' that we've already used to create the ListViewItem,
        # find the column name, and extract the data for that property on the current object/process
        $Process.psObject.Properties | Where {$_.Name -ne "Id"} | ForEach-Object {
            $ColumnName = $_.Name
            $ProcessListViewItem.SubItems.Add("$($Process.$ColumnName)") | Out-Null
        }
 
        # Add the created listViewItem to the ListView control
        # (not adding 'Out-Null' at the end of the line will result in numbers outputred to the console)
        $listview_Processes.Items.Add($ProcessListViewItem) | Out-Null
 
    }
 
    # Resize all columns of the listView to fit their contents
    $listview_Processes.AutoResizeColumns("HeaderSize")
 
}
 
Function EndProcesses{
 
    # Since we allowed 'MultiSelect = $true' on the listView control,
    # Compile a list in an array of selected items
    $SelectedProcesses = @($listview_Processes.SelectedIndices)
 
    # Find which column index has an the name 'Id' on it, for the listView control
    # We chose 'Id' because it is required by 'Stop-Process' to properly identify the process to kill.
    $IdColumnIndex = ($listview_Processes.Columns | Where {$_.Text -eq "Id"}).Index
   
    # For each object/item in the array of selected item, find which SubItem/cell of the row...
    $SelectedProcesses | ForEach-Object {
   
        # ...contains the Id of the process that is currently being "foreach'd",
        $ProcessId = ($listview_Processes.Items[$_].SubItems[$IdColumnIndex]).Text
       
        # ...and stop it.
        Stop-Process -Id $ProcessId -Confirm:$false -Force -WhatIf
 
        # The WhatIf switch was used to simulate the action. Remove it to use cmdlet as per normal.
 
    }
 
    # Refresh your process list, once you are done stopping them
    GetProcesses
   
}
 
 
# Drawing form and controls
$Form_HelloWorld = New-Object System.Windows.Forms.Form
    $Form_HelloWorld.Text = Process Manager
    $Form_HelloWorld.Size = New-Object System.Drawing.Size(832,528)
    $Form_HelloWorld.FormBorderStyle = "FixedDialog"
    $Form_HelloWorld.TopMost  = $true
    $Form_HelloWorld.MaximizeBox  = $true
    $Form_HelloWorld.MinimizeBox  = $true
    $Form_HelloWorld.ControlBox = $true
    $Form_HelloWorld.StartPosition = CenterScreen
    $Form_HelloWorld.Font = "Segoe UI"
 
 
# Adding a label control to Form
$label_HelloWorld = New-Object System.Windows.Forms.Label
    $label_HelloWorld.Location = New-Object System.Drawing.Size(8,8)
    $label_HelloWorld.Size = New-Object System.Drawing.Size(240,32)
    $label_HelloWorld.TextAlign = "MiddleLeft"
    $label_HelloWorld.Text = Processes:
        $Form_HelloWorld.Controls.Add($label_HelloWorld)
 
 
# Adding a listView control to Form, which will hold all process information
$Global:listview_Processes = New-Object System.Windows.Forms.ListView
    $listview_Processes.Location = New-Object System.Drawing.Size(8,40)
    $listview_Processes.Size = New-Object System.Drawing.Size(800,402)
    $listview_Processes.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor
    [System.Windows.Forms.AnchorStyles]::Right -bor
    [System.Windows.Forms.AnchorStyles]::Top -bor
    [System.Windows.Forms.AnchorStyles]::Left
    $listview_Processes.View = "Details"
    $listview_Processes.FullRowSelect = $true
    $listview_Processes.MultiSelect = $true
    $listview_Processes.Sorting = "None"
    $listview_Processes.AllowColumnReorder = $true
    $listview_Processes.GridLines = $true
    $listview_Processes.Add_ColumnClick({SortListView $_.Column})
        $Form_HelloWorld.Controls.Add($listview_Processes)
 
 
# Adding a button control to Form
$button_GetProcess = New-Object System.Windows.Forms.Button
    $button_GetProcess.Location = New-Object System.Drawing.Size(8,450)
    $button_GetProcess.Size = New-Object System.Drawing.Size(240,32)
    $button_GetProcess.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor
    [System.Windows.Forms.AnchorStyles]::Left
    $button_GetProcess.TextAlign = "MiddleCenter"
    $button_GetProcess.Text = Refresh Process List
    $button_GetProcess.Add_Click({GetProcesses})
        $Form_HelloWorld.Controls.Add($button_GetProcess)
 
 
# Adding another button control to Form
$button_EndProcess = New-Object System.Windows.Forms.Button
    $button_EndProcess.Location = New-Object System.Drawing.Size(568,450)
    $button_EndProcess.Size = New-Object System.Drawing.Size(240,32)
    $button_EndProcess.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor
    [System.Windows.Forms.AnchorStyles]::Right
    $button_EndProcess.TextAlign = "MiddleCenter"
    $button_EndProcess.Text = End Selected Process(es)
    $button_EndProcess.Add_Click({EndProcesses})
        $Form_HelloWorld.Controls.Add($button_EndProcess)
 
 
 
# Show form with all of its controls
$Form_HelloWorld.Add_Shown({$Form_HelloWorld.Activate();GetProcesses})
[Void] $Form_HelloWorld.ShowDialog()</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Help</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>example</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Help</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>example</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'You do not have to use all-uppercase letters, but the period preceding each help keyword 
'	(.SYNOPSIS, .DESCRIPTION) must be in the first column. 
 



# completed...
function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Write-Verbose "Connecting to $computer over $protocol"
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option
  
        Write-Verbose "Querying from $computer"
        $os_params = @{'ClassName'='Win32_OperatingSystem'
                       'CimSession'=$session}
        $os = Get-CimInstance @os_params

        $cs_params = @{'ClassName'='Win32_ComputerSystem'
                       'CimSession'=$session}
        $cs = Get-CimInstance @cs_params

        $sysdrive = $os.SystemDrive
        $drive_params = @{'ClassName'='Win32_LogicalDisk'
                          'Filter'="DeviceId='$sysdrive'"
                          'CimSession'=$session}
        $drive = Get-CimInstance @drive_params

        $proc_params = @{'ClassName'='Win32_Processor'
                         'CimSession'=$session}
        $proc = Get-CimInstance @proc_params |
                Select-Object -first 1

  
        Write-Verbose "Closing session to $computer"
        $session | Remove-CimSession
  
        Write-Verbose "Outputting for $computer"
        $obj = [pscustomobject]@{'ComputerName'=$computer
                   'OSVersion'=$os.version
                   'SPVersion'=$os.servicepackmajorversion
                   'OSBuild'=$os.buildnumber
                   'Manufacturer'=$cs.manufacturer
                   'Model'=$cs.model
                   'Procs'=$cs.numberofprocessors
                   'Cores'=$cs.numberoflogicalprocessors
                   'RAM'=($cs.totalphysicalmemory / 1GB)
                   'Arch'=$proc.addresswidth
                   'SysDriveFreeSpace'=$drive.freespace}
        Write-Output $obj
 
    } #foreach
} #PROCESS

END {}

} #function



# prettier...
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.

.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.

.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.

.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.

.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.

.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.

.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.

.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;



# more sections...
&lt;#
.INPUTS
System.String

.NOTES
version     : 1.0.0
last updated: 1 February, 2017

.LINK
https://powershell.org/forums/
.LINK
Get-CimInstance
.LINK
Get-WmiObject

#&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Input</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-Content</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Input</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-Content</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
LINE BREAKS issue

Get-Content : 'will split the file at the newlines, 
			  'effectively removing the line breaks. 
			  
			  'Use the -Raw switch to read the file as a single string, keeping the newlines intact:
			  'The -Raw parameter will bring the entire contents in as a multi-line string.

				$Contents = get-content $File -Raw

				'vs this, which strips out the newlines:

				$Contents = Get-Content $File

'The -ReadCount parameter on Get-Content defines how many lines that Get-Content will read at once.

 'This example will count how many times each error shows up in the $Path. 
 'This pipeline can process each line as it is read from the file.
 
$dataset = @{}
Get-Content -Path $path -ReadCount 15 |
    Where-Object {$PSItem -match 'error'} |
    ForEach-Object {$dataset[$PSItem] += 1}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Input</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>readWrite_LineBreaks_Get-Content</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Input</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>readWrite_LineBreaks_Get-Content</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>readWrite_LineBreaks_Get-Content

LINE BREAKS issue

'Get-Content will split the file at the newlines, 
	'effectively removing the line breaks and puts each line into an array
'Use the -Raw switch to read the file as a single string, keeping the newlines intact:

$Contents = get-content $File -Raw

'vs this, which strips out the newlines:

$Contents = Get-Content $File

'Then $Contents contains an array of strings that represent the lines in the file.
'By sending that back out to Set-Content 
'	(which knows how to handle an array or pipeline of strings) 
'	it will write lines.

'You can join the cells of the array with a line break character, into one long string:
$content = (Get-Content $File) -join "`r`n" 

'When you use "$contents" the array items will be joined with spaces, not newlines, 
'	so when you use $stream.WriteLine you are writing a single string with one line break at the end.
'EXAMPLE:
$File = "c:\somefile"
$Contents = get-content $File
$stream = [System.IO.StreamWriter] $File
$stream.WriteLine("$contents")
$stream.close()
'Then the file looks as though all line breaks have been ignored and is a bit of a mess.

'OR to Stream the incoming array, and have the line breaks in the output file:
 $inFile = "c:\infile.txt"
 $outFile = "c:\outfile.txt"
$content = (Get-Content $inFile) -join "`r`n" 
$stream = [System.IO.StreamWriter] $outFile
$stream.Write(($content -join "`r`n"))</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Query IIS Logs using Logparser via Powershell - example </Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Query IIS Logs using Logparser via Powershell - example </Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

#'Query IIS Logs using Logparser via Powershell
#' https://gallery.technet.microsoft.com/office/Query-IIS-Logs-using-fa66667f



&lt;#
=====================================
Script Created by - Binu Balan      
Script Created on - 11/8/2015
Version - V 1.1
Requirement *
PowerShell = 2.0 or above
This script is used to perform query
Huge IIS Log Files
	 .__.
     (oo)____
     (__)    )\
        ll--ll '
=====================================
#&gt;
cls
Write-Host " "
Write-Host " "
Write-host " AAAAAAAA     PPPPPPPPP    PPPPPPPPP    UUU    UUU" -ForegroundColor Green
Write-host "AAAAAAAAAA    PPP   PPPP   PPP   PPPP   UUU    UUU" -ForegroundColor Green
Write-host "AAA    AAA    PPP    PPP   PPP    PPP   UUU    UUU" -ForegroundColor Green
Write-host "AAAAAAAAAA    PPPPPPPP     PPPPPPPP     UUU    UUU" -ForegroundColor Green
Write-host "AAA    AAA    PPP          PPP          UUU    UUU" -ForegroundColor Green
Write-host "AAA    AAA    PPP          PPP           UUUUUUUU" -ForegroundColor Green
Write-Host " "
Write-Host " " 
Write-host "	           .__." -ForegroundColor Green
Write-host "                   (oo)____" -ForegroundColor Green
Write-host "                   (__)    )\" -ForegroundColor Green
Write-host "                      ll--ll '" -ForegroundColor Green
Write-Host "               SCRIPT BY BINU BALAN               " -ForegroundColor DarkYellow -BackgroundColor DarkBlue 
Write-Host " "
Write-Host " "


$i = 1

# Getting Input from User
# =======================
Write-Host " "
Write-Host " "
Write-Host "Pre-Requisite Check for the Logparser.exe on local path" -NoNewline

Start-Sleep -Seconds 2
If(Test-Path -Path Logparser.exe){
Write-Host "                 [   OK   ]" -ForegroundColor Green
} Else {
Write-Host "                 [ Failed ]" -ForegroundColor Red
Write-Host " "
Write-Host " "
Write-Warning "Either Logparser is not installed or you are running this script on a different folder where Logparser.exe file is unavailable."
Write-Host " "
Write-Host "To download logparser follow this link : " -NoNewline -BackgroundColor Yellow -ForegroundColor Black
Write-Host "http://www.microsoft.com/en-in/download/details.aspx?id=24659" -ForegroundColor Blue -BackgroundColor Yellow
Write-Host " "
exit
}



Write-Host " "
Write-Host " "
$ReportPath = Read-Host "Enter Report Folder Path [Ex: c:\reports] "
$ReportName = Read-Host "Enter the report file name [Ex: LogReport.csv] "
Write-Host " "
Write-Host " "

Write-Host "Select the query type that you want to perform against the log?" -ForegroundColor Yellow
Write-Host "&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt; " -ForegroundColor Blue
Write-Host "1. Date             Example -2014-12-02" -ForegroundColor Green
Write-Host "2. Time             Example -00:00:12" -ForegroundColor Green
Write-Host "3. s-ip             Example -192.168.1.20" -ForegroundColor Green
Write-Host "4. cs-method        Example - GET/POST" -ForegroundColor Green
Write-Host "5. cs-uri-query     Example - /EWS/Exchange.asmx" -ForegroundColor Green
Write-Host "6. s-port           Example -443" -ForegroundColor Green
Write-Host "7. cs-username      Example -appudomain\binu.balan" -ForegroundColor Green
Write-Host "8. c-ip             Example -106.33.98.222" -ForegroundColor Green
Write-Host "9. cs(user-Agent)   Example -Microsoft+office" -ForegroundColor Green
Write-Host "10. sc-status       Example -401" -ForegroundColor Green
Write-Host "11. sc-substatus    Example -1" -ForegroundColor Green
Write-Host "12. sc-win32-status " -ForegroundColor Green
Write-Host "13. time-taken" -ForegroundColor Green
Write-Host " "
Write-Host " "

$GetInput = Read-host "Enter the query number "

switch ($GetInput) 
    { 
        1 {$WhereVal = "Date"} 
        2 {$WhereVal = "Time"} 
        3 {$WhereVal = "s-ip"} 
        4 {$WhereVal = "cs-method"} 
        5 {$WhereVal = "cs-uri-query"} 
        6 {$WhereVal = "s-port"} 
        7 {$WhereVal = "cs-username"} 
        8 {$WhereVal = "c-ip"} 
        9 {$WhereVal = "cs(user-Agent)"} 
        10 {$WhereVal = "sc-status"} 
        11 {$WhereVal = "sc-substatus"} 
        12 {$WhereVal = "sc-win32-status"} 
        13 {$WhereVal = "time-taken"} 

        default {"You have input invalid data !!"}
    }

if ($WhereVal -eq $null) {

Write-Host "You have entered invalid data. Exiting the Script"

exit

}

Write-host "Enter Log folder path. For multiple folders use Comma separated value [Example [C:\Log1,C:\Log2"
$ORRFolderpath = Read-Host "Enter here "

$WhereQuery = Read-Host ("Enter the Query for $WhereVal ")
$EachFolder = $ORRFolderpath.Split(",")
$EachIP = $WhereQuery.Split(",")


#$RName = Read-Host ("Enter Report Name with CSV Extension - (Result.csv)")
#$RPath = Read-Host ("Enter the path where you want to store the report - (C:\Report)")



ForEach ($S_Folder in $EachFolder) {

    ForEach ($IP in $EachIP) {

    $LogPath = $S_Folder
    $FileNames = Get-childItem -Path $LogPath


            ForEach ($File in $FileNames) {

            Write-Host "Script Line $i - .\LogParser.exe SELECT * INTO $ReportPath\$ReportName FROM $LogPath\$File WHERE $WhereVal LIKE '%$IP%' -filemode:0" -ForegroundColor Yellow


            $i = $i + 1

            .\LogParser.exe "SELECT * INTO $ReportPath\$ReportName FROM $LogPath\$File WHERE $WhereVal LIKE '%$IP%'" -filemode:0

            Write-Host "[ Completed ]" -ForegroundColor Green

            Write-Host "    "
            Write-Host "    "

            }


    }

}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>foreach_Switch</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>foreach_Switch</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function ll
{
    param ($dir = ".", $all = $false)
 
    $origFg = $Host.UI.RawUI.ForegroundColor
    if ( $all ) { $toList = ls -force $dir }
    else { $toList = ls $dir }
 
    foreach ($Item in $toList)
    {
        Switch ($Item.Extension)
        {
            ".exe" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".hta" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".cmd" {$Host.UI.RawUI.ForegroundColor="DarkRed"}
            ".ps1" {$Host.UI.RawUI.ForegroundColor="DarkGreen"}
            ".html" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".htm" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".7z" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".zip" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".gz" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".rar" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            Default {$Host.UI.RawUI.ForegroundColor=$origFg}
        }
        if ($item.Mode.StartsWith("d")) {$Host.UI.RawUI.ForegroundColor="Gray"}
        $item
    }
    $Host.UI.RawUI.ForegroundColor = $origFg
} </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Loop_Through_Records_from_TEXT_file_DoSomething_Export_To_Excel_file</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Loop_Through_Records_from_TEXT_file_DoSomething_Export_To_Excel_file</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'#Loop_Through_Records_from_TEXT_file_DoSomething_Export_To_Excel_file


#### Spreadsheet Location 
 $DirectoryToSaveTo = "c:\" 
 $date=Get-Date -format "yyyy-MM-d" 
 $Filename="Patchinfo-$($patch)" 
 
  
 ###InputLocation 
 $Computers = Get-Content "c:\computers.txt" 
 

  
 
  
# before we do anything else, are we likely to be able to save the file? 
# if the directory doesn't exist, then create it 
if (!(Test-Path -path "$DirectoryToSaveTo")) #create it if not existing 
  { 
  New-Item "$DirectoryToSaveTo" -type directory | out-null 
  } 
   
 
 
#Create a new Excel object using COM  
$Excel = New-Object -ComObject Excel.Application 
$Excel.visible = $True 
$Excel = $Excel.Workbooks.Add() 
$Sheet = $Excel.Worksheets.Item(1) 
 
$sheet.Name = 'Patch status - ' 
#Create a Title for the first worksheet 
$row = 1 
$Column = 1 
$Sheet.Cells.Item($row,$column)= 'Patch status'  
 
$range = $Sheet.Range("a1","f2") 
$range.Merge() | Out-Null 
$range.VerticalAlignment = -4160 
 
#Give it a nice Style so it stands out 
$range.Style = 'Title' 
 
#Increment row for next set of data 
$row++;$row++ 
 
#Save the initial row so it can be used later to create a border 
#Counter variable for rows 
$intRow = $row 
$xlOpenXMLWorkbook=[int]51 
 
#Read thru the contents of the Servers.txt file 
 
$Sheet.Cells.Item($intRow,1)  ="Name" 
$Sheet.Cells.Item($intRow,2)  ="status" 
$Sheet.Cells.Item($intRow,3)  ="Patch status" 
$Sheet.Cells.Item($intRow,4)  ="OS" 
$Sheet.Cells.Item($intRow,5)  ="SystemType" 
$Sheet.Cells.Item($intRow,6)  ="Last Boot Time" 
 
 
for ($col = 1; $col le 6; $col++) 
     { 
          $Sheet.Cells.Item($intRow,$col).Font.Bold = $True 
          $Sheet.Cells.Item($intRow,$col).Interior.ColorIndex = 48 
          $Sheet.Cells.Item($intRow,$col).Font.ColorIndex = 34 
     } 
 
$intRow++ 
 
 
#Function GetStatusCode 
#{  
#    Param([int] $StatusCode)   
#    switch($StatusCode) 
#    { 
#        0         {"Success"} 
#        11001   {"Buffer Too Small"} 
#        11002   {"Destination Net Unreachable"} 
#        11003   {"Destination Host Unreachable"} 
#        11004   {"Destination Protocol Unreachable"} 
#        11005   {"Destination Port Unreachable"} 
#        11006   {"No Resources"} 
#        11007   {"Bad Option"} 
#        11008   {"Hardware Error"} 
#        11009   {"Packet Too Big"} 
#        11010   {"Request Timed Out"} 
#        11011   {"Bad Request"} 
#        11012   {"Bad Route"} 
#        11013   {"TimeToLive Expired Transit"} 
#        11014   {"TimeToLive Expired Reassembly"} 
#        11015   {"Parameter Problem"} 
#        11016   {"Source Quench"} 
#        11017   {"Option Too Big"} 
#        11018   {"Bad Destination"} 
#        11032   {"Negotiating IPSEC"} 
#        11050   {"General Failure"} 
#        default {"Failed"} 
#    } 
#} 
 
 
 
Function GetUpTime 
{ 
    param([string] $LastBootTime) 
    $Uptime = (Get-Date) - [System.Management.ManagementDateTimeconverter]::ToDateTime($LastBootTime) 
    "Days: $($Uptime.Days); Hours: $($Uptime.Hours); Minutes: $($Uptime.Minutes); Seconds: $($Uptime.Seconds)"  
} 
 
 
foreach ($Computer in $Computers)         
			 {                    #'&lt;===========   Loop Starts
 
				TRY 
					{ 
							$OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer 
							$sheetS = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Computer 
							$date = Get-Date 
					} 
  
				CATCH 
					{ 
							$pcnotfound = "true" 
					} 


				 #### Pump Data to Excel 
				 if ($pcnotfound -eq "true") 
				 { 

				 $sheet.Cells.Item($intRow, 1) = $computer 
				 $sheet.Cells.Item($intRow, 2) = "PC Not Found" 
				 } 
				 else 
				 { 
				 $sheet.Cells.Item($intRow, 1) = $computer 
				 $sheet.Cells.Item($intRow, 2) = $status 
				 $Sheet.Cells.Item($intRow, 3) = $kbinstall 
				 $sheet.Cells.Item($intRow, 4) = $OSRunning 
				 $Sheet.Cells.Item($intRow, 5) = $SystemType 
				 $sheet.Cells.Item($intRow, 6) = $uptime 
				 } 
 
  
				$intRow = $intRow + 1 
				 $pcnotfound = "false" 
			 }                       #'&lt;===========   Loop Ends
 
$erroractionpreference = SilentlyContinue  
 
$Sheet.UsedRange.EntireColumn.AutoFit() 
########################################333 
 
 
 
############################################################## 
 
$filename = "$DirectoryToSaveTo$filename.xlsx" 
#if (test-path $filename ) { rm $filename } #delete the file if it already exists 
$Sheet.UsedRange.EntireColumn.AutoFit() 
$Excel.SaveAs($filename, $xlOpenXMLWorkbook) #save as an XML Workbook (xslx) 
$Excel.Saved = $True 
$Excel.Close() 
$Excel.DisplayAlerts = $False 
$Excel.quit()</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Loop_ThroughComputers_MultiColumnOutput_toFile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Loop_ThroughComputers_MultiColumnOutput_toFile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://filedb.experts-exchange.com/incoming/2015/11_w47/1030521/get-officeversion.ps1..txt
=============================================================================================
#'USAGE
$testcomputers = Get-Content -Path 'C:\DATA\DeskTops_AIO_EB_2018_04_03.txt'
$exportLocation = 'C:\DATA\OfficeVersions.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path C:\DATA\ComputersThatRespondToPing.txt
		}else{
			Add-Content -value $computer -path C:\DATA\DeadPCs.txt
		}
	}
	
#'Proceed with inventory of Live PCs
#'get-officeversion $testcomputers $exportLocation
get-officeversion -Infile C:\DATA\ComputersThatRespondToPing.txt -outfile C:\DATA\GetOffice_results.txt


=============================================================================================
&lt;#
.Synopsis
   Get-OfficeVersion 
.DESCRIPTION
   Gets the Office version from a list of computernames and returns a CSV of the Computername and Office Version (if available)
.EXAMPLE
 get-officeversion c:\test\servers.txt c:\test\officeversions.csv
.EXAMPLE
 get-officeversion -infile c:\test\servers.txt -outfile c:\test\officeversions.csv
.NOTES
   General notes
.PARAMETER infile
A path and a filename to a text file contains a list of the computernames or ip addresses to check the office version.
.PARAMETER Outfile
A path and filename of the output .csv file

#&gt;
function Get-OfficeVersion
{
#'..................................................................................................FUNCTION - START
param(
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $Infile,
    
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $outfile
    )
#$outfile = 'C:\temp\office.csv'
#$infile = 'c:\temp\servers.txt'
Begin
    {
    }
 Process
    {
    #'************************************************************************************************PROCESS - START
		    $office = @()
		    $computers = Get-Content $infile
		    $i=0
		    $count = $computers.count   
		    foreach($computer in $computers)
		     {
		      #'=======================================================================================FOREACH - START
		     $i++
		     Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
		      -PercentComplete ($i/$count*100)
		        $info = @{}
		        $version = 0
			    try{
				          $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $computer) 
				          $reg.OpenSubKey('software\Microsoft\Office').GetSubKeyNames() |
				          	ForEach-Object {
									            if ($_ -match '(\d+)\.') 
										            {
										              if ([int]$matches[1] -gt $version) 
											              {
											                $version = $matches[1]
											              }
										            }    
			      						}
				          if ($version) {
								            Write-Debug("$computer : found $version")
								            switch($version) {
												                "7" {$officename = 'Office 97' }
												                "8" {$officename = 'Office 98' }
												                "9" {$officename = 'Office 2000' }
												                "10" {$officename = 'Office XP' }
												                "11" {$officename = 'Office 97' }
												                "12" {$officename = 'Office 2003' }
												                "13" {$officename = 'Office 2007' }
												                "14" {$officename = 'Office 2010' }
												                "15" {$officename = 'Office 2013' }
												                "16" {$officename = 'Office 2016' }
												                default {$officename = 'Unknown Version'}
												            }
								    
								          }
			      }
			  catch{
		          $officename = 'Not Installed/Not Available'
		      	   }
			  $info.Computer = $computer
			  $info.Name= $officename
			  $info.version =  $version
			
			  $object = new-object -TypeName PSObject -Property $info
			  $office += $object
			#'=======================================================================================FOREACH - END  
		    }
		    $office | select computer,version,name | Export-Csv -NoTypeInformation -Path $outfile
		  
		    
		    
    #'************************************************************************************************PROCESS - END		    
    }
    
    
#'..................................................................................................FUNCTION - END    
}
  write-output ("Done")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Switch</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Switch</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


'EXAMPLE

function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[string]$VMName
	)
	
    switch ($VMName) {  										 
        'SQLInjectAttackName' {													&lt;===== So if VMName = 'SQLInjectAttackName'
            Write-Error -Message "OMG! Someone's trying to H@x0r our base!"		'Then do this
        }

        'AlreadyExists' {
            Write-Warning -Message "You got a problem. This VM already exists so you can't add it, dummy"
        }

        'DoesNotExistAlready' {
            Write-Verbose -Message 'The VM does not already exist. You may proceed to add a new one with that name'
        }

        'FlakyIssue' {
            $ThatVariable = 'notright'
            Write-Debug -Message 'I will add this VM on host 123, blade 4564 on the molecule H2S squared'
        }
    }
}

/////////////////////////////////////////////////////////////


# Switch statement for multiple conditions
Clear-Host
$var = 42                   # Also test with 43 and 49
switch  ($var)
{
  41 {"Forty One"}
  42 {"Forty Two"}
  43 {"Forty Three"}
  default {"default"}
}



# Will match all lines that match
Clear-Host
$var = 42
switch  ($var)
{
  42 {"Forty Two"}
  "42" {"Forty Two String"}
  default {"default"}
}
# Note type coercion will cause both 42 lines to have a match


# To stop processing once a block is found use break
# The semicolon (;) let's you put more than one command on the line
# the "break" ends processing within the brackets, or script block, and jumps to the code right after the brackets
Clear-Host
$var = 42
switch  ($var)
{
  42 {"Forty Two - 1"; break}
  42 {"Forty Two - 2"             #You can break the previous line into multiple lines w/out semicolons as well
       break
       }
  "42" {"Forty Two String"; break}
  default {"default"}
}
# Note, if you want to put multiple commands on a single line, use a ; to separate them


# Switch works with collections, looping and executing for each match
Clear-Host
switch (3,1,2,42)       # So it will go through the options for each item in this collection, and produce results for each.
{
  1 {"One"}
  2 {"Two"}
  3 {"Three"}
  default {"The default answer"}
}


# String compares are case insensitive by default
Clear-Host
switch ("PowerShell")
{
  "powershell" {"lowercase"}
  "POWERSHELL" {"uppercase"}
  "PowerShell" {"mixedcase"}
}



# Use the -casesenstive switch to make it so
Clear-Host
switch -casesensitive ("PowerShell")
{
  "powershell" {"lowercase"}
  "POWERSHELL" {"uppercase"}
  "PowerShell" {"mixedcase"}
}


# Supports wildcards
Clear-Host
switch -Wildcard ("Pluralsight")
{
  "plural*" {"*"}
  "?luralsight" {"?"}
  "Pluralsi???" {"???"}
}

# Note it will also support regex matches

#endregion Logic Branching

##
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WaitForReboot_Remote_Computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WaitForReboot_Remote_Computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--------------------------------------------------------------------------------
https://4sysops.com/archives/add-a-computer-to-an-active-directory-domain-with-powershell/

function Add-AcmeComputer {

						    param(
								        [string[]]$ComputerName,
								        [string]$Domain,
								        [switch]$Wait
								    )
						 
						    foreach ($computer in $ComputerName) 
						    {
						    
						    
						        if (-not (Test-Connection -ComputerName $computer -Quiet -Count 1)) 
							        {
							            Write-Warning "Could not ping computer [$computer]"
							        } 
						        else 
							        {
							            Write-Information "[$computer] is being added to domain [$Domain]..."   #' &lt;===== Message: what is occuring
							            
							            #'========================================================================Actions
							            Add-Computer -ComputerName $computer -Domain $Domain -Restart
							            #'========================================================================            
							           
							            if ($Wait.IsPresent) 
							            	{
							                #' Give it some time to go offline
							                while (Test-Connection -ComputerName $computer -Quiet -Count 1) 
										                {
										                    Start-Sleep -Seconds 2
										                }
							 
							                #' It's now offline, wait for it to come back
							                while (-not (Test-Connection -ComputerName $computer -Quiet -Count 1)) 
										                {
										                    Start-Sleep -Seconds 2
										                    Write-Information "[$computer] rebooted and is back!"
										                }
							            	}
							            Write-Information "[$computer] was added to domain [$Domain]..."
							        }
						    }
						}
--------------------------------------------------------------------------------
'Waiting for restart
https://itknowledgeexchange.techtarget.com/powershell/waiting-for-restart/
--------------------------------------------------------------------------------
'Restart server and wait for service to be available
http://community.idera.com/powershell/ask_the_experts/f/learn_powershell_from_don_jones-24/23349/restart-server-and-wait-for-service-to-be-available

--------------------------------------------------------------------------------
https://www.sapien.com/forums/viewtopic.php?t=7226

function WaitForWMI{
     Param(
           $computername
     )
     $msg='Timed out after {1:N0} seconds connecting to {0}.  Trying again'
     $starttime=[datetime]::Now
     While(!(GWMI Win32_Bios -computername $computername -ea 0)){
           Write-Host ( $msg -f $computername, $([datetime]::Now -$starttime).TotalSeconds) -fore green
     }
      Write-Host ('Host {0} conncted at {1}'  -f $computername, [datetime]::Now) -fore blue -back white
}
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Menus_and_Controllers</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>basic_menu_FANCY</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Menus_and_Controllers</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>basic_menu_FANCY</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#a fancier function using Write-Host

Function Invoke-MyMenu {

[cmdletbinding()]
Param()

#start with a clear screen
Clear-Host

$title = "Help Desk Menu"
$menuwidth = 30
#calculate how much to pad left to center the title
[int]$pad = ($menuwidth/2)+($title.length/2)	     #' use this for formatting base on the width of the menu

#define a here string for the menu options
$menu = @"

1. Get services
2. Get processes
3. Get System event logs
4. Check free disk space (MB)
5. Quit

"@

Write-Host ($title.PadLeft($pad)) -ForegroundColor Cyan   #'color the title
Write-Host $menu -ForegroundColor Yellow				  #' color the menu itself

#Read-Host writes strings but we can specifically treat the result as
#an integer
[int]$r = Read-Host "Select a menu choice"

#validate the value
if ((1..5) -notcontains $r ) {
        write-warning "$r is not a valid choice"
        pause
        Invoke-Mymenu
}
elseif ((1..4) -contains $r) {
    #get computername for first four menu choices
    $Computername = Read-Host "Enter a computername or press Enter to use the localhost"
    if ($Computername -notmatch "\w+") {
        $computername = $env:COMPUTERNAME
    }
}

#code to execute
Switch ($r) {
    1 {
        Get-Service -computername $Computername
    }
    2 {
        Get-Process -computername $Computername
    }
    3 {
        Get-Eventlog -LogName System -Newest 25 -ComputerName $Computername
    }
    4 {
        $c = Get-CimInstance -ClassName win32_logicaldisk -ComputerName $computername -filter "deviceid='c:'"
        $c.FreeSpace/1mb
    }
    5 {
        Write-Host "Have a nice day" -ForegroundColor Green
        #bail out of the command 
        Return
    }
} #switch

#insert a blank line
write-host ""
pause

#run this function again
&amp;$MyInvocation.MyCommand

} #end function </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Menus_and_Controllers</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>basic_menu_Improved</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Menus_and_Controllers</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>basic_menu_Improved</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#a function based menu

Function Invoke-MyMenu {

[cmdletbinding()]
Param()

#start with a clear screen
Clear-Host

#define a here string for the menu options
$menu = @"

        MyMenu
--------------------------
1. Get services
2. Get processes
3. Get System event logs
4. Check free disk space (MB)
5. Quit

Select a menu choice
"@

#Read-Host writes strings but we can specifically treat the result as
#an integer
[int]$r = Read-Host $menu

#validate the value
if ((1..5) -notcontains $r ) {
        write-warning "$r is not a valid choice"
        pause
        Invoke-Mymenu
}
elseif ((1..4) -contains $r) {
    #get computername for first four menu choices
    $Computername = Read-Host "Enter a computername or press Enter to use the localhost"
    if ($Computername -notmatch "\w+") {
        $computername = $env:COMPUTERNAME
    }
}

#code to execute
Switch ($r) {
    1 {
        Get-Service -computername $Computername
    }
    2 {
        Get-Process -computername $Computername
    }
    3 {
        Get-Eventlog -LogName System -Newest 25 -ComputerName $Computername
    }
    4 {
        $c = Get-CimInstance -ClassName win32_logicaldisk -ComputerName $computername -filter "deviceid='c:'"
        $c.FreeSpace/1mb
    }
    5 {
        Write-Host "Have a nice day" -ForegroundColor Green
        #bail out of the command 
        Return    #' &lt;==== Bails out of the function
    }
} #switch

pause

#re-run this function
&amp;$MyInvocation.MyCommand     #' &amp;=Execute   and   'yInvocation.MyCommand' means execute my last command

} #end function </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Menus_and_Controllers</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>basic_menu</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Menus_and_Controllers</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>basic_menu</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#create a basic console based menu

#define a here string for the menu options
$menu = @"

        MyMenu
--------------------------
1. Get services
2. Get processes
3. Get System event logs
4. Check free disk space (MB)
5. Quit

Select a menu choice
"@

#Read-Host writes strings but we can specifically treat the result as
#an integer
[int]$r = Read-Host $menu          #' force it to be an integer, so it gets the number

$Computername = Read-Host "Enter a computername or press Enter to use the localhost"
if ($Computername -notmatch "\w+") {                                                     #' regular expression for at least a character, and more (+)
    $computername = $env:COMPUTERNAME
}

#code to execute
Switch ($r) {
    1 {
        Get-Service -computername $Computername
    }
    2 {
        Get-Process -computername $Computername
    }
    3 {
        Get-Eventlog -LogName System -Newest 25 -ComputerName $Computername
    }
    4 {
        $c = Get-CimInstance -ClassName win32_logicaldisk -ComputerName $computername -filter "deviceid='c:'"
        $c.FreeSpace/1mb
    }
    5 {
        Write-Host "Have a nice day" -ForegroundColor Green
    }
    default { 
        write-warning "$r is not a valid choice"
    }
}
'OUTPUT
-------------
#'        MyMenu
#'--------------------------
#'1. Get services
#'2. Get processes
#'3. Get System event logs
#'4. Check free disk space (MB)
#'5. Quit
#'
#'Select a menu choice: #'
#'
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Patch_Query_list_of_Computers_to_see_if_a_patch_is_installed</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Patch_Query_list_of_Computers_to_see_if_a_patch_is_installed</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://gallery.technet.microsoft.com/scriptcenter/Powershell-Query-a-patch-67cf35f8

#'The script uses GET-HOTFIX powershell cmdlet to query local or remote computers 
#'    to gather the patch/hotfix state either installed or missing on the list of servers based on the KB number. 
#'    It also queries and reports other basic OS details like OS version, system type , ping connectivity check and last boot time etc. 
#'These information is consolidate and saved into excel format to provide better human readable format.
#'
#' 
#'
#'The script, by default reads the list of servers from "C:\Computers.txt" , prompts for user input for kb number and saves the generated excel report to "C:\patchinfo*.xlsx"
#'
#'It doesn't overwrite the file automatically if the file exist by the name to avoid accidental deletion.
#'
#'The computer on which the script is run should have excel 2007 or later installed.


  
#### Spreadsheet Location 
 $DirectoryToSaveTo = "c:\" 
 $date=Get-Date -format "yyyy-MM-d" 
 $Filename="Patchinfo-$($patch)" 
 
  
 ###InputLocation 
 $Computers = Get-Content "c:\computers.txt" 
 # Enter KB to be checked here 
 $Patch = Read-Host 'Enter the KB number ? - eg: KB3011780 ' 
  
 
  
# before we do anything else, are we likely to be able to save the file? 
# if the directory doesn't exist, then create it 
if (!(Test-Path -path "$DirectoryToSaveTo")) #create it if not existing 
  { 
  New-Item "$DirectoryToSaveTo" -type directory | out-null 
  } 
   
 
 
#Create a new Excel object using COM  
$Excel = New-Object -ComObject Excel.Application 
$Excel.visible = $True 
$Excel = $Excel.Workbooks.Add() 
$Sheet = $Excel.Worksheets.Item(1) 
 
$sheet.Name = 'Patch status - ' 
#Create a Title for the first worksheet 
$row = 1 
$Column = 1 
$Sheet.Cells.Item($row,$column)= 'Patch status'  
 
$range = $Sheet.Range("a1","f2") 
$range.Merge() | Out-Null 
$range.VerticalAlignment = -4160 
 
#Give it a nice Style so it stands out 
$range.Style = 'Title' 
 
#Increment row for next set of data 
$row++;$row++ 
 
#Save the initial row so it can be used later to create a border 
#Counter variable for rows 
$intRow = $row 
$xlOpenXMLWorkbook=[int]51 
 
#Read thru the contents of the Servers.txt file 
 
$Sheet.Cells.Item($intRow,1)  ="Name" 
$Sheet.Cells.Item($intRow,2)  ="status" 
$Sheet.Cells.Item($intRow,3)  ="Patch status" 
$Sheet.Cells.Item($intRow,4)  ="OS" 
$Sheet.Cells.Item($intRow,5)  ="SystemType" 
$Sheet.Cells.Item($intRow,6)  ="Last Boot Time" 
 
 
for ($col = 1; $col le 6; $col++) 
     { 
          $Sheet.Cells.Item($intRow,$col).Font.Bold = $True 
          $Sheet.Cells.Item($intRow,$col).Interior.ColorIndex = 48 
          $Sheet.Cells.Item($intRow,$col).Font.ColorIndex = 34 
     } 
 
$intRow++ 
 
 
Function GetStatusCode 
{  
    Param([int] $StatusCode)   
    switch($StatusCode) 
    { 
        0         {"Success"} 
        11001   {"Buffer Too Small"} 
        11002   {"Destination Net Unreachable"} 
        11003   {"Destination Host Unreachable"} 
        11004   {"Destination Protocol Unreachable"} 
        11005   {"Destination Port Unreachable"} 
        11006   {"No Resources"} 
        11007   {"Bad Option"} 
        11008   {"Hardware Error"} 
        11009   {"Packet Too Big"} 
        11010   {"Request Timed Out"} 
        11011   {"Bad Request"} 
        11012   {"Bad Route"} 
        11013   {"TimeToLive Expired Transit"} 
        11014   {"TimeToLive Expired Reassembly"} 
        11015   {"Parameter Problem"} 
        11016   {"Source Quench"} 
        11017   {"Option Too Big"} 
        11018   {"Bad Destination"} 
        11032   {"Negotiating IPSEC"} 
        11050   {"General Failure"} 
        default {"Failed"} 
    } 
} 
 
 
 
Function GetUpTime 
{ 
    param([string] $LastBootTime) 
    $Uptime = (Get-Date) - [System.Management.ManagementDateTimeconverter]::ToDateTime($LastBootTime) 
    "Days: $($Uptime.Days); Hours: $($Uptime.Hours); Minutes: $($Uptime.Minutes); Seconds: $($Uptime.Seconds)"  
} 
 
 
foreach ($Computer in $Computers) 
 { 
 
 TRY { 
 $OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer 
 $sheetS = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Computer 
 $sheetPU = Get-WmiObject -Class Win32_Processor -ComputerName $Computer 
 $drives = Get-WmiObject -ComputerName $Computer Win32_LogicalDisk | Where-Object {$_.DriveType -eq 3} 
 $pingStatus = Get-WmiObject -Query "Select * from win32_PingStatus where Address='$Computer'" 
 $OSRunning = $OS.caption + " " + $OS.OSArchitecture + " SP " + $OS.ServicePackMajorVersion 
 $systemType=$sheetS.SystemType 
 $date = Get-Date 
 $uptime = $OS.ConvertToDateTime($OS.lastbootuptime) 
   
 if  
 ($kb=get-hotfix -id $Patch -ComputerName $computer -ErrorAction 2) 
 
 { 
 $kbinstall="$patch is installed" 
 } 
 else 
 { 
 $kbinstall="$patch is not installed" 
 } 
 
  
  
 if($pingStatus.StatusCode -eq 0) 
    { 
        $Status = GetStatusCode( $pingStatus.StatusCode ) 
    } 
else 
    { 
    $Status = GetStatusCode( $pingStatus.StatusCode ) 
       } 
 } 
  
 CATCH 
 { 
 $pcnotfound = "true" 
 } 
 #### Pump Data to Excel 
 if ($pcnotfound -eq "true") 
 { 
 #$sheet.Cells.Item($intRow, 1) = "PC Not Found" 
 $sheet.Cells.Item($intRow, 1) = $computer 
 $sheet.Cells.Item($intRow, 2) = "PC Not Found" 
 } 
 else 
 { 
 $sheet.Cells.Item($intRow, 1) = $computer 
 $sheet.Cells.Item($intRow, 2) = $status 
 $Sheet.Cells.Item($intRow, 3) = $kbinstall 
 $sheet.Cells.Item($intRow, 4) = $OSRunning 
 $Sheet.Cells.Item($intRow, 5) = $SystemType 
 $sheet.Cells.Item($intRow, 6) = $uptime 
 } 
 
  
$intRow = $intRow + 1 
 $pcnotfound = "false" 
 } 
 
$erroractionpreference = SilentlyContinue  
 
$Sheet.UsedRange.EntireColumn.AutoFit() 
########################################333 
 
 
 
############################################################## 
 
$filename = "$DirectoryToSaveTo$filename.xlsx" 
#if (test-path $filename ) { rm $filename } #delete the file if it already exists 
$Sheet.UsedRange.EntireColumn.AutoFit() 
$Excel.SaveAs($filename, $xlOpenXMLWorkbook) #save as an XML Workbook (xslx) 
$Excel.Saved = $True 
$Excel.Close() 
$Excel.DisplayAlerts = $False 
$Excel.quit() </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PopUp_MessageBox</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PopUp_MessageBox</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>  $msgBoxInput =  [System.Windows.MessageBox]::Show('Would you like to play a game?','Game  input','YesNoCancel','Error')
  [System.Windows.MessageBox]::Show('Hello')
  
  ============================================
  $msgBoxInput =  [System.Windows.MessageBox]::Show('Would you like to play a game?','Game  input','YesNoCancel','Error')

  switch  ($msgBoxInput) {

							  'Yes' {
							
							  ## Do something 
							
							  }

							  'No' {
							
							  ## Do something
							
							  }
							
							  'Cancel' {
							
							  ## Do something
							
							  }
  }</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>REBOOT_into_Boot_Options_Local_or_Remote_computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>REBOOT_into_Boot_Options_Local_or_Remote_computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Can put the commands in a text file that ends in .bat and run as a batch

'The shutdown command is a Command Prompt command that can be used to shut down, restart, log off, or hibernate your own computer.

'You run shutdown from the command prompt or PowerShell interface. What you can do however is create shortcuts so that you don't 
	'have to write the commands each time you want to use them, but can simply click on the shortcut instead to run them. 

'The shutdown command can also be used to remotely shut down or restart a computer you have access to over a network.

shutdown /a -- This command stops a shut down or reboot process. 
				Can be useful if Windows Update decided that it is time to reboot the PC, 
				or if your actions or other programs started the process.
shutdown /s -- The shutdown command. This shuts down the computer when you run it.
shutdown /r -- Shuts down the computer, and restarts it afterwards.
shutdown /g -- Like shutdown /r, but will restart any registered program when the system has loaded.
shutdown /h -- Hibernates the local computer.
shutdown /l -- Logs off the current user.
shutdown /p -- Turns the computer off without prior warnings. Equals running shutdown /s /f /t 0

/m \\computer -- Specify a remote computer that you want to run the command on.

/e -- This enables documentation for the shutdown of the computer.
/i -- Show the graphics user interface. Must be the first option of the command, 
		and all other switches are ignored (as the graphical user interface is loaded).
/hybrid -- Shuts the computer down, and enables Fast Startup.
			 Must be used with /s
/t 0 -- Sets the timeout period before the shutdown. 
			The default is 30 seconds, and you may speed things up by setting /t 0.
/f -- Forces running programs to terminate without user warning.  Also /force.

/c "remark" -- Adds a comment that explains the reason for the shutdown or restart of the computer. 
	Supports a maximum of 512 characters, and is displayed on the shutdown prompt.
/d -- Adds a reason for the restart using a system of codes. 
		Basically, /d p:1:2 indicates a planned shutdown because of a hardware installation, 
		while /d u:1:2 a user defined shutdown because of a hardware installation. 
		You can leave out p and u to set an unplanned reason for the shutdown. 
		The table with major and minor reasons is displayed when you run shutdown /?.
/o -- This command restarts the PC and loads the Advanced Boot Menu on the next start. Needs to be run with /r
-----------------------------------------------------
'Run a fast shutdown. This forces applications to close, and sets the

shutdown /s /f /t:0

------------------------------------------------------
'This command shuts down the remote computer ComputerXYZ after 300 seconds forcefully, 
'	adds a reason for the shutdown, and displays the comment in the shutdown prompt.

shutdown /m \\ComputerXYZ /s /f /d p:1:2 /c "Computer will restart for maintenance, save your work" /t 300</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Modules</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Modules</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Modules</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Modules</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Modules  (.psm1)

'Good Source of scripts:
	http://technet.microsoft.com/scriptcenter
	http://www.codeplex.com/

'NOTE: the name of the parent folder MUST be the same as the Module name.

'Modules - A package that contains Windows PowerShell commands in the form of functions, 
'	cmdlerts and workflows, in addition it may contain variables, aliases and providers. 
'	Modules can be written in PowerShell and/or compiled as DLLs.

'============================================================================
'To load a module to memory you can use:

$modulePath = 'C:\PS\Beginning PowerShell Scripting for Developers\demo\'
$moduleName = 'bpsd-m05-module-simple'

$module = "$($modulePath)$($moduleName).psm1"

# To use a module, you first need to import it, which runs all the code in the module
# so now the functions in the modules are in memory
Import-Module $module

'BUT if you change the module and try to re-import it the changes will not take affect
'	b/c it loads a module only once
' SO use this in DEVELOPMENT

# Because the module is already loaded, by default PS won't reload
# To force it to reload, you have to use the -Force switch
Import-Module -Force $module
'============================================================================
#' Remove a module from memory (note just used the module name, not the whole path :
Remove-Module $moduleName

#' IF your module is located in one of the module paths of the env variable you can still call one of it's functions
#'	WITHOUT explicitly importing the module that contains the function
#'  BUT if the module file is NOT located in one of the paths of your environment variable 
#'  THEN you do need to explicitly import the module to invoke it's functions




'============================================================================
'Modules have primarily 2 locations on your system:

%windir%\system32\WindowsPowerShell\v1.0\Modules 		'this is the location for system wide modules available to any user in the system.
%USERPROFILE%\Documents\WindowsPowerShell\Modules

'Each module is stored in a folder where there is a psd1 file that is known as a Module Manifest, 
'	this manifest has the settings for the module and sets the restrictions for it in terms of .Net Framework version, 
'	version of PowerShell, files to load, version, copyright, author and many other settings. 
'	This file can load what is called a main module and sub-modules each can either be a psm1 or dll file, 
'	in addition they can also be scripts that gets processes. 

'We can also have modules in other locations that can be accessed by the PowerShell session we run in, 
'	the locations are defined in the environment variable $env:PSModulePath

C:\&gt; $env:PSModulePath

C:\Users\Carlos\Documents\WindowsPowerShell\Modules;C:\Windows\system32\WindowsPowerShell\v1.0\Modules\

'If we want to add another path for PowerShell to look at we just add that path to the current environment variable:

$env:psmodulepath = $env:psmodulepath + ";"

'To list the modules that are available we use the Get-Module cmdlet withe the -listavailable parameter:

Get-Module -ListAvailable

'If you only want to see the modules that are currently loaded in to the session the -All parameter is used with Get-Module:

C:\&gt; Get-Module -All

'To import a module in to our session we just use the Import-Module cmdlet and give it the name of the module. 

&gt;  Import-Module -Name Posh-SSH -Verbose

' If you are in a session and want to know if a module is loaded the Get-Module cmndlet with the -Name option 
'	is use and we give it the module name we want to know about, 
'	if it returns the information about the module the module is loaded, if nothing is returned the module is not:

C:\&gt; Get-Module -Name posh-ssh

'To remove the module from our session we use the Remove-Module cmdlet and give it the name of the module we want to remove:

C:\&gt; Remove-Module -Name posh-ssh -Verbose

' We can also load modules by calling directly the DLL or the PSM1 file, 
'lets call another module I'm still developing for controlling Metasploit:

C:\&gt; Import-Module C:\Users\Carlos\Desktop\Posh-Metasploit.psm1 -Verbose

'If you are developing a module and whant to reload the module with the changes you just made 
'	I recommend just using the Import-Module cmdlet with the -Force parameter instead of removing and importing the module again. 


#' get a list of all the commands in a module (e.g 'PowerShellGet')
Get-command -module PowerShellGet | more</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-SubNetItems.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-SubNetItems.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Get-SubNetItems.ps1
'https://gallery.technet.microsoft.com/scriptcenter/SubNet-Scan-dad0311f

I ended up putting this in the MyFunctions Module


'This file Get-SubNetItems.ps1 contains only definition of Get-SubNetItems function. To use this tool try this:
'1) Load file with cmdlet definition. Don't forget first . It is important to load the cmdlets in the current namespace.
'PS&gt;. P:\Get-SubNetItems.ps1

'2) And next try use function.

'Basic
PS&gt;Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.10
'Formated
Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.10 | Format-Table -Property Host, IP, OS_Name, OS_Ver, WMI  -AutoSize
'To File
Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.254 | Format-Table -Property Host, IP, OS_Name, OS_Ver, WMI  -AutoSize | Out-File C:\ListOfComputers.txt
===================================================================================
Function Get-SubNetItems
{
&lt;# 
	.SYNOPSIS 
		Scan subnet machines
		
	.DESCRIPTION 
		Use Get-SubNetItems to receive list of machines in specific IP range.

	.PARAMETER StartScanIP 
		Specify start of IP range.

	.PARAMETER EndScanIP
		Specify end of IP range.

	.PARAMETER Ports
		Specify ports numbers to scan if open or not.
		
	.PARAMETER MaxJobs
		Specify number of threads to scan.
		
	.PARAMETER ShowAll
		Show even adress is inactive.
	
	.PARAMETER ShowInstantly 
		Show active status of scaned IP address instanly. 
	
	.PARAMETER SleepTime  
		Wait time to check if threads are completed.
 
	.PARAMETER TimeOut 
		Time out when script will be break.

	.EXAMPLE 
		PS C:\&gt;$Result = Get-SubNetItems -StartScanIP 10.10.10.1 -EndScanIP 10.10.10.10 -ShowInstantly -ShowAll
		10.10.10.7 is active.
		10.10.10.10 is active.
		10.10.10.9 is active.
		10.10.10.1 is inactive.
		10.10.10.6 is active.
		10.10.10.4 is active.
		10.10.10.3 is inactive.
		10.10.10.2 is active.
		10.10.10.5 is active.
		10.10.10.8 is inactive.

		PS C:\&gt; $Result | Format-Table IP, Active, WMI, WinRM, Host, OS_Name -AutoSize

		IP           Active   WMI WinRM Host              OS_Name
		--           ------   --- ----- ----              -------
		10.10.10.1    False False False
		10.10.10.2     True  True  True pc02.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.3    False False False
		10.10.10.4     True  True  True pc05.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.5     True  True  True pc06.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.6     True  True  True pc07.mydomain.com Microsoft(R) Windows(R) Server 2003, Standard Edition
		10.10.10.7     True False False
		10.10.10.8    False False False
		10.10.10.9     True  True False pc09.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.10    True  True False pc10.mydomain.com Microsoft Windows XP Professional

	.EXAMPLE 
		PS C:\&gt; Get-SubNetItems -StartScanIP 10.10.10.2 -Verbose
		VERBOSE: Creating own list class.
		VERBOSE: Start scaning...
		VERBOSE: Starting job (1/20) for 10.10.10.2.
		VERBOSE: Trying get part of data.
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (0)
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (5)
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (10)
		VERBOSE: Trying get last part of data.
		VERBOSE: Geting job 10.10.10.2 result.
		VERBOSE: Removing job 10.10.10.2.
		VERBOSE: Scan finished.


		RunspaceId : d2882105-df8c-4c0a-b92c-0d078bcde752
		Active     : True
		Host       : pc02.mydomain.com
		IP         : 10.10.10.2
		OS_Name    : Microsoft Windows Server 2008 R2 Enterprise
		OS_Ver     : 6.1.7601 Service Pack 1
		WMI        : True
		WinRM      : True
		
	.EXAMPLE 	
		PS C:\&gt; $Result = Get-SubNetItems -StartScanIP 10.10.10.1 -EndScanIP 10.10.10.25 -Ports 80,3389,5900	

		PS C:\&gt; $Result | Select-Object IP, Host, MAC, @{l="Ports";e={[string]::join(", ",($_.Ports | Select-Object @{Label="Ports";Expression={"$($_.Port)-$($_.Status)"}} | Select-Object -ExpandProperty Ports))}} | Format-Table * -AutoSize
		
		IP          Host              MAC               Ports
		--          ----              ---               -----
		10.10.10.1                                      80-False, 3389-False, 5900-False
		10.10.10.2  pc02.mydomain.com 00-15-AD-0C-82-20 80-True, 3389-False, 5900-False
		10.10.10.5  pc05.mydomain.com 00-15-5D-1C-80-25 80-True, 3389-False, 5900-False
		10.10.10.7  pc07.mydomain.com 00-15-4D-0C-81-04 80-True, 3389-True, 5900-False
		10.10.10.9  pc09.mydomain.com 00-15-4A-0C-80-31 80-True, 3389-True, 5900-False
		10.10.10.10 pc10.mydomain.com 00-15-5D-02-1F-1C 80-False, 3389-True, 5900-False

	.NOTES 
		Author: Michal Gajda
		
		ChangeLog:
		v1.3
		-Scan items in subnet for MAC
		-Basic port scan on items in subnet
		-Fixed some small spelling bug
		
		v1.2
		-IP Range Ganerator upgrade
		
		v1.1
		-ProgressBar upgrade
		
		v1.0:
		-Scan subnet for items
		-Scan items in subnet for WMI Access
		-Scan items in subnet for WinRM Access
#&gt;

	[CmdletBinding(
		SupportsShouldProcess=$True,
		ConfirmImpact="Low" 
	)]	
	param(
		[parameter(Mandatory=$true)]
		[System.Net.IPAddress]$StartScanIP,
		[System.Net.IPAddress]$EndScanIP,
		[Int]$MaxJobs = 20,
		[Int[]]$Ports,
		[Switch]$ShowAll,
		[Switch]$ShowInstantly,
		[Int]$SleepTime = 5,
		[Int]$TimeOut = 90
	)

	Begin{}

	Process
	{
		if ($pscmdlet.ShouldProcess("$StartScanIP $EndScanIP" ,"Scan IP range for active machines"))
		{
			if(Get-Job -name *.*.*.*)
			{
				Write-Verbose "Removing old jobs."
				Get-Job -name *.*.*.* | Remove-Job -Force
			}
			
			$ScanIPRange = @()
			if($EndScanIP -ne $null)
			{
				Write-Verbose "Generating IP range list."
				# Many thanks to Dr. Tobias Weltner, MVP PowerShell and Grant Ward for IP range generator
				$StartIP = $StartScanIP -split '\.'
	  			[Array]::Reverse($StartIP)  
	  			$StartIP = ([System.Net.IPAddress]($StartIP -join '.')).Address 
				
				$EndIP = $EndScanIP -split '\.'
	  			[Array]::Reverse($EndIP)  
	  			$EndIP = ([System.Net.IPAddress]($EndIP -join '.')).Address 
				
				For ($x=$StartIP; $x -le $EndIP; $x++) {    
					$IP = [System.Net.IPAddress]$x -split '\.'
					[Array]::Reverse($IP)   
					$ScanIPRange += $IP -join '.' 
				}
			
			}
			else
			{
				$ScanIPRange = $StartScanIP
			}

			Write-Verbose "Creating own list class."
			$Class = @"
			public class SubNetItem {
				public bool Active;
				public string Host;
				public System.Net.IPAddress IP;
				public string MAC;
				public System.Object Ports;
				public string OS_Name;
				public string OS_Ver;
				public bool WMI;
				public bool WinRM;
			}
"@		

			Write-Verbose "Start scaning..."	
			$ScanResult = @()
			$ScanCount = 0
			Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete (0)
			Foreach($IP in $ScanIPRange)
			{
	 			Write-Verbose "Starting job ($((Get-Job -name *.*.*.* | Measure-Object).Count+1)/$MaxJobs) for $IP."
				Start-Job -Name $IP -ArgumentList $IP,$Ports,$Class -ScriptBlock{ 
				
					param
					(
					[System.Net.IPAddress]$IP = $IP,
					[Int[]]$Ports = $Ports,
					$Class = $Class 
					)
					
					Add-Type -TypeDefinition $Class
					
					if(Test-Connection -ComputerName $IP -Quiet)
					{
						#Get Hostname
						Try
						{
							$HostName = [System.Net.Dns]::GetHostbyAddress($IP).HostName
						}
						Catch
						{
							$HostName = $null
						}
						
						#Get WMI Access, OS Name and version via WMI
						Try
						{
							#I don't use Get-WMIObject because it havent TimeOut options. 
							$WMIObj = [WMISearcher]''  
							$WMIObj.options.timeout = '0:0:10' 
							$WMIObj.scope.path = "\\$IP\root\cimv2"  
							$WMIObj.query = "SELECT * FROM Win32_OperatingSystem"  
							$Result = $WMIObj.get()  

							if($Result -ne $null)
							{
								$OS_Name = $Result | Select-Object -ExpandProperty Caption
								$OS_Ver = $Result | Select-Object -ExpandProperty Version
								$OS_CSDVer = $Result | Select-Object -ExpandProperty CSDVersion
								$OS_Ver += " $OS_CSDVer"
								$WMIAccess = $true					
							}
							else
							{
								$WMIAccess = $false	
							}
						}	
						catch
						{
							$WMIAccess = $false					
						}
						
						#Get WinRM Access, OS Name and version via WinRM
						if($HostName)
						{
							$Result = Invoke-Command -ComputerName $HostName -ScriptBlock {systeminfo} -ErrorAction SilentlyContinue 
						}
						else
						{
							$Result = Invoke-Command -ComputerName $IP -ScriptBlock {systeminfo} -ErrorAction SilentlyContinue 
						}
						
						if($Result -ne $null)
						{
							if($OS_Name -eq $null)
							{
								$OS_Name = ($Result[2..3] -split ":\s+")[1]
								$OS_Ver = ($Result[2..3] -split ":\s+")[3]
							}	
							$WinRMAccess = $true
						}
						else
						{
							$WinRMAccess = $false
						}
						
						#Get MAC Address
						Try
						{
							$result= nbtstat -A $IP | select-string "MAC"
							$MAC = [string]([Regex]::Matches($result, "([0-9A-F][0-9A-F]-){5}([0-9A-F][0-9A-F])"))
						}
						Catch
						{
							$MAC = $null
						}
						
						#Get ports status
						$PortsStatus = @()
						ForEach($Port in $Ports)
						{
							Try
							{							
								$TCPClient = new-object Net.Sockets.TcpClient
								$TCPClient.Connect($IP, $Port)
								$TCPClient.Close()
								
								$PortStatus = New-Object PSObject -Property @{            
		        					Port		= $Port
									Status      = $true
								}
								$PortsStatus += $PortStatus
							}	
							Catch
							{
								$PortStatus = New-Object PSObject -Property @{            
		        					Port		= $Port
									Status      = $false
								}	
								$PortsStatus += $PortStatus
							}
						}

						
						$HostObj = New-Object SubNetItem -Property @{            
		        					Active		= $true
									Host        = $HostName
									IP          = $IP 
									MAC         = $MAC
									Ports       = $PortsStatus
		        					OS_Name     = $OS_Name
									OS_Ver      = $OS_Ver               
		        					WMI         = $WMIAccess      
		        					WinRM       = $WinRMAccess      
		        		}
						$HostObj
					}
					else
					{
						$HostObj = New-Object SubNetItem -Property @{            
		        					Active		= $false
									Host        = $null
									IP          = $IP  
									MAC         = $null
									Ports       = $null
		        					OS_Name     = $null
									OS_Ver      = $null               
		        					WMI         = $null      
		        					WinRM       = $null      
		        		}
						$HostObj
					}
				} | Out-Null
				$ScanCount++
				Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
				
				do
				{
					Write-Verbose "Trying get part of data."
					Get-Job -State Completed | Foreach {
						Write-Verbose "Geting job $($_.Name) result."
						$JobResult = Receive-Job -Id ($_.Id)

						if($ShowAll)
						{
							if($ShowInstantly)
							{
								if($JobResult.Active -eq $true)
								{
									Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
								}
								else
								{
									Write-Host "$($JobResult.IP) is inactive." -ForegroundColor Red
								}
							}
							
							$ScanResult += $JobResult	
						}
						else
						{
							if($JobResult.Active -eq $true)
							{
								if($ShowInstantly)
								{
									Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
								}
								$ScanResult += $JobResult
							}
						}
						Write-Verbose "Removing job $($_.Name)."
						Remove-Job -Id ($_.Id)
						Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
					}
					
					if((Get-Job -name *.*.*.*).Count -eq $MaxJobs)
					{
						Write-Verbose "Jobs are not completed ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs), please wait..."
						Sleep $SleepTime
					}
				}
				while((Get-Job -name *.*.*.*).Count -eq $MaxJobs)
			}
			
			$timeOutCounter = 0
			do
			{
				Write-Verbose "Trying get last part of data."
				Get-Job -State Completed | Foreach {
					Write-Verbose "Geting job $($_.Name) result."
					$JobResult = Receive-Job -Id ($_.Id)

					if($ShowAll)
					{
						if($ShowInstantly)
						{
							if($JobResult.Active -eq $true)
							{
								Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
							}
							else
							{
								Write-Host "$($JobResult.IP) is inactive." -ForegroundColor Red
							}
						}
						
						$ScanResult += $JobResult	
					}
					else
					{
						if($JobResult.Active -eq $true)
						{
							if($ShowInstantly)
							{
								Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
							}
							$ScanResult += $JobResult
						}
					}
					Write-Verbose "Removing job $($_.Name)."
					Remove-Job -Id ($_.Id)
					Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
				}
				
				if(Get-Job -name *.*.*.*)
				{
					Write-Verbose "All jobs are not completed ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs), please wait... ($timeOutCounter)"
					Sleep $SleepTime
					$timeOutCounter += $SleepTime				

					if($timeOutCounter -ge $TimeOut)
					{
						Write-Verbose "Time out... $TimeOut. Can't finish some jobs  ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs) try remove it manualy."
						Break
					}
				}
			}
			while(Get-Job -name *.*.*.*)
			
			Write-Verbose "Scan finished."
			Return $ScanResult | Sort-Object {"{0:d3}.{1:d3}.{2:d3}.{3:d3}" -f @([int[]]([string]$_.IP).split('.'))}
		}
	}
	
	End{}
}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Object_CUSTOM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CREATE_custom_Objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Object_CUSTOM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CREATE_custom_Objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://technet.microsoft.com/en-us/library/hh750381.aspx


#'The Full-Form Way
======================
#'Assuming I have an object in the variable $os, and another in $bios, 
#' I could combine selected pieces of information from them like this:
--------------------
$object = New-Object TypeNamePSObject
$object | Add-Member MemberTypeNoteProperty Name OSBuild Value $os.BuildNumber
$object | Add-Member MemberTypeNoteProperty Name OSVersion Value $os.Version
$object | Add-Member MemberTypeNoteProperty Name BIOSSerial Value $bios.SerialNumber
Write-Output $object

#'PassThru: A Brief Shortcut
===========================
#'You can make that first approach a bit more concise by telling 
#'	Add-Member to put the object back into the pipeline:
#'When you end a line with a pipe character, 
#'    Windows PowerShell knows to go to the next physical line to look for the next command in the pipeline. 
#' Essentially, its a way of breaking up a long command into multiple physical lines. 
#' That trick, combined with the PassThru switch, makes this a series of three distinct commands.
---------------------------
$object = New-Object TypeNamePSObject
$object | Add-Member MemberTypeNoteProperty Name OSBuild Value $os.BuildNumber PassThru |
Add-Member MemberTypeNoteProperty Name OSVersion Value $os.Version PassThru |
Add-Member MemberTypeNoteProperty Name BIOSSerial Value $bios.SerialNumber
Write-Output $object

#'Hashtable
========================
#'Using the New-Object feature is a more concise approach. 
#'This lets you create a hashtable (or associative array) that contains 
#'    the property names and values you want to add to the newly created object. 
#'These properties are each automatically created as a NoteProperty:
-------------------------
$properties = @{'OSBuild'=$os.BuildNumber;
                'OSVersion'=$os.version;
                'BIOSSerial'=$bios.SerialNumber}
$object = New-Object TypeNamePSObject Prop $properties
Write-Output $object

#'parenthetical expression to make it even shorter. However, 
#'	I think this makes it a bit more difficult to read:

$object = New-Object TypeNamePSObject Prop
(@{'OSBuild'=$os.BuildNumber;
                'OSVersion'=$os.version;
                'BIOSSerial'=$bios.SerialNumber})
Write-Output $object

#'Going a Bit Further
==========================
#'Youll notice that in all these examples, 
#'    I save the custom object to a variable ($object) before writing it to the pipeline. 
#'The reason for this is simple. You might want to manipulate the object a bit more. 
#'For example, you might want to give your object a custom type name:
#'Doing this lets you create a custom default formatting layout for displaying your object.
----------------------------

$object.PSObject.TypeNames.Insert(0,'My.Custom.Name')


#'Less readable and harder to teach
====================================
#'assuming that my $os and $bios variables contain the raw objects I want to extract information from:
#'Its basically generating custom properties using a syntax unique to that cmdlet (and shared by the Format cmdlets). 
----------------------------------

$os | Select-Object Property @{n='OSVersion';e={$_.Version}},
@{n='OSBuild';e={$_.BuildNumber}},
@{n='BIOSSerial';e={$bios.SerialNumber}}

#'Another way:
======================================
#'Youre creating an empty hashtable, 
#'    then adding information by referring to properties that dont exist. 
#'When you first try to access OSBuild, for example, 
#'    Windows PowerShell realizes that no such property exists in the $info object 
#'    (which was an empty hashtable). 
#'It implicitly creates the property and assigns your value. Crazy stuffbut it works.
-----------------------------------------

$info = @{}
$info.OSBuild=$os.BuildNumber
$info.OSVersion=$os.version
$info.BIOSSerial=$bios.SerialNumber
$object = New-Object TypeNamePSObject Prop $info
Write-Output $object</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Office</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-OfficeVersion</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Office</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-OfficeVersion</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://filedb.experts-exchange.com/incoming/2015/11_w47/1030521/get-officeversion.ps1..txt
=============================================================================================
#'USAGE - Multiple Computers
$testcomputers = Get-Content -Path 'C:\DATA\DeskTops_AIO_EB_2018_04_03.txt'
$exportLocation = 'C:\DATA\OfficeVersions.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path C:\DATA\ComputersThatRespondToPing.txt
		}else{
			Add-Content -value $computer -path C:\DATA\DeadPCs.txt
		}
	}
	
#'Proceed with inventory of Live PCs
#'get-officeversion $testcomputers $exportLocation
get-officeversion -Infile C:\DATA\ComputersThatRespondToPing.txt -outfile C:\DATA\GetOffice_results.txt
=============================================================================================
#'USAGE - Single Computer
Remove-Item c:\DATA\ONE_Computer_RespondToPing.txt
#'Remove-Item c:\DATA\ONE_Computer_officeversions.csv

$testcomputers = "IT-1083"
#'$exportLocation = 'C:\DATA\OfficeVersions.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\ONE_Computer_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\ONE_Computer_DidNotPing.txt
		}
	}

 get-officeversion -infile c:\DATA\ONE_Computer_RespondToPing.txt -outfile c:\DATA\ONE_Computer_officeversions.csv


Get-Content c:\DATA\ONE_Computer_officeversions.csv

=============================================================================================
&lt;#
.Synopsis
   Get-OfficeVersion 
.DESCRIPTION
   Gets the Office version from a list of computernames and returns a CSV of the Computername and Office Version (if available)
.EXAMPLE
 get-officeversion c:\test\servers.txt c:\test\officeversions.csv
.EXAMPLE
 get-officeversion -infile c:\test\servers.txt -outfile c:\test\officeversions.csv
.NOTES
   General notes
.PARAMETER infile
A path and a filename to a text file contains a list of the computernames or ip addresses to check the office version.
.PARAMETER Outfile
A path and filename of the output .csv file

#&gt;
function Get-OfficeVersion
{
param(
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $Infile,
    
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $outfile
    )
#$outfile = 'C:\temp\office.csv'
#$infile = 'c:\temp\servers.txt'
Begin
    {
    }
 Process
    {
    $office = @()
    $computers = Get-Content $infile
    $i=0
    $count = $computers.count
    foreach($computer in $computers)
     {
     $i++
     Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
      -PercentComplete ($i/$count*100)
        $info = @{}
        $version = 0
        try{
          $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $computer) 
          $reg.OpenSubKey('software\Microsoft\Office').GetSubKeyNames() |% {
            if ($_ -match '(\d+)\.') {
              if ([int]$matches[1] -gt $version) {
                $version = $matches[1]
              }
            }    
          }
          if ($version) {
            Write-Debug("$computer : found $version")
            switch($version) {
                "7" {$officename = 'Office 97' }
                "8" {$officename = 'Office 98' }
                "9" {$officename = 'Office 2000' }
                "10" {$officename = 'Office XP' }
                "11" {$officename = 'Office 97' }
                "12" {$officename = 'Office 2003' }
                "13" {$officename = 'Office 2007' }
                "14" {$officename = 'Office 2010' }
                "15" {$officename = 'Office 2013' }
                "16" {$officename = 'Office 2016' }
                default {$officename = 'Unknown Version'}
            }
    
          }
          }
          catch{
              $officename = 'Not Installed/Not Available/Not Answering'
          }
    $info.Computer = $computer
    $info.Name= $officename
    $info.version =  $version

    $object = new-object -TypeName PSObject -Property $info
    $office += $object
    }
    $office | select computer,version,name | Export-Csv -NoTypeInformation -Path $outfile
    }
}
  write-output ("Done")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_OutPut</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Put_results_into_an_object_thenAtTheEnd_Write-Output_the_object</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_OutPut</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Put_results_into_an_object_thenAtTheEnd_Write-Output_the_object</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># simply notice the use of Write- commands in the below...
function Get-MachineInfo {
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Write-Verbose "Connecting to $computer over $protocol"
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option
  
        Write-Verbose "Querying from $computer"
        $os_params = @{'ClassName'='Win32_OperatingSystem'
                       'CimSession'=$session}
        $os = Get-CimInstance @os_params

        $cs_params = @{'ClassName'='Win32_ComputerSystem'
                       'CimSession'=$session}
        $cs = Get-CimInstance @cs_params

        $sysdrive = $os.SystemDrive
        $drive_params = @{'ClassName'='Win32_LogicalDisk'
                          'Filter'="DeviceId='$sysdrive'"
                          'CimSession'=$session}
        $drive = Get-CimInstance @drive_params

        $proc_params = @{'ClassName'='Win32_Processor'
                         'CimSession'=$session}
        $proc = Get-CimInstance @proc_params |
                Select-Object -first 1

  
        Write-Verbose "Closing session to $computer"
        $session | Remove-CimSession
  
        Write-Verbose "Outputting for $computer"
        $obj = [pscustomobject]@{'ComputerName'=$computer         #'&lt;===========
                   'OSVersion'=$os.version
                   'SPVersion'=$os.servicepackmajorversion
                   'OSBuild'=$os.buildnumber
                   'Manufacturer'=$cs.manufacturer
                   'Model'=$cs.model
                   'Procs'=$cs.numberofprocessors
                   'Cores'=$cs.numberoflogicalprocessors
                   'RAM'=($cs.totalphysicalmemory / 1GB)
                   'Arch'=$proc.addresswidth
                   'SysDriveFreeSpace'=$drive.freespace}
        Write-Output $obj                                        #'&lt;===========
 
    } #foreach
} #PROCESS

END {}

} #function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Parameters</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Complex_example</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Parameters</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Complex_example</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Function Get-DiskCheck {

[cmdletbinding(DefaultParameterSetName = "name")]

Param(
[Parameter(Position = 0, Mandatory, 
HelpMessage = "Enter a computer name to check",
ParameterSetName = "name",
ValueFromPipeline)]
[Alias("cn")]
[ValidateNotNullorEmpty()]
[string[]]$Computername,

[Parameter(Mandatory,
HelpMessage = "Enter the path to a text file of computer names",
ParameterSetName = "file"
)]
[ValidateScript({
if (Test-Path $_) {
   $True
}
else {
   Throw "Cannot validate path $_"
}
})]     
[ValidatePattern("\.txt$")]
[string]$Path,

[ValidateRange(10,50)]
[int]$Threshhold = 25,

[ValidateSet("C:","D:","E:","F:")]
[string]$Drive = "C:",

[switch]$Test
)

Begin {
    ...
    }
} #begin

Process {

...

} #process

End {
   ...
} #end

}

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Parameters</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Positional_Parms</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Parameters</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Positional_Parms</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-------------------------------------------------
'To turn of positional parms:
[CmdletBinding(PositionalBinding=$false)] in 
-------------------------------------------------

#' quick example
function test {
    param(
        [string[]]$one,
        [int]$two,
        [switch]$three
    )
}
'To see output
help test -Full



#' assigned positions
function test {
    param(
        [Parameter(Position=1)]
        [string[]]$one,

        [Parameter(Position=2)]
        [int]$two,

        [Parameter(Position=3)]		'Should not use Position for 'switch' parms
        [switch]$three
    )
}
'To see output
help test -Full</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Parameters</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>simple examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Parameters</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>simple examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
------------------------------------------------------------------------------------------
#'ScriptWithParameter.ps1
#'get a breakdown of error sources in the System eventlog
#'NOTE: the DEFAULT values are given
Param(
    [string]$Log = "System",
    [string]$Computername = $env:COMPUTERNAME,
    [int32]$Newest = 500,
    [string]$ReportTitle = "Event Log Report",
    [Parameter(Mandatory,HelpMessage = "Enter the path for the HTML file.")]
    [string]$Path
)

#'get event log data and group it
$data = Get-Eventlog -logname $Log -EntryType Error -Newest $newest -ComputerName $Computername |
    Group-object -Property Source -NoElement 

#'create an HTML report
$footer = "&lt;h5&gt;&lt;i&gt;report run $(Get-Date)&lt;/i&gt;&lt;/h5&gt;"
$css = "http://jdhitsolutions.com/sample.css"
$precontent = "&lt;H1&gt;$Computername&lt;/H1&gt;&lt;H2&gt;Last $newest error sources from $Log&lt;/H2&gt;"

$data |Sort-Object -Property Count, Name -Descending |
    Select-Object Count, Name | 
    ConvertTo-Html -Title $ReportTitle -PreContent $precontent  -PostContent $footer -CssUri $css |
    Out-File $Path
-------------------------------------------------------------------------------------------





===================================================================

Param
(
    [parameter()]
    $ParameterName
)
-------------------------

'It is mandatory (required).
'It takes input from the pipeline.
'It takes an array of strings as input.
Param
(
    [parameter(Mandatory=$true,
    		   ValueFromPipeline=$true)]
    [String[]]
    $ComputerName
)

---------------------'Position

Param
(
    [parameter(Position=0)]
    [String[]]
    $ComputerName
)

-------------------'Parameter Set Name
'example 1
Param
(
    [parameter(Mandatory=$true,
    ParameterSetName="Computer")]
    [String[]]
    $ComputerName,

    [parameter(Mandatory=$true,
    ParameterSetName="User")]
    [String[]]
    $UserName,

    [parameter(Mandatory=$false)]
    [Switch]
    $Summary
)

'example 2
Param
(
    [parameter(Mandatory=$true,
    ParameterSetName="Computer")]
    [String[]]
    $ComputerName,

    [parameter(Mandatory=$true,
    ParameterSetName="User")]
    [String[]]
    $UserName,

    [parameter(Mandatory=$false, ParameterSetName="Computer")]
    [parameter(Mandatory=$true, ParameterSetName="User")]
    [Switch]
    $Summary
)

-------------------'ValueFromPipeline Argument
'declares a ComputerName parameter that is mandatory 
'	and accepts an object that is passed to the function from the pipeline.
Param
(
    [parameter(Mandatory=$true,
    ValueFromPipeline=$true)]
    [String[]]
    $ComputerName
)
-------------------'ValueFromPipelineByPropertyName Argument
'the parameter accepts input from a property of a pipeline object. 
'The object property must have the same name or alias as the parameter.
Param
(
    [parameter(Mandatory=$true,
    ValueFromPipelineByPropertyName=$true)]
    [String[]]
    $ComputerName
)

----------------'HelpMessage Argument
'a brief description of the parameter or its value. 
'Windows PowerShell displays this message in the prompt 
'	that appears when a mandatory parameter value is missing from a command. 

Param
(
    [parameter(mandatory=$true,
    HelpMessage="Enter one or more computer names separated by commas.")]
    [String[]]
    $ComputerName
)
----------------'Alias Attribute
' There is no limit to the number of aliases that you can assign to a parameter.
Param
(
    [parameter(Mandatory=$true)]
    [alias("CN","MachineName")]
    [String[]]
    $ComputerName
)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Parameters</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Switch_Parameter</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Parameters</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Switch_Parameter</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'Switch parameters are parameters with no parameter value
-----------------------------------------------------------------------
'Switch parameters, in their general usage, are $false if you don't specify them on the command line, 
'	and are $true if you do specify them on the command line. 
'They don't take any arguments (again, in the general usage case):

function MyFunction([switch] $MySwitch) { }

MyFunction #' $MySwitch is $false

MyFunction -MySwitch #' $MySwitch is $true


-----------------------------------------------------------------------
'However, sometimes you do need to be able to pass in a specific value for the switch parameter, 
'	either because you're passing it on from one function to another (such as in a proxy function), 
'	or because you need to deliberately set a switch to $false (which is rare, 
'	but you'll sometimes see this with -Confirm:$false . 
'In this case, setting Confirm explicitly to false causes it to override 
'	the behavior of the $ConfirmPreference variable, which would otherwise be used.) 
'When you do need to pass an argument to a switch parameter, 
'	you need place a colon between the parameter and its argument, like so:

Param ([Switch]&lt;ParameterName&gt;)


-----------------------------------------------------------------------
'If you're using splatting with a hashtable, 
'	you can just assign a value of $true or $false to that key of the hashtable, 
'	and PowerShell knows what to do with it:
$params = @{ MySwitch = $true }

MyFunction @params


-----------------------------------------------------------------------

Param
(
    [parameter(Mandatory=$false)]
    [Switch]$&lt;ParameterName&gt;
)

---------------------------------------------------------------------------
Function Do-Something
	{
	param
		(
			[switch]$param1
		)
	}

Do-Something -param1
---------------------------------------------------------------------------
Function Do-Something
{
    [cmdletbinding()] 
     
    Param  
    (                 
         [Parameter(Mandatory=$false,  
         [switch]$Param1,

         [Parameter(Mandatory=$false, 
         [switch]$Param2,

         [Parameter(Mandatory=$false, 
         [switch]$Param3
    )   

	Begin {}
	
	End {}
}
---------------------------------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_poswsus</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Install-WSUSServer.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_poswsus</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Install-WSUSServer.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' TO install only the console
#'			. .\Install-WSUSServer.ps1 ConsoleOnly -verbose
===========================================================================================
This script allows you to install a WSUS server locally or remotely using a variety of configuration options. 
	You can also just install the WSUS Administration Console without having to install the entire server! 
	This script makes use of psexec.exe, 
		which is available to download from this link: 
		http://download.sysinternals.com/Files/SysinternalsSuite.zip. 
	This file must be in the same location as the script, 
		otherwise the script will not run.

The script also requires either the x86 or x64 installation file, 
	which the script will download for you if you allow it to and have an available internet connection 
		from the location you are running the script. 
Keep in mind that the installation files must be in the same location as the script 
	and you also need to keep the installation file's original name.

Also, be sure to check out my companion script: Uninstall-WSUSServer.ps1 as well!
============================================================================================
&lt;#  
.SYNOPSIS  
    Downloads (if needed) and performs an unattended installation of WSUS Server with SP2 on a local or remote system. Requires psexec.exe to be in the same
    location as the script in order to run properly.

.DESCRIPTION
    Downloads (if needed) and performs an unattended installation of WSUS Server with SP2 on a local or remote system. Requires psexec.exe to be in the same
    location as the script in order to run properly. Also optional to have the installation files in the same location as the script, otherwise the files will
    be downloaded from the internet.
     
.PARAMETER Computername
    Name of computer to install WSUS server on.

.PARAMETER ConsoleOnlyServer
    Switch used to only install the console without installing the server application.

.PARAMETER StoreUpdatesLocally
    Switch used to determine if updates will be downloaded and saved to system locally.

.PARAMETER ContentDirectory
    Path to the local content folder holding update files. Default location is: %rootdrive%\WSUS\WSUSContent where the root drive is the largest local drive on the system.

.PARAMETER InternalDatabasePath
    Path to install the internal database
    
.PARAMETER CreateDatabase
    Create a database on the SQL server. Will not create database and attempt to use existing database if switch not used.

.PARAMETER WebsitePort
    Determine the port of the WSUS Site. Accepted Values are "80" and "8530". 

.PARAMETER SQLInstance
    Name of the SQL Instance to connect to for database
    
.PARAMETER IsFrontEndServer
    This server will be a front end server in an NLB

.NOTES  
    Name: Install-WSUSServer
    Author: Boe Prox
    DateCreated: 29NOV2011 
           
.LINK  
    https://learn-powershell.net
    
.EXAMPLE
Install-WSUSServer.ps1 -ConsoleOnly

Description
-----------
Installs the WSUS Console on the local system

.EXAMPLE
Install-WSUSServer.ps1 -ConsoleOnly -Computername Server1

Description
-----------
Installs the WSUS Console on the remote system Server1

.EXAMPLE
Install-WSUSServer.ps1 -Computername TestServer -StoreUpdatesLocally -ContentDirectory "D:\WSUS" -InternalDatabasePath "D:\" -CreateDatabase

Description
-----------
Installs WSUS server on TestServer and stores content locally on D:\WSUS and installs an internal database on D:\

.EXAMPLE
Install-WSUSServer.ps1 -Computername A24 -StoreUpdatesLocally -ContentDirectory "D:\WSUS" -SQLInstance "Server1\Server1" -CreateDatabase

Description
-----------
Installs WSUS server on TestServer and stores content locally on D:\WSUS and creates a database on Server1\Server1 SQL instance

.EXAMPLE
Install-WSUSServer.ps1 -Computername A24 -StoreUpdatesLocally -ContentDirectory "D:\WSUS" -SQLInstance "Server1\Server1"

Description
-----------
Installs WSUS server on TestServer and stores content locally on D:\WSUS and uses an existing WSUS database on Server1\Server1 SQL instance
#&gt; 
[cmdletbinding(
    DefaultParameterSetName = 'Console',
    SupportsShouldProcess = $True
)]
Param (
    [parameter(ValueFromPipeLine = $True)]
    [string]$Computername = $Env:Computername,
    [parameter(ParameterSetName = 'Console')]
    [switch]$ConsoleOnly,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [switch]$StoreUpdatesLocally,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [string]$ContentDirectory,
    [parameter(ParameterSetName = 'InternalDatabase')]
    [string]$InternalDatabasePath, 
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [ValidateSet("80","8530")]
    [string]$WebsitePort,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [switch]$CreateDatabase,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [string]$SQLInstance,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [switch]$IsFrontEndServer    
    
)
Begin {
    If (-NOT (Test-Path psexec.exe)) {
        Write-Warning ("Psexec.exe is not in the current directory! Please copy psexec to this location: {0} or change location to where psexec.exe is currently at.`nPsexec can be downloaded from the following site:`
        http://download.sysinternals.com/Files/SysinternalsSuite.zip" -f $pwd)
        Break
    }
    
    #Source Files for X86 and X64
    Write-Verbose "Setting source files"
    $x86 = Join-Path $pwd "WSUS30-KB972455-x86.exe"
    $x64 = Join-Path $pwd "WSUS30-KB972455-x64.exe"
        
    #Menu items for later use if required
    Write-Verbose "Building scriptblock for later use"
    $sb = {$title = "WSUS File Required"
    $message = "The executable you specified needs to be downloaded from the internet. Do you wish to allow this?"
    $yes = New-Object System.Management.Automation.Host.ChoiceDescription "&amp;Yes", `
        "Download the file."
    $no = New-Object System.Management.Automation.Host.ChoiceDescription "&amp;No", `
        "Do not download the file. I will download it myself."    
    $options = [System.Management.Automation.Host.ChoiceDescription[]]($yes, $no)
    Write-Verbose "Launching menu for file download"
    $Host.ui.PromptForChoice($title, $message, $options, 0)}             
    
    Write-Verbose "Adding URIs for installation files"
    #URI of specified files if needed to download        
    $WSUS_X86 = "http://download.microsoft.com/download/B/0/6/B06A69C3-CF97-42CF-86BF-3C59D762E0B2/WSUS30-KB972455-x86.exe"
    $WSUS_X64 = "http://download.microsoft.com/download/B/0/6/B06A69C3-CF97-42CF-86BF-3C59D762E0B2/WSUS30-KB972455-x64.exe"
    
    #Define Quiet switch first
    $arg = "/q "
    
    #Process parameters
    If ($PSBoundParameters['ConsoleOnly']) {
        Write-Verbose "Setting argument to Console Install Only"
        $arg += "CONSOLE_INSTALL=1 "
    }
    If ($PSBoundParameters['StoreUpdatesLocally']){
        $arg += "CONTENT_LOCAL=1 "
        If ($PSBoundParameters['ContentDirectory']) {
            $arg += "CONTENT_DIR=$ContentDirectory "
        }
    }
    If ($PSBoundParameters['WebsitePort']) {
            Switch ($WebsitePort) {
            "80" {
                $arg += "DEFAULT_WEBSITE=1 "
            }
            "8530" {
                $arg += "DEFAULT_WEBSITE=0 "
            }
            Default {
                $arg += "DEFAULT_WEBSITE=1 "
            }
        }
    }
    If ($PSBoundParameters['InternalDatabasePath']) {
        $arg += "WYUKON_DATA_DIR=$InternalDatabasePath "
    }
    If ($PSBoundParameters['CreateDatabase']) {
        $arg += "CREATE_DATABASE=1 "
    } ElseIf ($PSCmdlet.ParameterSetName -ne 'Console') {
        #Use default database
        $arg += "CREATE_DATABASE=0 "
    }
    If ($PSBoundParameters['SQLInstance']) {
        $arg += "SQLINSTANCE_NAME=$SQLInstance "
    }
    If ($PSBoundParameters['IsFrontEndServer']) {
        $arg += "FRONTEND_SETUP=1 "
    }
}
Process {
    Try {
        $OSArchitecture = Get-WmiObject Win32_OperatingSystem -ComputerName $Computername | Select -Expand OSArchitecture -EA Stop
    } Catch {
        Write-Warning ("{0}: Unable to perform lookup of operating system!`n{1}" -f $Computername,$_.Exception.Message)
    }  
    If ($OSArchitecture -eq "64-bit") {
        Write-Verbose ("{0} using 64-bit" -f $Computername)
        If (-NOT (Test-Path $x64)) {
            Write-Verbose ("{0} not found, download from internet" -f $x64)
            switch (&amp;$sb) {
                0 {
                    If ($pscmdlet.ShouldProcess($WSUS_X64,"Download File")) {
                        Write-Verbose "Configuring webclient to download file"
                        $wc = New-Object Net.WebClient
                        $wc.UseDefaultCredentials = $True              
                        Write-Host -ForegroundColor Green -BackgroundColor Black ("Downloading from {0} to {1} prior to installation. This may take a few minutes" -f $WSUS_X64,$x64)
                        Try {
                            $wc.DownloadFile($WSUS_X64,$x64)                                                                                    
                        } Catch {
                            Write-Warning ("Unable to download file!`nReason: {0}" -f $_.Exception.Message)
                            Break
                        } 
                    }                   
                }
                1 {
                    #Cancel action
                    Break
                }                
            }
        } 
        #Copy file to root drive
        If (-NOT (Test-Path ("\\$Computername\c$\{0}" -f (Split-Path $x64 -Leaf)))) {
            Write-Verbose ("Copying {0} to {1}" -f $x64,$Computername)
            If ($pscmdlet.ShouldProcess($Computername,"Copy File")) {                                
                Try {
                    Copy-Item -Path $x64 -Destination "\\$Computername\c$" -EA Stop
                } Catch {
                    Write-Warning ("Unable to copy {0} to {1}`nReason: {2}" -f $x64,$Computername,$_.Exception.Message)
                }
            }
        } Else {Write-Verbose ("{0} already exists on {1}" -f (Split-Path $x64 -Leaf),$Computername)}
        #Perform the installation
        Write-Verbose ("Begin installation on {0} using specified options" -f $Computername)
        If ($pscmdlet.ShouldProcess($Computername,"Install WSUS")) {
            .\psexec.exe -accepteula -i -s \\$Computername cmd /c ("C:\{0} $arg" -f (Split-Path $x64 -Leaf))                                
        }
    } Else {
        Write-Verbose ("{0} using 32-bit" -f $Computername)
        If (-NOT (Test-Path $x86)) {
            Write-Verbose ("{0} not found, download from internet" -f $x86)
            switch (&amp;$sb) {
                0 {
                    If ($pscmdlet.ShouldProcess($WSUS_X86,"Download File")) {
                        Write-Verbose "Configuring webclient to download file"
                        $wc = New-Object Net.WebClient
                        $wc.UseDefaultCredentials = $True              
                        Write-Host -ForegroundColor Green -BackgroundColor Black ("Downloading from {0} to {1} prior to installation. This may take a few minutes" -f $WSUS_X86,$x86)
                        Try {
                            $wc.DownloadFile($WSUS_X86,$x86)                                                                                          
                        } Catch {
                            Write-Warning ("Unable to download file!`nReason: {0}" -f $_.Exception.Message)
                            Break
                        }
                    }                    
                }
                1 {
                    #Cancel action
                    Break
                }                                
            }
        }
        #Copy file to root drive
        If (-NOT (Test-Path ("\\$Computername\c$\{0}" -f (Split-Path $x86 -Leaf)))) {
            Write-Verbose ("Copying {0} to {1}" -f $x86,$Computername) 
            If ($pscmdlet.ShouldProcess($Computername,"Copy File")) {
                Try {
                    Copy-Item -Path $x86 -Destination "\\$Computername\c$" -EA Stop
                } Catch {
                    Write-Warning ("Unable to copy {0} to {1}`nReason: {2}" -f $x86,$Computername,$_.Exception.Message)
                }
            }
        } Else {Write-Verbose ("{0} already exists on {1}" -f $x86,$Computername)}
        #Perform the installation
        Write-Verbose ("Begin installation on {0} using specified options" -f $Computername)
        If ($pscmdlet.ShouldProcess($Computername,"Install WSUS")) {
            .\psexec.exe -accepteula -i -s \\$Computername cmd /c ("C:\{0} $arg" -f (Split-Path $x86 -Leaf))
        }
    }   
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Sample_Profile_0____gig-Utility</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Sample_Profile_0____gig-Utility</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function gig-RemotelyQueryUser {
                                 &lt;#
                                   .Synopsis
                                    w/ no parm, it uses the local computer, with the parm it will query a remote computer 
                                   .Description
                                    From: https://4sysops.com/archives/remotely-query-user-profile-information-with-powershell/
                                   .Example
                                    Example-
                                    Example- accomplishes 
                                   .Parameter 
                                    ValueFromPipeline = 
                                   .Parameter 
                                    ComputerName = defaults to local
                                   .Notes
                                    Example: 
                                            &gt; gig-RemotelyQueryUser  {for local}
                                            &gt; gig-RemotelyQueryUser -ComputerName WBSQL1   {for remote}
                                    AUTHOR: glenn garson, JPHSA
                                    LASTEDIT: 12/28/2016 13:45:05
                                    KEYWORDS:
                                    HSG: 
                                   .Link
                                     Http://www.ScriptingGuys.com
                                 #'Requires -Version 2.0
                                 #&gt;
								[cmdletbinding()]
                                param (
                                [parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
                                [string[]]$ComputerName = $env:computername
                                )            
 
                                foreach ($Computer in $ComputerName) {
                                 $Profiles = Get-WmiObject -Class Win32_UserProfile -Computer $Computer -ea 0
                                 foreach ($profile in $profiles) {
                                  try {
                                      $objSID = New-Object System.Security.Principal.SecurityIdentifier($profile.sid)
                                      $objuser = $objsid.Translate([System.Security.Principal.NTAccount])
                                      $objusername = $objuser.value
                                  } catch {
                                        $objusername = $profile.sid
                                  }
                                  switch($profile.status){
                                   1 { $profileType="Temporary" }
                                   2 { $profileType="Roaming" }
                                   4 { $profileType="Mandatory" }
                                   8 { $profileType="Corrupted" }
                                   default { $profileType = "LOCAL" }
                                  }
                                  $User = $objUser.Value
                                  $ProfileLastUseTime = ([WMI]"").Converttodatetime($profile.lastusetime)
                                  $OutputObj = New-Object -TypeName PSobject
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ComputerName -Value $Computer.toUpper()
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfileName -Value $objusername
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfilePath -Value $profile.localpath
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfileType -Value $ProfileType
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name IsinUse -Value $profile.loaded
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name IsSystemAccount -Value $profile.special
                                  $OutputObj
  
                                 }
                                }
							}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Sample_Profile_0____PowerShellISEModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Sample_Profile_0____PowerShellISEModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

Function gig-commentIt
{
 &lt;#
   .Synopsis
    This function will add a remark #' character to beginning of line
   .Description
    This function will add a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to comment out
    a section of PowerShell code. 
   .Example
    Add-RemarkedText
    adds the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ("#'" + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-commentIt

Function gig-unCommentIt
{
 &lt;#
   .Synopsis
    This function will remove a remark #' character to beginning of line
   .Description
    This function will remove a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to clean up a 
    previously commentted out section of PowerShell code. 
   .Example
    gig-unCommentIt
    Removes the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($l -replace "#'",''),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-unCommentIt


Function gig-editProfile
{

 psedit $profile

 #'ISE $profile

} #'end function gig-editProfile

Function gig-addHelp
{
  &lt;#
   .Synopsis
    This function adds help at current insertion point 
   .Example
    add-help
    adds comment based help at current insertion point 
   .Notes
    NAME:  Add-Help
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016
    HSG: WES-09-11-10
    KEYWORDS: Scripting Techniques, Windows PowerShell ISE
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $helpText = @"
 &lt;#
   .Synopsis
    This does that 
   .Description
    This function does
   .Example
    Example-
    Example- accomplishes 
   .Parameter 
    The parameter
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS:
    HSG: 
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
"@
 $psise.CurrentFile.Editor.InsertText($helpText)
} #'end function gig-addHelp

Function gig-addHeaderToScript
{
  &lt;#
   .Synopsis
    This function adds header information to a script 
   .Example
    Add-HeaderToScript
    Adds header comments to script 
   .Example 
    AH
    Uses alias to add header comments to script
   .Notes
    NAME:  Add-HeaderToScript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS: $keyword
    HSG: $hsg
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($keyword, $comment, $hsg)
 $header = @"
#' -----------------------------------------------------------------------------
#' Script: $(split-path -Path $psISE.CurrentFile.FullPath -Leaf)
#' Author: glenn garson, JPHSA
#' Date: $(Get-Date)
#' Keywords: $keyword
#' comments: $comment
#'
#' -----------------------------------------------------------------------------
"@
 $psise.CurrentFile.Editor.InsertText($header)
} #'end function gig-addHeaderToScript

Function gig-getLogNameFromDate
{
  &lt;#
   .Synopsis
    Creates a log name from date
   .Description
    This script creates a log from a date. 
   .Example
    gig-getLogNameFromDate -path "c:\jumk" -name "log"
    Creates a file name like c:\JUNK\log20100914-122019.Txt but does not
    create the file. It returns the file name to calling code.
   .Example
    gig-getLogNameFromDate -path "c:\JUNK" -name "log" -Create
    Creates a file name like c:\JUNK\log20100914-122019.Txt and
    create the file. It returns the file name to calling code.
   .Parameter path
    path to log file
   .Parameter name
    base name of log file
   .Parameter create
    switch that determines whether log file or only name is created
   .inputs
    [string]
   .outputs
    [string]
   .Notes
    NAME:  gig-getLogNameFromDate
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 16:58:06
    KEYWORDS: parameter substitution, format specifier, string substitution
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param(
  [string]$path = "c:\JUNKC:\DATA\junkPowerShellTranscripts",
  [string]$name = "log",
  [switch]$Create
 )
 $logname = "{0}\{1}{2}.{3}" -f $path,$name, `
    (Get-Date -Format yyyyMMdd-HHmmss),"Txt"
 if($create) 
  { 
   New-Item -Path $logname -ItemType file -force | out-null
   $logname
  }
 else {$logname}
} #' end function gig-getLogNameFromDate

Function gig-start_ISE_Transcript
{
  &lt;#
   .Synopsis
    This captures output from a script to a created text file
    To use the gig-start_ISE_Transcript function, add the call to the function at the bottom of your script.
   .Example

    xxxxx...{your script}
    gig-start_ISE_Transcript -logname "c:\junk\log.txt"

    Copies output from script to file named xxxxlog.txt in c:\junk folder
   .Parameter logname
    the name and path of the log file.
   .inputs
    [string]
   .outputs
    [io.file]
   .Notes
    NAME:  gig-start_ISE_Transcript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 17:27:22
    KEYWORDS:
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
  Param(
   [string]$logname = (gig-getLogNameFromDate -path $transcriptHome -name "log" -Create)
  )
  $transcriptHeader = @"
**************************************
Windows PowerShell ISE Transcript Start
Start Time: $(get-date)
UserName: $env:username
UserDomain: $env:USERDNSDOMAIN
ComputerName: $env:COMPUTERNAME
Windows version: $((Get-WmiObject win32_operatingsystem).version)
**************************************
Transcript started. Output file is $logname
"@
 $transcriptHeader &gt;&gt; $logname
 $psISE.CurrentPowerShellTab.ConsolePane.Text &gt;&gt; $logname
 Log saved to $logname
} #'end function gig-start_ISE_Transcript

function gig-indentText_x_spaces
{
  &lt;#
   .Synopsis
    This function will indent text in the ISE a specific number
   .Description
    This function will indent selected text in the PowerShell ISE. These are
    real spaces, not tabs. Therefore this is appropriate for situations where
    an actual tab "`t" will not work. 
   .Example
    gig-indentText_x_spaces -space 5
    moves selected text five spaces 
   .Parameter spaces
    The number of spaces to indent the selected text. Note this number cannot
    be a negative number, and this function does not "unindent" the selected text.
   .Notes
    NAME:  gig-indentText_x_spaces
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 06/11/2012 17:16:29
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-6-17-12
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param([int]$space = 1)
 $tab = " " * $space
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($tab + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'end function gig-indentText_x_spaces

Function gig-editModule
{
  &lt;#
   .Synopsis
    This opens a module stored in the $env:PSModulePath location on a new tab in ISE 
   .Description
    This function uses Get-Module to retrieve a module from $env:PSModulePath and then
    it opens the module from that location into a new tab in ISE for editing. Wildcard
    characters that resolve to a single module are supported.
   .Example
    gig-editModule PowerShellISEModule
    gig-editModule PowerShellISEModule opens the PowerShellISEModule into a new tab in the
    ISE for editing 
  .Example
    gig-editModule PowerShellISE*
    gig-editModule PowerShellISE* opens the PowerShellISEModule into a new tab in the
    ISE for editing by using a wild card character for the module name
   .Parameter Name
    The name of the module. Wild cards that resolve to a single module are supported
   .Notes
    NAME:  gig-editModule
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 18:14:19
    KEYWORDS: Scripting Techniques, Modules
    HSG: WES-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($name)
 ISE (Get-Module -ListAvailable $name).path
} #'end function gig-editModule

Function gig-toggleOutlineView
{
  &lt;#
   .Synopsis
    This function toggles the outline view in the ISE 
   .Description
    This function toggles the outline view in the ISE. It will expand 
    or collapse all functions in the current script pane.
   .Example
    gig-toggleOutlineView
    gig-toggleOutlineView will either expand or collapse all functions 
   .Notes
    NAME:  gig-toggleOutlineView
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 19:28:37
    KEYWORDS: Scripting Techniques, Modules
    HSG: wes-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 3.0
 #&gt;
 $psise.CurrentFile.Editor.ToggleOutliningExpansion()
} #'end function gig-toggleOutlineView


#'added Functions from New-ModulesDrive.ps1
#' HSG-1-20-10
Function gig-newModuleDrives
{
&lt;#
    .SYNOPSIS
    Creates two PSDrives: myMods and sysMods
    .EXAMPLE
    gig-newModuleDrives
    Creates two PSDrives: myMods and sysMods. These correspond 
    to the users' modules folder and the system modules folder respectively. 
#&gt;
 $driveNames = "myMods","sysMods"

 For($i = 0 ; $i -le 1 ; $i++)
 {
  New-PsDrive -name $driveNames[$i] -PSProvider filesystem `
  -Root ($env:PSModulePath.split(";")[$i]) -scope Global |
  Out-Null
 } #'end For
} #'end gig-newModuleDrives

Function gig-getFileSystemDrives
{
&lt;#
    .SYNOPSIS
    Displays global PS Drives that use the Filesystem provider
    .EXAMPLE
    gig-getFileSystemDrives
    Displays global PS Drives that use the Filesystem provider
#&gt;
 Get-PSDrive -PSProvider FileSystem -scope Global
} #'end gig-getFileSystemDrives

Function gig-OpenPath
{
 &lt;#
   .Synopsis
    Opens a path in Explorer 
   .Description
    Opens a path in Explorer, default path is C:\, or the first parameter is the path
   .Example
    gig-OpenPath C:\Junk
    gig-OpenPath $moduleHome 
   .Parameter Path
    The path to open in Explorer
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/26/2016 17:31:28
    KEYWORDS:
    HSG: 
   .Link
     
 #'Requires -Version 2.0
 #&gt;
  Param(
  [string]$path = "C:\"
 )
 Invoke-Item -Path $path
 }
 
#' *** Alias ***
#'if(!(Test-Path alias:ah))
#' {
#'  New-Alias -Name ah -Value add-headertoscript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:abh))
#' {
#'  New-Alias -Name abh -Value Add-SBSBookHeaderToScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ahlp))
#' {
#'  New-Alias -Name ahlp -Value add-help -Description "MrEd alias" |
#'  Out-Null
#'  }
#'  if(!(Test-Path alias:ras))
#' {
#'  New-Alias -Name ras -Value Remove-AliasFromScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:gfsd))
#' {
#'  New-Alias -Name gfsd -Value gig-getFileSystemDrives -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:cs))
#' {
#'  New-Alias -Name cs -value Copy-ScriptToNewTab -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ar))
#' {
#'  New-Alias -Name ar -value Add-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:rr))
#' {
#'  New-Alias -Name rr -value Remove-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:em))
#' {
#'  New-Alias -Name em -value Edit-Module -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:iem))
#' {
#'  New-Alias -Name iem -value Import-EveryModule -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:sov))
#' {
#'  New-Alias -Name sov -value gig-toggleOutlineView -Description "MrEd alias" |
#'  Out-Null
#'  }



#' *** Variables ***
if(!(Test-Path variable:moduleHome))
{
 new-variable -name moduleHome -value "$env:userProfile\documents\WindowsPowerShell\Modules"
}
#'if(!(Test-Path variable:backupHome))
#'{
#' new-variable -name backupHome -value "$env:userProfile\documents\WindowsPowerShell\profileBackup"
#'}

if(!(Test-Path variable:TranscriptHome))
{
 new-variable -name TranscriptHome -value "C:\DATA\junkPowerShellTranscripts"
 #' new-variable -name TranscriptHome -value "$env:userProfile\documents\WindowsPowerShell\transcript"
}

if(!(Test-Path variable:myScripts))
{
 new-variable -name myScripts -value "C:\DATA\PowerShellScripts"
}

Set-Location $myScripts

Clear-Host

Export-ModuleMember -alias * -function * -variable *</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>SAMPLE_Profile_1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>SAMPLE_Profile_1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'http://www.zerrouki.com/powershell-profile-example/


&lt;#
.SYNOPSIS
    Microsoft.PowerShell_profile.ps1 - My PowerShell profile
.DESCRIPTION
    Microsoft.PowerShell_profile - Customizes the PowerShell console
.NOTES
    File Name   : Microsoft.PowerShell_profile.ps1
    Author      : Fabrice ZERROUKI - fabricezerrouki@hotmail.com
#&gt;
Set-Location D:\Documents\xxxxxx\PERSONNEL\powerscripts
$Shell=$Host.UI.RawUI
$size=$Shell.BufferSize
$size.width=120
$size.height=3000
$Shell.BufferSize=$size
$size=$Shell.WindowSize
$size.width=120
$size.height=30
$Shell.WindowSize=$size
 
$Shell.BackgroundColor="Black"
$Shell.ForegroundColor="White"
$Shell.CursorSize=10
 
function Get-Time {return $(Get-Date | ForEach {$_.ToLongTimeString()})}
function prompt
{
    Write-Host "[" -noNewLine
    Write-Host $(Get-Time) -ForegroundColor DarkYellow -noNewLine
    Write-Host "] " -noNewLine
    Write-Host $($(Get-Location).Path.replace($home,"~")) -ForegroundColor DarkGreen -noNewLine
    Write-Host $(if ($nestedpromptlevel -ge 1) { '&gt;&gt;' }) -noNewLine
    return "&gt; "
}
 
function ll
{
    param ($dir = ".", $all = $false)
 
    $origFg = $Host.UI.RawUI.ForegroundColor
    if ( $all ) { $toList = ls -force $dir }
    else { $toList = ls $dir }
 
    foreach ($Item in $toList)
    {
        Switch ($Item.Extension)
        {
            ".exe" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".hta" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".cmd" {$Host.UI.RawUI.ForegroundColor="DarkRed"}
            ".ps1" {$Host.UI.RawUI.ForegroundColor="DarkGreen"}
            ".html" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".htm" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".7z" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".zip" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".gz" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".rar" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            Default {$Host.UI.RawUI.ForegroundColor=$origFg}
        }
        if ($item.Mode.StartsWith("d")) {$Host.UI.RawUI.ForegroundColor="Gray"}
        $item
    }
    $Host.UI.RawUI.ForegroundColor = $origFg
}
 
function Edit-HostsFile {
    Start-Process -FilePath notepad -ArgumentList "$env:windir\system32\drivers\etc\hosts"
}
 
function rdp ($ip) {
    Start-Process -FilePath mstsc -ArgumentList "/admin /w:1024 /h:768 /v:$ip"
}
 
function tail ($file) {
Get-Content $file -Wait
}
 
function whoami {
    [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
}
 
function Reload-Profile {
    @(
        $Profile.AllUsersAllHosts,
        $Profile.AllUsersCurrentHost,
        $Profile.CurrentUserAllHosts,
        $Profile.CurrentUserCurrentHost
    ) | % {
        if(Test-Path $_) {
            Write-Verbose "Running $_"
            . $_
        }
    }    
}
 
function Check-SessionArch {
    if ([System.IntPtr]::Size -eq 8) { return "x64" }
    else { return "x86" }
}
 
function Test-Port {
[cmdletbinding()]
param(
[parameter(mandatory=$true)]
[string]$Target,
[parameter(mandatory=$true)]
[int32]$Port,
[int32]$Timeout=2000
)
$outputobj=New-Object -TypeName PSobject
$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostName -Value $Target
if(Test-Connection -ComputerName $Target -Count 2) {$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "ONLINE"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "OFFLINE"}            
$outputobj | Add-Member -MemberType NoteProperty -Name PortNumber -Value $Port
$Socket=New-Object System.Net.Sockets.TCPClient
$Connection=$Socket.BeginConnect($Target,$Port,$null,$null)
$Connection.AsyncWaitHandle.WaitOne($timeout,$false) | Out-Null
if($Socket.Connected -eq $true) {$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Success"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Failed"}            
$Socket.Close | Out-Null
$outputobj | Select TargetHostName, TargetHostStatus, PortNumber, Connectionstatus | Format-Table -AutoSize
}
 
Set-Alias powergui "C:\Program Files\PowerGUI\ScriptEditor.exe"
Set-Alias grep select-string
 
$MaximumHistoryCount=1024
$IPAddress=@(Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.DefaultIpGateway})[0].IPAddress[0]
$PSVersion=$host | Select-Object -ExpandProperty Version
$PSVersion=$PSVersion -replace '^.+@\s'
$SessionArch=Check-SessionArch
$Shell.WindowTitle="PowerFab rulez! ($SessionArch)"
 
Clear-Host
 
Write-Host "`r`nsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  ssssss`tHi Fab!" -nonewline; Write-Host "`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tComputerName`t`t" -nonewline
Write-Host $($env:COMPUTERNAME) -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tIP Address`t`t" -nonewline
Write-Host $IPAddress -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss`tUserName`t`t" -nonewline
Write-Host $env:UserDomain\$env:UserName -nonewline; Write-Host "`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Version`t" -nonewline
Write-Host $PSVersion -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Session`t" -nonewline
Write-Host $SessionArch -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss`n" -ForegroundColor Yellow
 
$LogicalDisk = @()
Get-WmiObject Win32_LogicalDisk -filter "DriveType='3'" | % {
    $LogicalDisk += @($_ | Select @{n="Name";e={$_.Caption}},
    @{n="Volume Label";e={$_.VolumeName}},
    @{n="Size (Gb)";e={"{0:N2}" -f ($_.Size/1GB)}},
    @{n="Used (Gb)";e={"{0:N2}" -f (($_.Size/1GB) - ($_.FreeSpace/1GB))}},
    @{n="Free (Gb)";e={"{0:N2}" -f ($_.FreeSpace/1GB)}},
    @{n="Free (%)";e={if($_.Size) {"{0:N2}" -f (($_.FreeSpace/1GB) / ($_.Size/1GB) * 100 )} else {"NAN"} }})
  }
$LogicalDisk | Format-Table -AutoSize | Out-String</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Sample_Profile_3__PowerShellISEModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Sample_Profile_3__PowerShellISEModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

Function gig-commentIt
{
 &lt;#
   .Synopsis
    This function will add a remark #' character to beginning of line
   .Description
    This function will add a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to comment out
    a section of PowerShell code. 
   .Example
    Add-RemarkedText
    adds the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ("#'" + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-commentIt

Function gig-unCommentIt
{
 &lt;#
   .Synopsis
    This function will remove a remark #' character to beginning of line
   .Description
    This function will remove a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to clean up a 
    previously commentted out section of PowerShell code. 
   .Example
    gig-unCommentIt
    Removes the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($l -replace "#'",''),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-unCommentIt


Function gig-editProfile
{

 psedit $profile

 #'ISE $profile

} #'end function gig-editProfile

Function gig-addHelp
{
  &lt;#
   .Synopsis
    This function adds help at current insertion point 
   .Example
    add-help
    adds comment based help at current insertion point 
   .Notes
    NAME:  Add-Help
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016
    HSG: WES-09-11-10
    KEYWORDS: Scripting Techniques, Windows PowerShell ISE
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $helpText = @"
 &lt;#
   .Synopsis
    This does that 
   .Description
    This function does
   .Example
    Example-
    Example- accomplishes 
   .Parameter 
    The parameter
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS:
    HSG: 
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
"@
 $psise.CurrentFile.Editor.InsertText($helpText)
} #'end function gig-addHelp

Function gig-addHeaderToScript
{
  &lt;#
   .Synopsis
    This function adds header information to a script 
   .Example
    Add-HeaderToScript
    Adds header comments to script 
   .Example 
    AH
    Uses alias to add header comments to script
   .Notes
    NAME:  Add-HeaderToScript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS: $keyword
    HSG: $hsg
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($keyword, $comment, $hsg)
 $header = @"
#' -----------------------------------------------------------------------------
#' Script: $(split-path -Path $psISE.CurrentFile.FullPath -Leaf)
#' Author: glenn garson, JPHSA
#' Date: $(Get-Date)
#' Keywords: $keyword
#' comments: $comment
#'
#' -----------------------------------------------------------------------------
"@
 $psise.CurrentFile.Editor.InsertText($header)
} #'end function gig-addHeaderToScript

Function gig-getLogNameFromDate
{
  &lt;#
   .Synopsis
    Creates a log name from date
   .Description
    This script creates a log from a date. 
   .Example
    gig-getLogNameFromDate -path "c:\jumk" -name "log"
    Creates a file name like c:\JUNK\log20100914-122019.Txt but does not
    create the file. It returns the file name to calling code.
   .Example
    gig-getLogNameFromDate -path "c:\JUNK" -name "log" -Create
    Creates a file name like c:\JUNK\log20100914-122019.Txt and
    create the file. It returns the file name to calling code.
   .Parameter path
    path to log file
   .Parameter name
    base name of log file
   .Parameter create
    switch that determines whether log file or only name is created
   .inputs
    [string]
   .outputs
    [string]
   .Notes
    NAME:  gig-getLogNameFromDate
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 16:58:06
    KEYWORDS: parameter substitution, format specifier, string substitution
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param(
  [string]$path = "c:\JUNKC:\DATA\junkPowerShellTranscripts",
  [string]$name = "log",
  [switch]$Create
 )
 $logname = "{0}\{1}{2}.{3}" -f $path,$name, `
    (Get-Date -Format yyyyMMdd-HHmmss),"Txt"
 if($create) 
  { 
   New-Item -Path $logname -ItemType file -force | out-null
   $logname
  }
 else {$logname}
} #' end function gig-getLogNameFromDate

Function gig-start_ISE_Transcript
{
  &lt;#
   .Synopsis
    This captures output from a script to a created text file
    To use the gig-start_ISE_Transcript function, add the call to the function at the bottom of your script.
   .Example

    xxxxx...{your script}
    gig-start_ISE_Transcript -logname "c:\junk\log.txt"

    Copies output from script to file named xxxxlog.txt in c:\junk folder
   .Parameter logname
    the name and path of the log file.
   .inputs
    [string]
   .outputs
    [io.file]
   .Notes
    NAME:  gig-start_ISE_Transcript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 17:27:22
    KEYWORDS:
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
  Param(
   [string]$logname = (gig-getLogNameFromDate -path $transcriptHome -name "log" -Create)
  )
  $transcriptHeader = @"
**************************************
Windows PowerShell ISE Transcript Start
Start Time: $(get-date)
UserName: $env:username
UserDomain: $env:USERDNSDOMAIN
ComputerName: $env:COMPUTERNAME
Windows version: $((Get-WmiObject win32_operatingsystem).version)
**************************************
Transcript started. Output file is $logname
"@
 $transcriptHeader &gt;&gt; $logname
 $psISE.CurrentPowerShellTab.ConsolePane.Text &gt;&gt; $logname
 Log saved to $logname
} #'end function gig-start_ISE_Transcript

function gig-indentText_x_spaces
{
  &lt;#
   .Synopsis
    This function will indent text in the ISE a specific number
   .Description
    This function will indent selected text in the PowerShell ISE. These are
    real spaces, not tabs. Therefore this is appropriate for situations where
    an actual tab "`t" will not work. 
   .Example
    gig-indentText_x_spaces -space 5
    moves selected text five spaces 
   .Parameter spaces
    The number of spaces to indent the selected text. Note this number cannot
    be a negative number, and this function does not "unindent" the selected text.
   .Notes
    NAME:  gig-indentText_x_spaces
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 06/11/2012 17:16:29
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-6-17-12
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param([int]$space = 1)
 $tab = " " * $space
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($tab + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'end function gig-indentText_x_spaces

Function gig-editModule
{
  &lt;#
   .Synopsis
    This opens a module stored in the $env:PSModulePath location on a new tab in ISE 
   .Description
    This function uses Get-Module to retrieve a module from $env:PSModulePath and then
    it opens the module from that location into a new tab in ISE for editing. Wildcard
    characters that resolve to a single module are supported.
   .Example
    gig-editModule PowerShellISEModule
    gig-editModule PowerShellISEModule opens the PowerShellISEModule into a new tab in the
    ISE for editing 
  .Example
    gig-editModule PowerShellISE*
    gig-editModule PowerShellISE* opens the PowerShellISEModule into a new tab in the
    ISE for editing by using a wild card character for the module name
   .Parameter Name
    The name of the module. Wild cards that resolve to a single module are supported
   .Notes
    NAME:  gig-editModule
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 18:14:19
    KEYWORDS: Scripting Techniques, Modules
    HSG: WES-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($name)
 ISE (Get-Module -ListAvailable $name).path
} #'end function gig-editModule

Function gig-toggleOutlineView
{
  &lt;#
   .Synopsis
    This function toggles the outline view in the ISE 
   .Description
    This function toggles the outline view in the ISE. It will expand 
    or collapse all functions in the current script pane.
   .Example
    gig-toggleOutlineView
    gig-toggleOutlineView will either expand or collapse all functions 
   .Notes
    NAME:  gig-toggleOutlineView
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 19:28:37
    KEYWORDS: Scripting Techniques, Modules
    HSG: wes-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 3.0
 #&gt;
 $psise.CurrentFile.Editor.ToggleOutliningExpansion()
} #'end function gig-toggleOutlineView


#'added Functions from New-ModulesDrive.ps1
#' HSG-1-20-10
Function gig-newModuleDrives
{
&lt;#
    .SYNOPSIS
    Creates two PSDrives: myMods and sysMods
    .EXAMPLE
    gig-newModuleDrives
    Creates two PSDrives: myMods and sysMods. These correspond 
    to the users' modules folder and the system modules folder respectively. 
#&gt;
 $driveNames = "myMods","sysMods"

 For($i = 0 ; $i -le 1 ; $i++)
 {
  New-PsDrive -name $driveNames[$i] -PSProvider filesystem `
  -Root ($env:PSModulePath.split(";")[$i]) -scope Global |
  Out-Null
 } #'end For
} #'end gig-newModuleDrives

Function gig-getFileSystemDrives
{
&lt;#
    .SYNOPSIS
    Displays global PS Drives that use the Filesystem provider
    .EXAMPLE
    gig-getFileSystemDrives
    Displays global PS Drives that use the Filesystem provider
#&gt;
 Get-PSDrive -PSProvider FileSystem -scope Global
} #'end gig-getFileSystemDrives

Function gig-OpenPath
{
 &lt;#
   .Synopsis
    Opens a path in Explorer 
   .Description
    Opens a path in Explorer, default path is C:\, or the first parameter is the path
   .Example
    gig-OpenPath C:\Junk
    gig-OpenPath $moduleHome 
   .Parameter Path
    The path to open in Explorer
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/26/2016 17:31:28
    KEYWORDS:
    HSG: 
   .Link
     
 #'Requires -Version 2.0
 #&gt;
  Param(
  [string]$path = "C:\"
 )
 Invoke-Item -Path $path
 }


 function gig-LoadNetworkPSDrives
{
#'    net use G: "\\Jphsa.org\shared\Data" 
#'    net use H: "\\Jphsa.org\shared\Users\ggarson\" 
#'    net use I: "\\Jphsa-ebhost2\AnasaziFiles\" 
#'    net use M: "\\Jphsa.org\shared\Data\MIS\" 
#'    net use N: "\\Jphsa-ebfile01\e$\" 
#'    net use P: "\\Jphsa.org\shared\Users\ggarson\PROJECTS"


    New-PSDrive -Name "G" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Data" -scope Global
    New-PSDrive -Name "H" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Users\ggarson\" -scope Global
    New-PSDrive -Name "I" -PSProvider "FileSystem" -Root "\\Jphsa-ebhost2\AnasaziFiles\" -scope Global
    New-PSDrive -Name "M" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Data\MIS\" -scope Global
    New-PSDrive -Name "N" -PSProvider "FileSystem" -Root "\\Jphsa-ebfile01\e$\" -scope Global
    New-PSDrive -Name "P" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Users\ggarson\PROJECTS"-scope Global


} 
 
#' *** Alias ***
#'if(!(Test-Path alias:ah))
#' {
#'  New-Alias -Name ah -Value add-headertoscript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:abh))
#' {
#'  New-Alias -Name abh -Value Add-SBSBookHeaderToScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ahlp))
#' {
#'  New-Alias -Name ahlp -Value add-help -Description "MrEd alias" |
#'  Out-Null
#'  }
#'  if(!(Test-Path alias:ras))
#' {
#'  New-Alias -Name ras -Value Remove-AliasFromScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:gfsd))
#' {
#'  New-Alias -Name gfsd -Value gig-getFileSystemDrives -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:cs))
#' {
#'  New-Alias -Name cs -value Copy-ScriptToNewTab -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ar))
#' {
#'  New-Alias -Name ar -value Add-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:rr))
#' {
#'  New-Alias -Name rr -value Remove-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:em))
#' {
#'  New-Alias -Name em -value Edit-Module -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:iem))
#' {
#'  New-Alias -Name iem -value Import-EveryModule -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:sov))
#' {
#'  New-Alias -Name sov -value gig-toggleOutlineView -Description "MrEd alias" |
#'  Out-Null
#'  }



#' *** Variables ***
if(!(Test-Path variable:moduleHome))
{
 new-variable -name moduleHome -value "$env:userProfile\documents\WindowsPowerShell\Modules"
}
#'if(!(Test-Path variable:backupHome))
#'{
#' new-variable -name backupHome -value "$env:userProfile\documents\WindowsPowerShell\profileBackup"
#'}

if(!(Test-Path variable:TranscriptHome))
{
 new-variable -name TranscriptHome -value "C:\DATA\junkPowerShellTranscripts"
 #' new-variable -name TranscriptHome -value "$env:userProfile\documents\WindowsPowerShell\transcript"
}

if(!(Test-Path variable:myScripts))
{
 new-variable -name myScripts -value "C:\DATA\PowerShellScripts"
}

Set-Location $myScripts

Clear-Host

gig-LoadNetworkPSDrives

Export-ModuleMember -alias * -function * -variable *

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Proxy_Clone_Function</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_base_Then_build_Proxy_from_it_RESULT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Proxy_Clone_Function</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_base_Then_build_Proxy_from_it_RESULT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function NewConvertTo-HTML {
[CmdletBinding(DefaultParameterSetName='Page', HelpUri='http://go.microsoft.com/fwlink/?LinkID=113290', RemotingCapability='None')]
param(
    [Parameter(ValueFromPipeline=$true)]
    [psobject]
    ${InputObject},

    [Parameter(Position=0)]
    [System.Object[]]
    ${Property},

    [Parameter(ParameterSetName='Page', Position=3)]
    [string[]]
    ${Body},

    [Parameter(ParameterSetName='Page', Position=1)]
    [string[]]
    ${Head},

    [Parameter(ParameterSetName='Page', Position=2)]
    [ValidateNotNullOrEmpty()]
    [string]
    ${Title},

    [ValidateNotNullOrEmpty()]
    [ValidateSet('Table','List')]
    [string]
    ${As},

    [Parameter(ParameterSetName='Page')]
    [Alias('cu','uri')]
    [ValidateNotNullOrEmpty()]
    [uri]
    ${CssUri},

    [Parameter(ParameterSetName='Fragment')]
    [ValidateNotNullOrEmpty()]
    [switch]
    ${Fragment},

    [ValidateNotNullOrEmpty()]
    [string[]]
    ${PostContent},

    [ValidateNotNullOrEmpty()]
    [string[]]
    ${PreContent})

begin
{
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer))
        {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Utility\ConvertTo-Html', [System.Management.Automation.CommandTypes]::Cmdlet)
        
        # create our css
        $css += @'
        &lt;style&gt;
        th { color:white; background-color: black;}
        body { font-family: Calibri; padding: 2px }
        &lt;/style&gt;   
'@

        # was -head specified?
        if ($PSBoundParameters.ContainsKey('head')) {
            $PSBoundParameters.head += $css
        } else {
            $PSBoundParameters += @{'Head'=$css}
        }
        

        $scriptCmd = {&amp; $wrappedCmd @PSBoundParameters }
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process
{
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end
{
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
&lt;#

.ForwardHelpTargetName Microsoft.PowerShell.Utility\ConvertTo-Html
.ForwardHelpCategory Cmdlet

#&gt;
}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Proxy_Clone_Function</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_base_Then_build_Proxy_from_it</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Proxy_Clone_Function</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_base_Then_build_Proxy_from_it</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># proxy base
$cmd = New-Object System.Management.Automation.CommandMetaData (Get-Command ConvertTo-HTML)
[System.Management.Automation.ProxyCommand]::Create($cmd) |
Out-File ConvertToHTMLProxy.ps1


# result#'
[CmdletBinding(DefaultParameterSetName='Page', HelpUri='http://go.microsoft.com/fwlink/?LinkID=113290', RemotingCapability='None')]
param(
    [Parameter(ValueFromPipeline=$true)]
    [psobject]
    ${InputObject},

    [Parameter(Position=0)]
    [System.Object[]]
    ${Property},

    [Parameter(ParameterSetName='Page', Position=3)]
    [string[]]
    ${Body},

    [Parameter(ParameterSetName='Page', Position=1)]
    [string[]]
    ${Head},

    [Parameter(ParameterSetName='Page', Position=2)]
    [ValidateNotNullOrEmpty()]
    [string]
    ${Title},

    [ValidateNotNullOrEmpty()]
    [ValidateSet('Table','List')]
    [string]
    ${As},

    [Parameter(ParameterSetName='Page')]
    [Alias('cu','uri')]
    [ValidateNotNullOrEmpty()]
    [uri]
    ${CssUri},

    [Parameter(ParameterSetName='Fragment')]
    [ValidateNotNullOrEmpty()]
    [switch]
    ${Fragment},

    [ValidateNotNullOrEmpty()]
    [string[]]
    ${PostContent},

    [ValidateNotNullOrEmpty()]
    [string[]]
    ${PreContent})

begin
{
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer))
        {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Utility\ConvertTo-Html', [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {&amp; $wrappedCmd @PSBoundParameters }
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}


process
{
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end
{
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
&lt;#

.ForwardHelpTargetName Microsoft.PowerShell.Utility\ConvertTo-Html
.ForwardHelpCategory Cmdlet

#&gt;




# modifying
function NewConvertTo-HTML {
[CmdletBinding(DefaultParameterSetName='Page', HelpUri='http://go.microsoft.com/fwlink/?LinkID=113290', RemotingCapability='None')]
param(
    [Parameter(ValueFromPipeline=$true)]
    [psobject]
    ${InputObject},

    [Parameter(Position=0)]
    [System.Object[]]
    ${Property},

    [Parameter(ParameterSetName='Page', Position=3)]
    [string[]]
    ${Body},

    [Parameter(ParameterSetName='Page', Position=1)]
    [string[]]
    ${Head},

    [Parameter(ParameterSetName='Page', Position=2)]
    [ValidateNotNullOrEmpty()]
    [string]
    ${Title},

    [ValidateNotNullOrEmpty()]
    [ValidateSet('Table','List')]
    [string]
    ${As},

    [Parameter(ParameterSetName='Page')]
    [Alias('cu','uri')]
    [ValidateNotNullOrEmpty()]
    [uri]
    ${CssUri},

    [Parameter(ParameterSetName='Fragment')]
    [ValidateNotNullOrEmpty()]
    [switch]
    ${Fragment},

    [ValidateNotNullOrEmpty()]
    [string[]]
    ${PostContent},

    [ValidateNotNullOrEmpty()]
    [string[]]
    ${PreContent})

begin
{
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer))
        {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Utility\ConvertTo-Html', [System.Management.Automation.CommandTypes]::Cmdlet)
        
        # create our css
        $css += @'
        &lt;style&gt;
        th { color:white; background-color: black;}
        body { font-family: Calibri; padding: 2px }
        &lt;/style&gt;   
'@

        # was -head specified?
        if ($PSBoundParameters.ContainsKey('head')) {
            $PSBoundParameters.head += $css
        } else {
            $PSBoundParameters += @{'Head'=$css}
        }
        

        $scriptCmd = {&amp; $wrappedCmd @PSBoundParameters }
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process
{
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end
{
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
&lt;#

.ForwardHelpTargetName Microsoft.PowerShell.Utility\ConvertTo-Html
.ForwardHelpCategory Cmdlet

#&gt;
}




# add a param
$PSBoundParameters.Remove('MyNewParam')
$scriptCmd = {&amp; $wrappedCmd @PSBoundParameters }



# remove a param
$PSBoundParameters += @{'RemovedParam'=$MyValue}
$scriptCmd = {&amp; $wrappedCmd @PSBoundParameters }



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Proxy_Clone_Function</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Output_an_existing_Command_to_A_File</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Proxy_Clone_Function</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Output_an_existing_Command_to_A_File</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># proxy base
$cmd = New-Object System.Management.Automation.CommandMetaData (Get-Command ConvertTo-HTML)
[System.Management.Automation.ProxyCommand]::Create($cmd) |
Out-File ConvertToHTMLProxy.ps1



HERE IS THE OUTPUT
=====================
#'[CmdletBinding(DefaultParameterSetName='Page', HelpUri='http://go.microsoft.com/fwlink/?LinkID=113290', RemotingCapability='None')]
#'param(
#'    [Parameter(ValueFromPipeline=$true)]
#'    [psobject]
#'    ${InputObject},
#'
#'    [Parameter(Position=0)]
#'    [System.Object[]]
#'    ${Property},
#'
#'    [Parameter(ParameterSetName='Page', Position=3)]
#'    [string[]]
#'    ${Body},
#'
#'    [Parameter(ParameterSetName='Page', Position=1)]
#'    [string[]]
#'    ${Head},
#'
#'    [Parameter(ParameterSetName='Page', Position=2)]
#'    [ValidateNotNullOrEmpty()]
#'    [string]
#'    ${Title},
#'
#'    [ValidateSet('Table','List')]
#'    [ValidateNotNullOrEmpty()]
#'    [string]
#'    ${As},
#'
#'    [Parameter(ParameterSetName='Page')]
#'    [Alias('cu','uri')]
#'    [ValidateNotNullOrEmpty()]
#'    [uri]
#'    ${CssUri},
#'
#'    [Parameter(ParameterSetName='Fragment')]
#'    [ValidateNotNullOrEmpty()]
#'    [switch]
#'    ${Fragment},
#'
#'    [ValidateNotNullOrEmpty()]
#'    [string[]]
#'    ${PostContent},
#'
#'    [ValidateNotNullOrEmpty()]
#'    [string[]]
#'    ${PreContent})
#'
#'begin
#'{
#'    try {
#'        $outBuffer = $null
#'        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer))
#'        {
#'            $PSBoundParameters['OutBuffer'] = 1
#'        }
#'        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Utility\ConvertTo-Html', [System.Management.Automation.CommandTypes]::Cmdlet)
#'        $scriptCmd = {&amp; $wrappedCmd @PSBoundParameters }
#'        $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)
#'        $steppablePipeline.Begin($PSCmdlet)
#'    } catch {
#'        throw
#'    }
#'}
#'
#'process
#'{
#'    try {
#'        $steppablePipeline.Process($_)
#'    } catch {
#'        throw
#'    }
#'}
#'
#'end
#'{
#'    try {
#'        $steppablePipeline.End()
#'    } catch {
#'        throw
#'    }
#'}
#'&lt;#
#'
#'.ForwardHelpTargetName Microsoft.PowerShell.Utility\ConvertTo-Html
#'.ForwardHelpCategory Cmdlet
#'
#'#&gt;
#'
#'
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Proxy_Clone_Function</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>wrapper_around_Export-CSV_that_HardCodesTheDelimiter</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Proxy_Clone_Function</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>wrapper_around_Export-CSV_that_HardCodesTheDelimiter</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Create a proxy function named Export-TDF. 
'This should be a wrapper around Export-CSV, 
'	and should not include a -Delimiter parameter. 
'Instead, it should hardcode the delimiter to be a tab. 
'Hint: you can specify a tab by putting a backtick, followed by the letter t, inside double quotes. 


function Export-TDF {
[CmdletBinding(DefaultParameterSetName='Delimiter', SupportsShouldProcess=$true, ConfirmImpact='Medium', HelpUri='http://go.microsoft.com/fwlink/?LinkID=113299')]
param(
    [Parameter(Mandatory=$true, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]
    [psobject]
    ${InputObject},

    [Parameter(Position=0)]
    [ValidateNotNullOrEmpty()]
    [string]
    ${Path},

    [Alias('PSPath')]
    [ValidateNotNullOrEmpty()]
    [string]
    ${LiteralPath},

    [switch]
    ${Force},

    [Alias('NoOverwrite')]
    [switch]
    ${NoClobber},

    [ValidateSet('Unicode','UTF7','UTF8','ASCII','UTF32','BigEndianUnicode','Default','OEM')]
    [string]
    ${Encoding},

    [switch]
    ${Append},

    [Parameter(ParameterSetName='UseCulture')]
    [switch]
    ${UseCulture},

    [Alias('NTI')]
    [switch]
    ${NoTypeInformation})

begin
{
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer))
        {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Microsoft.PowerShell.Utility\Export-Csv', [System.Management.Automation.CommandTypes]::Cmdlet)
        $PSBoundParameters += @{'Delimiter'="`t"}
        $scriptCmd = {&amp; $wrappedCmd @PSBoundParameters }
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process
{
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end
{
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
&lt;#

.ForwardHelpTargetName Microsoft.PowerShell.Utility\Export-Csv
.ForwardHelpCategory Cmdlet

#&gt;
}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>DoesRemoveWindowsStoreExist_if_So_WhatIsItsValue_v4</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>DoesRemoveWindowsStoreExist_if_So_WhatIsItsValue_v4</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$file_WindowsVersionsInfo &lt;=== This file was not created. What was the problem? 0959 did not show up in the Windows List

#'DoesRemoveWindowsStoreExist_if_So_WhatIsItsValue_v4.ps1
#' 1] Ping the computer
#' 2] Write the name of those that ping into the file Ping_Returned_2018_05_01.txt
#'    Write the name of those that did NOT ping into the file Ping_DidNOT_2018_05_01.txt
#' 3] For those that pinged check the OS version
#'    Write the name of Win10 computers into the file OS_Win10_2018_05_01.txt
#'    Write the name of Other OS into the file OS_NOT_Win10_2018_05_01.txt
#' 4] For the Win10 computers: store in file: 
#'    Three columns: OS, RemoveWindowsStore_Exists, RemoveWindowsStore_Value

#'============================================

$Path_forFiles = "C:\DATA\"
$file_INPUT_computerList = $Path_forFiles + "2018_05_01_ALL_computers.txt"
$file_PingReturned = $Path_forFiles + "2018_05_01_Ping_Returned.txt"
$file_PingNOTReturned = $Path_forFiles + "2018_05_01_Ping_DidNOT.txt"
$file_WindowsVersionsInfo =  $Path_forFiles + "2018_05_01_WindowsVersion.csv"    #' NOTE: CSV
$file_OS_Win10 = $Path_forFiles + "2018_05_01_OS_Win10.txt"
$file_WindowsStoreINFO  = $Path_forFiles + "2018_05_01_WindowsStoreINFO.csv"    #' NOTE: CSV

$registryPath = "HKLM:\Software\Microsoft\WindowsStore"
$RegitryValueName = "RemoveWindowsStore"
$value = "1"

#' 1] Ping the computer
#' 2] Write the name of those that ping into the file Ping_Returned_2018_05_01.txt
#'    Write the name of those that did NOT ping into the file Ping_DidNOT_2018_05_01.txt
$Computers = get-content $file_INPUT_computerList;
foreach ($computer in $Computers) {
    write-host $computer   
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path $file_PingReturned
		}else{
			Add-Content -value $computer -path $file_PingNOTReturned
		}
	}

#' 3] For those that pinged check the OS version
#'    Write the name of Win10 computers into the file OS_Win10_2018_05_01.txt
#'    Write the name of Other OS into the file OS_NOT_Win10_2018_05_01.txt

 
$theComputerOSinfo = @()
$computers = Get-Content $file_PingReturned 
$i=0
$count = $computers.count
foreach($computer in $computers)
    {
        $i++
        Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
        -PercentComplete ($i/$count*100)
        $info = @{}
        $version = 0
        try{
            #'================================================================================

                        write-host "responded to PING:"$computer -ForegroundColor Green 
                        #'--------------------------------------------------------------------------------
                        $OperatingSystem = Get-WmiObject -ComputerName $computer -Class Win32_OperatingSystem
                        #'--------------------------------------------------------------------------------
                        $BuildNumber = $OperatingSystem.BuildNumber 
                        write-host "Build Number:"$BuildNumber -ForegroundColor White                  
                        switch  ($BuildNumber)
                        {
                            10240 {$Build = "1507, Threshold 1, N/A,  July 29, 2015"}
                            10586 {$Build = "1511, Threshold 2, November Update,  2015/11/10"}
                            14393 {$Build = "1607, Redstone 1, 2016/08/02"}
                            15063 {$Build = "1703, Redstone 2, Creators Update, 2017/04/05"}
                            16299 {$Build = "1709, Redstone 3, Fall Creators Update, 2017/10/17"}
                            17134 {$Build = "1803, Redstone 4, Early 2018"}
                            17650 {$Build = "1809, Redstone 5, Late 2018"}
                            default {$Build = "default"}
                        }
                        write-host "Build:"$Build -ForegroundColor White 

                        #'--------------------------------------------------------------------------------
                        $OS = $OperatingSystem.Version  
                        write-host "OS:"$OS -ForegroundColor Yellow                  
                        switch  ($OS)
                        {
                            "10.0.16299" {$OSName = "Windows 10 (1709)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.15063" {$OSName = "Windows 10 (1703)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.14393" {$OSName = "Windows 10 (1607)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.10586" {$OSName = "Windows 10 (1511)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.10240" {$OSName = "Windows 10"; Add-Content -value $computer -path $file_OS_Win10}
                            "6.3.9600" {$OSName = "Windows 8.1 (Update 1)"}
                            "6.3.9200" {$OSName = "Windows 8.1"}
                            "6.2.9200" {$OSName = "Windows 8"}
                            "6.1.7601" {$OSName = "Windows 7 SP1"}
                            "6.1.7600" {$OSName = "Windows 7"}
                            "6.0.6002" {$OSName = "Windows Vista SP2"}
                            "6.0.6001" {$OSName = "Windows Vista SP1"}
                            "6.0.6000" {$OSName = "Windows Vista"}
                            "5.1.2600" {$OSName = "Windows XP"}
                            default {$OSName = "default"}
                        }
                        write-host "OSName:"$OSName -ForegroundColor Yellow 
            #'================================================================================
            }
 
 
            catch
            {
                        $OperatingSystem  = 'Not Installed/Not Available'
            }

            $info.Computer = $computer
            $info.OSName= $OSName
            $info.Build =  $Build
            $info.BuildNumber =  $BuildNumber
            $info.OSversion = $OS

            $object = new-object -TypeName PSObject -Property $info
            $theComputerOSinfo += $object
}
$theComputerOSinfo | select computer,OSName,Build, BuildNumber,OSversion  | Export-Csv -NoTypeInformation -Path $file_WindowsVersionsInfo

#' 4] For the Win10 computers: store in file:  $file_WindowsStoreINFO
#'    Three columns: OS, RemoveWindowsStore_Exists, RemoveWindowsStore_Value

$return_object = @()

foreach ($computer in (Get-Content $file_OS_Win10)){

  write-verbose "Getting Windows Store Info on $computer..." -Verbose
  $return_object += Invoke-Command -ComputerName "$computer" -ScriptBlock {
                                                                            #'=====================================================================================
                                                                            write-verbose "1]" -Verbose
                                                                            $info2 = @{}
                                                                            $registryPath = "HKLM:\Software\Microsoft\WindowsStore"
                                                                            $Name = "RemoveWindowsStore"
                                                                            $value = "1"
                                                                            write-verbose "2]" -Verbose
                                                                            try{
                                                                                    IF(!(Test-Path $registryPath))
	                                                                                    {
                                                                                            $registryPathExists = "1"
                                                                                            $registryPathValue = (Get-ItemProperty -Path $registryPath -Name $RegitryValueName).$RegitryValueName
	                                                                                    }
                                                                                     ELSE 
 	                                                                                    {
    	                                                                                    $registryPathExists = "0"
                                                                                            $registryPathValue = "n/a"
                                                                                        }
 			                                                                      }
			                                                                  catch{
		                                                                                $registryPathExists = "error"
                                                                                        $registryPathValue = "error"
		      	                                                                   }

                                                                            #' ------------------------------------------------------------

                                                                            write-verbose "3]" -Verbose
                                                                            Write-Host "-&gt; computer"$Using:computer
                                                                            Write-Host "-&gt; registryPathExists"$registryPathExists
                                                                            Write-Host "-&gt; registryPathValue"$registryPathValue
                                                                            New-Object -TypeName PSCustomObject -Property @{Host=$env:computername; registryPathExists=$registryPathExists; registryPathValue=$registryPathValue}
                                                                            write-verbose "4]" -Verbose

                                                                           #'========================================================================================
                                                                            Write-Host "ScriptBlock Loop Done: " -ForegroundColor Green
                                                                            #'return $info2
                                                                            } 
                                                        Write-Host "6] Loop for computer is done"$computer -ForegroundColor Green
                                                        
                                                        
                                                    }
                                                    write-verbose "7] all computers have been looped" -Verbose
                                                   
                                                   #'| SELECT computer,registryPathExists,registryPathValue
                                                    $return_object | select Host, registryPathExists, registryPathValue  | Export-Csv -NoTypeInformation -Path $file_WindowsStoreINFO
                                                    write-output ("Done with all computers")
                                                     $return_object | select Host, registryPathExists, registryPathValue  | Format-List









</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting__Invoke-Command</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Parameters</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting__Invoke-Command</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Parameters</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
=======================================================================================================
https://blogs.technet.microsoft.com/ralphkyttle/2015/06/04/powershell-passing-parameters-as-variables-using-remote-management-and-invoke-command/

Param
(
  [string]$remoteserver,
  [string]$eventloginput,
  [string]$numinput
)
$ScriptBlockContent =
{
$eventlog = $args[0]
$num = $args[1]
get-eventlog -logname $eventlog -newest $num
}

Invoke-Command -Computer $remoteserver -ScriptBlock $ScriptBlockContent -ArgumentList $eventloginput, $numinput
#End

=======================================================================================================
https://stackoverflow.com/questions/4225748/how-do-i-pass-named-parameters-with-invoke-command

'PROBLEM:
---------
'I have a script that I can run remotely via Invoke-Command

Invoke-Command -ComputerName (Get-Content C:\Scripts\Servers.txt) `
               -FilePath C:\Scripts\ArchiveEventLogs\ver5\ArchiveEventLogs.ps1
'As long as I use default parameters, it works fine. However, 
'the script has 2 named [switch] parameters (-Debug and -Clear)

'How can I pass the switched parameters via the Invoke-Command? I've tried the -ArgumentList
'	 but I'm getting errors so I must have the syntax wrong or something. Any help is greatly appreciated.

'Answer #1:
---------
'-ArgumentList is based on use with scriptblock commands, like:

Invoke-Command -Cn (gc Servers.txt) {param($Debug=$False, $Clear=$False) C:\Scripts\ArchiveEventLogs\ver5\ArchiveEventLogs.ps1 } -ArgumentList $False,$True

'When you call it with a -File it still passes the parameters like a dumb splatted array. 

a whole lot more in the post. Check it out</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CIM_ErrorHandling_assumes_you_start_with_WSman_Protocol</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CIM_ErrorHandling_assumes_you_start_with_WSman_Protocol</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'In this revision, we changed our New-CimSessionOption to use a variable for the protocol.
'We manually set this to Wsman to begin with, but in the event of a failure, we switch it to Dcom. 
' If it fails again, we set the protocol to Stop, which triggers an exit from our Do loop, 
'	and also take the opportunity to log the computer name, if we were asked to do so. 
'Writes error to Log	


function Set-TMServiceLogon {
&lt;#'
.SYNOPSIS
Sets service login name and password.
.DESCRIPTION
This command uses either CIM (default) or WMI to
set the service password, and optionally the logon
user name, for a service, which can be running on
one or more remote machines. You must run this command
as a user who has permission to peform this task,
remotely, on the computers involved.
.PARAMETER ServiceName
The name of the service. Query the Win32_Service class
to verify that you know the correct name.
.PARAMETER ComputerName
One or more computer names. Using IP addresses will
fail with CIM; they will work with WMI. CIM is always
attempted first. 
.PARAMETER NewPassword
A plain-text string of the new password.
.PARAMETER NewUser
Optional; the new logon user name, in DOMAIN\USER
format.
.PARAMETER ErrorLogFilePath
If provided, this is a path and filename of a text
file where failed computer names will be logged.
#'&gt;
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True,
                   ValueFromPipelineByPropertyName=$True)]
        [string]$ServiceName,

        [Parameter(Mandatory=$True,
                   ValueFromPipeline=$True,
                   ValueFromPipelineByPropertyName=$True)]
        [string[]]$ComputerName,

        [Parameter(ValueFromPipelineByPropertyName=$True)]
        [string]$NewPassword,

        [Parameter(ValueFromPipelineByPropertyName=$True)]
        [string]$NewUser,

        [string]$ErrorLogFilePath
    )

BEGIN{}

PROCESS{
    ForEach ($computer in $ComputerName) {

        Do {
            Write-Verbose "Connect to $computer on WS-MAN"
            $protocol = "Wsman"

            Try {
                $option = New-CimSessionOption -Protocol $protocol
                $session = New-CimSession -SessionOption $option `
                                          -ComputerName $Computer `
                                          -ErrorAction Stop

                If ($PSBoundParameters.ContainsKey('NewUser')) {
                    $args = @{'StartName'=$NewUser
                              'StartPassword'=$NewPassword}
                } Else {
                    $args = @{'StartPassword'=$NewPassword}
                    Write-Warning "Not setting a new user name"
                }

                Write-Verbose "Setting $servicename on $computer"
                $params = @{'CimSession'=$session
                            'MethodName'='Change'
                            'Query'="SELECT * FROM Win32_Service " +
                                    "WHERE Name = '$ServiceName'"
                            'Arguments'=$args}
                $ret = Invoke-CimMethod @params

                switch ($ret.ReturnValue) {
                    0  { $status = "Success" }
                    22 { $status = "Invalid Account" }
                    Default { $status = "Failed: $($ret.ReturnValue)" }
                }

                $props = @{'ComputerName'=$computer
                           'Status'=$status}
                $obj = New-Object -TypeName PSObject -Property $props
                Write-Output $obj

                Write-Verbose "Closing connection to $computer"
                $session | Remove-CimSession
		$protocol = "Stop"
            } Catch {
                #' change protocol - if we've tried both
                #' and logging was specified, log the computer
                Switch ($protocol) {
                    'Wsman' { $protocol = 'Dcom' }
                    'Dcom'  { 
                        $protocol = 'Stop'

                        if ($PSBoundParameters.ContainsKey('ErrorLogFilePath')) {
                            Write-Warning "$computer failed; logged to $ErrorLogFilePath"
                            $computer | Out-File $ErrorLogFilePath -Append
                        } #' if logging
                     }            
                } #'switch

            } #' try/catch
        } Until ($protocol -eq 'Stop')
    } #'foreach
} #'PROCESS

END{} 

} #'function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CIM_ErrorHandling</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CIM_ErrorHandling</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Errors from CIM remoting tend to be .NET types of errors
'This one lets you switch from one protocol to the other

#' notice error behavior
Get-Service -Name BITS,Nobody,WinRM



#' try each in turn
Get-Service -Name BITS,Nobody,WinRM -EA Continue
Get-Service -Name BITS,Nobody,WinRM -EA SilentlyContinue
Get-Service -Name BITS,Nobody,WinRM -EA Inquire
Get-Service -Name BITS,Nobody,WinRM -EA Stop



#' moving from this... The processing would continue even if there is an error
        Write-Verbose "Connecting to $computer over $protocol"
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option


#' to this... This should be used when just one thing, on one computer is happening.
        Write-Verbose "Connecting to $computer over $protocol"
        $params = @{'ComputerName'=$Computer
                    'SessionOption'=$option
                    'ErrorAction'='Stop'}       #'' Put a terminating action into the session, when the script has a problem, rather than allowing processing to continue.
        $session = New-CimSession @params



#' observe structure - will not execute as-is
 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params            #'' so if it were to stop here it would jump to the 'Catch' section
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj
        } Catch {
                                                 #'Empty CATCH section
        } #'try/catch
 
    } #'foreach
} #'PROCESS


#'' HERE IS A CATCH section that has been filled out.

#' observe catch behavior - will not execute as-is
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            #' Did we specify protocol fallback?
            #' If so, try again. If we specified logging,
            #' we won't log a problem here - we'll let
            #' the logging occur if this fallback also
            #' fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #'if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #'if logging

                Get-MachineInfo @params
            } #'if protocolfallback

            #' if we didn't specify fallback, but we
            #' did specify logging, then log the error,
            #' because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } #' if write to log

        } #'try/catch




#' pseudo-code
Try {
	$ErrorActionPreference = "Stop"
	#' run something that doesn't have -ErrorAction
	$ErrorActionPreference = "Continue"
} Catch {
	#' ...
}



#' pseudo-code (tend to be .NET types of errors)
Try {
	#' something here generates an exception
} Catch [Exception.Type.One] {
	#' deal with that exception here
} Catch [Exception.Type.Two] {
	#' deal with the other exception here
} Catch {
	#' deal with anything else here
} Finally {
	#' run something else
}



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>custom_Get-MachineInfo_with_Help_and_ErrorHandling_and_LogFile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>custom_Get-MachineInfo_with_Help_and_ErrorHandling_and_LogFile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            # Did we specify protocol fallback?
            # If so, try again. If we specified logging,
            # we won't log a problem here - we'll let
            # the logging occur if this fallback also
            # fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #if logging

                Get-MachineInfo @params
            } #if protocolfallback

            # if we didn't specify fallback, but we
            # did specify logging, then log the error,
            # because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } # if write to log

        } #try/catch
 
    } #foreach
} #PROCESS

END {}

} #function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>custom_Get-MachineInfo</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>custom_Get-MachineInfo</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>From Directions Training:


assumes WSman if $Protocol is not supplied
======================================================================
#' final code
function Get-MachineInfo {
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        #' Establish session protocol
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        #' Connect session
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option
  
        #' Query data
        $os_params = @{'ClassName'='Win32_OperatingSystem'
                       'CimSession'=$session}
        $os = Get-CimInstance @os_params

        $cs_params = @{'ClassName'='Win32_ComputerSystem'
                       'CimSession'=$session}
        $cs = Get-CimInstance @cs_params

        $sysdrive = $os.SystemDrive
        $drive_params = @{'ClassName'='Win32_LogicalDisk'
                          'Filter'="DeviceId='$sysdrive'"
                          'CimSession'=$session}
        $drive = Get-CimInstance @drive_params

        $proc_params = @{'ClassName'='Win32_Processor'
                         'CimSession'=$session}
        $proc = Get-CimInstance @proc_params |
                Select-Object -first 1

  
        #' Close session
        $session | Remove-CimSession
  
        #' Output data
        $props = @{'ComputerName'=$computer
                   'OSVersion'=$os.version
                   'SPVersion'=$os.servicepackmajorversion
                   'OSBuild'=$os.buildnumber
                   'Manufacturer'=$cs.manufacturer
                   'Model'=$cs.model
                   'Procs'=$cs.numberofprocessors
                   'Cores'=$cs.numberoflogicalprocessors
                   'RAM'=($cs.totalphysicalmemory / 1GB)
                   'Arch'=$proc.addresswidth
                   'SysDriveFreeSpace'=$drive.freespace}
        $obj = New-Object -TypeName PSObject -Property $props
        Write-Output $obj                           #' &lt;=== Put HashTable object for output
 
    } #'foreach
} #'PROCESS

END {}

} #'function


====NOTES=====================================================================

#' functional overview of tool - will not execute as-is
        #' Query data
        $os = Get-CimInstance -ClassName Win32_OperatingSystem `
                              -CimSession $session
  
        #' Close session
        $session | Remove-CimSession
  
        #' Output data
        $os | Select-Object -Prop @{n='ComputerName';e={$computer}},
                                Version,ServicePackMajorVersion


#' params into hash table
$params = @{'ClassName'='Win32_OperatingSystem'
            'ComputerName'='CLIENT1'}


#' switch params in hash table
$params = @{'ClassName'='Win32_OperatingSystem'
            'ComputerName'='CLIENT1'
            'Verbose' = $True}



#' splatting hash table of params
Get-CimInstance @params



#' revised snippet - will not execute as-is
        #' Query data
        $os_params = @{'ClassName'='Win32_OperatingSystem'
                       'CimSession'=$session}
        $os = Get-CimInstance @os_params

        $cs_params = @{'ClassName'='Win32_ComputerSystem'
                       'CimSession'=$session}
        $cs = Get-CimInstance @cs_params

        $sysdrive = $os.SystemDrive
        $drive_params = @{'ClassName'='Win32_LogicalDisk'
                          'Filter'="DeviceId='$sysdrive'"
                          'CimSession'=$session}        $drive = Get-CimInstance @drive_params

        $proc_params = @{'ClassName'='Win32_Processor'
                         'CimSession'=$session}
        $proc = Get-CimInstance @proc_params |
                Select-Object -first 1



#' constructing custom object
        #' Output data
        $props = @{'ComputerName'=$computer
                   'OSVersion'=$os.version
                   'SPVersion'=$os.servicepackmajorversion
                   'OSBuild'=$os.buildnumber
                   'Manufacturer'=$cs.manufacturer
                   'Model'=$cs.model
                   'Procs'=$cs.numberofprocessors
                   'Cores'=$cs.numberoflogicalprocessors
                   'RAM'=($cs.totalphysicalmemory / 1GB)
                   'Arch'=$proc.addresswidth
                   'SysDriveFreeSpace'=$drive.freespace}
        $obj = New-Object -TypeName PSObject -Property $props
        Write-Output $obj</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_GetResultsFromContactingAComputer_showAsStatus</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_GetResultsFromContactingAComputer_showAsStatus</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Example_GetResultsFromContactingAComputer_showAsStatus

'it outputs an object for each computer it operates against. 
'	The output should include the computer name and a status 




===========================================================
function Set-TMServiceLogon {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True,                              #' &lt;=== Mandatory
                   ValueFromPipelineByPropertyName=$True)]       #' &lt;=== can accept pipeline input ByPropertyName
        [string]$ServiceName,

        [Parameter(Mandatory=$True,                              #' &lt;=== Mandatory
                   ValueFromPipeline=$True,                      #' &lt;=== can accept pipeline input ByValue  (only one parm is allowed to do so?)
                   ValueFromPipelineByPropertyName=$True)]       #' &lt;=== can accept pipeline input ByPropertyName
        [string[]]$ComputerName,

        [Parameter(Mandatory=$True,                              #' &lt;=== Mandatory
                   ValueFromPipelineByPropertyName=$True)]       #' &lt;=== can accept pipeline input ByPropertyName
        [string]$NewPassword,

        [Parameter(ValueFromPipelineByPropertyName=$True)]       #' &lt;=== can accept pipeline input ByPropertyName
        [string]$NewUser,

        [string]$ErrorLogFilePath
    )

BEGIN{}

PROCESS{
    ForEach ($computer in $ComputerName) {

        $option = New-CimSessionOption -Protocol Wsman
        $session = New-CimSession -SessionOption $option `
                                  -ComputerName $Computer

        If ($PSBoundParameters.ContainsKey('NewUser')) {           
            $args = @{'StartName'=$NewUser
                      'StartPassword'=$NewPassword}
        } Else {
            $args = @{'StartPassword'=$NewPassword}
        }

        $params = @{'CimSession'=$session                        #' Put the Parms into a HashTable
                    'MethodName'='Change'
                    'Query'="SELECT * FROM Win32_Service WHERE Name = '$ServiceName'"
                    'Arguments'=$args}
        $ret = Invoke-CimMethod @params                          #' Splat the HashTable as input to 'Invoke-CimMethod'
       
        #' Change Method (Win32_Service) status Codes: https://msdn.microsoft.com/en-us/library/aa384901.aspx
        
        switch ($ret.ReturnValue) {                              #' Get the Return Value
            0  { $status = "Success" }      
            22 { $status = "Invalid Account" }
            Default { $status = "Failed: $($ret.ReturnValue)" }
        }

        $props = @{'ComputerName'=$computer                      #' Build the output variable, with the Return Value and the Computer Name
                   'Status'=$status}
        $obj = New-Object -TypeName PSObject -Property $props    #' Package the output variable into a new object
        Write-Output $obj                                        #' Write the object to the screen

        $session | Remove-CimSession

    } #foreach
} #PROCESS

END{} 

} #function
===========================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-UserSession</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-UserSession</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

#'FROM: https://gallery.technet.microsoft.com/scriptcenter/Get-UserSessions-Parse-b4c97837

#' To uset it:
#' &gt; Get-UserSession -ComputerName BCC-EXPLORER3


function Get-UserSession {
&lt;#  
.SYNOPSIS  
    Retrieves all user sessions from local or remote computers(s)

.DESCRIPTION
    Retrieves all user sessions from local or remote computer(s).
    
    Note:   Requires query.exe in order to run
    Note:   This works against Windows Vista and later systems provided the following registry value is in place
            HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\AllowRemoteRPC = 1
    Note:   If query.exe takes longer than 15 seconds to return, an error is thrown and the next computername is processed.  Suppress this with -erroraction silentlycontinue
    Note:   If $sessions is empty, we return a warning saying no users.  Suppress this with -warningaction silentlycontinue

.PARAMETER computername
    Name of computer(s) to run session query against
              
.parameter parseIdleTime
    Parse idle time into a timespan object

.parameter timeout
    Seconds to wait before ending query.exe process.  Helpful in situations where query.exe hangs due to the state of the remote system.
                    
.FUNCTIONALITY
    Computers

.EXAMPLE
    Get-usersession -computername "server1"

    Query all current user sessions on 'server1'

.EXAMPLE
    Get-UserSession -computername $servers -parseIdleTime | ?{$_.idletime -gt [timespan]"1:00"} | ft -AutoSize

    Query all servers in the array $servers, parse idle time, check for idle time greater than 1 hour.

.NOTES
    Thanks to Boe Prox for the ideas - http://learn-powershell.net/2010/11/01/quick-hit-find-currently-logged-on-users/

.LINK
    http://gallery.technet.microsoft.com/Get-UserSessions-Parse-b4c97837

#&gt; 
    [cmdletbinding()]
    Param(
        [Parameter(
            Position = 0,
            ValueFromPipeline = $True)]
        [string[]]$ComputerName = "localhost",

        [switch]$ParseIdleTime,

        [validaterange(0,120)]
        [int]$Timeout = 15
    )             
    Process
    {
        ForEach($computer in $ComputerName)
        {
        
            #start query.exe using .net and cmd /c.  We do this to avoid cases where query.exe hangs

                #build temp file to store results.  Loop until we see the file
                    Try
                    {
                        $Started = Get-Date
                        $tempFile = [System.IO.Path]::GetTempFileName()
                        
                        Do{
                            start-sleep -Milliseconds 300
                            
                            if( ((Get-Date) - $Started).totalseconds -gt 10)
                            {
                                Throw "Timed out waiting for temp file '$TempFile'"
                            }
                        }
                        Until(Test-Path -Path $tempfile)
                    }
                    Catch
                    {
                        Write-Error "Error for '$Computer': $_"
                        Continue
                    }

                #Record date.  Start process to run query in cmd.  I use starttime independently of process starttime due to a few issues we ran into
                    $Started = Get-Date
                    $p = Start-Process -FilePath C:\windows\system32\cmd.exe -ArgumentList "/c query user /server:$computer &gt; $tempfile" -WindowStyle hidden -passthru

                #we can't read in info or else it will freeze.  We cant run waitforexit until we read the standard output, or we run into issues...
                #handle timeouts on our own by watching hasexited
                    $stopprocessing = $false
                    do
                    {
                    
                        #check if process has exited
                            $hasExited = $p.HasExited
                
                        #check if there is still a record of the process
                            Try
                            {
                                $proc = Get-Process -id $p.id -ErrorAction stop
                            }
                            Catch
                            {
                                $proc = $null
                            }

                        #sleep a bit
                            start-sleep -seconds .5

                        #If we timed out and the process has not exited, kill the process
                            if( ( (Get-Date) - $Started ).totalseconds -gt $timeout -and -not $hasExited -and $proc)
                            {
                                $p.kill()
                                $stopprocessing = $true
                                Remove-Item $tempfile -force
                                Write-Error "$computer`: Query.exe took longer than $timeout seconds to execute"
                            }
                    }
                    until($hasexited -or $stopProcessing -or -not $proc)
                    
                    if($stopprocessing)
                    {
                        Continue
                    }

                    #if we are still processing, read the output!
                        try
                        {
                            $sessions = Get-Content $tempfile -ErrorAction stop
                            Remove-Item $tempfile -force
                        }
                        catch
                        {
                            Write-Error "Could not process results for '$computer' in '$tempfile': $_"
                            continue
                        }
        
            #handle no results
            if($sessions){

                1..($sessions.count - 1) | Foreach-Object {
            
                    #Start to build the custom object
                    $temp = "" | Select ComputerName, Username, SessionName, Id, State, IdleTime, LogonTime
                    $temp.ComputerName = $computer

                    #The output of query.exe is dynamic. 
                    #strings should be 82 chars by default, but could reach higher depending on idle time.
                    #we use arrays to handle the latter.

                    if($sessions[$_].length -gt 5){
                        
                        #if the length is normal, parse substrings
                        if($sessions[$_].length -le 82){
                           
                            $temp.Username = $sessions[$_].Substring(1,22).trim()
                            $temp.SessionName = $sessions[$_].Substring(23,19).trim()
                            $temp.Id = $sessions[$_].Substring(42,4).trim()
                            $temp.State = $sessions[$_].Substring(46,8).trim()
                            $temp.IdleTime = $sessions[$_].Substring(54,11).trim()
                            $logonTimeLength = $sessions[$_].length - 65
                            try{
                                $temp.LogonTime = Get-Date $sessions[$_].Substring(65,$logonTimeLength).trim() -ErrorAction stop
                            }
                            catch{
                                #Cleaning up code, investigate reason behind this.  Long way of saying $null....
                                $temp.LogonTime = $sessions[$_].Substring(65,$logonTimeLength).trim() | Out-Null
                            }

                        }
                        
                        #Otherwise, create array and parse
                        else{                                       
                            $array = $sessions[$_] -replace "\s+", " " -split " "
                            $temp.Username = $array[1]
                
                            #in some cases the array will be missing the session name.  array indices change
                            if($array.count -lt 9){
                                $temp.SessionName = ""
                                $temp.Id = $array[2]
                                $temp.State = $array[3]
                                $temp.IdleTime = $array[4]
                                try
                                {
                                    $temp.LogonTime = Get-Date $($array[5] + " " + $array[6] + " " + $array[7]) -ErrorAction stop
                                }
                                catch
                                {
                                    $temp.LogonTime = ($array[5] + " " + $array[6] + " " + $array[7]).trim()
                                }
                            }
                            else{
                                $temp.SessionName = $array[2]
                                $temp.Id = $array[3]
                                $temp.State = $array[4]
                                $temp.IdleTime = $array[5]
                                try
                                {
                                    $temp.LogonTime = Get-Date $($array[6] + " " + $array[7] + " " + $array[8]) -ErrorAction stop
                                }
                                catch
                                {
                                    $temp.LogonTime = ($array[6] + " " + $array[7] + " " + $array[8]).trim()
                                }
                            }
                        }

                        #if specified, parse idle time to timespan
                        if($parseIdleTime){
                            $string = $temp.idletime
                
                            #quick function to handle minutes or hours:minutes
                            function Convert-ShortIdle {
                                param($string)
                                if($string -match "\:"){
                                    [timespan]$string
                                }
                                else{
                                    New-TimeSpan -Minutes $string
                                }
                            }
                
                            #to the left of + is days
                            if($string -match "\+"){
                                $days = New-TimeSpan -days ($string -split "\+")[0]
                                $hourMin = Convert-ShortIdle ($string -split "\+")[1]
                                $temp.idletime = $days + $hourMin
                            }
                            #. means less than a minute
                            elseif($string -like "." -or $string -like "none"){
                                $temp.idletime = [timespan]"0:00"
                            }
                            #hours and minutes
                            else{
                                $temp.idletime = Convert-ShortIdle $string
                            }
                        }
                
                        #Output the result
                        $temp
                    }
                }
            }            
            else
            {
                Write-Warning "'$computer': No sessions found"
            }
        }
    }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>How_To_from_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>How_To_from_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;#'-----------------------------------------------------------------------------
  Beginning PowerShell Scripting for Developers
  Simple script that will just 'Do Something'

  Author: Robert C. Cain | @ArcaneCode | arcanecode@gmail.com
          http://arcanecode.com
 
  This module is Copyright (c) 2015 Robert C. Cain. All rights reserved.
  The code herein is for demonstration purposes. No warranty or guarentee
  is implied or expressly granted. 
  This module may not be reproduced in whole or in part without the express
  written consent of the author. 
-----------------------------------------------------------------------------#&gt;


#'-----------------------------------------------------------------------------#'
#' A few definitions, the "remote" computer is the machine you want to remote
#' control from PowerShell. The "local" computer is the one you are using,
#' i.e. running PowerShell on. 
#'-----------------------------------------------------------------------------#'

#' First, you will need to enable remoting on the computer you want to control
#' ON the REMOTE COMPUTER, enter the command below. (-Force will run without
#' prompts)

Enable-PSRemoting -Force

#' If you are NOT running on a domain, for example doing this on a home
#' network, you will need to do a few other things. 
#' On both the remote computer and the local computer, run:
#' This tells it to trust ALL hosts (!!!!)

Set-Item wsman:\localhost\client\trustedhosts *

#' Instead of an *, you could specify the IP Addresses of the machines. 

#' You will then need to restart the Windows Remote Management service
#' on both computers.
Restart-Service WinRM

#' On the LOCAL computer you are using, you can test by using Test-WSMan
#' followed by the name of the remote computer. 
#' wsman
Test-WSMan ACSrv

#' Now execute a command on the remote system
#' The Script block could be stored in a variable
Invoke-Command -ComputerName BCC-EXPLORER3DB `
               -ScriptBlock { Get-ChildItem C:\ } `
               -Credential glenng
#' It immediately challenges me for my password, then it runs successfully


#' You can also open up a PowerShell window which will execute
#' on the remote computer
Enter-PSSession -ComputerName BCC-EXPLORER3 -Credential glenng

#' Now the console screen shows that it is actually on the remote server:
#' [BCC-EXPLORER3]: PS C:\Users\glenng\Documents&gt; 

#' To exit the remote server in the console window:
exit   'OR &gt; Exit-PSSession

#' In the PowerShell ISE there is an icon in the menu bar to launch a remote session
#' It will ask for the computer and my UserID, then challenge me for the password.
#' When it succeeds it will open a new tab in the ISE that is on the remote computer


#'-----------------------------------------------------------------------------#'
#' Fix for network connection profile public {this was not a problem for me at BCC}
#'-----------------------------------------------------------------------------#'
Get-NetConnectionProfile           #' I think this is not available in Windows 7

#' Temporarily Set to Private
Set-NetConnectionProfile `
  -InterfaceAlias 'vEthernet (HWired)' `
  -NetworkCategory Private

Set-NetConnectionProfile `
  -InterfaceAlias 'vEthernet (Internal Ethernet Port Windows Phone Emulator Internal Switch)' `
  -NetworkCategory Private


#' Put them back
Set-NetConnectionProfile `
  -InterfaceAlias 'vEthernet (HWired)' `
  -NetworkCategory Public

Set-NetConnectionProfile `
  -InterfaceAlias 'vEthernet (Internal Ethernet Port Windows Phone Emulator Internal Switch)' `
  -NetworkCategory Public
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PSPASSWD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PSPASSWD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Usage for local accounts:
  pspasswd [\\[computer[,computer,[,...]]|@file] [-u Username [-p Password]]] &lt;Account&gt; [NewPassword]
Usage for domain accounts:
  pspasswd &lt;Domain\Account&gt; [NewPassword]

     computer    Computer or computers on which the local account exists. If
                 you omit the computer name, the local computer is assumed.
                 If you specify a wildcard (\\*), PsPasswd runs the
                 command on all computers in the current domain or workgroup.
     @file       PsPasswd will change the password on the computers listed
                 in the file.
     -u          Specifies optional user name for login to remote computer.
     -p          Specifies optional password for user name. If you omit this
                 you will be prompted to enter a hidden password.
     -nobanner   Do not display the startup banner and copyright message.
     Domain      Specifies name of the domain of the target account.
     Account     Specifies name of the account for password change.
     NewPassword New password. If omitted a NULL password is applied.


'For a single computer:
pspasswd \\computer_name Local_administrator_account_name New_Password 

'For multiple computers:
pspasswd \\computer1_name,computer2_name,computer3_name Local_administrator_account_name New_Password 

'For all computers in the environment:
pspasswd \\* Local_administrator_account_name New_Password 

'For multiple computers using a text file containing the computer names:
pspasswd \\@file.txt Local_administrator_account_name New_Password

'Just to clarify the Sysinternal Tools attempt to use your current user profiles credentials 
'	to authenticate against the other Machines / Domain. 
'	If you are running as an admin you are fine.

'If however you are using a limited account when you open the tool 
'	you will need to specify a username and a password using the "-u" and "-p" switches. 
'	Using these DOES transmit your username and password in plain text.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>TEST_Remote_Registry</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>TEST_Remote_Registry</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://filedb.experts-exchange.com/incoming/2015/11_w47/1030521/get-officeversion.ps1..txt
=============================================================================================
#'USAGE
$testcomputers = "LT-1039"
#'$exportLocation = 'C:\OfficeVersions.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\ONE_Computer_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\ONE_Computer_DidNotPing.txt
		}
	}

 get-officeversion -infile C:\ONE_Computer_RespondToPing.txt -outfile C:\ONE_Computer_officeversions.csv


Get-Content C:\ONE_Computer_officeversions.csv


=============================================================================================
&lt;#
.Synopsis
   Get-OfficeVersion 
.DESCRIPTION
   Gets the Office version from a list of computernames and returns a CSV of the Computername and Office Version (if available)
.EXAMPLE
 get-officeversion c:\test\servers.txt c:\test\officeversions.csv
.EXAMPLE
 get-officeversion -infile c:\test\servers.txt -outfile c:\test\officeversions.csv
.NOTES
   General notes
.PARAMETER infile
A path and a filename to a text file contains a list of the computernames or ip addresses to check the office version.
.PARAMETER Outfile
A path and filename of the output .csv file

#&gt;
function Get-OfficeVersion
{
param(
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $Infile,
    
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $outfile
    )
#$outfile = 'C:\temp\office.csv'
#$infile = 'c:\temp\servers.txt'
Begin
    {
    }
 Process
    {
    $office = @()
    $computers = Get-Content $infile
    $i=0
    $count = $computers.count
    foreach($computer in $computers)
     {
     $i++
     Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
      -PercentComplete ($i/$count*100)
        $info = @{}
        $version = 0
        try{
          $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $computer) 
          $reg.OpenSubKey('software\Microsoft\Office').GetSubKeyNames() |% {
            if ($_ -match '(\d+)\.') {
              if ([int]$matches[1] -gt $version) {
                $version = $matches[1]
              }
            }    
          }
          if ($version) {
            Write-Debug("$computer : found $version")
            switch($version) {
                "7" {$officename = 'Office 97' }
                "8" {$officename = 'Office 98' }
                "9" {$officename = 'Office 2000' }
                "10" {$officename = 'Office XP' }
                "11" {$officename = 'Office 97' }
                "12" {$officename = 'Office 2003' }
                "13" {$officename = 'Office 2007' }
                "14" {$officename = 'Office 2010' }
                "15" {$officename = 'Office 2013' }
                "16" {$officename = 'Office 2016' }
                default {$officename = 'Unknown Version'}
            }
    
          }
          }
          catch{
              $officename = 'Not Installed/Not Available/Not Answering'
          }
    $info.Computer = $computer
    $info.Name= $officename
    $info.version =  $version

    $object = new-object -TypeName PSObject -Property $info
    $office += $object
    }
    $office | select computer,version,name | Export-Csv -NoTypeInformation -Path $outfile
    }
}
  write-output ("Done")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ScheduledTask</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>TaskSchedular_command</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ScheduledTask</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>TaskSchedular_command</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'Instead of only using the path to your script in the task scheduler 
'	you should start Powershell with your script in the task scheduler, e.g.

C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe -NoLogo -NonInteractive -File "C:\Path\To\Your\PS1File.ps1"

C:\WINDOWS\SysWOW64\WindowsPowerShell\v1.0\powershell.exe
C:\WINDOWS\SysWOW64\WindowsPowerShell\v1.0\powershell.exe -NoLogo -ExecutionPolicy Bypass -NonInteractive -File C:\DATA\PowerShellScript_LOGS\Kill_All_User_Sessions.ps1
=========================================================================================================================
'set the execution policy of a specific invocation of PowerShell. This is what I usually do when executing PowerShell through a scheduled task:

powershell.exe -NoProfile -NoLogo -NonInteractive -ExecutionPolicy Bypass -File \\path\to\script.ps1


-NoProfile
'This ensures that you don't rely on anything in the user's PowerShell profile, and avoids the overhead of executing that additional code.

-NoLogo
'This mostly doesn't matter; maybe it does if you're capturing the output of your script. Mostly it makes me feel better.

-NonInteractive
'Ensures that your task won't wait indefinitely if something in your script unexpectedly prompts the user. 
'With this switch, the script will just exit instead; at least you'll have an error code instead of a hanging script.

-ExecutionPolicy Bypass
'You can use Unrestricted here or whichever execution policy you like. 
'This is probably the one you need the most.
=========================================================================================================================
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Server</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>monitor_a_server_SHUTDOWN_and_RESTART</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Server</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>monitor_a_server_SHUTDOWN_and_RESTART</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>monitor_a_server_SHUTDOWN_and_RESTART
http://techibee.com/powershell/power-ping-a-script-to-monitor-your-server-restart/706
===================================USAGE
#'save this into restart-monitor.ps1 and excute it from powershell window
&gt;.Restart-Monitor.ps1 -computer server1 -timeout 10
====================================

Param (            
 [Parameter(ValueFromPipeline=$False,Mandatory=$True)]            
 [string]$computer,            
 [Parameter(ValueFromPipeline=$False,Mandatory=$False)]            
 [int]$timeout=5            
)            
            
$MAX_PINGTIME = $timeout * 60            
$max_iterations = $MAX_PINGTIME/5            
$Notification_timeout = 10 # in seconds            
            
function Show-notification {            
            
param($type,$text,$title)            
            
#load Windows Forms and drawing assemblies            
[reflection.assembly]::loadwithpartialname("System.Windows.Forms") | Out-Null
[reflection.assembly]::loadwithpartialname("System.Drawing") | Out-Null            
#define an icon image pulled from PowerShell.exe            
$icon=[system.drawing.icon]::ExtractAssociatedIcon((join-path $pshome powershell.exe))            
$notify = new-object system.windows.forms.notifyicon            
$notify.icon = $icon            
$notify.visible = $True            
#define the tool tip icon based on the message type            
switch ($messagetype) {            
 "Error" { $messageIcon=[system.windows.forms.tooltipicon]::Error}            
 "Info" {$messageIcon=[system.windows.forms.tooltipicon]::Info}            
 "Warning" {$messageIcon=[system.windows.forms.tooltipicon]::Warning}            
 Default {$messageIcon=[system.windows.forms.tooltipicon]::None}            
}            
            
#display the balloon tipe            
$notify.showballoontip($Notification_timeout,$title,$text,$type)            
}            
            
function ping-host {            
param($pc)            
$status = Get-WmiObject -Class Win32_PingStatus -Filter "Address='$pc'"            
if( $status.statuscode -eq 0) {            
   return 1            
} else {            
 return 0            
}            
}            
            
if(ping-host -pc $computer) {            
 Write-Host "$computer is online; Waiting for it to go offline"            
 $status = "online"            
 for ($i=0; $i -le $max_iterations; $i++) {            
  if (!(ping-host -pc $computer )) {            
   break            
  }            
  Start-Sleep -Seconds 5            
  if($i -eq $max_iterations) {            
   Write-Host "$computer never went down in last $timeout minutes"            
   Write-Host "Check that reboot is initiated properly"            
   show-notification -type "error" -text "$computer is still ONLINE; Check that reboot is initiated properly" -title "Computer is not rebooting"            
   exit            
  }            
    }            
            
    Write-Host "$computer is offline now; monitoring for online status"            
            
} else {            
    Write-Host "$computer is offline; Monitoring for online status"            
    $status = "offline"            
}            
            
for ($i=0; $i -le $max_iterations; $i++) {            
 if ((ping-host -pc $computer )) {            
  break            
 }            
            
 Start-Sleep -Seconds 5            
 if($i -eq $max_iterations) {            
  Write-Host "Your computer never came back online in last $MAX_PINGTIME seconds"            
  Write-Host "Check that nothing is preventing starup"            
  show-notification -type "error" -text "$Computer is NOT coming online; Something is preventing its startup" -title "Computer failed to start"            
  exit            
 }            
}            
            
Write-Host "Your computer is Online Now; Task done; exiting"            
show-notification -type "info" -text "$Computer is online" -title "$Computer successfully restarted"</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Setup_My_Profile_on_New_Machine</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>05_PowerShellISEModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Setup_My_Profile_on_New_Machine</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>05_PowerShellISEModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

#'-------------------------------------------------------Drives for Powershell
New-PSDrive Name W PSProvider FileSystem Root "\\win10vm\ALL_Share" Persist
New-PSDrive Name J PSProvider FileSystem Root "\\jphsa.org\shared\Users\ggarson" Persist
#'-------------------------------------------------------

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

Function gig-commentIt
{
 &lt;#
   .Synopsis
    This function will add a remark #' character to beginning of line
   .Description
    This function will add a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to comment out
    a section of PowerShell code. 
   .Example
    Add-RemarkedText
    adds the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ("#'" + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-commentIt

Function gig-unCommentIt
{
 &lt;#
   .Synopsis
    This function will remove a remark #' character to beginning of line
   .Description
    This function will remove a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to clean up a 
    previously commentted out section of PowerShell code. 
   .Example
    gig-unCommentIt
    Removes the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($l -replace "#'",''),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-unCommentIt


Function gig-editProfile
{

 psedit $profile

 #'ISE $profile

} #'end function gig-editProfile

Function gig-addHelp
{
  &lt;#
   .Synopsis
    This function adds help at current insertion point 
   .Example
    add-help
    adds comment based help at current insertion point 
   .Notes
    NAME:  Add-Help
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016
    HSG: WES-09-11-10
    KEYWORDS: Scripting Techniques, Windows PowerShell ISE
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $helpText = @"
 &lt;#
   .Synopsis
    This does that 
   .Description
    This function does
   .Example
    Example-
    Example- accomplishes 
   .Parameter 
    The parameter
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS:
    HSG: 
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
"@
 $psise.CurrentFile.Editor.InsertText($helpText)
} #'end function gig-addHelp

Function gig-addHeaderToScript
{
  &lt;#
   .Synopsis
    This function adds header information to a script 
   .Example
    Add-HeaderToScript
    Adds header comments to script 
   .Example 
    AH
    Uses alias to add header comments to script
   .Notes
    NAME:  Add-HeaderToScript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS: $keyword
    HSG: $hsg
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($keyword, $comment, $hsg)
 $header = @"
#' -----------------------------------------------------------------------------
#' Script: $(split-path -Path $psISE.CurrentFile.FullPath -Leaf)
#' Author: glenn garson, JPHSA
#' Date: $(Get-Date)
#' Keywords: $keyword
#' comments: $comment
#'
#' -----------------------------------------------------------------------------
"@
 $psise.CurrentFile.Editor.InsertText($header)
} #'end function gig-addHeaderToScript

Function gig-getLogNameFromDate
{
  &lt;#
   .Synopsis
    Creates a log name from date
   .Description
    This script creates a log from a date. 
   .Example
    gig-getLogNameFromDate -path "c:\jumk" -name "log"
    Creates a file name like c:\JUNK\log20100914-122019.Txt but does not
    create the file. It returns the file name to calling code.
   .Example
    gig-getLogNameFromDate -path "c:\JUNK" -name "log" -Create
    Creates a file name like c:\JUNK\log20100914-122019.Txt and
    create the file. It returns the file name to calling code.
   .Parameter path
    path to log file
   .Parameter name
    base name of log file
   .Parameter create
    switch that determines whether log file or only name is created
   .inputs
    [string]
   .outputs
    [string]
   .Notes
    NAME:  gig-getLogNameFromDate
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 16:58:06
    KEYWORDS: parameter substitution, format specifier, string substitution
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param(
  [string]$path = "c:\JUNKC:\DATA\junkPowerShellTranscripts",
  [string]$name = "log",
  [switch]$Create
 )
 $logname = "{0}\{1}{2}.{3}" -f $path,$name, `
    (Get-Date -Format yyyyMMdd-HHmmss),"Txt"
 if($create) 
  { 
   New-Item -Path $logname -ItemType file -force | out-null
   $logname
  }
 else {$logname}
} #' end function gig-getLogNameFromDate

Function gig-start_ISE_Transcript
{
  &lt;#
   .Synopsis
    This captures output from a script to a created text file
    To use the gig-start_ISE_Transcript function, add the call to the function at the bottom of your script.
   .Example

    xxxxx...{your script}
    gig-start_ISE_Transcript -logname "c:\junk\log.txt"

    Copies output from script to file named xxxxlog.txt in c:\junk folder
   .Parameter logname
    the name and path of the log file.
   .inputs
    [string]
   .outputs
    [io.file]
   .Notes
    NAME:  gig-start_ISE_Transcript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 17:27:22
    KEYWORDS:
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
  Param(
   [string]$logname = (gig-getLogNameFromDate -path $transcriptHome -name "log" -Create)
  )
  $transcriptHeader = @"
**************************************
Windows PowerShell ISE Transcript Start
Start Time: $(get-date)
UserName: $env:username
UserDomain: $env:USERDNSDOMAIN
ComputerName: $env:COMPUTERNAME
Windows version: $((Get-WmiObject win32_operatingsystem).version)
**************************************
Transcript started. Output file is $logname
"@
 $transcriptHeader &gt;&gt; $logname
 $psISE.CurrentPowerShellTab.ConsolePane.Text &gt;&gt; $logname
 Log saved to $logname
} #'end function gig-start_ISE_Transcript

function gig-indentText_x_spaces
{
  &lt;#
   .Synopsis
    This function will indent text in the ISE a specific number
   .Description
    This function will indent selected text in the PowerShell ISE. These are
    real spaces, not tabs. Therefore this is appropriate for situations where
    an actual tab "`t" will not work. 
   .Example
    gig-indentText_x_spaces -space 5
    moves selected text five spaces 
   .Parameter spaces
    The number of spaces to indent the selected text. Note this number cannot
    be a negative number, and this function does not "unindent" the selected text.
   .Notes
    NAME:  gig-indentText_x_spaces
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 06/11/2012 17:16:29
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-6-17-12
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param([int]$space = 1)
 $tab = " " * $space
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($tab + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'end function gig-indentText_x_spaces

Function gig-editModule
{
  &lt;#
   .Synopsis
    This opens a module stored in the $env:PSModulePath location on a new tab in ISE 
   .Description
    This function uses Get-Module to retrieve a module from $env:PSModulePath and then
    it opens the module from that location into a new tab in ISE for editing. Wildcard
    characters that resolve to a single module are supported.
   .Example
    gig-editModule PowerShellISEModule
    gig-editModule PowerShellISEModule opens the PowerShellISEModule into a new tab in the
    ISE for editing 
  .Example
    gig-editModule PowerShellISE*
    gig-editModule PowerShellISE* opens the PowerShellISEModule into a new tab in the
    ISE for editing by using a wild card character for the module name
   .Parameter Name
    The name of the module. Wild cards that resolve to a single module are supported
   .Notes
    NAME:  gig-editModule
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 18:14:19
    KEYWORDS: Scripting Techniques, Modules
    HSG: WES-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($name)
 ISE (Get-Module -ListAvailable $name).path
} #'end function gig-editModule

Function gig-toggleOutlineView
{
  &lt;#
   .Synopsis
    This function toggles the outline view in the ISE 
   .Description
    This function toggles the outline view in the ISE. It will expand 
    or collapse all functions in the current script pane.
   .Example
    gig-toggleOutlineView
    gig-toggleOutlineView will either expand or collapse all functions 
   .Notes
    NAME:  gig-toggleOutlineView
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 19:28:37
    KEYWORDS: Scripting Techniques, Modules
    HSG: wes-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 3.0
 #&gt;
 $psise.CurrentFile.Editor.ToggleOutliningExpansion()
} #'end function gig-toggleOutlineView


#'added Functions from New-ModulesDrive.ps1
#' HSG-1-20-10
Function gig-newModuleDrives
{
&lt;#
    .SYNOPSIS
    Creates two PSDrives: myMods and sysMods
    .EXAMPLE
    gig-newModuleDrives
    Creates two PSDrives: myMods and sysMods. These correspond 
    to the users' modules folder and the system modules folder respectively. 
#&gt;
 $driveNames = "myMods","sysMods"

 For($i = 0 ; $i -le 1 ; $i++)
 {
  New-PsDrive -name $driveNames[$i] -PSProvider filesystem `
  -Root ($env:PSModulePath.split(";")[$i]) -scope Global |
  Out-Null
 } #'end For
} #'end gig-newModuleDrives

Function gig-getFileSystemDrives
{
&lt;#
    .SYNOPSIS
    Displays global PS Drives that use the Filesystem provider
    .EXAMPLE
    gig-getFileSystemDrives
    Displays global PS Drives that use the Filesystem provider
#&gt;
 Get-PSDrive -PSProvider FileSystem -scope Global
} #'end gig-getFileSystemDrives

Function gig-OpenPath
{
 &lt;#
   .Synopsis
    Opens a path in Explorer 
   .Description
    Opens a path in Explorer, default path is C:\, or the first parameter is the path
   .Example
    gig-OpenPath C:\Junk
    gig-OpenPath $moduleHome 
   .Parameter Path
    The path to open in Explorer
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/26/2016 17:31:28
    KEYWORDS:
    HSG: 
   .Link
     
 #'Requires -Version 2.0
 #&gt;
  Param(
  [string]$path = "C:\"
 )
 Invoke-Item -Path $path
 }


 function gig-LoadNetworkPSDrives
{
#'    net use G: "\\Jphsa.org\shared\Data" 
#'    net use H: "\\Jphsa.org\shared\Users\ggarson\" 
#'    net use I: "\\Jphsa-ebhost2\AnasaziFiles\" 
#'    net use M: "\\Jphsa.org\shared\Data\MIS\" 
#'    net use N: "\\Jphsa-ebfile01\e$\" 
#'    net use P: "\\Jphsa.org\shared\Users\ggarson\PROJECTS"


    New-PSDrive -Name "D" -PSProvider "FileSystem" -Root "\\CBTBRFS02\Credit\Credit Risk\Month-End Reports V2\SQL Queries\" -scope Global
    New-PSDrive -Name "M" -PSProvider "FileSystem" -Root "\\CBTBRFS02\Accounting\Managerial Accounting\" -scope Global
    New-PSDrive -Name "N" -PSProvider "FileSystem" -Root "\\CBTBRFS02\Credit\Credit Risk\" -scope Global
    New-PSDrive -Name "P" -PSProvider "FileSystem" -Root "\\cbt.corp.com\cbt-dfs\MyDoc\gigarson\Documents\Data\Projects\" -scope Global
    New-PSDrive -Name "N" -PSProvider "FileSystem" -Root "\\cbt.corp.com\cbt-dfs\Accounting\Managerial Accounting\CRD Reports\" -scope Global
    New-PSDrive -Name "P" -PSProvider "FileSystem" -Root "\\cbt.corp.com\cbt-dfs\MyDoc\gigarson\Documents\"-scope Global


} 
 
#' *** Alias ***
#'if(!(Test-Path alias:ah))
#' {
#'  New-Alias -Name ah -Value add-headertoscript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:abh))
#' {
#'  New-Alias -Name abh -Value Add-SBSBookHeaderToScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ahlp))
#' {
#'  New-Alias -Name ahlp -Value add-help -Description "MrEd alias" |
#'  Out-Null
#'  }
#'  if(!(Test-Path alias:ras))
#' {
#'  New-Alias -Name ras -Value Remove-AliasFromScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:gfsd))
#' {
#'  New-Alias -Name gfsd -Value gig-getFileSystemDrives -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:cs))
#' {
#'  New-Alias -Name cs -value Copy-ScriptToNewTab -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ar))
#' {
#'  New-Alias -Name ar -value Add-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:rr))
#' {
#'  New-Alias -Name rr -value Remove-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:em))
#' {
#'  New-Alias -Name em -value Edit-Module -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:iem))
#' {
#'  New-Alias -Name iem -value Import-EveryModule -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:sov))
#' {
#'  New-Alias -Name sov -value gig-toggleOutlineView -Description "MrEd alias" |
#'  Out-Null
#'  }



#' *** Variables ***
if(!(Test-Path variable:moduleHome))
{
 new-variable -name moduleHome -value "$env:userProfile\documents\WindowsPowerShell\Modules"
}
#'if(!(Test-Path variable:backupHome))
#'{
#' new-variable -name backupHome -value "$env:userProfile\documents\WindowsPowerShell\profileBackup"
#'}

if(!(Test-Path variable:TranscriptHome))
{
 new-variable -name TranscriptHome -value "C:\DATA\junkPowerShellTranscripts"
 #' new-variable -name TranscriptHome -value "$env:userProfile\documents\WindowsPowerShell\transcript"
}

if(!(Test-Path variable:myScripts))
{
 new-variable -name myScripts -value "C:\DATA\PowerShellScripts"
}

Set-Location $myScripts

Clear-Host

gig-LoadNetworkPSDrives

Export-ModuleMember -alias * -function * -variable *

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SSRS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>List_or_Delete_Datasources_With_No_Dependencies</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SSRS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>List_or_Delete_Datasources_With_No_Dependencies</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>    #************************************************************************************************************************************
# FileName:     Delete-DataSources.ps1
# Date:         2015/04/23
# Author:       Hugh Scott
#
# Description:
# This script finds data sources with no dependencies in SSRS and removes them.
#
# Parameters:
#   $serverBase     - base URL for the server to check (ie, myserver.mydomain.com)
#   [$WhatIf]       - Option wwitch parameter to prevent actual deleting of objects (will list out reports that need to be deleted)
#***********************************************************************************************************************************
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$true,Position=0)]
    [string]$serverBase,
    [Parameter(Mandatory=$false,Position=1)]
    [switch]$WhatIf
)

$url = "http://$serverBase/reportserver/ReportService2010.asmx?WSDL"
$ssrs = New-WebServiceProxy -uri $url -UseDefaultCredential -Namespace "ReportingWebService"

$outFile = ".\DeleteItems_$serverBase.txt"

# Connection to Web Service, grab all data sources
$items = $ssrs.ListChildren("/", $true) | where-object {$_.typename -eq "DataSource"}
foreach($item in $items) {

    $dependencies = $ssrs.ListDependentItems($item.Path)
    $dependentReports = $dependencies.Count

    if($dependencies.Count -eq 0){
        [string]$itemName = $item.Path
        if($WhatIf){

            Write-Host "Item $itemName would be deleted."
            Add-Content $outFile "Item $itemName would be deleted."
        } else {
            try {
                $ssrs.DeleteItem($item.Path)
                Write-Host "Item $itemName deleted."
                Add-Content $outFile "Deleted item $itemName ."
            } catch [System.Exception] {
                $Msg = $_.Exception.Message
                Write-Host $itemName $Msg
                Add-Content $itemName $msg
            }
        }
    }
}
shareeditflag</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_on_Client</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-ClientWSUSSetting.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_on_Client</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-ClientWSUSSetting.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get-ClientWSUSSetting.ps1
------------------------------


Function Get-ClientWSUSSetting {
    &lt;#  
    .SYNOPSIS  
        Retrieves the wsus client settings on a local or remove system.

    .DESCRIPTION
        Retrieves the wsus client settings on a local or remove system.
         
    .PARAMETER Computername
        Name of computer to connect to. Can be a collection of computers.

    .PARAMETER ShowEnvironment
        Display only the Environment settings.

    .PARAMETER ShowConfiguration
        Display only the Configuration settings.

    .NOTES  
        Name: Get-WSUSClient
        Author: Boe Prox
        DateCreated: 02DEC2011 
               
    .LINK  
        https://learn-powershell.net
        
    .EXAMPLE
    Get-ClientWSUSSetting -Computername TestServer
    
    RescheduleWaitTime            : NA
    AutoInstallMinorUpdates       : NA
    TargetGroupEnabled            : NA
    ScheduledInstallDay           : NA
    DetectionFrequencyEnabled     : 1
    WUServer                      : http://wsus.com
    Computername                  : TestServer
    RebootWarningTimeoutEnabled   : NA
    ElevateNonAdmins              : NA
    ScheduledInstallTime          : NA
    RebootRelaunchTimeout         : 10
    ScheduleInstallDay            : NA
    RescheduleWaitTimeEnabled     : NA
    DisableWindowsUpdateAccess    : NA
    AUOptions                     : 3
    DetectionFrequency            : 4
    RebootWarningTimeout          : NA
    ScheduleInstallTime           : NA
    WUStatusServer                : http://wsus.com
    TargetGroup                   : NA
    RebootRelaunchTimeoutEnabled  : 1
    UseWUServer                   : 1
    NoAutoRebootWithLoggedOnUsers : 1

    Description
    -----------
    Displays both Environment and Configuration settings for TestServer
    
    .EXAMPLE
    Get-ClientWSUSSetting -Computername Server1 -ShowEnvironment
    
    Computername               : Server1
    TargetGroupEnabled         : NA
    TargetGroup                : NA
    WUStatusServer             : http://wsus.com
    WUServer                   : http://wsus.com
    DisableWindowsUpdateAccess : 1
    ElevateNonAdmins           : 0
    
    Description
    -----------
    Displays the Environment settings for Server1
    
    .Example
    Get-ClientWSUSSetting -Computername Server1 -ShowConfiguration
    
    ScheduledInstallTime          : NA
    AutoInstallMinorUpdates       : 0
    ScheduledInstallDay           : NA
    Computername                  : Server1
    RebootWarningTimeoutEnabled   : NA
    RebootWarningTimeout          : NA
    NoAUAsDefaultShutdownOption   : NA
    RebootRelaunchTimeout         : NA
    DetectionFrequency            : 4
    ScheduleInstallDay            : NA
    RescheduleWaitTime            : NA
    RescheduleWaitTimeEnabled     : 0
    AUOptions                     : 3
    NoAutoRebootWithLoggedOnUsers : 1
    DetectionFrequencyEnabled     : 1
    ScheduleInstallTime           : NA
    NoAUShutdownOption            : NA
    RebootRelaunchTimeoutEnabled  : NA
    UseWUServer                   : 1
    IncludeRecommendedUpdates     : NA  
    
    Description
    -----------
    Displays the Configuration settings for Server1
    #&gt;
    [cmdletbinding()]
    Param (
        [parameter(ValueFromPipeLine = $True)]
        [string[]]$Computername = $Env:Computername,
        [parameter()]
        [switch]$ShowEnvironment,
        [parameter()]
        [switch]$ShowConfiguration        
    )
    Begin {
        $EnvKeys = "WUServer","WUStatusServer","ElevateNonAdmins","TargetGroupEnabled","TargetGroup","DisableWindowsUpdateAccess"
        $ConfigKeys = "AUOptions","AutoInstallMinorUpdates","DetectionFrequency","DetectionFrequencyEnabled","NoAutoRebootWithLoggedOnUsers",
        "NoAutoUpdate","RebootRelaunchTimeout","RebootRelaunchTimeoutEnabled","RebootWarningTimeout","RebootWarningTimeoutEnabled","RescheduleWaitTime","RescheduleWaitTimeEnabled",
        "ScheduleInstallDay","ScheduleInstallTime","UseWUServer"
    }
    Process {
        $PSBoundParameters.GetEnumerator() | ForEach {
            Write-Verbose ("{0}" -f $_)
        }
        ForEach ($Computer in $Computername) {
                If (Test-Connection -ComputerName $Computer -Count 1 -Quiet) {
                $WSUSEnvhash = @{}
                $WSUSConfigHash = @{}
                $ServerReg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey("LocalMachine",$Computer)
                #Get WSUS Client Environment Options
                $WSUSEnv = $ServerReg.OpenSubKey('Software\Policies\Microsoft\Windows\WindowsUpdate')
                $subkeys = @($WSUSEnv.GetValueNames())
                $NoData = @(Compare-Object -ReferenceObject $EnvKeys -DifferenceObject $subkeys | Select -ExpandProperty InputObject)
                ForEach ($item in $NoData) {
                    $WSUSEnvhash[$item] = 'NA'
                }
                $Data = @(Compare-Object -ReferenceObject $EnvKeys -DifferenceObject $subkeys -IncludeEqual -ExcludeDifferent | Select -ExpandProperty InputObject)
                ForEach ($key in $Data) {
                    If ($key -eq 'WUServer') {
                        $WSUSEnvhash['WUServer'] = $WSUSEnv.GetValue('WUServer')
                    }
                    If ($key -eq 'WUStatusServer') {
                        $WSUSEnvhash['WUStatusServer'] = $WSUSEnv.GetValue('WUStatusServer')
                    }
                    If ($key -eq 'ElevateNonAdmins') {
                        $WSUSEnvhash['ElevateNonAdmins'] = $WSUSEnv.GetValue('ElevateNonAdmins')
                    }
                    If ($key -eq 'TargetGroupEnabled') {
                        $WSUSEnvhash['TargetGroupEnabled'] = $WSUSEnv.GetValue('TargetGroupEnabled')
                    }
                    If ($key -eq 'TargetGroup') {
                        $WSUSEnvhash['TargetGroup'] = $WSUSEnv.GetValue('TargetGroup')
                    }  
                    If ($key -eq 'DisableWindowsUpdateAccess') {
                        $WSUSEnvhash['DisableWindowsUpdateAccess'] = $WSUSEnv.GetValue('DisableWindowsUpdateAccess')
                    }              
                }
                #Get WSUS Client Configuration Options
                $WSUSConfig = $ServerReg.OpenSubKey('Software\Policies\Microsoft\Windows\WindowsUpdate\AU')
                $subkeys = @($WSUSConfig.GetValueNames())
                $NoData = @(Compare-Object -ReferenceObject $ConfigKeys -DifferenceObject $subkeys | Select -ExpandProperty InputObject)
                ForEach ($item in $NoData) {
                    $WSUSConfighash[$item] = 'NA'
                }            
                $Data = @(Compare-Object -ReferenceObject $ConfigKeys -DifferenceObject $subkeys -IncludeEqual -ExcludeDifferent | Select -ExpandProperty InputObject)
                ForEach ($key in $Data) {
                    If ($key -eq 'AUOptions') {
                        $WSUSConfighash['AUOptions'] = $WSUSConfig.GetValue('AUOptions')
                    }
                    If ($key -eq 'AutoInstallMinorUpdates') {
                        $WSUSConfighash['AutoInstallMinorUpdates'] = $WSUSConfig.GetValue('AutoInstallMinorUpdates')
                    }
                    If ($key -eq 'DetectionFrequency') {
                        $WSUSConfighash['DetectionFrequency'] = $WSUSConfig.GetValue('DetectionFrequency')
                    }
                    If ($key -eq 'DetectionFrequencyEnabled') {
                        $WSUSConfighash['DetectionFrequencyEnabled'] = $WSUSConfig.GetValue('DetectionFrequencyEnabled')
                    }
                    If ($key -eq 'NoAutoRebootWithLoggedOnUsers') {
                        $WSUSConfighash['NoAutoRebootWithLoggedOnUsers'] = $WSUSConfig.GetValue('NoAutoRebootWithLoggedOnUsers')
                    }
                    If ($key -eq 'RebootRelaunchTimeout') {
                        $WSUSConfighash['RebootRelaunchTimeout'] = $WSUSConfig.GetValue('RebootRelaunchTimeout')
                    }
                    If ($key -eq 'RebootRelaunchTimeoutEnabled') {
                        $WSUSConfighash['RebootRelaunchTimeoutEnabled'] = $WSUSConfig.GetValue('RebootRelaunchTimeoutEnabled')
                    }
                    If ($key -eq 'RebootWarningTimeout') {
                        $WSUSConfighash['RebootWarningTimeout'] = $WSUSConfig.GetValue('RebootWarningTimeout')
                    }
                    If ($key -eq 'RebootWarningTimeoutEnabled') {
                        $WSUSConfighash['RebootWarningTimeoutEnabled'] = $WSUSConfig.GetValue('RebootWarningTimeoutEnabled')
                    }
                    If ($key -eq 'RescheduleWaitTime') {
                        $WSUSConfighash['RescheduleWaitTime'] = $WSUSConfig.GetValue('RescheduleWaitTime')
                    }                                                                                                            
                    If ($key -eq 'RescheduleWaitTimeEnabled') {
                        $WSUSConfighash['RescheduleWaitTimeEnabled'] = $WSUSConfig.GetValue('RescheduleWaitTimeEnabled')
                    }  
                    If ($key -eq 'ScheduleInstallDay') {
                        $WSUSConfighash['ScheduleInstallDay'] = $WSUSConfig.GetValue('ScheduleInstallDay')
                    }  
                    If ($key -eq 'ScheduleInstallTime') {
                        $WSUSConfighash['ScheduleInstallTime'] = $WSUSConfig.GetValue('ScheduleInstallTime')
                    }  
                    If ($key -eq 'UseWUServer') {
                        $WSUSConfighash['UseWUServer'] = $WSUSConfig.GetValue('UseWUServer')
                    }                                          
                }
                
                #Display Output
                If ((-Not ($PSBoundParameters['ShowEnvironment'] -OR $PSBoundParameters['ShowConfiguration'])) -OR `
                ($PSBoundParameters['ShowEnvironment'] -AND $PSBoundParameters['ShowConfiguration'])) {
                    Write-Verbose "Displaying everything"
                    $WSUSHash = ($WSUSEnvHash + $WSUSConfigHash)
                    $WSUSHash['Computername'] = $Computer
                    New-Object PSObject -Property $WSUSHash
                } Else {
                    If ($PSBoundParameters['ShowEnvironment']) {
                        Write-Verbose "Displaying environment settings"
                        $WSUSEnvHash['Computername'] = $Computer
                        New-Object PSObject -Property $WSUSEnvhash
                    }
                    If ($PSBoundParameters['ShowConfiguration']) {
                        Write-Verbose "Displaying Configuration settings"
                        $WSUSConfigHash['Computername'] = $Computer
                        New-Object PSObject -Property $WSUSConfigHash
                    }
                }
            } Else {
                Write-Warning ("{0}: Unable to connect!" -f $Computer)
            }
        }
    }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>approve_list_of_KBs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>approve_list_of_KBs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.reddit.com/r/sysadmin/comments/58jr92/powershell_script_approve_list_of_kbs_for_a_wsus/

[void][reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")   

#' Replace wsusHostName with the name of your WSUS server.
#' 8530 is the http port, if you use something different you'll have to change that to match. 
#' If you use https you'll want to change the boolean value to $True
$wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::getUpdateServer('wsusHostName',$False,8530)

#'Import list of KBs, find the updates and assign them to $approved, this takes a few minutes
#' The updates.txt has the KB number, 1 per line
$updates = "C:\bin\updates.txt"

#'Get WSUS computer group
$group = $wsus.GetComputerTargetGroups() | where {$_.Name -eq 'Name of group'}

Switch -File $updates {
#'If there are any KBs you don't want to install we can add them like below
"1234567" { &lt;# Do nothing if bad KB is found #&gt; }
DEFAULT{
    #'Search for update
    $toUpdate = $wsus.searchupdates($_)
    if(!$toUpdate){
        #'do nothing if update not found
        Write-Host "$_ not found"
    }
    else{
    #'Approve update
    $toUpdate.Approve("Install",$group)
    }
  }
}

=========================================================================
'Alternately use Switch. Using switch will go through the file line by line and perform an action based on the line,
' you could even use this to exclude specific KBs if needed:

[void][reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")   

# Replace wsusHostName with the name of your WSUS server.
# 8530 is the http port, if you use something different you'll have to change that to match. 
# If you use https you'll want to change the boolean value to $True
$wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::getUpdateServer('wsusHostName',$False,8530)

#Import list of KBs, find the updates and assign them to $approved, this takes a few minutes
# The updates.txt has the KB number, 1 per line
$updates = "C:\bin\updates.txt"

#Get WSUS computer group
$group = $wsus.GetComputerTargetGroups() | where {$_.Name -eq 'Name of group'}

#Scan through list of KBs
switch -Wildcard -File $updates {
    "KB1283102398013*" { &lt;# Do nothing! #&gt; }
    DEFAULT {
        #Search for update
        $toUpdate = $wsus.searchupdates($_)
        #Approve update
        $toUpdate.Approve("Install",$group)
    }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Approve_With_Criteria</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Approve_With_Criteria</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://blog.jasondahmen.com/2015/01/23/wsus-approve-patchesupdate-with-specific-criteria-via-powershell/

#' This scripts goes through and approves and decline updates/patches that meet a specific criteria, 
#'    if it does not meet the criteria it will leave the updates/patches in an unapproved state. 
#' We do not have any Itanium based servers, we only have 32 bit of windows server 2003, and 64 bit of windows server 2008. 
#' This script will let you first run a report of the list of patches that will be approved and declined. 
#' After your verify that your list is applicable to your criteria you can then run the approve option. 
#' This will approve and decline patches for computers in the All Computers group. 
#' If you need to get more granular than that I suggest you take a look at the $group variable 
#'    and be sure that you get the specific computer group that you need.
#'

------------------------------------------------------------------------
$caption = "Choose Option";
$message = "What would you like to do with new updates?";
$report = new-Object System.Management.Automation.Host.ChoiceDescription "&amp;Report Patches","Report";
$approve = new-Object System.Management.Automation.Host.ChoiceDescription "&amp;Approve/Decline Patches","Approve";
$choices = [System.Management.Automation.Host.ChoiceDescription[]]($approve,$report);
$answer = $host.ui.PromptForChoice($caption,$message,$choices,0)
#'$answer 0=approve 1=report
#'#FINAL SCRIPT
$wsusserver = "YOUR IP ADDRESS OR SERVERNAME"
#'#Load required assemblies
[void][reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")
$wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::getUpdateServer($wsusserver,$False,8530)
#'#Retriving "All Computers" Group information
$group = $wsus.GetComputerTargetGroups() | where {$_.Name -eq 'All Computers'}
#'#Retriving list of unapproved updates
$updates = $wsus.GetUpdates()  | where {$_.IsApproved -eq $False -and $_.IsDeclined -eq $False}
#'#######################################
#'Itanium Updates
#'#######################################
#'#Retrive a subset of updates where IA64 is in the legacyname
$IAUpdates = $updates | where {($_.LegacyName -like '*IA64*')}
Foreach ($IAUpdate in $IAUpdates) {
    switch ($answer){
        0 {$IAUpdate.Decline(); $msgDeclined = $msgDeclined + $IAUpdate.SecurityBulletins + "`t" + $IAUpdate.MsrcSeverity + "`t" + $IAUpdate.Title + "`n";break}
        1 {$msgDeclined = $msgDeclined + $IAUpdate.SecurityBulletins + "`t" + $IAUpdate.MsrcSeverity + "`t" + $IAUpdate.Title + "`n";break}
    }
    #'#Uncomment the next line to check updates that are in an incorrect state
    #'If ($IAUpdate.IsDeclined -ne "True") {$msgCheckTheseUpdates = $msgCheckTheseUpdates + $IAUpdate.Title + "`n"}
}
#'#######################################
#'Windows Security Updates Critical
#'#######################################
#'#Revise list of unapproved updates
$updates = $wsus.GetUpdates()  | where {$_.IsApproved -eq $False -and $_.IsDeclined -eq $False}
#'#Retrive a subset of updates that are security updates and are of the windows family and have a MSRC serverity of Critical
$WSecCriticalUpdates = $updates | where {$_.UpdateClassificationTitle -eq 'Security Updates' -and $_.ProductFamilyTitles -like 'Windows' -and $_.MsrcSeverity -eq 'Critical'}
Foreach ($WSecCriticalUpdate in $WSecCriticalUpdates) {
    If ($WSecCriticalUpdate.LegacyName -like "*x64*" -and ($WSecCriticalUpdate.ProductTitles -like "*2008*") -or ($WSecCriticalUpdate.ProductTitles -like "*2012 R2*")) {
            switch ($answer) {
                0 {$WSecCriticalUpdate.Approve('Install',$group); $msgApproved = $msgApproved + $WSecCriticalUpdate.SecurityBulletins + "`t" + $WSecCriticalUpdate.MsrcSeverity + "`t" + $WSecCriticalUpdate.Title + "`n";break}
                1 {$msgApproved = $msgApproved + $WSecCriticalUpdate.SecurityBulletins + "`t" + $WSecCriticalUpdate.MsrcSeverity + "`t" + $WSecCriticalUpdate.Title + "`n";break}
            }
            ##Uncomment the next line to check updates that are in an incorrect state
            #If ($WSecCriticalUpdate.IsApproved -ne "True"){$msgCheckTheseUpdates = $msgCheckTheseUpdates + $WSecCriticalUpdate.Title + "`n"}
    }elseif ($WSecCriticalUpdate.LegacyName -like "*x86*" -and $WSecCriticalUpdate.ProductTitles -like "*2003*") {
            switch ($answer) {
                0 {$WSecCriticalUpdate.Approve('Install',$group); $msgApproved = $msgApproved + $WSecCriticalUpdate.SecurityBulletins + "`t" + $WSecCriticalUpdate.MsrcSeverity + "`t" + $WSecCriticalUpdate.Title + "`n";break}
                1 {$msgApproved = $msgApproved + $WSecCriticalUpdate.SecurityBulletins + "`t" + $WSecCriticalUpdate.MsrcSeverity + "`t" + $WSecCriticalUpdate.Title + "`n";break}
            }
            ##Uncomment the next line to check updates that are in an incorrect state
            #If ($WSecCriticalUpdate.IsApproved -ne "True"){$msgCheckTheseUpdates = $msgCheckTheseUpdates + $WSecCriticalUpdate.Title + "`n"}
    }else {
        switch ($answer) {
            0 {$WSecCriticalUpdate.Decline(); $msgDeclined + $WSecCriticalUpdate.SecurityBulletins + "`t" + $WSecCriticalUpdate.MsrcSeverity + "`t" + $WSecCriticalUpdate.Title + "`n";break}
            1 {$msgDeclined = $msgDeclined + $WSecCriticalUpdate.SecurityBulletins + "`t" + $WSecCriticalUpdate.MsrcSeverity + "`t" + $WSecCriticalUpdate.Title + "`n";break}
        }
        ##Uncomment the next line to check updates that are in an incorrect state
        #If ($WSecCriticalUpdate.IsDeclined -ne "True"){$msgCheckTheseUpdates = $msgCheckTheseUpdates + $WSecCriticalUpdate.Title + "`n"}
    }
}
#'#######################################
#'Windows Security Updates 1 month old
#'#######################################
'##Revise list of unapproved updates
$updates = $wsus.GetUpdates()  | where {$_.IsApproved -eq $False -and $_.IsDeclined -eq $False}
#'#Retrive a subset of updates that are security updates and are of the windows family and DO NOT have a MSRC serverity of Critical
$WSecNoneCriticalUpdates = $updates | where {$_.UpdateClassificationTitle -eq 'Security Updates' -and $_.ProductFamilyTitles -like 'Windows' -and $_.MsrcSeverity -ne 'Critical'}
Foreach ($WSecNoneCriticalUpdate in $WSecNoneCriticalUpdates) {
    If ($WSecNoneCriticalUpdate.LegacyName -like "*x64*" -and ($WSecNoneCriticalUpdate.ProductTitles -like "*2008*") -or ($WSecNoneCriticalUpdate.ProductTitles -like "*2012 R2*")) {
            #'#Getting the createdate of each update and storing it in a variable that can be calculated later
            [datetime]$CreationDate = ($WSecNoneCriticalUpdate).CreationDate
            #'#If the update is more than 27 day old it will approve
            If ($CreationDate -le (Get-Date).AddDays(-27)) {
                switch ($answer){
                    0 {$WSecNoneCriticalUpdate.Approve('Install',$group);$msgApproved = $msgApproved + $WSecNoneCriticalUpdate.SecurityBulletins + "`t" + $WSecNoneCriticalUpdate.MsrcSeverity + "`t" + $WSecNoneCriticalUpdate.Title + "`n";break}
                    1 {$msgApproved = $msgApproved + $WSecNoneCriticalUpdate.SecurityBulletins + "`t" + $WSecNoneCriticalUpdate.MsrcSeverity + "`t" + $WSecNoneCriticalUpdate.Title + "`n";break}
                }
            }
    }elseif ($WSecNoneCriticalUpdate.LegacyName -like "*x86*" -and $WSecNoneCriticalUpdate.ProductTitles -like "*2003*") {
        #'#Getting the createdate of each update and storing it in a variable that can be calculated later
        [datetime]$CreationDate = ($WSecNoneCriticalUpdate).CreationDate
        #'#If the update is more than 27 day old it will approve
        If ($CreationDate -le (Get-Date).AddDays(-27)) {
            switch ($answer){
                    0 {$WSecNoneCriticalUpdate.Approve('Install',$group);$msgApproved = $msgApproved + $WSecNoneCriticalUpdate.SecurityBulletins + "`t" + $WSecNoneCriticalUpdate.MsrcSeverity + "`t" + $WSecNoneCriticalUpdate.Title + "`n";break}
                    1 {$msgApproved = $msgApproved + $WSecNoneCriticalUpdate.SecurityBulletins + "`t" + $WSecNoneCriticalUpdate.MsrcSeverity + "`t" + $WSecNoneCriticalUpdate.Title + "`n";break}
            }
        }
    }else {
        switch ($answer){
            0 {$WSecNoneCriticalUpdate.Decline(); $msgDeclined = $msgDeclined + $WSecNoneCriticalUpdate.SecurityBulletins + "`t" + $WSecNoneCriticalUpdate.MsrcSeverity + "`t" + $WSecNoneCriticalUpdate.Title + "`n";break}
            1 {$msgDeclined = $msgDeclined + $WSecNoneCriticalUpdate.SecurityBulletins + "`t" + $WSecNoneCriticalUpdate.MsrcSeverity + "`t" + $WSecNoneCriticalUpdate.Title + "`n";break}
        }
    }
}
#'#######################################
#'Windows Recommended Updates 1 month old
#'#######################################
#'#Revise list of unapproved updates
$updates = $wsus.GetUpdates()  | where {$_.IsApproved -eq $False -and $_.IsDeclined -eq $False}
#'#Retrive a subset of updates that are updates and are of the windows family
$WRecommendedUpdates = $updates | where {$_.UpdateClassificationTitle -eq 'Updates' -and $_.ProductFamilyTitles -like 'Windows'}
Foreach ($WRecommendedUpdate in $WRecommendedUpdates) {
    If ($WRecommendedUpdate.LegacyName -like "*x64*" -and ($WRecommendedUpdate.ProductTitles -like "*2008*") -or ($WRecommendedUpdate.ProductTitles -like "*2012 R2*")) {
        #'#Getting the createdate of each update and storing it in a variable that can be calculated later
        [datetime]$CreationDate = ($WRecommendedUpdate).CreationDate
        ##If the update is more than 27 day old it will approve
        If ($CreationDate -le (Get-Date).AddDays(-27)) {
            switch ($answer) {
                0 {$WRecommendedUpdate.Approve('Install',$group); $msgApproved = $msgApproved + $WRecommendedUpdate.SecurityBulletins + "`t      " + $WRecommendedUpdate.MsrcSeverity + "`t" +  $WRecommendedUpdate.Title + "`n";break}
                1 {$msgApproved = $msgApproved + $WRecommendedUpdate.SecurityBulletins + "`t      " + $WRecommendedUpdate.MsrcSeverity + "`t" +  $WRecommendedUpdate.Title + "`n";break}
            }
        }
    }elseif ($WRecommendedUpdate.LegacyName -like "*x86*" -and $WRecommendedUpdate.ProductTitles -like "*2003*") {
        #'#Getting the createdate of each update and storing it in a variable that can be calculated later
        [datetime]$CreationDate = ($WRecommendedUpdate).CreationDate
        #'#If the update is more than 27 day old it will approve
        If ($CreationDate -le (Get-Date).AddDays(-27)) {
            switch ($answer) {
                0 {$WRecommendedUpdate.Approve('Install',$group); $msgApproved = $msgApproved + $WRecommendedUpdate.SecurityBulletins + "`t      " + $WRecommendedUpdate.MsrcSeverity + "`t" +  $WRecommendedUpdate.Title + "`n";break}
                1 {$msgApproved = $msgApproved + $WRecommendedUpdate.SecurityBulletins + "`t      " + $WRecommendedUpdate.MsrcSeverity + "`t" +  $WRecommendedUpdate.Title + "`n";break}
            }
        }
    }else {
        switch ($answer) {
            0 {$WRecommendedUpdate.Decline();  $msgDeclined = $msgDeclined + $WRecommendedUpdate.SecurityBulletins + "`t      " + $WRecommendedUpdate.MsrcSeverity + "`t" +  $WRecommendedUpdate.Title + "`n";break}
            1 {$msgDeclined = $msgDeclined + $WRecommendedUpdate.SecurityBulletins + "`t      " + $WRecommendedUpdate.MsrcSeverity + "`t" +  $WRecommendedUpdate.Title + "`n";break}
        }
    }
}
#'#######################################
#'Windows Office Updates 1 month old
#'#######################################
#'#Revise list of unapproved updates
$updates = $wsus.GetUpdates()  | where {$_.IsApproved -eq $False -and $_.IsDeclined -eq $False}
#'#Retrive a subset of updates that are updates and are of the windows family
$WOfficeUpdates = $updates | where {($_.UpdateClassificationTitle -eq 'Updates' -or $_.UpdateClassificationTitle -eq 'Security Updates') -and $_.ProductTitles -like '*Office 2*' -and $_.Title -notlike '*Share*'}
Foreach ($WOfficeUpdate in $WOfficeUpdates) {
    [datetime]$CreationDate = ($WOfficeUpdate).CreationDate
    #'#If the update is more than 27 day old it will approve
    If ($CreationDate -le (Get-Date).AddDays(-27)) {
        switch ($answer) {
            0 {$WOfficeUpdate.Approve('Install',$group); $msgApproved = $msgApproved + $WOfficeUpdate.SecurityBulletins + "`t" + $WOfficeUpdate.MsrcSeverity + "`t" +  $WOfficeUpdate.Title + "`n"; break}
            1 {$msgApproved = $msgApproved + $WOfficeUpdate.SecurityBulletins + "`t" + $WOfficeUpdate.MsrcSeverity + "`t" +  $WOfficeUpdate.Title + "`n"; break}
        }
    }
}
#'#Sending EMAIL
$month = get-date -Format MMMM
switch($answer){
    0 {send-mailmessage -to patchingreports@example.com -subject "Updates Approve/Declined for $month" -body "Approved Updates`n $msgApproved`nDeclined Updates`n $msgDeclined"  -smtpserver "mailserver.example.com" -from WSUSServer@example.com;break}
    1 {send-mailmessage -to patchingreports@example.com -subject "Updates Reports for $month" -body "Approved Updates`n $msgApproved`nDeclined Updates`n $msgDeclined"  -smtpserver "mailserver.example.com" -from WSUSServer@example.com;break}
}
exit
------------------------------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Declining_Superseded_Updates_v0</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Declining_Superseded_Updates_v0</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#''Declining_Superseded_Updates_v0
'from: https://blogs.technet.microsoft.com/configurationmgr/2016/01/26/the-complete-guide-to-microsoft-wsus-and-configuration-manager-sup-maintenance/

'NOTE You always want to run the script with the SkipDecline parameter before running the decline so you get a summary of how many superseded updates you are about to decline.
'I run this once a quarter in my environment. 

'If you do not expire updates immediately in Configuration Manager, you will need to set an exclusion period that matches your Configuration Manager setting for number of days to expire superseded updates. In this case, 
'it would be 60 days since I specified to wait 2 months in my SUP properties.

'Examples on how to run the script using PowerShell running as administrator:

Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 80 -SkipDecline
Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8351
Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530
Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530 ExclusionPeriod 60


'Running the script with a SkipDecline and ExclusionPeriod 60 to gather information about my WSUS and how many updates I will decline:


==========================================================================================
#' ===============================================
#' Script to decline superseeded updates in WSUS.
#' ===============================================
#' It's recommended to run the script with the -SkipDecline switch to see how many superseded updates are in WSUS and to TAKE A BACKUP OF THE SUSDB before declining the updates.
#' Parameters:

#' $UpdateServer             = Specify WSUS Server Name
#' $UseSSL                   = Specify whether WSUS Server is configured to use SSL
#' $Port                     = Specify WSUS Server Port
#' $SkipDecline              = Specify this to do a test run and get a summary of how many superseded updates we have
#' $DeclineLastLevelOnly     = Specify whether to decline all superseded updates or only last level superseded updates
#' $ExclusionPeriod          = Specify the number of days between today and the release date for which the superseded updates must not be declined. Eg, if you want to keep superseded updates published within the last 2 months, specify a value of 60 (days)


#' Supersedence chain could have multiple updates. 
#' For example, Update1 supersedes Update2. Update2 supersedes Update3. In this scenario, the Last Level in the supersedence chain is Update3. 
#' To decline only the last level updates in the supersedence chain, specify the DeclineLastLevelOnly switch

#' Usage:
#' =======

#' To do a test run against WSUS Server without SSL
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530 -SkipDecline

#' To do a test run against WSUS Server using SSL
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -SkipDecline

#' To decline all superseded updates on the WSUS Server using SSL
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531

#' To decline only Last Level superseded updates on the WSUS Server using SSL
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -DeclineLastLevelOnly

#' To decline all superseded updates on the WSUS Server using SSL but keep superseded updates published within the last 2 months (60 days)
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -ExclusionPeriod 60


[CmdletBinding()]
Param(
	[Parameter(Mandatory=$True,Position=1)]
    [string] $UpdateServer,
	
	[Parameter(Mandatory=$False)]
    [switch] $UseSSL,
	
	[Parameter(Mandatory=$True, Position=2)]
    $Port,
	
    [switch] $SkipDecline,
	
    [switch] $DeclineLastLevelOnly,
	
    [Parameter(Mandatory=$False)]
    [int] $ExclusionPeriod = 0
)

Write-Host ""

if ($SkipDecline -and $DeclineLastLevelOnly) {
    Write-Host "Using SkipDecline and DeclineLastLevelOnly switches together is not allowed."
	Write-Host ""
    return
}

$outPath = Split-Path $script:MyInvocation.MyCommand.Path
$outSupersededList = Join-Path $outPath "SupersededUpdates.csv"
$outSupersededListBackup = Join-Path $outPath "SupersededUpdatesBackup.csv"
"UpdateID, RevisionNumber, Title, KBArticle, SecurityBulletin, LastLevel" | Out-File $outSupersededList

try {
    
    if ($UseSSL) {
        Write-Host "Connecting to WSUS server $UpdateServer on Port $Port using SSL... " -NoNewLine
    } Else {
        Write-Host "Connecting to WSUS server $UpdateServer on Port $Port... " -NoNewLine
    }
    
    [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") | out-null
    $wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($UpdateServer, $UseSSL, $Port);
}
catch [System.Exception] 
{
    Write-Host "Failed to connect."
    Write-Host "Error:" $_.Exception.Message
    Write-Host "Please make sure that WSUS Admin Console is installed on this machine"
	Write-Host ""
    $wsus = $null
}

if ($wsus -eq $null) { return } 

Write-Host "Connected."

$countAllUpdates = 0
$countSupersededAll = 0
$countSupersededLastLevel = 0
$countSupersededExclusionPeriod = 0
$countSupersededLastLevelExclusionPeriod = 0
$countDeclined = 0

Write-Host "Getting a list of all updates... " -NoNewLine

try {
	$allUpdates = $wsus.GetUpdates()
}

catch [System.Exception]
{
	Write-Host "Failed to get updates."
	Write-Host "Error:" $_.Exception.Message
    Write-Host "If this operation timed out, please decline the superseded updates from the WSUS Console manually."
	Write-Host ""
	return
}

Write-Host "Done"

Write-Host "Parsing the list of updates... " -NoNewLine
foreach($update in $allUpdates) {
    
    $countAllUpdates++
    
    if ($update.IsDeclined) {
        $countDeclined++
    }
    
    if (!$update.IsDeclined -and $update.IsSuperseded) {
        $countSupersededAll++
        
        if (!$update.HasSupersededUpdates) {
            $countSupersededLastLevel++
        }

        if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
		    $countSupersededExclusionPeriod++
			if (!$update.HasSupersededUpdates) {
				$countSupersededLastLevelExclusionPeriod++
			}
        }		
        
        "$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededList -Append       
        
    }
}

Write-Host "Done."
Write-Host "List of superseded updates: $outSupersededList"

Write-Host ""
Write-Host "Summary:"
Write-Host "========"

Write-Host "All Updates =" $countAllUpdates
Write-Host "Any except Declined =" ($countAllUpdates - $countDeclined)
Write-Host "All Superseded Updates =" $countSupersededAll
Write-Host "    Superseded Updates (Intermediate) =" ($countSupersededAll - $countSupersededLastLevel)
Write-Host "    Superseded Updates (Last Level) =" $countSupersededLastLevel
Write-Host "    Superseded Updates (Older than $ExclusionPeriod days) =" $countSupersededExclusionPeriod
Write-Host "    Superseded Updates (Last Level Older than $ExclusionPeriod days) =" $countSupersededLastLevelExclusionPeriod
Write-Host ""

$i = 0
if (!$SkipDecline) {
    
    Write-Host "SkipDecline flag is set to $SkipDecline. Continuing with declining updates"
    $updatesDeclined = 0
    
    if ($DeclineLastLevelOnly) {
        Write-Host "  DeclineLastLevel is set to True. Only declining last level superseded updates." 
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded -and !$update.HasSupersededUpdates) {
              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
			    $i++
				$percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededLastLevelExclusionPeriod) * 100)
				Write-Progress -Activity "Declining Updates" -Status "Declining update #'$i/$countSupersededLastLevelExclusionPeriod - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
				
                try 
                {
                    $update.Decline()                    
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Host "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                } 
              }             
            }
        }        
    }
    else {
        Write-Host "  DeclineLastLevel is set to False. Declining all superseded updates."
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded) {
              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {   
			  	
				$i++
				$percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededAll) * 100)
				Write-Progress -Activity "Declining Updates" -Status "Declining update #'$i/$countSupersededAll - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
                try 
                {
                    $update.Decline()
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Host "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                }
              }              
            }
        }   
        
    }
    
    Write-Host "  Declined $updatesDeclined updates."
    if ($updatesDeclined -ne 0) {
        Copy-Item -Path $outSupersededList -Destination $outSupersededListBackup -Force
		Write-Host "  Backed up list of superseded updates to $outSupersededListBackup"
    }
    
}
else {
    Write-Host "SkipDecline flag is set to $SkipDecline. Skipped declining updates"
}

Write-Host ""
Write-Host "Done"
Write-Host ""</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Declining_Superseeded_Updates</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Declining_Superseeded_Updates</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'SEE ORIGINAL source script below
https://4sysops.com/archives/automating-wsus-with-powershell/
-------------------------------------
#'My changes are in the lines 5759, 99100, and 242. 
#'I added the transcript file, so when the script ran via the Task Scheduler, 
#'    I could see the number of declined updates. And after I ran the script the first time, 
#'    I changed the update scope. 
#'So it'll check and decline only updates within the last six months.

#'===============================================
#'Script to decline superseeded updates in WSUS.
#'===============================================
#'It's recommended to run the script with the -SkipDecline switch to see how many superseded updates are in WSUS and to TAKE A BACKUP OF THE SUSDB before declining the updates.
#'Parameters:
 
#'$UpdateServer             = Specify WSUS Server Name
#'$UseSSL                   = Specify whether WSUS Server is configured to use SSL
#'$Port                     = Specify WSUS Server Port
#'$SkipDecline              = Specify this to do a test run and get a summary of how many superseded updates we have
#'$DeclineLastLevelOnly     = Specify whether to decline all superseded updates or only last level superseded updates
#'$ExclusionPeriod          = Specify the number of days between today and the release date for which the superseded updates must not be declined. Eg, if you want to keep superseded updates published within the last 2 months, specify a value of 60 (days)
 
 
#'Supersedence chain could have multiple updates. 
#'For example, Update1 supersedes Update2. Update2 supersedes Update3. In this scenario, the Last Level in the supersedence chain is Update3. 
#'To decline only the last level updates in the supersedence chain, specify the DeclineLastLevelOnly switch
 
#'Usage:
#'=======
 
#'To do a test run against WSUS Server without SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530 -SkipDecline
 
#'To do a test run against WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -SkipDecline
 
#'To decline all superseded updates on the WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531
 
#'To decline only Last Level superseded updates on the WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -DeclineLastLevelOnly
 
#'To decline all superseded updates on the WSUS Server using SSL but keep superseded updates published within the last 2 months (60 days)
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -ExclusionPeriod 60
 
 
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$True,Position=1)]
    [string] $UpdateServer,
    
    [Parameter(Mandatory=$False)]
    [switch] $UseSSL,
    
    [Parameter(Mandatory=$True, Position=2)]
    $Port,
    
    [switch] $SkipDecline,
    
    [switch] $DeclineLastLevelOnly,
    
    [Parameter(Mandatory=$False)]
    [int] $ExclusionPeriod = 0
)
 
$file = "c:\temp\WSUS_Decline_Superseded_{0:MMddyyyy_HHmm}.log" -f (Get-Date) 
 
Start-Transcript -Path $file
 
 
if ($SkipDecline -and $DeclineLastLevelOnly) {
    Write-Output "Using SkipDecline and DeclineLastLevelOnly switches together is not allowed."
    Write-Output ""
    return
}
 
$outPath = Split-Path $script:MyInvocation.MyCommand.Path
$outSupersededList = Join-Path $outPath "SupersededUpdates.csv"
$outSupersededListBackup = Join-Path $outPath "SupersededUpdatesBackup.csv"
"UpdateID, RevisionNumber, Title, KBArticle, SecurityBulletin, LastLevel" | Out-File $outSupersededList
 
try {
    
    if ($UseSSL) {
        Write-Output "Connecting to WSUS server $UpdateServer on Port $Port using SSL... " -NoNewLine
    } Else {
        Write-Output "Connecting to WSUS server $UpdateServer on Port $Port... " -NoNewLine
    }
    
    [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") | out-null
    $wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($UpdateServer, $UseSSL, $Port);
}
catch [System.Exception] 
{
    Write-Output "Failed to connect."
    Write-Output "Error:" $_.Exception.Message
    Write-Output "Please make sure that WSUS Admin Console is installed on this machine"
    Write-Output ""
    $wsus = $null
}
 
if ($wsus -eq $null) { return } 
 
Write-Output "Connected."
 
$UpdateScope = New-Object Microsoft.UpdateServices.Administration.UpdateScope
 
(get-date).AddMonths(-6)
$UpdateScope.FromArrivalDate = (get-date).AddMonths(-6)
$UpdateScope.ToArrivalDate = (get-date)
 
$countAllUpdates = 0
$countSupersededAll = 0
$countSupersededLastLevel = 0
$countSupersededExclusionPeriod = 0
$countSupersededLastLevelExclusionPeriod = 0
$countDeclined = 0
 
Write-Output "Getting a list of all updates... " -NoNewLine
 
try {
    $allUpdates = $wsus.GetUpdates($UpdateScope)
}
 
catch [System.Exception]
{
    Write-Output "Failed to get updates."
    Write-Output "Error:" $_.Exception.Message
    Write-Output "If this operation timed out, please decline the superseded updates from the WSUS Console manually."
    Write-Output ""
    return
}
 
Write-Output "Done"
 
Write-Output "Parsing the list of updates... " -NoNewLine
foreach($update in $allUpdates) {
    
    $countAllUpdates++
    
    if ($update.IsDeclined) {
        $countDeclined++
    }
    
    if (!$update.IsDeclined -and $update.IsSuperseded) {
        $countSupersededAll++
        
        if (!$update.HasSupersededUpdates) {
            $countSupersededLastLevel++
        }
 
        if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
            $countSupersededExclusionPeriod++
            if (!$update.HasSupersededUpdates) {
                $countSupersededLastLevelExclusionPeriod++
            }
        }        
        
        "$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededList -Append       
        
    }
}
 
Write-Output "Done."
Write-Output "List of superseded updates: $outSupersededList"
 
Write-Output ""
Write-Output "Summary:"
Write-Output "========"
 
Write-Output "All Updates = $countAllUpdates"
$AnyExceptDeclined = $countAllUpdates - $countDeclined
Write-Output "Any except Declined = $AnyExceptDeclined"
Write-Output "All Superseded Updates = $countSupersededAll"
$SuperseededAllOutput = $countSupersededAll - $countSupersededLastLevel
Write-Output "    Superseded Updates (Intermediate) = $SuperseededAllOutput"
Write-Output "    Superseded Updates (Last Level) = $countSupersededLastLevel"
Write-Output "    Superseded Updates (Older than $ExclusionPeriod days) = $countSupersededExclusionPeriod"
Write-Output "    Superseded Updates (Last Level Older than $ExclusionPeriod days) = $countSupersededLastLevelExclusionPeriod"
 
$i = 0
if (!$SkipDecline) {
    
    Write-Output "SkipDecline flag is set to $SkipDecline. Continuing with declining updates"
    $updatesDeclined = 0
    
    if ($DeclineLastLevelOnly) {
        Write-Output "  DeclineLastLevel is set to True. Only declining last level superseded updates." 
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded -and !$update.HasSupersededUpdates) {
              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
                $i++
                $percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededLastLevelExclusionPeriod) * 100)
                Write-Progress -Activity "Declining Updates" -Status "Declining update #$i/$countSupersededLastLevelExclusionPeriod - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
                
                try 
                {
                    $update.Decline()                    
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Output "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                } 
              }             
            }
        }        
    }
    else {
        Write-Output "  DeclineLastLevel is set to False. Declining all superseded updates."
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded) {
              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {   
                  
                $i++
                $percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededAll) * 100)
                Write-Progress -Activity "Declining Updates" -Status "Declining update #$i/$countSupersededAll - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
                try 
                {
                    $update.Decline()
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Output "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                }
              }              
            }
        }   
        
    }
    
    Write-Output "  Declined $updatesDeclined updates."
    if ($updatesDeclined -ne 0) {
        Copy-Item -Path $outSupersededList -Destination $outSupersededListBackup -Force
        Write-Output "  Backed up list of superseded updates to $outSupersededListBackup"
    }
    
}
else {
    Write-Output "SkipDecline flag is set to $SkipDecline. Skipped declining updates"
}
 
Write-Output ""
Write-Output "Done"
Write-Output ""
 
Stop-Transcript



===========================================================

==========ORIGINAL SOURCE SCRIPT========================================
https://social.technet.microsoft.com/Forums/msonline/en-US/15f0443d-2f68-4d9e-a580-0e330fbac6cc/no-updates-after-3159706?forum=winserverwsus
===============================================================
#'===============================================
#'Script to decline superseeded updates in WSUS.
#'===============================================
#'It's recommended to run the script with the -SkipDecline switch to see how many superseded updates are in WSUS and to TAKE A BACKUP OF THE SUSDB before declining the updates.
#'Parameters:

#'$UpdateServer             = Specify WSUS Server Name
#'$UseSSL                   = Specify whether WSUS Server is configured to use SSL
#'$Port                     = Specify WSUS Server Port
#'$SkipDecline              = Specify this to do a test run and get a summary of how many superseded updates we have
#'$DeclineLastLevelOnly     = Specify whether to decline all superseded updates or only last level superseded updates

#'Supersedence chain could have multiple updates. 
#'For example, Update1 supersedes Update2. Update2 supersedes Update3. In this scenario, the Last Level in the supersedence chain is Update3. 
#'To decline only the last level updates in the supersedence chain, specify the DeclineLastLevelOnly switch

#'Usage:
#'=======

#'To do a test run against WSUS Server without SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530 -SkipDecline

#'To do a test run against WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -SkipDecline

#'To decline all superseded updates on the WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531

#'To decline only Last Level superseded updates on the WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -DeclineLastLevelOnly

[CmdletBinding()]
Param(
	[Parameter(Mandatory=$True,Position=1)]
    [string] $UpdateServer,
	
	[Parameter(Mandatory=$False)]
    [switch] $UseSSL,
	
	[Parameter(Mandatory=$True, Position=2)]
    $Port,
    [switch] $SkipDecline,
    [switch] $DeclineLastLevelOnly
)

Write-Host ""

if ($SkipDecline -and $DeclineLastLevelOnly) {
    Write-Host "Using SkipDecline and DeclineLastLevelOnly switches together is not allowed."
	Write-Host ""
    return
}

$outPath = Split-Path $script:MyInvocation.MyCommand.Path
$outSupersededList = Join-Path $outPath "SupersededUpdates.csv"
$outSupersededListBackup = Join-Path $outPath "SupersededUpdatesBackup.csv"
"UpdateID, RevisionNumber, Title, KBArticle, SecurityBulletin, LastLevel" | Out-File $outSupersededList

try {
    
    if ($UseSSL) {
        Write-Host "Connecting to WSUS server $UpdateServer on Port $Port using SSL... " -NoNewLine
    } Else {
        Write-Host "Connecting to WSUS server $UpdateServer on Port $Port... " -NoNewLine
    }
    
    [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") | out-null
    #$wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($UpdateServer, $UseSSL, $Port);
	$wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer();
}
catch [System.Exception] 
{
    Write-Host "Failed to connect."
    Write-Host "Error:" $_.Exception.Message
    Write-Host "Please make sure that WSUS Admin Console is installed on this machine"
	Write-Host ""
    $wsus = $null
}

if ($wsus -eq $null) { return } 

Write-Host "Connected."

$countAllUpdates = 0
$countSupersededAll = 0
$countSupersededLastLevel = 0
$countDeclined = 0

Write-Host "Getting a list of all updates... " -NoNewLine

try {
	$allUpdates = $wsus.GetUpdates()
}

catch [System.Exception]
{
	Write-Host "Failed to get updates."
	Write-Host "Error:" $_.Exception.Message
    Write-Host "If this operation timed out, please decline the superseded updates from the WSUS Console manually."
	Write-Host ""
	return
}

Write-Host "Done"

Write-Host "Parsing the list of updates... " -NoNewLine
foreach($update in $allUpdates) {
    
    $countAllUpdates++
    
    if ($update.IsDeclined) {
        $countDeclined++
    }
    
    if (!$update.IsDeclined -and $update.IsSuperseded) {
        $countSupersededAll++
        
        if (!$update.HasSupersededUpdates) {
            $countSupersededLastLevel++
        }
        
        "$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededList -Append       
        
    }
}

Write-Host "Done."
Write-Host "List of superseded updates: $outSupersededList"

Write-Host ""
Write-Host "Summary:"
Write-Host "========"

Write-Host "All Updates =" $countAllUpdates
Write-Host "Any except Declined =" ($countAllUpdates - $countDeclined)
Write-Host "All Superseded Updates =" $countSupersededAll
Write-Host "    Superseded Updates (Intermediate) =" ($countSupersededAll - $countSupersededLastLevel)
Write-Host "    Superseded Updates (Last Level) =" $countSupersededLastLevel
Write-Host ""

if (!$SkipDecline) {
    
    Write-Host "SkipDecline flag is set to $SkipDecline. Continuing with declining updates"
    $updatesDeclined = 0
    
    if ($DeclineLastLevelOnly) {
        Write-Host "  DeclineLastLevel is set to True. Only declining last level superseded updates." 
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded -and !$update.HasSupersededUpdates) {
                
                try 
                {
                    $update.Decline()
                    #'Write-Host "Declined update $($update.Id.UpdateId.Guid)"
                    Write-Progress -Activity "Declining Updates" -Status "Declining update $($update.Id.UpdateId.Guid)" -PercentComplete (($updatesDeclined/$countSupersededLastLevel) * 100)
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Host "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                }            
            }
        }        
    }
    else {
        Write-Host "  DeclineLastLevel is set to False. Declining all superseded updates."
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded) {
                
                try 
                {
                    $update.Decline()
                    #'Write-Host "Declined update $($update.Id.UpdateId.Guid)"
                    Write-Progress -Activity "Declining Updates" -Status "Declining update $($update.Id.UpdateId.Guid)" -PercentComplete (($updatesDeclined/$countSupersededAll) * 100)
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Host "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                }            
            }
        }   
        
    }
    
    Write-Host "  Declined $updatesDeclined updates."
    if ($updatesDeclined -ne 0) {
        Copy-Item -Path $outSupersededList -Destination $outSupersededListBackup -Force
		Write-Host "  Backed up list of superseded updates to $outSupersededListBackup"
    }
    
}
else {
    Write-Host "SkipDecline flag is set to $SkipDecline. Skipped declining updates"
}

Write-Host ""
Write-Host "Done"
Write-Host ""</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-WindowsUpdate.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-WindowsUpdate.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://gallery.technet.microsoft.com/scriptcenter/Get-Installed-FailedWindows-9f28742a
============================================================================================

#'### Author Allenage.com ###

#'#### Remote Computers with server or ComputerName on Txt file ##

#'Get-WindowsUpdate_fromTextFile.ps1

$computers = get-Content c:\computers.txt
foreach ($computer in $computers){
if(!(Test-Connection -Cn $computer -BufferSize 16 -Count 1 -ea 0 -quiet))
{write-host "cannot reach $computer" -f red}

else {$Session = New-Object -ComObject "Microsoft.Update.Session"

$Searcher = $Session.CreateUpdateSearcher()

$historyCount = $Searcher.GetTotalHistoryCount()

$Searcher.QueryHistory(0, $historyCount) | Select-Object Date,

   @{name="Operation"; expression={switch($_.operation){

       1 {"Installation"}; 2 {"Uninstallation"}; 3 {"Other"}}}},

   @{name="Status"; expression={switch($_.resultcode){

       1 {"In Progress"}; 2 {"Succeeded"}; 3 {"Succeeded With Errors"};

       4 {"Failed"}; 5 {"Aborted"}

}}}, Title | Export-Csv -NoType "$Env:userprofile\Desktop\$computer-WindowsUpdates.csv"}}


#'### Enter Computer Name On Prompt to get installed Updates #####

$computers=[System.Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic') | Out-Null  
$computers= [Microsoft.VisualBasic.Interaction]::InputBox("Enter Computername")
foreach ($computer in $computers){
if(!(Test-Connection -Cn $computer -BufferSize 16 -Count 1 -ea 0 -quiet))
{write-host "cannot reach $computer" -f red}

else {$Session = New-Object -ComObject "Microsoft.Update.Session"

$Searcher = $Session.CreateUpdateSearcher()

$historyCount = $Searcher.GetTotalHistoryCount()

$Searcher.QueryHistory(0, $historyCount) | Select-Object Date,

   @{name="Operation"; expression={switch($_.operation){

       1 {"Installation"}; 2 {"Uninstallation"}; 3 {"Other"}}}},

   @{name="Status"; expression={switch($_.resultcode){

       1 {"In Progress"}; 2 {"Succeeded"}; 3 {"Succeeded With Errors"};

       4 {"Failed"}; 5 {"Aborted"}

}}}, Title | Export-Csv -NoType "$Env:userprofile\Desktop\$computer-WindowsUpdates.csv"}}



#'## get Local computers Windows Updates ######

$Session = New-Object -ComObject "Microsoft.Update.Session" 
 
$Searcher = $Session.CreateUpdateSearcher() 
 
$historyCount = $Searcher.GetTotalHistoryCount() 
 
$Searcher.QueryHistory(0, $historyCount) | Select-Object Date, 
 
   @{name="Operation"; expression={switch($_.operation){ 
 
       1 {"Installation"}; 2 {"Uninstallation"}; 3 {"Other"}}}}, 
 
   @{name="Status"; expression={switch($_.resultcode){ 
 
       1 {"In Progress"}; 2 {"Succeeded"}; 3 {"Succeeded With Errors"}; 
 
       4 {"Failed"}; 5 {"Aborted"} 
 
}}}, Title | Export-Csv -NoType "$Env:userprofile\Desktop\WindowsUpdates.csv"


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-WindowsUpdate_fromTextFile_v2.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-WindowsUpdate_fromTextFile_v2.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get-WindowsUpdate_fromTextFile_v2.ps1

$computers = get-Content c:\Data\computers.txt
foreach ($computer in $computers){

    if(!(Test-Connection -Cn $computer -BufferSize 16 -Count 1 -ea 0 -quiet))
            {write-host "cannot reach $computer" -f red}

else {$Session = New-Object -ComObject "Microsoft.Update.Session"

        $Searcher = $Session.CreateUpdateSearcher()

        $historyCount = $Searcher.GetTotalHistoryCount()

        $Searcher.QueryHistory(0, $historyCount) | Select-Object Date,

           @{
                name="Operation"; expression={switch($_.operation){

                                                                    1 {"Installation"}; 
                                                                    2 {"Uninstallation"}; 
                                                                    3 {"Other"} 
                                                                }
                                           }
            },

           @{
                name="Status"; expression={switch($_.resultcode){

                                                                    1 {"In Progress"}; 
                                                                    2 {"Succeeded"}; 
                                                                    3 {"Succeeded With Errors"};
                                                                    4 {"Failed"}; 
                                                                    5 {"Aborted"}

                                                                 }
                                           }
           }, Title | Export-Csv -NoType "c:\Data\$computer-WindowsUpdates.csv"}
    }</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Run-DeclineUpdate-CleanupV3.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Run-DeclineUpdate-CleanupV3.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Decline Updates Script by Jeff Carreon
'https://www.mnscug.org/images/carryon/Run-DeclineUpdate-Cleanup.zip

'By default the script run in What-If mode ($TrialRun set to $True). 
'Here is a syntax to run it in declining mode, without sending an email report:  
.\Run-DeclineUpdate-CleanupV3.ps1 -Servers CM01 TrialRun:$false EmailReport:$false

=================================================================================================
#'Run-DeclineUpdate-CleanupV3.ps1

&lt;#
.SYNOPSIS
	Script is for declining superseeded, Itanium Updates, XP, Preview, Beta, ARM64, IE7, IE8, IE9, IE10, Win10 Next, Server Next, and Embedded Updates in WSUS/SUP environment.
	
	Recommend running this monthly...  
	Run the scripts targetting the bottom or downstreams servers (bottom SUPs), then run it against the upstream server (Top SUP)...
	BE AWARE:  
		The XP function may grab Windows 2008 R2 articles.   
		I HIGHLY recommend do a -TrialRun first, and examine the results before executing this in prod environment.  By default, this is set to true, see param section.
	

.DESCRIPTION
	Script is designed to decline all of the updates that have been superseded for over 90 days, by default.  This can be adjusted in param section.
	
	# $Servers					= Specify the target servers as default target(s) for automation.  Or, can be specified manually at run time.
	# $UseSSL                   = Specify whether WSUS Server is configured to use SSL
	# $Port                     = Specify WSUS Server Port (Hard coded in param section, though this can be specified otherwise)
	# $TrialRun		            = Specify this to do a test run and get a summary of how many superseded updates, Itanium Updates, XP, Preview, Beta, Win10 Next, Server Next, ARM64, IE7, IE8, IE9, IE10, and Embedded Updates there are that can be declined.  It records to .csv and htm file
	# $DeclineLastLevelOnly     = Specify whether to decline all superseded updates or only last level superseded updates
									**For example, Update1 supersedes Update2. Update2 supersedes Update3. In this scenario, the Last Level in the supersedence chain is Update3. 
									**To decline only the last level updates in the supersedence chain, specify the DeclineLastLevelOnly switch
	# $ExclusionPeriod          = Specify the number of days between today and the release date for which the superseded updates must not be declined. Eg, if you want to keep superseded updates published within the last 2 months, specify a value of 60 (days)
	# $SkipItanium				= Specify this to skip declining Itanium updates.
	# $SkipXP					= Specify this to skip declining Windows XP updates.  
	# $SkipPrev					= Specify this to skip declining Windows Preview updates.  
	# $SkipBeta					= Specify this to skip declining Windows Beta updates.
	# $SkipWin10Next			= Specify this to skip declining Windows 10 Next updates.
	# $SkipServerNext			= Specify this to skip declining Windows Server Next updates.
	# $SkipArm64				= Specify this to skip declining ARM64-based updates.
	# $SkipIE7					= Specify this to skip declining Windows IE7 updates.
	# $SkipIE8					= Specify this to skip declining Windows IE8 updates. Default is $true
	# $SkipIE9					= Specify this to skip declining Windows IE9 updates. Default is $true
	# $SkipIE10					= Specify this to skip declining Windows IE10 updates. Default is $true
	# $SkipEmbedded				= Specify this to skip declining Windows Embedded updates.
	
	# $CleanUpdatelist			= Specify whether to clean the UpdateList folders/files to prevent build up. Default is $true
	# $CleanULNumber			= Specify the number of days old folders/files to keep in UpdateList folder

.NOTE
	$DeclineLastLevelOnly &amp; $trial CANNOT be used at the same time.
	Script will create custom application "CMSDKPosh" Eventlog for storing events below
		EventID 21020 = Successful Run
		EventID 21021 = Error running the main function
		EventID 21031 = Error running either the Decline superseded or itanium function
	
	Updates 4/25/2018: 
		- Added Decline updates for Win10 Next, and Server Next
        - Added email reporting and logging
		- Perfomance improvement on querying updates
	
	Updates 5/10/2018: 
		- Added Decline updates for ARM64-Based, and IE 10
        - Added Clean Update List maintnance function (optional), deletes files/folders that are # of days old.
		- Fixed error handling on querying for updates.
		- Perfomance improvement
	
	Jeff Carreon's Hack job :)
	Updated: 5/10/2018
	v.4
#&gt;

[CmdletBinding()]
Param(
	
    # Define lower tier SUP servers first, then TOP WSUS/SUP server last in this array
    $Servers = @("&lt;lowerSUPServer1&gt;","&lt;lowerSUPServer2&gt;","&lt;topSUPServer&gt;"),	

	[bool]$UseSSL = $False,
	
	[int]$PortNumber = 8530,
	
    [switch] $TrialRun = $true,
	
    [switch] $DeclineLastLevelOnly,
	
    [Parameter(Mandatory=$False)]
    [int] $ExclusionPeriod = 90,

    [switch] $SkipItanium,
	
	[switch] $SkipXP,
	
	[switch] $SkipPrev,
	
	[switch] $SkipBeta,

	[switch] $SkipWin10Next,
	
	[switch] $SkipServerNext,
	
	[switch] $SkipIE7,
	
	[switch] $SkipIE8 = $true,
	
	[switch] $SkipIE9 = $true,
	
	[switch] $SkipIE10 = $true,
	
	[switch] $SkipEmbedded,

    [switch] $SkipArm64,

	[bool]$EmailReport = $true,
	
	[string]$SMTPServer = "smtp.domain.com",
	
	[string]$From = "CMautomation@domain.com",
	
	[string[]]$To = "support@domain.com,yourmanager@domain.com",
	
	[string]$Subject = "WSUS/SUP Decline Updates Report",

    [string]$ReportTitle = "WSUS/SUP Decline Updates Maintenance Task"
	
	# UpdateList Folder maintenance
	[switch] $CleanUpdatelist = $true,
	
	# Define # of days old before it Cleans Update list files and folders
	[int]$CleanULNumber = 90

)



$EventSource = "WSUS Decline Maintenance"
$Eventlog = "CMSDKPosh"
$td = (get-date -uformat %m-%d-%y)
$path = Get-Location
$scriptName = $MyInvocation.MyCommand.Name
$ul = "UpdatesList"
$ulpath = "$path\" + "$ul\" + "$td"
$Overallhtmfile = "$ulpath\" + "_OverallCountsSummary-$td.htm"

#$script:CurrentErrorActionPreference = $ErrorActionPreference
#$ErrorActionPreference = "SilentlyContinue"
$CStyle = "&lt;Style&gt;BODY{font-size:12px;font-family:verdana,sans-serif;color:navy;font-weight:normal;}" + `
			"TABLE{border-width:1px;cellpadding=10;border-style:solid;border-color:navy;border-collapse:collapse;}" + `
			"TH{font-size:12px;border-width:1px;padding:10px;border-style:solid;border-color:navy;}" + `
			"TD{font-size:10px;border-width:1px;padding:10px;border-style:solid;border-color:navy;}&lt;/Style&gt;"



[String]$LogFile = "$path\" + $($((Split-Path $MyInvocation.MyCommand.Definition -leaf)).replace("ps1","log")) #Name and Location of LogFile


if ([System.Diagnostics.EventLog]::SourceExists('WSUS Decline Maintenance') -ne "True")
{
    New-EventLog -LogName $Eventlog -Source $EventSource
}

 Write-EventLog -LogName $Eventlog -EventID 21020 -Message "Run-DeclineCleanup Script has started." -Source $EventSource -EntryType Information

If($TrialRun){$Subject += " Trial Run"}
Function SendEmailStatus($From, $To, $Subject, $SMTPServer, $BodyAsHtml, $Body)
{	
    $SMTPMessage = New-Object System.Net.Mail.MailMessage $From, $To, $Subject, $Body
	$SMTPMessage.IsBodyHTML = $BodyAsHtml
	$SMTPClient = New-Object Net.Mail.SMTPClient($SMTPServer)
    $SMTPClient.Send($SMTPMessage)
	If($? -eq $False){Write-Warning "$($Error[0].Exception.Message) | $($Error[0].Exception.GetBaseException().Message)"}
	$SMTPMessage.Dispose()
	rv SMTPClient
	rv SMTPMessage
}

Function Write-toFile{
    &lt;#
    .SYNOPSIS
        Writing information to file
    .DESCRIPTION
        Function to write information to file
    #&gt;    
    Param ([string]$WriteLine)
    Out-File $XMLFile -encoding utf8 -input $WriteLine -append   
    Write-Host $WriteLine
}

Function Write-ToLog([string]$message, [string]$file) {
    &lt;#
    .SYNOPSIS
        Writing log to the logfile
    .DESCRIPTION
        Function to write logging to a logfile. This should be done in the End phase of the script.
    #&gt;
    If(-not($file)){$file=$LogFile}        
    $Date = $(get-date -uformat %Y-%m-%d-%H.%M.%S)
    $message = "$Date | `t$message"
    Write-Verbose $message
    Write-Host $message
    #Write Log to log file Without ASCII not able to read with tracer.
    Out-File $file -encoding ASCII -input $message -append
}

Function GetSuperSededList {

	$Script:countAllUpdates = 0
	$Script:countSupersededAll = 0
	$Script:countSupersededLastLevel = 0
	$Script:countSupersededExclusionPeriod = 0
	$Script:countSupersededLastLevelExclusionPeriod = 0
	$Script:countDeclined = 0
	
    $Prop = [ordered]@{}
    $ErrorActionPreference = "Stop"
    foreach($update in $allUpdates)
    {
    
        $Script:countAllUpdates++
    
        if ($update.IsDeclined) {
            $Script:countDeclined++
        }
    
        if (!$update.IsDeclined -and $update.IsSuperseded) {
            $Script:countSupersededAll++
        
            if (!$update.HasSupersededUpdates) {
                $Script:countSupersededLastLevel++
            }
			###################
            if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
				#"$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededExList -Append 
                "$($update.Title), $($update.KnowledgeBaseArticles), $($update.ArrivalDate), $($update.SecurityBulletins), $($update.UpdateClassificationTitle), $($update.ProductTitles), $($update.HasSupersededUpdates)" | Out-File $outSupersededExList -Append
		        $Script:countSupersededExclusionPeriod++
			    if (!$update.HasSupersededUpdates) {
				    $Script:countSupersededLastLevelExclusionPeriod++
			    }
            }		
        
            "$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.ArrivalDate), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededList -Append       
        
            $Prop.Title = [string]$update.Title
            $Prop."KB Article" = [string]$update.KnowledgeBaseArticles
            $Prop."Arrival Date" = [string]$update.ArrivalDate
            $Prop.Classification = [string]$update.UpdateClassificationTitle
            $Prop."Product Title" = [string]$update.ProductTitles
            $Prop."Has Superseded Updates" = [string]$update.HasSupersededUpdates
               
            New-Object PSObject -property $Prop
        }
     }
     
}

Function Decline-Superseded{
	#Write-ToLog ""
    
    Write-ToLog ""
    Write-ToLog "$WsusServer is starting Decline-SupersededUpdates function..."

	"UpdateID, RevisionNumber, Title, KBArticle, ArrivalDate, SecurityBulletin, LastLevel" | Out-File $outSupersededList
    "Title, KBArticle, ArrivalDate, SecurityBulletin, UpdateClassificationTitle, ProductTitles, HasSupersededUpdates" | Out-File $outSupersededExList


##########################

    GetSuperSededList | ConvertTo-HTML -head $CStyle | Out-File $outSupersededHTM
    

	Write-ToLog "Done."
	if ($csv){Write-ToLog "List of superseded updates: $outSupersededList"}
	Write-ToLog "List of Superseded Updates: $outSupersededHTM"

	Write-ToLog ""
	Write-ToLog "Superseded Summary:"
	Write-ToLog "========"
	Write-ToLog "All Updates = $countAllUpdates"
	Write-ToLog "Any except Declined = ($countAllUpdates - $countDeclined)"
	Write-ToLog "All Superseded Updates = $countSupersededAll"
	Write-ToLog "    Superseded Updates (Intermediate) = ($countSupersededAll - $countSupersededLastLevel)"
	Write-ToLog "    Superseded Updates (Last Level) = $countSupersededLastLevel"
	Write-ToLog "    Superseded Updates (Older than $ExclusionPeriod days) = $countSupersededExclusionPeriod"
	Write-ToLog "    Superseded Updates (Last Level Older than $ExclusionPeriod days) = $countSupersededLastLevelExclusionPeriod"
	Write-ToLog ""

	$i = 0
	if (!$TrialRun) {
	    
	    Write-ToLog "TrialRun flag is set to $TrialRun. Continuing with declining updates"
	    $updatesDeclined = 0
	    
	    if ($DeclineLastLevelOnly) {
	        Write-ToLog "  DeclineLastLevel is set to True. Only declining last level superseded updates." 
	        
	        foreach ($update in $allUpdates) {
	            
	            if (!$update.IsDeclined -and $update.IsSuperseded -and !$update.HasSupersededUpdates) {
	              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
				    $i++
					$percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededLastLevelExclusionPeriod) * 100)
					Write-Progress -Activity "Declining Updates" -Status "Declining update #$i/$countSupersededLastLevelExclusionPeriod - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
					
	                try 
	                {
	                    $update.Decline()                    
	                    $updatesDeclined++
	                }
	                catch [System.Exception]
	                {
	                    Write-ToLog "$WsusServer failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
	                    Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer failed to decline update $($update.Id.UpdateId.Guid). Error: $error[0]" -Source $EventSource -EntryType Error
	                } 
	              }             
	            }
	        }        
	    }
	    else {
	        Write-ToLog "  DeclineLastLevel is set to False. Declining all superseded updates."
	        
	        foreach ($update in $allUpdates) {
	            
	            if (!$update.IsDeclined -and $update.IsSuperseded) {
	              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {   
				  	
					$i++
					$percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededAll) * 100)
					Write-Progress -Activity "Declining Updates" -Status "Declining update #$i/$countSupersededAll - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
	                try 
	                {
	                    $update.Decline()
	                    $updatesDeclined++
	                }
	                catch [System.Exception]
	                {
	                    Write-Host "$WsusServer failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
	                    Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer failed to decline update $($update.Id.UpdateId.Guid). Error: $error[0]" -Source $EventSource -EntryType Error
	                }
	              }              
	            }
	        }   
	        
	    }
	    
	    Write-ToLog "  Declined $updatesDeclined updates."
	    #if ($updatesDeclined -ne 0) {
	    #    Copy-Item -Path $outSupersededList -Destination $outSupersededListBackup -Force
		#	Write-ToLog "  Backed up list of superseded updates to $outSupersededListBackup"
	    #}
	    
	}
	else {
	    Write-ToLog "TrialRun flag is set to $TrialRun. Skipped declining updates"
	
    if(Test-Path $outSupersededExList){ Import-csv $outSupersededExList | ConvertTo-HTML -head $table | Out-File $outSupersededExHTM}

    }
    
}

Function Decline-Itanium{


	Write-ToLog "$WsusServer is starting Decline-WsusItaniumUpdates function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."

    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Itanium updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}


    Write-ToLog "Searching for Itanium updates..."
	#$ItaniumUpdates = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match ia64|itanium}
	
	$ItaniumUpdates = $GrabUpdates | where-object {$_.Title -match "ia64|itanium"}
	$script:Itancount = $ItaniumUpdates.count
	
	If($ItaniumUpdates)
	{
		Write-ToLog "Found $script:Itancount Itanium Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Itanium Updates...";$ItaniumUpdates | %{$_.Decline()}}Else{Write-ToLog "Recording Itanium Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$ItaniumUpdates | Select $Table
            $ItaniumUpdates | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IThtmfile
            If(!$TrialRun){Write-ToLog "List of Itanium updates declined: $IThtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Itanium updates that could be declined: $IThtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Itanium Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Itanium Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Itanium Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-XPUpdates{



	Write-ToLog "$WsusServer is starting Decline-XPUpdates function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."



    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Windows XP updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Windows XP updates..."
	#$XPUpdates = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Windows XP"}
	$XPUpdates = $GrabUpdates | where-object {$_.Title -match "Windows XP"}
	$Script:XPcount = $XPUpdates.count	
	
	If($XPUpdates)
	{
		Write-ToLog "Found $Script:XPcount Windows XP Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Windows XP Updates...";$XPUpdates | %{$_.Decline()}}Else{Write-ToLog "Recording Windows XP Updates..."}
            $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$XPUpdates | Select $Table
            $XPUpdates | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $XPhtmfile
            If(!$TrialRun){Write-ToLog "List of Windows XP updates declined: $XPhtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Windows XP updates that could be declined: $XPhtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Windows XP Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Windows XP Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Windows XP Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-Preview{

	Write-ToLog "$WsusServer is starting Decline-Preview function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Preview updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Preview updates..."
	#$Prev = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Preview"}
	$Prev = $GrabUpdates | where-object {$_.Title -match "Preview"}
	$Script:Prevcount = $Prev.count	
	
	If($Prev)
	{
		Write-ToLog "Found $Script:Prevcount Preview Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Preview Updates...";$Prev | %{$_.Decline()}}Else{Write-ToLog "Recording Preview Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Prev | Select $Table
            $Prev | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Prevhtmfile
            If(!$TrialRun){Write-ToLog "List of Preview updates declined: $Prevhtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Preview updates that could be declined: $Prevhtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Preview Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Preview Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Preview Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-Beta{
	

	Write-ToLog "$WsusServer is starting Decline-Beta function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Beta updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Beta updates..."
	#$Beta= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Beta"}
	$Beta = $GrabUpdates | where-object {$_.Title -match "Beta"}
	$Script:Betacount = $Beta.count	
	
	If($Beta)
	{
		Write-ToLog "Found $Script:Betacount Beta Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Beta Updates...";$Beta | %{$_.Decline()}}Else{Write-ToLog "Recording Beta Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Beta | Select $Table
            $Beta | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Betahtmfile
            If(!$TrialRun){Write-ToLog "List of Beta updates declined: $Betahtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Beta updates that could be declined: $Betahtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Beta Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Beta Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Beta Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-Win10Next{
	
	Write-ToLog "$WsusServer is starting Decline-Win10Next function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Windows 10 Next updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Windows 10 Next updates..."
	#$Win10Next = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Windows 10 Version Next"}
	$Win10Next = $GrabUpdates | where-object {$_.Title -match "Windows 10 Version Next"}
	$Script:Win10Nextcount = $Win10Next.count	
	
	If($Win10Next)
	{
		Write-ToLog "Found $Script:Win10Nextcount Windows 10 Next Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Windows 10 Next Updates...";$Win10Next | %{$_.Decline()}}Else{Write-ToLog "Recording Windows 10 Next Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Win10Next | Select $Table
            $Win10Next | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Win10Nexthtmfile
            If(!$TrialRun){Write-ToLog "List of Windows 10 Next updates declined: $Win10Nexthtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Windows 10 Next updates that could be declined: $Win10Nexthtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Windows 10 Next Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Windows 10 Next Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Windows 10 Next Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-ServerNext{
	$Script:ServerNextcount = 0
	Write-ToLog "$WsusServer is starting Decline-ServerNext function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Windows Server Next updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Windows Server Next updates..."
	#$ServerNext = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Windows Server Next"}
	$ServerNext = $GrabUpdates | where-object {$_.Title -match "Windows Server Next"}
	$Script:ServerNextcount = $ServerNext.count	
	
	If($ServerNext)
	{
		Write-ToLog "Found $Script:ServerNextcount Windows Server Next Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Windows Server Next Updates...";$ServerNext | %{$_.Decline()}}Else{Write-ToLog "Recording Windows Server Next Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Next | Select $Table
            $ServerNext | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $ServerNexthtmfile
            If(!$TrialRun){Write-ToLog "List of Windows Server Next updates declined: $ServerNexthtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Windows Server Next updates that could be declined: $ServerNexthtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Windows Server Next Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Windows Server Next Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Windows Server Next Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-IE7{
	
	
	
	Write-ToLog "$WsusServer is starting Decline-IE7 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all IE7 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for IE7 updates..."
	#$IE7= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Internet Explorer 7"}
	$IE7 = $GrabUpdates | where-object {$_.Title -match "Internet Explorer 7"}
	$Script:IE7count = $IE7.count	
	
	If($IE7)
	{
		Write-ToLog "Found $Script:IE7count IE7 Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining IE7 Updates...";$IE7 | %{$_.Decline()}}Else{Write-ToLog "Recording IE7 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$IE7 | Select $Table
            $IE7 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IE7htmfile
            If(!$TrialRun){Write-ToLog "List of IE7 updates declined: $IE7htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of IE7 updates that could be declined: $IE7htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline IE7 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline IE7 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No IE7 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-IE8{

	Write-ToLog "$WsusServer is starting Decline-IE8 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all IE8 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for IE8 updates..."
	#$IE8= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Internet Explorer 8"}
	$IE8 = $GrabUpdates | where-object {$_.Title -match "Internet Explorer 8"}
	$Script:IE8count = $IE8.count	
	
	If($IE8)
	{
		Write-ToLog "Found $Script:IE8count IE8 Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining IE8 Updates...";$IE8 | %{$_.Decline()}}Else{Write-ToLog "Recording IE8 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$IE8 | Select $Table
            $IE8 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IE8htmfile
            If(!$TrialRun){Write-ToLog "List of IE8 updates declined: $IE8htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of IE8 updates that could be declined: $IE8htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline IE8 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline IE8 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No IE8 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-IE9{

	Write-ToLog "$WsusServer is starting Decline-IE9 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all IE9 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for IE9 updates..."
	#$IE9= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Internet Explorer 9"}
	$IE9 = $GrabUpdates | where-object {$_.Title -match "Internet Explorer 9"}
	$Script:IE9count = $IE9.count	
	
	If($IE9)
	{
		Write-ToLog "Found $Script:IE9count IE9 Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining IE9 Updates...";$IE9 | %{$_.Decline()}}Else{Write-ToLog "Recording IE9 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$IE9 | Select $Table
            $IE9 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IE9htmfile
            If(!$TrialRun){Write-ToLog "List of IE9 updates declined: $IE9htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of IE9 updates that could be declined: $IE9htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline IE9 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline IE9 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No IE9 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-Embedded{

	Write-ToLog "$WsusServer is starting Decline-Embedded function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Embedded updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Embedded updates..."
	#$Embedded= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Embedded"}
	$Embedded = $GrabUpdates | where-object {$_.Title -match "Embedded"}
	$Script:Embeddedcount = $Embedded.count	
	
	If($Embedded)
	{
		Write-ToLog "Found $Script:Embeddedcount Embedded Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Embedded Updates...";$Embedded | %{$_.Decline()}}Else{Write-ToLog "Recording Embedded Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Embedded | Select $Table
            $Embedded | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Embhtmfile
            If(!$TrialRun){Write-ToLog "List of Embedded updates declined: $Embhtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Embedded updates that could be declined: $Embhtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Embedded Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Embedded Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Embedded Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-ARM64{

	Write-ToLog "$WsusServer is starting Decline-ARM64 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all ARM64 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for ARM64 updates..."
	$Arm64 = $GrabUpdates | where-object {$_.Title -match "ARM64"}
	$Script:Arm64count = $Arm64.count	
	
	If($Arm64)
	{
		Write-ToLog "Found $Script:Arm64count ARM64-Based Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining ARM64 Updates...";$ARM64 | %{$_.Decline()}}Else{Write-ToLog "Recording ARM64 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$ARM64 | Select $Table
            $ARM64 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Arm64htmfile
            If(!$TrialRun){Write-ToLog "List of ARM64 updates declined: $Arm64htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of ARM64 updates that could be declined: $Arm64htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline ARM64 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline ARM64 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No ARM64 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-IE10{

	Write-ToLog "$WsusServer is starting Decline-IE10 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all IE10 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for IE10 updates..."
	$IE10 = $GrabUpdates | where-object {$_.Title -match "Internet Explorer 10"}
	$Script:IE10count = $IE10.count	
	
	If($IE10)
	{
		Write-ToLog "Found $Script:IE10count IE10 Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining IE10 Updates...";$IE10 | %{$_.Decline()}}Else{Write-ToLog "Recording IE10 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$IE10 | Select $Table
            $IE10 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IE10htmfile
            If(!$TrialRun){Write-ToLog "List of IE10 updates declined: $IE10htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of IE10 updates that could be declined: $IE10htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline IE10 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline IE10 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No IE10 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function UpdateListMaint{

	Write-ToLog "CleanUpdatelist is set to $CleanUpdatelist.  Cleaning the UpdateList folder."
	Write-ToLog "Deleting $CleanULNumber days old files and containers."
	Try{
		get-childitem -Path $ulpath -recurse | where-object {$_.lastwritetime -lt (get-date).addDays(-$CleanULNumber)} | Foreach-Object { remove-item $_.FullName -force -recurse}
		get-ChildItem $ulpath -recurse | Where-Object {$_.PSIsContainer -eq $True} | Where-Object {$_.GetFiles().Count -eq 0} | Foreach-Object { remove-item $_.FullName -recurse}
		Write-ToLog "Successfully removed files that are older than $CleanULNumber."
	}
	Catch
	{
		Write-ToLog "Failed to clean the UpdateList files/folder. Error: $Error[0]"
        Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Failed to clean the UpdateList files/folder. Error: $Error[0]" -Source $EventSource -EntryType Error
	    Write-ToLog "Please check the files manually."
		If($EmailReport)
			{	$Body = ConvertTo-Html -head $CStyle -Body "Failed to clean the UpdateList files/folder. Error: $Error[0].  Please check the files manually." | Out-String
				$Body = $Body.Replace("&lt;table&gt;`r`n&lt;/table&gt;", "")
				SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
				Write-ToLog "Sending Mail..."
			}

	}

}

############## Main Script ###############

Write-ToLog "####### Starting the $scriptName Script #######"
Write-ToLog ""
Write-ToLog "..."
if ($TrialRun -and $DeclineLastLevelOnly) {
    Write-ToLog "Using TrialRun and DeclineLastLevelOnly switches together is not allowed."
	Write-ToLog ""
    Write-ToLog "Exiting..."
    Exit
}

If (!(Test-Path -path $ulpath)){ New-Item -ItemType Directory $ulpath -force | Out-null }


$jeffobjects = Foreach ($WsusServer in $servers)
{
	
    $error.clear()
    $StartScript = Get-Date

    $outSupersededList = "$ulpath\" + "AllSupersededUpdates-$WsusServer.csv"
    $outSupersededListBackup = "$ulpath\" + "SupersededUpdatesBackup-$WsusServer.csv"
	$outSupersededExList = "$ulpath\" + "SupersededUpdates-Over-$ExclusionPeriod-$WsusServer.csv"
    $outSupersededExHTM = "$ulpath\" + "SupersededUpdates-Over-$ExclusionPeriod-$WsusServer.htm"
    $outSupersededHTM = "$ulpath\" + "AllSupersededUpdates-$WsusServer.htm"
    $IThtmfile = "$ulpath\" + "Itanium-Updates-$WsusServer.htm"
    $XPhtmfile = "$ulpath\" + "XP-Updates-$WsusServer.htm"
	$Prevhtmfile = "$ulpath\" + "Preview-$WsusServer.htm"
	$Betahtmfile = "$ulpath\" + "Beta-$WsusServer.htm"
	$Win10Nexthtmfile = "$ulpath\" + "Win10Next-$WsusServer.htm"
	$ServerNexthtmfile = "$ulpath\" + "ServerNext-$WsusServer.htm"
	$IE7htmfile = "$ulpath\" + "IE7-$WsusServer.htm"
	$IE8htmfile = "$ulpath\" + "IE8-$WsusServer.htm"
	$IE9htmfile = "$ulpath\" + "IE9-$WsusServer.htm"
	$IE10htmfile = "$ulpath\" + "IE10-$WsusServer.htm"
	$Embhtmfile = "$ulpath\" + "Embedded-$WsusServer.htm"
    $Arm64htmfile = "$ulpath\" + "Arm64-$WsusServer.htm"
    
	Function SendMail
	{
			If($EmailReport)
				{	$Body = ConvertTo-Html -head $CStyle -Body "Error on $WsusServer. Error: $Error[0]" | Out-String
					SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
					Write-ToLog "Sending Mail..."
				}
	}
	
    $Props = [ordered]@{}
	
	try {
	    
	    if ($UseSSL) {
	        Write-ToLog "Connecting to WSUS server $WsusServer on Port $PortNumber using SSL... "
	    } Else {
	        Write-ToLog "Connecting to WSUS server $WsusServer on Port $PortNumber... "
	    }
	    
	    [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") | out-null
	    $WsusServerAdminProxy = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($WsusServer,$UseSSL,$PortNumber);
		

	}
	catch [System.Exception] 
	{
	    $err1 = $_.Exception.Message
		Write-ToLog "Failed to connect $WsusServer. Error: $err1"
        Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Error running the $scriptName Script on $WsusServer.  Error: $err1" -Source $EventSource -EntryType Error
	    Write-ToLog "Please check the logs."
		If($EmailReport)
			{	$Body = ConvertTo-Html -head $CStyle -Body "Failed to connect $WsusServer. Error: $err1.  Script exited." | Out-String
				$Body = $Body.Replace("&lt;table&gt;`r`n&lt;/table&gt;", "")
				SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
				Write-ToLog "Sending Mail..."
			}
		Write-ToLog "Exiting..."
		Exit
	}
    
    if ($WsusServerAdminProxy) {Write-ToLog "Connected to $WsusServer."}
    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all superseded updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}


    $Props."Servername" = ("$wsusserver")

    Write-ToLog "Collecting a list of updates from $WsusServer... Please wait..."

    Try{$allUpdates = $WsusServerAdminProxy.GetUpdates()}
	Catch [System.Exception]
	{
	    $err1 = $_.Exception.Message
		Write-ToLog "Failed to collect a list of updates from $WsusServer. Error: $Error[0]"
        Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Error running the $scriptName Script on $WsusServer.  Error: $Error[0]" -Source $EventSource -EntryType Error
	    Write-ToLog "Please check the logs."
		If($EmailReport)
			{	$Body = ConvertTo-Html -head $CStyle -Body "Failed to collect a list of updates from $WsusServer. Error: $Error[0].  Please check the server manually.  Script exited." | Out-String
				$Body = $Body.Replace("&lt;table&gt;`r`n&lt;/table&gt;", "")
				SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
				Write-ToLog "Sending Mail..."
			}
		Write-ToLog "Exiting..."
		Exit
	}

	Write-ToLog "Done"

	Write-ToLog "Parsing the list of updates... " -NoNewLine

	Try{Decline-Superseded{};$Props."All Superseded" = ("$script:countSupersededAll");$Props."Superseded &gt; $ExclusionPeriod" = ("$script:countSupersededExclusionPeriod")}
	Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-SupersededUpdatesWithExclusionPeriod function on $WsusServer" -Source $EventSource -EntryType Error;	SendMail{}}
		
    Write-ToLog "Decline-SupersededUpdates function.....  Done."
	Write-ToLog ""
	
	Write-ToLog "Grabbing more updates info from $WsusServer..."
	#$GrabUpdates= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined}
    $GrabUpdates = $allUpdates | where-object {-not $_.IsDeclined}
	
	If (!$SkipItanium)
	{
		Try	{Decline-Itanium{};$Props."Itanium" = ("$Script:Itancount")}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-WsusItaniumUpdates function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
    Else
        { 
            Write-ToLog "SkipItanium is set to $SkipItanium.  Skipping Decline-WSusItaniumUpdates Function."
            $its = "Skipped"
            $Props."Itanium" = ([string]$its)
        }

	If (!$SkipXP)
	{	
		Try{Decline-XPUpdates{};$Props."Windows XP" = ($Script:XPcount)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-XPUpdates function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{
		Write-ToLog "SkipXP is set to $SkipXP.  Skipping Decline-XPUpdates Function."
		$xps = "Skipped"
		$Props."Windows XP" = ([string]$xps)
	}

	If (!$SkipPrev)
	{	
		Try{Decline-Preview{};$Props."Previews" = ("$script:Prevcount")}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-Preview function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipPrev is set to $SkipPrev.  Skipping Decline-Preview Function."
		$pvs = "Skipped"
		$Props."Previews" = ([string]$pvs)
	}
	
	If (!$SkipBeta)
	{	
		Try{Decline-Beta{};$Props."Beta" = ("$Script:Betacount")}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-Beta function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipBeta is set to $SkipBeta.  Skipping Decline-Beta Function."
		$bts = "Skipped"
		$Props."Beta" = ([string]$bts)
	}
	
	If (!$SkipWwin10Next)
	{	
		Try{Decline-Win10Next{};$Props."Windows 10 Next" = ("$Script:Win10Nextcount")}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-Win10Next function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipWin10Next is set to $SkipWin10Next.  Skipping Decline-Win10Next Function."
		$wns = "Skipped"
		$Props."Windows 10 Next" = ([string]$wns)
	}

	If (!$SkipServerNext)
	{	
		Try{Decline-ServerNext{};$Props."Server Next" = ($script:ServerNextcount)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-ServerNext function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipServerNext is set to $SkipServerNext.  Skipping Decline-ServerNext Function."
		$sns = "Skipped"
		$Props."Server 10 Next" = ([string]$sns)
	}
	
	If (!$SkipIE7)
	{	
		Try{Decline-IE7{};$Props."IE 7" = ($Script:IE7count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-IE7 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
    Else
        { 
            Write-ToLog "SkipIE7 is set to $SkipIE7.  Skipping Decline-IE7 Function."
            $i7s = "Skipped"
            $Props."IE 7" = ([string]$i7s)
         }
	
	If (!$SkipIE8)
	{	
		Try{Decline-IE8{};$Props."IE 8" = ($Script:IE8count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-IE8 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
    Else
        { 
            Write-ToLog "SkipIE8 is set to $SkipIE8.  Skipping Decline-IE8 Function."
            $i8s = "Skipped"
            $Props."IE 8" = ([string]$i8s)
         }
	
	If (!$SkipIE9)
	{	
		Try{Decline-IE9{};$Props."IE 9" = ($Script:IE9count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-IE9 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipIE9 is set to $SkipIE9.  Skipping Decline-IE9 Function."
		$i9s = "Skipped"
		$Props."IE 9" = ([string]$i9s)
		
	}

	If (!$SkipIE10)
	{	
		Try{Decline-IE10{};$Props."IE 10" = ($Script:IE10count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-IE10 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipIE10 is set to $SkipIE10.  Skipping Decline-IE10 Function."
		$i0s = "Skipped"
		$Props."IE 10" = ([string]$i0s)
		
	}

	If (!$SkipEmbedded)
	{	
		Try{Decline-Embedded{};$Props."Windows Embedded" = ($Script:Embeddedcount)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-Embedded function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipEmbedded is set to $SkipEmbedded.  Skipping Decline-Embedded Function."
		$ems = "Skipped"
		$Props."Windows Embedded" = ([string]$ems)
	}

	If (!$SkipArm64)
	{	
		Try{Decline-ARM64{};$Props."ARM64 Based" = ($Script:Arm64count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-ARM64 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipArm64 is set to $SkipArm64.  Skipping Decline-ARM64 Function."
		$arm = "Skipped"
		$Props."ARM64 Based" = ([string]$arm)
	}

    if ($error)
    {
        Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Error running the $scriptName Script on $WsusServer.  Error: $error{0}" -Source $EventSource -EntryType Error
		SendMail{}
    }
    Else
    {

     Write-EventLog -LogName $Eventlog -EventID 21020 -Message "$scriptName Script has completed successfully on $WsusServer." -Source $EventSource -EntryType Information
    }

    #$row = $table.NewRow()

	Write-ToLog ""
	Write-ToLog "Done with $WsusServer... "
	Write-ToLog ""
	Write-ToLog "=========================="
	Write-ToLog "Overall Summary for $WsusServer"
	Write-ToLog "=========================="
	Write-ToLog "    Total Superseded Updates (Older than $ExclusionPeriod days) = $script:countSupersededExclusionPeriod"
	Write-ToLog "    Total Itanium Updates = $script:Itancount. $its"
	Write-ToLog "    Total Windows XP Updates = $Script:XPcount. $xts"
	Write-ToLog "    Total Preview Updates = $Script:Prevcount. $pvs"
	Write-ToLog "    Total Beta Updates = $Script:Betacount. $bts"
	Write-ToLog "    Total Windows 10 Next Updates = $Script:Win10Nextcount. $wns"
	Write-ToLog "    Total Windows Server Next Updates = $Script:ServerNextcount. $sns"
	Write-ToLog "    Total ARM64-Based Updates = $Script:Arm64count. $arm"
	Write-ToLog "    Total Windows Embedded Updates = $Script:Embeddedcount. $ems"
	Write-ToLog "    Total IE 7 Updates = $Script:IE7count. $i7s"
	Write-ToLog "    Total IE 8 Updates = $Script:IE8count. $i8s"
	Write-ToLog "    Total IE 9 Updates = $Script:IE9count. $i9s"
	Write-ToLog "    Total IE 10 Updates = $Script:IE10count. $i0s"
	
    
	Write-ToLog ""
	If (!$TrialRun){Write-ToLog "These Updates were declined, unless Skipped."}Else{Write-ToLog "Updates were ONLY recorded. See UpdatesList folder."}
	Write-ToLog "=========================="
	Write-ToLog "=========================="
	Write-ToLog ""

    $Props."TrialRun" = ($TrialRun)
   
    $StopScript = Get-Date
    $timespan = new-timespan -seconds $(($StopScript-$startScript).totalseconds) 
    $ScriptTime = '{0:00}h:{1:00}m:{2:00}s' -f $timespan.Hours,$timespan.Minutes,$timespan.Seconds
	Write-ToLog "$WsusServer Run Time: $ScriptTime"
	Write-ToLog "=========================="
	Write-ToLog ""

    $Props."Run Time" = ($ScriptTime)

    New-Object PSObject -property $Props
}

$jeffobjects | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Overallhtmfile

If($CleanUpdatelist){UpdateListMaint{}}

If($EmailReport)
	{	
        $Body = "&lt;p class=MsoTitle&gt;&lt;span style='font-size:20pt;font-family:Verdana,sans-serif'&gt;$ReportTitle&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;"
        $Body += $jeffobjects | Select $Table | ConvertTo-HTML -head $CStyle -PostContent "&lt;h6&gt;Created $(Get-Date)&lt;/h6&gt;&lt;br&gt;$from"
		SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
	}
	
Write-ToLog "====&gt;  Done  &lt;===="
Write-ToLog "All target WSUS/SUP servers have been completed."
Write-ToLog "See $Overallhtmfile."
Write-ToLog "=========================================="

=================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Start-WsusServerSync.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Start-WsusServerSync.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://gallery.technet.microsoft.com/scriptcenter/Synchronize-all-WSUS-00c899c2
#'Start-WsusServerSync.ps1

Param(
	$WsusServer = ([system.net.dns]::GetHostByName('localhost')).hostname,
	[switch]$Recursive,
	[bool]$TrialRun = $True,
	[int]$SleepTime = 60,
	[string]$SmtpServer = "smtp.company.com",
	[string]$From = "wsus@company.com",
	[string]$To = "wsus@company.com",
	[string]$Subject = "WSUS Server Synchronization.",
	[switch]$EmailLog
)
Begin
{	$script:CurrentErrorActionPreference = $ErrorActionPreference
	$script:Output = @()
	$script:ProcessedServers = @()
	$WsusAssembly = [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")
	If($WsusAssembly -eq $Null)
	{	throw "Loading Microsoft.UpdateServices.Administration failed. Are you running this on a machine with the WSUS 3.0 SP2 Administration Console installed? http://technet.microsoft.com/en-us/library/dd939875(v=ws.10).aspx"}

	$ErrorActionPreference = "SilentlyContinue"
	If($EmailLog)
	{	If($Recursive)
		{	$Table = @{Name="Parent Wsus Server";expression={$_.ParentWsusServer}},@{Name="Wsus Server";expression={$_.WsusServer}},@{Name="Port Number";expression={$_.PortNumber}},@{Name="Using SSL";expression={$_.UsingSSL}},@{Name="Version";expression={$_.Version}},@{Name="Start";expression={$_.Start}},@{Name="Finish";expression={$_.Finish}}
		}
		Else
		{	$Table = @{Name="Wsus Server";expression={$_.WsusServer}},@{Name="Port Number";expression={$_.PortNumber}},@{Name="Using SSL";expression={$_.UsingSSL}},@{Name="Version";expression={$_.Version}},@{Name="Start";expression={$_.Start}},@{Name="Finish";expression={$_.Finish}}
		}
		If($TrialRun -eq $False)
		{	$Table += @{Name="Categories";expression={$_.Categories}},@{Name="Updates";expression={$_.Updates}},@{Name="Approvals";expression={$_.Approvals}},@{Name="LastSyncResult";expression={$_.LastSyncResult}}
		}
		$Style = "&lt;Style&gt;BODY{font-size:12px;font-family:verdana,sans-serif;color:navy;font-weight:normal;}" + `
		"TABLE{border-width:1px;cellpadding=10;border-style:solid;border-color:navy;border-collapse:collapse;}" + `
		"TH{font-size:12px;border-width:1px;padding:10px;border-style:solid;border-color:navy;}" + `
		"TD{font-size:10px;border-width:1px;padding:10px;border-style:solid;border-color:navy;}&lt;/Style&gt;"
		Function SendEmailStatus($From, $To, $Subject, $SmtpServer, $BodyAsHtml, $Body)
		{	$SmtpMessage = New-Object System.Net.Mail.MailMessage $From, $To, $Subject, $Body
			$SmtpMessage.IsBodyHTML = $BodyAsHtml
			$SmtpClient = New-Object System.Net.Mail.SmtpClient $SmtpServer
			$SmtpClient.Send($SmtpMessage)
			If($? -eq $False){Write-Warning "$($Error[0].Exception.Message) | $($Error[0].Exception.GetBaseException().Message)"}
			$SmtpMessage.Dispose()
			rv SmtpClient
			rv SmtpMessage
		}
	}

	function Get-HKLMValue
	{	Param(
  		[string]$computername=".",
  		[string]$key = "SOFTWARE\Microsoft\Update Services\Server\Setup",
  		[string]$value,
  		[switch]$REG_SZ,
  		[switch]$REG_DWORD
  	)
		$HKLM = 2147483650
		$reg = [wmiclass]"\\$computername\root\default:StdRegprov"
		If($REG_SZ)
		{	$Result = $reg.GetStringValue($HKLM,$key,$value)
			If($Result.ReturnValue -eq 0){$Result.sValue}
		}
		If($REG_DWORD)
		{	$Result = $reg.GetDwordValue($HKLM,$key,$value)
			If($Result.ReturnValue -eq 0){$Result.uValue}
		}
	}

	function Start-Pause
	{	Param(
			[int]$SleepTime = 10,
			[int]$ID = 1,
			[int]$ParentID,
			[string]$Activity = "Just taking a quick breather after all that activity..."
		)
		for($x = 1 ; $x -le $SleepTime; $x++)
		{	If(!$ParentID)
			{	Write-progress -Activity $Activity -Status "Seconds Remaining: $($SleepTime-$x)" -PercentComplete ($x/$SleepTime*100) -ID $ID}
			Else	
			{	Write-progress -Activity $Activity -Status "Seconds Remaining: $($SleepTime-$x)" -PercentComplete ($x/$SleepTime*100) -ID $ID -ParentId $ParentID}
			Sleep 1
		}
		Write-progress -Activity $Activity -Status "Done sleeping..." -Completed -ID $ID
	}

	Function Sync-WsusServer
	{	Param(
			$WsusServer,
			$ParentWsusServer
		)
		Write-Progress -Activity "Processing server: $WsusServer" -Status "Started at $((get-date).DateTime)" -ID 2 -ParentID 1
		Write-Progress -Activity "Retrieving PortNumber value from the registry via StdRegprov ..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
		$PortNumber = Get-HKLMValue -Computername $WsusServer -value PortNumber -REG_DWORD
		Write-Progress -Activity "Retrieving UsingSSL value from the registry via StdRegprov ..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
		$UsingSSL = If((Get-HKLMValue -Computername $WsusServer -value UsingSSL -REG_DWORD) -eq 1){$True}Else{$False}
		If($UsingSSL)
		{ Write-Progress -Activity "Retrieving ServerCertificateName value from the registry via StdRegprov ..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
			$ServerCertificateName = Get-HKLMValue -Computername $WsusServer -value ServerCertificateName -REG_SZ
			If($ServerCertificateName){$WsusServer = $ServerCertificateName}
		}
		If($script:ProcessedServers -Contains $WsusServer)
		{	Write-Warning "$WsusServer appears to have already been processed. You may have a circular loop in your hierarchy."}
		Else
		{	$script:ProcessedServers += $WsusServer
			$Object = New-Object psobject
			If($Recursive)
			{	If(!$ParentWsusServer){$ParentWsusServer = "--"}
				$Object | Add-Member NoteProperty ParentWsusServer $ParentWsusServer
			}
			$Object | Add-Member NoteProperty WsusServer $WsusServer -PassThru | Add-Member NoteProperty PortNumber $PortNumber -PassThru | 
				Add-Member NoteProperty UsingSSL $UsingSSL -PassThru | Add-Member NoteProperty Version "" -PassThru |
				Add-Member NoteProperty Start (get-date).DateTime -PassThru | Add-Member NoteProperty Finish ""
			If($TrialRun -eq $False)
			{	$Object | Add-Member NoteProperty Categories "--" -PassThru | 
					Add-Member NoteProperty Updates "--" -PassThru | 
					Add-Member NoteProperty Approvals "--" -PassThru | 
					Add-Member NoteProperty LastSyncResult ""
			}
			Write-Progress -Activity "Connecting to UpdateServices AdminProxy..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
			$WsusServerAdminProxy = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($WsusServer,$UsingSSL,$PortNumber)
			If ($? -eq $False)
			{	$Object.Version = $Error[0]
				Write-Warning "Failed to connect to $WsusServer $($Error[0])"
				$Object.Finish = (get-date).DateTime
				$Object
				If($EmailLog){$script:Output += $Object}
			}
			Else
			{	$Object.Version = $WsusServerAdminProxy.Version
				If($TrialRun -eq $False)
				{	Write-Progress -Activity "Connecting to the Subscription..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
					$Subscription = $WsusServerAdminProxy.GetSubscription();
					Write-Progress -Activity "Calling StartSynchronization on $WsusServer" -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
					$Subscription.StartSynchronization()
					$SynchronizationProgress = $Subscription.GetSynchronizationProgress()
					While ($SynchronizationProgress.Phase.ToString() -eq "NotProcessing")
					{	Start-Sleep -Milliseconds 100
						$SynchronizationProgress = $Subscription.GetSynchronizationProgress()
					}
					While ($SynchronizationProgress.Phase.ToString() -ne "NotProcessing")
					{	If($SynchronizationProgress.Phase.ToString() -eq "Categories")
						{$Object.Categories = $SynchronizationProgress.TotalItems}
						If($SynchronizationProgress.Phase.ToString() -eq "Updates")
						{	$Object.Updates = $SynchronizationProgress.TotalItems}
						If($SynchronizationProgress.Phase.ToString() -eq "Approvals")
						{$Object.Approvals = $SynchronizationProgress.TotalItems}
						Write-Progress -Activity "Synchronization Phase: $($SynchronizationProgress.Phase.ToString())" -Status "$($SynchronizationProgress.ProcessedItems) of $($SynchronizationProgress.TotalItems) items done..." -PercentComplete ($SynchronizationProgress.ProcessedItems*100/($SynchronizationProgress.TotalItems)) -ID 4 -ParentId 3
						$SynchronizationProgress = $Subscription.GetSynchronizationProgress()
					}
					$Object.LastSyncResult = $Subscription.GetLastSynchronizationInfo().Result
					Write-Progress -Activity "Synchronization Phase: $($SynchronizationProgress.Phase.ToString())" -Status "Complete." -ID 4 -ParentId 3 -Completed
				}
				$Object.Finish = (get-date).DateTime
				$Object
				If($EmailLog){$script:Output += $Object}
				If($Recursive -And $TrialRun -eq $False){Start-Pause -Activity "Processed $($script:ProcessedServers.Count) server(s). The script is pausing for $SleepTime seconds starting at $((get-date).DateTime)." -SleepTime $SleepTime -ID 3 -ParentID 2}
				If($Recursive)
				{	Write-Progress -Activity "Retrieving Downstream Servers on $WsusServer..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
					$WsusDownstreamServers = $WsusServerAdminProxy.GetDownstreamServers()
					If($WsusDownstreamServers){$WsusDownstreamServers | %{Sync-WsusServer -WsusServer $_.FullDomainName -ParentWsusServer $WsusServer}}
				}
			}
		}
	}
	Write-Progress -Activity "WSUS Server Synchronization." -Status "Started at $((get-date).DateTime)" -ID 1
}
Process
{	If($WsusServer)
	{	ForEach($Server in $WsusServer){Sync-WsusServer $Server}
	}
	Else
	{	Sync-WsusServer $_
	}
}
End
{	If($EmailLog){SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body ($Output | Select $Table | ConvertTo-HTML -head $Style)}
	$ErrorActionPreference = $script:CurrentErrorActionPreference
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WindowsUpdate_Module</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WindowsUpdate_Module</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'WindowsUpdate.psm1
#'https://github.com/adbertram/Random-PowerShell-Work/blob/master/Software%20Updates/WindowsUpdate.psm1

Set-StrictMode -Version Latest

function Get-WindowsUpdate {
	&lt;#
		.SYNOPSIS
			This function retrieves a list of Microsoft updates based on a number of different criteria for a remote
			computer. It will retrieve these updates over a PowerShell remoting session. It uses the update source set
			at the time of query. If it's set to WSUS, it will only return updates that are advertised to the computer
			by WSUS.
	
		.EXAMPLE
			PS&gt; Get-WindowsUpdate -ComputerName FOO
		.PARAMETER ComputerName
			 A mandatory string parameter representing the FQDN of a computer. This is only mandatory is Session is
			 not used.
		.PARAMETER Credential
			 A optoional pscredential parameter representing an alternate credential to connect to the remote computer.
		.PARAMETER Session
			 A mandatory PSSession parameter representing a PowerShell remoting session created with New-PSSession. This
			 is only mandatory if ComputerName is not used.
		
		.PARAMETER Installed
			 A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			 updates on this criteria.
		.PARAMETER Hidden
			 A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			 updates on this criteria.
		.PARAMETER Assigned
			A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			updates on this criteria.
		.PARAMETER RebootRequired
			A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			updates on this criteria.
	#&gt;
	[OutputType([System.Management.Automation.PSObject])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory, ParameterSetName = 'ByComputerName')]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName,

		[Parameter(ParameterSetName = 'ByComputerName')]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential,

		[Parameter(Mandatory, ParameterSetName = 'BySession')]
		[ValidateNotNullOrEmpty()]
		[System.Management.Automation.Runspaces.PSSession]$Session,
        
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('MicrosoftUpdate')]
		[string]$Source,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$Installed = 'False',

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$Hidden,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$Assigned,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$RebootRequired
	)
	begin {
		$ErrorActionPreference = 'Stop'
		if (-not $Session) {
			$sessParams = @{
				ComputerName = $ComputerName
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$sessParams.Credential = $Credential
			}
			$Session = New-PSSession @sessParams
		}
	}
	process {
		try {
			$criteriaParams = @{}

			## Had to set these to string values because if they're boolean they will have a $false value even if
			## they aren't set.  I needed to check for a $null value.ided
			@('Installed', 'Hidden', 'Assigned', 'RebootRequired').where({ (Get-Variable -Name $_).Value }).foreach({
					$criteriaParams[$_] = if ((Get-Variable -Name $_).Value -eq 'True') {
						$true 
					} else {
						$false 
					}
				})
			$query = NewUpdateCriteriaQuery @criteriaParams
			Write-Verbose -Message "Using the update criteria query: [$($Query)]..."
			$searchParams = @{
				Session = $Session
				Query   = $query
			}
			if ($PSBoundParameters.ContainsKey('Source')) {
				$searchParams.Source = $Source
			}
			SearchWindowsUpdate @searchParams
		} catch {
			Write-Error $_.Exception.Message
		} finally {
			## Only clean up the session if it was generated from within this function. This is because updates
			## are stored in a variable to be used again by other functions, if necessary.
			if (($PSCmdlet.ParameterSetName -eq 'ByComputerName') -and (Test-Path Variable:\session)) {
				$session | Remove-PSSession
			}
		}
	}
}

function Install-WindowsUpdate {
	&lt;#
		.SYNOPSIS
			This function retrieves all updates that are targeted at a remote computer, download and installs any that it
			finds. Depending on how the remote computer's update source is set, it will either read WSUS or Microsoft Update
			for a compliancy report.
			Once found, it will download each update, install them and then read output to detect if a reboot is required
			or not.
	
		.EXAMPLE
			PS&gt; Install-WindowsUpdate -ComputerName FOO.domain.local
		.EXAMPLE
			PS&gt; Install-WindowsUpdate -ComputerName FOO.domain.local,FOO2.domain.local			
		
		.EXAMPLE
			PS&gt; Install-WindowsUpdate -ComputerName FOO.domain.local,FOO2.domain.local -ForceReboot
		.PARAMETER ComputerName
			 A mandatory string parameter representing one or more computer FQDNs.
		.PARAMETER Credential
			 A optional pscredential parameter representing an alternate credential to connect to the remote computer.
		
		.PARAMETER ForceReboot
			 An optional switch parameter to set if any updates on any computer targeted needs a reboot following update
			 install. By default, computers are NOT rebooted automatically. Use this switch to force a reboot.
		
		.PARAMETER AsJob
			 A optional switch parameter to set when activity needs to be sent to a background job. By default, this function 
			 waits for each computer to finish. However, if this parameter is used, it will start the process on each
			 computer and immediately return a background job object to then monitor yourself with Get-Job.
	#&gt;
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string[]]$ComputerName,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('MicrosoftUpdate')]
		[string]$Source,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[switch]$ForceReboot,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[switch]$AsJob
	)
	begin {
		$ErrorActionPreference = 'Stop'

		$scheduledTaskName = 'Windows Update Install'

	}
	process {
		try {
			$getParams = @{}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$getParams.Credential = $Credential
			}
			if ($PSBoundParameters.ContainsKey('Source')) {
				$getParams.Source = $Source
			}
			@($ComputerName).foreach({
					$getParams.ComputerName = $_
					if (-not (Get-WindowsUpdate @getParams)) {
						Write-Verbose -Message 'No updates needed to install. Skipping computer...'
					} else {
						$installProcess = {
							param($ComputerName, $TaskName, $Credential, $ForceReboot)
							$VerbosePreferences = 'Continue'
							try {
								$sessParams = @{ ComputerName = $ComputerName }
								if ($Credential) {
									$sessParams.Credential = $Credential
								}
							
								$session = New-PSSession @sessParams

								$scriptBlock = {
									$updateSession = New-Object -ComObject 'Microsoft.Update.Session'
									$objSearcher = $updateSession.CreateUpdateSearcher()
									if ($using:Source -eq 'MicrosoftUpdate') {
										$objSearcher.ServerSelection = 3
									}
									if ($updates = ($objSearcher.Search('IsInstalled=0'))) {
										$updates = $updates.Updates

										$downloader = $updateSession.CreateUpdateDownloader();
										$downloader.Updates = $updates;
										$downloadResult = $downloader.Download();
										if ($downloadResult.ResultCode -ne 2) {
											exit $downloadResult.ResultCode;
										}

										$installer = New-Object -ComObject Microsoft.Update.Installer;
										$installer.Updates = $updates;
										$installResult = $installer.Install();
										if ($installResult.RebootRequired) {
											exit 7;
										} else {
											$installResult.ResultCode
										}
									} else {
										exit 6;
									}
								}
							
								$taskParams = @{
									Session     = $session
									Name        = $TaskName
									Scriptblock = $scriptBlock
									PassThru    = $true
								}
								Write-Verbose -Message 'Creating scheduled task...'
								if (-not ($task = NewWindowsUpdateScheduledTask @taskParams)) {
									throw "Failed to create scheduled task."
								}

								Write-Verbose -Message "Starting scheduled task [$($task.TaskName)]..."

								$icmParams = @{
									Session      = $session
									ScriptBlock  = { Start-ScheduledTask -TaskName $args[0] }
									ArgumentList = $task.TaskName
									Verbose      = $true
								}
								Invoke-Command @icmParams
                                
								$waitParams = @{
									ComputerName = $_
								}
								if ($Credential) {
									$waitParams.Credential = $Credential
								}
								Wait-ScheduledTask @waitParams -Name $task.TaskName

								$installResult = GetWindowsUpdateInstallResult -Session $session

								if ($installResult -eq 'NoUpdatesNeeded') {
									Write-Verbose -Message "No updates to install"
								} elseif ($installResult -eq 'RebootRequired') {
									if ($ForceReboot) {
										Restart-Computer -ComputerName $ComputerName -Force -Wait;
									} else {
										Write-Warning "Reboot required but -ForceReboot was not used."
									}
								} else {
									throw "Updates failed. Reason: [$($installResult)]"
								}
							
							} catch {
								$PSCmdlet.ThrowTerminatingError($_)
							} finally {
								Remove-ScheduledTask @getParams -Name $TaskName
							}
						}

						$blockArgs = $_, $scheduledTaskName, $Credential, $ForceReboot.IsPresent
						if ($AsJob.IsPresent) {
							Start-Job -ScriptBlock $installProcess -Name "$_ - Windows Update Install" -ArgumentList $blockArgs
						} else {
							Invoke-Command -ScriptBlock $installProcess -ArgumentList $blockArgs
						}
					}
				})
		} catch {
			Write-Error $_.Exception.Message
		} finally {
			# Remove any sessions created. This is done when processes aren't invoked under a PS job
			$sessParams = @{
				ComputerName = $ComputerName
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$sessParams.Credential = $Credential
			}
			@(Get-PSSession @sessParams).foreach({
					Remove-PSSession -Session $_
				})
		}
	}
}

function GetWindowsUpdateInstallResult {
	[OutputType([string])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[System.Management.Automation.Runspaces.PSSession]$Session,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[string]$ScheduledTaskName = 'Windows Update Install'
	)

	$sb = { (Get-ScheduledTask -TaskName $args[0] | Get-ScheduledTaskInfo).LastTaskResult }
	$resultCode = Invoke-Command -Session $Session -ScriptBlock $sb -ArgumentList $ScheduledTaskName
	switch -exact ($resultCode) {
		0   {
			'Installed'
			break
		}
		1   {
			'InProgress'
			break
		}
		2   {
			'Installed'
			break
		}
		3   {
			'InstalledWithErrors'
			break
		}
		4   {
			'Failed'
			break
		}
		5   {
			'Aborted'
			break
		}
		6   {
			'NoUpdatesNeeded'
			break
		}
		7   {
			'RebootRequired'
			break
		}
		267009 {
			'TimedOut'
			break
		}
		default {
			"Unknown exit code [$($_)]"
		}
	}
}

function NewUpdateCriteriaQuery {
	[OutputType([string])]
	[CmdletBinding()]
	param
	(
		[Parameter()]
		[bool]$Installed,

		[Parameter()]
		[bool]$Hidden,

		[Parameter()]
		[bool]$Assigned,

		[Parameter()]
		[bool]$RebootRequired
	)

	$conversion = @{
		Installed      = 'IsInstalled'
		Hidden         = 'IsHidden'
		Assigned       = 'IsAssigned'
		RebootRequired = 'RebootRequired'
	}

	$queryElements = @()
	$PSBoundParameters.GetEnumerator().where({ $_.Key -in $conversion.Keys }).foreach({
			$queryElements += '{0}={1}' -f $conversion[$_.Key], [int]$_.Value
		})
	$queryElements -join ' and '
}

function SearchWindowsUpdate {
	[OutputType()]
	[CmdletBinding()]
	param
	(
		[Parameter()]
		[string]$Query,
        
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[string]$Source,

		[Parameter()]
		[System.Management.Automation.Runspaces.PSSession]$Session
	)

	$scriptBlock = {
		$objSession = New-Object -ComObject 'Microsoft.Update.Session'
		$objSearcher = $objSession.CreateUpdateSearcher()
		if ($using:Source -eq 'MicrosoftUpdate') {
			$objServiceManager = New-Object -ComObject "Microsoft.Update.ServiceManager"
			$objSearcher.ServerSelection = 3
			$objServiceManager.Services | Where-Object { $_.Name -eq 'Microsoft Update' } | Foreach {
				$objSearcher.ServiceID = $_.ServiceID
			}
		}
		if ($updates = ($objSearcher.Search($args[0]))) {
			$updates = $updates.Updates
			## Save the updates needed to the file system for other functions to pick them up to download/install later.
			$updates | Export-CliXml -Path "$env:TEMP\Updates.xml"
			$updates
		}
		
	}
	Invoke-Command -Session $Session -ScriptBlock $scriptBlock -ArgumentList $Query
}

function NewWindowsUpdateScheduledTask {
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[System.Management.Automation.Runspaces.PSSession]$Session,

		[Parameter(Mandatory)]
		[string]$Name,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[scriptblock]$Scriptblock,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[switch]$PassThru
	)

	if (TestWindowsUpdateScheduledTask -Session $Session -Name $Name) {
		Write-Verbose -Message "A windows update install task already exists. Removing..."
		Remove-ScheduledTask -ComputerName $Session.ComputerName -Name $Name
	}

	$createStartSb = {
		$action = New-ScheduledTaskAction -Execute 'powershell.exe' -Argument $args[1]
		$principal = New-ScheduledTaskPrincipal -UserId $args[3] -LogonType Password
		$settings = New-ScheduledTaskSettingsSet -StartWhenAvailable -Hidden
		$task = New-ScheduledTask -Action $action -Settings $settings -Principal $principal
		$regTask = Register-ScheduledTask -InputObject $task -TaskName $args[0]
		if ($args[2].IsPresent) {
			$regTask
		}
	}

	$psArgs = '-NonInteractive -NoProfile -Command "{0}"' -f $Scriptblock.ToString()

	$icmParams = @{
		Session      = $Session
		ScriptBlock  = $createStartSb
		ArgumentList = $Name, $psArgs, $PassThru
	}
	if ($PSBoundParameters.ContainsKey('Credential')) {
		$icmParams.ArgumentList += $Credential.UserName	
	} else {
		$icmParams.ArgumentList += 'SYSTEM'
	}
	
	Invoke-Command @icmParams
	
}

function TestWindowsUpdateScheduledTask {
	[OutputType([bool])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[System.Management.Automation.Runspaces.PSSession]$Session,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$Name
	)
	$testScriptBlock = {
		if (Get-ScheduledTask -TaskName $args[0] -ErrorAction Ignore) {
			$true
		} else {
			$false
		}
	}

	Invoke-Command -Session $Session -ScriptBlock $testScriptBlock -ArgumentList $Name
}

function Wait-WindowsUpdate {
	&lt;#
		.SYNOPSIS
			This function looks for any currently running background jobs that were created by Install-WindowsUpdate
			and continually waits for all of them to finish before returning control to the console.
	
		.EXAMPLE
			PS&gt; Wait-WindowsUpdate
		
		.PARAMETER Timeout
			 An optional integer parameter representing the amount of seconds to wait for the job to finish.
	
	#&gt;
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[int]$Timeout = 3600
	)
	process {
		try {
			if ($updateJobs = (Get-Job -Name '*Windows Update Install*').where({ $_.State -eq 'Running'})) {
				$timer = Start-Timer
				while ((Microsoft.PowerShell.Core\Get-Job -Id $updateJobs.Id | Where-Object { $_.State -eq 'Running' }) -and ($timer.Elapsed.TotalSeconds -lt $Timeout)) {
					Write-Verbose -Message "Waiting for all Windows Update install background jobs to complete..."
					Start-Sleep -Seconds 3
				}
				Stop-Timer -Timer $timer
			}
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}

function Remove-ScheduledTask {
	&lt;#
		.SYNOPSIS
			This function looks for a scheduled task on a remote system and, once found, removes it.
	
		.EXAMPLE
			PS&gt; Remove-ScheduledTask -ComputerName FOO -Name Task1
		
		.PARAMETER ComputerName
			 A mandatory string parameter representing a FQDN of a remote computer.
		.PARAMETER Name
			 A mandatory string parameter representing the name of the scheduled task. Scheduled tasks can be retrieved
			 by using the Get-ScheduledTask cmdlet.
		.PARAMETER Credential
			 Specifies a user account that has permission to perform this action. The default is the current user.
			 
			 Type a user name, such as 'User01' or 'Domain01\User01', or enter a variable that contains a PSCredential
			 object, such as one generated by the Get-Credential cmdlet. When you type a user name, you will be prompted for a password.
	
	#&gt;
	[OutputType([void])]
	[CmdletBinding(SupportsShouldProcess)]
	param
	(
		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential	
	)
	begin {
		$ErrorActionPreference = 'Stop'
	}
	process {
		try {
			$icmParams = @{
				ComputerName = $ComputerName
				ArgumentList = $Name
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$icmParams.Credential = $Credential
			}
			
			$sb = { 
				if ($task = Get-ScheduledTask -TaskName $args[0] -ErrorAction Ignore) {
					$task | Unregister-ScheduledTask -Confirm:$false
				}
			}

			if ($PSCmdlet.ShouldProcess("Remove scheduled task [$($Name)] from [$($ComputerName)]", '----------------------')) {
				Invoke-Command @icmParams -ScriptBlock $sb	
			}
		} catch {
			Write-Error -Message $_.Exception.Message
		}
	}
}

function Wait-ScheduledTask {
	&lt;#
		.SYNOPSIS
			This function looks for a scheduled task on a remote system and, once found, checks to see if it's running.
			If so, it will wait until the task has completed and return control.
	
		.EXAMPLE
			PS&gt; Wait-ScheduledTask -ComputerName FOO -Name Task1 -Timeout 120
		
		.PARAMETER ComputerName
			 A mandatory string parameter representing a FQDN of a remote computer.
		.PARAMETER Name
			 A mandatory string parameter representing the name of the scheduled task. Scheduled tasks can be retrieved
			 by using the Get-ScheduledTask cmdlet.
		.PARAMETER Timeout
			 A optional integer parameter representing how long to wait for the scheduled task to complete. By default,
			 it will wait 3600 seconds.
		.PARAMETER Credential
			 Specifies a user account that has permission to perform this action. The default is the current user.
			 
			 Type a user name, such as 'User01' or 'Domain01\User01', or enter a variable that contains a PSCredential
			 object, such as one generated by the Get-Credential cmdlet. When you type a user name, you will be prompted for a password.
	
	#&gt;
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[int]$Timeout = 3600, ## seconds

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential
	)
	begin {
		$ErrorActionPreference = 'Stop'
	}
	process {
		try {
			$sessParams = @{
				ComputerName = $ComputerName
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$sessParams.Credential = $Credential
			}
			$session = New-PSSession @sessParams

			$scriptBlock = {
				$VerbosePreference = 'Continue'
				$timer = [Diagnostics.Stopwatch]::StartNew()
				while (((Get-ScheduledTask -TaskName $args[0]).State -ne 'Ready') -and ($timer.Elapsed.TotalSeconds -lt $args[1])) {
					Write-Verbose -Message "Waiting on scheduled task [$($args[0])]"
					Start-Sleep -Seconds 3
				}
				$timer.Stop()
				Write-Verbose -Message "We waited [$($timer.Elapsed.TotalSeconds)] seconds on the task [$($args[0])]"
			}

			Invoke-Command -Session $session -ScriptBlock $scriptBlock -ArgumentList $Name, $Timeout
		} catch {
			Write-Error -Message $_.Exception.Message
		} finally {
			if (Test-Path Variable:\session) {
				$session | Remove-PSSession
			}
		}
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Validation</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_likeTheSnippet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Validation</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_likeTheSnippet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Function Get-DiskCheck {

[cmdletbinding(DefaultParameterSetName = "name")]

Param(
[Parameter(Position = 0, Mandatory, 
HelpMessage = "Enter a computer name to check",
ParameterSetName = "name",
ValueFromPipeline)]
[Alias("cn")]
[ValidateNotNullorEmpty()]
[string[]]$Computername,

[Parameter(Mandatory,
HelpMessage = "Enter the path to a text file of computer names",
ParameterSetName = "file"
)]
[ValidateScript({
if (Test-Path $_) {
   $True
}
else {
   Throw "Cannot validate path $_"
}
})]     
[ValidatePattern("\.txt$")]
[string]$Path,

[ValidateRange(10,50)]
[int]$Threshhold = 25,

[ValidateSet("C:","D:","E:","F:")]
[string]$Drive = "C:",

[switch]$Test
)

Begin {
    Write-Verbose "[BEGIN  ] Starting: $($MyInvocation.Mycommand)"  

    $cimParam = @{
        Classname = "Win32_LogicalDisk"
        Filter = "DeviceID='$Drive'"
        Computername = $Null
        ErrorAction = "Stop"
    }
} #begin

Process {

    if ($PSCmdlet.ParameterSetName -eq 'name') {
        $names = $Computername
    }
    else {
        #get list of names and trim off any extra spaces
        Write-Verbose "[PROCESS] Importing names from $path"
        $names = Get-Content -Path $path | Where {$_ -match "\w+"} | foreach {$_.Trim()}

    }

    if ($test) {
        Write-Verbose "[PROCESS] Testing connectivity"
        #ignore errors for offline computers
        $names = $names | Where {Test-WSMan $_ -ErrorAction SilentlyContinue}
    }
    
    foreach ($computer in $names) {
        $cimParam.Computername = $Computer
        Write-Verbose "[PROCESS] Querying $($computer.toUpper())"
        Try {
            $data = Get-Ciminstance @cimParam

            #write custom result to the pipeline
            $data | Select PSComputername,
            DeviceID,Size,Freespace,
            @{Name="PctFree";Expression = {[math]::Round(($_.freespace/$_.size)*100,2)}},
            @{Name="OK";Expression = {
              [int]$p = ($_.freespace/$_.size)*100
              if ($p -ge $Threshhold) {
                $True
              } else {
                $false
              }
            }},@{Name="Date";Expression={(Get-Date)}}
        }
        Catch {
            Write-Warning "[$($computer.toUpper())] Failed. $($_.Exception.message)"
        }
    } #foreach computer

} #process

End {
    Write-Verbose "[END    ] Ending: $($MyInvocation.Mycommand)"
} #end

}

'OUTPUT from help for this function:
---------------------------------------
#'&gt;help Get-DiskCheck -Full
#'
#'NAME
#'    Get-DiskCheck
#'    
#'SYNTAX
#'    Get-DiskCheck [-Computername] &lt;string[]&gt; [-Threshhold &lt;int&gt;] [-Drive &lt;string&gt; {C: | D: | E: | F:}] [-Test]  [&lt;CommonParameters&gt;]
#'    
#'    Get-DiskCheck -Path &lt;string&gt; [-Threshhold &lt;int&gt;] [-Drive &lt;string&gt; {C: | D: | E: | F:}] [-Test]  [&lt;CommonParameters&gt;]
#'    
#'    
#'PARAMETERS
#'    -Computername &lt;string[]&gt;
#'        Enter a computer name to check
#'        
#'        Required?                    true
#'        Position?                    0
#'        Accept pipeline input?       true (ByValue)
#'        Parameter set name           name
#'        Aliases                      cn
#'        Dynamic?                     false
#'        
#'    -Drive &lt;string&gt;
#'        
#'        Required?                    false
#'        Position?                    Named
#'        Accept pipeline input?       false
#'        Parameter set name           (All)
#'        Aliases                      None
#'        Dynamic?                     false
#'        
#'    -Path &lt;string&gt;
#'        Enter the path to a text file of computer names
#'        
#'        Required?                    true
#'        Position?                    Named
#'        Accept pipeline input?       false
#'        Parameter set name           file
#'        Aliases                      None
#'        Dynamic?                     false
#'        
#'    -Test
#'        
#'        Required?                    false
#'        Position?                    Named
#'        Accept pipeline input?       false
#'        Parameter set name           (All)
#'        Aliases                      None
#'        Dynamic?                     false
#'        
#'    -Threshhold &lt;int&gt;
#'        
#'        Required?                    false
#'        Position?                    Named
#'        Accept pipeline input?       false
#'        Parameter set name           (All)
#'        Aliases                      None
#'        Dynamic?                     false
#'        
#'    &lt;CommonParameters&gt;
#'        This cmdlet supports the common parameters: Verbose, Debug,
#'        ErrorAction, ErrorVariable, WarningAction, WarningVariable,
#'        OutBuffer, PipelineVariable, and OutVariable. For more information, see 
#'        about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216). 
#'    
#'    
#'INPUTS
#'    System.String[]
#'    
#'    
#'OUTPUTS
#'    System.Object
#'    
#'ALIASES
#'    None
#'    
#'
#'REMARKS
#'    None
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Validation</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Validation _snippets</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Validation</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Validation _snippets</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># example (complete file is in sample code)
[cmdletbinding(DefaultParameterSetName = "name")]

Param(
	[Parameter(Position = 0, Mandatory, 
		HelpMessage = "Enter a computer name to check",
		ParameterSetName = "name",
		ValueFromPipeline)]
		[Alias("cn")]
		[ValidateNotNullorEmpty()]
		[string[]]$Computername,
	
	[Parameter(Mandatory,
		HelpMessage = "Enter the path to a text file of computer names",
		ParameterSetName = "file"
		)]
		[ValidateScript({
							if (Test-Path $_) {
							   $True
							}
							else {
							   Throw "Cannot validate path $_"
							}
						})]     
		[ValidatePattern("\.txt$")]
		[string]$Path,
		
		[ValidateRange(10,50)]
		[int]$Threshhold = 25,
		
		[ValidateSet("C:","D:","E:","F:")]
		[string]$Drive = "C:",
		
		[switch]$Test
)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Windows_10</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_Windows_VersionForComputerList_v2.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Windows_10</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_Windows_VersionForComputerList_v2.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get_Windows_VersionForComputerList_v2.ps1

#'$outfile = 'C:\data\computers_WindowsVersion.csv'
#'$infile = 'c:\data\computers.txt'



#' 1] Ping the computers and get the ones that respond:******************************************************************************************************************************    

$inTestcomputers = Get-Content -Path 'c:\data\2018_04_20_ALL_computerObjectsInActiveDirectory.txt'
$outRespondToPing = 'C:\DATA\2018_04_20__RespondToPing.txt'
$TEST = 'C:\DATA\TEST.txt'
'Run part 1 to see which machines ping
'Then using the list of the ones that PING'd get the Windows version
'NOTE: the servers were all wrong




$outDidNOTrespondToPING = 'C:\DATA\2018_04_20__DidNOTrespondToPING.txt'
$outfile = 'C:\data\2018_04_20__WindowsVersion.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $inTestcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path $outRespondToPing
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path $outDidNOTrespondToPING 
		}
	}


#' 2] ******************************************************************************************************************************   
#'           $TEST = 'C:\DATA\TEST.txt'  
$outRespondToPing = 'C:\DATA\2018_04_20__RespondToPing.txt'
$outfile = 'C:\data\2018_04_20__WindowsVersion.csv'
 
           $theComputerOSinfo = @()
                    $computers = Get-Content $outRespondToPing
                    $i=0
                    $count = $computers.count
                    foreach($computer in $computers)
                     {
                            $i++
                            Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
                            -PercentComplete ($i/$count*100)
                            $info = @{}
                            $version = 0
                            try{
                                #'================================================================================

                                            write-host "responded to PING:"$computer -ForegroundColor Green 
                                            #'--------------------------------------------------------------------------------
                                            $OperatingSystem = Get-WmiObject -ComputerName $computer -Class Win32_OperatingSystem
                                            #'--------------------------------------------------------------------------------
                                            $BuildNumber = $OperatingSystem.BuildNumber 
                                            write-host "Build Number:"$BuildNumber -ForegroundColor White                  
                                            switch  ($BuildNumber)
                                            {
                                                10240 {$Build = "1507, Threshold 1, N/A,  July 29, 2015"}
                                                10586 {$Build = "1511, Threshold 2, November Update,  2015/11/10"}
                                                14393 {$Build = "1607, Redstone 1, 2016/08/02"}
                                                15063 {$Build = "1703, Redstone 2, Creators Update, 2017/04/05"}
                                                16299 {$Build = "1709, Redstone 3, Fall Creators Update, 2017/10/17"}
                                                17134 {$Build = "1803, Redstone 4, Early 2018"}
                                                17650 {$Build = "1809, Redstone 5, Late 2018"}
                                                default {$Build = "default"}
                                            }
                                            write-host "Build:"$Build -ForegroundColor White 
                                            #'$Build 

                                            #'--------------------------------------------------------------------------------
                                            #'$OperatingSystem = Get-WmiObject -ComputerName IT-1241 -Class Win32_OperatingSystem
                                            $OS = $OperatingSystem.Version  
                                            write-host "OS:"$OS -ForegroundColor Yellow                  
                                            switch  ($OS)
                                            {
                                                "10.0.16299" {$OSName = "Windows 10 (1709)"}
                                                "10.0.15063" {$OSName = "Windows 10 (1703)"}
                                                "10.0.14393" {$OSName = "Windows 10 (1607)"}
                                                "10.0.10586" {$OSName = "Windows 10 (1511)"}
                                                "10.0.10240" {$OSName = "Windows 10"}
                                                "6.3.9600" {$OSName = "Windows 8.1 (Update 1) or Server"}
                                                "6.3.9200" {$OSName = "Windows 8.1 or Server "}
                                                "6.2.9200" {$OSName = "Windows 8"}
                                                "6.1.7601" {$OSName = "Windows 7 SP1"}
                                                "6.1.7600" {$OSName = "Windows 7"}
                                                "6.0.6002" {$OSName = "Windows Vista SP2"}
                                                "6.0.6001" {$OSName = "Windows Vista SP1"}
                                                "6.0.6000" {$OSName = "Windows Vista"}
                                                "5.1.2600" {$OSName = "Windows XP"}
                                                default {$OSName = "default"}
                                            }
                                            write-host "OSName:"$OSName -ForegroundColor Yellow 
                                #'================================================================================
                                }
 
 
                                catch
                                {
                                            $OperatingSystem  = 'Not Installed/Not Available'
                                }

                                $info.Computer = $computer
                                $info.OSName= $OSName
                                $info.Build =  $Build
                                $info.BuildNumber =  $BuildNumber
                                $info.OSversion = $OS

                                $object = new-object -TypeName PSObject -Property $info
                                $theComputerOSinfo += $object
                    }
                    $theComputerOSinfo | select computer,OSName,Build, BuildNumber,OSversion  | Export-Csv -NoTypeInformation -Path $outfile
#'    }


  write-output ("Done")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Windows_10</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>UnPin_apps_from_START</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Windows_10</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>UnPin_apps_from_START</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://www.tenforums.com/customization/21002-how-automatically-cmd-powershell-script-unpin-all-apps-start.html

function Pin-App { param(
[string]$appname,
[switch]$unpin
)
try{
if ($unpin.IsPresent){
((New-Object -Com Shell.Application).NameSpace('shell:::{4234d49b-0245-4df3-b780-3893943456e1}').Items() | ?{$_.Name -eq $appname}).Verbs() | ?{$_.Name.replace('&amp;','') -match 'From "Start" UnPin|Unpin from Start'} | %{$_.DoIt()}
return "App '$appname' unpinned from Start"
}else{
((New-Object -Com Shell.Application).NameSpace('shell:::{4234d49b-0245-4df3-b780-3893943456e1}').Items() | ?{$_.Name -eq $appname}).Verbs() | ?{$_.Name.replace('&amp;','') -match 'To "Start" Pin|Pin to Start'} | %{$_.DoIt()}
return "App '$appname' pinned to Start"
}
}catch{
Write-Error "Error Pinning/Unpinning App! (App-Name correct?)"
}
}

Pin-App "Mail" -unpin
Pin-App "Store" -unpin
Pin-App "Calendar" -unpin
Pin-App "Microsoft Edge" -unpin
Pin-App "Photos" -unpin
Pin-App "Cortana" -unpin
Pin-App "Weather" -unpin
Pin-App "Phone Companion" -unpin
Pin-App "Music" -unpin
Pin-App "xbox" -unpin
Pin-App "movies &amp; tv" -unpin
Pin-App "microsoft solitaire collection" -unpin
Pin-App "money" -unpin
Pin-App "get office" -unpin
Pin-App "onenote" -unpin
Pin-App "news" -unpin
Pin-App "Mail" -unpin
Pin-App "Store" -unpin
Pin-App "Calendar" -unpin
Pin-App "Microsoft Edge" -unpin
Pin-App "Photos" -unpin
Pin-App "Cortana" -unpin
Pin-App "Weather" -unpin
Pin-App "Phone Companion" -unpin
Pin-App "Music" -unpin
Pin-App "xbox" -unpin
Pin-App "movies &amp; tv" -unpin
Pin-App "microsoft solitaire collection" -unpin
Pin-App "money" -unpin
Pin-App "get office" -unpin
Pin-App "onenote" -unpin
Pin-App "news" -unpin

Pin-App "Groove Music" -unpin
Pin-App "Calculator" -unpin
Pin-App "Sway" -unpin
Pin-App "Pandora" -unpin
Pin-App "Skype Preview" -unpin

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_WMI</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WMIExplorer.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_WMI</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WMIExplorer.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'  https://gallery.technet.microsoft.com/scriptcenter/89c759b7-20b4-49e8-98a8-3c8fbdb2dd69
#' WmiExplorer.ps1  
#'  
#' A GUI WMI explorer and WMI Method Help generator  
#'  
#' /\/\o\/\/ 2006  
#' www.ThePowerShellGuy.com  
#'  
#' load Forms NameSpace  
[void][System.Reflection.Assembly]::LoadWithPartialName("System.windows.forms")   
   
#'region BuildTheForm build in C# then translated to powershell  
#'region Make the form  
$frmMain = new-object Windows.Forms.form    
$frmMain.Size = new-object System.Drawing.Size @(800,600)    
$frmMain.text = "/\/\o\/\/'s PowerShell WMI Explorer"   
#'endregion Make the form  
#'region Define Used Controls  
$MainMenu = new-object System.Windows.Forms.MenuStrip  
$statusStrip = new-object System.Windows.Forms.StatusStrip  
$FileMenu = new-object System.Windows.Forms.ToolStripMenuItem  
$ToolMenu = new-object System.Windows.Forms.ToolStripMenuItem('&amp;tools')  
$miQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;Query (run)')  
$miSelectQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;SelectQuery')  
$miSelectQuery.add_Click({$sq | out-propertyGrid;$wmiSearcher.Query = $sq})  
[void]$ToolMenu.DropDownItems.Add($miSelectQuery)  
$miRelatedObjectQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;RelatedObjectQuery')  
$miRelatedObjectQuery.add_Click({$roq | out-propertyGrid;$wmiSearcher.Query = $roq})  
[void]$ToolMenu.DropDownItems.Add($miRelatedObjectQuery)  
$miRelationshipQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;RelationshipQuery')  
$miRelationshipQuery.add_Click({$rq | out-propertyGrid ;$wmiSearcher.Query = $rq})  
[void]$ToolMenu.DropDownItems.Add($miRelationshipQuery)  
$oq = new-object System.Management.ObjectQuery  
$eq = new-object System.Management.EventQuery  
$sq = new-object System.Management.SelectQuery  
$roq = new-object System.Management.RelatedObjectQuery  
$rq = new-object System.Management.RelationshipQuery  
$wmiSearcher = [wmisearcher]''  
[void]$ToolMenu.DropDownItems.Add($miQuery)  
$miQuery.add_Click({  
    $wmiSearcher | out-propertyGrid  
    $moc = $wmiSearcher.get()  
    $DT =  new-object  System.Data.DataTable  
    $DT.TableName = $lblClass.text  
    $Col =  new-object System.Data.DataColumn  
    $Col.ColumnName = "WmiPath"  
    $DT.Columns.Add($Col)  
    $i = 0  
    $j = 0 ;$lblInstances.Text = $j; $lblInstances.Update()  
    $MOC |  
    ForEach-Object {  
        $j++ ;$lblInstances.Text = $j; $lblInstances.Update()  
        $MO = $_  
         
        #' Make a DataRow  
        $DR = $DT.NewRow()  
        $Col =  new-object System.Data.DataColumn  
        $DR.Item("WmiPath") = $mo.__PATH  
        $MO.psbase.properties |  
        ForEach-Object {  
         
            $prop = $_  
             
            If ($i -eq 0)  {  
     
                #' Only On First Row make The Headers  
                 
                $Col =  new-object System.Data.DataColumn  
                $Col.ColumnName = $prop.Name.ToString()  
   
                $prop.psbase.Qualifiers |  
                ForEach-Object {  
                    If ($_.Name.ToLower() -eq "key") {  
                        $Col.ColumnName = $Col.ColumnName + "*"  
                    }  
                }  
                $DT.Columns.Add($Col)   
            }  
             
            #' fill dataRow   
             
            if ($prop.value -eq $null) {  
                $DR.Item($prop.Name) = "[empty]"  
            } ElseIf ($prop.IsArray) {  
                $DR.Item($prop.Name) =[string]::Join($prop.value ,";")  
            } Else {  
                $DR.Item($prop.Name) = $prop.value  
                #'Item is Key try again with *  
                trap{$DR.Item("$($prop.Name)*") = $prop.Value.tostring();continue}  
            }  
        } #'end ForEach  
        #' Add the row to the DataTable  
         
        $DT.Rows.Add($DR)  
        $i += 1  
    }  
    $DGInstances.DataSource = $DT.psObject.baseobject    
    $status.Text = "Retrieved $j Instances"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
})#'$miQuery.add_Click  
 
$miQuit = new-object System.Windows.Forms.ToolStripMenuItem('&amp;quit')  
$miQuit.add_Click({$frmMain.close()})   
$SplitContainer1 = new-object System.Windows.Forms.SplitContainer  
$splitContainer2 = new-object System.Windows.Forms.SplitContainer  
$splitContainer3 = new-object System.Windows.Forms.SplitContainer  
$grpComputer = new-object System.Windows.Forms.GroupBox  
$grpNameSpaces = new-object System.Windows.Forms.GroupBox  
$grpClasses = new-object System.Windows.Forms.GroupBox  
$grpClass = new-object System.Windows.Forms.GroupBox  
$grpInstances = new-object System.Windows.Forms.GroupBox  
$grpStatus = new-object System.Windows.Forms.GroupBox  
$txtComputer = new-object System.Windows.Forms.TextBox  
$btnConnect = new-object System.Windows.Forms.Button  
$btnInstances = new-object System.Windows.Forms.Button  
$tvNameSpaces = new-object System.Windows.Forms.TreeView  
$lvClasses = new-object System.Windows.Forms.ListView  
$clbProperties = new-object System.Windows.Forms.CheckedListBox  
$clbProperties.CheckOnClick = $true  
$lbMethods = new-object System.Windows.Forms.ListBox  
$label1 = new-object System.Windows.Forms.Label  
$label2 = new-object System.Windows.Forms.Label  
$lblServer = new-object System.Windows.Forms.Label  
$lblPath = new-object System.Windows.Forms.Label  
$lblNameSpace = new-object System.Windows.Forms.Label  
$label6 = new-object System.Windows.Forms.Label  
$lblClass = new-object System.Windows.Forms.Label  
$label10 = new-object System.Windows.Forms.Label  
$lblClasses = new-object System.Windows.Forms.Label  
$label12 = new-object System.Windows.Forms.Label  
$lblProperties = new-object System.Windows.Forms.Label  
$label8 = new-object System.Windows.Forms.Label  
$lblMethods = new-object System.Windows.Forms.Label  
$label14 = new-object System.Windows.Forms.Label  
$lblInstances = new-object System.Windows.Forms.Label  
$label16 = new-object System.Windows.Forms.Label  
$dgInstances = new-object System.Windows.Forms.DataGridView  
$TabControl = new-object System.Windows.Forms.TabControl  
$tabPage1 = new-object System.Windows.Forms.TabPage  
$tabInstances = new-object System.Windows.Forms.TabPage  
$rtbHelp = new-object System.Windows.Forms.RichTextBox  
$tabMethods = new-object System.Windows.Forms.TabPage  
$rtbMethods = new-object System.Windows.Forms.RichTextBox  
#'endregion Define Used Controls         
#'region Suspend the Layout  
$splitContainer1.Panel1.SuspendLayout()  
$splitContainer1.Panel2.SuspendLayout()  
$splitContainer1.SuspendLayout()  
$splitContainer2.Panel1.SuspendLayout()  
$splitContainer2.Panel2.SuspendLayout()  
$splitContainer2.SuspendLayout()  
$grpComputer.SuspendLayout()  
$grpNameSpaces.SuspendLayout()  
$grpClasses.SuspendLayout()  
$splitContainer3.Panel1.SuspendLayout()  
$splitContainer3.Panel2.SuspendLayout()  
$splitContainer3.SuspendLayout()  
$grpClass.SuspendLayout()  
$grpStatus.SuspendLayout()  
$grpInstances.SuspendLayout()  
$TabControl.SuspendLayout()  
$tabPage1.SuspendLayout()  
$tabInstances.SuspendLayout()  
$FrmMain.SuspendLayout()  
#'endregion Suspend the Layout  
#'region Configure Controls  
[void]$MainMenu.Items.Add($FileMenu)  
[void]$MainMenu.Items.Add($ToolMenu)  
$MainMenu.Location = new-object System.Drawing.Point(0, 0)  
$MainMenu.Name = "MainMenu"  
$MainMenu.Size = new-object System.Drawing.Size(1151, 24)  
$MainMenu.TabIndex = 0  
$MainMenu.Text = "Main Menu"  
#'  
#' statusStrip1  
#'  
$statusStrip.Location = new-object System.Drawing.Point(0, 569)  
$statusStrip.Name = "statusStrip"  
$statusStrip.Size = new-object System.Drawing.Size(1151, 22);  
$statusStrip.TabIndex = 1  
$statusStrip.Text = "statusStrip"  
$splitContainer1.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer1.Location = new-object System.Drawing.Point(0, 24)  
$splitContainer1.Name = "splitContainer1"  
$splitContainer1.Panel1.Controls.Add($splitContainer2)  
$splitContainer1.Panel2.Controls.Add($splitContainer3)  
$splitContainer1.Size = new-object System.Drawing.Size(1151, 545)  
$splitContainer1.SplitterDistance = 372  
$splitContainer1.TabIndex = 2  
$splitContainer2.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$splitContainer2.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer2.Location = new-object System.Drawing.Point(0, 0)  
$splitContainer2.Name = "splitContainer2"  
$splitContainer2.Orientation = [System.Windows.Forms.Orientation]::Horizontal  
$splitContainer2.Panel1.BackColor = [System.Drawing.SystemColors]::Control  
$splitContainer2.Panel1.Controls.Add($grpNameSpaces)  
$splitContainer2.Panel1.Controls.Add($btnConnect)  
$splitContainer2.Panel1.Controls.Add($grpComputer)  
$splitContainer2.Panel2.Controls.Add($grpClasses)  
$splitContainer2.Size = new-object System.Drawing.Size(372, 545)  
$splitContainer2.SplitterDistance = 302  
$splitContainer2.TabIndex = 0  
#'  
#' fileMenu  
#'  
[void]$fileMenu.DropDownItems.Add($miQuit)  
$fileMenu.Name = "fileMenu"  
$fileMenu.Size = new-object System.Drawing.Size(35, 20)  
$fileMenu.Text = "&amp;File"  
$grpComputer.Anchor = "top, left, right"  
$grpComputer.Controls.Add($txtComputer)  
$grpComputer.Location = new-object System.Drawing.Point(12, 3)  
$grpComputer.Name = "grpComputer"  
$grpComputer.Size = new-object System.Drawing.Size(340, 57)  
$grpComputer.TabIndex = 0  
$grpComputer.TabStop = $false  
$grpComputer.Text = "Computer"  
$txtComputer.Anchor = "top, left, right"  
$txtComputer.Location = new-object System.Drawing.Point(7, 20)  
$txtComputer.Name = "txtComputer"  
$txtComputer.Size = new-object System.Drawing.Size(244, 20)  
$txtComputer.TabIndex = 0  
$txtComputer.Text = "."  
 
$btnConnect.Anchor = "top, right"  
$btnConnect.Location = new-object System.Drawing.Point(269, 23);  
$btnConnect.Name = "btnConnect"  
$btnConnect.Size = new-object System.Drawing.Size(75, 23)  
$btnConnect.TabIndex = 1  
$btnConnect.Text = "Connect"  
$btnConnect.UseVisualStyleBackColor = $true  
#'  
#' grpNameSpaces  
#'  
$grpNameSpaces.Anchor = "Bottom, top, left, right"  
$grpNameSpaces.Controls.Add($tvNameSpaces)  
$grpNameSpaces.Location = new-object System.Drawing.Point(12, 67)  
$grpNameSpaces.Name = "grpNameSpaces"  
$grpNameSpaces.Size = new-object System.Drawing.Size(340, 217)  
$grpNameSpaces.TabIndex = 2  
$grpNameSpaces.TabStop = $false  
$grpNameSpaces.Text = "NameSpaces"  
#'  
#' grpClasses  
#'  
$grpClasses.Anchor = "Bottom, top, left, right"  
$grpClasses.Controls.Add($lvClasses)  
$grpClasses.Location = new-object System.Drawing.Point(12, 14)  
$grpClasses.Name = "grpClasses"  
$grpClasses.Size = new-object System.Drawing.Size(340, 206)  
$grpClasses.TabIndex = 0  
$grpClasses.TabStop = $False  
$grpClasses.Text = "Classes"  
#'  
#' tvNameSpaces  
#'  
$tvNameSpaces.Anchor = "Bottom, top, left, right"  
$tvNameSpaces.Location = new-object System.Drawing.Point(7, 19)  
$tvNameSpaces.Name = "tvNameSpaces"  
$tvNameSpaces.Size = new-object System.Drawing.Size(325, 184)  
$tvNameSpaces.TabIndex = 0  
#'  
#' tvClasses  
#'  
$lvClasses.Anchor = "Bottom, top, left, right"  
$lvClasses.Location = new-object System.Drawing.Point(7, 19)  
$lvClasses.Name = "tvClasses"  
$lvClasses.Size = new-object System.Drawing.Size(325, 172)  
$lvClasses.TabIndex = 0  
$lvClasses.UseCompatibleStateImageBehavior = $False  
$lvClasses.ShowItemToolTips = $true  
$lvClasses.View = 'Details'  
$colName = $lvClasses.Columns.add('Name')  
$colname.Width = 160  
$colPath = $lvClasses.Columns.add('Description')  
$colname.Width = 260  
$colPath = $lvClasses.Columns.add('Path')  
$colname.Width = 260  
#'  
#' splitContainer3  
#'  
$splitContainer3.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$splitContainer3.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer3.Location = new-object System.Drawing.Point(0, 0)  
$splitContainer3.Name = "splitContainer3"  
$splitContainer3.Orientation = [System.Windows.Forms.Orientation]::Horizontal  
#'  
#' splitContainer3.Panel1  
#'  
$splitContainer3.Panel1.Controls.Add($grpStatus)  
$splitContainer3.Panel1.Controls.Add($grpClass)  
#'  
#' splitContainer3.Panel2  
#'  
$splitContainer3.Panel2.Controls.Add($TabControl)  
$splitContainer3.Size = new-object System.Drawing.Size(775, 545)  
$splitContainer3.SplitterDistance = 303  
$splitContainer3.TabIndex = 0  
#'  
#' grpClass  
#'  
$grpClass.Anchor = "Bottom, top, left, right"  
$grpClass.Controls.Add($lblInstances)  
$grpClass.Controls.Add($label16)  
$grpClass.Controls.Add($lblMethods)  
$grpClass.Controls.Add($label14)  
$grpClass.Controls.Add($lblProperties)  
$grpClass.Controls.Add($label8)  
$grpClass.Controls.Add($lblClass)  
$grpClass.Controls.Add($label10)  
$grpClass.Controls.Add($lbMethods)  
$grpClass.Controls.Add($clbProperties)  
$grpClass.Controls.Add($btnInstances)  
$grpClass.Location = new-object System.Drawing.Point(17, 86)  
$grpClass.Name = "grpClass"  
$grpClass.Size = new-object System.Drawing.Size(744, 198)  
$grpClass.TabIndex = 0  
$grpClass.TabStop = $False  
$grpClass.Text = "Class"  
#'  
#' btnInstances  
#'  
$btnInstances.Anchor = "Bottom, Left"  
$btnInstances.Location = new-object System.Drawing.Point(6, 169);  
$btnInstances.Name = "btnInstances";  
$btnInstances.Size = new-object System.Drawing.Size(96, 23);  
$btnInstances.TabIndex = 0;  
$btnInstances.Text = "Get Instances";  
$btnInstances.UseVisualStyleBackColor = $true  
#'  
#' grpStatus  
#'  
$grpStatus.Anchor = "Top,Left,Right"  
$grpStatus.Controls.Add($lblClasses)  
$grpStatus.Controls.Add($label12)  
$grpStatus.Controls.Add($lblNameSpace)  
$grpStatus.Controls.Add($label6)  
$grpStatus.Controls.Add($lblPath)  
$grpStatus.Controls.Add($lblServer)  
$grpStatus.Controls.Add($label2)  
$grpStatus.Controls.Add($label1)  
$grpStatus.Location = new-object System.Drawing.Point(17, 3)  
$grpStatus.Name = "grpStatus"  
$grpStatus.Size = new-object System.Drawing.Size(744, 77)  
$grpStatus.TabIndex = 1  
$grpStatus.TabStop = $False  
$grpStatus.Text = "Status"  
#'  
#' label1  
#'  
$label1.AutoSize = $true  
$label1.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label1.Location = new-object System.Drawing.Point(7, 20)  
$label1.Name = "label1"  
$label1.Size = new-object System.Drawing.Size(62, 16)  
$label1.TabIndex = 0  
$label1.Text = "Server :"  
#'  
#' label2  
#'  
$label2.AutoSize = $true  
$label2.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label2.Location = new-object System.Drawing.Point(7, 41)  
$label2.Name = "label2"  
$label2.Size = new-object System.Drawing.Size(51, 16)  
$label2.TabIndex = 1  
$label2.Text = "Path  :"  
#'  
#' lblServer  
#'  
$lblServer.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblServer.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblServer.Location = new-object System.Drawing.Point(75, 20)  
$lblServer.Name = "lblServer"  
$lblServer.Size = new-object System.Drawing.Size(144, 20)  
$lblServer.TabIndex = 2  
#'  
#' lblPath  
#'  
$lblPath.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblPath.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblPath.Location = new-object System.Drawing.Point(75, 40)  
$lblPath.Name = "lblPath"  
$lblPath.Size = new-object System.Drawing.Size(567, 20)  
$lblPath.TabIndex = 3  
#'  
#' lblNameSpace  
#'  
$lblNameSpace.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblNameSpace.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblNameSpace.Location = new-object System.Drawing.Point(337, 20)  
$lblNameSpace.Name = "lblNameSpace"  
$lblNameSpace.Size = new-object System.Drawing.Size(144, 20)  
$lblNameSpace.TabIndex = 5  
#'  
#' label6  
#'  
$label6.AutoSize = $true  
$label6.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label6.Location = new-object System.Drawing.Point(229, 20)  
$label6.Name = "label6"  
$label6.Size = new-object System.Drawing.Size(102, 16)  
$label6.TabIndex = 4  
$label6.Text = "NameSpace :"  
#'  
#' lblClass  
#'  
$lblClass.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblClass.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblClass.Location = new-object System.Drawing.Point(110, 26)  
$lblClass.Name = "lblClass"  
$lblClass.Size = new-object System.Drawing.Size(159, 20)  
$lblClass.TabIndex = 11  
#'  
#' label10  
#'  
$label10.AutoSize = $true  
$label10.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label10.Location = new-object System.Drawing.Point(6, 26)  
$label10.Name = "label10"  
$label10.Size = new-object System.Drawing.Size(55, 16)  
$label10.TabIndex = 10  
$label10.Text = "Class :"  
#'  
#' lblClasses  
#'  
$lblClasses.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblClasses.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblClasses.Location = new-object System.Drawing.Point(595, 21)  
$lblClasses.Name = "lblClasses"  
$lblClasses.Size = new-object System.Drawing.Size(47, 20)  
$lblClasses.TabIndex = 9  
#'  
#' label12  
#'  
$label12.AutoSize = $true  
$label12.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label12.Location = new-object System.Drawing.Point(487, 21)  
$label12.Name = "label12"  
$label12.Size = new-object System.Drawing.Size(76, 16)  
$label12.TabIndex = 8  
$label12.Text = "Classes  :"  
#'  
#' clbProperties  
#'  
$clbProperties.Anchor = "Bottom, top,left"  
$clbProperties.FormattingEnabled = $true  
$clbProperties.Location = new-object System.Drawing.Point(510, 27)  
$clbProperties.Name = "clbProperties"  
$clbProperties.Size = new-object System.Drawing.Size(220, 160)  
$clbProperties.TabIndex = 1  
#'  
#' lbMethods  
#'  
$lbMethods.Anchor = "Bottom, top, Left"  
$lbMethods.FormattingEnabled = $true  
$lbMethods.Location = new-object System.Drawing.Point(280, 27)  
$lbMethods.Name = "lbMethods"  
$lbMethods.Size = new-object System.Drawing.Size(220, 160)  
$lbMethods.TabIndex = 2  
#'  
#' lblProperties  
#'  
$lblProperties.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblProperties.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblProperties.Location = new-object System.Drawing.Point(110, 46)  
$lblProperties.Name = "lblProperties"  
$lblProperties.Size = new-object System.Drawing.Size(119, 20)  
$lblProperties.TabIndex = 13  
#'  
#' label8  
#'  
$label8.AutoSize = $true  
$label8.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label8.Location = new-object System.Drawing.Point(6, 46)  
$label8.Name = "label8"  
$label8.Size = new-object System.Drawing.Size(88, 16)  
$label8.TabIndex = 12  
$label8.Text = "Properties :"  
#'  
#' lblMethods  
#'  
$lblMethods.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblMethods.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblMethods.Location = new-object System.Drawing.Point(110, 66)  
$lblMethods.Name = "lblMethods"  
$lblMethods.Size = new-object System.Drawing.Size(119, 20)  
$lblMethods.TabIndex = 15  
#'  
#' label14  
#'  
$label14.AutoSize = $true  
$label14.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label14.Location = new-object System.Drawing.Point(6, 66)  
$label14.Name = "label14"  
$label14.Size = new-object System.Drawing.Size(79, 16)  
$label14.TabIndex = 14  
$label14.Text = "Methods  :"  
#'  
#' lblInstances  
#'  
$lblInstances.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblInstances.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblInstances.Location = new-object System.Drawing.Point(110, 86)  
$lblInstances.Name = "lblInstances"  
$lblInstances.Size = new-object System.Drawing.Size(119, 20)  
$lblInstances.TabIndex = 17  
#'  
#' label16  
#'  
$label16.AutoSize = $true  
$label16.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label16.Location = new-object System.Drawing.Point(6, 86)  
$label16.Name = "label16"  
$label16.Size = new-object System.Drawing.Size(82, 16)  
$label16.TabIndex = 16  
$label16.Text = "Instances :"  
#'  
#' grpInstances  
#'  
$grpInstances.Anchor = "Bottom, top, left, right"  
$grpInstances.Controls.Add($dgInstances)  
$grpInstances.Location = new-object System.Drawing.Point(17, 17)  
$grpInstances.Name = "grpInstances"  
$grpInstances.Size = new-object System.Drawing.Size(744, 202)  
$grpInstances.TabIndex = 0  
$grpInstances.TabStop = $False  
$grpInstances.Text = "Instances"  
#'  
#' dgInstances  
#'  
$dgInstances.Anchor = "Bottom, top, left, right"  
$dgInstances.ColumnHeadersHeightSizeMode = [System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode]::AutoSize  
$dgInstances.Location = new-object System.Drawing.Point(10, 19)  
$dgInstances.Name = "dgInstances"  
$dgInstances.Size = new-object System.Drawing.Size(728, 167)  
$dgInstances.TabIndex = 0  
$dginstances.ReadOnly = $true  
#' TabControl  
#'  
$TabControl.Controls.Add($tabPage1)  
$TabControl.Controls.Add($tabInstances)  
$TabControl.Controls.Add($tabMethods)  
$TabControl.Dock = [System.Windows.Forms.DockStyle]::Fill  
$TabControl.Location = new-object System.Drawing.Point(0, 0)  
$TabControl.Name = "TabControl"  
$TabControl.SelectedIndex = 0  
$TabControl.Size = new-object System.Drawing.Size(771, 234)  
$TabControl.TabIndex = 0  
#'  
#' tabPage1  
#'  
$tabPage1.Controls.Add($rtbHelp)  
$tabPage1.Location = new-object System.Drawing.Point(4, 22)  
$tabPage1.Name = "tabPage1"  
$tabPage1.Padding = new-object System.Windows.Forms.Padding(3)  
$tabPage1.Size = new-object System.Drawing.Size(763, 208)  
$tabPage1.TabIndex = 0  
$tabPage1.Text = "Help"  
$tabPage1.UseVisualStyleBackColor = $true  
#'  
#' tabInstances  
#'  
$tabInstances.Controls.Add($grpInstances)  
$tabInstances.Location = new-object System.Drawing.Point(4, 22)  
$tabInstances.Name = "tabInstances"  
$tabInstances.Padding = new-object System.Windows.Forms.Padding(3)  
$tabInstances.Size = new-object System.Drawing.Size(763, 208)  
$tabInstances.TabIndex = 1  
$tabInstances.Text = "Instances"  
$tabInstances.UseVisualStyleBackColor = $true  
#'  
#' richTextBox1  
#'  
$rtbHelp.Dock = [System.Windows.Forms.DockStyle]::Fill  
$rtbHelp.Location = new-object System.Drawing.Point(3, 3)  
$rtbHelp.Name = "richTextBox1"  
$rtbHelp.Size = new-object System.Drawing.Size(757, 202)  
$rtbHelp.TabIndex = 0  
$rtbHelp.Text = ""  
#'  
#' tabMethods  
#'  
$tabMethods.Location = new-object System.Drawing.Point(4, 22)  
$tabMethods.Name = "tabMethods"  
$tabMethods.Padding = new-object System.Windows.Forms.Padding(3)  
$tabMethods.Size = new-object System.Drawing.Size(763, 208)  
$tabMethods.TabIndex = 2  
$tabMethods.Text = "Methods"  
$tabMethods.UseVisualStyleBackColor = $true  
 
        $rtbMethods.Dock = [System.Windows.Forms.DockStyle]::Fill  
        $rtbMethods.Font = new-object System.Drawing.Font("Lucida Console",8 )  
        $rtbMethods.DetectUrls = $false  
        $tabMethods.controls.add($rtbMethods)  
         
#'endregion Configure Controls  
#' Configure  Main Form  
#'region frmMain  
 
#'  
$frmMain.AutoScaleDimensions = new-object System.Drawing.SizeF(6, 13)  
$frmMain.AutoScaleMode = [System.Windows.Forms.AutoScaleMode]::Font  
$frmMain.ClientSize = new-object System.Drawing.Size(1151, 591)  
$frmMain.Controls.Add($splitContainer1)  
$frmMain.Controls.Add($statusStrip)  
$frmMain.Controls.Add($MainMenu)  
$frmMain.MainMenuStrip = $mainMenu  
$FrmMain.Name = "frmMain"  
$FrmMain.Text = "/\/\o\/\/ PowerShell WMI Browser"  
$mainMenu.ResumeLayout($false)  
$mainMenu.PerformLayout()  
$MainMenu.ResumeLayout($false)  
$MainMenu.PerformLayout()  
$splitContainer1.Panel1.ResumeLayout($false)  
$splitContainer1.Panel2.ResumeLayout($false)  
$splitContainer1.ResumeLayout($false)  
$splitContainer2.Panel1.ResumeLayout($false)  
$splitContainer2.Panel2.ResumeLayout($false)  
$splitContainer2.ResumeLayout($false)  
$grpComputer.ResumeLayout($false)  
$grpComputer.PerformLayout()  
$grpNameSpaces.ResumeLayout($false)  
$grpClasses.ResumeLayout($false)  
$splitContainer3.Panel1.ResumeLayout($false)  
$splitContainer3.Panel2.ResumeLayout($false)  
$splitContainer3.ResumeLayout($false)  
$grpClass.ResumeLayout($false)  
$grpClass.PerformLayout()  
$grpStatus.ResumeLayout($false)  
$grpStatus.PerformLayout()  
$grpInstances.ResumeLayout($false)  
$TabControl.ResumeLayout($false)  
$tabPage1.ResumeLayout($false)  
$tabInstances.ResumeLayout($false)  
$frmMain.ResumeLayout($false)  
$FrmMain.PerformLayout()  
$status = new-object System.Windows.Forms.ToolStripStatusLabel  
$status.BorderStyle = 'SunkenInner'  
$status.BorderSides = 'All'  
$status.Text = "Not Connected"  
[void]$statusStrip.Items.add($status)  
$slMessage = new-object System.Windows.Forms.ToolStripStatusLabel  
$slMessage.BorderStyle = 'SunkenInner'  
$slMessage.BorderSides = 'All'  
$slMessage.Text = ""  
[void]$statusStrip.Items.add($slMessage)  
#'endregion frmMain  
#'endregion  
#'region Helper Functions  
Function out-PropertyGrid {  
  Param ($Object,[switch]$noBase,[Switch]$array)  
  $PsObject = $null  
  if ($object) {  
      $PsObject = $object  
  }Else{  
     if ($Array.IsPresent) {  
         $PsObject = @()  
         $input |ForEach-Object {$PsObject += $_}  
     }Else{  
         $input |ForEach-Object {$PsObject = $_}  
     }  
  }  
  if ($PsObject){  
      $form = new-object Windows.Forms.Form   
      $form.Size = new-object Drawing.Size @(600,600)   
      $PG = new-object Windows.Forms.PropertyGrid   
      $PG.Dock = 'Fill'   
      $form.text = "$psObject"   
      if ($noBase.IsPresent) {"no";  
          $PG.selectedobject = $psObject   
      }Else{  
          $PG.selectedobject = $psObject.PsObject.baseobject   
      }   
      $form.Controls.Add($PG)   
      $Form.Add_Shown({$form.Activate()})    
      $form.showdialog()  
  }  
} #'Function out-PropertyGrid  
Function Update-Status {  
  $script:computer = $Script:NameSpaces.__SERVER  
  $txtComputer.Text = $script:computer  
  $lblPath.Text = $Script:NameSpaces.__PATH                                 
  $lblProperties.Text = $Script:NameSpaces.__PROPERTY_COUNT                                 
  $lblClass.Text = $Script:NameSpaces.__RELPATH                                     
  $lblServer.Text = $script:Computer  
  $lblnamespace.Text = $Script:NameSpaces.__NAMESPACE  
} #' Function Update-Status  
Function Set-StatusBar ([Drawing.Color]$Color,$Text) {  
  $status.BackColor = $color  
  $status.Text = $text  
  $statusstrip.Update()    
}  
#'endregion Helper Functions  
#'################### Main ###############################  
#'region Global Variables  
$FontBold = new-object System.Drawing.Font("Microsoft Sans Serif",8,[Drawing.FontStyle]'Bold' )  
$fontNormal = new-object System.Drawing.Font("Microsoft Sans Serif",8,[Drawing.FontStyle]'Regular')  
$fontCode = new-object System.Drawing.Font("Lucida Console",8 )  
#' Create Script Variables for WMI Connection  
$Script:ConnectionOptions = new-object System.Management.ConnectionOptions  
$script:WmiConnection = new-object system.management.ManagementScope  
$script:WmiClass = [wmiClass]''  
#' NamespaceCaching , Make HashTable to store Treeview Items  
$script:nsc = @{}  
#' Make DataSet for secondary Cache  
$Script:dsCache = new-object data.dataset  
if (-not ${Global:WmiExplorer.dtClasses}){  
    ${Global:WmiExplorer.dtClasses} = new-object data.datatable  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Path',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Namespace',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('name',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Description',[string]))  
    ${Global:WmiExplorer.dtClasses}.tablename = 'Classes'  
}  
#'endregion  
#'region Control Handlers  
#' Add Delegate Scripts to finetune the WMI Connection objects to the events of the controls  
$slMessage.DoubleClickEnabled = $true  
$slMessage.add_DoubleClick({$error[0] | out-PropertyGrid})  
$lblNameSpace.add_DoubleClick({$script:WmiConnection | out-PropertyGrid})  
$lblserver.add_DoubleClick({$Script:ConnectionOptions | out-PropertyGrid})  
$lblClass.add_DoubleClick({$script:WmiClass | out-PropertyGrid})  
 
$btnConnect.add_click({ConnectToComputer})  
$TVNameSpaces.add_DoubleClick({GetClassesFromNameSpace})  
$lvClasses.Add_DoubleClick({GetWmiClass})  
$btnInstances.add_Click({GetWmiInstances})  
$dgInstances.add_DoubleClick({OutputWmiInstance})  
$lbMethods.Add_DoubleClick({GetWmiMethod})  
$clbProperties.add_Click({  
  trap{Continue}  
  $DGInstances.Columns.Item(($this.SelectedItem)).visible = -not $clbProperties.GetItemChecked($this.SelectedIndex)  
})  
$TVNameSpaces.add_AfterSelect({  
    if ($this.SelectedNode.name -ne $Computer){  
        $lblPath.Text = "$($script:WmiConnection.path.path.replace('\root',''))\$($this.SelectedNode.Text)"   
    }  
   
    $lblProperties.Text = $Script:NameSpaces.__PROPERTY_COUNT                                 
    $lblServer.Text = $Script:NameSpaces.__SERVER  
    $lblnamespace.Text = $this.SelectedNode.Text  
    if ($this.SelectedNode.tag -eq "NotEnumerated") {  
        (new-object system.management.managementClass(  
                "$($script:WmiConnection.path.path.replace('\root',''))\$($this.SelectedNode.Text):__NAMESPACE")  
        ).PSbase.getInstances() | Sort-Object $_.name |  
        ForEach-Object {  
          $TN = new-object System.Windows.Forms.TreeNode  
          $TN.Name = $_.name  
          $TN.Text = ("{0}\{1}" -f $_.__NameSpace,$_.name)  
          $TN.tag = "NotEnumerated"  
          $this.SelectedNode.Nodes.Add($TN)  
        }  
         
        #' Set tag to show this node is already enumerated  
        $this.SelectedNode.tag = "Enumerated"  
    }  
    $mp = ("{0}\{1}" -f $script:WmiConnection.path.path.replace('\root','') , $this.SelectedNode.text)  
    $lvClasses.Items.Clear()  
    if($Script:nsc.Item("$mp")){ #' in Namespace cache  
        $lvClasses.BeginUpdate()  
        $lvClasses.Items.AddRange(($nsc.Item( "$mp")))  
        $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
        $lvClasses.EndUpdate()  
        $lblClasses.Text = $lvClasses.Items.count  
    } else {  
        if(${Global:WmiExplorer.dtClasses}.Select("Namespace='$mp'")){ #' In DataTable Cache  
            $status.BackColor = 'beige'  
            $status.Text = "$mp : Classes in Cache, DoubleClick NameSpace to retrieve Classes"  
        } else {  
            $status.BackColor = 'LightSalmon'  
            $status.Text = "$mp : Classes not recieved yet, DoubleClick NameSpace to retrieve Classes"  
        }  
    }  
}) #' $TVNameSpaces.add_AfterSelect  
#'endregion  
#'region Processing Functions  
#'region ConnectToComputer  
#' Connect to Computer  
Function ConnectToComputer {  
     
    $computer = $txtComputer.Text  
    Set-StatusBar 'beige' "Connecting to : $computer"  
     
    #' Try to Connect to Computer  
    &amp;{  
        trap {  
            Set-StatusBar 'Red' "Connecting to : $computer Failed"  
            $slMessage.Text = "$_.message"  
            Continue  
        }  
        &amp;{  
            #' Connect to WMI root  
             
            $script:WmiConnection.path = "\\$computer\root"  
            $script:WmiConnection.options = $Script:ConnectionOptions  
            $script:WmiConnection.Connect()  
             
            #' Get Avaiable NameSpaces  
     
            $opt = new-object system.management.ObjectGetOptions  
            $opt.UseAmendedQualifiers = $true  
            $Script:NameSpaces = new-object System.Management.ManagementClass(  
                $script:WmiConnection,[Management.ManagementPath]'__Namespace',$opt  
            )  
            Update-Status  
            #' Create a TreeNode for the WMI Root found  
            $computer = $txtComputer.Text  
            $TNRoot = new-object System.Windows.Forms.TreeNode("Root")  
            $TNRoot.Name = $Computer  
            $TNRoot.Text = $lblPath.Text  
            $TNRoot.tag = "Enumerated"  
             
            #' Create NameSpaces List  
             
            $Script:NameSpaces.PSbase.getInstances() | Sort-Object $_.name |  
            ForEach-Object {  
                $TN = new-object System.Windows.Forms.TreeNode  
                $TN.Name = $_.name  
                $TN.Text = ("{0}\{1}" -f $_.__NameSpace,$_.name)  
                $TN.tag = "NotEnumerated"  
                [void]$TNRoot.Nodes.Add($TN)  
            }  
            #' Add to Treeview  
            $tvNameSpaces.Nodes.clear()  
            [void]$TVNamespaces.Nodes.Add($TNRoot)  
             
            #' update StatusBar  
            Set-StatusBar 'YellowGreen' "Connected to : $computer"  
        }  
    }  
} #' ConnectToComputer  
#'endregion  
#'region GetClasseFromNameSpace  
#' Get Classes on DoubleClick on Namespace in TreeView  
Function GetClassesFromNameSpace {  
  if ($this.SelectedNode.name -ne $script:computer){  
    #' Connect to WMI Namespace  
         
    $mp = ("{0}\{1}" -f $script:WmiConnection.path.path.replace('\root','') , $this.SelectedNode.text)  
      #' Update Status  
         
      $lvClasses.BeginUpdate()  
      $lvClasses.Items.Clear()  
      $i = 0 ;$lblClasses.Text = $i; $lblclasses.Update()  
    if($Script:nsc.Item("$mp")){ #'in Namespace Cache, so just attach to ListView again  
         
        $lvClasses.Items.AddRange(($nsc.Item( "$mp")))  
        #' $lvClasses.Items.AddRange(([System.Windows.Forms.ListViewItem[]]($nsc.Item( "$mp") |  
            #' where {$_.name -like 'win32_*'})))  
        $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
        $i = $lvClasses.Items.count  
    } else { #'Not In NameSpace Cache  
      if(${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'")){ #' In DataTable cache, so get from there  
        $status.Text = "loading cache from $($this.SelectedNode.name)"  
        $statusStrip.Update()  
        ${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'") |  
        foreach {  
            $i++  
            $LI = New-Object system.Windows.Forms.ListViewItem  
            $li.Name = $_.name  
            $li.Text = $_.name  
            $li.SubItems.add($_.description)  
            $li.SubItems.add($_.path)  
            $li.ToolTipText = ($_.description)  
            $lvClasses.Items.add($li)  
            $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
            $lblClasses.Text = $lvClasses.Items.count  
        }  
      } else { #' Not in any Cache , Load WMI Classes  
        Set-StatusBar 'Khaki' "Getting Classes from $($this.SelectedNode.name)"  
        $mc = new-object System.Management.ManagementClass($mp,$opt)  
        $eo = New-Object system.management.EnumerationOptions  
        $eo.EnumerateDeep = $true  
        $eo.UseAmendedQualifiers = $true  
        $Mc.psbase.GetSubclasses($eo) |  
        ForEach-Object  {  
            $i++ ; if ($i%10 -eq 0){$lblClasses.Text = $i;$lblclasses.Update() }  
            Trap{$script:Description = "[Empty]";continue}  
            $script:description = $_.psbase.Qualifiers.item("description").value  
            ${Global:WmiExplorer.dtClasses}.Rows.Add($_.__path,$mp,$_.name,$description)  
            $LI = New-Object system.Windows.Forms.ListViewItem  
            $li.Name = $_.name  
            $li.Text = $_.name  
            $li.SubItems.add($description)  
            $li.SubItems.add($_.__path)  
            $li.ToolTipText = $description  
            $lvClasses.Items.add($li)  
        }  
        $status.Text = "Ready, Retrieved $i Classes from $mp"  
      } #'if(${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'"))  
      $lvClasses.Sorting = 'Ascending'  
      $lvClasses.Sort()  
      $script:nsc.Add($mp,(([System.Windows.Forms.ListViewItem[]]($lvClasses.Items)).clone()))  
       
    }  
    $lvClasses.EndUpdate()  
    $this.selectedNode.BackColor = 'AliceBlue'  
    $lblClasses.Text = $i;$lblclasses.Update()  
    $status.BackColor = 'YellowGreen'  
    $statusStrip.Update()  
  } #'if($Script:nsc.Item("$mp"))  
     
} #' GetClassesFromNameSpace  
#'endregion  
#'region GetWmiClass  
Function GetWmiClass {  
    #' Update Status  
     
    $status.Text = "Retrieving Class"  
    $status.BackColor = 'Khaki'  
    $statusstrip.Update()  
    $lblClass.Text =  $this.SelectedItems |ForEach-Object {$_.name}  
    $lblPath.text = $this.SelectedItems |ForEach-Object {"$($_.SubItems[2].text)"}  
     
    #' Add HelpText  
     
    $rtbHelp.Text = ""  
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext("$($lblClass.Text)`n`n")  
    $rtbHelp.selectionFont  = $fontNormal  
    $rtbHelp.appendtext(($this.SelectedItems |ForEach-Object {"$($_.SubItems[1].text)"}))  
    $rtbHelp.appendtext("`n")  
    $path = $lblPath.text  
     
    $opt = new-object system.management.ObjectGetOptions  
    $opt.UseAmendedQualifiers = $true  
     
    $script:WmiClass = new-object system.management.ManagementClass($path,$opt)  
    #' Add Property Help  
     
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext("`n$($lblClass.Text) Properties :`n`n")  
    $rtbHelp.selectionFont  = $fontNormal  
     
    $i = 0 ;$lblProperties.Text = $i; $lblProperties.Update()  
    $clbproperties.Items.Clear()  
    $clbProperties.Items.add('WmiPath',$False)  
             
    $script:WmiClass.psbase.properties |  
    ForEach-Object {  
        $i++ ;$lblProperties.Text = $i; $lblProperties.Update()  
        $clbProperties.Items.add($_.name,$true)  
        $rtbHelp.selectionFont  = $fontBold  
        $rtbHelp.appendtext("$($_.Name) :`n" )  
        &amp;{  
            Trap {$rtbHelp.appendtext("[Empty]");Continue}  
            $rtbHelp.appendtext($_.psbase.Qualifiers["description"].value)  
        }  
        $rtbHelp.appendtext("`n`n")  
    } #' ForEach-Object  
     
    #' Create Method Help  
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext( "$($lblClass.Text) Methods :`n`n" )  
    $i = 0 ;$lblMethods.Text = $i; $lblMethods.Update()  
    $lbmethods.Items.Clear()  
     
    $script:WmiClass.psbase.Methods |  
    ForEach-Object {  
        $i++ ;$lblMethods.Text = $i; $lblMethods.Update()  
        $lbMethods.Items.add($_.name)  
        $rtbHelp.selectionFont  = $fontBold  
        $rtbHelp.appendtext("$($_.Name) :`n")  
        &amp;{  
            Trap {$rtbHelp.Text += "[Empty]"}  
            $rtbHelp.appendtext($_.Qualifiers["description"].value)  
        }  
        $rtbHelp.appendtext("`n`n" )  
    } #'ForEach-Object  
      
    $tabControl.SelectedTab = $tabpage1  
    $status.Text = "Retrieved Class"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
} #' GetWmiClass  
#'endregion  
#'region GetWmiInstances  
Function GetWmiInstances {  
    $status.Text = "Getting Instances for $($lblClass.text)"  
    $status.BackColor = 'Red'  
    $statusstrip.Update()  
    $tabControl.SelectedTab = $tabInstances  
    $MC = new-object system.management.ManagementClass $lblPath.text  
    $MOC = $MC.PSbase.getInstances()  
     
    #'trap{"Class Not found";break}  
     
    $DT =  new-object  System.Data.DataTable  
    $DT.TableName = $lblClass.text  
    $Col =  new-object System.Data.DataColumn  
    $Col.ColumnName = "WmiPath"  
    $DT.Columns.Add($Col)  
    $i = 0  
    $j = 0 ;$lblInstances.Text = $j; $lblInstances.Update()  
    $MOC | ForEach-Object {  
        $j++ ;$lblInstances.Text = $j; $lblInstances.Update()  
        $MO = $_  
         
        #' Make a DataRow  
        $DR = $DT.NewRow()  
        $Col =  new-object System.Data.DataColumn  
         
        $DR.Item("WmiPath") = $mo.__PATH  
        $MO.psbase.properties |  
        ForEach-Object {  
            $prop = $_  
            If ($i -eq 0)  {  
     
                #' Only On First Row make The Headers  
                 
                $Col =  new-object System.Data.DataColumn  
                $Col.ColumnName = $prop.Name.ToString()  
                $prop.psbase.Qualifiers | ForEach-Object {  
                    If ($_.Name.ToLower() -eq "key") {  
                        $Col.ColumnName = $Col.ColumnName + "*"  
                    }  
                }  
                $DT.Columns.Add($Col)   
            }  
             
            #' fill dataRow   
             
            if ($prop.value -eq $null) {  
                $DR.Item($prop.Name) = "[empty]"  
            }  
            ElseIf ($prop.IsArray) {  
                                $ofs = ";"  
                $DR.Item($prop.Name) ="$($prop.value)"  
                                $ofs = $null  
            }  
            Else {  
                $DR.Item($prop.Name) = $prop.value  
                #'Item is Key try again with *  
                trap{$DR.Item("$($prop.Name)*") = $prop.Value.tostring();continue}  
            }  
        }  
        #' Add the row to the DataTable  
        $DT.Rows.Add($DR)  
        $i += 1  
    }  
    $DGInstances.DataSource = $DT.psObject.baseobject  
        $DGInstances.Columns.Item('WmiPath').visible =  $clbProperties.GetItemChecked(0)   
    $status.Text = "Retrieved $j Instances"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
} #' GetWmiInstances  
#'endregion  
#'region OutputWmiInstance  
Function OutputWmiInstance {  
    if ( $this.SelectedRows.count -eq 1 ) {  
        if (-not $Script:InstanceTab) {$Script:InstanceTab = new-object System.Windows.Forms.TabPage  
            $Script:InstanceTab.Name = 'Instance'  
            $Script:rtbInstance = new-object System.Windows.Forms.RichTextBox  
            $Script:rtbInstance.Dock = [System.Windows.Forms.DockStyle]::Fill  
            $Script:rtbInstance.Font = $fontCode  
            $Script:rtbInstance.DetectUrls = $false  
            $Script:InstanceTab.controls.add($Script:rtbInstance)  
            $TabControl.TabPages.add($Script:InstanceTab)  
        }  
        $Script:InstanceTab.Text = "Instance = $($this.SelectedRows | ForEach-Object {$_.DataboundItem.wmiPath.split(':')[1]})" 
        $Script:rtbInstance.Text = $this.SelectedRows |ForEach-Object {$_.DataboundItem |Format-List  * | out-String -width 1000 } 
        $tabControl.SelectedTab = $Script:InstanceTab  
    }  
}  #' OutputWmiInstance  
#'endregion  
#'region GetWmiMethod  
Function GetWmiMethod {  
    $WMIMethod = $this.SelectedItem  
    $WmiClassName = $script:WmiClass.__Class  
    $tabControl.SelectedTab = $tabMethods  
    #'$rtbmethods.ForeColor = 'Green'  
    $rtbMethods.Font  = new-object System.Drawing.Font("Microsoft Sans Serif",8)  
    $rtbMethods.text = ""  
    $rtbMethods.selectionFont  = $fontBold  
     
    $rtbMethods.AppendText(("{1} Method : {0} `n" -f $this.SelectedItem , $script:WmiClass.__Class))  
    $rtbMethods.AppendText("`n")  
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("OverloadDefinitions:`n")  
    $rtbMethods.AppendText("$($script:WmiClass.$WMIMethod.OverloadDefinitions)`n`n")  
    $Qualifiers=@()  
    $script:WmiClass.psbase.Methods[($this.SelectedItem)].Qualifiers | ForEach-Object {$qualifiers += $_.name}  
    #'$rtbMethods.AppendText( "$qualifiers`n" )  
    $static = $Qualifiers -Contains "Static"   
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText( "Static : $static`n" )  
    If ($static) {   
         $rtbMethods.AppendText( "A Static Method does not an Instance to act upon`n`n" )  
         $rtbMethods.AppendText("`n")  
     
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Sample Of Connecting to a WMI Class`n`n")  
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $SB = new-Object text.stringbuilder  
         $SB = $SB.Append('$Computer = "') ; $SB = $SB.AppendLine(".`"")  
         $SB = $SB.Append('$Class = "') ; $SB = $SB.AppendLine("$WmiClassName`"")    
         $SB = $SB.Append('$Method = "') ; $SB = $SB.AppendLine("$WmiMethod`"`n")  
         $SB = $SB.AppendLine('$MC = [WmiClass]"\\$Computer\' + "$($script:WmiClass.__NAMESPACE)" + ':$Class"')    
         #'$SB = $SB.Append('$MP.Server = "') ; $SB = $SB.AppendLine("$($MP.Server)`"")    
         #'$SB = $SB.Append('$MP.NamespacePath = "') ; $SB = $SB.AppendLine("$($script:WmiClass.__NAMESPACE)`"")    
         #'$SB = $SB.AppendLine('$MP.ClassName = $Class')  
         $SB = $SB.AppendLine("`n")     
         #'$SB = $SB.AppendLine('$MC = new-object system.management.ManagementClass($MP)')    
         $rtbMethods.AppendText(($sb.tostring()))  
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Getting information about the methods`n`n")  
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText(  
             '$mc' + "`n" +  
             '$mc | Get-Member -membertype Method' + "`n" +  
             "`$mc.$WmiMethod"  
         )  
    } Else {  
         $rtbMethods.AppendText( "This is a non Static Method and needs an Instance to act upon`n`n" )  
         $rtbMethods.AppendText( "The Example given will use the Key Properties to Connect to a WMI Instance : `n`n" )  
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Example Of Connecting to an Instance`n`n")  
     
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $SB = new-Object text.stringbuilder  
         $SB = $SB.AppendLine('$Computer = "."')  
         $SB = $SB.Append('$Class = "') ; $SB = $SB.AppendLine("$WmiClassName.`"")    
         $SB = $SB.Append('$Method = "') ; $SB = $SB.AppendLine("$WMIMethod`"")  
         $SB = $SB.AppendLine("`n#' $WmiClassName. Key Properties :")    
         $Filter = ""    
         $script:WmiClass.psbase.Properties | ForEach-Object {    
           $Q = @()  
           $_.psbase.Qualifiers | ForEach-Object {$Q += $_.name}   
           $key = $Q -Contains "key"   
           If ($key) {    
             $CIMType = $_.psbase.Qualifiers["Cimtype"].Value    
             $SB = $SB.AppendLine("`$$($_.Name) = [$CIMType]")    
             $Filter += "$($_.name) = `'`$$($_.name)`'"     
           }    
         }    
         $SB = $SB.Append("`n" + '$filter=');$SB = $SB.AppendLine("`"$filter`"")    
         $SB = $SB.AppendLine('$MC = get-WMIObject $class -computer $Computer -Namespace "' +  
             "$($script:WmiClass.__NAMESPACE)" + '" -filter $filter' + "`n")  
         $SB = $SB.AppendLine('#' $MC = [Wmi]"\\$Computer\Root\CimV2:$Class.$filter"')   
         $rtbMethods.AppendText(($sb.tostring()))  
    }   
    $SB = $SB.AppendLine('$InParams = $mc.psbase.GetMethodParameters($Method)')  
    $SB = $SB.AppendLine("`n")  
    #' output Method Parameter Help  
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("`n`n$WmiClassName. $WMIMethod Method :`n`n")   
    $q = $script:WmiClass.PSBase.Methods[$WMIMethod].Qualifiers | foreach {$_.name}  
    if ($q -contains "Description") {  
         $rtbMethods.AppendText(($script:WmiClass.psbase.Methods[$WMIMethod].psbase.Qualifiers["Description"].Value))  
    }   
   
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("`n`n$WMIMethod Parameters :`n")   
  #' get the Parameters   
    
  $inParam = $script:WmiClass.psbase.GetMethodParameters($WmiMethod)  
  $HasParams = $False   
  if ($true) {   
    trap{$rtbMethods.AppendText('[None]') ;continue}    
    $inParam.PSBase.Properties | foreach {   
      $Q = $_.Qualifiers | foreach {$_.name}  
      #' if Optional Qualifier is not present then Parameter is Mandatory   
      $Optional = $q -contains "Optional"  
      $CIMType = $_.Qualifiers["Cimtype"].Value   
      $rtbMethods.AppendText("`nName = $($_.Name) `nType = $CIMType `nOptional = $Optional")  
      #' write Parameters to Example script   
      if ($Optional -eq $TRUE) {$SB = $SB.Append('#' ')}   
      $SB = $SB.Append('$InParams.');$SB = $SB.Append("$($_.Name) = ");$SB = $SB.AppendLine("[$CIMType]")   
      if ($q -contains "Description") {$rtbMethods.AppendText($_.Qualifiers["Description"].Value)}  
      $HasParams = $true    
    }   
  }  
  #' Create the Rest of the Script  
  $rtbMethods.selectionFont  = $fontBold  
  $rtbMethods.AppendText("`n`nTemplate Script :`n")   
  #' Call diferent Overload as Method has No Parameters   
  If ($HasParams -eq $True) {   
      $SB = $SB.AppendLine("`n`"Calling $WmiClassName. : $WMIMethod with Parameters :`"")   
      $SB = $SB.AppendLine('$inparams.PSBase.properties | select name,Value | format-Table')   
      $SB = $SB.AppendLine("`n" + '$R = $mc.PSBase.InvokeMethod($Method, $inParams, $Null)')   
  }Else{   
      $SB = $SB.AppendLine("`n`"Calling $WmiClassName. : $WMIMethod `"")   
      $SB = $SB.AppendLine("`n" + '$R = $mc.PSBase.InvokeMethod($Method,$Null)')   
  }   
  $SB = $SB.AppendLine('"Result :"')   
  $SB = $SB.AppendLine('$R | Format-list' + "`n`n")  
  #' Write Header of the Sample Script :   
   
  $rtbMethods.SelectionColor = 'Green'  
  $rtbMethods.SelectionFont = $fontCode  
  $rtbMethods.AppendText(@"  
#' $WmiClassName. $WMIMethod-Method Template Script"   
#' Created by PowerShell WmiExplorer  
#' /\/\o\/\/ 2006  
#' www.ThePowerShellGuy.com  
#'  
#' Fill InParams values before Executing   
#' InParams that are Remarked (#) are Optional  
"@  
  )  
  $rtbMethods.SelectionColor = 'Black'  
  #'$rtbMethods.SelectionFont = $fontCode  
  $rtbMethods.AppendText("`n`n" + $SB)  
  $rtbMethods.SelectionFont = new-object System.Drawing.Font("Lucida Console",6 )  
  $rtbMethods.AppendText("`n`n Generated by the PowerShell WMI Explorer  /\/\o\/\/ 2006" )  
         
} #' GetWmiMethod  
#'endregion  
#'endregion  
#' Show the Form  
$FrmMain.Add_Shown({$FrmMain.Activate()})  
   
trap {Write-Host $_ ;$status.Text = "unexpected error";$slMessage.Text = "$_.message";continue}  
&amp; {  
    [void]$FrmMain.showdialog()  
}  
#' Resolve-Error $Error[0] | out-string</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>PYTHON_logic_loops_Conditionals</Category>
        <Language>PYTHON</Language>
        <Public>false</Public>
        <Name>if_elif_else</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PYTHON_logic_loops_Conditionals</Category>
          <Language>PYTHON</Language>
          <Public>false</Public>
          <Name>if_elif_else</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#Python uses this in place of a CASE or SWITCH


if True:
    print('if true')
elif False:
    print('elif true')
else:
    print('neither true')


#==================================================
x = 42
y = 73

if x &lt; y:
    print('x &lt; y: x is {} and y is {}'.format(x, y))
elif x &gt; y:
    print('Yo mama')
elif x == y:
    print('Yo mama was a sissy')    
else:
    print('Do something else')</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>PYTHON</Category>
        <Language>PYTHON</Language>
        <Public>false</Public>
        <Name>print_MISC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PYTHON</Category>
          <Language>PYTHON</Language>
          <Public>false</Public>
          <Name>print_MISC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.python.org/3/library/string.html#string-formatting
This link has many details


#Some simple format string examples:

"First, thou shalt count to {0}"  # References first positional argument
"Bring me a {}"                   # Implicitly references the first positional argument
"From {} to {}"                   # Same as "From {0} to {1}"
"My quest is {name}"              # References keyword argument 'name'
"Weight in tons {0.weight}"       # 'weight' attribute of first positional arg
"Units destroyed: {players[0]}"   # First element of keyword argument 'players'.

#The meaning of the various alignment options is as follows:
#===============================================================
'&lt;'
#Forces the field to be left-aligned within the available space (this is the default for most objects).
'&gt;'
#Forces the field to be right-aligned within the available space (this is the default for numbers).
'='
#Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form +000000120. This alignment option is only valid for numeric types. It becomes the default when 0 immediately precedes the field width.
'^'
#Forces the field to be centered within the available space.

#The sign option is only valid for number types, and can be one of the following:
#===============================================================
'+'
#indicates that a sign should be used for both positive as well as negative numbers.
'-'
#indicates that a sign should be used only for negative numbers (this is the default behavior).
space
#indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers.

#The available string presentation types are:
#The sign option is only valid for number types, and can be one of the following:
#===============================================================
's'
#String format. This is the default type for strings and may be omitted.
None
#The same as 's'.

#The available integer presentation types are:
#===============================================================
'b'
#Binary format. Outputs the number in base 2.
'c'
#Character. Converts the integer to the corresponding unicode character before printing.
'd'
#Decimal Integer. Outputs the number in base 10.
'o'
#Octal format. Outputs the number in base 8.
'x'
#Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9.
'X'
#Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9.
'n'
#Number. This is the same as 'd', except that it uses the current locale setting to insert the appropriate number separator characters.
None
#The same as 'd'.

#The available presentation types for floating point and decimal values are:
#===============================================================
'e'
#Exponent notation. Prints the number in scientific notation using the letter e to indicate the exponent. The default precision is 6.
'E'
#Exponent notation. Same as 'e' except it uses an upper case E as the separator character.
'f'
#Fixed-point notation. Displays the number as a fixed-point number. The default precision is 6.
'F'
#Fixed-point notation. Same as 'f', but converts nan to NAN and inf to INF.
'g'
#General format. For a given precision p &gt;= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude.
#The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then, if m &lt;= exp &lt; p, where m is -4 for floats and -6 for Decimals, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the '#' option is used.
#Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision.
#A precision of 0 is treated as equivalent to a precision of 1. The default precision is 6.
'G'
#General format. Same as 'g' except switches to 'E' if the number gets too large. The representations of infinity and NaN are uppercased, too.
'n'
#Number. This is the same as 'g', except that it uses the current locale setting to insert the appropriate number separator characters.
'%'
#Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a percent sign.
None
#Similar to 'g', except that fixed-point notation, when used, has at least one digit past the decimal point. The default precision is as high as needed to represent the particular value. The overall effect is to match the output of str() as altered by the other format modifiers.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>ReSharper</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>Method_Signature</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>ReSharper</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>Method_Signature</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

C# 
   
To learn about available method signatures, place the caret between parentheses of a method call and press Ctrl+P.  

To switch between signatures and their descriptions, press Ctrl+P or Ctrl+Shift+P. 
 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SCHEMA_Organization</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Schema_Logins_Users_Tables_Revert_</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SCHEMA_Organization</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Schema_Logins_Users_Tables_Revert_</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>	--You don't need to GRANT table creation permission to the logins if you don't want to,
	--you can instead just use a higher level account an do 
	--CREATE TABLE S1.Test(...). I just find it easier to do it this way so that 
	--I don't have to qualify everything all the time. After I create things then
	--I can just REVOKE the permission.



--//Make sure we're using the correct credentials, this undoes any calls to EXECUTE AS ...
REVERT
GO

--//Switch to the master database
USE MASTER
GO

--//Create our test database
CREATE DATABASE Tester
GO

--//Swtich to the test database
USE Tester
GO

--//CREATE two logins, T1 and T2
CREATE LOGIN T1 WITH PASSWORD = 'T1'
CREATE USER T1 WITH DEFAULT_SCHEMA = S1

CREATE LOGIN T2 WITH PASSWORD = 'T2'
CREATE USER T2 WITH DEFAULT_SCHEMA = S2
GO

--//Give them permission to create tables
GRANT CREATE TABLE to T1
GRANT CREATE TABLE to T2
GO

--//Create two schemas, S1 and S2
CREATE SCHEMA S1 AUTHORIZATION T1
GO
CREATE SCHEMA S2 AUTHORIZATION T2
GO

--//Switch context to the T1 user
EXECUTE AS USER = 'T1'
GO

--//Create our table
CREATE TABLE Test
(
Col1 varChar(255)
)
GO

--//Insert some data
INSERT INTO Test VALUES ('This is from schema 1')
GO

--//Displays schema 1
SELECT * FROM Test

--//Switch back to the currently logged in user
REVERT
GO

--//Switch context to the T2 user
EXECUTE AS USER = 'T2'
GO

--//Create our table
CREATE TABLE Test
(
Col1 varChar(255)
)
GO

--//Insert some data
INSERT INTO Test VALUES ('This is from schema 2')
GO

--//Displays schema 2
SELECT * FROM Test
GO

--//Switch back to the currently logged in user
REVERT
GO

--//As the main user now select from both tables by schema-prefix
SELECT * FROM S1.Test
UNION
SELECT * FROM S2.Test


--//Cleanup everything that we just made
DROP TABLE S1.Test
DROP TABLE S2.Test

DROP SCHEMA S1
DROP SCHEMA S2

DROP LOGIN T1
DROP LOGIN T2
GO

USE MASTER
GO

DROP DATABASE Tester
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQLCMD</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Nomenclature_and_Syntax</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQLCMD</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Nomenclature_and_Syntax</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.simple-talk.com/sql/sql-tools/sql-server-sqlcmd-basics/

see BAT section of DOSBATCH language
/*
a colon (:) precedes the sqlcmd directives. 
The colon is required for most of these commands. 
For a few of them, however, such as quit and exit, you can omit the colon. 

each sqlcmd directive must run on its own line
*/
--WINDOWS COMMAND
\\\\\\\\\\\\\\\\\
--This one begins with double exclamation points (!!):
:!!if exist C:\DataFiles\PersonData.txt del C:\DataFiles\PersonData.txt
--The exclamation points let you run a Windows operating system command, such as those youd run directly at a command prompt.

--CONNECT
\\\\\\\\\\\\
The second line in our example uses the connect command to specify a connection to a SQL Server instance:

:connect localhost\sqlsrv2012

/*
Although this example is specific to a local SQL Server instance, 
	you can connect to any available instance for which youve been granted access. 
If that instance is the default one, you need only provide the server name. 
In addition, when you specify the server and, optionally, the instance name, 
sqlcmd uses Windows authentication to connect to SQL Server with your current account. 
However, you can also specify a username and password when connecting to an instance. 
To specify a username, add the -U switch followed by the username. 
To include a password, add the -P switch followed by the password. 
If you enter the username option without the password option, youll be prompted for a password.	*/

--OUT
\\\\\\\\\\\\

:out C:\DataFiles\PersonData.txt

/*
The command specifies that all query results should be redirected to an output file, in this case, the PersonData.txt file. 
If the file already exists when you run this commend, the file will be truncated. 
For this reason, you might not need to run a Windows command to first delete the file	*/

--interactive
\\\\\\\\\\\\\

/*
To work in interactive mode, open a command prompt window and enter sqlcmd at the command prompt. 
The prompts drive letter will be replaced by a 1, which represents the first line where you start entering your commands. 
The lines are numbered sequentially until all the commands are submitted, and then the numbering starts again.
*/

--When you use sqlcmd to switch to interactive mode, the utility establishes a connection to the default instance of SQL Server. 
-- If your system includes only named instances or you want to connect to a specific instance, 
-- you must specify the instance by adding the -S switch and instance name, as shown in the following command:

sqlcmd -S .\sqlsrv2012

-- In this case, Ive used a period to represent the local computer, and Im connecting to an instance named SqlSrv2012. 
--But you can connect to any accessible instance.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQLCMD</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>ReadMe_SQLCMD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQLCMD</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>ReadMe_SQLCMD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ReadMe_SQLCMD

open cmd 
C:\Users\ggarson&gt;

C:\Users\ggarson&gt; sqlcmd -S SQL-SERVER\PRODUCTION
1&gt; 

///////////////////////////////////


{this does a CHECKDB and outputs the results to a text file
C:\Users\ggarson&gt; sqlcmd -S SQL-SERVER\PRODUCTION -Q"DBCC CHECKDB (master) WITH ALL_ERRORMSGS, NO_INFOMSGS" -oC:\errorlist.txt


///////////////////////////////////

sqlcmd {switches are case senstive}
   -a packet_size
   -A (dedicated administrator connection)
   -b (terminate batch job if there is an error)
   -c batch_terminator
   -C (trust the server certificate)
   -d db_name	{this is the default to use for our commands}
   -e (echo input)
   -E (use trusted connection)
   -f codepage | i:codepage[,o:codepage] | o:codepage[,i:codepage]
   -h rows_per_header
   -H workstation_name	{name of the machine that has the instance of SQL Server on it}
   -i input_file
   -I (enable quoted identifiers)
   -k[1 | 2] (remove or replace control characters)
   -K application_intent
   -l login_timeout
   -L[c] (list servers, optional clean output)
   -m error_level
   -M multisubnet_failover
   -N (encrypt connection)
   -o output_file
   -p[1] (print statistics, optional colon format)
   -P password
   -q "cmdline query"
   -Q "cmdline query" (and exit)
   -r[0 | 1] (msgs to stderr)
   -R (use client regional settings)
   -s col_separator
   -S [protocol:]server[\instance_name][,port]	{this is the particular instance on the Hostname machine, e.g. dot (.) for local, 
   			you don't need this switch for a default instance}
   -t query_timeout
   -u (unicode output file)
   -U login_id
   -v var = "value"
   -V error_severity_level
   -w column_width
   -W (remove trailing spaces)
   -x (disable variable substitution)
   -X[1] (disable commands, startup script, environment variables and optional exit)
   -y variable_length_type_display_width
   -Y fixed_length_type_display_width
   -z new_password 
   -Z new_password (and exit)

   -? (usage)
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SSRS</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>CHART_convert_mmm_To_Months_on_X_axis</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SSRS</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>CHART_convert_mmm_To_Months_on_X_axis</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>CHART_convert_mmm_To_Months_on_X_axis

ISSUE:
The X axis is coming in as strings like this: jan, feb, ..., dec
I need them to show up in order, but they would be in alphabetic order


1] Create Calculated field, to use as the "Category Groups" for the chart
	Dataset =&gt; right click =&gt; calculated field properties =&gt; Fields
		{at the bottom add a field 'm' and then for it's formula put this
		
Switch(Fields!RptMonth.Value = "Jan", "01/01/00,
            Fields!RptMonth.Value = "Feb", "02/01/00, 
            Fields!RptMonth.Value = "Mar", "03/01/00, 
            Fields!RptMonth.Value = "Apr", "04/01/00, 
            Fields!RptMonth.Value = "May", "05/01/00, 
            Fields!RptMonth.Value = "Jun", "06/01/00, 
            Fields!RptMonth.Value = "Jul", "07/01/00, 
            Fields!RptMonth.Value = "Aug", "08/01/00, 
            Fields!RptMonth.Value = "Sep", "09/01/00, 
            Fields!RptMonth.Value = "Oct", "10/01/00, 
            Fields!RptMonth.Value = "Nov", "11/01/00, 
            Fields!RptMonth.Value = "Dec", "12/01/00)
            
2] x-axis =&gt; right click =&gt; Horizontal Axis Properties
	
	Axis Options {tab}
		Axis Type: (x) Scaler (Numbers/Dates)
		
		Interval: 1
		Interval Type: Months
	Number {tab}
		Category: Custom, Custom Format:MMM</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SSRS</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>ConditionalFormating_Font_Fill_Background_etc</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SSRS</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>ConditionalFormating_Font_Fill_Background_etc</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Switch(Fields!Reason.Value = 1, "A", Fields!Reason.Value = 2, "H", Fields!Reason.Value = 3, "B",
Fields!Reason.Value = 4, "C", Fields!Reason.Value = 5, "D", Fields!Reason.Value = 6, "E", True, "")

Switch(Fields!TT_5_indicator.Value = 0, "White", Fields!TT_5_indicator.Value = 1, "Green", Fields!TT_5_indicator.Value = 2, "Yellow",Fields!TT_5_indicator.Value = 3, "Red")


Select the field value on the design surface, such that the whole cell is selected (NOT when just the field name is dark-blue selected)
=&gt; Right click =&gt; Text Box Properties =&gt; then select 
a) Fill{left tab} =&gt; Expression {under 'Fill Color'}
OR
b) Font{left tab} =&gt; Color {Fx under the size text box}
//////////////Simple /////////////////////////////////////

Fill
=IIf(((TRIM(Fields!EmployeeStatus.Value)="Complete") and (TRIM(Fields!CompanyPolicy.Value)="Required") OR (TRIM(Fields!CompanyPolicy.Value)="Optional")),"White","Yellow")

Font color
=IIf(((TRIM(Fields!EmployeeStatus.Value)="Complete") and (TRIM(Fields!CompanyPolicy.Value)="Required") OR (TRIM(Fields!CompanyPolicy.Value)="Optional")),"Black","Red")

Bold
=IIf(((TRIM(Fields!EmployeeStatus.Value)="Complete") and (TRIM(Fields!CompanyPolicy.Value)="Required") OR (TRIM(Fields!CompanyPolicy.Value)="Optional")),"Default","Bold")


////////////three levels, sub-IIF statement //////////////

=IIf(((TRIM(Fields!Status.Value)="Approved_By_Accounting")),"White",IIf(((TRIM(Fields!Status.Value)="Approved_By_Supervisor")),"Yellow","Orange"))


//////////////alternative Simple /////////////////////////////////////

Fill
=IIf(((TRIM(Fields!EmployeeStatus_Training.Value)="Incomplete") and (TRIM(Fields!CompanyPolicy_Training.Value)="Required") OR (TRIM(Fields!CompanyPolicy_Training.Value)="Mandatory_All_Employees")),"Yellow","White")

Font color
=IIf(((TRIM(Fields!EmployeeStatus_Training.Value)="Incomplete") and (TRIM(Fields!CompanyPolicy_Training.Value)="Required") OR (TRIM(Fields!CompanyPolicy_Training.Value)="Mandatory_All_Employees")),"Red","Black")


//////////////- Ok, Expired, Will Expire /////////////////////////////////////

FONT:
=IIf(  TRIM(Fields!Gen__Liab__Status.Value)="Will EXPIRE" ,"Red","Black")

FILL:
=IIf(((TRIM(Fields!Gen__Liab__Status.Value)="EXPIRED") OR (TRIM(Fields!Gen__Liab__Status.Value)="Will EXPIRE") ),"Yellow","White")

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

using colors:
=IIf(  (Sum(Fields!KPI_sp_1.Value, "Main") &lt; Sum(Fields!KPI_sp_1_GOAL.Value, "Main")) ,"#f7d5ff","#dcffe3")

0 to goal is one color, above goal up to 1.00 is one color, over 1 is Yellow
=IIf(  (Sum(Fields!KPI_sp_1.Value, "Main") &lt; Sum(Fields!KPI_sp_1_GOAL.Value, "Main")) ,"#f7d5ff",IIf( (Sum(Fields!KPI_sp_1.Value, "Main")&gt;1), "Yellow","#dcffe3")  )
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
WHITE if null, Green if below the GrandTotal, Red if above the GrandTotal
=IIf( IsNothing(Fields!AVG_TT_byDecisionLO.Value),"White",IIf(   Fields!AVG_TT_byDecisionLO.Value &gt; Fields!AVG_TT__forGRANDtotals.Value,"Red","Green"))</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SSRS</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>HyperLink_To_The_Report_in_TABLE_of_CONTENTS</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SSRS</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>HyperLink_To_The_Report_in_TABLE_of_CONTENTS</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>HyperLink_To_The_Report_in_TABLE_of_CONTENTS

NOTE: 
1] The stuff on this page is for the expression
2] On the General Tab of the Placeholder: (x) HTML - Interpret HTML tags as styles
3] Action tab of the Placeholder: (x) None
4] On the Action Tab of the Text Box: 
	(x) Go to URL
	in the SELECT URL: text box put the field which has the URI
	
#########################################################################--- BROWSER and URI for files
Both work in IE, but neither works in Chrome

file://cbtbrfs02/Credit/Credit%20Risk/_Modules/DataGovernance_DoNotEdit/test.sql

file:\\cbtbrfs02\Credit\Credit%20Risk\_Modules\DataGovernance_DoNotEdit\test.sql
	
#########################################################################################################

&lt;a href="""  + Fields!Report_Hyperlink.Value+ "" "&gt;
External Link
&lt;/a&gt;


---------------------------------------------

="&lt;a href="""  + Fields!Report_Hyperlink.Value+ """&gt; CLICK &lt;/a&gt;"

--Show the hyperlink if it is there, otherwise just a dot
=IIf( Len(Fields!Report_Hyperlink.Value)&gt; 0, "&lt;a href="""  + Fields!Report_Hyperlink.Value + """&gt; CLICK &lt;/a&gt;", ".")


=IIf( Len(Fields!Report_Hyperlink.Value)&gt; 0, "&lt;a href="""  + Fields!Report_Hyperlink.Value + """ target= """  + "blank" + """&gt; CLICK &lt;/a&gt;", ".")

="&lt;a href="""  + Fields!Report_Hyperlink.Value + """ target= """  + "blank" + """&gt; " + Fields!SSRS_BirdCrumbPath.Value + " &lt;/a&gt;"



---------------------------------------------TARGET = BLANK is not working yet

="&lt;a href="""  + Fields!Report_Hyperlink.Value + """&gt; External Link &lt;/a&gt;"

=IIf( Len(Fields!Report_Hyperlink.Value)&gt; 0, "&lt;a href="""  + Fields!Report_Hyperlink.Value + """&gt; CLICK &lt;/a&gt;", ".")

=Switch(Fields!State.Value = "OR","Oregon",Fields!State.Value = "WA","Washington")
=Switch(Fields!FirstName.Value = "Sue","Susan",Fields!FirstName.Value = "Bob","Robert")


=IIf( Len(Fields!Report_Hyperlink.Value)&gt; 0, "&lt;a href="""  + Fields!Report_Hyperlink.Value + """&gt; CLICK &lt;/a&gt;", ".")

=IIf( Len(Fields!Report_Hyperlink.Value)&gt; 0, "&lt;a href="""  + Fields!Report_Hyperlink.Value + """ target= """  + "blank" + """&gt; CLICK &lt;/a&gt;", ".")

=IIf( 
      (Len(Fields!Report_Hyperlink.Value)&gt; 0) AND (Len(Fields!SSRS_BirdCrumbPath.Value)&gt; 0) 
      , 
      "&lt;a href="""  + Fields!Report_Hyperlink.Value + """ target= """  + "blank" + """&gt; " + Fields!SSRS_BirdCrumbPath.Value + " &lt;/a&gt;"
      , 
      "."
    )


=IIf( 
      (Len(Fields!Report_Hyperlink.Value)&gt; 0) AND (Len(Fields!SSRS_BirdCrumbPath.Value)&gt; 0) 
      , 
      "&lt;a href="""  + Fields!Report_Hyperlink.Value + """ target= """  + "blank" + """&gt; " + Fields!SSRS_BirdCrumbPath.Value + " &lt;/a&gt;"
      , 
      IIf( 
           (Len(Fields!Report_Hyperlink.Value)&gt; 0) AND (Len(Fields!SSRS_BirdCrumbPath.Value) = 0) 
      	   , 
           "&lt;a href="""  + Fields!Report_Hyperlink.Value + """ target= """  + "blank" + """&gt; CLICK &lt;/a&gt;"
	   ,
      	   IIf( 
           	(Len(Fields!Report_Hyperlink.Value) = 0) AND (Len(Fields!SSRS_BirdCrumbPath.Value) &gt; 0) 
      	   	, 
           	Fields!SSRS_BirdCrumbPath.Value
	   	,
		"."
	      )
	 )
    )
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Identity_removeProperty_butKeepTheData</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Identity_removeProperty_butKeepTheData</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--[1]========================================================================

--The new column did not create a new auto-increment field, rather the old field was still auto-increment
BEGIN TRAN
BEGIN TRY
    EXEC sp_rename '[SomeTable].[Id]', 'OldId';

    ALTER TABLE [SomeTable] ADD Id int NULL

    EXEC ('UPDATE [SomeTable] SET Id = OldId')

    ALTER TABLE [SomeTable] NOCHECK CONSTRAINT ALL

    ALTER TABLE [SomeTable] DROP CONSTRAINT [PK_constraintName];
    ALTER TABLE [SomeTable] DROP COLUMN OldId
    ALTER TABLE [SomeTable] ALTER COLUMN [Id] INTEGER NOT NULL
    ALTER TABLE [SomeTable] ADD CONSTRAINT PK_JobInfo PRIMARY KEY (Id)

    ALTER TABLE [SomeTable] CHECK CONSTRAINT ALL

    COMMIT TRAN
END TRY
BEGIN CATCH
    ROLLBACK TRAN   
    SELECT ERROR_MESSAGE ()
END CATCH


--[1]========================================================================
/*
DID NOT TRY THIS YET

Remove all foreign keys that point to this table
Script the table to be created; rename everything e.g. 'MyTable2', 'MyIndex2', etc. Remove the IDENTITY specification.
You should now have two "identical"-ish tables, one full, the other empty with no IDENTITY.
Run ALTER TABLE [Original] SWITCH TO [Original2]
Now your original table will be empty and the new one will have the data. You have switched the metadata for the two tables (instant).
Drop the original (now-empty table), exec sys.sp_rename to rename the various schema objects back to the original names, and then you can recreate your foreign keys.
*/

--For example, given:

CREATE TABLE Original
(
  Id INT IDENTITY PRIMARY KEY
, Value NVARCHAR(300)
);
CREATE NONCLUSTERED INDEX IX_Original_Value ON Original (Value);

INSERT INTO Original
SELECT 'abcd'
UNION ALL 
SELECT 'defg';
--You can do the following:

--create new table with no IDENTITY
CREATE TABLE Original2
(
  Id INT PRIMARY KEY
, Value NVARCHAR(300)
);
CREATE NONCLUSTERED INDEX IX_Original_Value2 ON Original2 (Value);

--data before switch
SELECT 'Original', *
FROM Original
UNION ALL
SELECT 'Original2', *
FROM Original2;

ALTER TABLE Original SWITCH TO Original2;		--&lt;=== NOTE this is for "partitioned" data tables ??????

--data after switch
SELECT 'Original', *
FROM Original
UNION ALL
SELECT 'Original2', *
FROM Original2;

--clean up
DROP TABLE Original;
EXEC sys.sp_rename 'Original2.IX_Original_Value2', 'IX_Original_Value', 'INDEX';
EXEC sys.sp_rename 'Original2', 'Original', 'OBJECT';


UPDATE Original
SET Id = Id + 1;

SELECT *
FROM Original;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TimeZone_DaylightSavingsTime_UTC_GMT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>about_TimeZone_DaylightSavingsTime_UTC_GMT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TimeZone_DaylightSavingsTime_UTC_GMT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>about_TimeZone_DaylightSavingsTime_UTC_GMT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_TimeZone_DaylightSavingsTime_UTC_GMT

UTC time?
--Prior to 1972, this time was called Greenwich Mean Time (GMT) 
--but is now referred to as Coordinated Universal Time 
--or Universal Time Coordinated (UTC). 

--It is a coordinated time scale, maintained by the Bureau International des Poids et Mesures (BIPM). 
--It is also known as "Z time" or "Zulu Time

Handle conversion between time zones in SQL Server - part 1
https://www.mssqltips.com/sqlservertip/3173/handle-conversion-between-time-zones-in-sql-server--part-1/

 DATETIMEOFFSET is not Daylight Savings Time-aware
 
 
 
--For the Eastern time zone, in the Spring, we move from 2 AM to 3 AM local time, at 7 AM UTC ("Spring forward"). 
--And in the Fall, we move from 2 AM to 1 AM local time, at 6 AM UTC ("Fall back"). 

 -- since 2000 (well, since 1987), 
-- there are only two different conditions for determining the dates of these events: 
-- until 2006, we Spring forward on the first Sunday in April, and Fall back on the last Sunday in October. 
-- In 2007, this changed such that we Spring forward on the second Sunday in March, 
--	and fall back on the first Sunday in November. 
--So, for example, in 2014, we will switch to DST on March 9th, and fall back on November 2nd. 
--We use the local time values in the table only to rule out invalid dates 
--(e.g. 2:20 AM, in Eastern Time, on the morning we Spring forward from 2 AM to 3 AM, is not a possible local time, because it never happened).


==================================================================================================

https://en.wikipedia.org/wiki/List_of_UTC_time_offsets
The main purpose of this page is to list the standard time offsets of different countries, territories and regions. 
Information on daylight saving time or historical changes in offsets can be found in the individual offset articles 
                (e.g. UTC+01:00), 
                or the country-specific time articles (e.g. Time in Russia).
Places that observe daylight saving time (DST) during their respective summer periods are listed only once, 
                at the offset for their winter (usually known as "standard") period; 
*****************************************************************************************************
Several regions in North America, Europe and Australia use daylight saving time (DST). 
                The UTC offset during observation of DST is typically obtained by adding one hour to standard time.       
Examples:
Central European Time UTC+01:00 is replaced by Central European Summer Time UTC+02:00, 
 and Pacific Standard Time UTC08:00 is replaced by Pacific Daylight Time UTC07:00.      

OK: I take this to mean that:
Louisiana is : UTC06:00 (https://en.wikipedia.org/wiki/List_of_UTC_time_offsets)
BUT DURING DAYLIGHT SAVINGS TIME:                
Louisiana is : UTC05:00

HOWEVER WE ARE USING an offset of 5 hours ALL YEAR LONG here at Crescent Bank. THIS NOT THE WAY THAT EVERYONE ELSE IS SUGGESTING THAT IT BE DONE.

*****************************************************************************************************
https://en.wikipedia.org/wiki/UTC%E2%88%9206:00
Louisiana is : UTC06:00 (https://en.wikipedia.org/wiki/List_of_UTC_time_offsets)
UTC06:00 is a time offset that subtracts six hours from Coordinated Universal Time (UTC). 
                In North America, it is observed in the Central Time Zone during standard time,
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>sp_Blitz____script</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>sp_Blitz____script</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>IF OBJECT_ID('dbo.sp_Blitz') IS NULL
  EXEC ('CREATE PROCEDURE dbo.sp_Blitz AS RETURN 0;')
GO

ALTER PROCEDURE [dbo].[sp_Blitz]
    @Help TINYINT = 0 ,
    @CheckUserDatabaseObjects TINYINT = 1 ,
    @CheckProcedureCache TINYINT = 0 ,
    @OutputType VARCHAR(20) = 'TABLE' ,
    @OutputProcedureCache TINYINT = 0 ,
    @CheckProcedureCacheFilter VARCHAR(10) = NULL ,
    @CheckServerInfo TINYINT = 0 ,
    @SkipChecksServer NVARCHAR(256) = NULL ,
    @SkipChecksDatabase NVARCHAR(256) = NULL ,
    @SkipChecksSchema NVARCHAR(256) = NULL ,
    @SkipChecksTable NVARCHAR(256) = NULL ,
    @IgnorePrioritiesBelow INT = NULL ,
    @IgnorePrioritiesAbove INT = NULL ,
    @OutputServerName NVARCHAR(256) = NULL ,
    @OutputDatabaseName NVARCHAR(256) = NULL ,
    @OutputSchemaName NVARCHAR(256) = NULL ,
    @OutputTableName NVARCHAR(256) = NULL ,
    @OutputXMLasNVARCHAR TINYINT = 0 ,
    @EmailRecipients VARCHAR(MAX) = NULL ,
    @EmailProfile sysname = NULL ,
    @SummaryMode TINYINT = 0 ,
    @BringThePain TINYINT = 0 ,
    @VersionDate DATETIME = NULL OUTPUT
AS
    SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET @VersionDate = '20161210';
	SET @OutputType = UPPER(@OutputType);

	IF @Help = 1 PRINT '
	/*
	sp_Blitz from http://FirstResponderKit.org
	
	This script checks the health of your SQL Server and gives you a prioritized
	to-do list of the most urgent things you should consider fixing.

	To learn more, visit http://FirstResponderKit.org where you can download new
	versions for free, watch training videos on how it works, get more info on
	the findings, contribute your own code, and more.

	Known limitations of this version:
	 - Only Microsoft-supported versions of SQL Server. Sorry, 2005 and 2000.
	 - If a database name has a question mark in it, some tests will fail. Gotta
	   love that unsupported sp_MSforeachdb.
	 - If you have offline databases, sp_Blitz fails the first time you run it,
	   but does work the second time. (Hoo, boy, this will be fun to debug.)
      - @OutputServerName will output QueryPlans as NVARCHAR(MAX) since Microsoft
	    has refused to support XML columns in Linked Server queries. The bug is now
		16 years old! *~ \o/ ~*

	Unknown limitations of this version:
	 - None.  (If we knew them, they would be known. Duh.)

     Changes - for the full list of improvements and fixes in this version, see:
     https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/


	Parameter explanations:

	@CheckUserDatabaseObjects	1=review user databases for triggers, heaps, etc. Takes more time for more databases and objects.
	@CheckServerInfo			1=show server info like CPUs, memory, virtualization
	@CheckProcedureCache		1=top 20-50 resource-intensive cache plans and analyze them for common performance issues.
	@OutputProcedureCache		1=output the top 20-50 resource-intensive plans even if they did not trigger an alarm
	@CheckProcedureCacheFilter	''CPU'' | ''Reads'' | ''Duration'' | ''ExecCount''
	@OutputType					''TABLE''=table | ''COUNT''=row with number found | ''MARKDOWN''=bulleted list | ''SCHEMA''=version and field list | ''NONE'' = none
	@IgnorePrioritiesBelow		50=ignore priorities below 50
	@IgnorePrioritiesAbove		50=ignore priorities above 50
	For the rest of the parameters, see http://www.brentozar.com/blitz/documentation for details.

    MIT License

	Copyright (c) 2016 Brent Ozar Unlimited

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.


	*/'
	ELSE IF @OutputType = 'SCHEMA'
	BEGIN
		SELECT FieldList = '[Priority] TINYINT, [FindingsGroup] VARCHAR(50), [Finding] VARCHAR(200), [DatabaseName] NVARCHAR(128), [URL] VARCHAR(200), [Details] NVARCHAR(4000), [QueryPlan] NVARCHAR(MAX), [QueryPlanFiltered] NVARCHAR(MAX), [CheckID] INT'

	END
	ELSE /* IF @OutputType = 'SCHEMA' */
	BEGIN

		/*
		We start by creating #BlitzResults. It's a temp table that will store all of
		the results from our checks. Throughout the rest of this stored procedure,
		we're running a series of checks looking for dangerous things inside the SQL
		Server. When we find a problem, we insert rows into #BlitzResults. At the
		end, we return these results to the end user.

		#BlitzResults has a CheckID field, but there's no Check table. As we do
		checks, we insert data into this table, and we manually put in the CheckID.
		For a list of checks, visit http://FirstResponderKit.org.
		*/
		DECLARE @StringToExecute NVARCHAR(4000)
			,@curr_tracefilename NVARCHAR(500)
			,@base_tracefilename NVARCHAR(500)
			,@indx int
			,@query_result_separator CHAR(1)
			,@EmailSubject NVARCHAR(255)
			,@EmailBody NVARCHAR(MAX)
			,@EmailAttachmentFilename NVARCHAR(255)
			,@ProductVersion NVARCHAR(128)
			,@ProductVersionMajor DECIMAL(10,2)
			,@ProductVersionMinor DECIMAL(10,2)
			,@CurrentName NVARCHAR(128)
			,@CurrentDefaultValue NVARCHAR(200)
			,@CurrentCheckID INT
			,@CurrentPriority INT
			,@CurrentFinding VARCHAR(200)
			,@CurrentURL VARCHAR(200)
			,@CurrentDetails NVARCHAR(4000)
			,@MsSinceWaitsCleared DECIMAL(38,0)
			,@CpuMsSinceWaitsCleared DECIMAL(38,0)
			,@ResultText NVARCHAR(MAX)
			,@crlf NVARCHAR(2)
			,@Processors int
			,@NUMANodes int
			,@MinServerMemory bigint
			,@MaxServerMemory bigint
			,@ColumnStoreIndexesInUse bit;


		SET @crlf = NCHAR(13) + NCHAR(10);
		SET @ResultText = 'sp_Blitz Results: ' + @crlf;
		
		IF OBJECT_ID('tempdb..#BlitzResults') IS NOT NULL
			DROP TABLE #BlitzResults;
		CREATE TABLE #BlitzResults
			(
			  ID INT IDENTITY(1, 1) ,
			  CheckID INT ,
			  DatabaseName NVARCHAR(128) ,
			  Priority TINYINT ,
			  FindingsGroup VARCHAR(50) ,
			  Finding VARCHAR(200) ,
			  URL VARCHAR(200) ,
			  Details NVARCHAR(4000) ,
			  QueryPlan [XML] NULL ,
			  QueryPlanFiltered [NVARCHAR](MAX) NULL
			);

		IF OBJECT_ID('tempdb..#TemporaryDatabaseResults') IS NOT NULL
			DROP TABLE #TemporaryDatabaseResults;
		CREATE TABLE #TemporaryDatabaseResults
			(
			  DatabaseName NVARCHAR(128) ,
			  Finding NVARCHAR(128)
			);

		/*
		You can build your own table with a list of checks to skip. For example, you
		might have some databases that you don't care about, or some checks you don't
		want to run. Then, when you run sp_Blitz, you can specify these parameters:
		@SkipChecksDatabase = 'DBAtools',
		@SkipChecksSchema = 'dbo',
		@SkipChecksTable = 'BlitzChecksToSkip'
		Pass in the database, schema, and table that contains the list of checks you
		want to skip. This part of the code checks those parameters, gets the list,
		and then saves those in a temp table. As we run each check, we'll see if we
		need to skip it.

		Really anal-retentive users will note that the @SkipChecksServer parameter is
		not used. YET. We added that parameter in so that we could avoid changing the
		stored proc's surface area (interface) later.
		*/
		IF OBJECT_ID('tempdb..#SkipChecks') IS NOT NULL
			DROP TABLE #SkipChecks;
		CREATE TABLE #SkipChecks
			(
			  DatabaseName NVARCHAR(128) ,
			  CheckID INT ,
			  ServerName NVARCHAR(128)
			);
		CREATE CLUSTERED INDEX IX_CheckID_DatabaseName ON #SkipChecks(CheckID, DatabaseName);

		IF @SkipChecksTable IS NOT NULL
			AND @SkipChecksSchema IS NOT NULL
			AND @SkipChecksDatabase IS NOT NULL
			BEGIN
				SET @StringToExecute = 'INSERT INTO #SkipChecks(DatabaseName, CheckID, ServerName )
				SELECT DISTINCT DatabaseName, CheckID, ServerName
				FROM ' + QUOTENAME(@SkipChecksDatabase) + '.' + QUOTENAME(@SkipChecksSchema) + '.' + QUOTENAME(@SkipChecksTable)
					+ ' WHERE ServerName IS NULL OR ServerName = SERVERPROPERTY(''ServerName'');'
				EXEC(@StringToExecute)
			END

		IF NOT EXISTS ( SELECT  1
							FROM    #SkipChecks
							WHERE   DatabaseName IS NULL AND CheckID = 106 )
							AND (select convert(int,value_in_use) from sys.configurations where name = 'default trace enabled' ) = 1
			BEGIN
					select @curr_tracefilename = [path] from sys.traces where is_default = 1 ;
					set @curr_tracefilename = reverse(@curr_tracefilename);
					select @indx = patindex('%\%', @curr_tracefilename) ;
					set @curr_tracefilename = reverse(@curr_tracefilename) ;
					set @base_tracefilename = left( @curr_tracefilename,len(@curr_tracefilename) - @indx) + '\log.trc' ;
			END

		/* If the server has any databases on Antiques Roadshow, skip the checks that would break due to CTEs. */
		IF @CheckUserDatabaseObjects = 1 AND EXISTS(SELECT * FROM sys.databases WHERE compatibility_level &lt; 90)
		BEGIN
			SET @CheckUserDatabaseObjects = 0;
			PRINT 'Databases with compatibility level &lt; 90 found, so setting @CheckUserDatabaseObjects = 0.';
			PRINT 'The database-level checks rely on CTEs, which are not supported in SQL 2000 compat level databases.';
			PRINT 'Get with the cool kids and switch to a current compatibility level, Grandpa. To find the problems, run:';
			PRINT 'SELECT * FROM sys.databases WHERE compatibility_level &lt; 90;';
		END


			/* If the server is Amazon RDS, skip checks that it doesn't allow */
		IF LEFT(CAST(SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS VARCHAR(8000)), 8) = 'EC2AMAZ-'
		   AND LEFT(CAST(SERVERPROPERTY('MachineName') AS VARCHAR(8000)), 8) = 'EC2AMAZ-'
		   AND LEFT(CAST(SERVERPROPERTY('ServerName') AS VARCHAR(8000)), 8) = 'EC2AMAZ-'
			BEGIN
						INSERT INTO #SkipChecks (CheckID) VALUES (6);
						INSERT INTO #SkipChecks (CheckID) VALUES (29);
						INSERT INTO #SkipChecks (CheckID) VALUES (30);
						INSERT INTO #SkipChecks (CheckID) VALUES (31);
						INSERT INTO #SkipChecks (CheckID) VALUES (40); /* TempDB only has one data file */
						INSERT INTO #SkipChecks (CheckID) VALUES (57);
						INSERT INTO #SkipChecks (CheckID) VALUES (59);
						INSERT INTO #SkipChecks (CheckID) VALUES (61);
						INSERT INTO #SkipChecks (CheckID) VALUES (62);
						INSERT INTO #SkipChecks (CheckID) VALUES (68);
						INSERT INTO #SkipChecks (CheckID) VALUES (69);
						INSERT INTO #SkipChecks (CheckID) VALUES (73);
						INSERT INTO #SkipChecks (CheckID) VALUES (79);
						INSERT INTO #SkipChecks (CheckID) VALUES (92);
						INSERT INTO #SkipChecks (CheckID) VALUES (94);
						INSERT INTO #SkipChecks (CheckID) VALUES (96);
						INSERT INTO #SkipChecks (CheckID) VALUES (98);
						INSERT INTO #SkipChecks (CheckID) VALUES (100); /* Remote DAC disabled */
						INSERT INTO #SkipChecks (CheckID) VALUES (123);
						INSERT INTO #SkipChecks (CheckID) VALUES (177);
						INSERT INTO #SkipChecks (CheckID) VALUES (180); /* 180/181 are maintenance plans */
						INSERT INTO #SkipChecks (CheckID) VALUES (181);
			END /* Amazon RDS skipped checks */



		/*
		That's the end of the SkipChecks stuff.
		The next several tables are used by various checks later.
		*/
		IF OBJECT_ID('tempdb..#ConfigurationDefaults') IS NOT NULL
			DROP TABLE #ConfigurationDefaults;
		CREATE TABLE #ConfigurationDefaults
			(
			  name NVARCHAR(128) ,
			  DefaultValue BIGINT,
			  CheckID INT
			);

        IF OBJECT_ID ('tempdb..#Recompile') IS NOT NULL 
            DROP TABLE #Recompile; 
        CREATE TABLE #Recompile( 
            DBName varchar(200), 
            ProcName varchar(300), 
            RecompileFlag varchar(1),
            SPSchema varchar(50)
        );

		IF OBJECT_ID('tempdb..#DatabaseDefaults') IS NOT NULL
			DROP TABLE #DatabaseDefaults;
		CREATE TABLE #DatabaseDefaults
			(
				name NVARCHAR(128) ,
				DefaultValue NVARCHAR(200),
				CheckID INT,
		        Priority INT,
		        Finding VARCHAR(200),
		        URL VARCHAR(200),
		        Details NVARCHAR(4000)
			);

		IF OBJECT_ID('tempdb..#DatabaseScopedConfigurationDefaults') IS NOT NULL
			DROP TABLE #DatabaseScopedConfigurationDefaults;
		CREATE TABLE #DatabaseScopedConfigurationDefaults
			(ID INT IDENTITY(1,1), configuration_id INT, [name] NVARCHAR(60), default_value sql_variant, default_value_for_secondary sql_variant, CheckID INT, );



		IF OBJECT_ID('tempdb..#DBCCs') IS NOT NULL
			DROP TABLE #DBCCs;
		CREATE TABLE #DBCCs
			(
			  ID INT IDENTITY(1, 1)
					 PRIMARY KEY ,
			  ParentObject VARCHAR(255) ,
			  Object VARCHAR(255) ,
			  Field VARCHAR(255) ,
			  Value VARCHAR(255) ,
			  DbName NVARCHAR(128) NULL
			)


		IF OBJECT_ID('tempdb..#LogInfo2012') IS NOT NULL
			DROP TABLE #LogInfo2012;
		CREATE TABLE #LogInfo2012
			(
			  recoveryunitid INT ,
			  FileID SMALLINT ,
			  FileSize BIGINT ,
			  StartOffset BIGINT ,
			  FSeqNo BIGINT ,
			  [Status] TINYINT ,
			  Parity TINYINT ,
			  CreateLSN NUMERIC(38)
			);

		IF OBJECT_ID('tempdb..#LogInfo') IS NOT NULL
			DROP TABLE #LogInfo;
		CREATE TABLE #LogInfo
			(
			  FileID SMALLINT ,
			  FileSize BIGINT ,
			  StartOffset BIGINT ,
			  FSeqNo BIGINT ,
			  [Status] TINYINT ,
			  Parity TINYINT ,
			  CreateLSN NUMERIC(38)
			);

		IF OBJECT_ID('tempdb..#partdb') IS NOT NULL
			DROP TABLE #partdb;
		CREATE TABLE #partdb
			(
			  dbname NVARCHAR(128) ,
			  objectname NVARCHAR(200) ,
			  type_desc NVARCHAR(128)
			)

		IF OBJECT_ID('tempdb..#TraceStatus') IS NOT NULL
			DROP TABLE #TraceStatus;
		CREATE TABLE #TraceStatus
			(
			  TraceFlag VARCHAR(10) ,
			  status BIT ,
			  Global BIT ,
			  Session BIT
			);

		IF OBJECT_ID('tempdb..#driveInfo') IS NOT NULL
			DROP TABLE #driveInfo;
		CREATE TABLE #driveInfo
			(
			  drive NVARCHAR ,
			  SIZE DECIMAL(18, 2)
			)


		IF OBJECT_ID('tempdb..#dm_exec_query_stats') IS NOT NULL
			DROP TABLE #dm_exec_query_stats;
		CREATE TABLE #dm_exec_query_stats
			(
			  [id] [int] NOT NULL
						 IDENTITY(1, 1) ,
			  [sql_handle] [varbinary](64) NOT NULL ,
			  [statement_start_offset] [int] NOT NULL ,
			  [statement_end_offset] [int] NOT NULL ,
			  [plan_generation_num] [bigint] NOT NULL ,
			  [plan_handle] [varbinary](64) NOT NULL ,
			  [creation_time] [datetime] NOT NULL ,
			  [last_execution_time] [datetime] NOT NULL ,
			  [execution_count] [bigint] NOT NULL ,
			  [total_worker_time] [bigint] NOT NULL ,
			  [last_worker_time] [bigint] NOT NULL ,
			  [min_worker_time] [bigint] NOT NULL ,
			  [max_worker_time] [bigint] NOT NULL ,
			  [total_physical_reads] [bigint] NOT NULL ,
			  [last_physical_reads] [bigint] NOT NULL ,
			  [min_physical_reads] [bigint] NOT NULL ,
			  [max_physical_reads] [bigint] NOT NULL ,
			  [total_logical_writes] [bigint] NOT NULL ,
			  [last_logical_writes] [bigint] NOT NULL ,
			  [min_logical_writes] [bigint] NOT NULL ,
			  [max_logical_writes] [bigint] NOT NULL ,
			  [total_logical_reads] [bigint] NOT NULL ,
			  [last_logical_reads] [bigint] NOT NULL ,
			  [min_logical_reads] [bigint] NOT NULL ,
			  [max_logical_reads] [bigint] NOT NULL ,
			  [total_clr_time] [bigint] NOT NULL ,
			  [last_clr_time] [bigint] NOT NULL ,
			  [min_clr_time] [bigint] NOT NULL ,
			  [max_clr_time] [bigint] NOT NULL ,
			  [total_elapsed_time] [bigint] NOT NULL ,
			  [last_elapsed_time] [bigint] NOT NULL ,
			  [min_elapsed_time] [bigint] NOT NULL ,
			  [max_elapsed_time] [bigint] NOT NULL ,
			  [query_hash] [binary](8) NULL ,
			  [query_plan_hash] [binary](8) NULL ,
			  [query_plan] [xml] NULL ,
			  [query_plan_filtered] [nvarchar](MAX) NULL ,
			  [text] [nvarchar](MAX) COLLATE SQL_Latin1_General_CP1_CI_AS
									 NULL ,
			  [text_filtered] [nvarchar](MAX) COLLATE SQL_Latin1_General_CP1_CI_AS
											  NULL
			)

		IF OBJECT_ID('tempdb..#ErrorLog') IS NOT NULL
			DROP TABLE #ErrorLog;
		CREATE TABLE #ErrorLog
			(
			  LogDate DATETIME ,
			  ProcessInfo NVARCHAR(20) ,
			  [Text] NVARCHAR(1000) 
			);

		IF OBJECT_ID('tempdb..#IgnorableWaits') IS NOT NULL
			DROP TABLE #IgnorableWaits;
		CREATE TABLE #IgnorableWaits (wait_type NVARCHAR(60));
		INSERT INTO #IgnorableWaits VALUES ('BROKER_EVENTHANDLER');
		INSERT INTO #IgnorableWaits VALUES ('BROKER_RECEIVE_WAITFOR');
		INSERT INTO #IgnorableWaits VALUES ('BROKER_TASK_STOP');
		INSERT INTO #IgnorableWaits VALUES ('BROKER_TO_FLUSH');
		INSERT INTO #IgnorableWaits VALUES ('BROKER_TRANSMITTER');
		INSERT INTO #IgnorableWaits VALUES ('CHECKPOINT_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('CLR_AUTO_EVENT');
		INSERT INTO #IgnorableWaits VALUES ('CLR_MANUAL_EVENT');
		INSERT INTO #IgnorableWaits VALUES ('CLR_SEMAPHORE');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRROR_DBM_EVENT');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRROR_DBM_MUTEX');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRROR_EVENTS_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRROR_WORKER_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRRORING_CMD');
		INSERT INTO #IgnorableWaits VALUES ('DIRTY_PAGE_POLL');
		INSERT INTO #IgnorableWaits VALUES ('DISPATCHER_QUEUE_SEMAPHORE');
		INSERT INTO #IgnorableWaits VALUES ('FT_IFTS_SCHEDULER_IDLE_WAIT');
		INSERT INTO #IgnorableWaits VALUES ('FT_IFTSHC_MUTEX');
		INSERT INTO #IgnorableWaits VALUES ('HADR_CLUSAPI_CALL');
		INSERT INTO #IgnorableWaits VALUES ('HADR_FILESTREAM_IOMGR_IOCOMPLETION');
		INSERT INTO #IgnorableWaits VALUES ('HADR_LOGCAPTURE_WAIT');
		INSERT INTO #IgnorableWaits VALUES ('HADR_NOTIFICATION_DEQUEUE');
		INSERT INTO #IgnorableWaits VALUES ('HADR_TIMER_TASK');
		INSERT INTO #IgnorableWaits VALUES ('HADR_WORK_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('LAZYWRITER_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('LOGMGR_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('ONDEMAND_TASK_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('PREEMPTIVE_HADR_LEASE_MECHANISM');
		INSERT INTO #IgnorableWaits VALUES ('PREEMPTIVE_SP_SERVER_DIAGNOSTICS');
		INSERT INTO #IgnorableWaits VALUES ('QDS_ASYNC_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('QDS_PERSIST_TASK_MAIN_LOOP_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('QDS_SHUTDOWN_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('REDO_THREAD_PENDING_WORK');
		INSERT INTO #IgnorableWaits VALUES ('REQUEST_FOR_DEADLOCK_SEARCH');
		INSERT INTO #IgnorableWaits VALUES ('SLEEP_SYSTEMTASK');
		INSERT INTO #IgnorableWaits VALUES ('SLEEP_TASK');
		INSERT INTO #IgnorableWaits VALUES ('SP_SERVER_DIAGNOSTICS_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('SQLTRACE_BUFFER_FLUSH');
		INSERT INTO #IgnorableWaits VALUES ('SQLTRACE_INCREMENTAL_FLUSH_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('UCS_SESSION_REGISTRATION');
		INSERT INTO #IgnorableWaits VALUES ('WAIT_XTP_OFFLINE_CKPT_NEW_LOG');
		INSERT INTO #IgnorableWaits VALUES ('WAITFOR');
		INSERT INTO #IgnorableWaits VALUES ('XE_DISPATCHER_WAIT');
		INSERT INTO #IgnorableWaits VALUES ('XE_LIVE_TARGET_TVF');
		INSERT INTO #IgnorableWaits VALUES ('XE_TIMER_EVENT');


        /* Used for the default trace checks. */
        DECLARE @TracePath NVARCHAR(256);
        SELECT @TracePath=CAST(value as NVARCHAR(256))
            FROM sys.fn_trace_getinfo(1)
            WHERE traceid=1 AND property=2;
        
        SELECT @MsSinceWaitsCleared = DATEDIFF(MINUTE, create_date, CURRENT_TIMESTAMP) * 60000.0
            FROM    sys.databases
            WHERE   name='tempdb';

		/* Have they cleared wait stats? Using a 10% fudge factor */
		IF @MsSinceWaitsCleared * .9 &gt; (SELECT wait_time_ms FROM sys.dm_os_wait_stats WHERE wait_type = 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP')
			BEGIN
				SET @MsSinceWaitsCleared = (SELECT wait_time_ms FROM sys.dm_os_wait_stats WHERE wait_type = 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP')
				INSERT  INTO #BlitzResults
						( CheckID ,
							Priority ,
							FindingsGroup ,
							Finding ,
							URL ,
							Details
						)
					VALUES( 185,
								240,
								'Wait Stats',
								'Wait Stats Have Been Cleared',
								'http://BrentOzar.com/go/waits',
								'Someone ran DBCC SQLPERF to clear sys.dm_os_wait_stats at approximately: ' + CONVERT(NVARCHAR(100), DATEADD(ms, (-1 * @MsSinceWaitsCleared), GETDATE()), 120))
			END

		/* @CpuMsSinceWaitsCleared is used for waits stats calculations */
		SELECT @CpuMsSinceWaitsCleared = @MsSinceWaitsCleared * scheduler_count
			FROM sys.dm_os_sys_info;


		/* If we're outputting CSV or Markdown, don't bother checking the plan cache because we cannot export plans. */
		IF @OutputType = 'CSV' OR @OutputType = 'MARKDOWN'
			SET @CheckProcedureCache = 0;

		/* If we're posting a question on Stack, include background info on the server */
		IF @OutputType = 'MARKDOWN'
			SET @CheckServerInfo = 1;


		/* Only run CheckUserDatabaseObjects if there are less than 50 databases. */
		IF @BringThePain = 0 AND 50 &lt;= (SELECT COUNT(*) FROM sys.databases) AND @CheckUserDatabaseObjects = 1
			BEGIN
			SET @CheckUserDatabaseObjects = 0;
			PRINT 'Running sp_Blitz @CheckUserDatabaseObjects = 1 on a server with 50+ databases may cause temporary insanity for the server and/or user.';
			PRINT 'If you''re sure you want to do this, run again with the parameter @BringThePain = 1.';
			END

		/* Sanitize our inputs */
		SELECT
			@OutputServerName = QUOTENAME(@OutputServerName),
			@OutputDatabaseName = QUOTENAME(@OutputDatabaseName),
			@OutputSchemaName = QUOTENAME(@OutputSchemaName),
			@OutputTableName = QUOTENAME(@OutputTableName)

		/* Get the major and minor build numbers */
		SET @ProductVersion = CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128));
		SELECT @ProductVersionMajor = SUBSTRING(@ProductVersion, 1,CHARINDEX('.', @ProductVersion) + 1 ),
			@ProductVersionMinor = PARSENAME(CONVERT(varchar(32), @ProductVersion), 2)
		
		/*
		Whew! we're finally done with the setup, and we can start doing checks.
		First, let's make sure we're actually supposed to do checks on this server.
		The user could have passed in a SkipChecks table that specified to skip ALL
		checks on this server, so let's check for that:
		*/
		IF ( ( SERVERPROPERTY('ServerName') NOT IN ( SELECT ServerName
													 FROM   #SkipChecks
													 WHERE  DatabaseName IS NULL
															AND CheckID IS NULL ) )
			 OR ( @SkipChecksTable IS NULL )
		   )
			BEGIN

				/*
				Our very first check! We'll put more comments in this one just to
				explain exactly how it works. First, we check to see if we're
				supposed to skip CheckID 1 (that's the check we're working on.)
				*/
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 1 )
					BEGIN

						/*
						Below, we check master.sys.databases looking for databases
						that haven't had a backup in the last week. If we find any,
						we insert them into #BlitzResults, the temp table that
						tracks our server's problems. Note that if the check does
						NOT find any problems, we don't save that. We're only
						saving the problems, not the successful checks.
						*/
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  1 AS CheckID ,
										d.[name] AS DatabaseName ,
										1 AS Priority ,
										'Backup' AS FindingsGroup ,
										'Backups Not Performed Recently' AS Finding ,
										'http://BrentOzar.com/go/nobak' AS URL ,
										'Last backed up: '
										+ COALESCE(CAST(MAX(b.backup_finish_date) AS VARCHAR(25)),'never') AS Details
								FROM    master.sys.databases d
										LEFT OUTER JOIN msdb.dbo.backupset b ON d.name COLLATE SQL_Latin1_General_CP1_CI_AS = b.database_name COLLATE SQL_Latin1_General_CP1_CI_AS
																  AND b.type = 'D'
																  AND b.server_name = SERVERPROPERTY('ServerName') /*Backupset ran on current server */
								WHERE   d.database_id &lt;&gt; 2  /* Bonus points if you know what that means */
										AND d.state NOT IN(1, 6, 10) /* Not currently offline or restoring, like log shipping databases */
										AND d.is_in_standby = 0 /* Not a log shipping target database */
										AND d.source_database_id IS NULL /* Excludes database snapshots */
										AND d.name NOT IN ( SELECT DISTINCT
																  DatabaseName
															FROM  #SkipChecks
															WHERE CheckID IS NULL )
										/*
										The above NOT IN filters out the databases we're not supposed to check.
										*/
								GROUP BY d.name
								HAVING  MAX(b.backup_finish_date) &lt;= DATEADD(dd,
																  -7, GETDATE())
                                        OR MAX(b.backup_finish_date) IS NULL;
						/*
						And there you have it. The rest of this stored procedure works the same
						way: it asks:
						- Should I skip this check?
						- If not, do I find problems?
						- Insert the results into #BlitzResults
						*/

					END

				/*
				And that's the end of CheckID #1.

				CheckID #2 is a little simpler because it only involves one query, and it's
				more typical for queries that people contribute. But keep reading, because
				the next check gets more complex again.
				*/

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 2 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
										SELECT DISTINCT
										2 AS CheckID ,
										d.name AS DatabaseName ,
										1 AS Priority ,
										'Backup' AS FindingsGroup ,
										'Full Recovery Mode w/o Log Backups' AS Finding ,
										'http://BrentOzar.com/go/biglogs' AS URL ,
										( 'The ' + CAST(CAST((SELECT ((SUM([mf].[size]) * 8.) / 1024.) FROM sys.[master_files] AS [mf] WHERE [mf].[database_id] = d.[database_id] AND [mf].[type_desc] = 'LOG') AS DECIMAL(18,2)) AS VARCHAR) + 'MB log file has not been backed up in the last week.' ) AS Details
								FROM    master.sys.databases d
								WHERE   d.recovery_model IN ( 1, 2 )
										AND d.database_id NOT IN ( 2, 3 )
										AND d.source_database_id IS NULL
										AND d.state NOT IN(1, 6, 10) /* Not currently offline or restoring, like log shipping databases */
										AND d.is_in_standby = 0 /* Not a log shipping target database */
										AND d.source_database_id IS NULL /* Excludes database snapshots */
										AND d.name NOT IN ( SELECT DISTINCT
																  DatabaseName
															FROM  #SkipChecks
															WHERE CheckID IS NULL )
										AND NOT EXISTS ( SELECT *
														 FROM   msdb.dbo.backupset b
														 WHERE  d.name COLLATE SQL_Latin1_General_CP1_CI_AS = b.database_name COLLATE SQL_Latin1_General_CP1_CI_AS
																AND b.type = 'L'
																AND b.backup_finish_date &gt;= DATEADD(dd,
																  -7, GETDATE()) ); 
					END


				/*
				Next up, we've got CheckID 8. (These don't have to go in order.) This one
				won't work on SQL Server 2005 because it relies on a new DMV that didn't
				exist prior to SQL Server 2008. This means we have to check the SQL Server
				version first, then build a dynamic string with the query we want to run:
				*/

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 8 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID, Priority,
							FindingsGroup,
							Finding, URL,
							Details)
					  SELECT 8 AS CheckID,
					  230 AS Priority,
					  ''Security'' AS FindingsGroup,
					  ''Server Audits Running'' AS Finding,
					  ''http://BrentOzar.com/go/audits'' AS URL,
					  (''SQL Server built-in audit functionality is being used by server audit: '' + [name]) AS Details FROM sys.dm_server_audit_status'
								EXECUTE(@StringToExecute)
							END;
					END

				/*
				But what if you need to run a query in every individual database?
				Hop down to the @CheckUserDatabaseObjects section.
                
				And that's the basic idea! You can read through the rest of the
				checks if you like - some more exciting stuff happens closer to the
				end of the stored proc, where we start doing things like checking
				the plan cache, but those aren't as cleanly commented.

				If you'd like to contribute your own check, use one of the check
				formats shown above and email it to Help@BrentOzar.com. You don't
				have to pick a CheckID or a link - we'll take care of that when we
				test and publish the code. Thanks!
				*/


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 93 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT
										93 AS CheckID ,
										1 AS Priority ,
										'Backup' AS FindingsGroup ,
										'Backing Up to Same Drive Where Databases Reside' AS Finding ,
										'http://BrentOzar.com/go/backup' AS URL ,
										CAST(COUNT(1) AS VARCHAR(50)) + ' backups done on drive '
										+ UPPER(LEFT(bmf.physical_device_name, 3))
										+ ' in the last two weeks, where database files also live. This represents a serious risk if that array fails.' Details
								FROM    msdb.dbo.backupmediafamily AS bmf
										INNER JOIN msdb.dbo.backupset AS bs ON bmf.media_set_id = bs.media_set_id
																  AND bs.backup_start_date &gt;= ( DATEADD(dd,
																  -14, GETDATE()) )
										/* Filter out databases that were recently restored: */
										LEFT OUTER JOIN msdb.dbo.restorehistory rh ON bs.database_name = rh.destination_database_name AND rh.restore_date &gt; DATEADD(dd, -14, GETDATE())
								WHERE   UPPER(LEFT(bmf.physical_device_name COLLATE SQL_Latin1_General_CP1_CI_AS, 3)) IN (
										SELECT DISTINCT
												UPPER(LEFT(mf.physical_name COLLATE SQL_Latin1_General_CP1_CI_AS, 3))
										FROM    sys.master_files AS mf )
										AND rh.destination_database_name IS NULL
								GROUP BY UPPER(LEFT(bmf.physical_device_name, 3))
					END


					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 119 )
						AND EXISTS ( SELECT *
									 FROM   sys.all_objects o
									 WHERE  o.name = 'dm_database_encryption_keys' )
						BEGIN
							SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, DatabaseName, URL, Details)
								SELECT 119 AS CheckID,
								1 AS Priority,
								''Backup'' AS FindingsGroup,
								''TDE Certificate Not Backed Up Recently'' AS Finding,
								db_name(dek.database_id) AS DatabaseName,
								''http://BrentOzar.com/go/tde'' AS URL,
								''The certificate '' + c.name + '' is used to encrypt database '' + db_name(dek.database_id) + ''. Last backup date: '' + COALESCE(CAST(c.pvt_key_last_backup_date AS VARCHAR(100)), ''Never'') AS Details
								FROM sys.certificates c INNER JOIN sys.dm_database_encryption_keys dek ON c.thumbprint = dek.encryptor_thumbprint
								WHERE pvt_key_last_backup_date IS NULL OR pvt_key_last_backup_date &lt;= DATEADD(dd, -30, GETDATE())';
							EXECUTE(@StringToExecute);
						END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 3 )
					BEGIN
						IF DATEADD(dd, -60, GETDATE()) &gt; (SELECT TOP 1 backup_start_date FROM msdb.dbo.backupset ORDER BY 1)
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT TOP 1
										3 AS CheckID ,
										'msdb' ,
										200 AS Priority ,
										'Backup' AS FindingsGroup ,
										'MSDB Backup History Not Purged' AS Finding ,
										'http://BrentOzar.com/go/history' AS URL ,
										( 'Database backup history retained back to '
										  + CAST(bs.backup_start_date AS VARCHAR(20)) ) AS Details
								FROM    msdb.dbo.backupset bs
								ORDER BY backup_set_id ASC;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 186 )
					BEGIN
						IF DATEADD(dd, -2, GETDATE()) &lt; (SELECT TOP 1 backup_start_date FROM msdb.dbo.backupset ORDER BY 1)
							INSERT  INTO #BlitzResults
									( CheckID ,
									  DatabaseName ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT TOP 1
											186 AS CheckID ,
											'msdb' ,
											200 AS Priority ,
											'Backup' AS FindingsGroup ,
											'MSDB Backup History Purged Too Frequently' AS Finding ,
											'http://BrentOzar.com/go/history' AS URL ,
											( 'Database backup history only retained back to '
											  + CAST(bs.backup_start_date AS VARCHAR(20)) ) AS Details
									FROM    msdb.dbo.backupset bs
									ORDER BY backup_set_id ASC;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 178 )
					AND EXISTS (SELECT *
									FROM msdb.dbo.backupset bs
									WHERE bs.type = 'D'
									AND bs.backup_size &gt;= 50000000000 /* At least 50GB */
									AND DATEDIFF(SECOND, bs.backup_start_date, bs.backup_finish_date) &lt;= 60 /* Backup took less than 60 seconds */
									AND bs.backup_finish_date &gt;= DATEADD(DAY, -14, GETDATE()) /* In the last 2 weeks */)
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT 178 AS CheckID ,
										200 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Snapshot Backups Occurring' AS Finding ,
										'http://BrentOzar.com/go/snaps' AS URL ,
										( CAST(COUNT(*) AS VARCHAR(20)) + ' snapshot-looking backups have occurred in the last two weeks, indicating that IO may be freezing up.') AS Details
								FROM msdb.dbo.backupset bs
								WHERE bs.type = 'D'
								AND bs.backup_size &gt;= 50000000000 /* At least 50GB */
								AND DATEDIFF(SECOND, bs.backup_start_date, bs.backup_finish_date) &lt;= 60 /* Backup took less than 60 seconds */
								AND bs.backup_finish_date &gt;= DATEADD(DAY, -14, GETDATE()) /* In the last 2 weeks */
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 4 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  4 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Sysadmins' AS Finding ,
										'http://BrentOzar.com/go/sa' AS URL ,
										( 'Login [' + l.name
										  + '] is a sysadmin - meaning they can do absolutely anything in SQL Server, including dropping databases or hiding their tracks.' ) AS Details
								FROM    master.sys.syslogins l
								WHERE   l.sysadmin = 1
										AND l.name &lt;&gt; SUSER_SNAME(0x01)
										AND l.denylogin = 0
										AND l.name NOT LIKE 'NT SERVICE\%'
										AND l.name &lt;&gt; 'l_certSignSmDetach'; /* Added in SQL 2016 */
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 5 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  5 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Security Admins' AS Finding ,
										'http://BrentOzar.com/go/sa' AS URL ,
										( 'Login [' + l.name
										  + '] is a security admin - meaning they can give themselves permission to do absolutely anything in SQL Server, including dropping databases or hiding their tracks.' ) AS Details
								FROM    master.sys.syslogins l
								WHERE   l.securityadmin = 1
										AND l.name &lt;&gt; SUSER_SNAME(0x01)
										AND l.denylogin = 0;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 104 )
					BEGIN
						INSERT  INTO #BlitzResults
								( [CheckID] ,
								  [Priority] ,
								  [FindingsGroup] ,
								  [Finding] ,
								  [URL] ,
								  [Details]
								)
								SELECT  104 AS [CheckID] ,
										230 AS [Priority] ,
										'Security' AS [FindingsGroup] ,
										'Login Can Control Server' AS [Finding] ,
										'http://BrentOzar.com/go/sa' AS [URL] ,
										'Login [' + pri.[name]
										+ '] has the CONTROL SERVER permission - meaning they can do absolutely anything in SQL Server, including dropping databases or hiding their tracks.' AS [Details]
								FROM    sys.server_principals AS pri
								WHERE   pri.[principal_id] IN (
										SELECT  p.[grantee_principal_id]
										FROM    sys.server_permissions AS p
										WHERE   p.[state] IN ( 'G', 'W' )
												AND p.[class] = 100
												AND p.[type] = 'CL' )
										AND pri.[name] NOT LIKE '##%##'
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 6 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  6 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Jobs Owned By Users' AS Finding ,
										'http://BrentOzar.com/go/owners' AS URL ,
										( 'Job [' + j.name + '] is owned by ['
										  + SUSER_SNAME(j.owner_sid)
										  + '] - meaning if their login is disabled or not available due to Active Directory problems, the job will stop working.' ) AS Details
								FROM    msdb.dbo.sysjobs j
								WHERE   j.enabled = 1
										AND SUSER_SNAME(j.owner_sid) &lt;&gt; SUSER_SNAME(0x01);
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 7 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  7 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Stored Procedure Runs at Startup' AS Finding ,
										'http://BrentOzar.com/go/startup' AS URL ,
										( 'Stored procedure [master].['
										  + r.SPECIFIC_SCHEMA + '].['
										  + r.SPECIFIC_NAME
										  + '] runs automatically when SQL Server starts up.  Make sure you know exactly what this stored procedure is doing, because it could pose a security risk.' ) AS Details
								FROM    master.INFORMATION_SCHEMA.ROUTINES r
								WHERE   OBJECTPROPERTY(OBJECT_ID(ROUTINE_NAME),
													   'ExecIsStartup') = 1;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 10 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 10 AS CheckID,
					  100 AS Priority,
					  ''Performance'' AS FindingsGroup,
					  ''Resource Governor Enabled'' AS Finding,
					  ''http://BrentOzar.com/go/rg'' AS URL,
					  (''Resource Governor is enabled.  Queries may be throttled.  Make sure you understand how the Classifier Function is configured.'') AS Details FROM sys.resource_governor_configuration WHERE is_enabled = 1'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 11 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 11 AS CheckID,
					  100 AS Priority,
					  ''Performance'' AS FindingsGroup,
					  ''Server Triggers Enabled'' AS Finding,
					  ''http://BrentOzar.com/go/logontriggers/'' AS URL,
					  (''Server Trigger ['' + [name] ++ ''] is enabled.  Make sure you understand what that trigger is doing - the less work it does, the better.'') AS Details FROM sys.server_triggers WHERE is_disabled = 0 AND is_ms_shipped = 0'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 12 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  12 AS CheckID ,
										[name] AS DatabaseName ,
										10 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Auto-Close Enabled' AS Finding ,
										'http://BrentOzar.com/go/autoclose' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-close enabled.  This setting can dramatically decrease performance.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_close_on = 1
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 13 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  13 AS CheckID ,
										[name] AS DatabaseName ,
										10 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Auto-Shrink Enabled' AS Finding ,
										'http://BrentOzar.com/go/autoshrink' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-shrink enabled.  This setting can dramatically decrease performance.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_shrink_on = 1
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL);
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 14 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID,
							DatabaseName,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 14 AS CheckID,
					  [name] as DatabaseName,
					  50 AS Priority,
					  ''Reliability'' AS FindingsGroup,
					  ''Page Verification Not Optimal'' AS Finding,
					  ''http://BrentOzar.com/go/torn'' AS URL,
					  (''Database ['' + [name] + ''] has '' + [page_verify_option_desc] + '' for page verification.  SQL Server may have a harder time recognizing and recovering from storage corruption.  Consider using CHECKSUM instead.'') COLLATE database_default AS Details
					  FROM sys.databases
					  WHERE page_verify_option &lt; 2
					  AND name &lt;&gt; ''tempdb''
					  and name not in (select distinct DatabaseName from #SkipChecks)'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 15 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  15 AS CheckID ,
										[name] AS DatabaseName ,
										110 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Auto-Create Stats Disabled' AS Finding ,
										'http://BrentOzar.com/go/acs' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-create-stats disabled.  SQL Server uses statistics to build better execution plans, and without the ability to automatically create more, performance may suffer.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_create_stats_on = 0
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 16 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  16 AS CheckID ,
										[name] AS DatabaseName ,
										110 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Auto-Update Stats Disabled' AS Finding ,
										'http://BrentOzar.com/go/aus' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-update-stats disabled.  SQL Server uses statistics to build better execution plans, and without the ability to automatically update them, performance may suffer.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_update_stats_on = 0
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 17 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  17 AS CheckID ,
										[name] AS DatabaseName ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Stats Updated Asynchronously' AS Finding ,
										'http://BrentOzar.com/go/asyncstats' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-update-stats-async enabled.  When SQL Server gets a query for a table with out-of-date statistics, it will run the query with the stats it has - while updating stats to make later queries better. The initial run of the query may suffer, though.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_update_stats_async_on = 1
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 18 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  18 AS CheckID ,
										[name] AS DatabaseName ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Forced Parameterization On' AS Finding ,
										'http://BrentOzar.com/go/forced' AS URL ,
										( 'Database [' + [name]
										  + '] has forced parameterization enabled.  SQL Server will aggressively reuse query execution plans even if the applications do not parameterize their queries.  This can be a performance booster with some programming languages, or it may use universally bad execution plans when better alternatives are available for certain parameters.' ) AS Details
								FROM    sys.databases
								WHERE   is_parameterization_forced = 1
										AND name NOT IN ( SELECT  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 20 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  20 AS CheckID ,
										[name] AS DatabaseName ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Date Correlation On' AS Finding ,
										'http://BrentOzar.com/go/corr' AS URL ,
										( 'Database [' + [name]
										  + '] has date correlation enabled.  This is not a default setting, and it has some performance overhead.  It tells SQL Server that date fields in two tables are related, and SQL Server maintains statistics showing that relation.' ) AS Details
								FROM    sys.databases
								WHERE   is_date_correlation_on = 1
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 21 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID,
							DatabaseName,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 21 AS CheckID,
					  [name] as DatabaseName,
					  200 AS Priority,
					  ''Informational'' AS FindingsGroup,
					  ''Database Encrypted'' AS Finding,
					  ''http://BrentOzar.com/go/tde'' AS URL,
					  (''Database ['' + [name] + ''] has Transparent Data Encryption enabled.  Make absolutely sure you have backed up the certificate and private key, or else you will not be able to restore this database.'') AS Details
					  FROM sys.databases
					  WHERE is_encrypted = 1
					  and name not in (select distinct DatabaseName from #SkipChecks)'
								EXECUTE(@StringToExecute)
							END;
					END

				/*
				Believe it or not, SQL Server doesn't track the default values
				for sp_configure options! We'll make our own list here.
				*/
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'access check cache bucket count', 0, 1001 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'access check cache quota', 0, 1002 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Ad Hoc Distributed Queries', 0, 1003 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'affinity I/O mask', 0, 1004 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'affinity mask', 0, 1005 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'affinity64 mask', 0, 1066 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'affinity64 I/O mask', 0, 1067 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Agent XPs', 0, 1071 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'allow updates', 0, 1007 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'awe enabled', 0, 1008 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'backup checksum default', 0, 1070 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'backup compression default', 0, 1073 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'blocked process threshold', 0, 1009 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'blocked process threshold (s)', 0, 1009 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'c2 audit mode', 0, 1010 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'clr enabled', 0, 1011 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'common criteria compliance enabled', 0, 1074 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'contained database authentication', 0, 1068 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'cost threshold for parallelism', 5, 1012 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'cross db ownership chaining', 0, 1013 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'cursor threshold', -1, 1014 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Database Mail XPs', 0, 1072 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'default full-text language', 1033, 1016 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'default language', 0, 1017 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'default trace enabled', 1, 1018 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'disallow results from triggers', 0, 1019 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'EKM provider enabled', 0, 1075 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'filestream access level', 0, 1076 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'fill factor (%)', 0, 1020 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'ft crawl bandwidth (max)', 100, 1021 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'ft crawl bandwidth (min)', 0, 1022 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'ft notify bandwidth (max)', 100, 1023 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'ft notify bandwidth (min)', 0, 1024 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'index create memory (KB)', 0, 1025 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'in-doubt xact resolution', 0, 1026 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'lightweight pooling', 0, 1027 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'locks', 0, 1028 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max degree of parallelism', 0, 1029 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max full-text crawl range', 4, 1030 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max server memory (MB)', 2147483647, 1031 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max text repl size (B)', 65536, 1032 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max worker threads', 0, 1033 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'media retention', 0, 1034 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'min memory per query (KB)', 1024, 1035 );
				/* Accepting both 0 and 16 below because both have been seen in the wild as defaults. */
				IF EXISTS ( SELECT  *
							FROM    sys.configurations
							WHERE   name = 'min server memory (MB)'
									AND value_in_use IN ( 0, 16 ) )
					INSERT  INTO #ConfigurationDefaults
							SELECT  'min server memory (MB)' ,
									CAST(value_in_use AS BIGINT), 1036
							FROM    sys.configurations
							WHERE   name = 'min server memory (MB)'
				ELSE
					INSERT  INTO #ConfigurationDefaults
					VALUES  ( 'min server memory (MB)', 0, 1036 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'nested triggers', 1, 1037 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'network packet size (B)', 4096, 1038 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Ole Automation Procedures', 0, 1039 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'open objects', 0, 1040 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'optimize for ad hoc workloads', 0, 1041 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'PH timeout (s)', 60, 1042 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'precompute rank', 0, 1043 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'priority boost', 0, 1044 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'query governor cost limit', 0, 1045 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'query wait (s)', -1, 1046 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'recovery interval (min)', 0, 1047 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'remote access', 1, 1048 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'remote admin connections', 0, 1049 );
				/* SQL Server 2012 changes a configuration default */
				IF @@VERSION LIKE '%Microsoft SQL Server 2005%'
					OR @@VERSION LIKE '%Microsoft SQL Server 2008%'
					BEGIN
						INSERT  INTO #ConfigurationDefaults
						VALUES  ( 'remote login timeout (s)', 20, 1069 );
					END
				ELSE
					BEGIN
						INSERT  INTO #ConfigurationDefaults
						VALUES  ( 'remote login timeout (s)', 10, 1069 );
					END
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'remote proc trans', 0, 1050 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'remote query timeout (s)', 600, 1051 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Replication XPs', 0, 1052 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'RPC parameter data validation', 0, 1053 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'scan for startup procs', 0, 1054 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'server trigger recursion', 1, 1055 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'set working set size', 0, 1056 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'show advanced options', 0, 1057 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'SMO and DMO XPs', 1, 1058 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'SQL Mail XPs', 0, 1059 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'transform noise words', 0, 1060 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'two digit year cutoff', 2049, 1061 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'user connections', 0, 1062 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'user options', 0, 1063 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Web Assistant Procedures', 0, 1064 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'xp_cmdshell', 0, 1065 );


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 22 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  cd.CheckID ,
										200 AS Priority ,
										'Non-Default Server Config' AS FindingsGroup ,
										cr.name AS Finding ,
										'http://BrentOzar.com/go/conf' AS URL ,
										( 'This sp_configure option has been changed.  Its default value is '
										  + COALESCE(CAST(cd.[DefaultValue] AS VARCHAR(100)),
													 '(unknown)')
										  + ' and it has been set to '
										  + CAST(cr.value_in_use AS VARCHAR(100))
										  + '.' ) AS Details
								FROM    sys.configurations cr
										INNER JOIN #ConfigurationDefaults cd ON cd.name = cr.name
										LEFT OUTER JOIN #ConfigurationDefaults cdUsed ON cdUsed.name = cr.name
																  AND cdUsed.DefaultValue = cr.value_in_use
								WHERE   cdUsed.name IS NULL;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 190 )
					BEGIN
						SELECT @MinServerMemory = CAST(value_in_use as BIGINT) FROM sys.configurations WHERE name = 'min server memory (MB)'
						SELECT @MaxServerMemory = CAST(value_in_use as BIGINT) FROM sys.configurations WHERE name = 'max server memory (MB)'
						
						IF (@MinServerMemory = @MaxServerMemory)
						BEGIN
						INSERT INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								VALUES  
									(	190,
										200,
										'Performance',
										'Non-Dynamic Memory',
										'http://BrentOzar.com/go/memory',
										'Minimum Server Memory setting is the same as the Maximum (both set to ' + CAST(@MinServerMemory AS NVARCHAR(50)) + '). This will not allow dynamic memory. Please revise memory settings'
									)
						END
					END
					
					IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 188 )
					BEGIN

						/* Let's set variables so that our query is still SARGable */
						SET @Processors = (SELECT cpu_count FROM sys.dm_os_sys_info)
						SET @NUMANodes = (SELECT COUNT(1)
											FROM sys.dm_os_performance_counters pc
											WHERE pc.object_name LIKE '%Buffer Node%'
												AND counter_name = 'Page life expectancy')
						/* If Cost Threshold for Parallelism is default then flag as a potential issue */
						/* If MAXDOP is default and processors &gt; 8 or NUMA nodes &gt; 1 then flag as potential issue */
						INSERT INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  188 AS CheckID ,
										200 AS Priority ,
										'Performance' AS FindingsGroup ,
										cr.name AS Finding ,
										'http://BrentOzar.com/go/cxpacket' AS URL ,
										( 'Set to ' + CAST(cr.value_in_use AS NVARCHAR(50)) + ', its default value. Changing this sp_configure setting may reduce CXPACKET waits.')
								FROM    sys.configurations cr
										INNER JOIN #ConfigurationDefaults cd ON cd.name = cr.name
											AND cr.value_in_use = cd.DefaultValue
								WHERE   cr.name = 'cost threshold for parallelism'
									OR (cr.name = 'max degree of parallelism' AND (@NUMANodes &gt; 1 OR @Processors &gt; 8));
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 24 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										24 AS CheckID ,
										DB_NAME(database_id) AS DatabaseName ,
										170 AS Priority ,
										'File Configuration' AS FindingsGroup ,
										'System Database on C Drive' AS Finding ,
										'http://BrentOzar.com/go/cdrive' AS URL ,
										( 'The ' + DB_NAME(database_id)
										  + ' database has a file on the C drive.  Putting system databases on the C drive runs the risk of crashing the server when it runs out of space.' ) AS Details
								FROM    sys.master_files
								WHERE   UPPER(LEFT(physical_name, 1)) = 'C'
										AND DB_NAME(database_id) IN ( 'master',
																  'model', 'msdb' );
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 25 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT TOP 1
										25 AS CheckID ,
										'tempdb' ,
										20 AS Priority ,
										'File Configuration' AS FindingsGroup ,
										'TempDB on C Drive' AS Finding ,
										'http://BrentOzar.com/go/cdrive' AS URL ,
										CASE WHEN growth &gt; 0
											 THEN ( 'The tempdb database has files on the C drive.  TempDB frequently grows unpredictably, putting your server at risk of running out of C drive space and crashing hard.  C is also often much slower than other drives, so performance may be suffering.' )
											 ELSE ( 'The tempdb database has files on the C drive.  TempDB is not set to Autogrow, hopefully it is big enough.  C is also often much slower than other drives, so performance may be suffering.' )
										END AS Details
								FROM    sys.master_files
								WHERE   UPPER(LEFT(physical_name, 1)) = 'C'
										AND DB_NAME(database_id) = 'tempdb';
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 26 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										26 AS CheckID ,
										DB_NAME(database_id) AS DatabaseName ,
										20 AS Priority ,
										'Reliability' AS FindingsGroup ,
										'User Databases on C Drive' AS Finding ,
										'http://BrentOzar.com/go/cdrive' AS URL ,
										( 'The ' + DB_NAME(database_id)
										  + ' database has a file on the C drive.  Putting databases on the C drive runs the risk of crashing the server when it runs out of space.' ) AS Details
								FROM    sys.master_files
								WHERE   UPPER(LEFT(physical_name, 1)) = 'C'
										AND DB_NAME(database_id) NOT IN ( 'master',
																  'model', 'msdb',
																  'tempdb' )
										AND DB_NAME(database_id) NOT IN (
										SELECT DISTINCT
												DatabaseName
										FROM    #SkipChecks )
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 27 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  27 AS CheckID ,
										'master' AS DatabaseName ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Tables in the Master Database' AS Finding ,
										'http://BrentOzar.com/go/mastuser' AS URL ,
										( 'The ' + name
										  + ' table in the master database was created by end users on '
										  + CAST(create_date AS VARCHAR(20))
										  + '. Tables in the master database may not be restored in the event of a disaster.' ) AS Details
								FROM    master.sys.tables
								WHERE   is_ms_shipped = 0;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 28 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  28 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Tables in the MSDB Database' AS Finding ,
										'http://BrentOzar.com/go/msdbuser' AS URL ,
										( 'The ' + name
										  + ' table in the msdb database was created by end users on '
										  + CAST(create_date AS VARCHAR(20))
										  + '. Tables in the msdb database may not be restored in the event of a disaster.' ) AS Details
								FROM    msdb.sys.tables
								WHERE   is_ms_shipped = 0 AND name NOT LIKE '%DTA_%';
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 29 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  29 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Tables in the Model Database' AS Finding ,
										'http://BrentOzar.com/go/model' AS URL ,
										( 'The ' + name
										  + ' table in the model database was created by end users on '
										  + CAST(create_date AS VARCHAR(20))
										  + '. Tables in the model database are automatically copied into all new databases.' ) AS Details
								FROM    model.sys.tables
								WHERE   is_ms_shipped = 0;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 30 )
					BEGIN
						IF ( SELECT COUNT(*)
							 FROM   msdb.dbo.sysalerts
							 WHERE  severity BETWEEN 19 AND 25
						   ) &lt; 7
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  30 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'Not All Alerts Configured' AS Finding ,
											'http://BrentOzar.com/go/alert' AS URL ,
											( 'Not all SQL Server Agent alerts have been configured.  This is a free, easy way to get notified of corruption, job failures, or major outages even before monitoring systems pick it up.' ) AS Details;
					END



				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 59 )
					BEGIN
						IF EXISTS ( SELECT  *
									FROM    msdb.dbo.sysalerts
									WHERE   enabled = 1
											AND COALESCE(has_notification, 0) = 0
											AND (job_id IS NULL OR job_id = 0x))
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  59 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'Alerts Configured without Follow Up' AS Finding ,
											'http://BrentOzar.com/go/alert' AS URL ,
											( 'SQL Server Agent alerts have been configured but they either do not notify anyone or else they do not take any action.  This is a free, easy way to get notified of corruption, job failures, or major outages even before monitoring systems pick it up.' ) AS Details;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 96 )
					BEGIN
						IF NOT EXISTS ( SELECT  *
										FROM    msdb.dbo.sysalerts
										WHERE   message_id IN ( 823, 824, 825 ) )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  96 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'No Alerts for Corruption' AS Finding ,
											'http://BrentOzar.com/go/alert' AS URL ,
											( 'SQL Server Agent alerts do not exist for errors 823, 824, and 825.  These three errors can give you notification about early hardware failure. Enabling them can prevent you a lot of heartbreak.' ) AS Details;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 61 )
					BEGIN
						IF NOT EXISTS ( SELECT  *
										FROM    msdb.dbo.sysalerts
										WHERE   severity BETWEEN 19 AND 25 )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  61 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'No Alerts for Sev 19-25' AS Finding ,
											'http://BrentOzar.com/go/alert' AS URL ,
											( 'SQL Server Agent alerts do not exist for severity levels 19 through 25.  These are some very severe SQL Server errors. Knowing that these are happening may let you recover from errors faster.' ) AS Details;
					END

		--check for disabled alerts
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 98 )
					BEGIN
						IF EXISTS ( SELECT  name
									FROM    msdb.dbo.sysalerts
									WHERE   enabled = 0 )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  98 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'Alerts Disabled' AS Finding ,
											'http://www.BrentOzar.com/go/alerts/' AS URL ,
											( 'The following Alert is disabled, please review and enable if desired: '
											  + name ) AS Details
									FROM    msdb.dbo.sysalerts
									WHERE   enabled = 0
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 31 )
					BEGIN
						IF NOT EXISTS ( SELECT  *
										FROM    msdb.dbo.sysoperators
										WHERE   enabled = 1 )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  31 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'No Operators Configured/Enabled' AS Finding ,
											'http://BrentOzar.com/go/op' AS URL ,
											( 'No SQL Server Agent operators (emails) have been configured.  This is a free, easy way to get notified of corruption, job failures, or major outages even before monitoring systems pick it up.' ) AS Details;
					END



				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 34 )
					BEGIN
						IF EXISTS ( SELECT  *
									FROM    sys.all_objects
									WHERE   name = 'dm_db_mirroring_auto_page_repair' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT
		  34 AS CheckID ,
		  db.name ,
		  1 AS Priority ,
		  ''Corruption'' AS FindingsGroup ,
		  ''Database Corruption Detected'' AS Finding ,
		  ''http://BrentOzar.com/go/repair'' AS URL ,
		  ( ''Database mirroring has automatically repaired at least one corrupt page in the last 30 days. For more information, query the DMV sys.dm_db_mirroring_auto_page_repair.'' ) AS Details
		  FROM (SELECT rp2.database_id, rp2.modification_time 
			FROM sys.dm_db_mirroring_auto_page_repair rp2 
			WHERE rp2.[database_id] not in (
			SELECT db2.[database_id] 
			FROM sys.databases as db2 
			WHERE db2.[state] = 1
			) ) as rp 
		  INNER JOIN master.sys.databases db ON rp.database_id = db.database_id
		  WHERE   rp.modification_time &gt;= DATEADD(dd, -30, GETDATE()) ;'
								EXECUTE(@StringToExecute)
							END;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 89 )
					BEGIN
						IF EXISTS ( SELECT  *
									FROM    sys.all_objects
									WHERE   name = 'dm_hadr_auto_page_repair' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT
		  89 AS CheckID ,
		  db.name ,
		  1 AS Priority ,
		  ''Corruption'' AS FindingsGroup ,
		  ''Database Corruption Detected'' AS Finding ,
		  ''http://BrentOzar.com/go/repair'' AS URL ,
		  ( ''AlwaysOn has automatically repaired at least one corrupt page in the last 30 days. For more information, query the DMV sys.dm_hadr_auto_page_repair.'' ) AS Details
		  FROM    sys.dm_hadr_auto_page_repair rp
		  INNER JOIN master.sys.databases db ON rp.database_id = db.database_id
		  WHERE   rp.modification_time &gt;= DATEADD(dd, -30, GETDATE()) ;'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 90 )
					BEGIN
						IF EXISTS ( SELECT  *
									FROM    msdb.sys.all_objects
									WHERE   name = 'suspect_pages' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT
		  90 AS CheckID ,
		  db.name ,
		  1 AS Priority ,
		  ''Corruption'' AS FindingsGroup ,
		  ''Database Corruption Detected'' AS Finding ,
		  ''http://BrentOzar.com/go/repair'' AS URL ,
		  ( ''SQL Server has detected at least one corrupt page in the last 30 days. For more information, query the system table msdb.dbo.suspect_pages.'' ) AS Details
		  FROM    msdb.dbo.suspect_pages sp
		  INNER JOIN master.sys.databases db ON sp.database_id = db.database_id
		  WHERE   sp.last_update_date &gt;= DATEADD(dd, -30, GETDATE()) ;'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 36 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										36 AS CheckID ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Slow Storage Reads on Drive '
										+ UPPER(LEFT(mf.physical_name, 1)) AS Finding ,
										'http://BrentOzar.com/go/slow' AS URL ,
										'Reads are averaging longer than 200ms for at least one database on this drive.  For specific database file speeds, run the query from the information link.' AS Details
								FROM    sys.dm_io_virtual_file_stats(NULL, NULL)
										AS fs
										INNER JOIN sys.master_files AS mf ON fs.database_id = mf.database_id
																  AND fs.[file_id] = mf.[file_id]
								WHERE   ( io_stall_read_ms / ( 1.0 + num_of_reads ) ) &gt; 200
								AND num_of_reads &gt; 100000;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 37 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										37 AS CheckID ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Slow Storage Writes on Drive '
										+ UPPER(LEFT(mf.physical_name, 1)) AS Finding ,
										'http://BrentOzar.com/go/slow' AS URL ,
										'Writes are averaging longer than 100ms for at least one database on this drive.  For specific database file speeds, run the query from the information link.' AS Details
								FROM    sys.dm_io_virtual_file_stats(NULL, NULL)
										AS fs
										INNER JOIN sys.master_files AS mf ON fs.database_id = mf.database_id
																  AND fs.[file_id] = mf.[file_id]
								WHERE   ( io_stall_write_ms / ( 1.0
																+ num_of_writes ) ) &gt; 100
																AND num_of_writes &gt; 100000;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 40 )
					BEGIN
						IF ( SELECT COUNT(*)
							 FROM   tempdb.sys.database_files
							 WHERE  type_desc = 'ROWS'
						   ) = 1
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  DatabaseName ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
								VALUES  ( 40 ,
										  'tempdb' ,
										  170 ,
										  'File Configuration' ,
										  'TempDB Only Has 1 Data File' ,
										  'http://BrentOzar.com/go/tempdb' ,
										  'TempDB is only configured with one data file.  More data files are usually required to alleviate SGAM contention.'
										);
							END;
					END

						IF ( SELECT COUNT (distinct [size])
							FROM   tempdb.sys.database_files
							WHERE  type_desc = 'ROWS'
							) &lt;&gt; 1
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  DatabaseName ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
								VALUES  ( 183 ,
										  'tempdb' ,
										  170 ,
										  'File Configuration' ,
										  'TempDB Unevenly Sized Data Files' ,
										  'http://BrentOzar.com/go/tempdb' ,
										  'TempDB data files are not configured with the same size.  Unevenly sized tempdb data files will result in unevenly sized workloads.'
										);
							END;

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 44 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  44 AS CheckID ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Queries Forcing Order Hints' AS Finding ,
										'http://BrentOzar.com/go/hints' AS URL ,
										CAST(occurrence AS VARCHAR(10))
										+ ' instances of order hinting have been recorded since restart.  This means queries are bossing the SQL Server optimizer around, and if they don''t know what they''re doing, this can cause more harm than good.  This can also explain why DBA tuning efforts aren''t working.' AS Details
								FROM    sys.dm_exec_query_optimizer_info
								WHERE   counter = 'order hint'
										AND occurrence &gt; 1000
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 45 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  45 AS CheckID ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Queries Forcing Join Hints' AS Finding ,
										'http://BrentOzar.com/go/hints' AS URL ,
										CAST(occurrence AS VARCHAR(10))
										+ ' instances of join hinting have been recorded since restart.  This means queries are bossing the SQL Server optimizer around, and if they don''t know what they''re doing, this can cause more harm than good.  This can also explain why DBA tuning efforts aren''t working.' AS Details
								FROM    sys.dm_exec_query_optimizer_info
								WHERE   counter = 'join hint'
										AND occurrence &gt; 1000
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 49 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										49 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Linked Server Configured' AS Finding ,
										'http://BrentOzar.com/go/link' AS URL ,
										+CASE WHEN l.remote_name = 'sa'
											  THEN s.data_source
												   + ' is configured as a linked server. Check its security configuration as it is connecting with sa, because any user who queries it will get admin-level permissions.'
											  ELSE s.data_source
												   + ' is configured as a linked server. Check its security configuration to make sure it isn''t connecting with SA or some other bone-headed administrative login, because any user who queries it might get admin-level permissions.'
										 END AS Details
								FROM    sys.servers s
										INNER JOIN sys.linked_logins l ON s.server_id = l.server_id
								WHERE   s.is_linked = 1
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 50 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
		  SELECT  50 AS CheckID ,
		  100 AS Priority ,
		  ''Performance'' AS FindingsGroup ,
		  ''Max Memory Set Too High'' AS Finding ,
		  ''http://BrentOzar.com/go/max'' AS URL ,
		  ''SQL Server max memory is set to ''
			+ CAST(c.value_in_use AS VARCHAR(20))
			+ '' megabytes, but the server only has ''
			+ CAST(( CAST(m.total_physical_memory_kb AS BIGINT) / 1024 ) AS VARCHAR(20))
			+ '' megabytes.  SQL Server may drain the system dry of memory, and under certain conditions, this can cause Windows to swap to disk.'' AS Details
		  FROM    sys.dm_os_sys_memory m
		  INNER JOIN sys.configurations c ON c.name = ''max server memory (MB)''
		  WHERE   CAST(m.total_physical_memory_kb AS BIGINT) &lt; ( CAST(c.value_in_use AS BIGINT) * 1024 )'
								EXECUTE(@StringToExecute)
							END;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 51 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
		  SELECT  51 AS CheckID ,
		  1 AS Priority ,
		  ''Performance'' AS FindingsGroup ,
		  ''Memory Dangerously Low'' AS Finding ,
		  ''http://BrentOzar.com/go/max'' AS URL ,
		  ''The server has '' + CAST(( CAST(m.total_physical_memory_kb AS BIGINT) / 1024 ) AS VARCHAR(20)) + '' megabytes of physical memory, but only '' + CAST(( CAST(m.available_physical_memory_kb AS BIGINT) / 1024 ) AS VARCHAR(20))
			+ '' megabytes are available.  As the server runs out of memory, there is danger of swapping to disk, which will kill performance.'' AS Details
		  FROM    sys.dm_os_sys_memory m
		  WHERE   CAST(m.available_physical_memory_kb AS BIGINT) &lt; 262144'
								EXECUTE(@StringToExecute)
							END;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 159 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
		  SELECT DISTINCT 159 AS CheckID ,
		  1 AS Priority ,
		  ''Performance'' AS FindingsGroup ,
		  ''Memory Dangerously Low in NUMA Nodes'' AS Finding ,
		  ''http://BrentOzar.com/go/max'' AS URL ,
		  ''At least one NUMA node is reporting THREAD_RESOURCES_LOW in sys.dm_os_nodes and can no longer create threads.'' AS Details
		  FROM    sys.dm_os_nodes m
		  WHERE   node_state_desc LIKE ''%THREAD_RESOURCES_LOW%'''
								EXECUTE(@StringToExecute)
							END;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 53 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT TOP 1
										53 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Cluster Node' AS Finding ,
										'http://BrentOzar.com/go/node' AS URL ,
										'This is a node in a cluster.' AS Details
								FROM    sys.dm_os_cluster_nodes
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 55 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  55 AS CheckID ,
										[name] AS DatabaseName ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Database Owner &lt;&gt; SA' AS Finding ,
										'http://BrentOzar.com/go/owndb' AS URL ,
										( 'Database name: ' + [name] + '   '
										  + 'Owner name: ' + SUSER_SNAME(owner_sid) ) AS Details
								FROM    sys.databases
								WHERE   SUSER_SNAME(owner_sid) &lt;&gt; SUSER_SNAME(0x01)
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL);
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 57 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  57 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'SQL Agent Job Runs at Startup' AS Finding ,
										'http://BrentOzar.com/go/startup' AS URL ,
										( 'Job [' + j.name
										  + '] runs automatically when SQL Server Agent starts up.  Make sure you know exactly what this job is doing, because it could pose a security risk.' ) AS Details
								FROM    msdb.dbo.sysschedules sched
										JOIN msdb.dbo.sysjobschedules jsched ON sched.schedule_id = jsched.schedule_id
										JOIN msdb.dbo.sysjobs j ON jsched.job_id = j.job_id
								WHERE   sched.freq_type = 64
								        AND sched.enabled = 1;
					END



				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 97 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  97 AS CheckID ,
										100 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Unusual SQL Server Edition' AS Finding ,
										'http://BrentOzar.com/go/workgroup' AS URL ,
										( 'This server is using '
										  + CAST(SERVERPROPERTY('edition') AS VARCHAR(100))
										  + ', which is capped at low amounts of CPU and memory.' ) AS Details
								WHERE   CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Standard%'
										AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Enterprise%'
										AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Data Center%'
										AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Developer%'
										AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Business Intelligence%'
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 154 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  154 AS CheckID ,
										10 AS Priority ,
										'Performance' AS FindingsGroup ,
										'32-bit SQL Server Installed' AS Finding ,
										'http://BrentOzar.com/go/32bit' AS URL ,
										( 'This server uses the 32-bit x86 binaries for SQL Server instead of the 64-bit x64 binaries. The amount of memory available for query workspace and execution plans is heavily limited.' ) AS Details
								WHERE   CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%64%'
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 62 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  62 AS CheckID ,
										[name] AS DatabaseName ,
										200 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Old Compatibility Level' AS Finding ,
										'http://BrentOzar.com/go/compatlevel' AS URL ,
										( 'Database ' + [name]
										  + ' is compatibility level '
										  + CAST(compatibility_level AS VARCHAR(20))
										  + ', which may cause unwanted results when trying to run queries that have newer T-SQL features.' ) AS Details
								FROM    sys.databases
								WHERE   name NOT IN ( SELECT DISTINCT
																DatabaseName
													  FROM      #SkipChecks 
													  WHERE CheckID IS NULL)
										AND compatibility_level &lt;= 90
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 94 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  94 AS CheckID ,
										200 AS [Priority] ,
										'Monitoring' AS FindingsGroup ,
										'Agent Jobs Without Failure Emails' AS Finding ,
										'http://BrentOzar.com/go/alerts' AS URL ,
										'The job ' + [name]
										+ ' has not been set up to notify an operator if it fails.' AS Details
								FROM    msdb.[dbo].[sysjobs] j
										INNER JOIN ( SELECT DISTINCT
															[job_id]
													 FROM   [msdb].[dbo].[sysjobschedules]
													 WHERE  next_run_date &gt; 0
												   ) s ON j.job_id = s.job_id
								WHERE   j.enabled = 1
										AND j.notify_email_operator_id = 0
										AND j.notify_netsend_operator_id = 0
										AND j.notify_page_operator_id = 0
										AND j.category_id &lt;&gt; 100 /* Exclude SSRS category */
					END


				IF EXISTS ( SELECT  1
							FROM    sys.configurations
							WHERE   name = 'remote admin connections'
									AND value_in_use = 0 )
					AND NOT EXISTS ( SELECT 1
									 FROM   #SkipChecks
									 WHERE  DatabaseName IS NULL AND CheckID = 100 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  100 AS CheckID ,
										50 AS Priority ,
										'Reliability' AS FindingGroup ,
										'Remote DAC Disabled' AS Finding ,
										'http://BrentOzar.com/go/dac' AS URL ,
										'Remote access to the Dedicated Admin Connection (DAC) is not enabled. The DAC can make remote troubleshooting much easier when SQL Server is unresponsive.'
					END


				IF EXISTS ( SELECT  *
							FROM    sys.dm_os_schedulers
							WHERE   is_online = 0 )
					AND NOT EXISTS ( SELECT 1
									 FROM   #SkipChecks
									 WHERE  DatabaseName IS NULL AND CheckID = 101 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  101 AS CheckID ,
										50 AS Priority ,
										'Performance' AS FindingGroup ,
										'CPU Schedulers Offline' AS Finding ,
										'http://BrentOzar.com/go/schedulers' AS URL ,
										'Some CPU cores are not accessible to SQL Server due to affinity masking or licensing problems.'
					END


					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 110 )
								AND EXISTS (SELECT * FROM master.sys.all_objects WHERE name = 'dm_os_memory_nodes')
						BEGIN
							SET @StringToExecute = 'IF EXISTS (SELECT  *
												FROM sys.dm_os_nodes n
												INNER JOIN sys.dm_os_memory_nodes m ON n.memory_node_id = m.memory_node_id
												WHERE n.node_state_desc = ''OFFLINE'')
												INSERT  INTO #BlitzResults
														( CheckID ,
														  Priority ,
														  FindingsGroup ,
														  Finding ,
														  URL ,
														  Details
														)
														SELECT  110 AS CheckID ,
																50 AS Priority ,
																''Performance'' AS FindingGroup ,
																''Memory Nodes Offline'' AS Finding ,
																''http://BrentOzar.com/go/schedulers'' AS URL ,
																''Due to affinity masking or licensing problems, some of the memory may not be available.''';
									EXECUTE(@StringToExecute);
						END


				IF EXISTS ( SELECT  *
							FROM    sys.databases
							WHERE   state &gt; 1 )
					AND NOT EXISTS ( SELECT 1
									 FROM   #SkipChecks
									 WHERE  DatabaseName IS NULL AND CheckID = 102 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  102 AS CheckID ,
										[name] ,
										20 AS Priority ,
										'Reliability' AS FindingGroup ,
										'Unusual Database State: ' + [state_desc] AS Finding ,
										'http://BrentOzar.com/go/repair' AS URL ,
										'This database may not be online.'
								FROM    sys.databases
								WHERE   state &gt; 1
					END

				IF EXISTS ( SELECT  *
							FROM    master.sys.extended_procedures )
					AND NOT EXISTS ( SELECT 1
									 FROM   #SkipChecks
									 WHERE  DatabaseName IS NULL AND CheckID = 105 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  105 AS CheckID ,
										'master' ,
										200 AS Priority ,
										'Reliability' AS FindingGroup ,
										'Extended Stored Procedures in Master' AS Finding ,
										'http://BrentOzar.com/go/clr' AS URL ,
										'The [' + name
										+ '] extended stored procedure is in the master database. CLR may be in use, and the master database now needs to be part of your backup/recovery planning.'
								FROM    master.sys.extended_procedures
					END



					IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 107 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  107 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: THREADPOOL'  AS Finding ,
											'http://BrentOzar.com/go/poison' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of this wait have been recorded. This wait often indicates killer performance problems.'
									FROM sys.[dm_os_wait_stats]
									WHERE wait_type = 'THREADPOOL'
									GROUP BY wait_type
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000
						END

					IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 108 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  108 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: RESOURCE_SEMAPHORE'  AS Finding ,
											'http://BrentOzar.com/go/poison' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of this wait have been recorded. This wait often indicates killer performance problems.'
									FROM sys.[dm_os_wait_stats]
									WHERE wait_type = 'RESOURCE_SEMAPHORE'
									GROUP BY wait_type
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000
						END


					IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 109 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  109 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: RESOURCE_SEMAPHORE_QUERY_COMPILE'  AS Finding ,
											'http://BrentOzar.com/go/poison' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of this wait have been recorded. This wait often indicates killer performance problems.'
									FROM sys.[dm_os_wait_stats]
									WHERE wait_type = 'RESOURCE_SEMAPHORE_QUERY_COMPILE'
									GROUP BY wait_type
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000
						END


					IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 121 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  121 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: Serializable Locking'  AS Finding ,
											'http://BrentOzar.com/go/serializable' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of LCK_M_R% waits have been recorded. This wait often indicates killer performance problems.'
									FROM sys.[dm_os_wait_stats]
									WHERE wait_type IN ('LCK_M_RS_S', 'LCK_M_RS_U', 'LCK_M_RIn_NL','LCK_M_RIn_S', 'LCK_M_RIn_U','LCK_M_RIn_X', 'LCK_M_RX_S', 'LCK_M_RX_U','LCK_M_RX_X')
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000
						END




					IF @ProductVersionMajor &gt;= 11 AND NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 162 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  162 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: CMEMTHREAD &amp; NUMA'  AS Finding ,
											'http://BrentOzar.com/go/poison' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of this wait have been recorded. In servers with over 8 cores per NUMA node, when CMEMTHREAD waits are a bottleneck, trace flag 8048 may be needed.'
									FROM sys.dm_os_nodes n 
									INNER JOIN sys.[dm_os_wait_stats] w ON w.wait_type = 'CMEMTHREAD'
									WHERE n.node_id = 0 AND n.online_scheduler_count &gt;= 8
									GROUP BY w.wait_type
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000;
						END




						IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 111 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  DatabaseName ,
									  URL ,
									  Details
									)
									SELECT  111 AS CheckID ,
											50 AS Priority ,
											'Reliability' AS FindingGroup ,
											'Possibly Broken Log Shipping'  AS Finding ,
											d.[name] ,
											'http://BrentOzar.com/go/shipping' AS URL ,
											d.[name] + ' is in a restoring state, but has not had a backup applied in the last two days. This is a possible indication of a broken transaction log shipping setup.'
											FROM [master].sys.databases d
											INNER JOIN [master].sys.database_mirroring dm ON d.database_id = dm.database_id
												AND dm.mirroring_role IS NULL
											WHERE ( d.[state] = 1
											OR (d.[state] = 0 AND d.[is_in_standby] = 1) )
											AND NOT EXISTS(SELECT * FROM msdb.dbo.restorehistory rh
											INNER JOIN msdb.dbo.backupset bs ON rh.backup_set_id = bs.backup_set_id
											WHERE d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = rh.destination_database_name COLLATE SQL_Latin1_General_CP1_CI_AS
											AND rh.restore_date &gt;= DATEADD(dd, -2, GETDATE()))

						END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 112 )
									AND EXISTS (SELECT * FROM master.sys.all_objects WHERE name = 'change_tracking_databases')
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
							  SELECT 112 AS CheckID,
							  100 AS Priority,
							  ''Performance'' AS FindingsGroup,
							  ''Change Tracking Enabled'' AS Finding,
							  ''http://BrentOzar.com/go/tracking'' AS URL,
							  ( d.[name] + '' has change tracking enabled. This is not a default setting, and it has some performance overhead. It keeps track of changes to rows in tables that have change tracking turned on.'' ) AS Details FROM sys.change_tracking_databases AS ctd INNER JOIN sys.databases AS d ON ctd.database_id = d.database_id';
										EXECUTE(@StringToExecute);
							END


						IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 116 )
									AND EXISTS (SELECT * FROM msdb.sys.all_columns WHERE name = 'compressed_backup_size')
						BEGIN
							SET @StringToExecute = 'INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  116 AS CheckID ,
											200 AS Priority ,
											''Informational'' AS FindingGroup ,
											''Backup Compression Default Off''  AS Finding ,
											''http://BrentOzar.com/go/backup'' AS URL ,
											''Uncompressed full backups have happened recently, and backup compression is not turned on at the server level. Backup compression is included with SQL Server 2008R2 &amp; newer, even in Standard Edition. We recommend turning backup compression on by default so that ad-hoc backups will get compressed.''
											FROM sys.configurations
											WHERE configuration_id = 1579 AND CAST(value_in_use AS INT) = 0
                                            AND EXISTS (SELECT * FROM msdb.dbo.backupset WHERE backup_size = compressed_backup_size AND type = ''D'' AND backup_finish_date &gt;= DATEADD(DD, -14, GETDATE()));'
										EXECUTE(@StringToExecute);
						END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 117 )
									AND EXISTS (SELECT * FROM master.sys.all_objects WHERE name = 'dm_exec_query_resource_semaphores')
							BEGIN
								SET @StringToExecute = 'IF 0 &lt; (SELECT SUM([forced_grant_count]) FROM sys.dm_exec_query_resource_semaphores WHERE [forced_grant_count] IS NOT NULL)
								INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
							  SELECT 117 AS CheckID,
							  100 AS Priority,
							  ''Performance'' AS FindingsGroup,
							  ''Memory Pressure Affecting Queries'' AS Finding,
							  ''http://BrentOzar.com/go/grants'' AS URL,
							  CAST(SUM(forced_grant_count) AS NVARCHAR(100)) + '' forced grants reported in the DMV sys.dm_exec_query_resource_semaphores, indicating memory pressure has affected query runtimes.''
							  FROM sys.dm_exec_query_resource_semaphores WHERE [forced_grant_count] IS NOT NULL;'
										EXECUTE(@StringToExecute);
							END



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 124 )
							BEGIN
								INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
								SELECT 124, 150, 'Performance', 'Deadlocks Happening Daily', 'http://BrentOzar.com/go/deadlocks',
									CAST(p.cntr_value AS NVARCHAR(100)) + ' deadlocks have been recorded since startup.' AS Details
								FROM sys.dm_os_performance_counters p
									INNER JOIN sys.databases d ON d.name = 'tempdb'
								WHERE RTRIM(p.counter_name) = 'Number of Deadlocks/sec'
									AND RTRIM(p.instance_name) = '_Total'
									AND p.cntr_value &gt; 0
									AND (1.0 * p.cntr_value / NULLIF(datediff(DD,create_date,CURRENT_TIMESTAMP),0)) &gt; 10;
							END


						IF DATEADD(mi, -15, GETDATE()) &lt; (SELECT TOP 1 creation_time FROM sys.dm_exec_query_stats ORDER BY creation_time)
						BEGIN
							INSERT INTO #BlitzResults
								(CheckID,
								Priority,
								FindingsGroup,
								Finding,
								URL,
								Details)
							SELECT TOP 1 125, 10, 'Performance', 'Plan Cache Erased Recently', 'http://BrentOzar.com/askbrent/plan-cache-erased-recently/',
								'The oldest query in the plan cache was created at ' + CAST(creation_time AS NVARCHAR(50)) + '. Someone ran DBCC FREEPROCCACHE, restarted SQL Server, or it is under horrific memory pressure.'
							FROM sys.dm_exec_query_stats WITH (NOLOCK)
							ORDER BY creation_time	
						END;

						IF EXISTS (SELECT * FROM sys.configurations WHERE name = 'priority boost' AND (value = 1 OR value_in_use = 1))
						BEGIN
							INSERT INTO #BlitzResults
								(CheckID,
								Priority,
								FindingsGroup,
								Finding,
								URL,
								Details)
							VALUES(126, 5, 'Reliability', 'Priority Boost Enabled', 'http://BrentOzar.com/go/priorityboost/',
								'Priority Boost sounds awesome, but it can actually cause your SQL Server to crash.')
						END;

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 128 )
							BEGIN

							IF (@ProductVersionMajor = 12 AND @ProductVersionMinor &lt; 2000) OR
							   (@ProductVersionMajor = 11 AND @ProductVersionMinor &lt; 3000) OR
							   (@ProductVersionMajor = 10.5 AND @ProductVersionMinor &lt; 6000) OR
							   (@ProductVersionMajor = 10 AND @ProductVersionMinor &lt; 6000) OR
							   (@ProductVersionMajor = 9 /*AND @ProductVersionMinor &lt;= 5000*/)
								BEGIN
								INSERT INTO #BlitzResults(CheckID, Priority, FindingsGroup, Finding, URL, Details)
									VALUES(128, 20, 'Reliability', 'Unsupported Build of SQL Server', 'http://BrentOzar.com/go/unsupported',
										'Version ' + CAST(@ProductVersionMajor AS VARCHAR(100)) + '.' + 
										CASE WHEN @ProductVersionMajor &gt; 9 THEN
										CAST(@ProductVersionMinor AS VARCHAR(100)) + ' is no longer supported by Microsoft. You need to apply a service pack.'
										ELSE ' is no longer support by Microsoft. You should be making plans to upgrade to a modern version of SQL Server.' END);
								END;

							END;
							
						/* Reliability - Dangerous Build of SQL Server (Corruption) */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 129 )
							BEGIN
							IF (@ProductVersionMajor = 11 AND @ProductVersionMinor &gt;= 3000 AND @ProductVersionMinor &lt;= 3436) OR
							   (@ProductVersionMajor = 11 AND @ProductVersionMinor = 5058) OR
							   (@ProductVersionMajor = 12 AND @ProductVersionMinor &gt;= 2000 AND @ProductVersionMinor &lt;= 2342)
								BEGIN
								INSERT INTO #BlitzResults(CheckID, Priority, FindingsGroup, Finding, URL, Details)
									VALUES(129, 20, 'Reliability', 'Dangerous Build of SQL Server (Corruption)', 'http://sqlperformance.com/2014/06/sql-indexes/hotfix-sql-2012-rebuilds',
										'There are dangerous known bugs with version ' + CAST(@ProductVersionMajor AS VARCHAR(100)) + '.' + CAST(@ProductVersionMinor AS VARCHAR(100)) + '. Check the URL for details and apply the right service pack or hotfix.');
								END;

							END;

						/* Reliability - Dangerous Build of SQL Server (Security) */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 157 )
							BEGIN
							IF (@ProductVersionMajor = 10 AND @ProductVersionMinor &gt;= 5500 AND @ProductVersionMinor &lt;= 5512) OR
							   (@ProductVersionMajor = 10 AND @ProductVersionMinor &gt;= 5750 AND @ProductVersionMinor &lt;= 5867) OR
							   (@ProductVersionMajor = 10.5 AND @ProductVersionMinor &gt;= 4000 AND @ProductVersionMinor &lt;= 4017) OR
							   (@ProductVersionMajor = 10.5 AND @ProductVersionMinor &gt;= 4251 AND @ProductVersionMinor &lt;= 4319) OR
							   (@ProductVersionMajor = 11 AND @ProductVersionMinor &gt;= 3000 AND @ProductVersionMinor &lt;= 3129) OR
							   (@ProductVersionMajor = 11 AND @ProductVersionMinor &gt;= 3300 AND @ProductVersionMinor &lt;= 3447) OR
							   (@ProductVersionMajor = 12 AND @ProductVersionMinor &gt;= 2000 AND @ProductVersionMinor &lt;= 2253) OR
							   (@ProductVersionMajor = 12 AND @ProductVersionMinor &gt;= 2300 AND @ProductVersionMinor &lt;= 2370)
								BEGIN
								INSERT INTO #BlitzResults(CheckID, Priority, FindingsGroup, Finding, URL, Details)
									VALUES(157, 20, 'Reliability', 'Dangerous Build of SQL Server (Security)', 'https://technet.microsoft.com/en-us/library/security/MS14-044',
										'There are dangerous known bugs with version ' + CAST(@ProductVersionMajor AS VARCHAR(100)) + '.' + CAST(@ProductVersionMinor AS VARCHAR(100)) + '. Check the URL for details and apply the right service pack or hotfix.');
								END;

							END;
						
						/* Check if SQL 2016 Standard Edition but not SP1 */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 189 )
							BEGIN
							IF (@ProductVersionMajor = 13 AND @ProductVersionMinor &lt; 4001 AND @@VERSION LIKE '%Standard Edition%') 
								BEGIN
								INSERT INTO #BlitzResults(CheckID, Priority, FindingsGroup, Finding, URL, Details)
									VALUES(189, 100, 'Features', 'Missing Features', 'https://blogs.msdn.microsoft.com/sqlreleaseservices/sql-server-2016-service-pack-1-sp1-released/',
										'SQL 2016 Standard Edition is being used but not Service Pack 1. Check the URL for a list of Enterprise Features that are included in Standard Edition as of SP1.');
								END;

							END;						

                        /* Performance - High Memory Use for In-Memory OLTP (Hekaton) */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 145 )
	                        AND EXISTS ( SELECT *
					                        FROM   sys.all_objects o
					                        WHERE  o.name = 'dm_db_xtp_table_memory_stats' )
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT 145 AS CheckID,
			                        10 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''High Memory Use for In-Memory OLTP (Hekaton)'' AS Finding,
			                        ''http://BrentOzar.com/go/hekaton'' AS URL,
			                        CAST(CAST((SUM(mem.pages_kb / 1024.0) / CAST(value_in_use AS INT) * 100) AS INT) AS NVARCHAR(100)) + ''% of your '' + CAST(CAST((CAST(value_in_use AS DECIMAL(38,1)) / 1024) AS MONEY) AS NVARCHAR(100)) + ''GB of your max server memory is being used for in-memory OLTP tables (Hekaton). Microsoft recommends having 2X your Hekaton table space available in memory just for Hekaton, with a max of 250GB of in-memory data regardless of your server memory capacity.'' AS Details
			                        FROM sys.configurations c INNER JOIN sys.dm_os_memory_clerks mem ON mem.type = ''MEMORYCLERK_XTP''
                                    WHERE c.name = ''max server memory (MB)''
                                    GROUP BY c.value_in_use
                                    HAVING CAST(value_in_use AS DECIMAL(38,2)) * .25 &lt; SUM(mem.pages_kb / 1024.0)
                                      OR SUM(mem.pages_kb / 1024.0) &gt; 250000';
		                        EXECUTE(@StringToExecute);
	                        END


                        /* Performance - In-Memory OLTP (Hekaton) In Use */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 146 )
	                        AND EXISTS ( SELECT *
					                        FROM   sys.all_objects o
					                        WHERE  o.name = 'dm_db_xtp_table_memory_stats' )
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT 146 AS CheckID,
			                        200 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''In-Memory OLTP (Hekaton) In Use'' AS Finding,
			                        ''http://BrentOzar.com/go/hekaton'' AS URL,
			                        CAST(CAST((SUM(mem.pages_kb / 1024.0) / CAST(value_in_use AS INT) * 100) AS INT) AS NVARCHAR(100)) + ''% of your '' + CAST(CAST((CAST(value_in_use AS DECIMAL(38,1)) / 1024) AS MONEY) AS NVARCHAR(100)) + ''GB of your max server memory is being used for in-memory OLTP tables (Hekaton).'' AS Details
			                        FROM sys.configurations c INNER JOIN sys.dm_os_memory_clerks mem ON mem.type = ''MEMORYCLERK_XTP''
                                    WHERE c.name = ''max server memory (MB)''
                                    GROUP BY c.value_in_use
                                    HAVING SUM(mem.pages_kb / 1024.0) &gt; 10';
		                        EXECUTE(@StringToExecute);
	                        END

                        /* In-Memory OLTP (Hekaton) - Transaction Errors */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 147 )
	                        AND EXISTS ( SELECT *
					                        FROM   sys.all_objects o
					                        WHERE  o.name = 'dm_xtp_transaction_stats' )
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT 147 AS CheckID,
			                        100 AS Priority,
			                        ''In-Memory OLTP (Hekaton)'' AS FindingsGroup,
			                        ''Transaction Errors'' AS Finding,
			                        ''http://BrentOzar.com/go/hekaton'' AS URL,
			                        ''Since restart: '' + CAST(validation_failures AS NVARCHAR(100)) + '' validation failures, '' + CAST(dependencies_failed AS NVARCHAR(100)) + '' dependency failures, '' + CAST(write_conflicts AS NVARCHAR(100)) + '' write conflicts, '' + CAST(unique_constraint_violations AS NVARCHAR(100)) + '' unique constraint violations.'' AS Details
			                        FROM sys.dm_xtp_transaction_stats
                                    WHERE validation_failures &lt;&gt; 0
                                            OR dependencies_failed &lt;&gt; 0
                                            OR write_conflicts &lt;&gt; 0
                                            OR unique_constraint_violations &lt;&gt; 0;'
		                        EXECUTE(@StringToExecute);
	                        END



                        /* Reliability - Database Files on Network File Shares */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 148 )
	                        BEGIN
		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        DatabaseName ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT DISTINCT 148 AS CheckID ,
						                        d.[name] AS DatabaseName ,
						                        170 AS Priority ,
						                        'Reliability' AS FindingsGroup ,
						                        'Database Files on Network File Shares' AS Finding ,
						                        'http://BrentOzar.com/go/nas' AS URL ,
						                        ( 'Files for this database are on: ' + LEFT(mf.physical_name, 30)) AS Details
				                        FROM    sys.databases d
                                          INNER JOIN sys.master_files mf ON d.database_id = mf.database_id
				                        WHERE mf.physical_name LIKE '\\%'
						                        AND d.name NOT IN ( SELECT DISTINCT
													                        DatabaseName
											                        FROM    #SkipChecks 
																	WHERE CheckID IS NULL)
	                        END

                        /* Reliability - Database Files Stored in Azure */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 149 )
	                        BEGIN
		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        DatabaseName ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT DISTINCT 149 AS CheckID ,
						                        d.[name] AS DatabaseName ,
						                        170 AS Priority ,
						                        'Reliability' AS FindingsGroup ,
						                        'Database Files Stored in Azure' AS Finding ,
						                        'http://BrentOzar.com/go/azurefiles' AS URL ,
						                        ( 'Files for this database are on: ' + LEFT(mf.physical_name, 30)) AS Details
				                        FROM    sys.databases d
                                          INNER JOIN sys.master_files mf ON d.database_id = mf.database_id
				                        WHERE mf.physical_name LIKE 'http://%'
						                        AND d.name NOT IN ( SELECT DISTINCT
													                        DatabaseName
											                        FROM    #SkipChecks 
																	WHERE CheckID IS NULL)
	                        END


                        /* Reliability - Errors Logged Recently in the Default Trace */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 150 )
                            AND @TracePath IS NOT NULL
	                        BEGIN

		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        DatabaseName ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT DISTINCT 150 AS CheckID ,
					                            t.DatabaseName,
						                        50 AS Priority ,
						                        'Reliability' AS FindingsGroup ,
						                        'Errors Logged Recently in the Default Trace' AS Finding ,
						                        'http://BrentOzar.com/go/defaulttrace' AS URL ,
						                         CAST(t.TextData AS NVARCHAR(4000)) AS Details
                                        FROM    sys.fn_trace_gettable(@TracePath, DEFAULT) t
                                        WHERE t.EventClass = 22
                                          AND t.Severity &gt;= 17
                                          AND t.StartTime &gt; DATEADD(dd, -30, GETDATE())
	                        END


                        /* Performance - Log File Growths Slow */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 151 )
                            AND @TracePath IS NOT NULL
	                        BEGIN
		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        DatabaseName ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT DISTINCT 151 AS CheckID ,
					                            t.DatabaseName,
						                        50 AS Priority ,
						                        'Performance' AS FindingsGroup ,
						                        'Log File Growths Slow' AS Finding ,
						                        'http://BrentOzar.com/go/filegrowth' AS URL ,
						                        CAST(COUNT(*) AS NVARCHAR(100)) + ' growths took more than 15 seconds each. Consider setting log file autogrowth to a smaller increment.' AS Details
                                        FROM    sys.fn_trace_gettable(@TracePath, DEFAULT) t
                                        WHERE t.EventClass = 93
                                          AND t.StartTime &gt; DATEADD(dd, -30, GETDATE())
                                          AND t.Duration &gt; 15000000
                                        GROUP BY t.DatabaseName
                                        HAVING COUNT(*) &gt; 1
	                        END


                        /* Performance - Many Plans for One Query */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 160 )
                            AND EXISTS (SELECT * FROM sys.all_columns WHERE name = 'query_hash')
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT TOP 1 160 AS CheckID,
			                        100 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''Many Plans for One Query'' AS Finding,
			                        ''http://BrentOzar.com/go/parameterization'' AS URL,
			                        CAST(COUNT(DISTINCT plan_handle) AS NVARCHAR(50)) + '' plans are present for a single query in the plan cache - meaning we probably have parameterization issues.'' AS Details
			                        FROM sys.dm_exec_query_stats qs
                                    CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) pa
                                    WHERE pa.attribute = ''dbid''
                                    GROUP BY qs.query_hash, pa.value
                                    HAVING COUNT(DISTINCT plan_handle) &gt; 50
									ORDER BY COUNT(DISTINCT plan_handle) DESC;';
		                        EXECUTE(@StringToExecute);
	                        END


                        /* Performance - High Number of Cached Plans */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 161 )
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT TOP 1 161 AS CheckID,
			                        100 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''High Number of Cached Plans'' AS Finding,
			                        ''http://BrentOzar.com/go/planlimits'' AS URL,
			                        ''Your server configuration is limited to '' + CAST(ht.buckets_count * 4 AS VARCHAR(20)) + '' '' + ht.name + '', and you are currently caching '' + CAST(cc.entries_count AS VARCHAR(20)) + ''.'' AS Details
			                        FROM sys.dm_os_memory_cache_hash_tables ht
			                        INNER JOIN sys.dm_os_memory_cache_counters cc ON ht.name = cc.name AND ht.type = cc.type
			                        where ht.name IN ( ''SQL Plans'' , ''Object Plans'' , ''Bound Trees'' )
			                        AND cc.entries_count &gt;= (3 * ht.buckets_count)';
		                        EXECUTE(@StringToExecute);
	                        END


						/* Performance - Too Much Free Memory */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 165 )
							BEGIN
								INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
								SELECT 165, 50, 'Performance', 'Too Much Free Memory', 'http://BrentOzar.com/go/freememory',
									CAST((CAST(cFree.cntr_value AS BIGINT) / 1024 / 1024 ) AS NVARCHAR(100)) + N'GB of free memory inside SQL Server''s buffer pool, which is ' + CAST((CAST(cTotal.cntr_value AS BIGINT) / 1024 / 1024) AS NVARCHAR(100)) + N'GB. You would think lots of free memory would be good, but check out the URL for more information.' AS Details
								FROM sys.dm_os_performance_counters cFree
								INNER JOIN sys.dm_os_performance_counters cTotal ON cTotal.object_name LIKE N'%Memory Manager%'
									AND cTotal.counter_name = N'Total Server Memory (KB)                                                                                                        '
								WHERE cFree.object_name LIKE N'%Memory Manager%'
									AND cFree.counter_name = N'Free Memory (KB)                                                                                                                '
									AND CAST(cTotal.cntr_value AS BIGINT) &gt; 4000
									AND CAST(cTotal.cntr_value AS BIGINT) * .3 &lt;= CAST(cFree.cntr_value AS BIGINT)
                                    AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Standard%'

							END


                        /* Outdated sp_Blitz - sp_Blitz is Over 6 Months Old */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 155 )
				           AND DATEDIFF(MM, @VersionDate, GETDATE()) &gt; 6
	                        BEGIN
		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT 155 AS CheckID ,
						                        0 AS Priority ,
						                        'Outdated sp_Blitz' AS FindingsGroup ,
						                        'sp_Blitz is Over 6 Months Old' AS Finding ,
						                        'http://FirstResponderKit.org/' AS URL ,
						                        'Some things get better with age, like fine wine and your T-SQL. However, sp_Blitz is not one of those things - time to go download the current one.' AS Details
	                        END


						/* Populate a list of database defaults. I'm doing this kind of oddly -
						    it reads like a lot of work, but this way it compiles &amp; runs on all
						    versions of SQL Server.
						*/
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_supplemental_logging_enabled', 0, 131, 210, 'Supplemental Logging Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_supplemental_logging_enabled' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'snapshot_isolation_state', 0, 132, 210, 'Snapshot Isolation Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'snapshot_isolation_state' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_read_committed_snapshot_on', 0, 133, 210, 'Read Committed Snapshot Isolation Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_read_committed_snapshot_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_auto_create_stats_incremental_on', 0, 134, 210, 'Auto Create Stats Incremental Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_auto_create_stats_incremental_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_ansi_null_default_on', 0, 135, 210, 'ANSI NULL Default Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_ansi_null_default_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_recursive_triggers_on', 0, 136, 210, 'Recursive Triggers Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_recursive_triggers_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_trustworthy_on', 0, 137, 210, 'Trustworthy Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_trustworthy_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_parameterization_forced', 0, 138, 210, 'Forced Parameterization Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_parameterization_forced' AND object_id = OBJECT_ID('sys.databases');
						/* Not alerting for this since we actually want it and we have a separate check for it:
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_query_store_on', 0, 139, 210, 'Query Store Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_query_store_on' AND object_id = OBJECT_ID('sys.databases');
						*/
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_cdc_enabled', 0, 140, 210, 'Change Data Capture Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_cdc_enabled' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'containment', 0, 141, 210, 'Containment Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'containment' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'target_recovery_time_in_seconds', 0, 142, 210, 'Target Recovery Time Changed', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'target_recovery_time_in_seconds' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'delayed_durability', 0, 143, 210, 'Delayed Durability Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'delayed_durability' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_memory_optimized_elevate_to_snapshot_on', 0, 144, 210, 'Memory Optimized Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_memory_optimized_elevate_to_snapshot_on' AND object_id = OBJECT_ID('sys.databases');

						DECLARE DatabaseDefaultsLoop CURSOR FOR
						  SELECT name, DefaultValue, CheckID, Priority, Finding, URL, Details
						  FROM #DatabaseDefaults

						OPEN DatabaseDefaultsLoop
						FETCH NEXT FROM DatabaseDefaultsLoop into @CurrentName, @CurrentDefaultValue, @CurrentCheckID, @CurrentPriority, @CurrentFinding, @CurrentURL, @CurrentDetails
						WHILE @@FETCH_STATUS = 0
						BEGIN 

							/* Target Recovery Time (142) can be either 0 or 60 due to a number of bugs */
						    IF @CurrentCheckID = 142
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
								   SELECT ' + CAST(@CurrentCheckID AS NVARCHAR(200)) + ', d.[name], ' + CAST(@CurrentPriority AS NVARCHAR(200)) + ', ''Non-Default Database Config'', ''' + @CurrentFinding + ''',''' + @CurrentURL + ''',''' + COALESCE(@CurrentDetails, 'This database setting is not the default.') + '''
									FROM sys.databases d
									WHERE d.database_id &gt; 4 AND (d.[' + @CurrentName + '] NOT IN (0, 60) OR d.[' + @CurrentName + '] IS NULL);';
							ELSE
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
								   SELECT ' + CAST(@CurrentCheckID AS NVARCHAR(200)) + ', d.[name], ' + CAST(@CurrentPriority AS NVARCHAR(200)) + ', ''Non-Default Database Config'', ''' + @CurrentFinding + ''',''' + @CurrentURL + ''',''' + COALESCE(@CurrentDetails, 'This database setting is not the default.') + '''
									FROM sys.databases d
									WHERE d.database_id &gt; 4 AND (d.[' + @CurrentName + '] &lt;&gt; ' + @CurrentDefaultValue + ' OR d.[' + @CurrentName + '] IS NULL);';
						    EXEC (@StringToExecute);

						FETCH NEXT FROM DatabaseDefaultsLoop into @CurrentName, @CurrentDefaultValue, @CurrentCheckID, @CurrentPriority, @CurrentFinding, @CurrentURL, @CurrentDetails 
						END

						CLOSE DatabaseDefaultsLoop
						DEALLOCATE DatabaseDefaultsLoop;
							

/*This checks to see if Agent is Offline*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 167 )
					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
									BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							167 AS [CheckID] ,
							250 AS [Priority] ,
							'Server Info' AS [FindingsGroup] ,
							'Agent is Currently Offline' AS [Finding] ,
							'' AS [URL] ,
							( 'Oops! It looks like the ' + [servicename] + ' service is ' + [status_desc] + '. The startup type is ' + [startup_type_desc] + '.'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_services]
						  WHERE [status_desc] &lt;&gt; 'Running'
						  AND [servicename] LIKE 'SQL Server Agent%'
						  AND CAST(SERVERPROPERTY('Edition') AS VARCHAR(1000)) NOT LIKE '%xpress%'

					END; 
				END;

/*This checks to see if the Full Text thingy is offline*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 168 )
					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							168 AS [CheckID] ,
							250 AS [Priority] ,
							'Server Info' AS [FindingsGroup] ,
							'Full-text Filter Daemon Launcher is Currently Offline' AS [Finding] ,
							'' AS [URL] ,
							( 'Oops! It looks like the ' + [servicename] + ' service is ' + [status_desc] + '. The startup type is ' + [startup_type_desc] + '.'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_services]
						  WHERE [status_desc] &lt;&gt; 'Running'
						  AND [servicename] LIKE 'SQL Full-text Filter Daemon Launcher%'

					END;
					END; 

/*This checks which service account SQL Server is running as.*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 169 )

					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							169 AS [CheckID] ,
							250 AS [Priority] ,
							'Informational' AS [FindingsGroup] ,
							'SQL Server is running under an NT Service account' AS [Finding] ,
							'http://BrentOzar.com/go/setup' AS [URL] ,
							( 'I''m running as ' + [service_account] + '. I wish I had an Active Directory service account instead.'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_services]
						  WHERE [service_account] LIKE 'NT Service%'
						  AND [servicename] LIKE 'SQL Server%'
						  AND [servicename] NOT LIKE 'SQL Server Agent%'

					END;
					END;

/*This checks which service account SQL Agent is running as.*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 170 )

					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							170 AS [CheckID] ,
							250 AS [Priority] ,
							'Informational' AS [FindingsGroup] ,
							'SQL Server Agent is running under an NT Service account' AS [Finding] ,
							'http://BrentOzar.com/go/setup' AS [URL] ,
							( 'I''m running as ' + [service_account] + '. I wish I had an Active Directory service account instead.'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_services]
						  WHERE [service_account] LIKE 'NT Service%'
						  AND [servicename] LIKE 'SQL Server Agent%'

					END; 
					END;

/*This counts memory dumps and gives min and max date of in view*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 171 )
					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_memory_dumps' )
					BEGIN
						IF 5 &lt;= (SELECT COUNT(*) FROM [sys].[dm_server_memory_dumps] WHERE [creation_time] &gt;= DATEADD(year, -1, GETDATE()))
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							171 AS [CheckID] ,
							20 AS [Priority] ,
							'Reliability' AS [FindingsGroup] ,
							'Memory Dumps Have Occurred' AS [Finding] ,
							'http://BrentOzar.com/go/dump' AS [URL] ,
							( 'That ain''t good. I''ve had ' + 
								CAST(COUNT(*) AS VARCHAR(100)) + ' memory dumps between ' + 
								CAST(CAST(MIN([creation_time]) AS DATETIME) AS VARCHAR(100)) +
								' and ' +
								CAST(CAST(MAX([creation_time]) AS DATETIME) AS VARCHAR(100)) +
								'!'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_memory_dumps]
						  WHERE [creation_time] &gt;= DATEADD(year, -1, GETDATE());

					END; 
					END;

/*Checks to see if you're on Developer or Evaluation*/
					IF	NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 173 )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							173 AS [CheckID] ,
							200 AS [Priority] ,
							'Licensing' AS [FindingsGroup] ,
							'Non-Production License' AS [Finding] ,
							'http://BrentOzar.com/go/licensing' AS [URL] ,
							( 'We''re not the licensing police, but if this is supposed to be a production server, and you''re running ' + 
							CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) +
							' the good folks at Microsoft might get upset with you. Better start counting those cores.'
							   ) AS [Details]
							WHERE CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) LIKE '%Developer%'
							OR CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) LIKE '%Evaluation%'

					END

/*Checks to see if Buffer Pool Extensions are in use*/
			IF @ProductVersionMajor &gt;= 12  
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 174 )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							174 AS [CheckID] ,
							200 AS [Priority] ,
							'Performance' AS [FindingsGroup] ,
							'Buffer Pool Extensions Enabled' AS [Finding] ,
							'http://BrentOzar.com/go/bpe' AS [URL] ,
							( 'You have Buffer Pool Extensions enabled, and one lives here: ' + 
								[path] +
								'. It''s currently ' +
								CASE WHEN [current_size_in_kb] / 1024. / 1024. &gt; 0
																	 THEN CAST([current_size_in_kb] / 1024. / 1024. AS VARCHAR(100))
																		  + ' GB'
																	 ELSE CAST([current_size_in_kb] / 1024. AS VARCHAR(100))
																		  + ' MB'
								END +
								'. Did you know that BPEs only provide single threaded access 8 bytes at a time?'	
							   ) AS [Details]
							 FROM sys.dm_os_buffer_pool_extension_configuration
							 WHERE [state_description] &lt;&gt; 'BUFFER POOL EXTENSION DISABLED'

					END

/*Check for too many tempdb files*/
			IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 175 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
										SELECT DISTINCT
										175 AS CheckID ,
										'TempDB' AS DatabaseName ,
										170 AS Priority ,
										'File Configuration' AS FindingsGroup ,
										'TempDB Has &gt;16 Data Files' AS Finding ,
										'http://BrentOzar.com/go/tempdb' AS URL ,
										'Woah, Nelly! TempDB has ' + CAST(COUNT_BIG(*) AS VARCHAR) + '. Did you forget to terminate a loop somewhere?' AS Details
								  FROM sys.[master_files] AS [mf] 
								  WHERE [mf].[database_id] = 2 AND [mf].[type] = 0
								  HAVING COUNT_BIG(*) &gt; 16; 
					END	

			IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 176 )
			IF EXISTS ( SELECT  1
														FROM    sys.all_objects
														WHERE   name = 'dm_xe_sessions' )
								BEGIN
								BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  DatabaseName ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
													SELECT DISTINCT
													176 AS CheckID ,
													'' AS DatabaseName ,
													200 AS Priority ,
													'Monitoring' AS FindingsGroup ,
													'Extended Events Hyperextension' AS Finding ,
													'http://BrentOzar.com/go/xe' AS URL ,
													'Hey big spender, you have ' + CAST(COUNT_BIG(*) AS VARCHAR) + ' Extended Events sessions running. You sure you meant to do that?' AS Details
											    FROM sys.dm_xe_sessions
												WHERE [name] NOT IN
												('system_health', 'sp_server_diagnostics session', 'hkenginexesession', 'telemetry_xevents')
												AND name NOT LIKE '%$A%'
											  HAVING COUNT_BIG(*) &gt;= 2; 
								END	
								END
			
			/*Harmful startup parameter*/
			IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 177 )
								BEGIN
								IF EXISTS ( SELECT  1
														FROM    sys.all_objects
														WHERE   name = 'dm_server_registry' )
			
								BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  DatabaseName ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
													SELECT DISTINCT
													177 AS CheckID ,
													'' AS DatabaseName ,
													5 AS Priority ,
													'Monitoring' AS FindingsGroup ,
													'Disabled Internal Monitoring Features' AS Finding ,
													'https://msdn.microsoft.com/en-us/library/ms190737.aspx' AS URL ,
													'You have -x as a startup parameter. You should head to the URL and read more about what it does to your system.' AS Details
													FROM
													[sys].[dm_server_registry] AS [dsr]
													WHERE
													[dsr].[registry_key] LIKE N'%MSSQLServer\Parameters'
													AND [dsr].[value_data] = '-x';; 
								END		
								END
			
			
			/* Reliability - Dangerous Third Party Modules - 179 */
			IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 179 )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							179 AS [CheckID] ,
							5 AS [Priority] ,
							'Reliability' AS [FindingsGroup] ,
							'Dangerous Third Party Modules' AS [Finding] ,
							'https://support.microsoft.com/en-us/kb/2033238' AS [URL] ,
							( COALESCE(company, '') + ' - ' + COALESCE(description, '') + ' - ' + COALESCE(name, '') + ' - suspected dangerous third party module is installed.') AS [Details]
							FROM sys.dm_os_loaded_modules 
							WHERE UPPER(name) LIKE UPPER('%\ENTAPI.DLL') /* McAfee VirusScan Enterprise */
							OR UPPER(name) LIKE UPPER('%\HIPI.DLL') OR UPPER(name) LIKE UPPER('%\HcSQL.dll') OR UPPER(name) LIKE UPPER('%\HcApi.dll') OR UPPER(name) LIKE UPPER('%\HcThe.dll') /* McAfee Host Intrusion */
							OR UPPER(name) LIKE UPPER('%\SOPHOS_DETOURED.DLL') OR UPPER(name) LIKE UPPER('%\SOPHOS_DETOURED_x64.DLL') OR UPPER(name) LIKE UPPER('%\SWI_IFSLSP_64.dll') /* Sophos AV */
							OR UPPER(name) LIKE UPPER('%\PIOLEDB.DLL') OR UPPER(name) LIKE UPPER('%\PISDK.DLL') /* OSISoft PI data access */

					END

			/*Find shrink database tasks*/

			IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 180 )
							AND CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) LIKE '1%' /* Only run on 2008+ */
					BEGIN
						;
						WITH XMLNAMESPACES ('www.microsoft.com/SqlServer/Dts' AS [dts])
						,[maintenance_plan_steps] AS (
							SELECT [name]
								, CAST(CAST([packagedata] AS VARBINARY(MAX)) AS XML) AS [maintenance_plan_xml]
							FROM [msdb].[dbo].[sysssispackages]
							WHERE [packagetype] = 6
						   )
							INSERT    INTO [#BlitzResults]
									( [CheckID] ,
										[Priority] ,
										[FindingsGroup] ,
										[Finding] ,
										[URL] ,
										[Details] )									  
						SELECT
						180 AS [CheckID] ,
						100 AS [Priority] ,
						'Performance' AS [FindingsGroup] ,
						'Shrink Database Step In Maintenance Plan' AS [Finding] ,
						'http://BrentOzar.com/go/autoshrink' AS [URL] ,									  
						'The maintenance plan ' + [mps].[name] + ' has a step to shrink databases in it. Shrinking databases is as outdated as maintenance plans.' AS [Details] 
						FROM [maintenance_plan_steps] [mps]
							CROSS APPLY [maintenance_plan_xml].[nodes]('//dts:Executables/dts:Executable') [t]([c])
						WHERE [c].[value]('(@dts:ObjectName)', 'VARCHAR(128)') = 'Shrink Database Task'

						END


		/*Find repetitive maintenance tasks*/
		IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 181 )
						AND CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) LIKE '1%' /* Only run on 2008+ */
				BEGIN
						;
						WITH XMLNAMESPACES ('www.microsoft.com/SqlServer/Dts' AS [dts])
						,[maintenance_plan_steps] AS (
							SELECT [name]
								, CAST(CAST([packagedata] AS VARBINARY(MAX)) AS XML) AS [maintenance_plan_xml]
							FROM [msdb].[dbo].[sysssispackages]
							WHERE [packagetype] = 6
							), [maintenance_plan_table] AS (
						SELECT [mps].[name]
							,[c].[value]('(@dts:ObjectName)', 'NVARCHAR(128)') AS [step_name]
						FROM [maintenance_plan_steps] [mps]
							CROSS APPLY [maintenance_plan_xml].[nodes]('//dts:Executables/dts:Executable') [t]([c])
						), [mp_steps_pretty] AS (SELECT DISTINCT [m1].[name] ,
								STUFF((SELECT N', ' + [m2].[step_name]  FROM [maintenance_plan_table] AS [m2] WHERE [m1].[name] = [m2].[name] 
								FOR XML PATH(N'')), 1, 2, N'') AS [maintenance_plan_steps]
						FROM [maintenance_plan_table] AS [m1])
						
							INSERT    INTO [#BlitzResults]
									( [CheckID] ,
										[Priority] ,
										[FindingsGroup] ,
										[Finding] ,
										[URL] ,
										[Details] )						
						
						SELECT
						181 AS [CheckID] ,
						100 AS [Priority] ,
						'Performance' AS [FindingsGroup] ,
						'Repetitive Steps In Maintenance Plans' AS [Finding] ,
						'https://ola.hallengren.com/' AS [URL] , 
						'The maintenance plan ' + [m].[name] + ' is doing repetitive work on indexes and statistics. Perhaps it''s time to try something more modern?' AS [Details]
						FROM [mp_steps_pretty] m
						WHERE m.[maintenance_plan_steps] LIKE '%Rebuild%Reorganize%'
						OR m.[maintenance_plan_steps] LIKE '%Rebuild%Update%'

						END
			

			/* Reliability - No Failover Cluster Nodes Available - 184 */
			IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 184 )
				AND CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)) NOT LIKE '10%'
				AND CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)) NOT LIKE '9%'
					BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        							SELECT TOP 1
							  184 AS CheckID ,
							  20 AS Priority ,
							  ''Reliability'' AS FindingsGroup ,
							  ''No Failover Cluster Nodes Available'' AS Finding ,
							  ''http://BrentOzar.com/go/node'' AS URL ,
							  ''There are no failover cluster nodes available if the active node fails'' AS Details
							FROM (
							  SELECT SUM(CASE WHEN [status] = 0 AND [is_current_owner] = 0 THEN 1 ELSE 0 END) AS [available_nodes]
							  FROM sys.dm_os_cluster_nodes
							) a
							WHERE [available_nodes] &lt; 1';
		                        EXECUTE(@StringToExecute);
					END

		/* Reliability - TempDB File Error */
		IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 191 )
			AND (SELECT COUNT(*) FROM sys.master_files WHERE database_id = 2) &lt;&gt; (SELECT COUNT(*) FROM tempdb.sys.database_files)
				BEGIN
					INSERT    INTO [#BlitzResults]
							( [CheckID] ,
								[Priority] ,
								[FindingsGroup] ,
								[Finding] ,
								[URL] ,
								[Details] )						
						
						SELECT
						191 AS [CheckID] ,
						50 AS [Priority] ,
						'Reliability' AS [FindingsGroup] ,
						'TempDB File Error' AS [Finding] ,
						'http://BrentOzar.com/go/tempdboops' AS [URL] , 
						'Mismatch between the number of TempDB files in sys.master_files versus tempdb.sys.database_files' AS [Details]
				END


				IF @CheckUserDatabaseObjects = 1
					BEGIN

                        /*
                        But what if you need to run a query in every individual database?
				        Check out CheckID 99 below. Yes, it uses sp_MSforeachdb, and no,
				        we're not happy about that. sp_MSforeachdb is known to have a lot
				        of issues, like skipping databases sometimes. However, this is the
				        only built-in option that we have. If you're writing your own code
				        for database maintenance, consider Aaron Bertrand's alternative:
				        http://www.mssqltips.com/sqlservertip/2201/making-a-more-reliable-and-flexible-spmsforeachdb/
				        We don't include that as part of sp_Blitz, of course, because
				        copying and distributing copyrighted code from others without their
				        written permission isn't a good idea.
				        */
				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 99 )
					        BEGIN
						        EXEC dbo.sp_MSforeachdb 'USE [?];  IF EXISTS (SELECT * FROM  sys.tables WITH (NOLOCK) WHERE name = ''sysmergepublications'' ) IF EXISTS ( SELECT * FROM sysmergepublications WITH (NOLOCK) WHERE retention = 0)   INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) SELECT DISTINCT 99, DB_NAME(), 110, ''Performance'', ''Infinite merge replication metadata retention period'', ''http://BrentOzar.com/go/merge'', (''The ['' + DB_NAME() + ''] database has merge replication metadata retention period set to infinite - this can be the case of significant performance issues.'')';
					        END
				        /*
				        Note that by using sp_MSforeachdb, we're running the query in all
				        databases. We're not checking #SkipChecks here for each database to
				        see if we should run the check in this database. That means we may
				        still run a skipped check if it involves sp_MSforeachdb. We just
				        don't output those results in the last step.
                        */


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 163 )
                            AND EXISTS(SELECT * FROM sys.all_objects WHERE name = 'database_query_store_options')
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			                            INSERT INTO #BlitzResults
			                            (CheckID,
			                            DatabaseName,
			                            Priority,
			                            FindingsGroup,
			                            Finding,
			                            URL,
			                            Details)
		                              SELECT TOP 1 163,
		                              ''?'',
		                              10,
		                              ''Performance'',
		                              ''Query Store Disabled'',
		                              ''http://BrentOzar.com/go/querystore'',
		                              (''The new SQL Server 2016 Query Store feature has not been enabled on this database.'')
		                              FROM [?].sys.database_query_store_options WHERE desired_state = 0 AND ''?'' NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''DWConfiguration'', ''DWDiagnostics'', ''DWQueue'', ''ReportServer'', ''ReportServerTempDB'')';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 182 )
                            AND EXISTS(SELECT * FROM sys.all_objects WHERE name = 'database_query_store_options')
							AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Enterprise%'
							AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Developer%'
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			                            INSERT INTO #BlitzResults
			                            (CheckID,
			                            DatabaseName,
			                            Priority,
			                            FindingsGroup,
			                            Finding,
			                            URL,
			                            Details)
		                              SELECT TOP 1 182,
		                              ''?'',
		                              20,
		                              ''Reliability'',
		                              ''Query Store Cleanup Disabled'',
		                              ''http://BrentOzar.com/go/cleanup'',
		                              (''SQL 2016 RTM has a bug involving dumps that happen every time Query Store cleanup jobs run.'')
		                              FROM [?].sys.database_query_store_options WHERE desired_state &lt;&gt; 0 AND ''?'' NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''DWConfiguration'', ''DWDiagnostics'', ''DWQueue'', ''ReportServer'', ''ReportServerTempDB'')';
							END


				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 41 )
					        BEGIN
						        EXEC dbo.sp_MSforeachdb 'use [?];
		                              INSERT INTO #BlitzResults
		                              (CheckID,
		                              DatabaseName,
		                              Priority,
		                              FindingsGroup,
		                              Finding,
		                              URL,
		                              Details)
		                              SELECT 41,
		                              ''?'',
		                              170,
		                              ''File Configuration'',
		                              ''Multiple Log Files on One Drive'',
		                              ''http://BrentOzar.com/go/manylogs'',
		                              (''The ['' + DB_NAME() + ''] database has multiple log files on the '' + LEFT(physical_name, 1) + '' drive. This is not a performance booster because log file access is sequential, not parallel.'')
		                              FROM [?].sys.database_files WHERE type_desc = ''LOG''
			                            AND ''?'' &lt;&gt; ''[tempdb]''
		                              GROUP BY LEFT(physical_name, 1)
		                              HAVING COUNT(*) &gt; 1';
					        END

				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 42 )
					        BEGIN
						        EXEC dbo.sp_MSforeachdb 'use [?];
			                            INSERT INTO #BlitzResults
			                            (CheckID,
			                            DatabaseName,
			                            Priority,
			                            FindingsGroup,
			                            Finding,
			                            URL,
			                            Details)
			                            SELECT DISTINCT 42,
			                            ''?'',
			                            170,
			                            ''File Configuration'',
			                            ''Uneven File Growth Settings in One Filegroup'',
			                            ''http://BrentOzar.com/go/grow'',
			                            (''The ['' + DB_NAME() + ''] database has multiple data files in one filegroup, but they are not all set up to grow in identical amounts.  This can lead to uneven file activity inside the filegroup.'')
			                            FROM [?].sys.database_files
			                            WHERE type_desc = ''ROWS''
			                            GROUP BY data_space_id
			                            HAVING COUNT(DISTINCT growth) &gt; 1 OR COUNT(DISTINCT is_percent_growth) &gt; 1';
					        END


				            IF NOT EXISTS ( SELECT  1
								            FROM    #SkipChecks
								            WHERE   DatabaseName IS NULL AND CheckID = 82 )
					            BEGIN
						            EXEC sp_MSforeachdb 'use [?];
		                                INSERT INTO #BlitzResults
		                                (CheckID,
		                                DatabaseName,
		                                Priority,
		                                FindingsGroup,
		                                Finding,
		                                URL, Details)
		                                SELECT  DISTINCT 82 AS CheckID,
		                                ''?'' as DatabaseName,
		                                170 AS Priority,
		                                ''File Configuration'' AS FindingsGroup,
		                                ''File growth set to percent'',
		                                ''http://brentozar.com/go/percentgrowth'' AS URL,
		                                ''The ['' + DB_NAME() + ''] database file '' + f.physical_name + '' has grown to '' + CAST((f.size * 8 / 1000000) AS NVARCHAR(10)) + '' GB, and is using percent filegrowth settings. This can lead to slow performance during growths if Instant File Initialization is not enabled.''
		                                FROM    [?].sys.database_files f
		                                WHERE   is_percent_growth = 1 and size &gt; 128000 ';
					            END



                            /* addition by Henrik Staun Poulsen, Stovi Software */
				            IF NOT EXISTS ( SELECT  1
								            FROM    #SkipChecks
								            WHERE   DatabaseName IS NULL AND CheckID = 158 )
					            BEGIN
						            EXEC sp_MSforeachdb 'use [?];
		                                INSERT INTO #BlitzResults
		                                (CheckID,
		                                DatabaseName,
		                                Priority,
		                                FindingsGroup,
		                                Finding,
		                                URL, Details)
		                                SELECT  DISTINCT 158 AS CheckID,
		                                ''?'' as DatabaseName,
		                                170 AS Priority,
		                                ''File Configuration'' AS FindingsGroup,
		                                ''File growth set to 1MB'',
		                                ''http://brentozar.com/go/percentgrowth'' AS URL,
		                                ''The ['' + DB_NAME() + ''] database file '' + f.physical_name + '' is using 1MB filegrowth settings, but it has grown to '' + CAST((f.size * 8 / 1000000) AS NVARCHAR(10)) + '' GB. Time to up the growth amount.''
		                                FROM    [?].sys.database_files f
                                        WHERE is_percent_growth = 0 and growth=128 and size &gt; 128000 ';
					            END



				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 33 )
					        BEGIN
						        IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							        AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							        BEGIN
								        EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults
					                                (CheckID,
					                                DatabaseName,
					                                Priority,
					                                FindingsGroup,
					                                Finding,
					                                URL,
					                                Details)
		                                  SELECT DISTINCT 33,
		                                  db_name(),
		                                  200,
		                                  ''Licensing'',
		                                  ''Enterprise Edition Features In Use'',
		                                  ''http://BrentOzar.com/go/ee'',
		                                  (''The ['' + DB_NAME() + ''] database is using '' + feature_name + ''.  If this database is restored onto a Standard Edition server, the restore will fail.'')
		                                  FROM [?].sys.dm_db_persisted_sku_features';
							        END;
					        END


				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 19 )
					        BEGIN
						        /* Method 1: Check sys.databases parameters */
						        INSERT  INTO #BlitzResults
								        ( CheckID ,
								          DatabaseName ,
								          Priority ,
								          FindingsGroup ,
								          Finding ,
								          URL ,
								          Details
								        )

								        SELECT  19 AS CheckID ,
										        [name] AS DatabaseName ,
										        200 AS Priority ,
										        'Informational' AS FindingsGroup ,
										        'Replication In Use' AS Finding ,
										        'http://BrentOzar.com/go/repl' AS URL ,
										        ( 'Database [' + [name]
										          + '] is a replication publisher, subscriber, or distributor.' ) AS Details
								        FROM    sys.databases
								        WHERE   name NOT IN ( SELECT DISTINCT
																        DatabaseName
													          FROM      #SkipChecks 
													          WHERE CheckID IS NULL)
										        AND is_published = 1
										        OR is_subscribed = 1
										        OR is_merge_published = 1
										        OR is_distributor = 1;

						        /* Method B: check subscribers for MSreplication_objects tables */
						        EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults
										        (CheckID,
										        DatabaseName,
										        Priority,
										        FindingsGroup,
										        Finding,
										        URL,
										        Details)
							          SELECT DISTINCT 19,
							          db_name(),
							          200,
							          ''Informational'',
							          ''Replication In Use'',
							          ''http://BrentOzar.com/go/repl'',
							          (''['' + DB_NAME() + ''] has MSreplication_objects tables in it, indicating it is a replication subscriber.'')
							          FROM [?].sys.tables
							          WHERE name = ''dbo.MSreplication_objects'' AND ''?'' &lt;&gt; ''master''';

					        END



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 32 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
			SELECT 32,
			''?'',
			150,
			''Performance'',
			''Triggers on Tables'',
			''http://BrentOzar.com/go/trig'',
			(''The ['' + DB_NAME() + ''] database has '' + CAST(SUM(1) AS NVARCHAR(50)) + '' triggers.'')
			FROM [?].sys.triggers t INNER JOIN [?].sys.objects o ON t.parent_id = o.object_id
			INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id WHERE t.is_ms_shipped = 0 AND DB_NAME() != ''ReportServer''
			HAVING SUM(1) &gt; 0';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 38 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
		  SELECT DISTINCT 38,
		  ''?'',
		  110,
		  ''Performance'',
		  ''Active Tables Without Clustered Indexes'',
		  ''http://BrentOzar.com/go/heaps'',
		  (''The ['' + DB_NAME() + ''] database has heaps - tables without a clustered index - that are being actively queried.'')
		  FROM [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id
		  INNER JOIN [?].sys.partitions p ON i.object_id = p.object_id AND i.index_id = p.index_id
		  INNER JOIN sys.databases sd ON sd.name = ''?''
		  LEFT OUTER JOIN [?].sys.dm_db_index_usage_stats ius ON i.object_id = ius.object_id AND i.index_id = ius.index_id AND ius.database_id = sd.database_id
		  WHERE i.type_desc = ''HEAP'' AND COALESCE(ius.user_seeks, ius.user_scans, ius.user_lookups, ius.user_updates) IS NOT NULL
		  AND sd.name &lt;&gt; ''tempdb'' AND sd.name &lt;&gt; ''DWDiagnostics'' AND o.is_ms_shipped = 0 AND o.type &lt;&gt; ''S''';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 164 )
                            AND EXISTS(SELECT * FROM sys.all_objects WHERE name = 'fn_validate_plan_guide')
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
		  SELECT DISTINCT 164,
		  ''?'',
		  20,
		  ''Reliability'',
		  ''Plan Guides Failing'',
		  ''http://BrentOzar.com/go/misguided'',
		  (''The ['' + DB_NAME() + ''] database has plan guides that are no longer valid, so the queries involved may be failing silently.'')
		  FROM [?].sys.plan_guides g CROSS APPLY fn_validate_plan_guide(g.plan_guide_id)';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 39 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
		  SELECT DISTINCT 39,
		  ''?'',
		  150,
		  ''Performance'',
		  ''Inactive Tables Without Clustered Indexes'',
		  ''http://BrentOzar.com/go/heaps'',
		  (''The ['' + DB_NAME() + ''] database has heaps - tables without a clustered index - that have not been queried since the last restart.  These may be backup tables carelessly left behind.'')
		  FROM [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id
		  INNER JOIN [?].sys.partitions p ON i.object_id = p.object_id AND i.index_id = p.index_id
		  INNER JOIN sys.databases sd ON sd.name = ''?''
		  LEFT OUTER JOIN [?].sys.dm_db_index_usage_stats ius ON i.object_id = ius.object_id AND i.index_id = ius.index_id AND ius.database_id = sd.database_id
		  WHERE i.type_desc = ''HEAP'' AND COALESCE(ius.user_seeks, ius.user_scans, ius.user_lookups, ius.user_updates) IS NULL
		  AND sd.name &lt;&gt; ''tempdb'' AND sd.name &lt;&gt; ''DWDiagnostics'' AND o.is_ms_shipped = 0 AND o.type &lt;&gt; ''S''';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 46 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 46,
		  ''?'',
		  150,
		  ''Performance'',
		  ''Leftover Fake Indexes From Wizards'',
		  ''http://BrentOzar.com/go/hypo'',
		  (''The index ['' + DB_NAME() + ''].['' + s.name + ''].['' + o.name + ''].['' + i.name + ''] is a leftover hypothetical index from the Index Tuning Wizard or Database Tuning Advisor.  This index is not actually helping performance and should be removed.'')
		  from [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_hypothetical = 1';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 47 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 47,
		  ''?'',
		  100,
		  ''Performance'',
		  ''Indexes Disabled'',
		  ''http://BrentOzar.com/go/ixoff'',
		  (''The index ['' + DB_NAME() + ''].['' + s.name + ''].['' + o.name + ''].['' + i.name + ''] is disabled.  This index is not actually helping performance and should either be enabled or removed.'')
		  from [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_disabled = 1';
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 48 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT 48,
		  ''?'',
		  150,
		  ''Performance'',
		  ''Foreign Keys Not Trusted'',
		  ''http://BrentOzar.com/go/trust'',
		  (''The ['' + DB_NAME() + ''] database has foreign keys that were probably disabled, data was changed, and then the key was enabled again.  Simply enabling the key is not enough for the optimizer to use this key - we have to alter the table using the WITH CHECK CHECK CONSTRAINT parameter.'')
		  from [?].sys.foreign_keys i INNER JOIN [?].sys.objects o ON i.parent_object_id = o.object_id INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_not_trusted = 1 AND i.is_not_for_replication = 0 AND i.is_disabled = 0 AND ''?'' NOT IN (''master'', ''model'', ''msdb'', ''ReportServer'', ''ReportServerTempDB'')';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 56 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 56,
		  ''?'',
		  150,
		  ''Performance'',
		  ''Check Constraint Not Trusted'',
		  ''http://BrentOzar.com/go/trust'',
		  (''The check constraint ['' + DB_NAME() + ''].['' + s.name + ''].['' + o.name + ''].['' + i.name + ''] is not trusted - meaning, it was disabled, data was changed, and then the constraint was enabled again.  Simply enabling the constraint is not enough for the optimizer to use this constraint - we have to alter the table using the WITH CHECK CHECK CONSTRAINT parameter.'')
		  from [?].sys.check_constraints i INNER JOIN [?].sys.objects o ON i.parent_object_id = o.object_id
		  INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_not_trusted = 1 AND i.is_not_for_replication = 0 AND i.is_disabled = 0';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 95 )
							BEGIN
								IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
									AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
									BEGIN
										EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
				  (CheckID,
				  DatabaseName,
				  Priority,
				  FindingsGroup,
				  Finding,
				  URL,
				  Details)
			SELECT TOP 1 95 AS CheckID,
			''?'' as DatabaseName,
			110 AS Priority,
			''Performance'' AS FindingsGroup,
			''Plan Guides Enabled'' AS Finding,
			''http://BrentOzar.com/go/guides'' AS URL,
			(''Database ['' + DB_NAME() + ''] has query plan guides so a query will always get a specific execution plan. If you are having trouble getting query performance to improve, it might be due to a frozen plan. Review the DMV sys.plan_guides to learn more about the plan guides in place on this server.'') AS Details
			FROM [?].sys.plan_guides WHERE is_disabled = 0'
									END;
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 60 )
							BEGIN
								EXEC sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT  DISTINCT 60 AS CheckID,
		  ''?'' as DatabaseName,
		  100 AS Priority,
		  ''Performance'' AS FindingsGroup,
		  ''Fill Factor Changed'',
		  ''http://brentozar.com/go/fillfactor'' AS URL,
		  ''The ['' + DB_NAME() + ''] database has objects with fill factor &lt; 80%. This can cause memory and storage performance problems, but may also prevent page splits.''
		  FROM    [?].sys.indexes
		  WHERE   fill_factor &lt;&gt; 0 AND fill_factor &lt; 80 AND is_disabled = 0 AND is_hypothetical = 0';
							END



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 78 )
							BEGIN
                                EXECUTE master.sys.sp_MSforeachdb 'USE [?]; 
                                    INSERT INTO #Recompile 
                                    SELECT DBName = DB_Name(), SPName = SO.name, SM.is_recompiled, ISR.SPECIFIC_SCHEMA 
                                    FROM sys.sql_modules AS SM 
                                    LEFT OUTER JOIN master.sys.databases AS sDB ON SM.object_id = DB_id() 
                                    LEFT OUTER JOIN dbo.sysobjects AS SO ON SM.object_id = SO.id and type = ''P'' 
                                    LEFT OUTER JOIN INFORMATION_SCHEMA.ROUTINES AS ISR on ISR.Routine_Name = SO.name AND ISR.SPECIFIC_CATALOG = DB_Name()
                                    WHERE SM.is_recompiled=1 
                                    ' 
                                INSERT INTO #BlitzResults
													(Priority,
													FindingsGroup,
                                                    Finding,
                                                    DatabaseName,
                                                    URL,
                                                    Details,
                                                    CheckID)
                                SELECT [Priority] = '100', 
                                    FindingsGroup = 'Performance', 
                                    Finding = 'Stored Procedure WITH RECOMPILE',
                                    DatabaseName = DBName,
                                    URL = 'http://BrentOzar.com/go/recompile',
                                    Details = '[' + DBName + '].[' + SPSchema + '].[' + ProcName + '] has WITH RECOMPILE in the stored procedure code, which may cause increased CPU usage due to constant recompiles of the code.',
                                    CheckID = '78'
                                FROM #Recompile AS TR WHERE ProcName NOT LIKE 'sp_AskBrent%' AND ProcName NOT LIKE 'sp_Blitz%' 
                                DROP TABLE #Recompile;
                            END



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 86 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) SELECT DISTINCT 86, DB_NAME(), 230, ''Security'', ''Elevated Permissions on a Database'', ''http://BrentOzar.com/go/elevated'', (''In ['' + DB_NAME() + ''], user ['' + u.name + '']  has the role ['' + g.name + ''].  This user can perform tasks beyond just reading and writing data.'') FROM [?].dbo.sysmembers m inner join [?].dbo.sysusers u on m.memberuid = u.uid inner join sysusers g on m.groupuid = g.uid where u.name &lt;&gt; ''dbo'' and g.name in (''db_owner'' , ''db_accessadmin'' , ''db_securityadmin'' , ''db_ddladmin'')';
							END


							/*Check for non-aligned indexes in partioned databases*/

										IF NOT EXISTS ( SELECT  1
														FROM    #SkipChecks
														WHERE   DatabaseName IS NULL AND CheckID = 72 )
											BEGIN
												EXEC dbo.sp_MSforeachdb 'USE [?];
								insert into #partdb(dbname, objectname, type_desc)
								SELECT distinct db_name(DB_ID()) as DBName,o.name Object_Name,ds.type_desc
								FROM sys.objects AS o JOIN sys.indexes AS i ON o.object_id = i.object_id
								JOIN sys.data_spaces ds on ds.data_space_id = i.data_space_id
								LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s ON i.object_id = s.object_id AND i.index_id = s.index_id AND s.database_id = DB_ID()
								WHERE  o.type = ''u''
								 -- Clustered and Non-Clustered indexes
								AND i.type IN (1, 2)
								AND o.object_id in
								  (
									SELECT a.object_id from
									  (SELECT ob.object_id, ds.type_desc from sys.objects ob JOIN sys.indexes ind on ind.object_id = ob.object_id join sys.data_spaces ds on ds.data_space_id = ind.data_space_id
									  GROUP BY ob.object_id, ds.type_desc ) a group by a.object_id having COUNT (*) &gt; 1
								  )'
												INSERT  INTO #BlitzResults
														( CheckID ,
														  DatabaseName ,
														  Priority ,
														  FindingsGroup ,
														  Finding ,
														  URL ,
														  Details
														)
														SELECT DISTINCT
																72 AS CheckID ,
																dbname AS DatabaseName ,
																100 AS Priority ,
																'Performance' AS FindingsGroup ,
																'The partitioned database ' + dbname
																+ ' may have non-aligned indexes' AS Finding ,
																'http://BrentOzar.com/go/aligned' AS URL ,
																'Having non-aligned indexes on partitioned tables may cause inefficient query plans and CPU pressure' AS Details
														FROM    #partdb
														WHERE   dbname IS NOT NULL
																AND dbname NOT IN ( SELECT DISTINCT
																						  DatabaseName
																					FROM  #SkipChecks 
																					WHERE CheckID IS NULL)
												DROP TABLE #partdb
											END


					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 113 )
									BEGIN
							  EXEC dbo.sp_MSforeachdb 'USE [?];
							  INSERT INTO #BlitzResults
									(CheckID,
									DatabaseName,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
							  SELECT DISTINCT 113,
							  ''?'',
							  50,
							  ''Reliability'',
							  ''Full Text Indexes Not Updating'',
							  ''http://BrentOzar.com/go/fulltext'',
							  (''At least one full text index in this database has not been crawled in the last week.'')
							  from [?].sys.fulltext_indexes i WHERE change_tracking_state_desc &lt;&gt; ''AUTO'' AND i.is_enabled = 1 AND i.crawl_end_date &lt; DATEADD(dd, -7, GETDATE())';
												END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 115 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 115,
		  ''?'',
		  110,
		  ''Performance'',
		  ''Parallelism Rocket Surgery'',
		  ''http://BrentOzar.com/go/makeparallel'',
		  (''['' + DB_NAME() + ''] has a make_parallel function, indicating that an advanced developer may be manhandling SQL Server into forcing queries to go parallel.'')
		  from [?].INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = ''make_parallel'' AND ROUTINE_TYPE = ''FUNCTION''';
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 122 )
							BEGIN
								/* SQL Server 2012 and newer uses temporary stats for AlwaysOn Availability Groups, and those show up as user-created */
								IF EXISTS (SELECT *
									  FROM sys.all_columns c
									  INNER JOIN sys.all_objects o ON c.object_id = o.object_id
									  WHERE c.name = 'is_temporary' AND o.name = 'stats')

										EXEC dbo.sp_MSforeachdb 'USE [?];
												INSERT INTO #BlitzResults
													(CheckID,
													DatabaseName,
													Priority,
													FindingsGroup,
													Finding,
													URL,
													Details)
												SELECT TOP 1 122,
												''?'',
												200,
												''Performance'',
												''User-Created Statistics In Place'',
												''http://BrentOzar.com/go/userstats'',
												(''['' + DB_NAME() + ''] has '' + CAST(SUM(1) AS NVARCHAR(10)) + '' user-created statistics. This indicates that someone is being a rocket scientist with the stats, and might actually be slowing things down, especially during stats updates.'')
												from [?].sys.stats WHERE user_created = 1 AND is_temporary = 0
                                                HAVING SUM(1) &gt; 0;';

									ELSE
										EXEC dbo.sp_MSforeachdb 'USE [?];
												INSERT INTO #BlitzResults
													(CheckID,
													DatabaseName,
													Priority,
													FindingsGroup,
													Finding,
													URL,
													Details)
												SELECT 122,
												''?'',
												200,
												''Performance'',
												''User-Created Statistics In Place'',
												''http://BrentOzar.com/go/userstats'',
												(''['' + DB_NAME() + ''] has '' + CAST(SUM(1) AS NVARCHAR(10)) + '' user-created statistics. This indicates that someone is being a rocket scientist with the stats, and might actually be slowing things down, especially during stats updates.'')
												from [?].sys.stats WHERE user_created = 1
                                                HAVING SUM(1) &gt; 0;';


							END /* IF NOT EXISTS ( SELECT  1 */


		        /*Check for high VLF count: this will omit any database snapshots*/

				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 69 )
					        BEGIN
						        IF @ProductVersionMajor &gt;= 11

							        BEGIN
								        EXEC sp_MSforeachdb N'USE [?];
		                                      INSERT INTO #LogInfo2012
		                                      EXEC sp_executesql N''DBCC LogInfo() WITH NO_INFOMSGS'';
		                                      IF    @@ROWCOUNT &gt; 999
		                                      BEGIN
			                                    INSERT  INTO #BlitzResults
			                                    ( CheckID
			                                    ,DatabaseName
			                                    ,Priority
			                                    ,FindingsGroup
			                                    ,Finding
			                                    ,URL
			                                    ,Details)
			                                    SELECT      69
			                                    ,DB_NAME()
			                                    ,170
			                                    ,''File Configuration''
			                                    ,''High VLF Count''
			                                    ,''http://BrentOzar.com/go/vlf''
			                                    ,''The ['' + DB_NAME() + ''] database has '' +  CAST(COUNT(*) as VARCHAR(20)) + '' virtual log files (VLFs). This may be slowing down startup, restores, and even inserts/updates/deletes.''
			                                    FROM #LogInfo2012
			                                    WHERE EXISTS (SELECT name FROM master.sys.databases
					                                    WHERE source_database_id is null) ;
		                                      END
		                                    TRUNCATE TABLE #LogInfo2012;'
								        DROP TABLE #LogInfo2012;
							        END
						        ELSE
							        BEGIN
								        EXEC sp_MSforeachdb N'USE [?];
		                                      INSERT INTO #LogInfo
		                                      EXEC sp_executesql N''DBCC LogInfo() WITH NO_INFOMSGS'';
		                                      IF    @@ROWCOUNT &gt; 999
		                                      BEGIN
			                                    INSERT  INTO #BlitzResults
			                                    ( CheckID
			                                    ,DatabaseName
			                                    ,Priority
			                                    ,FindingsGroup
			                                    ,Finding
			                                    ,URL
			                                    ,Details)
			                                    SELECT      69
			                                    ,DB_NAME()
			                                    ,170
			                                    ,''File Configuration''
			                                    ,''High VLF Count''
			                                    ,''http://BrentOzar.com/go/vlf''
			                                    ,''The ['' + DB_NAME() + ''] database has '' +  CAST(COUNT(*) as VARCHAR(20)) + '' virtual log files (VLFs). This may be slowing down startup, restores, and even inserts/updates/deletes.''
			                                    FROM #LogInfo
			                                    WHERE EXISTS (SELECT name FROM master.sys.databases
			                                    WHERE source_database_id is null);
		                                      END
		                                      TRUNCATE TABLE #LogInfo;'
								        DROP TABLE #LogInfo;
							        END
					        END


				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 80 )
					        BEGIN
						        EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) SELECT DISTINCT 80, DB_NAME(), 170, ''Reliability'', ''Max File Size Set'', ''http://BrentOzar.com/go/maxsize'', (''The ['' + DB_NAME() + ''] database file '' + name + '' has a max file size set to '' + CAST(CAST(max_size AS BIGINT) * 8 / 1024 AS VARCHAR(100)) + ''MB. If it runs out of space, the database will stop working even though there may be drive space available.'') FROM sys.database_files WHERE max_size &lt;&gt; 268435456 AND max_size &lt;&gt; -1 AND type &lt;&gt; 2 AND name &lt;&gt; ''DWDiagnostics'' ';
					        END

	
						/* Check if columnstore indexes are in use - for Github issue #615 */
				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 74 ) /* Trace flags */
					        BEGIN
								TRUNCATE TABLE #TemporaryDatabaseResults;
						        EXEC dbo.sp_MSforeachdb 'USE [?]; IF EXISTS(SELECT * FROM sys.indexes WHERE type IN (5,6)) INSERT INTO #TemporaryDatabaseResults (DatabaseName, Finding) VALUES (DB_NAME(), ''Yup'')';
								IF EXISTS (SELECT * FROM #TemporaryDatabaseResults) SET @ColumnStoreIndexesInUse = 1;
					        END


						/* Non-Default Database Scoped Config - Github issue #598 */
				        IF EXISTS ( SELECT * FROM sys.all_objects WHERE [name] = 'database_scoped_configurations' )
					        BEGIN
								INSERT INTO #DatabaseScopedConfigurationDefaults (configuration_id, [name], default_value, default_value_for_secondary, CheckID)
									SELECT 1, 'MAXDOP', 0, NULL, 194
									UNION ALL
									SELECT 2, 'LEGACY_CARDINALITY_ESTIMATION', 0, NULL, 195
									UNION ALL
									SELECT 3, 'PARAMETER_SNIFFING', 1, NULL, 196
									UNION ALL
									SELECT 4, 'QUERY_OPTIMIZER_HOTFIXES', 0, NULL, 197;
						        EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) 
									SELECT def1.CheckID, DB_NAME(), 210, ''Non-Default Database Scoped Config'', dsc.[name], ''http://BrentOzar.com/go/dbscope'', (''Set value: '' + COALESCE(CAST(dsc.value AS NVARCHAR(100)),''Empty'') + '' Default: '' + COALESCE(CAST(def1.default_value AS NVARCHAR(100)),''Empty'') + '' Set value for secondary: '' + COALESCE(CAST(dsc.value_for_secondary AS NVARCHAR(100)),''Empty'') + '' Default value for secondary: '' + COALESCE(CAST(def1.default_value_for_secondary AS NVARCHAR(100)),''Empty''))
									FROM [?].sys.database_scoped_configurations dsc 
									INNER JOIN #DatabaseScopedConfigurationDefaults def1 ON dsc.configuration_id = def1.configuration_id
									LEFT OUTER JOIN #DatabaseScopedConfigurationDefaults def ON dsc.configuration_id = def.configuration_id AND (dsc.value = def.default_value OR dsc.value IS NULL) AND (dsc.value_for_secondary = def.default_value_for_secondary OR dsc.value_for_secondary IS NULL)
									LEFT OUTER JOIN #SkipChecks sk ON def.CheckID = sk.CheckID AND (sk.DatabaseName IS NULL OR sk.DatabaseName = DB_NAME())
									WHERE def.configuration_id IS NULL AND sk.CheckID IS NULL ORDER BY 1';
					        END



	
					END /* IF @CheckUserDatabaseObjects = 1 */

				IF @CheckProcedureCache = 1
					BEGIN

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 35 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  35 AS CheckID ,
												100 AS Priority ,
												'Performance' AS FindingsGroup ,
												'Single-Use Plans in Procedure Cache' AS Finding ,
												'http://BrentOzar.com/go/single' AS URL ,
												( CAST(COUNT(*) AS VARCHAR(10))
												  + ' query plans are taking up memory in the procedure cache. This may be wasted memory if we cache plans for queries that never get called again. This may be a good use case for SQL Server 2008''s Optimize for Ad Hoc or for Forced Parameterization.' ) AS Details
										FROM    sys.dm_exec_cached_plans AS cp
										WHERE   cp.usecounts = 1
												AND cp.objtype = 'Adhoc'
												AND EXISTS ( SELECT
																  1
															 FROM sys.configurations
															 WHERE
																  name = 'optimize for ad hoc workloads'
																  AND value_in_use = 0 )
										HAVING  COUNT(*) &gt; 1;
							END


		  /* Set up the cache tables. Different on 2005 since it doesn't support query_hash, query_plan_hash. */
						IF @@VERSION LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								IF @CheckProcedureCacheFilter = 'CPU'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			  FROM sys.dm_exec_query_stats qs
			  ORDER BY qs.total_worker_time DESC)
			  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			  FROM queries qs
			  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
			  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'Reads'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_logical_reads DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'ExecCount'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.execution_count DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'Duration'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			FROM sys.dm_exec_query_stats qs
			ORDER BY qs.total_elapsed_time DESC)
			INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			FROM queries qs
			LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
			WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

							END;
						IF @ProductVersionMajor &gt;= 10
							BEGIN
								IF @CheckProcedureCacheFilter = 'CPU'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_worker_time DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'Reads'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_logical_reads DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'ExecCount'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.execution_count DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'Duration'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_elapsed_time DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

		/* Populate the query_plan_filtered field. Only works in 2005SP2+, but we're just doing it in 2008 to be safe. */
								UPDATE  #dm_exec_query_stats
								SET     query_plan_filtered = qp.query_plan
								FROM    #dm_exec_query_stats qs
										CROSS APPLY sys.dm_exec_text_query_plan(qs.plan_handle,
																  qs.statement_start_offset,
																  qs.statement_end_offset)
										AS qp

							END;

		/* Populate the additional query_plan, text, and text_filtered fields */
						UPDATE  #dm_exec_query_stats
						SET     query_plan = qp.query_plan ,
								[text] = st.[text] ,
								text_filtered = SUBSTRING(st.text,
														  ( qs.statement_start_offset
															/ 2 ) + 1,
														  ( ( CASE qs.statement_end_offset
																WHEN -1
																THEN DATALENGTH(st.text)
																ELSE qs.statement_end_offset
															  END
															  - qs.statement_start_offset )
															/ 2 ) + 1)
						FROM    #dm_exec_query_stats qs
								CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
								CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle)
								AS qp

		/* Dump instances of our own script. We're not trying to tune ourselves. */
						DELETE  #dm_exec_query_stats
						WHERE   text LIKE '%sp_Blitz%'
								OR text LIKE '%#BlitzResults%'

		/* Look for implicit conversions */

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 63 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  63 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Implicit Conversion' AS Finding ,
												'http://BrentOzar.com/go/implicit' AS URL ,
												( 'One of the top resource-intensive queries is comparing two fields that are not the same datatype.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%CONVERT_IMPLICIT%'
												AND COALESCE(qs.query_plan_filtered,
															 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%PhysicalOp="Index Scan"%'
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 64 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  64 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Implicit Conversion Affecting Cardinality' AS Finding ,
												'http://BrentOzar.com/go/implicit' AS URL ,
												( 'One of the top resource-intensive queries has an implicit conversion that is affecting cardinality estimation.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%&lt;PlanAffectingConvert ConvertIssue="Cardinality Estimate" Expression="CONVERT_IMPLICIT%'
							END

							/* @cms4j, 29.11.2013: Look for RID or Key Lookups */
							IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 118 )
								BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details ,
											  QueryPlan ,
											  QueryPlanFiltered
											)
											SELECT  118 AS CheckID ,
													120 AS Priority ,
													'Query Plans' AS FindingsGroup ,
													'RID or Key Lookups' AS Finding ,
													'http://BrentOzar.com/go/lookup' AS URL ,
													'One of the top resource-intensive queries contains RID or Key Lookups. Try to avoid them by creating covering indexes.' AS Details ,
													qs.query_plan ,
													qs.query_plan_filtered
											FROM    #dm_exec_query_stats qs
											WHERE   COALESCE(qs.query_plan_filtered,
															 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%Lookup="1"%'
								END /* @cms4j, 29.11.2013: Look for RID or Key Lookups */


						/* Look for missing indexes */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 65 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  65 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Missing Index' AS Finding ,
												'http://BrentOzar.com/go/missingindex' AS URL ,
												( 'One of the top resource-intensive queries may be dramatically improved by adding an index.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%MissingIndexGroup%'
							END

						/* Look for cursors */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 66 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  66 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Cursor' AS Finding ,
												'http://BrentOzar.com/go/cursor' AS URL ,
												( 'One of the top resource-intensive queries is using a cursor.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%&lt;StmtCursor%'
							END

		/* Look for scalar user-defined functions */

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 67 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  67 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Scalar UDFs' AS Finding ,
												'http://BrentOzar.com/go/functions' AS URL ,
												( 'One of the top resource-intensive queries is using a user-defined scalar function that may inhibit parallelism.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%&lt;UserDefinedFunction%'
							END

					END /* IF @CheckProcedureCache = 1 */
									  
		/*Check to see if the HA endpoint account is set at the same as the SQL Server Service Account*/
		IF @ProductVersionMajor &gt;= 10
								AND NOT EXISTS ( SELECT 1
								FROM #SkipChecks
								WHERE DatabaseName IS NULL AND CheckID = 187 )

		IF SERVERPROPERTY('IsHadrEnabled') = 1
    		BEGIN
                INSERT    INTO [#BlitzResults]
                               	( [CheckID] ,
                                [Priority] ,
                                [FindingsGroup] ,
                                [Finding] ,
                                [URL] ,
                                [Details] )
               	SELECT
                        187 AS [CheckID] ,
                        230 AS [Priority] ,
                        'Security' AS [FindingsGroup] ,
                        'Endpoints Owned by Users' AS [Finding] ,
                       	'http://BrentOzar.com/go/owners' AS [URL] ,
                        ( 'Endpoint ' + ep.[name] + ' is owned by ' + SUSER_NAME(ep.principal_id) + '. If the endpoint owner login is disabled or not available due to Active Directory problems, the high availability will stop working.'
                        ) AS [Details]
					FROM sys.database_mirroring_endpoints ep
					LEFT OUTER JOIN sys.dm_server_services s ON SUSER_NAME(ep.principal_id) = s.service_account
					WHERE s.service_account IS NULL;
    		END

		/*Check for the last good DBCC CHECKDB date */
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 68 )
					BEGIN
						EXEC sp_MSforeachdb N'USE [?];
						INSERT #DBCCs
							(ParentObject,
							Object,
							Field,
							Value)
						EXEC (''DBCC DBInfo() With TableResults, NO_INFOMSGS'');
						UPDATE #DBCCs SET DbName = N''?'' WHERE DbName IS NULL;';

						WITH    DB2
								  AS ( SELECT DISTINCT
												Field ,
												Value ,
												DbName
									   FROM     #DBCCs
									   WHERE    Field = 'dbi_dbccLastKnownGood'
									 )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  DatabaseName ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  68 AS CheckID ,
											DB2.DbName AS DatabaseName ,
											1 AS PRIORITY ,
											'Reliability' AS FindingsGroup ,
											'Last good DBCC CHECKDB over 2 weeks old' AS Finding ,
											'http://BrentOzar.com/go/checkdb' AS URL ,
											'Last successful CHECKDB: '
											+ CASE DB2.Value
												WHEN '1900-01-01 00:00:00.000'
												THEN ' never.'
												ELSE DB2.Value
											  END AS Details
									FROM    DB2
									WHERE   DB2.DbName &lt;&gt; 'tempdb'
											AND DB2.DbName NOT IN ( SELECT DISTINCT
																  DatabaseName
																FROM
																  #SkipChecks 
																WHERE CheckID IS NULL)
											AND CONVERT(DATETIME, DB2.Value, 121) &lt; DATEADD(DD,
																  -14,
																  CURRENT_TIMESTAMP)
					END




	/*Verify that the servername is set */
			IF NOT EXISTS ( SELECT  1
							FROM    #SkipChecks
							WHERE   DatabaseName IS NULL AND CheckID = 70 )
				BEGIN
					IF @@SERVERNAME IS NULL
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  70 AS CheckID ,
											200 AS Priority ,
											'Informational' AS FindingsGroup ,
											'@@Servername Not Set' AS Finding ,
											'http://BrentOzar.com/go/servername' AS URL ,
											'@@Servername variable is null. You can fix it by executing: "sp_addserver ''&lt;LocalServerName&gt;'', local"' AS Details
						END;

					IF  /* @@SERVERNAME IS set */
						(@@SERVERNAME IS NOT NULL
						AND
						/* not a named instance */
						CHARINDEX('\',CAST(SERVERPROPERTY('ServerName') AS NVARCHAR)) = 0
						AND
						/* not clustered, when computername may be different than the servername */
						SERVERPROPERTY('IsClustered') = 0
						AND
						/* @@SERVERNAME is different than the computer name */
						@@SERVERNAME &lt;&gt; CAST(ISNULL(SERVERPROPERTY('ComputerNamePhysicalNetBIOS'),@@SERVERNAME) AS NVARCHAR) )
						 BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  70 AS CheckID ,
											200 AS Priority ,
											'Configuration' AS FindingsGroup ,
											'@@Servername Not Correct' AS Finding ,
											'http://BrentOzar.com/go/servername' AS URL ,
											'The @@Servername is different than the computer name, which may trigger certificate errors.' AS Details
						END;

				END
		/*Check to see if a failsafe operator has been configured*/
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 73 )
					BEGIN

						DECLARE @AlertInfo TABLE
							(
							  FailSafeOperator NVARCHAR(255) ,
							  NotificationMethod INT ,
							  ForwardingServer NVARCHAR(255) ,
							  ForwardingSeverity INT ,
							  PagerToTemplate NVARCHAR(255) ,
							  PagerCCTemplate NVARCHAR(255) ,
							  PagerSubjectTemplate NVARCHAR(255) ,
							  PagerSendSubjectOnly NVARCHAR(255) ,
							  ForwardAlways INT
							)
						INSERT  INTO @AlertInfo
								EXEC [master].[dbo].[sp_MSgetalertinfo] @includeaddresses = 0
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  73 AS CheckID ,
										200 AS Priority ,
										'Monitoring' AS FindingsGroup ,
										'No failsafe operator configured' AS Finding ,
										'http://BrentOzar.com/go/failsafe' AS URL ,
										( 'No failsafe operator is configured on this server.  This is a good idea just in-case there are issues with the [msdb] database that prevents alerting.' ) AS Details
								FROM    @AlertInfo
								WHERE   FailSafeOperator IS NULL;
					END

/*Identify globally enabled trace flags*/
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 74 )
					BEGIN
						INSERT  INTO #TraceStatus
								EXEC ( ' DBCC TRACESTATUS(-1) WITH NO_INFOMSGS'
									)
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  74 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'TraceFlag On' AS Finding ,
										CASE WHEN [T].[TraceFlag] = '834'  AND @ColumnStoreIndexesInUse = 1 THEN 'https://support.microsoft.com/en-us/kb/3210239'
											 ELSE'http://www.BrentOzar.com/go/traceflags/' END AS URL ,
										'Trace flag ' + 
										CASE WHEN [T].[TraceFlag] = '2330' THEN ' 2330 enabled globally. Using this trace Flag disables missing index requests'
											 WHEN [T].[TraceFlag] = '1211' THEN ' 1211 enabled globally. Using this Trace Flag disables lock escalation when you least expect it. No Bueno!'
											 WHEN [T].[TraceFlag] = '1224' THEN ' 1224 enabled globally. Using this Trace Flag disables lock escalation based on the number of locks being taken. You shouldn''t have done that, Dave.'
											 WHEN [T].[TraceFlag] = '652'  THEN ' 652 enabled globally. Using this Trace Flag disables pre-fetching during index scans. If you hate slow queries, you should turn that off.'
											 WHEN [T].[TraceFlag] = '661'  THEN ' 661 enabled globally. Using this Trace Flag disables ghost record removal. Who you gonna call? No one, turn that thing off.'
											 WHEN [T].[TraceFlag] = '1806'  THEN ' 1806 enabled globally. Using this Trace Flag disables instant file initialization. I question your sanity.'
											 WHEN [T].[TraceFlag] = '3505'  THEN ' 3505 enabled globally. Using this Trace Flag disables Checkpoints. Probably not the wisest idea.'
											 WHEN [T].[TraceFlag] = '8649'  THEN ' 8649 enabled globally. Using this Trace Flag drops cost thresholf for parallelism down to 0. I hope this is a dev server.'
										     WHEN [T].[TraceFlag] = '834' AND @ColumnStoreIndexesInUse = 1 THEN ' 834 is enabled globally. Using this Trace Flag with Columnstore Indexes is not a great idea.'
											 ELSE [T].[TraceFlag] + ' is enabled globally.' END 
										AS Details
								FROM    #TraceStatus T
					END

		/*Check for transaction log file larger than data file */
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 75 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  75 AS CheckID ,
										DB_NAME(a.database_id) ,
										50 AS Priority ,
										'Reliability' AS FindingsGroup ,
										'Transaction Log Larger than Data File' AS Finding ,
										'http://BrentOzar.com/go/biglog' AS URL ,
										'The database [' + DB_NAME(a.database_id)
										+ '] has a ' + CAST((CAST(a.size AS BIGINT) * 8 / 1000000) AS NVARCHAR(20)) + ' GB transaction log file, larger than the total data file sizes. This may indicate that transaction log backups are not being performed or not performed often enough.' AS Details
								FROM    sys.master_files a
								WHERE   a.type = 1
										AND DB_NAME(a.database_id) NOT IN (
										SELECT DISTINCT
												DatabaseName
										FROM    #SkipChecks )
										AND a.size &gt; 125000 /* Size is measured in pages here, so this gets us log files over 1GB. */
										AND a.size &gt; ( SELECT   SUM(CAST(b.size AS BIGINT))
													   FROM     sys.master_files b
													   WHERE    a.database_id = b.database_id
																AND b.type = 0
													 )
										AND a.database_id IN (
										SELECT  database_id
										FROM    sys.databases
										WHERE   source_database_id IS NULL )
					END

		/*Check for collation conflicts between user databases and tempdb */
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 76 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  76 AS CheckID ,
										name AS DatabaseName ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Collation is ' + collation_name AS Finding ,
										'http://BrentOzar.com/go/collate' AS URL ,
										'Collation differences between user databases and tempdb can cause conflicts especially when comparing string values' AS Details
								FROM    sys.databases
							WHERE   name NOT IN ( 'master', 'model', 'msdb')
										AND name NOT LIKE 'ReportServer%'
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
										AND collation_name &lt;&gt; ( SELECT
																  collation_name
																FROM
																  sys.databases
																WHERE
																  name = 'tempdb'
															  )
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 77 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  77 AS CheckID ,
										dSnap.[name] AS DatabaseName ,
										50 AS Priority ,
										'Reliability' AS FindingsGroup ,
										'Database Snapshot Online' AS Finding ,
										'http://BrentOzar.com/go/snapshot' AS URL ,
										'Database [' + dSnap.[name]
										+ '] is a snapshot of ['
										+ dOriginal.[name]
										+ ']. Make sure you have enough drive space to maintain the snapshot as the original database grows.' AS Details
								FROM    sys.databases dSnap
										INNER JOIN sys.databases dOriginal ON dSnap.source_database_id = dOriginal.database_id
																  AND dSnap.name NOT IN (
																  SELECT DISTINCT
																  DatabaseName
																  FROM
																  #SkipChecks )
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 79 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  79 AS CheckID ,
										100 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Shrink Database Job' AS Finding ,
										'http://BrentOzar.com/go/autoshrink' AS URL ,
										'In the [' + j.[name] + '] job, step ['
										+ step.[step_name]
										+ '] has SHRINKDATABASE or SHRINKFILE, which may be causing database fragmentation.' AS Details
								FROM    msdb.dbo.sysjobs j
										INNER JOIN msdb.dbo.sysjobsteps step ON j.job_id = step.job_id
								WHERE   step.command LIKE N'%SHRINKDATABASE%'
										OR step.command LIKE N'%SHRINKFILE%'
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 81 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  81 AS CheckID ,
										200 AS Priority ,
										'Non-Active Server Config' AS FindingsGroup ,
										cr.name AS Finding ,
										'http://www.BrentOzar.com/blitz/sp_configure/' AS URL ,
										( 'This sp_configure option isn''t running under its set value.  Its set value is '
										  + CAST(cr.[value] AS VARCHAR(100))
										  + ' and its running value is '
										  + CAST(cr.value_in_use AS VARCHAR(100))
										  + '. When someone does a RECONFIGURE or restarts the instance, this setting will start taking effect.' ) AS Details
								FROM    sys.configurations cr
								WHERE   cr.value &lt;&gt; cr.value_in_use
                                 AND NOT (cr.name = 'min server memory (MB)' AND cr.value IN (0,16) AND cr.value_in_use IN (0,16));
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 123 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT TOP 1 123 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Agent Jobs Starting Simultaneously' AS Finding ,
										'http://BrentOzar.com/go/busyagent/' AS URL ,
										( 'Multiple SQL Server Agent jobs are configured to start simultaneously. For detailed schedule listings, see the query in the URL.' ) AS Details
								FROM    msdb.dbo.sysjobactivity
								WHERE start_execution_date &gt; DATEADD(dd, -14, GETDATE())
								GROUP BY start_execution_date HAVING COUNT(*) &gt; 1;
					END


				IF @CheckServerInfo = 1
					BEGIN

/*This checks Windows version. It would be better if Microsoft gave everything a separate build number, but whatever.*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 172 )
					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_os_windows_info' )

					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							172 AS [CheckID] ,
							250 AS [Priority] ,
							'Server Info' AS [FindingsGroup] ,
							'Windows Version' AS [Finding] ,
							'https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions' AS [URL] ,
							( CASE 
								WHEN [owi].[windows_release] = '5' THEN 'You''re running a really old version: Windows 2000, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] &gt; '5' AND [owi].[windows_release] &lt; '6' THEN 'You''re running a really old version: Windows Server 2003/2003R2 era, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] &gt;= '6' AND [owi].[windows_release] &lt;= '6.1' THEN 'You''re running a pretty old version: Windows: Server 2008/2008R2 era, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] = '6.2' THEN 'You''re running a rather modern version of Windows: Server 2012 era, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] = '6.3' THEN 'You''re running a pretty modern version of Windows: Server 2012R2 era, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] &gt; '6.3' THEN 'Hot dog! You''re living in the future! You''re running version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								ELSE 'I have no idea which version of Windows you''re on. Sorry.'
								END
							   ) AS [Details]
							 FROM [sys].[dm_os_windows_info] [owi]

					END;
					END;

/*
This check hits the dm_os_process_memory system view
to see if locked_page_allocations_kb is &gt; 0,
which could indicate that locked pages in memory is enabled.
*/
IF @ProductVersionMajor &gt;= 10 AND  NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 166 )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )
							SELECT
							166 AS [CheckID] ,
							250 AS [Priority] ,
							'Server Info' AS [FindingsGroup] ,
							'Locked Pages In Memory Enabled' AS [Finding] ,
							'http://BrentOzar.com/go/lpim' AS [URL] ,
							( 'You currently have '
							  + CASE WHEN [dopm].[locked_page_allocations_kb] / 1024. / 1024. &gt; 0
									 THEN CAST([dopm].[locked_page_allocations_kb] / 1024. / 1024. AS VARCHAR(100))
										  + ' GB'
									 ELSE CAST([dopm].[locked_page_allocations_kb] / 1024. AS VARCHAR(100))
										  + ' MB'
								END + ' of pages locked in memory.' ) AS [Details]
						  FROM
							[sys].[dm_os_process_memory] AS [dopm]
						  WHERE
							[dopm].[locked_page_allocations_kb] &gt; 0;
					END; 

			/* Server Info - Locked Pages In Memory Enabled - Check 166 - SQL Server 2016 SP1 and newer */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 166 )
							AND EXISTS ( SELECT  *
											FROM    sys.all_objects o
													INNER JOIN sys.all_columns c ON o.object_id = c.object_id
											WHERE   o.name = 'dm_os_sys_info'
													AND c.name = 'sql_memory_model' )
							BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  166 AS CheckID ,
			250 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Memory Model Unconventional'' AS Finding ,
			''http://BrentOzar.com/go/lpim'' AS URL ,
			''Memory Model: '' + CAST(sql_memory_model_desc AS NVARCHAR(100))
			FROM sys.dm_os_sys_info WHERE sql_memory_model &lt;&gt; 1';
										EXECUTE(@StringToExecute);
									END



			/*
			Starting with SQL Server 2014 SP2, Instant File Initialization 
			is logged in the SQL Server Error Log.
			*/
					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 184 )
							AND (@ProductVersionMajor &gt;= 13) OR (@ProductVersionMajor = 12 AND @ProductVersionMinor &gt;= 5000)
						BEGIN
							INSERT INTO #ErrorLog
							EXEC sys.xp_readerrorlog 0, 1, N'Database Instant File Initialization: enabled';

							IF @@ROWCOUNT &gt; 0
								INSERT  INTO #BlitzResults
										( CheckID ,
										  [Priority] ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT
												193 AS [CheckID] ,
												250 AS [Priority] ,
												'Server Info' AS [FindingsGroup] ,
												'Instant File Initialization Enabled' AS [Finding] ,
												'http://BrentOzar.com/go/instant' AS [URL] ,
												'The service account has the Perform Volume Maintenance Tasks permission.'
						END; 

			/* Server Info - Instant File Initialization Not Enabled - Check 192 - SQL Server 2016 SP1 and newer */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 192 )
							AND EXISTS ( SELECT  *
											FROM    sys.all_objects o
													INNER JOIN sys.all_columns c ON o.object_id = c.object_id
											WHERE   o.name = 'dm_server_services'
													AND c.name = 'instant_file_initialization_enabled' )
							BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  192 AS CheckID ,
			50 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Instant File Initialization Not Enabled'' AS Finding ,
			''http://BrentOzar.com/go/instant'' AS URL ,
			''Consider enabling IFI for faster restores and data file growths.''
			FROM sys.dm_server_services WHERE instant_file_initialization_enabled &lt;&gt; ''Y'' AND filename LIKE ''%sqlservr.exe%''';
										EXECUTE(@StringToExecute);
									END





					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 130 )
						BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
											SELECT  130 AS CheckID ,
													250 AS Priority ,
													'Server Info' AS FindingsGroup ,
													'Server Name' AS Finding ,
													'http://BrentOzar.com/go/servername' AS URL ,
													@@SERVERNAME AS Details
												WHERE @@SERVERNAME IS NOT NULL;
								END;



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 83 )
							BEGIN
								IF EXISTS ( SELECT  *
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
									BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
				SELECT  83 AS CheckID ,
				250 AS Priority ,
				''Server Info'' AS FindingsGroup ,
				''Services'' AS Finding ,
				'''' AS URL ,
				N''Service: '' + servicename + N'' runs under service account '' + service_account + N''. Last startup time: '' + COALESCE(CAST(CAST(last_startup_time AS DATETIME) AS VARCHAR(50)), ''not shown.'') + ''. Startup type: '' + startup_type_desc + N'', currently '' + status_desc + ''.''
				FROM sys.dm_server_services;'
										EXECUTE(@StringToExecute);
									END
							END

			/* Check 84 - SQL Server 2012 */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 84 )
							BEGIN
								IF EXISTS ( SELECT  *
											FROM    sys.all_objects o
													INNER JOIN sys.all_columns c ON o.object_id = c.object_id
											WHERE   o.name = 'dm_os_sys_info'
													AND c.name = 'physical_memory_kb' )
									BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  84 AS CheckID ,
			250 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Hardware'' AS Finding ,
			'''' AS URL ,
			''Logical processors: '' + CAST(cpu_count AS VARCHAR(50)) + ''. Physical memory: '' + CAST( CAST(ROUND((physical_memory_kb / 1024.0 / 1024), 1) AS INT) AS VARCHAR(50)) + ''GB.''
			FROM sys.dm_os_sys_info';
										EXECUTE(@StringToExecute);
									END

			/* Check 84 - SQL Server 2008 */
								IF EXISTS ( SELECT  *
											FROM    sys.all_objects o
													INNER JOIN sys.all_columns c ON o.object_id = c.object_id
											WHERE   o.name = 'dm_os_sys_info'
													AND c.name = 'physical_memory_in_bytes' )
									BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  84 AS CheckID ,
			250 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Hardware'' AS Finding ,
			'''' AS URL ,
			''Logical processors: '' + CAST(cpu_count AS VARCHAR(50)) + ''. Physical memory: '' + CAST( CAST(ROUND((physical_memory_in_bytes / 1024.0 / 1024 / 1024), 1) AS INT) AS VARCHAR(50)) + ''GB.''
			FROM sys.dm_os_sys_info';
										EXECUTE(@StringToExecute);
									END
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 85 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  85 AS CheckID ,
												250 AS Priority ,
												'Server Info' AS FindingsGroup ,
												'SQL Server Service' AS Finding ,
												'' AS URL ,
												N'Version: '
												+ CAST(SERVERPROPERTY('productversion') AS NVARCHAR(100))
												+ N'. Patch Level: '
												+ CAST(SERVERPROPERTY('productlevel') AS NVARCHAR(100))
												+ N'. Edition: '
												+ CAST(SERVERPROPERTY('edition') AS VARCHAR(100))
												+ N'. AlwaysOn Enabled: '
												+ CAST(COALESCE(SERVERPROPERTY('IsHadrEnabled'),
																0) AS VARCHAR(100))
												+ N'. AlwaysOn Mgr Status: '
												+ CAST(COALESCE(SERVERPROPERTY('HadrManagerStatus'),
																0) AS VARCHAR(100))
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 88 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  88 AS CheckID ,
												250 AS Priority ,
												'Server Info' AS FindingsGroup ,
												'SQL Server Last Restart' AS Finding ,
												'' AS URL ,
												CAST(create_date AS VARCHAR(100))
										FROM    sys.databases
										WHERE   database_id = 2
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 91 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  91 AS CheckID ,
												250 AS Priority ,
												'Server Info' AS FindingsGroup ,
												'Server Last Restart' AS Finding ,
												'' AS URL ,
												CAST(DATEADD(SECOND, (ms_ticks/1000)*(-1), GETDATE()) AS nvarchar(25))
										FROM sys.dm_os_sys_info
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 92 )
							BEGIN
								INSERT  INTO #driveInfo
										( drive, SIZE )
										EXEC master..xp_fixeddrives

								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  92 AS CheckID ,
												250 AS Priority ,
												'Server Info' AS FindingsGroup ,
												'Drive ' + i.drive + ' Space' AS Finding ,
												'' AS URL ,
												CAST(i.SIZE AS VARCHAR)
												+ 'MB free on ' + i.drive
												+ ' drive' AS Details
										FROM    #driveInfo AS i
								DROP TABLE #driveInfo
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 103 )
							AND EXISTS ( SELECT *
										 FROM   sys.all_objects o
												INNER JOIN sys.all_columns c ON o.object_id = c.object_id
										 WHERE  o.name = 'dm_os_sys_info'
												AND c.name = 'virtual_machine_type_desc' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
									SELECT 103 AS CheckID,
									250 AS Priority,
									''Server Info'' AS FindingsGroup,
									''Virtual Server'' AS Finding,
									''http://BrentOzar.com/go/virtual'' AS URL,
									''Type: ('' + virtual_machine_type_desc + '')'' AS Details
									FROM sys.dm_os_sys_info
									WHERE virtual_machine_type &lt;&gt; 0';
								EXECUTE(@StringToExecute);
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 114 )
							AND EXISTS ( SELECT *
										 FROM   sys.all_objects o
										 WHERE  o.name = 'dm_os_memory_nodes' )
							AND EXISTS ( SELECT *
										 FROM   sys.all_objects o
										 INNER JOIN sys.all_columns c ON o.object_id = c.object_id
										 WHERE  o.name = 'dm_os_nodes'
                                	 		AND c.name = 'processor_group' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
										SELECT  114 AS CheckID ,
												250 AS Priority ,
												''Server Info'' AS FindingsGroup ,
												''Hardware - NUMA Config'' AS Finding ,
												'''' AS URL ,
												''Node: '' + CAST(n.node_id AS NVARCHAR(10)) + '' State: '' + node_state_desc
												+ '' Online schedulers: '' + CAST(n.online_scheduler_count AS NVARCHAR(10)) + '' Offline schedulers: '' + CAST(oac.offline_schedulers AS VARCHAR(100)) + '' Processor Group: '' + CAST(n.processor_group AS NVARCHAR(10))
												+ '' Memory node: '' + CAST(n.memory_node_id AS NVARCHAR(10)) + '' Memory VAS Reserved GB: '' + CAST(CAST((m.virtual_address_space_reserved_kb / 1024.0 / 1024) AS INT) AS NVARCHAR(100))
										FROM sys.dm_os_nodes n
										INNER JOIN sys.dm_os_memory_nodes m ON n.memory_node_id = m.memory_node_id
										OUTER APPLY (SELECT 
										COUNT(*) AS [offline_schedulers]
										FROM sys.dm_os_schedulers dos
										WHERE n.node_id = dos.parent_node_id 
										AND dos.status = ''VISIBLE OFFLINE''
										) oac
										WHERE n.node_state_desc NOT LIKE ''%DAC%''
										ORDER BY n.node_id'
								EXECUTE(@StringToExecute);
							END


							IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 106 )
											AND (select convert(int,value_in_use) from sys.configurations where name = 'default trace enabled' ) = 1
                                AND DATALENGTH( COALESCE( @base_tracefilename, '' ) ) &gt; DATALENGTH('.TRC')
							BEGIN

								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT
												 106 AS CheckID
												,250 AS Priority
												,'Server Info' AS FindingsGroup
												,'Default Trace Contents' AS Finding
												,'http://BrentOzar.com/go/trace' AS URL
												,'The default trace holds '+cast(DATEDIFF(hour,MIN(StartTime),GETDATE())as varchar)+' hours of data'
												+' between '+cast(Min(StartTime) as varchar)+' and '+cast(GETDATE()as varchar)
												+('. The default trace files are located in: '+left( @curr_tracefilename,len(@curr_tracefilename) - @indx)
												) as Details
										FROM    ::fn_trace_gettable( @base_tracefilename, default )
										WHERE EventClass BETWEEN 65500 and 65600
							END /* CheckID 106 */


							IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 152 )
							BEGIN
								IF EXISTS (SELECT * FROM sys.dm_os_wait_stats ws
											LEFT OUTER JOIN #IgnorableWaits i ON ws.wait_type = i.wait_type
											WHERE wait_time_ms &gt; .1 * @CpuMsSinceWaitsCleared AND waiting_tasks_count &gt; 0 
											AND i.wait_type IS NULL)
									BEGIN
									/* Check for waits that have had more than 10% of the server's wait time */
									WITH os(wait_type, waiting_tasks_count, wait_time_ms, max_wait_time_ms, signal_wait_time_ms)
									AS
									(SELECT ws.wait_type, waiting_tasks_count, wait_time_ms, max_wait_time_ms, signal_wait_time_ms
										FROM sys.dm_os_wait_stats ws
										LEFT OUTER JOIN #IgnorableWaits i ON ws.wait_type = i.wait_type
											WHERE i.wait_type IS NULL 
												AND wait_time_ms &gt; .1 * @CpuMsSinceWaitsCleared
												AND waiting_tasks_count &gt; 0)
									INSERT  INTO #BlitzResults
											( CheckID ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
											SELECT TOP 9
													 152 AS CheckID
													,240 AS Priority
													,'Wait Stats' AS FindingsGroup
													, CAST(ROW_NUMBER() OVER(ORDER BY os.wait_time_ms DESC) AS NVARCHAR(10)) + N' - ' + os.wait_type AS Finding
													,'http://BrentOzar.com/go/waits' AS URL
													, Details = CAST(CAST(SUM(os.wait_time_ms / 1000.0 / 60 / 60) OVER (PARTITION BY os.wait_type) AS NUMERIC(18,1)) AS NVARCHAR(20)) + N' hours of waits, ' +
													CAST(CAST((SUM(60.0 * os.wait_time_ms) OVER (PARTITION BY os.wait_type) ) / @MsSinceWaitsCleared  AS NUMERIC(18,1)) AS NVARCHAR(20)) + N' minutes average wait time per hour, ' + 
													/* CAST(CAST(
														100.* SUM(os.wait_time_ms) OVER (PARTITION BY os.wait_type) 
														/ (1. * SUM(os.wait_time_ms) OVER () )
														AS NUMERIC(18,1)) AS NVARCHAR(40)) + N'% of waits, ' + */
													CAST(CAST(
														100. * SUM(os.signal_wait_time_ms) OVER (PARTITION BY os.wait_type) 
														/ (1. * SUM(os.wait_time_ms) OVER ())
														AS NUMERIC(18,1)) AS NVARCHAR(40)) + N'% signal wait, ' + 
													CAST(SUM(os.waiting_tasks_count) OVER (PARTITION BY os.wait_type) AS NVARCHAR(40)) + N' waiting tasks, ' +
													CAST(CASE WHEN  SUM(os.waiting_tasks_count) OVER (PARTITION BY os.wait_type) &gt; 0
													THEN
														CAST(
															SUM(os.wait_time_ms) OVER (PARTITION BY os.wait_type)
																/ (1. * SUM(os.waiting_tasks_count) OVER (PARTITION BY os.wait_type)) 
															AS NUMERIC(18,1))
													ELSE 0 END AS NVARCHAR(40)) + N' ms average wait time.'
											FROM    os
											ORDER BY SUM(os.wait_time_ms / 1000.0 / 60 / 60) OVER (PARTITION BY os.wait_type) DESC;
									END /* IF EXISTS (SELECT * FROM sys.dm_os_wait_stats WHERE wait_time_ms &gt; 0 AND waiting_tasks_count &gt; 0) */

								/* If no waits were found, add a note about that */
								IF NOT EXISTS (SELECT * FROM #BlitzResults WHERE CheckID IN (107, 108, 109, 121, 152, 162))
								BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
										VALUES (153, 240, 'Wait Stats', 'No Significant Waits Detected', 'http://BrentOzar.com/go/waits', 'This server might be just sitting around idle, or someone may have cleared wait stats recently.');
								END
							END /* CheckID 152 */    

					END /* IF @CheckServerInfo = 1 */
			END /* IF ( ( SERVERPROPERTY('ServerName') NOT IN ( SELECT ServerName */


				/* Delete priorites they wanted to skip. */
				IF @IgnorePrioritiesAbove IS NOT NULL
					DELETE  #BlitzResults
					WHERE   [Priority] &gt; @IgnorePrioritiesAbove AND CheckID &lt;&gt; -1;

				IF @IgnorePrioritiesBelow IS NOT NULL
					DELETE  #BlitzResults
					WHERE   [Priority] &lt; @IgnorePrioritiesBelow AND CheckID &lt;&gt; -1;

				/* Delete checks they wanted to skip. */
				IF @SkipChecksTable IS NOT NULL
					BEGIN
						DELETE  FROM #BlitzResults
						WHERE   DatabaseName IN ( SELECT    DatabaseName
												  FROM      #SkipChecks
												  WHERE CheckID IS NULL
												  AND (ServerName IS NULL OR ServerName = SERVERPROPERTY('ServerName')));
						DELETE  FROM #BlitzResults
						WHERE   CheckID IN ( SELECT    CheckID
												  FROM      #SkipChecks
												  WHERE DatabaseName IS NULL
												  AND (ServerName IS NULL OR ServerName = SERVERPROPERTY('ServerName')));
						DELETE r FROM #BlitzResults r
							INNER JOIN #SkipChecks c ON r.DatabaseName = c.DatabaseName and r.CheckID = c.CheckID
												  AND (ServerName IS NULL OR ServerName = SERVERPROPERTY('ServerName'));
					END

				/* Add summary mode */
				IF @SummaryMode &gt; 0
					BEGIN
					UPDATE #BlitzResults
					  SET Finding = br.Finding + ' (' + CAST(brTotals.recs AS NVARCHAR(20)) + ')'
					  FROM #BlitzResults br
						INNER JOIN (SELECT FindingsGroup, Finding, Priority, COUNT(*) AS recs FROM #BlitzResults GROUP BY FindingsGroup, Finding, Priority) brTotals ON br.FindingsGroup = brTotals.FindingsGroup AND br.Finding = brTotals.Finding AND br.Priority = brTotals.Priority
						WHERE brTotals.recs &gt; 1;

					DELETE br
					  FROM #BlitzResults br
					  WHERE EXISTS (SELECT * FROM #BlitzResults brLower WHERE br.FindingsGroup = brLower.FindingsGroup AND br.Finding = brLower.Finding AND br.Priority = brLower.Priority AND br.ID &gt; brLower.ID);

					END

				/* Add credits for the nice folks who put so much time into building and maintaining this for free: */
				INSERT  INTO #BlitzResults
						( CheckID ,
						  Priority ,
						  FindingsGroup ,
						  Finding ,
						  URL ,
						  Details
						)
				VALUES  ( -1 ,
						  255 ,
						  'Thanks!' ,
						  'From Your Community Volunteers' ,
						  'http://FirstResponderKit.org' ,
						  'We hope you found this tool useful.'
						);

				INSERT  INTO #BlitzResults
						( CheckID ,
						  Priority ,
						  FindingsGroup ,
						  Finding ,
						  URL ,
						  Details

						)
				VALUES  ( -1 ,
						  0 ,
						  'sp_Blitz ' + CAST(CONVERT(DATETIME, @VersionDate, 102) AS VARCHAR(100)),
						  'SQL Server First Responder Kit' ,
						  'http://FirstResponderKit.org/' ,
						  'To get help or add your own contributions, join us at http://FirstResponderKit.org.'

						);

				INSERT  INTO #BlitzResults
						( CheckID ,
						  Priority ,
						  FindingsGroup ,
						  Finding ,
						  URL ,
						  Details

						)
				SELECT 156 ,
						  254 ,
						  'Rundate' ,
						  GETDATE() ,
						  'http://FirstResponderKit.org/' ,
						  'Captain''s log: stardate something and something...';
						  
				IF @EmailRecipients IS NOT NULL
					BEGIN
					/* Database mail won't work off a local temp table. I'm not happy about this hacky workaround either. */
					IF (OBJECT_ID('tempdb..##BlitzResults', 'U') IS NOT NULL) DROP TABLE ##BlitzResults;
					SELECT * INTO ##BlitzResults FROM #BlitzResults;
					SET @query_result_separator = char(9);
					SET @StringToExecute = 'SET NOCOUNT ON;SELECT [Priority] , [FindingsGroup] , [Finding] , [DatabaseName] , [URL] ,  [Details] , CheckID FROM ##BlitzResults ORDER BY Priority , FindingsGroup, Finding, Details; SET NOCOUNT OFF;';
					SET @EmailSubject = 'sp_Blitz Results for ' + @@SERVERNAME;
					SET @EmailBody = 'sp_Blitz ' + CAST(CONVERT(DATETIME, @VersionDate, 102) AS VARCHAR(100)) + '. http://FirstResponderKit.org';
					IF @EmailProfile IS NULL
						EXEC msdb.dbo.sp_send_dbmail
							@recipients = @EmailRecipients,
							@subject = @EmailSubject,
							@body = @EmailBody,
							@query_attachment_filename = 'sp_Blitz-Results.csv',
							@attach_query_result_as_file = 1,
							@query_result_header = 1,
							@query_result_width = 32767,
							@append_query_error = 1,
							@query_result_no_padding = 1,
							@query_result_separator = @query_result_separator,
							@query = @StringToExecute;
					ELSE
						EXEC msdb.dbo.sp_send_dbmail
							@profile_name = @EmailProfile,
							@recipients = @EmailRecipients,
							@subject = @EmailSubject,
							@body = @EmailBody,
							@query_attachment_filename = 'sp_Blitz-Results.csv',
							@attach_query_result_as_file = 1,
							@query_result_header = 1,
							@query_result_width = 32767,
							@append_query_error = 1,
							@query_result_no_padding = 1,
							@query_result_separator = @query_result_separator,
							@query = @StringToExecute;
					IF (OBJECT_ID('tempdb..##BlitzResults', 'U') IS NOT NULL) DROP TABLE ##BlitzResults;
				END

				/* Checks if @OutputServerName is populated with a valid linked server, and that the database name specified is valid */
				DECLARE @ValidOutputServer BIT
				DECLARE @ValidOutputLocation BIT
				DECLARE @LinkedServerDBCheck NVARCHAR(2000)
				DECLARE @ValidLinkedServerDB INT
				DECLARE @tmpdbchk table (cnt int)
				IF @OutputServerName IS NOT NULL
					BEGIN
						IF EXISTS (SELECT server_id FROM sys.servers WHERE QUOTENAME([name]) = @OutputServerName)
							BEGIN
								SET @LinkedServerDBCheck = 'SELECT 1 WHERE EXISTS (SELECT * FROM '+@OutputServerName+'.master.sys.databases WHERE QUOTENAME([name]) = '''+@OutputDatabaseName+''')'
								INSERT INTO @tmpdbchk EXEC sys.sp_executesql @LinkedServerDBCheck
								SET @ValidLinkedServerDB = (SELECT COUNT(*) FROM @tmpdbchk)
								IF (@ValidLinkedServerDB &gt; 0)
									BEGIN
										SET @ValidOutputServer = 1
										SET @ValidOutputLocation = 1
									END
								ELSE
									RAISERROR('The specified database was not found on the output server', 16, 0)
							END
						ELSE
							BEGIN
								RAISERROR('The specified output server was not found', 16, 0)
							END
					END
				ELSE
					BEGIN
						IF @OutputDatabaseName IS NOT NULL
							AND @OutputSchemaName IS NOT NULL
							AND @OutputTableName IS NOT NULL
							AND EXISTS ( SELECT *
								 FROM   sys.databases
								 WHERE  QUOTENAME([name]) = @OutputDatabaseName)
							BEGIN
								SET @ValidOutputLocation = 1
							END
						ELSE IF @OutputDatabaseName IS NOT NULL
							AND @OutputSchemaName IS NOT NULL
							AND @OutputTableName IS NOT NULL
							AND NOT EXISTS ( SELECT *
								 FROM   sys.databases
								 WHERE  QUOTENAME([name]) = @OutputDatabaseName)
							BEGIN
								RAISERROR('The specified output database was not found on this server', 16, 0)
							END
						ELSE
							BEGIN
								SET @ValidOutputLocation = 0 
							END
					END

				/* @OutputTableName lets us export the results to a permanent table */
				IF @ValidOutputLocation = 1
					BEGIN
						SET @StringToExecute = 'USE '
							+ @OutputDatabaseName
							+ '; IF EXISTS(SELECT * FROM '
							+ @OutputDatabaseName
							+ '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
							+ @OutputSchemaName
							+ ''') AND NOT EXISTS (SELECT * FROM '
							+ @OutputDatabaseName
							+ '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
							+ @OutputSchemaName + ''' AND QUOTENAME(TABLE_NAME) = '''
							+ @OutputTableName + ''') CREATE TABLE '
							+ @OutputSchemaName + '.'
							+ @OutputTableName
							+ ' (ID INT IDENTITY(1,1) NOT NULL,
								ServerName NVARCHAR(128),
								CheckDate DATETIMEOFFSET,
								Priority TINYINT ,
								FindingsGroup VARCHAR(50) ,
								Finding VARCHAR(200) ,
								DatabaseName NVARCHAR(128),
								URL VARCHAR(200) ,
								Details NVARCHAR(4000) ,
								QueryPlan [XML] NULL ,
								QueryPlanFiltered [NVARCHAR](MAX) NULL,
								CheckID INT ,
								CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
						IF @ValidOutputServer = 1
							BEGIN
								SET @StringToExecute = REPLACE(@StringToExecute,''''+@OutputSchemaName+'''',''''''+@OutputSchemaName+'''''')
								SET @StringToExecute = REPLACE(@StringToExecute,''''+@OutputTableName+'''',''''''+@OutputTableName+'''''')
								SET @StringToExecute = REPLACE(@StringToExecute,'[XML]','[NVARCHAR](MAX)')
								EXEC('EXEC('''+@StringToExecute+''') AT ' + @OutputServerName);
							END   
						ELSE
							BEGIN
								EXEC(@StringToExecute);
							END
						IF @ValidOutputServer = 1
							BEGIN
								SET @StringToExecute = N' IF EXISTS(SELECT * FROM '
								+ @OutputServerName + '.'
								+ @OutputDatabaseName
								+ '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
								+ @OutputSchemaName + ''') INSERT '
								+ @OutputServerName + '.'
								+ @OutputDatabaseName + '.'
								+ @OutputSchemaName + '.'
								+ @OutputTableName
								+ ' (ServerName, CheckDate, CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered) SELECT '''
								+ CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
								+ ''', SYSDATETIMEOFFSET(), CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, CAST(QueryPlan AS NVARCHAR(MAX)), QueryPlanFiltered FROM #BlitzResults ORDER BY Priority , FindingsGroup , Finding , Details';

								EXEC(@StringToExecute);
							END   
						ELSE
							BEGIN
								SET @StringToExecute = N' IF EXISTS(SELECT * FROM '
								+ @OutputDatabaseName
								+ '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
								+ @OutputSchemaName + ''') INSERT '
								+ @OutputDatabaseName + '.'
								+ @OutputSchemaName + '.'
								+ @OutputTableName
								+ ' (ServerName, CheckDate, CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered) SELECT '''
								+ CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
								+ ''', SYSDATETIMEOFFSET(), CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered FROM #BlitzResults ORDER BY Priority , FindingsGroup , Finding , Details';
								
								EXEC(@StringToExecute);
							END
					END
				ELSE IF (SUBSTRING(@OutputTableName, 2, 2) = '##')
					BEGIN
						IF @ValidOutputServer = 1
							BEGIN
								RAISERROR('Due to the nature of temporary tables, outputting to a linked server requires a permanent table.', 16, 0)
							END
						ELSE
							BEGIN
								SET @StringToExecute = N' IF (OBJECT_ID(''tempdb..'
									+ @OutputTableName
									+ ''') IS NOT NULL) DROP TABLE ' + @OutputTableName + ';'
									+ 'CREATE TABLE '
									+ @OutputTableName
									+ ' (ID INT IDENTITY(1,1) NOT NULL,
										ServerName NVARCHAR(128),
										CheckDate DATETIMEOFFSET,
										Priority TINYINT ,
										FindingsGroup VARCHAR(50) ,
										Finding VARCHAR(200) ,
										DatabaseName NVARCHAR(128),
										URL VARCHAR(200) ,
										Details NVARCHAR(4000) ,
										QueryPlan [XML] NULL ,
										QueryPlanFiltered [NVARCHAR](MAX) NULL,
										CheckID INT ,
										CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
									+ ' INSERT '
									+ @OutputTableName
									+ ' (ServerName, CheckDate, CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered) SELECT '''
									+ CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
									+ ''', SYSDATETIMEOFFSET(), CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered FROM #BlitzResults ORDER BY Priority , FindingsGroup , Finding , Details';
							
									EXEC(@StringToExecute);
							END
					END
				ELSE IF (SUBSTRING(@OutputTableName, 2, 1) = '#')
					BEGIN
						RAISERROR('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0)
					END


				DECLARE @separator AS VARCHAR(1);
				IF @OutputType = 'RSV'
					SET @separator = CHAR(31);
				ELSE
					SET @separator = ',';

				IF @OutputType = 'COUNT'
					BEGIN
						SELECT  COUNT(*) AS Warnings
						FROM    #BlitzResults
					END
				ELSE
					IF @OutputType IN ( 'CSV', 'RSV' )
						BEGIN

							SELECT  Result = CAST([Priority] AS NVARCHAR(100))
									+ @separator + CAST(CheckID AS NVARCHAR(100))
									+ @separator + COALESCE([FindingsGroup],
															'(N/A)') + @separator
									+ COALESCE([Finding], '(N/A)') + @separator
									+ COALESCE(DatabaseName, '(N/A)') + @separator
									+ COALESCE([URL], '(N/A)') + @separator
									+ COALESCE([Details], '(N/A)')
							FROM    #BlitzResults
							ORDER BY Priority ,
									FindingsGroup ,
									Finding ,
									DatabaseName ,
									Details;
						END
					ELSE IF @OutputXMLasNVARCHAR = 1 AND @OutputType &lt;&gt; 'NONE'
						BEGIN
							SELECT  [Priority] ,
									[FindingsGroup] ,
									[Finding] ,
									[DatabaseName] ,
									[URL] ,
									[Details] ,
									CAST([QueryPlan] AS NVARCHAR(MAX)) AS QueryPlan,
									[QueryPlanFiltered] ,
									CheckID
							FROM    #BlitzResults
							ORDER BY Priority ,
									FindingsGroup ,
									Finding ,
									DatabaseName ,
									Details;
						END
					ELSE IF @OutputType = 'MARKDOWN'
						BEGIN
							WITH Results AS (SELECT row_number() OVER (ORDER BY Priority, FindingsGroup, Finding, DatabaseName, Details) AS rownum, * 
												FROM #BlitzResults
												WHERE Priority &gt; 0 AND Priority &lt; 255 AND FindingsGroup IS NOT NULL AND Finding IS NOT NULL
												AND FindingsGroup &lt;&gt; 'Security' /* Specifically excluding security checks for public exports */)
							SELECT 
								CASE 
									WHEN r.Priority &lt;&gt; COALESCE(rPrior.Priority, 0) OR r.FindingsGroup &lt;&gt; rPrior.FindingsGroup  THEN @crlf + N'**Priority ' + CAST(COALESCE(r.Priority,N'') AS NVARCHAR(5)) + N': ' + COALESCE(r.FindingsGroup,N'') + N'**:' + @crlf + @crlf 
									ELSE N'' 
								END
								+ CASE WHEN r.Finding &lt;&gt; COALESCE(rPrior.Finding,N'') AND r.Finding &lt;&gt; rNext.Finding THEN N'- ' + COALESCE(r.Finding,N'') + N' ' + COALESCE(r.DatabaseName, N'') + N' - ' + COALESCE(r.Details,N'') + @crlf
									   WHEN r.Finding &lt;&gt; COALESCE(rPrior.Finding,N'') AND r.Finding = rNext.Finding AND r.Details = rNext.Details THEN N'- ' + COALESCE(r.Finding,N'') + N' - ' + COALESCE(r.Details,N'') + @crlf + @crlf + N'    * ' + COALESCE(r.DatabaseName, N'') + @crlf
									   WHEN r.Finding &lt;&gt; COALESCE(rPrior.Finding,N'') AND r.Finding = rNext.Finding THEN N'- ' + COALESCE(r.Finding,N'') + @crlf + CASE WHEN r.DatabaseName IS NULL THEN N'' ELSE  N'    * ' + COALESCE(r.DatabaseName,N'') END + CASE WHEN r.Details &lt;&gt; rPrior.Details THEN N' - ' + COALESCE(r.Details,N'') + @crlf ELSE '' END
									   ELSE CASE WHEN r.DatabaseName IS NULL THEN N'' ELSE  N'    * ' + COALESCE(r.DatabaseName,N'') END + CASE WHEN r.Details &lt;&gt; rPrior.Details THEN N' - ' + COALESCE(r.Details,N'') + @crlf ELSE N'' + @crlf END 
								END + @crlf 
							  FROM Results r
							  LEFT OUTER JOIN Results rPrior ON r.rownum = rPrior.rownum + 1
							  LEFT OUTER JOIN Results rNext ON r.rownum = rNext.rownum - 1
							ORDER BY r.rownum FOR XML PATH(N'');
						END
					ELSE IF @OutputType &lt;&gt; 'NONE'
						BEGIN
							SELECT  [Priority] ,
									[FindingsGroup] ,
									[Finding] ,
									[DatabaseName] ,
									[URL] ,
									[Details] ,
									[QueryPlan] ,
									[QueryPlanFiltered] ,
									CheckID
							FROM    #BlitzResults
							ORDER BY Priority ,
									FindingsGroup ,
									Finding ,
									DatabaseName ,
									Details;
						END

				DROP TABLE #BlitzResults;

				IF @OutputProcedureCache = 1
				AND @CheckProcedureCache = 1
					SELECT TOP 20
							total_worker_time / execution_count AS AvgCPU ,
							total_worker_time AS TotalCPU ,
							CAST(ROUND(100.00 * total_worker_time
									   / ( SELECT   SUM(total_worker_time)
										   FROM     sys.dm_exec_query_stats
										 ), 2) AS MONEY) AS PercentCPU ,
							total_elapsed_time / execution_count AS AvgDuration ,
							total_elapsed_time AS TotalDuration ,
							CAST(ROUND(100.00 * total_elapsed_time
									   / ( SELECT   SUM(total_elapsed_time)
										   FROM     sys.dm_exec_query_stats
										 ), 2) AS MONEY) AS PercentDuration ,
							total_logical_reads / execution_count AS AvgReads ,
							total_logical_reads AS TotalReads ,
							CAST(ROUND(100.00 * total_logical_reads
									   / ( SELECT   SUM(total_logical_reads)
										   FROM     sys.dm_exec_query_stats
										 ), 2) AS MONEY) AS PercentReads ,
							execution_count ,
							CAST(ROUND(100.00 * execution_count
									   / ( SELECT   SUM(execution_count)
										   FROM     sys.dm_exec_query_stats
										 ), 2) AS MONEY) AS PercentExecutions ,
							CASE WHEN DATEDIFF(mi, creation_time,
											   qs.last_execution_time) = 0 THEN 0
								 ELSE CAST(( 1.00 * execution_count / DATEDIFF(mi,
																  creation_time,
																  qs.last_execution_time) ) AS MONEY)
							END AS executions_per_minute ,
							qs.creation_time AS plan_creation_time ,
							qs.last_execution_time ,
							text ,
							text_filtered ,
							query_plan ,
							query_plan_filtered ,
							sql_handle ,
							query_hash ,
							plan_handle ,
							query_plan_hash
					FROM    #dm_exec_query_stats qs
					ORDER BY CASE UPPER(@CheckProcedureCacheFilter)
							   WHEN 'CPU' THEN total_worker_time
							   WHEN 'READS' THEN total_logical_reads
							   WHEN 'EXECCOUNT' THEN execution_count
							   WHEN 'DURATION' THEN total_elapsed_time
							   ELSE total_worker_time
							 END DESC

	END /* ELSE -- IF @OutputType = 'SCHEMA' */

    SET NOCOUNT OFF;
GO

/*
--Sample execution call with the most common parameters:
EXEC [dbo].[sp_Blitz]
    @CheckUserDatabaseObjects = 1 ,
    @CheckProcedureCache = 0 ,
    @OutputType = 'TABLE' ,
    @OutputProcedureCache = 0 ,
    @CheckProcedureCacheFilter = NULL,
    @CheckServerInfo = 1
*/
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>sp_BlitzTrace____script</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>sp_BlitzTrace____script</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>SET ANSI_NULLS ON;
SET ANSI_PADDING ON;
SET ANSI_WARNINGS ON;
SET ARITHABORT ON;
SET CONCAT_NULL_YIELDS_NULL ON;
SET QUOTED_IDENTIFIER ON;
SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;
GO
IF OBJECT_ID('dbo.sp_BlitzTrace') IS NOT NULL
    DROP PROCEDURE dbo.sp_BlitzTrace
GO
CREATE PROCEDURE dbo.sp_BlitzTrace
    @Debug BIT = 0 , /* 1 prints the statement and won't execute it */
    @SessionId INT = NULL ,
    @Action VARCHAR(5) = NULL ,  /* 'start', 'read', 'stop', 'drop'*/
    @TargetPath VARCHAR(528) = NULL,  /* Required for 'start'. 'Read' will look for a running sp_BlitzTrace session if not specified.*/
    @TraceRecompiles BIT = 1,
    @TraceObjectCreates BIT = 1,
    @TraceParallelism BIT = 1,
    @TraceSortWarnings BIT = 1,
    @TraceStatements BIT = 0,
    @MaxFileSizeMB INT = 256,
    @TraceExecutionPlansAndKillMyPerformance BIT = 0, /* Non-production environments only */
    @MaxRolloverFiles INT = 4,
    @MaxDispatchLatencySeconds INT = 5 /* 0 is unlimited! */,
    @Help TINYINT = 0

WITH RECOMPILE
AS
IF @Help = 1 PRINT '
/*
sp_BlitzTrace from http://FirstResponderKit.org

Description: Starts, stops, and reads Extended Events traces.

--List running sessions
exec sp_BlitzTrace @Action=''start'';

--Start a trace for a session. You specify the @SessionID and @TargetPath
exec sp_BlitzTrace @SessionId=52, @TargetPath=''S:\XEvents\Traces\'', @Action=''start'';

--Stop a session
exec sp_BlitzTrace @Action=''stop'';

--Read the results. You can move the files to another server and read there by specifying a @TargetPath.
exec sp_BlitzTrace @Action=''read'';

--Drop the session. This does NOT delete files created in @TargetPath.
exec sp_BlitzTrace @Action=''drop'';

To learn more, visit http://FirstResponderKit.org where you can download new
versions for free, watch training videos on how it works, get more info on
the findings, contribute your own code, and more.

Known limitations of this version:
 - Extended Events can be hard.

Unknown limitations of this version:
 - Probably a lot. This is one of our lesser-tested scripts.

Changes in v1.0 - 2016/06/26
 - Switched to MIT licensing.
 - Added @Help parameter.

MIT License

Copyright (c) 2016 Brent Ozar Unlimited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
'

    DECLARE @nl NVARCHAR(2) = NCHAR(13) + NCHAR(10) ;

    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    SET XACT_ABORT ON;

BEGIN TRY

    DECLARE @msg NVARCHAR(MAX);
    DECLARE @rowcount INT;
    DECLARE @v decimal(6,2);
    DECLARE @build int;
    DECLARE @datestamp VARCHAR(30);
    DECLARE @TargetPathFull NVARCHAR(MAX);
    DECLARE @filepathXML XML;
    DECLARE @filepath VARCHAR(1024);
    DECLARE @traceexists BIT = 0;
    DECLARE @tracerunning BIT = 0;



    /* Validate parameters */
    SET @msg = CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Validatin'' parameters.'
    RAISERROR (@msg,0,1) WITH NOWAIT;

    IF @Action NOT IN (N'start', N'read', N'stop', N'drop')  OR @Action is NULL
    BEGIN
        RAISERROR (N'You need to specify a valid @Action for sp_BlitzTrace: ''start'', ''read'', ''stop'', or ''drop''.',16,1) WITH NOWAIT;
    END

    IF @Action = N'start' AND @SessionId IS NULL
    BEGIN
        SELECT ses.session_id, con.last_read, con.last_write, ses.login_name, ses.host_name, ses.program_name,
            con.connect_time, con.protocol_type, con.encrypt_option,
            con.num_reads, con.num_writes, con.client_net_address,
            req.status, req.command, req.wait_type, req.last_wait_type, req.open_transaction_count
        FROM sys.dm_exec_sessions as ses
        JOIN sys.dm_exec_connections AS con ON
            con.session_id=ses.session_id
        LEFT JOIN sys.dm_exec_requests AS req ON
            con.session_id=req.session_id
        WHERE
            ses.session_id &lt;&gt; @@SPID
        ORDER BY last_read DESC

        RAISERROR (N'sp_BlitzTrace watches just one session, so you have to specify @SessionId. Check out the session list above for some ideas.',16,1) WITH NOWAIT;
    END

    IF @MaxDispatchLatencySeconds &gt; 99
    BEGIN
        RAISERROR (N'@MaxDispatchLatencySeconds must be 99 or less. 5 is the default. 0 is unlimited latency.',16,1) WITH NOWAIT;
    END

    IF @MaxFileSizeMB &gt; 9999
    BEGIN
        RAISERROR (N'@MaxFileSizeMB must be 9999 or smaller - 256MB is the default.',16,1) WITH NOWAIT;
    END

    IF @MaxRolloverFiles &gt; 99
    BEGIN
        RAISERROR (N'@MaxRolloverFiles must be 99 or smaller. 4 is the default.',16,1) WITH NOWAIT;
    END

    IF @TargetPath IS NULL AND @Action = N'start'
    BEGIN
        RAISERROR (N'You gotta give a valid @TargetPath for ''start''.',16,1) WITH NOWAIT;
    END

    IF @TargetPath IS NOT NULL AND @Action=N'start' AND RIGHT(@TargetPath, 1) &lt;&gt; N'\'
    BEGIN
        RAISERROR (N'@TargetPath must be a directory ending in ''\'', like: ''S:\Xevents\''',16,1) WITH NOWAIT;
    END


    IF @TargetPath IS NOT NULL AND @Action='read' AND  ( RIGHT(@TargetPath, 1) &lt;&gt; '\' AND RIGHT(@TargetPath, 4) &lt;&gt; '.xel')
    BEGIN
        RAISERROR (N'To read, @TargetPath must be a directory ending in ''\'', like: ''S:\XEvents\'', or a file ending in .xel, like ''S:\XEvents\sp_BlitzTrace*.xel''',16,1) WITH NOWAIT;
    END

    /* Validate transaction state */
    SET @msg = CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Validatin'' transaction state.'
    RAISERROR (@msg,0,1) WITH NOWAIT;
    IF @@TRANCOUNT &gt; 0
    BEGIN
        RAISERROR (N'@@TRANCOUNT &gt; 0 not supported',16,1) WITH NOWAIT;
    END

    /* Check version */
    SET @msg = CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Determining SQL Server version.'
    RAISERROR (@msg,0,1) WITH NOWAIT;

    SELECT @v = SUBSTRING(CAST(SERVERPROPERTY('ProductVersion') as NVARCHAR(128)), 1,CHARINDEX('.', CAST(SERVERPROPERTY('ProductVersion') as NVARCHAR(128))) + 1 )

    IF @v &lt; N'11'
    BEGIN
        SET @msg = N'Sad news: most the events sp_BlitzTrace uses are only in SQL Server 2012 and higher-- so it''s not supported on SQL 2008/R2.'
        RAISERROR (@msg,16,1) WITH NOWAIT;
        RETURN;
    END


    /* Get current trace status */
    SELECT
        @traceexists = (CASE WHEN (s.name IS NULL) THEN 0 ELSE 1 END),
        @tracerunning = (CASE WHEN (r.create_time IS NULL) THEN 0 ELSE 1 END)
    FROM sys.server_event_sessions AS s
    LEFT OUTER JOIN sys.dm_xe_sessions AS r ON r.name = s.name
    WHERE s.name=N'sp_BlitzTrace'


    /* We use this to filter sp_BlitzTrace activity out of the results, */
    /* in case you're tracing your own session. */
    /* That's just to make the results less confusing */
    DECLARE @context VARBINARY(128);
    SET @context=CAST('sp_BlitzTrace IS THE BEST' as binary);
    SET CONTEXT_INFO @context;

    IF @Action = N'start'
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Creating extended events trace.'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        IF @traceexists = 1
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- A trace named sp_BlitzTrace already exists'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            IF @tracerunning=1
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- sp_BlitzTrace is running, so stopping it before we recreate: ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = STOP;'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = STOP;

                SET @tracerunning=0;
            END

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Dropping the trace: DROP EVENT SESSION sp_BlitzTrace ON SERVER; '
            RAISERROR (@msg,0,1) WITH NOWAIT;

            DROP EVENT SESSION sp_BlitzTrace ON SERVER;

            SET @traceexists=0;

        END

        IF @traceexists = 0
        BEGIN
            SELECT @datestamp = REPLACE(REPLACE( CONVERT(VARCHAR(26),getdate(),126),':','-'),'.','')
            SET @TargetPathFull=@TargetPath + N'sp_BlitzTrace-' + @datestamp

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Target path = ' + @TargetPathFull;
            RAISERROR (@msg,0,1) WITH NOWAIT;


            DECLARE @dsql NVARCHAR(MAX);
            DECLARE @dsql1 NVARCHAR(MAX)=
                N'CREATE EVENT SESSION sp_BlitzTrace ON SERVER
                ' + case @TraceStatements when 1 then + N'
                ADD EVENT sqlserver.sp_statement_completed (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ADD EVENT sqlserver.sql_statement_completed (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END + case @TraceSortWarnings when 1 then N'
                ADD EVENT sqlserver.sort_warning (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END + case @TraceParallelism when 1 then + N'
                ADD EVENT sqlserver.degree_of_parallelism (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END + N'
                ' + case @TraceObjectCreates when 1 then + N'
                ADD EVENT sqlserver.object_created (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END;

            DECLARE @dsql2 NVARCHAR(MAX)=
                N'ADD EVENT sqlserver.sql_batch_completed (
                    ACTION(sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' + case @TraceRecompiles when 1 then + N'
                ADD EVENT sqlserver.sql_statement_recompile (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END
                + case @TraceExecutionPlansAndKillMyPerformance when 1 then + N'
                ADD EVENT sqlserver.query_post_execution_showplan (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END + N'
                ADD EVENT sqlserver.rpc_completed (
                    ACTION(sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N')))
                ADD TARGET package0.event_file(SET filename=''' + @TargetPathFull + N''',
                    MAX_FILE_SIZE=(' + CAST(@MaxFileSizeMB AS VARCHAR(4)) + N'),
                    MAX_ROLLOVER_FILES = ' + CAST(@MaxRolloverFiles as VARCHAR(2)) + N')
                WITH (
                    MAX_MEMORY = 128 MB,
                    EVENT_RETENTION_MODE = ALLOW_MULTIPLE_EVENT_LOSS,
                    MAX_DISPATCH_LATENCY = ' + CAST(@MaxDispatchLatencySeconds AS NVARCHAR(2)) + N' SECONDS,
                    MEMORY_PARTITION_MODE=NONE,
                    TRACK_CAUSALITY=OFF,
                    STARTUP_STATE=OFF)';

            SET @dsql=@dsql1 + @dsql2;

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Creating trace with dynamic SQL. I REGRET NOTHING!!!'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            IF @Debug=1
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Debug mode, printing but not executing.'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                RAISERROR (@nl,0,1) WITH NOWAIT;

                RAISERROR (@dsql1,0,0) WITH NOWAIT;
                RAISERROR (@dsql2,0,0) WITH NOWAIT;
            END
            ELSE
            BEGIN

                EXEC sp_executesql @dsql;

            END
            SET @traceexists = 1;
        END

        IF @tracerunning = 0
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = START;'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            IF @Debug=0
            BEGIN
                ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = START;

                SET @tracerunning = 1;
            END
            ELSE
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- @Debug=1, not starting trace;'
                RAISERROR (@msg,0,1) WITH NOWAIT;
            END
        END
    END
    IF @Action = 'read'
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Reading, processing, and reporting.'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        IF @traceexists = 0
        BEGIN
            SET @filepath=@TargetPath + N'*.xel';

        END

        /* Figure out the file name for current trace, if it's running */
        if @tracerunning=1
        BEGIN
            SELECT TOP 1 @filepathXML= x.target_data
            FROM sys.dm_xe_sessions as se
            JOIN sys.dm_xe_session_targets as t on
                se.address=t.event_session_address
            CROSS APPLY (SELECT cast(t.target_data as XML) AS target_data) as x
            WHERE se.name=N'sp_BlitzTrace'
            OPTION (RECOMPILE);

            SELECT @filepath=CAST(@filepathXML.query('data(EventFileTarget/File/@name)') AS VARCHAR(1024))
        END
        ELSE /* Figure out the file path for the trace if exists and isn't running */
        BEGIN
            SELECT TOP 1 @filepath=CAST(f.value AS VARCHAR(1024)) + N'*.xel'
            FROM sys.server_event_sessions AS ses
            LEFT OUTER JOIN sys.dm_xe_sessions AS running ON
                running.name = ses.name
            JOIN sys.server_event_session_targets AS t ON
                ses.event_session_id = t.event_session_id
                and t.package = 'package0'
                and t.name='event_file'
                and ses.name='sp_BlitzTrace'
            JOIN sys.dm_xe_objects AS o ON
                t.name = o.name
                AND o.object_type='target'
            JOIN sys.dm_xe_object_columns AS c ON
                t.name = c.object_name AND
                c.column_type = 'customizable' AND
                c.name='filename'
            JOIN sys.server_event_session_fields AS f ON
                t.event_session_id = f.event_session_id AND
                t.target_id = f.object_id
                AND c.name = f.name
        END

        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Using filepath: ' + @filepath
        RAISERROR (@msg,0,1) WITH NOWAIT;

        IF @Debug = 0
        BEGIN
            CREATE TABLE #sp_BlitzTraceXML (
                event_data XML NOT NULL
            );

            CREATE TABLE #sp_BlitzTraceEvents (
                event_time DATETIME2 NOT NULL,
                event_type NVARCHAR(256) NOT NULL,
                batch_text VARCHAR(MAX) NULL,
                sql_text VARCHAR(MAX) NULL,
                [statement] VARCHAR(MAX) NULL,
                duration_micros INT NULL,
                cpu_micros INT NULL,
                physical_reads INT NULL,
                logical_reads INT NULL,
                writes INT NULL,
                row_count INT NULL,
                result NVARCHAR(256) NULL,
                dop_statement_type SYSNAME NULL,
                dop INT NULL,
                workspace_memory_grant_kb INT NULL,
                object_id INT NULL,
                object_type sysname NULL,
                object_name sysname NULL,
                ddl_phase sysname NULL,
                recompile_cause sysname NULL,
                sort_warning_type VARCHAR(256) NULL,
                query_operation_node_id INT NULL,
                query_hash varchar(256) NULL,
                query_plan_hash varchar(256) NULL,
                estimated_cost bigint NULL,
                [showplan_xml] XML NULL,
                context_info sysname NULL,
                event_data XML NOT NULL
            )

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Populating #sp_BlitzTraceXML...'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            INSERT #sp_BlitzTraceXML (event_data)
            SELECT
                x.event_data
            FROM  sys.fn_xe_file_target_read_file(@filepath,null,null,null) as xet
            CROSS APPLY (SELECT CAST(event_data AS XML) AS event_data) as x
            OUTER APPLY x.event_data.nodes('//event') AS y(n) OPTION (RECOMPILE);

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Started populating #sp_BlitzTraceEvents...'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            INSERT #sp_BlitzTraceEvents (event_time, event_type, batch_text, sql_text, [statement], duration_micros, cpu_micros, physical_reads,
            logical_reads, writes, row_count, result, dop_statement_type, dop, workspace_memory_grant_kb, object_id, object_type,
            object_name, ddl_phase, recompile_cause, sort_warning_type, query_operation_node_id, query_hash, query_plan_hash,
            estimated_cost, [showplan_xml], context_info, event_data)
            SELECT
                DATEADD(mi, DATEDIFF(mi, GETUTCDATE(), CURRENT_TIMESTAMP), n.value('@timestamp', 'datetime2')) AS event_time,
                n.value('@name', 'NVARCHAR(max)') AS event_type,
                n.value('(data[@name="batch_text"]/value)[1]', 'varchar(max)') AS batch_text,
                n.value('(action[@name="sql_text"]/value)[1]', 'varchar(max)') AS sql_text,
                n.value('(data[@name="statement"]/value)[1]', 'varchar(max)') AS [statement],
                n.value('(data[@name="duration"]/value)[1]', 'int') AS duration_micros,
                n.value('(data[@name="cpu_time"]/value)[1]', 'int') AS cpu_micros,
                n.value('(data[@name="physical_reads"]/value)[1]', 'int') AS physical_reads,
                n.value('(data[@name="logical_reads"]/value)[1]', 'int') AS logical_reads,
                n.value('(data[@name="writes"]/value)[1]', 'int') AS writes,
                n.value('(data[@name="row_count"]/value)[1]', 'int') AS row_count,
                n.value('(data[@name="result"]/text)[1]', 'varchar(256)') AS result,

                /* Parallelism */
                n.value('(data[@name="statement_type"]/text)[1]', 'varchar(256)') AS dop_statement_type,
                n.value('(data[@name="dop"]/value)[1]', 'int') AS dop,
                n.value('(data[@name="workspace_memory_grant_kb"]/value)[1]', 'bigint') AS workspace_memory_grant_kb,

                /* Object create comes in pairs, begin and end */
                n.value('(data[@name="object_id"]/value)[1]', 'int') AS [object_id],
                n.value('(data[@name="object_type"]/value)[1]', 'varchar(256)') AS object_type,
                n.value('(data[@name="object_name"]/value)[1]', 'varchar(256)') AS [object_name],
                n.value('(data[@name="ddl_phase"]/value)[1]', 'varchar(256)') AS ddl_phase,

                /* Recompiles */
                n.value('(data[@name="recompile_cause"]/text)[1]', 'varchar(256)') AS recompile_cause,

                /* tempdb spills */
                n.value('(data[@name="sort_warning_type"]/text)[1]', 'varchar(256)') AS sort_warning_type,
                n.value('(data[@name="query_operation_node_id"]/value)[1]', 'varchar(256)') AS query_operation_node_id,

                /* query hash and query plan hash */
                n.value('(action[@name="query_hash"]/value)[1]', 'varchar(256)') AS query_hash,
                n.value('(action[@name="query_plan_hash"]/value)[1]', 'varchar(256)') AS query_plan_hash,

                /* actual execution plan */
                n.value('(data[@name="estimated_cost"]/value)[1]', 'bigint') AS estimated_cost,
                n.query('(data[@name="showplan_xml"]/value/*)[1]') AS [showplan_xml],

                /* Context info, for filtering */
                n.value('(action[@name="context_info"]/value)[1]', 'VARCHAR(MAX)') AS [context_info],
                x.event_data as event_data
            FROM #sp_BlitzTraceXML AS xet
            CROSS APPLY (SELECT CAST(xet.event_data AS XML) AS event_data) as x
            OUTER APPLY x.event_data.nodes('//event') AS y(n)
            OPTION (RECOMPILE);

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Finished populating #sp_BlitzTraceEvents...'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            SET @rowcount=@@ROWCOUNT;

            IF @rowcount = 0
            BEGIN
                RAISERROR('No rows found in the trace for these events for your session id',0,1) WITH NOWAIT;
            END
            ELSE
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- ' + CAST(@rowcount AS NVARCHAR(20)) + N' rows inserted into #sp_BlitzTraceEvents.'
                RAISERROR (@msg,0,1) WITH NOWAIT;
            END

            CREATE CLUSTERED INDEX cx_spBlitzTrace on #sp_BlitzTraceEvents (event_type, event_time)

            DELETE FROM #sp_BlitzTraceEvents
            WHERE (@SessionId=@@SPID and [context_info] = '73705f426c69747a5472616365204953205448452042455354')
            OR PATINDEX('%sp_BlitzTrace%',batch_text) &lt;&gt; 0
            OR PATINDEX('%sp_BlitzTrace%',sql_text) &lt;&gt; 0
                OPTION (RECOMPILE);

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying sql_batch_completed, rpc_completed, sql_statement_completed, sp_statement_completed...'
            RAISERROR (@msg,0,1) WITH NOWAIT;
            /* sql_batch_completed, rpc_completed */
            SELECT
                event_time,
                event_type,
                batch_text,
                [statement],
                sql_text,
                duration_micros,
                cpu_micros,
                physical_reads,
                logical_reads,
                writes,
                row_count,
                result,
                query_hash,
                query_plan_hash,
                event_data
            FROM #sp_BlitzTraceEvents
            WHERE event_type in (N'sql_batch_completed',N'rpc_completed','sql_statement_completed', 'sp_statement_completed')
            ORDER BY 1;

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'degree_of_parallelism')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying parallelism and memory grant...'
                RAISERROR (@msg,0,1) WITH NOWAIT;
                /* parallelism and memory grant */
                SELECT
                    event_time,
                    event_type,
                    sql_text,
                    dop_statement_type,
                    dop,
                    workspace_memory_grant_kb,
                    query_hash,
                    query_plan_hash,
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'degree_of_parallelism'
                  and query_hash &lt;&gt; '0'
                ORDER BY 1;
            END

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'object_created')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying object_created ...'
                RAISERROR (@msg,0,1) WITH NOWAIT;
                /* object_created */
                SELECT
                    event_time,
                    event_type,
                    sql_text,
                    [object_id],
                    [object_name],
                    cpu_micros,
                    ddl_phase,
                    query_hash,
                    query_plan_hash,
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'object_created'
                ORDER BY 1;
            END

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'sql_statement_recompile')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying sql_statement_recompile ...'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                /* sql_statement_recompile */
                SELECT
                    event_time,
                    event_type,
                    sql_text,
                    recompile_cause,
                    query_hash,
                    query_plan_hash,
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'sql_statement_recompile'
                ORDER BY 1;
            END

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'sort_warning')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying sort_warning ...'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                /* sql_statement_recompile */
                SELECT
                    event_time,
                    event_type,
                    sort_warning_type,
                    query_operation_node_id,
                    query_hash,
                    query_plan_hash,
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'sort_warning'
                ORDER BY 1;
            END

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'query_post_execution_showplan')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying actual execution plans ...'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                /* sql_statement_recompile */
                SELECT
                    event_time,
                    estimated_cost,
                    [object_name],
                    sql_text,
                    [showplan_xml] as [hope_this_isn't_production],
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'query_post_execution_showplan'
                ORDER BY 1;
            END

        END
        ELSE /* We're in @Debug=1 mode */
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- @Debug=1, not reading sp_BlitzTrace Extended Events session files;'
            RAISERROR (@msg,0,1) WITH NOWAIT;
        END
    END

    IF @Action = 'stop'
    BEGIN
        IF @tracerunning = 1
        BEGIN
            IF @Debug = 0
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Stopping sp_BlitzTrace Extended Events session.'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = STOP;

                SET @tracerunning = 0;
            END
            ELSE /* @Debug=1 */
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- @Debug=1, sp_BlitzTrace Extended Events session is running but we are NOT stopping it;'
                RAISERROR (@msg,0,1) WITH NOWAIT;
            END
        END
        ELSE
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- No running sp_BlitzTrace Extended Events session to stop.'
            RAISERROR (@msg,16,1) WITH NOWAIT;
        END
    END


    IF @Action = 'drop'
    BEGIN
        IF @traceexists = 1
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Dropping sp_BlitzTrace Extended Events session.'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            IF @Debug=0
            BEGIN
                DROP EVENT SESSION sp_BlitzTrace ON SERVER;

                SET @traceexists=0;
            END
            ELSE /* @Debug=1 */
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- @Debug=1, sp_BlitzTrace Extended Events session exists but we are NOT dropping it.'
                RAISERROR (@msg,0,1) WITH NOWAIT;
            END
        END
        ELSE
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- No sp_BlitzTrace XEvents trace to drop.'
            RAISERROR (@msg,16,1) WITH NOWAIT;
        END
    END

    RAISERROR (@nl,0,1) WITH NOWAIT;
    RAISERROR (N'********************READ ME!********************',0,1) WITH NOWAIT;


    IF @traceexists = 1 and @tracerunning = 0
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Extended Events session sp_BlitzTrace exists, but is stopped.'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- To drop sp_BlitzTrace, run: exec dbo.sp_BlitzTrace @Action=''drop'';'
        RAISERROR (@msg,0,1) WITH NOWAIT;

    END
    ELSE IF @traceexists = 1 and @tracerunning = 1
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Extended Events session sp_BlitzTrace exists and is running' +
            CASE WHEN @SessionId is not null
               THEN N' for @SessionId=' + cast(@SessionId as NVARCHAR(5))
               ELSE N''
               END
        RAISERROR (@msg,0,1) WITH NOWAIT;

        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Don''t leave the sp_BlitzTrace session running for long periods!'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- To stop sp_BlitzTrace, run: exec dbo.sp_BlitzTrace @Action=''stop'';'
        RAISERROR (@msg,0,1) WITH NOWAIT;
    END
    ELSE IF @traceexists = 0
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Extended Events session sp_BlitzTrace doesn''t exist, we''re all cleaned up.'
        RAISERROR (@msg,0,1) WITH NOWAIT;
    END

    RAISERROR (N'********************SEE YA********************',0,1) WITH NOWAIT;

    SET CONTEXT_INFO 0x;
END TRY
BEGIN CATCH

    SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Catching error ...'
    RAISERROR (@msg,0,1) WITH NOWAIT;

    SELECT
        ERROR_NUMBER() AS ErrorNumber
        ,ERROR_SEVERITY() AS ErrorSeverity
        ,ERROR_STATE() AS ErrorState
        ,ERROR_PROCEDURE() AS ErrorProcedure
        ,ERROR_LINE() AS ErrorLine
        ,ERROR_MESSAGE() AS ErrorMessage;

    /* Re-check trace status */
    SELECT
        @traceexists = (CASE WHEN (s.name IS NULL) THEN 0 ELSE 1 END),
        @tracerunning = (CASE WHEN (r.create_time IS NULL) THEN 0 ELSE 1 END)
    FROM sys.server_event_sessions AS s
    LEFT OUTER JOIN sys.dm_xe_sessions AS r ON r.name = s.name
    WHERE s.name='sp_BlitzTrace'


    IF @Action='start' and @traceexists=1
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- An error occurred starting the trace. Cleaning it up.'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        DROP EVENT SESSION sp_BlitzTrace ON SERVER;
    END

    SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Resetting context and we''re outta here.'
    RAISERROR (@msg,0,1) WITH NOWAIT;

    SET CONTEXT_INFO 0x;

END CATCH

GO
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Order of events for forms and subforms</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Order of events for forms and subforms</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://support.office.com/en-ca/article/Order-of-events-for-database-objects-e76fbbfe-6180-4a52-8787-ce86553682f9#bm3
Very good description of events for all kinds of stuff 

'Opening and closing a form
===============================
'When you open a form, the following sequence of events occurs for the form:

Open =&gt; Load =&gt; Resize =&gt; Activate =&gt; Current 

'If there are no active controls on the form, the GotFocus event occurs for the form after the Activate event but before the Current event.

'When you close a form, the following sequence of events occurs for the form:
========================
Unload =&gt; Deactivate =&gt; Close 

'If there are no active controls on the form, the LostFocus event occurs for the form after the Unload event but before the Deactivate event.



When you switch between two open forms, the Deactivate event occurs for the first form, and the Activate event occurs for the second form:

Deactivate (form1) arrow Activate (form2)

The Deactivate event for a form also occurs when you switch from the form to another object tab in Access. However, the Deactivate event does not occur when you switch to a dialog box, to a form whose PopUp Property is set to Yes, or to a window in another program.

 Note    The Open event does not occur if you move the focus to a form that is already open, even if you have moved the focus to that form by performing an OpenForm action.



Working with data on a form

Form and control events occur as you move between records in the form and change data. For example, when you first open a form, the following sequence of events occurs:

Open (form) arrow Load (form) arrow Resize (form) arrow Activate (form) arrow Current (form) arrow Enter (control) arrow GotFocus (control)

Similarly, when you close a form, the following sequence of events occurs:

Exit (control) arrow LostFocus (control) arrow Unload (form) arrow Deactivate (form) arrow Close (form)

If you have changed data in a control, the BeforeUpdate and AfterUpdate events for both the control and the form occur before the Exit event for the control.



Working with subforms

When you open a form that contains a subform, the subform and its records are loaded before the main form. Thus, the events for the subform and its controls (such as Open, Current, Enter, and GotFocus) occur before the events for the form. However, the Activate event does not occur for subforms. Therefore, opening a main form triggers an Activate event only for the main form.

Similarly, when you close a form that contains a subform, the subform and its records are unloaded after the form. The Deactivate event does not occur for subforms. Therefore, closing a main form triggers a Deactivate event only for the main form. The events for the controls, form, and subform occur in the following order:

1.Events for the subform's controls (such as Exit and LostFocus)


2.Events for the form's controls (including the subform control)


3.Events for the form (such as Deactivate and Close)


4.Events for the subform


 Note    Because the events for a subform occur after the main form is closed, certain events, such as canceling the closing of the main form from an event in the subform, will not occur. You may need to move these types of validation tests to an event on the main form.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Report</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>User_chooses_Sort_Order_from_FORM_then_Report_is_Sorted</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Report</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>User_chooses_Sort_Order_from_FORM_then_Report_is_Sorted</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>User_chooses_Sort_Order_from_FORM_then_Report_is_Sorted

'The Report has a field indicating the sort choosen by the user


============================= '1] The SQL for the Query that provides the data to the Report
'This has the [Start Date] And [End Date], but NOT the SORT parameter

q009:

SELECT T003_Service.Archive_flag, T001_Demo.NAME_F, T001_Demo.NAME_L, T001_Demo.NAME_M, T001_Demo.SSN, T003_Service.SERV_DATE, LIST_Lookups.ValueLabel AS Service, T001_Demo.DEMO_PK, T003_Service.Service_PK
FROM T001_Demo INNER JOIN (T003_Service INNER JOIN LIST_Lookups ON T003_Service.SERVICE = LIST_Lookups.Value) ON T001_Demo.DEMO_PK = T003_Service.Demo_FK
WHERE (((T003_Service.SERV_DATE) Between [Start Date] And [End Date]) AND ((LIST_Lookups.LK_ID)=3))
ORDER BY T003_Service.Archive_flag DESC , T001_Demo.NAME_F, T001_Demo.NAME_L, T003_Service.SERV_DATE DESC;

============================= '2]The Form has a button, an Option Group, and two options

'The Button
	cmd_Report_3
'The Option Group
	optGroup_Service
'The two options:
	opt_Services_by_Date	'Labeled: "Sort: Date, Then Last Name"
	opt_Services_by_Lname	'Labeled: "Sort Last Name, then First"
	
'CODE on the form: Switchboard

Private Sub cmd_Report_3_Click()

On Error GoTo Err_cmd1_Click
    Dim stDocName As String
    Dim str As String
'    DoCmd.OpenReport "r003_ServiceDates_for_All_Clients", acViewReport
    
  Select Case Me.optGroup_Service
    Case 1
      str = "Date_LastName"
    Case 2
      str = "LName_FName"
  End Select
  
    stDocName = "r003_ServiceDates_for_All_Clients"
    DoCmd.OpenReport stDocName, acPreview, , , , str

Exit_cmd1_Click:
    Exit Sub

Err_cmd1_Click:
    MsgBox Err.Description
    Resume Exit_cmd1_Click
End Sub

Private Sub Form_Load()
    Me.optGroup_Service.DefaultValue = 1
End Sub

============================= '3] The Report has an unbound text field

'The Unbound Text Field:
	txt_SortedBy


'The Control Source for the text field is: 
	=[OpenArgs]

'The Open event for the Report is:

Private Sub Report_Open(Cancel As Integer)

    Dim sOpenArg As String
    sOpenArg = Me.OpenArgs
    
On Error GoTo ErrorHandler

   Select Case sOpenArg
      Case "Date_LastName"
         Me.OrderBy = "SERV_DATE DESC, NAME_L"   ' Sort by two fields.
      Case "LName_FName"
         Me.OrderBy = "NAME_L, NAME_F"        ' Sort by descending date.
   End Select

   Me.OrderByOn = True                        ' Apply the sort order.

   Exit Sub

ErrorHandler:
   MsgBox "Error #: " &amp; Err.Number &amp; vbCrLf &amp; vbCrLf &amp; Err.Description
    
    
    
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ACCESS_SQL_CompareAndContrast</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ACCESS_SQL_CompareAndContrast</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'http://sqlserver2000.databases.aspfaq.com/what-are-the-main-differences-between-access-and-sql-server.html

'TRUE/False ===========================

-- DETERMINING TRUE 
 
-- Access: 
[...] WHERE ynColumn = TRUE 
[...] WHERE ynColumn = -1 
 
-- SQL Server: 
[...] WHERE ynColumn &lt;&gt; 0 
 
'------------------------------ 
 
'-- DETERMINING FALSE 
 
'-- Access: 
[...] WHERE ynColumn = FALSE 
[...] WHERE ynColumn = 0 
 
'-- SQL Server: 
[...] WHERE ynColumn = 0


'Switching from Date/Time to DATETIME  ============

'When passing dates into Access from ASP or an application, you use pound signs (#) for surrounding dates. SQL Server, on the other hand, uses apostrophes ('). So the following query conversion would be required: 

'-- Access: 
[...] WHERE dtColumn &gt;= #2001-11-05# 
 
'-- SQL Server: 
[...] WHERE dtColumn &gt;= '20011105' 

'--------------------------------------------------

'In addition, Access allows you to store date and time independently. SQL Server, including SQL Server 2005 ("Yukon"), 
'does not allow this (see Article #2206 for more info). To see if a date equals 2001-11-05 in SQL Server, you would have to convert the stored value 
'(which includes time) to a date only. Here is how a typical query would have to change: 

'-- Access: 
[...] WHERE dtColumn = #11/05/2001# 
 
'-- SQL Server: 
[...] WHERE CONVERT(CHAR(8), dtColumn, 112) = '20011105' 
 
-- if dtColumn has an index, this will be more efficient: 
[...] WHERE dtColumn &gt;= '20011105' 
    AND dtColumn &lt; '20011106'

'If you want to retrieve the current date and time, the syntax is slightly different: 

'-- Access: 
SELECT Now() 
SELECT Date() &amp; " " &amp; Time() 
 
'-- SQL Server: 
SELECT GETDATE() 
SELECT CURRENT_TIMESTAMP 

'If you want just the time: 

'-- Access: 
SELECT Time() 
 
'-- SQL Server: 
SELECT CONVERT(CHAR(8), GETDATE(), 108) 
SELECT LTRIM(STUFF(RIGHT(CONVERT(CHAR(19), GETDATE(), 0), 7), 6, 0, ' ')) 

'If you want just today's date, there are other options: 

'-- Access: 
SELECT Date() 
 
'-- SQL Server: 
SELECT GETDATE() - {fn CURRENT_TIME} 
SELECT {fn CURDATE()} -- not friendly with certain languages 
SELECT CONVERT(CHAR(8), GETDATE(), 112)

'To get tomorrow's date, here is how your queries would look: 

'-- Access: 
SELECT DateAdd("d",1,date()) 
 
'-- SQL Server: 
SELECT CONVERT(CHAR(8), GETDATE()+1, 112) 
'--or 
SELECT DATEADD(DAY, 1, CONVERT(CHAR(8), GETDATE(), 112)) 

'To get the date and time 24 hours from now: 
 
'-- Access: 
SELECT cstr(DateAdd("d",1,date())) &amp; " " &amp; cstr(time()) 
 
'-- SQL Server: 
SELECT DATEADD(day, 1, GETDATE()) 
 
'To get the first day of the current month: 
 
'-- Access: 
SELECT DateAdd("d",1-day(date()),date()) 
 
'-- SQL Server: 
SELECT CONVERT(CHAR(10),GETDATE()+1-DAY(GETDATE()),101) 
 
'To get the number of days in the current month: 
 
'-- Access: 
SELECT DAY(DATEADD("m", 1, 1-DAY(date()) &amp; date())-1) 
 
'-- SQL Server: 
SELECT DAY(DATEADD(MONTH, 1, 1-DAY(GETDATE())+GETDATE())-1) 
 
'To get the current millisecond: 
 
'-- This is impossible in Access, but just for fun: 
SELECT "Pick a number between 1 and 1000" :-) 
 
'-- SQL Server: 
SELECT DATEPART(millisecond, GETDATE()) 
 
'To get the current weekday: 
 
'-- Access: 
SELECT weekdayname(weekday(date())) 
 
'-- SQL Server: 
SELECT DATENAME(WEEKDAY, GETDATE()) 

'==================


'This function converts NUMERIC data that may be stored in string format to INTEGER format for comparison and computation.
 Remember that SQL Server is much more strongly typed than VBA in Access, so you may find yourself using CAST a lot more than you expected. 
 
'-- Access: 
SELECT CINT(column) 
 
'-- SQL Server: 
SELECT CAST(column AS INT) 
 
'INSTR(data, expression) -&gt; CHARINDEX(expression, data) 
'This function returns an integer representing the character where the search expression is found within the data parameter. Note that the order of these parameters is reversed! 
 
'-- Access: 
SELECT INSTR("franky goes to hollywood","goes") 
 
'-- SQL Server: 
SELECT CHARINDEX('goes','franky goes to hollywood') 
 
'ISDATE(data) 
This function returns 1 if the supplied parameter is a valid date, and 0 if it is not. Aside from delimiters, the syntax is identical. 
 
'-- Access: 
SELECT ISDATE(#12/01/2001#) 
 
'-- SQL Server: 
SELECT ISDATE('12/01/2001') 
 
'ISNULL(data) 
This function works a bit differently in the two products. In Access, it returns 1 if the supplied parameter is NULL, and 0 if it is not. In SQL Server, there are two parameters, and the function works more like a CASE statement. The first parameter is the data you are checking; the second is what you want returned IF the first parameter is NULL (many applications outside the database haven't been designed to deal with NULL values very gracefully). The following example will return a 1 or 0 to Access, depending on whether 'column' is NULL or not; the code in SQL Server will return the column's value if it is not NULL, and will return 1 if it is NULL. The second parameter usually matches the datatype of the column you are checking. 
 
'-- Access: 
SELECT ISNULL(column) FROM tbl 
 
'-- SQL Server: 
SELECT ISNULL(column,1) FROM tbl 
 
'A more intuitive function to use in SQL Server is the ANSI standard COALESCE() function. Not only does it allow you to substitute a value when a NULL is found, it will allow you to step through a series of possible values, and stop at the first non-NULL. 
 
SELECT COALESCE(NULL, DateUpdated, DateAdded, GETDATE()) FROM tbl 
 
ISNUMERIC(data) 
'This function returns 1 if the supplied parameter is numeric, and 0 if it is not. The syntax is identical. 
 
SELECT ISNUMERIC(column) 
 
LEFT(data, n) 
'This function returns the leftmost n characters of data. The syntax is identical. 
 
SELECT LEFT(column,5) 
 
LEN(data) 
'This function returns the number of characters in data. The syntax is identical. 
 
SELECT LEN(column) 
 
LCASE(data) -&gt; LOWER(data) 
'This function converts data to lower case. 
 
'-- Access: 
SELECT LCASE(column) 
 
'-- SQL Server: 
SELECT LOWER(column) 
 
LTRIM(data) 
'This function removes white space from the left of data. The syntax is identical. 
 
SELECT LTRIM(column) 
 
REPLACE(data, expression1, expression2) 
'This function scans through data, replacing all instances of expression1 with expression2. 
 
SELECT REPLACE(column, 'bob', 'frank') 
 
RIGHT(data, n) 
'This function returns the rightmost n characters of data. The syntax is identical. 
 
SELECT RIGHT(column,8) 
 
RTRIM(data) 
'This function removes white space from the right of data. The syntax is identical. 
 
SELECT RTRIM(column) 
 
CSTR(data) -&gt; STR(data) 
'This function converts data to string format. 
 
'-- Access: 
SELECT CSTR(column) 
 
'-- SQL Server: 
'-- if column is NUMERIC: 
SELECT STR(column) 
'-- if column is not NUMERIC: 
SELECT CAST(column AS VARCHAR(n)) 
 
MID(data, start, length) -&gt; SUBSTRING(data, start, length) 
'This function returns 'length' characters, starting at 'start'. 
 
'-- Access: 
SELECT MID("franky goes to hollywood",1,6) 
 
'-- SQL Server: 
SELECT SUBSTRING('franky goes to hollywood',1,6) 
 
UCASE(data) -&gt; UPPER(data) 
'This function converts data to upper case. 
 
'-- Access: 
SELECT UCASE(column) 
 
'-- SQL Server: 
SELECT UPPER(column) 
 
'StrConv 
'This function converts a string into 'proper' case (but does not deal with names like O'Hallaran or vanDerNeuts). There is no direct equivalent for StrConv in SQL Server, but you can do it per word manually: 
 
'-- Access: 
SELECT StrConv("aaron bertrand",3) 
 
'-- SQL Server: 
SELECT LEFT(UPPER('aaron'),1) 
+ LOWER(RIGHT('aaron',LEN('aaron')-1)) 
+ ' ' 
+ LEFT(UPPER('bertrand'),1) 
+ LOWER(RIGHT('bertrand',LEN('bertrand')-1)) 
 
'There is a thread stored at Google dealing with proper casing an entire block of text; you could likely implement something like that in both Access and SQL Server. 
 
TRIM(data) 
'This function combines both LTRIM() and LTRIM(); there is no equivalent in SQL Server. To mimic the functionality, you would combine the two functions: 
 
'-- Access:  
SELECT TRIM(column) 
SELECT LTRIM(RTRIM(column)) 
 
'-- SQL Server: 
SELECT LTRIM(RTRIM(column)) 

































</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Password Protect a Form or a Report - Hard Coded</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Password Protect a Form or a Report - Hard Coded</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Password Protect a Form or a Report - Hard Coded


Private Sub Form_Open(Cancel As Integer)
    On Error GoTo Error_Handler
 
    If StrComp(InputBox("Please enter the Password. (the password is: MyPassword"), "MyPassword", 0) &lt;&gt; 0 Then
        Cancel = True
        MsgBox "Wrong password.", vbInformation Or vbOKOnly, "Operation cancelled"
    End If
 
Error_Handler_Exit:
    On Error Resume Next
    Exit Sub
 
Error_Handler:
    MsgBox "The following error has occurred" &amp; vbCrLf &amp; vbCrLf &amp; _
           "Error Number: " &amp; Err.Number &amp; vbCrLf &amp; _
           "Error Source: Form_Open" &amp; vbCrLf &amp; _
           "Error Description: " &amp; Err.Description &amp; _
           Switch(Erl = 0, "", Erl &lt;&gt; 0, vbCrLf &amp; "Line No: " &amp; Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Password Protect a Form or a Report - Table Based Password</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Password Protect a Form or a Report - Table Based Password</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Table Based Password

'Run Query
CREATE TABLE tbl_DB_Object_Password (  
     ObjectPasswordId              COUNTER PRIMARY KEY,
     Objecttype      TEXT(10) NOT NULL,
     ObjectName      TEXT(255) NOT NULL,
     ObjectPassword      TEXT(255) NOT NULL,
     CONSTRAINT UniqueObjectEntry UNIQUE (ObjectType, ObjectName)
);
     
     
     'Now you need to make an entry for each object you wish to protect

'ObjectType = Form or Report
'ObjectName = Name of the Form or Report
'ObjectPassword = Password youd like to use to protect the Form or Report

'Then once that is done, wed use code along the lines of

Private Sub Form_Open(Cancel As Integer)
    On Error GoTo Error_Handler
    Dim sFormPassword
 
    sFormPassword = Nz(DLookup("ObjectPassword", "tbl_DB_Object_Passwords", _
                               "[ObjectType]='Form' AND [ObjectName]='" &amp; Me.Name &amp; "'"), "")
    If sFormPassword &lt;&gt; "" Then
        '    If InputBox("Please enter the Password.") &lt;&gt; "MyPassword" Then 'if using Option Compare Binary
        If StrComp(InputBox("Please enter the Password. (the password is: ABc"), sFormPassword, 0) &lt;&gt; 0 Then
            Cancel = True
            MsgBox "Wrong password.", vbInformation Or vbOKOnly, "Operation cancelled"
        End If
    Else
        'You choose what to do here!
        '***************************
        '1. no password was set so this form isn't secured, do nothing
        '2. no password, so the admin forgot to set things up, so lock it down by Cancel=True
    End If
 
Error_Handler_Exit:
    On Error Resume Next
    Exit Sub
 
Error_Handler:
    MsgBox "The following error has occurred" &amp; vbCrLf &amp; vbCrLf &amp; _
           "Error Number: " &amp; Err.Number &amp; vbCrLf &amp; _
           "Error Source: Form_Open" &amp; vbCrLf &amp; _
           "Error Description: " &amp; Err.Description &amp; _
           Switch(Erl = 0, "", Erl &lt;&gt; 0, vbCrLf &amp; "Line No: " &amp; Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Password Protect a Form or a Report</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Password Protect a Form or a Report</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.devhut.net/2018/09/16/access-password-protect-a-form-or-a-report/

'Authorized User(s) Table run in Access:

CREATE TABLE tbl_Users (  
     UserId              COUNTER PRIMARY KEY,
     UserName      TEXT(255) NOT NULL,
     Objecttype      TEXT(10) NOT NULL,
     ObjectName      TEXT(255) NOT NULL,
     CONSTRAINT UniqueUserObject UNIQUE (UserName, ObjectType, ObjectName)
);


'Now you need to make an entry for each object you wish to protect

'UserName = The windows username of the authorized user
'ObjectType = Form or Report
'ObjectName = Name of the Form or Report

'and then we code the Forms/Reports On Open event like

'and then we code the Forms/Reports On Open event like

Private Sub Form_Open(Cancel As Integer)
    On Error GoTo Error_Handler
 
    If Nz(DLookup("UserName", "tbl_Users", _
                  "[ObjectType]='Form' AND [ObjectName]='" &amp; Me.Name &amp; "' AND [UserName]='" &amp; fOSUserName() &amp; "'"), "") = "" Then
        Cancel = True
        MsgBox "You are not authorized to open this form", vbInformation Or vbOKOnly, "Operation cancelled"
    End If
 
Error_Handler_Exit:
    On Error Resume Next
    Exit Sub
 
Error_Handler:
    MsgBox "The following error has occurred" &amp; vbCrLf &amp; vbCrLf &amp; _
           "Error Number: " &amp; Err.Number &amp; vbCrLf &amp; _
           "Error Source: Form_Open" &amp; vbCrLf &amp; _
           "Error Description: " &amp; Err.Description &amp; _
           Switch(Erl = 0, "", Erl &lt;&gt; 0, vbCrLf &amp; "Line No: " &amp; Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Sub



'====================================

Option Compare Database
Private Declare Function apiGetUserName Lib "advapi32.dll" Alias _
"GetUserNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Private Declare Function apiGetComputerName Lib "kernel32" Alias _
"GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long

Function fOSUserName() As String
'Returns the network login name
    Dim lnglen As Long, lngX As Long
    Dim strUserName As String
    strUserName = String$(254, 0)
    lnglen = 255
    lngX = apiGetUserName(strUserName, lnglen)
    If lngX &lt;&gt; 0 Then
        fOSUserName = Left$(strUserName, lnglen - 1)
    Else
        fOSUserName = ""
    End If

End Function
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VS_2015_CommandLine</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>about_VS_2015_CommandLine</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VS_2015_CommandLine</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>about_VS_2015_CommandLine</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_VS_2015_CommandLine

================
Since beta4, there have been some renames:

k -&gt; dnx
kpm -&gt; dnu
kvm -&gt; dnvm
====================

https://chad.tolkien.id.au/asp-net-vnext-ground-up-1-simplest-possible-thing/


There are three main commands to be aware of:

K - used to bootstrap up the KRE - gets your app up and running.
KVM - K Version Manager, for managing individual versions of the runtime.
KPM - K Package Manager, for managing packages that your application depends upon.



To get started using K, we need to first get the version manager.
execute the following from an admin cmd {cmd.exe} prompt:


&gt; @powershell -NoProfile -ExecutionPolicy unrestricted -Command "iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/aspnet/Home/master/kvminstall.ps1'))"


Once kvm is installed we can use this to install the K runtime itself.
a) restart VS 2015
b) then run from the Package Manager Console

&gt; kvm install latest -p 


The -p switch will persist this version of the runtime to your path.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VS_Code</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>Preference_Multiple_Consoles</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VS_Code</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>Preference_Multiple_Consoles</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://4sysops.com/archives/vscode-as-a-console-for-powershell-core-6-part-1-multiple-shells/


Use the Shell Launcher addin to easily launch multiple shell configurations in the terminal.
https://marketplace.visualstudio.com/items?itemName=Tyriar.shell-launcher

To install Shell Launcher, click the extension icon in the left navigation bar and then type "shell launcher."


Next, open the user settings again to add the lines below:

=============================================================================
"shellLauncher.shells.windows": [
    {
        "shell": "C:\\Windows\\system32\\cmd.exe",
        "label": "cmd"
    },
    {
        "shell": "C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe",
        "label": "PowerShell 5.1"
    },
    {
        "shell": "C:\\Program Files\\PowerShell\\6.0.1\\pwsh.exe",
        "label": "PowerShell 6.0"       
    },
    {
        "shell": "C:\\Program Files\\Git\\bin\\bash.exe",
        "label": "Git bash"
    },
 
],
=============================================================================
You now have to click the Reload button.

Note that the exact locations may vary depending on your operating system and shell version. 
If you want, you can remove the line we added above to set PowerShell 6 as the default shell. 
That way, PowerShell 5.1 will be your default shell (not really the recommended option).

To launch one of the new integrated consoles, 
	open the Command Palette in the View menu or press Ctrl+Shift+P. 
Then start typing "shell launcher" and select the extension. 
You should now see the new shells.

Select the shell you want to work with and hit Enter.

Once you start a new shell this way, it will stay open until you close VSCode. 
You can switch between shells in the Terminal tab as shown in the screenshot below.

You can also work with multiple consoles of the same shell by clicking the + icon.

You might feel always going through the Command Palette is too longwinded 
	to start a new shell in the Terminal tab. If so, you can assign a keyboard shortcut to Shell Launcher. 
Navigate to the Keyboard Shortcuts (File &gt; Preferences) and start typing "shell launcher."
Then double-click the extension and assign your shortcut (for instance, Ctrl+Shift+T).</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Windows_10</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>disable_WebSearch_for_Cortana</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Windows_10</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>disable_WebSearch_for_Cortana</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://www.ghacks.net/2015/06/23/how-to-disable-web-search-in-windows-10s-start-menu/

-To open the Group Policy Editor, tap on the Windows-key, type gpedit.msc and hit enter. 
	Note that the editor is (likely) only included in Pro and Enterprise versions and not in Windows 10 Home.
	If you run home, check out the other methods listed below instead.
- Browse to the following path using the left sidebar: 
	Local Computer Policy &gt; Computer Configuration &gt; Administrative Templates &gt; Windows Components &gt; Search
- Locate "Do not allow web search" and double-click it. Switch the preference to enabled.
- Locate "Don't search the web or display web results in Search and double-click it. 
	Switch the preference to enabled.
- Locate "Don't search the web or display web results in Search over metered connections" and double-click it. 
	Switch the preference to enabled.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Windows_10</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>Disable_Windows_Defender</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Windows_10</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>Disable_Windows_Defender</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Click on the Search Windows icon next to the Start Menu icon and type defender.
When the Windows Defender windows pops up, click on Settings.


You should now see the following Windows Defender settings window.
Switch off the Real-time protection option option by clicking on the on-off toggle.
Switch off the Cloud-based Protection option by clicking on the on-off toggle.
Close the settings window.
The windows Defender app window should now appear in red.


Now it is time to turn Windows Defender back on.
Once again open Windows Defender, and click on the settings button.
This time switch both real-time and cloud-based protection to on.
The windows Defender app window should now appear in green.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Windows_10</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>Unpin_Apps_from_START</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Windows_10</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>Unpin_Apps_from_START</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://www.tenforums.com/customization/21002-how-automatically-cmd-powershell-script-unpin-all-apps-start.html

function Pin-App { param(
[string]$appname,
[switch]$unpin
)
try{
if ($unpin.IsPresent){
((New-Object -Com Shell.Application).NameSpace('shell:::{4234d49b-0245-4df3-b780-3893943456e1}').Items() | ?{$_.Name -eq $appname}).Verbs() | ?{$_.Name.replace('&amp;','') -match 'From "Start" UnPin|Unpin from Start'} | %{$_.DoIt()}
return "App '$appname' unpinned from Start"
}else{
((New-Object -Com Shell.Application).NameSpace('shell:::{4234d49b-0245-4df3-b780-3893943456e1}').Items() | ?{$_.Name -eq $appname}).Verbs() | ?{$_.Name.replace('&amp;','') -match 'To "Start" Pin|Pin to Start'} | %{$_.DoIt()}
return "App '$appname' pinned to Start"
}
}catch{
Write-Error "Error Pinning/Unpinning App! (App-Name correct?)"
}
}

Pin-App "Mail" -unpin
Pin-App "Store" -unpin
Pin-App "Calendar" -unpin
Pin-App "Microsoft Edge" -unpin
Pin-App "Photos" -unpin
Pin-App "Cortana" -unpin
Pin-App "Weather" -unpin
Pin-App "Phone Companion" -unpin
Pin-App "Music" -unpin
Pin-App "xbox" -unpin
Pin-App "movies &amp; tv" -unpin
Pin-App "microsoft solitaire collection" -unpin
Pin-App "money" -unpin
Pin-App "get office" -unpin
Pin-App "onenote" -unpin
Pin-App "news" -unpin
Pin-App "Mail" -unpin
Pin-App "Store" -unpin
Pin-App "Calendar" -unpin
Pin-App "Microsoft Edge" -unpin
Pin-App "Photos" -unpin
Pin-App "Cortana" -unpin
Pin-App "Weather" -unpin
Pin-App "Phone Companion" -unpin
Pin-App "Music" -unpin
Pin-App "xbox" -unpin
Pin-App "movies &amp; tv" -unpin
Pin-App "microsoft solitaire collection" -unpin
Pin-App "money" -unpin
Pin-App "get office" -unpin
Pin-App "onenote" -unpin
Pin-App "news" -unpin

Pin-App "Groove Music" -unpin
Pin-App "Calculator" -unpin
Pin-App "Sway" -unpin
Pin-App "Pandora" -unpin
Pin-App "Skype Preview" -unpin</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Windows_7</Category>
        <Language>TEXT</Language>
        <Public>false</Public>
        <Name>ODBC_UDL_to_see_installed_Providers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Windows_7</Category>
          <Language>TEXT</Language>
          <Public>false</Public>
          <Name>ODBC_UDL_to_see_installed_Providers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


https://blogs.msdn.microsoft.com/farukcelik/2007/12/31/basics-first-udl-test/

32bit providers on a 32 bit machine
====================================
1) Create a new empty text file like test.txt (For example, right mouse click on an empty place on your desktop, select New and Text Document)

2) Rename the file as test.udl

  As soon as you renamed the file, text file icon  should change to a UDL icon 

3) Double click on test.udl file and youll receive a window titled Data Link Properties

Youll get all the installed OLE DB Providers on the box when youve switched to the Provider tab. 
	If the OLE DB Provider for the database/datasource youre interested in is in the list, 
	select the OLE DB Provider and click on Nextand youll switch to Connection tab and will be ready to play with the OLE DB Provider. 
	The rest depends on the OLE DB Provider you selected.
	
32bit providers on a 64bit machine
==================================
But one day, you followed the same procedure on a 64 bit machine and couldnt see the OLE DB Providers though youre sure that its been installed. 
There must be something wrong then ?

The reason behind for this is simple. When you double clicked on a UDL file on a 64 bit machine, 
itll enumerate only the 64 bit OLE DB Providers and most probably youve installed a 32 bit OLE DB Provider.

So then, there should be a way of making UDL Test using the 32 bit OLE DB Providers on a 64 bit machine.

Actually when youve created a UDL file on a 64 bit machine and double clicked on it,

C:\Program Files\Common Files\System\Ole DB\oledb32.dll,OpenDSLFile  C:\test.udl

command will be called through C:\windows\system32\rundll32.exe

Both binaries (oledb32.dll and rundll32.exe) used here are 64 bit and 64 bit oledb32.dll does not deal with 32 bit OLE DB Providers.

Since we already have 32 bit versions of those oledb32.dll and rundll32.exe in other folders on our 64 bit machines, 
we need to use them. Therefore, instead of double clicking on the UDL file, well need to  execute the command below from a command line or Start/Run :

C:\Windows\syswow64\rundll32.exe C:\Program Files (x86)\Common Files\System\Ole DB\oledb32.dll,OpenDSLFile C:\test.udl</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>