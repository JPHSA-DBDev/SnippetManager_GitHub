<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>PERCENTILE.INC_ vs_PERCENTILE.EXC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>PERCENTILE.INC_ vs_PERCENTILE.EXC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>PERCENTILE.INC_ vs_PERCENTILE.EXC


//Median_PERCENTILE_EXE_INC.dax

/*
'PERCENTILE. INC includes the full range of 0 to 1 as valid k values, compared to PERCENTILE. 
'EXC which excludes percentages below 1/(N+1) and above N/(N+1).

'When percentiles fall between values, PERCENTILE.INC will interpolate and return an intermediate value.

*/


DEFINE
	TABLE SampleDate = {1,2,3,4,5,6,7,8,9,10,11}
//'	TABLE SampleDate = {1,2,3,4,5,6,7,8,9,10,11}	

EVALUATE
{
	( 
		"Median", MEDIAN(SampleDate[Value] )
		,"EXC 0.25", PERCENTILE.EXC(SampleDate[Value],0.25 )	
		,"INC 0.25", PERCENTILE.INC(SampleDate[Value],0.25 )			
		,"EXC 0.50", PERCENTILE.EXC(SampleDate[Value],0.50 )	
		,"INC 0.50", PERCENTILE.INC(SampleDate[Value],0.50 )	
		,"EXC 0.75", PERCENTILE.EXC(SampleDate[Value],0.75 )	
		,"INC 0.75", PERCENTILE.INC(SampleDate[Value],0.75 )				
	
	)
}

'//OUTPUT
'/*
'Median		6	
'EXC 0.25	3	 INC 0.25	3.5	
'EXC 0.50	6	 INC 0.50	6	
'EXC 0.75	9	 INC 0.75	8.5
'*/
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Statistical_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Statistical_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/statistical-functions-dax

' Filters do not propogate in a Row Context, i.e. in Calculated Columns
----------------------------------------------------------------------------------
'SO if you created two columns in a Visual (e.g. Table) and one was based on a Calculated Column using data from a Related table, 
'	and the other was based on a Measure using data from a Related table, then the Calculated-based Rank would remain unchanged as you
'	apply filters to the related Table, but the Measure-based Rank would change as you applied filters to the related Table.

'e.g. for a Calculated Column
Ranking =        RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))

'e.g. for a MEASURE Column
RankingMeasure = RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))		
---------------------------------------------------------------------------------

ADDCOLUMNS
APPROXIMATEDISTINCTCOUNT
AVERAGE
AVERAGEA

AVERAGEX
 		'e.g.
 		AverageGrossSales = AVERAGEX(SalesOrderDetail, SalesOrderDetail[OrderQty] * SalesOrderDetail[UnitPrice] * (1 - SalesOrderDetail[UnitPriceDiscount]))
 		
BETA.DIST
BETA.INV
CHISQ.INV
CHISQ.INV.RT
CONFIDENCE.NORM
CONFIDENCE.T

COUNT():
	'The COUNT function counts the number of cells in a column that contains 
	'values of the whole number or integer or string datatype excluding the 
	'blank cell. It even counts the cell with repeated values.
	' only count non-empty cells  and are not sensitive to repetitive values 
	'in cells.
	Apps = COUNT(FactApplication[Client_App_ID])
	
	'EXAMPLE: show 0 if there are none, 1 if there are some
	' add a zero to convert the blanks to zero, then use "&gt;" to create boolean, then INT to convert back to 0/1
	INT((COUNT(FactApplication[Client_App_ID]) + 0) &gt; 0)

COUNTA():
	'COUNTA function can also count the boolean values (True or False) 
	'whereas count function returns an error .
	' only count non-empty cells  and are not sensitive to repetitive values 
	'in cells.

	Measure  = CALCULATE(
							COUNTA(	Table[Column1] )
							,ALLEXCEPT(
										Table
										,Table[Column1]
									   )
					     )

COUNTX():
	'Syntax: COUNTX(&lt;table&gt;,&lt;expression&gt;)
	'COUNTX function counts the number of rows which are non-empty when 
	'evaluating an expression over a table.
	'This function cannot be used for boolean values.

COUNTAX():
	'Syntax: COUNTAX(&lt;table&gt;,&lt;expression&gt;)
	'similar to COUNTX function with the only difference being that COUNTAX function can operate on boolean values.	

COUNTBLANKS():
	'Syntax: COUNTBLANK(&lt;column&gt;)
	' calculate the number of blanks present in a column.
	 NumbOfRowNumbersWithBlanks = COUNTBLANK('tableName'[columnName])
	
COUNTROWS():
	'Syntax : COUNTROWS(&lt;table&gt;)
	'NOTE: can use FILTERs in place of &lt;table&gt;
	'counts the number of rows in the specified table, or in a table defined by an expression .


CROSSJOIN
	'e.g. Cross Join 3 tables
	RowHeader_Territory_Segment = CROSSJOIN(RowHeaders,Segments,Territories)
DATATABLE function
DISTINCTCOUNT():
	'Syntax: DISTINCTCOUNT(&lt;column&gt;)
	' returns the number of unique values present in a column.
	'It counts NULL as a unique value

DISTINCTCOUNTNOBLANK
	' returns the number of unique values present in a column.
	'It DOES NOT counts NULL as a unique value
	
	CALCULATE( 
				DISTINCTCOUNT(DimDealer[DealerCode]),
				FILTER(DimDealer,DimDealer[DealerActive] = True())
			  )
	
	
EXPON.DIST
GENERATE
GENERATEALL
GEOMEAN
GEOMEANX
MAX
	'This takes the Max from a column, but does not let you filter by some category
MAXA
MAXX
	'This takes the Max from an expression, where the expression is what let's us 'filter' 
	'	down to just some rows
	
	Last Purchase Date for each Customer = 
	    //'return the MAX value from the set of returned rows
	    MAXX(
	            RELATEDTABLE(Internet Sales),     //'Work on the related set of rows from the table, related by the relationship (i.e. the customer)
	            Internet Sales[Order Date]       // 'for each row returned, return this field
	        )	
MEDIAN
	'Returns the median of numbers in a column
	'To return the median of an expresssion evaluated for each row in a table, use MEDIANX function.
	'Syntax
	MEDIAN(&lt;column&gt;)
	'Return value
		A decimal number
		
	'NOTES
		'Only the numbers in the column are counted. Blanks, logical values, and text are ignored.
		'MEDIAN( Table[Column] ) is equivalent to MEDIANX( Table, Table[Column] ).
MEDIANX
	'Returns the median number of an expression evaluated for each row in a table
	'To return the median of numbers in a column, use MEDIAN function.
	
	'Syntax
	MEDIANX(&lt;table&gt;, &lt;expression&gt;) 
	
	table	'The table containing the rows for which the expression will be evaluated.
	expression	'The expression to be evaluated for each row of the table.
	
	'NOTES
		'Only the numbers in the column are counted.
		'Logical values and text are ignored.
		' MEDIANX does not ignore blanks; however, MEDIAN does ignore blanks  &lt;====== IMPORTANT DIFFERENCE
		
	'EX
	= MEDIANX( FILTER(Customers, RELATED( Geography[Country]="USA" ) ), Customers[Age] )  
	
MIN
MINA
MINX
NORM.DIST
NORM.INV
NORM.S.DIST
NORM.S.INV (DAX)
PERCENTILE.EXC   (EXCLUSIVE)
	'Returns the k-th percentile of values in a range, where k is in the range 0..1, EXCLUSIVE.
	'To return the percentile number of an expression evaluated for each row in a table, use PERCENTILEX.EXC function.
	
	'SYNTAX
		PERCENTILE.EXC(&lt;column&gt;, &lt;k&gt;) 
		
		column	'A column containing the values that define relative standing.
		k	'The percentile value in the range 0..1, exclusive.	
PERCENTILE.INC  (INCLUSIVE)
	' Returns the k-th percentile of values in a range, where k is in the range 0..1, INCLUSIVE.
	' To return the percentile number of an expression evaluated for each row in a table, use PERCENTILEX.INC.

	'SYNTAX
		PERCENTILE.INC(&lt;column&gt;, &lt;k&gt;)   
		
		column	'A column containing the values that define relative standing.
		k	'The percentile value in the range 0..1, inclusive.	
PERCENTILEX.EXC   (EXCLUSIVE)
	'Returns the percentile number of an expression evaluated for each row in a table.
	'To return the percentile of numbers in a column, use PERCENTILE.EXC function.
	
	PERCENTILEX.EXC(&lt;table&gt;, &lt;expression&gt;, k)  
	
	table'	The table containing the rows for which the expression will be evaluated.
	expression	'The expression to be evaluated for each row of the table.
	k	'The desired percentile value in the range 0 to 1 EXCLUSIVE.

PERCENTILEX.INC  (INCLUSIVE)
	'Returns the percentile number of an expression evaluated for each row in a table.
	'To return the percentile of numbers in a column, use PERCENTILE.INC.
	
	PERCENTILEX.INC(&lt;table&gt;, &lt;expression&gt;;, k)  

	table	'The table containing the rows for which the expression will be evaluated.
	expression	'The expression to be evaluated for each row of the table.
	k	'The desired percentile value in the range 0 to 1 INCLUSIVE.

POISSON.DIST
RANK.EQ
RANKX
	RANKX(&lt;table&gt;, &lt;expression&gt;[, &lt;value&gt;[, &lt;order&gt;[, &lt;ties&gt;]]])  
	'e.g. create a MEASURE: for each product (in TABLE_1: Products), go through each row in another table (TABLE_2: SalesOrderDetail)
	
	Ranking = RANKX(
					ALL(Products), 
					SUMX(
							RELATEDTABLE(SalesOrderDetail), 
							SalesOrderDetail[GrossSales])
						)
					)
	'NOTE: if you used  SUMX(SalesOrderDetail, SalesOrderDetail[GrossSales]) 
	'	then it would sum up all the rows, rather than just the related rows
	'NOTE: if we did not use ALL (for [Products] table) then it would only rank for the filtered rows of [Products], and not give us an overall Rank


ROW
SAMPLE
SELECTCOLUMNS
SIN
SINH
SQRTPI
STDEV.P
STDEV.S
STDEVX.P
STDEVX.S
SUMMARIZE
	'SYNTAX
	SUMMARIZE (&lt;table&gt;, &lt;groupBy_columnName&gt;[, &lt;groupBy_columnName&gt;]…[, &lt;name&gt;, &lt;expression&gt;]…)
	'Returns a summary table for the requested totals over a set of groups.
	&lt;expression&gt;	'Any DAX expression that returns a single scalar value, where the expression is to be evaluated multiple times (for each row/context).
T.DIST
T.DIST.2T
T.DIST.RT
T.INV
T.INV.2t
TAN
TANH
TOPN
VAR.P
VAR.S
VARX.P
VARX.S
XIRR
XNPV
</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>