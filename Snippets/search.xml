<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>All_Groups_and_All_Members</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>All_Groups_and_All_Members</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://serverfault.com/questions/532945/list-all-groups-and-their-members-with-powershell-on-win2008r2


'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
'#LIST_AD_Groups_and_Members.ps1
Import-Module ActiveDirectory

$Groups = (Get-AdGroup -filter * | Where {$_.name -like "**"} | select name -ExpandProperty name)

$Table = @()

$Record = @{
  "Group Name" = ""
  "Name" = ""
  "Username" = ""
}


Foreach ($Group in $Groups) {

  $Arrayofmembers = Get-ADGroupMember -identity $Group -recursive | select name,samaccountname

  foreach ($Member in $Arrayofmembers) {
    $Record."Group Name" = $Group
    $Record."Name" = $Member.name
    $Record."UserName" = $Member.samaccountname
    $objRecord = New-Object PSObject -property $Record
    $Table += $objrecord

  }
}

$Table | export-csv "C:\temp\SecurityGroups.csv" -NoTypeInformation

'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

$Groups = Get-ADGroup -Properties * -Filter * -SearchBase "OU=Groups,DC=corp,DC=ourcompany,DC=Com" 
Foreach($G In $Groups)
{
    Write-Host $G.Name
    Write-Host "-------------"
    $G.Members
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>accessing_CIM_Instances</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>accessing_CIM_Instances</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Accessing Class Instances
'ASSUMING:  -Namespace root/cimv2
#'
#'Once you know the class name, you can get instances of that class
#'Use Get-CimInstance and specify class name and, if needed Namespace
#'Send instances to Get-Member to discover instance contents

&gt;Get-CimInstance -ClassName win32_share
'OUTPUT
---------
#'Name                        Path                                     Description                
#'----                        ----                                     -----------                
#'ADMIN$                      C:\Windows                               Remote Admin               
#'C$                          C:\                                      Default share              
#'E$                          E:\                                      Default share              
#'G$                          G:\                                      Default share              
#'HP Universal Printing PCL 6 HP Universal Printing PCL 6,LocalsplOnly HP Universal Printing PCL 6
#'IPC$                                                                 Remote IPC                 
#'print$                      C:\Windows\system32\spool\drivers        Printer Drivers            
#'Users                       C:\Users                                                            
#'Z$                          Z:\                                      Default share   


'These are the properties of the CimClass 'Win32_Share'
&gt;Get-CimClass -ClassName win32_share | Format-List
'OUTPUT
---------
#'CimSuperClassName   : CIM_LogicalElement
#'CimSuperClass       : ROOT/cimv2:CIM_LogicalElement
#'CimClassProperties  : {Caption, Description, InstallDate, Name...}
#'CimClassQualifiers  : {Locale, UUID, CreateBy, DeleteBy...}
#'CimClassMethods     : {Create, SetShareInfo, GetAccessMask, Delete}
#'CimSystemProperties : Microsoft.Management.Infrastructure.CimSystemProperties
#'CimClassName        : Win32_Share

'Then EXPAND the CimClassMethods Property
'NOTE: 'Create' has the 'Static' qualifier, therefore it is a STATIC method
'		whereas 'Delete' lacks the qualifer, and is not a STATIC method
&gt;Get-CimClass -ClassName win32_share | Select-Object -ExpandProperty Cimclassmethods
#'
#'Name          ReturnType Parameters                                     Qualifiers                                        
#'----          ---------- ----------                                     ----------                                        
#'Create            UInt32 {Access, Description, MaximumAllowed, Name...} {Constructor, Implemented, MappingStrings, Static}
#'SetShareInfo      UInt32 {Access, Description, MaximumAllowed}          {Implemented, MappingStrings}                     
#'GetAccessMask     UInt32 {}                                             {Implemented, MappingStrings}                     
#'Delete            UInt32 {}                                             {Destructor, Implemented, MappingStrings}  



'To see the Property and Methods of the instances
'NOTE: the methods shown are 'Instance Methods', but STATIC methods are not shown
&gt;Get-CimInstance -ClassName win32_share | Get-Member
'OUTPUT
---------
#'   TypeName: Microsoft.Management.Infrastructure.CimInstance#root/cimv2/Win32_Share
#'
#'Name                      MemberType  Definition                                                                            
#'----                      ----------  ----------                                                                            
#'Clone                     Method      System.Object ICloneable.Clone()                                                      
#'Dispose                   Method      void Dispose(), void IDisposable.Dispose()                                            
#'Equals                    Method      bool Equals(System.Object obj)                                                        
#'GetCimSessionComputerName Method      string GetCimSessionComputerName()                                                    
#'GetCimSessionInstanceId   Method      guid GetCimSessionInstanceId()                                                        
#'GetHashCode               Method      int GetHashCode()                                                                     
#'GetObjectData             Method      void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runt...
#'GetType                   Method      type GetType()                                                                        
#'ToString                  Method      string ToString()                                                                     
#'AccessMask                Property    uint32 AccessMask {get;}                                                              
#'AllowMaximum              Property    bool AllowMaximum {get;}                                                              
#'Caption                   Property    string Caption {get;}                                                                 
#'Description               Property    string Description {get;}                                                             
#'InstallDate               Property    CimInstance#DateTime InstallDate {get;}                                               
#'MaximumAllowed            Property    uint32 MaximumAllowed {get;}                                                          
#'Name                      Property    string Name {get;}                                                                    
#'Path                      Property    string Path {get;}                                                                    
#'PSComputerName            Property    string PSComputerName {get;}                                                          
#'Status                    Property    string Status {get;}                                                                  
#'Type                      Property    uint32 Type {get;}                                                                    
#'PSStatus                  PropertySet PSStatus {Status, Type, Name}  
#'
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>discovering_Class_Methods</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>discovering_Class_Methods</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'ASSUMING:  -Namespace root/cimv2


#'This gets a list of processes
&gt;Get-CimInstance Win32_process

#'This gets the CimClass Methods for the process "Win32_process"
(Get-CimInstance -ClassName Win32_process -Filter "name = 'powershell_ise.exe'").CimClass.CimClassMethods 

================================

&gt;Get-CimInstance Win32_Service
'OUTPUT
-----------
#'ProcessId Name                               StartMode State   Status ExitCode
#'--------- ----                               --------- -----   ------ --------
#'0         AeLookupSvc                        Manual    Stopped OK     0       
#'0         ALG                                Manual    Stopped OK     1077    
#'884       AMD External Events Utility        Auto      Running OK     0       
#'0         AppIDSvc                           Manual    Stopped OK     1077    
#'0         Appinfo                            Manual    Stopped OK     1077    
#'0         AppMgmt                            Manual    Stopped OK     1077    
#'0         aspnet_state                       Disabled  Stopped OK     1077    
#'316       AudioEndpointBuilder               Auto      Running OK     0       
#'992       AudioSrv                           Auto      Running OK     0       
#'0         AxInstSV                           Manual    Stopped OK     1077    
#'0         BDESVC                             Manual    Stopped OK     1077    
#'1512      BFE                                Auto      Running OK     0       
#'356       BITS                               Manual    Running OK     0       
#'356       Browser                            Manual    Running OK     0       
#'0         bthserv                            Disabled  Stopped OK     1077    
#'356       CertPropSvc                        Manual    Running OK     0       
#'0         clr_optimization_v2.0.50727_32     Disabled  Stopped OK     1077    
#'0         clr_optimization_v2.0.50727_64     Disabled  Stopped OK     1077    
#'

'This pulls out the BITS instance:
&gt;Get-CimInstance -ClassName Win32_Service |  Where-Object -Property name -EQ BITS
'OUTPUT
----------
'ProcessId Name StartMode State   Status ExitCode
'--------- ---- --------- -----   ------ --------
'356       BITS Manual    Running OK     0    

'Now to see the methods:
&gt;(Get-CimInstance -ClassName Win32_Service |  Where-Object -Property name -EQ BITS).CimClass.CimClassMethods
'OUTPUT
-------
#'Name                  ReturnType Parameters                                                      Qualifiers                         
#'----                  ---------- ----------                                                      ----------                         
#'StartService              UInt32 {}                                                              {MappingStrings, ValueMap}         
#'StopService               UInt32 {}                                                              {MappingStrings, ValueMap}         
#'PauseService              UInt32 {}                                                              {MappingStrings, ValueMap}         
#'ResumeService             UInt32 {}                                                              {MappingStrings, ValueMap}         
#'InterrogateService        UInt32 {}                                                              {MappingStrings, ValueMap}         
#'UserControlService        UInt32 {ControlCode}                                                   {MappingStrings, ValueMap}         
#'Create                    UInt32 {DesktopInteract, DisplayName, ErrorControl, LoadOrderGroup...} {MappingStrings, Static, ValueMap} 
#'Change                    UInt32 {DesktopInteract, DisplayName, ErrorControl, LoadOrderGroup...} {MappingStrings, ValueMap}         
#'ChangeStartMode           UInt32 {StartMode}                                                     {MappingStrings, ValueMap}         
#'Delete                    UInt32 {}                                                              {MappingStrings, ValueMap}         
#'GetSecurityDescriptor     UInt32 {Descriptor}                                                    {implemented, Privileges, ValueMap}
#'SetSecurityDescriptor     UInt32 {Descriptor}                                                    {implemented, Privileges, ValueMap}
#'

'Then this expands the 'Parameters' Property of the 'change' ,method:
&gt;(Get-CimInstance -ClassName Win32_Service |  Where-Object -Property name -EQ BITS).CimClass.CimClassMethods | Where-Object -Property name -EQ Change | select -ExpandProperty Parameters
'OUTPUT
--------
#'Name                           CimType Qualifiers                         ReferenceClassName
#'----                           ------- ----------                         ------------------
#'DesktopInteract                Boolean {ID, In, MappingStrings}                             
#'DisplayName                     String {ID, In, MappingStrings}                             
#'ErrorControl                     UInt8 {ID, In, MappingStrings}                             
#'LoadOrderGroup                  String {ID, In, MappingStrings}                             
#'LoadOrderGroupDependencies StringArray {ID, In, MappingStrings}                             
#'PathName                        String {ID, In, MappingStrings}                             
#'ServiceDependencies        StringArray {ID, In, MappingStrings}                             
#'ServiceType                      UInt8 {BitMap, ID, In, MappingStrings}                     
#'StartMode                       String {ID, In, MappingStrings, ValueMap}                   
#'StartName                       String {ID, In, MappingStrings}                             
#'StartPassword                   String {ID, In, MappingStrings}                             
#'



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Getting_Class_Qualifiers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Getting_Class_Qualifiers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>What is a WMI qualifier?
------------------------
#'    MSDN defines these as: a data string that provides more information about a class, 
#'        instance, property, method, or parameter.
#'    Think of it as an attribute – of a class, instance, property, method, or parameter.
#'
#'You use Get-CimClass to discover information about a class, including class, method and property 
#'qualifiers
--------------------- How to get the Qualifiers
#'Get-CimClass returns an object with key properties returned as arrays
#'    Pipe the output of Get-CimClass to Select-Object –Expand &lt;prop&gt; to expand any of the properties
---------------------

#' Get Class details
Get-CimClass –Classname Win32_Share

#' Get class qualifiers
Get-CimClass –Classname Win32_Share | Select-Object –Expand CimClassQualifiers

#' To get class method details, including qualifiers
Get-CimClass –Classname Win32_Share | Select-Object –Expand CimClassMethods

#' To get class property details, including qualifiers
&gt;Get-CimClass –Classname Win32_Share | Select-Object –Expand CimClassProperties

#' To get the Class System Properties (these tend to be less useful)
&gt;Get-CimClass –Classname Win32_Share | Select-Object –Expand CimSystemProperties


==============================================================================
# First, get basic CIM Class details for Win32_share
Get-CimClass -ClassName Win32_Share | Format-Table -Wrap
#'OUTPUT
------------
#'   NameSpace: ROOT/cimv2
#'
#'CimClassName                        CimClassMethods      CimClassProperties                                           
#'------------                        ---------------      ------------------                                           
#'Win32_Share                         {Create,             {Caption, Description, InstallDate, Name...}                 
#'                                    SetShareInfo,                                                                     
#'                                    GetAccessMask,                                                                    
#'                                    Delete}  
==============================================================================
# Now get details of methods in this class
Get-CimClass -ClassName Win32_Share | Select-Object -ExpandProperty CimClassMethods | format-table -AutoSize 

#'OUTPUT
------------
#'Name          ReturnType Parameters                                     Qualifiers                               
#'----          ---------- ----------                                     ----------                               
#'Create            UInt32 {Access, Description, MaximumAllowed, Name...} {Constructor, Implemented, MappingStri...
#'SetShareInfo      UInt32 {Access, Description, MaximumAllowed}          {Implemented, MappingStrings}            
#'GetAccessMask     UInt32 {}                                             {Implemented, MappingStrings}            
#'Delete            UInt32 {}                                             {Destructor, Implemented, MappingStrings}


# Now get the class properties
Get-CimClass -ClassName Win32_Share | Select-Object -ExpandProperty CimClassProperties | Format-Table -AutoSize 

#'OUTPUT
------------
#'Name           Value  CimType                              Flags Qualifiers                            ReferenceC
#'                                                                                                       lassName  
#'----           -----  -------                              ----- ----------                            ----------
#'Caption                String      Property, ReadOnly, NullValue {MaxLen, read}                                  
#'Description            String      Property, ReadOnly, NullValue {read}                                          
#'InstallDate          DateTime      Property, ReadOnly, NullValue {MappingStrings, read}                          
#'Name                   String Property, Key, ReadOnly, NullValue {read, key, MappingStrings, Override}           
#'Status                 String      Property, ReadOnly, NullValue {MaxLen, read, ValueMap}                        
#'AccessMask             UInt32      Property, ReadOnly, NullValue {DEPRECATED, read}                              
#'AllowMaximum          Boolean      Property, ReadOnly, NullValue {MappingStrings, read}                          
#'MaximumAllowed         UInt32      Property, ReadOnly, NullValue {MappingStrings, read}                          
#'Path                   String      Property, ReadOnly, NullValue {MappingStrings, read}                          
#'Type                   UInt32      Property, ReadOnly, NullValue {MappingStrings, read, ValueMap}   



# Get class qualifiers
Get-CimClass –Classname Win32_Share | Select-Object -ExpandProperty CimClassQualifiers | Format-Table -Wrap -AutoSize


#'OUTPUT
------------
#'Name                                            Value CimType                      Flags
#'----                                            ----- -------                      -----
#'Locale                                           1033  SInt32 EnableOverride, ToSubclass
#'UUID           {8502C4D6-5FBB-11D2-AAC1-006008C78BC7}  String EnableOverride, ToSubclass
#'CreateBy                                       Create  String EnableOverride, Restricted
#'DeleteBy                               DeleteInstance  String EnableOverride, Restricted
#'dynamic                                          True Boolean EnableOverride, ToSubclass
#'provider                                     CIMWin32  String EnableOverride, ToSubclass
#'SupportsCreate                                   True Boolean EnableOverride, Restricted
#'SupportsDelete                                   True Boolean EnableOverride, Restricted
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CIM_Computer_Info_v2____with__BIOSReleaseDate</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CIM_Computer_Info_v2____with__BIOSReleaseDate</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Usage===========================================================================
#'         &gt; Get-MachineInfo -ComputerName 10.11.56.176 -Protocol Dcom -Verbose
#'===========================================================================

function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1
            #'----------------------------------
            #'CIM_BIOSElement
            #'CIM_BIOSFeature
            #'CIM_BIOSFeatureBIOSElements
            #'CIM_BIOSLoadedInNV
            #'Get-CimClass win32_bios

            #'Get-CimClass CIM_BIOSElement | select -First 1 -ExpandProperty CimClassProperties | Select InstallDate
            $BIOS_params = @{'ClassName'='CIM_BIOSElement'
                             'CimSession'=$session}
            $BIOS = Get-CimInstance @BIOS_params | Select-Object -first 1

            $BIOS | select -First 1 -ExpandProperty ReleaseDate 

            #'----------------------------------
  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                        #'----------------------------------
                       'BIOSReleaseDate' = $BIOS | select -First 1 -ExpandProperty ReleaseDate 
                        #'----------------------------------
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            # Did we specify protocol fallback?
            # If so, try again. If we specified logging,
            # we won't log a problem here - we'll let
            # the logging occur if this fallback also
            # fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #if logging

                Get-MachineInfo @params
            } #if protocolfallback

            # if we didn't specify fallback, but we
            # did specify logging, then log the error,
            # because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } # if write to log

        } #try/catch
 
    } #foreach
} #PROCESS

END {}

} #function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Login__get_LoginInstancesFunction</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Login__get_LoginInstancesFunction</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USAGE:

&gt;Get-LoginInstance -ComputerName "LT-103111" -StartDate (Get-Date).AddDays(-1) -Verbose  | SELECT UserName, LoginTime, SessionType, LoginIpAddress



'Get-LoginInstance - Retrieve Local and Remote Computer Login/Logout Instances
https://gallery.technet.microsoft.com/scriptcenter/Get-LoginInstance-Retrieve-6437b1af

#'This script contains a function (Get-LoginInstance), 
#'    as well as two sub-functions (Get-LoginData and Get-LogoutData), 
#'    which are used to retrieve login and logout events from the Security event log on a local or remote computer, 
#'    and join them together to display login instance data.  
#'    Please use the native help bundled with the cmdlet for more information on ways to utilize/run this function.
#'
#'Additionally, please note that this cmdlet is reliant upon Remote Event Log Management, 
#'    which may need to be enabled on the target machine(s), 
#'    and due to its use of Get-WinEvent, can only work on Vista, 
#'    Server 2008 R2 and later Windows releases for consumer and enterprise markets, respectively.
#'
#'UPDATE - 10/23/14: I've revised the cmdlet to fix a few different areas - 
#'                    please download the latest version of this if you have a previous version of the script.  
#'                    Changes made to the latest version include:
#'
#'New sorting algorithm to ensure all login instances 
#'        (logins and logouts) and logins without corresponding logouts 
#'        appear in final collection, regardless of OS, account domain, etc.
#'Official support of PowerShell versions 2, 3 and 4 - Get-LoginInstance has now been tested and confirmed to work in all of those versions
#'Remove Desktop Window Manager (DWM) logins from final collection if present
#'Minor help file tweaks
=================================================================================
    -------------------------- EXAMPLE 1 --------------------------
    
    PS C:\&gt;Get-LoginInstance
    
    Retrieve all available login instances from the local computer within 
    the past week.
    
    
    
    
    -------------------------- EXAMPLE 2 --------------------------
    
    PS C:\&gt;Get-LoginInstance -ComputerName "GSR-242" -StartDate (Get-Date).AddMonths(-1) -Verbose
    
    Retrieve all available login instances from remote computer "GSR-242" 
    within the past month, displaying verbose output as well.

=================================================================================

#PowerShell Script Containing Function(s) Used to Retrieve Login &amp; Logout Instances from a Local or Remote Computer
#Developer: Andrew Saraceni (saraceni@wharton.upenn.edu)
#Date: 10/23/14

function Get-LoginInstance
{
    &lt;#
    .SYNOPSIS
    Retrieves login and logout instances from a local or remote computer.
    .DESCRIPTION
    Retrieves all interactive and remote-based logins from a specific 
    computer, then obtains all logouts and joins the instances together 
    via processing.  This information is retrieved from the Security 
    event logs on the computer, and thus can only pull data from logs 
    that have yet to turn over.

    Without parameters, a Get-LoginInstance command retrieves all logins 
    and logouts from the local computer within the past week.
    .PARAMETER ComputerName
    Specifies the computer from which to pull the login/logout 
    information.  The default value for this is the local computer.
    .PARAMETER StartDate
    Specifies the earliest (i.e. oldest) date from which to retrieve 
    logins/logouts.  The default value for this is one week before the 
    current date: (Get-Date).AddDays(-7)
    .PARAMETER EndDate
    Specifies the most recent date from which to retrieve logins/logouts.  
    The default value for this is the current date.
    .EXAMPLE
    Get-LoginInstance
    Retrieve all available login instances from the local computer within 
    the past week.
    .EXAMPLE
    Get-LoginInstance -ComputerName "GSR-242" -StartDate (Get-Date).AddMonths(-1) -Verbose
    Retrieve all available login instances from remote computer "GSR-242" 
    within the past month, displaying verbose output as well.
    .NOTES
    This cmdlet makes use of the Get-WinEvent cmdlet, which is only 
    available on Windows Vista, Windows Server 2008 R2 and later consumer 
    and enterprise verisons of Windows, respectively.

    Additionally, Remote Event Log Management will need to be enabled 
    via your firewall.  The following CMD prompt command can enable this 
    on a local computer:

    netsh advfirewall firewall set rule group=”remote event log management” new enable=yes
    #&gt;
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,Mandatory=$false)]
        [String]$ComputerName = $env:COMPUTERNAME,
        [Parameter(Position=1,Mandatory=$false)]
        [DateTime]$StartDate = (Get-Date).AddDays(-7),
        [Parameter(Position=2,Mandatory=$false)]
        [DateTime]$EndDate = (Get-Date)
    )

    function Get-LoginData
    {
        param($ComputerName,$StartDate,$EndDate)
        
        Write-Verbose "Getting Login Data from $ComputerName..."
        [Int32[]]$loginID = @(4624)

        try
        {
            $loginEvents = Get-WinEvent -ComputerName $ComputerName -FilterHashtable @{ LogName="Security"; ID=$loginID; StartTime=$StartDate; EndTime=$EndDate } -ErrorAction Stop
        }
        catch
        {
            Set-Variable -Name catchError -Value $_
            if ($catchError -match "No events were found that match the specified selection criteria.")
            {
                Write-Warning "No Login Events Found - Ending Login Collection"
            }
        }

        Write-Verbose "Converting Logins to XML &amp; Parsing Data for Better Readability..."
        foreach ($loginEvent in $loginEvents)
        {
            $xmlLoginEvent = [Xml]$loginEvent.ToXml()

            for ($i=0; $i -lt $xmlLoginEvent.Event.EventData.Data.Count; $i++)
            {            
                Add-Member -InputObject $loginEvent -MemberType NoteProperty -Name $xmlLoginEvent.Event.EventData.Data[$i].Name -Value $xmlLoginEvent.Event.EventData.Data[$i]."#Text" -Force
            }
        }

        $revisedLoginEvents = @()
        $xmlLoginEvents = $loginEvents | Where-Object { (($_.LogonType -eq "2") -or ($_.LogonType -eq "10")) -and ($_.TargetDomainName -ne "Window Manager") } | Select-Object -Property *
        foreach ($xmlLoginEvent in $xmlLoginEvents)
        {
            switch ($xmlLoginEvent.LogonType)
            {
                "2" {
                    $xmlLoginEvent.LogonType = "Login-Interactive"
                }
                "10" {
                    $xmlLoginEvent.LogonType = "Login-Remote"
                }
            }
            
            if (($xmlLoginEvent.IpAddress -eq "127.0.0.1") -or ($xmlLoginEvent.IpAddress -eq "::1"))
            {
                $xmlLoginEvent.IpAddress = $null
            }

            if ($xmlLoginEvent.IpPort -eq "0")
            {
                $xmlLoginEvent.IpPort = $null
            }
            
            $revisedLoginEvents += $xmlLoginEvent
        }
        
        return $revisedLoginEvents
    }

    function Get-LogoutData
    {
        param($ComputerName,$StartDate,$EndDate)

        Write-Verbose "Getting Logout Data from $ComputerName..."
        [Int32[]]$logoutID = @(4647)

        try
        {
            $logoutEvents = Get-WinEvent -ComputerName $ComputerName -FilterHashtable @{ LogName="Security"; ID=$logoutID; StartTime=$startDate; EndTime=$endDate } -ErrorAction Stop
        }
        catch
        {
            Set-Variable -Name catchError -Value $_
            if ($catchError -match "No events were found that match the specified selection criteria.")
            {
                Write-Warning "No Logout Events Found - Ending Logout Collection"
            }
        }

        Write-Verbose "Converting Logouts to XML &amp; Parsing Data for Better Readability..."
        foreach ($logoutEvent in $logoutEvents)
        {
            $xmlLogoutEvent = [Xml]$logoutEvent.ToXml()

            for ($i=0; $i -lt $xmlLogoutEvent.Event.EventData.Data.Count; $i++)
            {            
                Add-Member -InputObject $logoutEvent -MemberType NoteProperty -Name $xmlLogoutEvent.Event.EventData.Data[$i].name -Value $xmlLogoutEvent.Event.EventData.Data[$i]."#Text" -Force
            }
        }
        
        $revisedLogoutEvents = @()
        $xmlLogoutEvents = $logoutEvents | Select-Object -Property *
        foreach ($xmlLogoutEvent in $xmlLogoutEvents)
        {
            Add-Member -InputObject $xmlLogoutEvent -MemberType NoteProperty -Name "WorkstationName" -Value $ComputerName -Force

            $revisedLogoutEvents += $xmlLogoutEvent
        }
        
        return $revisedLogoutEvents
    }

    $finalLoginEvents = Get-LoginData -ComputerName $ComputerName -StartDate $StartDate -EndDate $EndDate
    $finalLogoutEvents = Get-LogoutData -ComputerName $ComputerName -StartDate $StartDate -EndDate $EndDate

    Write-Verbose "Creating Final Collection of Revised Login and Logout Instance Data..."
    $loginInstances = @()

    foreach ($finalLoginEvent in $finalLoginEvents)
    {
        $instanceProperties = @{
            ComputerName = $finalLoginEvent.WorkstationName
            UserName = $finalLoginEvent.TargetUserName
            AccountDomain = $finalLoginEvent.TargetDomainName
            LoginTime = $finalLoginEvent.TimeCreated
            LogoutTime = $null
            TargetLogonID = $finalLoginEvent.TargetLogonID
            Days = $null
            Hours = $null
            Minutes = $null
            Seconds = $null
            SessionType = $finalLoginEvent.LogonType
            LoginIpAddress = $finalLoginEvent.IpAddress
            LoginIpPort = $finalLoginEvent.IpPort
            LogonGuid = $finalLoginEvent.LogonGuid
        }

        $loginInstance = New-Object -TypeName PSObject -Property $instanceProperties

        foreach ($finalLogoutEvent in $finalLogoutEvents)
        {
            if (($finalLogoutEvent.WorkstationName -eq $finalLoginEvent.WorkstationName) -and ($finalLogoutEvent.TargetUserName -eq $finalLoginEvent.TargetUserName) -and ($finalLogoutEvent.TargetLogonID -eq $finalLoginEvent.TargetLogonID))
            {
                $loginInstance.LogoutTime = $finalLogoutEvent.TimeCreated
                $loginInstance.Days = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Days
                $loginInstance.Hours = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Hours
                $loginInstance.Minutes = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Minutes
                $loginInstance.Seconds = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Seconds
            }
        }

        $loginInstances += $loginInstance
    }

    $fullLoginInstances = $loginInstances | Where-Object { $_.LogoutTime -ne $null }
    $partialLoginInstances = $loginInstances | Where-Object { $_.LogoutTime -eq $null } | Sort-Object -Property LoginTime -Descending -Unique

    $fullLoginInstanceLoginTimes = $fullLoginInstances | Select-Object -ExpandProperty LoginTime
    $filteredPartialLoginInstances = @()
    
    foreach ($partialLoginInstance in $partialLoginInstances)
    {
        if ($fullLoginInstanceLoginTimes -notcontains $partialLoginInstance.LoginTime)
        {
            $filteredPartialLoginInstances += $partialLoginInstance
        }
    }

    $finalLoginInstances = @($fullLoginInstances) + @($filteredPartialLoginInstances) | Sort-Object -Property LoginTime -Descending -Unique

    return $finalLoginInstances | Select-Object -Property ComputerName, UserName, AccountDomain, LoginTime, LogoutTime, TargetLogonID, Days, Hours, Minutes, Seconds, SessionType, LoginIpAddress, LoginIpPort, LogonGuid
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Event_Logs</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_differentTypesOfErrors_OutputEachTypeToASeperateFile_usesSubExpressionToGetTheFileNames</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Event_Logs</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_differentTypesOfErrors_OutputEachTypeToASeperateFile_usesSubExpressionToGetTheFileNames</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' Creates a file for each 'Source' of errors in the EventLog
#' Writes the errors of that type to the appropriate file
#' Targets the C:\junk folder
#' shows a count of the number of errors
#' Uses a SubExpression to get the 'name' of the error, and thus name the file



get-eventlog application -EntryType Error,Warning | Group Source | foreach {
$file = Join-Path -path C:\junk -ChildPath "$($_.name).txt"
"$($_.count) entries" | Out-File -FilePath $file
$_.group | foreach {
 $_ | Select TimeGenerated,EntryType | Out-File -FilePath $file -Append
 $_ | Select -ExpandProperty Message | Out-File -FilePath $file -Append
}
Get-Item $file
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ExtendingOutputTypes </Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Add_a_Member</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ExtendingOutputTypes </Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Add_a_Member</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}

            # create a default display property set
            [string[]]$props = 'ComputerName','OSVersion','Cores','RAM'
            $ddps = New-Object -TypeName System.Management.Automation.PSPropertySet `
                               DefaultDisplayPropertySet, $props
            $pssm = [System.Management.Automation.PSMemberInfo[]]$ddps
            $obj | Add-Member -MemberType MemberSet `
                              -Name PSStandardMembers `
                              -Value $pssm

            ###Adding additional members###
            #adding a property set
            $obj | Add-Member -MemberType PropertySet `
                              -Name OS `
                              -Value 'Computername','OSVersion','OSBuild','Arch'

            #adding an alias
            $obj | Add-Member -MemberType AliasProperty `
                              -Name Free `
                              -Value SysDriveFreeSpace

            #adding a script method
            $obj | Add-Member -MemberType ScriptMethod `
                              -Name Ping `
                              -Value { Test-NetConnection $this.computername }

            #adding a script property
            $obj | Add-Member -MemberType ScriptProperty `
                              -Name TopProcesses `
                              -Value { 
                                Get-Process -ComputerName $this.computername |
                                Sort-Object -Property WorkingSet -Descending |
                                Select-Object -first 5
                                }
                                
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            # Did we specify protocol fallback?
            # If so, try again. If we specified logging,
            # we won't log a problem here - we'll let
            # the logging occur if this fallback also
            # fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #if logging

                Get-MachineInfo @params
            } #if protocolfallback

            # if we didn't specify fallback, but we
            # did specify logging, then log the error,
            # because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } # if write to log

        } #try/catch
 
    } #foreach
} #PROCESS

END {}

} #function

Get-MachineInfo -ComputerName localhost</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ExtendingOutputTypes </Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>script_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ExtendingOutputTypes </Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>script_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' example - see the bottom for notes
function Get-MachineInfo {
&lt;#'
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#'&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
                       
                       #'&lt;========= This is where you would 'add' things to the object
                       
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            #' Did we specify protocol fallback?
            #' If so, try again. If we specified logging,
            #' we won't log a problem here - we'll let
            #' the logging occur if this fallback also
            #' fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #'if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #'if logging

                Get-MachineInfo @params
            } #'if protocolfallback

            #' if we didn't specify fallback, but we
            #' did specify logging, then log the error,
            #' because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } #' if write to log

        } #'try/catch
 
    } #'foreach
} #'PROCESS

END {}

} #'function

===========================================================================================

#' this is the bit we'll change
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj



#' here's the change
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}

            #' create a default display property set                          #'  &lt;==========display property set
            [string[]]$props = 'ComputerName','OSVersion','Cores','RAM'
            $ddps = New-Object -TypeName System.Management.Automation.PSPropertySet `
                               DefaultDisplayPropertySet, $props
            $pssm = [System.Management.Automation.PSMemberInfo[]]$ddps
            $obj | Add-Member -MemberType MemberSet `
                              -Name PSStandardMembers `
                              -Value $pssm

            Write-Output $obj

--------------------------------------------------
'USAGE of predefined group of properties:
&gt; $a | Select Computername,OSVersion,OSBuild,Arch
'shortens to this:
&gt; $a | Select OS
---------------------------------------------

#' more member types...
#'adding an alias, after the object is defined
$obj | Add-Member -MemberType AliasProperty `
                    -Name Free `
                    -Value SysDriveFreeSpace
                    
'USAGE
-------                    
&gt; $a.SysDriveFreeSpace

--------------------------------------------------------------

#'adding a script method, after the object is defined
$obj | Add-Member -MemberType ScriptMethod `
                    -Name Ping `
                    -Value { Test-NetConnection $this.computername }
                    
'USAGE of a Method
--------------
&gt;$a.ping()                    
                    
---------------------------------------------------------------
#'adding a script property, after the object is defined
$obj | Add-Member -MemberType ScriptProperty `
                    -Name TopProcesses `
                    -Value { 
                    Get-Process -ComputerName $this.computername |
                    Sort-Object -Property WorkingSet -Descending |
                    Select-Object -first 5
                    }
'USAGE of property
----------------
&gt;$a.TopProcesses


#' insert a custom name
$obj.psobject.TypeNames.Insert(0,"myMachineInfo")   &lt;=== The authors said this was flaky



#' extending with update-typedata
$myType = "myMachineInfo"

Update-TypeData -TypeName $myType -DefaultDisplayPropertySet 'ComputerName','OSVersion','Cores','RAM' -force

Update-TypeData -TypeName $myType -MemberType AliasProperty -MemberName Free `
                                  -Value SysDriveFreeSpace -force 

Update-TypeData -TypeName $myType -MemberType ScriptMethod -MemberName Ping `
                                  -Value { 
                                    Test-NetConnection $this.computername 
                                   } -force 

Update-TypeData -TypeName $myType -MemberType ScriptProperty -MemberName `
                              TopProcesses -Value { 
                              Get-Process -ComputerName $this.computername |
                              Sort-Object -Property WorkingSet -Descending |
                              Select-Object -first 5
                              } -force



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FOLDERS_that_do_not_inherit_permissions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FOLDERS_that_do_not_inherit_permissions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

=========================
https://stackoverflow.com/questions/25126877/getting-names-of-folders-that-do-not-inherit-permissions

'CMD
&gt;DIR "C:\temp" -directory -recurse | GET-ACL | where {$_.Access.IsInherited -eq $false}

'POWERSHELL:
'The concept is: if a folder has at least 1 inherited access rule, 
'	then inheritance is enabled, 
'	if it has 0 inherited rules, inheritance is disabled.
&gt; Get-ChildItem C:\temp -recurse | Select @{Name='Path';Expression={$_.FullName}},@{Name='InheritedCount';Expression={(Get-Acl $_.FullName | Select -ExpandProperty Access | Where { $_.IsInherited }).Count}} | Where { $_.InheritedCount -eq 0 } | Select Path

=================================================================

'	You can use Add-Member to add the path as a property on each ACE object:
'	I also wrapped Get-Acl in a try block because it throws terminating errors.
dir c:\temp -Directory -Recurse | ForEach-Object {
    $Path = $_.FullName
    try {
        Get-Acl $Path | 
            select -ExpandProperty Access | 
            where { $_.IsInherited -eq $false } | 
            Add-Member -MemberType NoteProperty -Name Path -Value $Path -PassThru
    }
    catch {
        Write-Error $_
    }
}

================================================================
#'https://www.experts-exchange.com/questions/28395713/How-to-enumerate-which-folders-are-not-inheriting-permissions-from-parent-folder.html

NOTE: the output did not make sense, it only listed the subfolders, not sub-sub folders
	  and the output did not match what I was observing in the permissions

#requires -version 3

$Path = "c:\temp"
$Folders = Get-ChildItem $Path -Directory -Recurse
$statuses = @()

Foreach ($Folder in $Folders)
{
    $ACLs = Get-Acl -Path $Folder.fullname | ForEach-Object { $_.Access }
    Foreach ($ACL in $ACLs)
    {
        if (!($ACL.IsInherited))
        {
                $status = [ordered]@{ 
                FolderPath = $Folder.Fullname;
                IsInherited = $ACL.IsInherited;
                InheritanceFlags = $ACL.InheritanceFlags;
                PropagationFlags = $ACL.PropagationFlags }
            $statuses += (New-Object -TypeName PSObject -Property $status)
            break;
        }
        
    }
}
$statuses | Export-Csv -Path c:\temp\report.csv -Encoding ASCII -NoTypeInformation </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Format_Commands_to_change_output_vie</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>format-table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Format_Commands_to_change_output_vie</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>format-table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'Select the fields and order
&gt;dir c:\work\*.dat | format-table -property Fullname,length,lastwritetime

#'With a custom property
&gt;&gt;Get-Process Notepad | Format-Table ProcessName, @{Label="TotalRunningTime"; Expression={(Get-Date) - $_.StartTime}}

#'Custom property
&gt;dir c:\work\*.dat | format-table -property Fullname,Name,
@{Name="Size";Expression={$_.length}},lastwritetime,
@{Name="Age(Days)";Expression = { (Get-Date)-$_.lastwritetime | Select -ExpandProperty TotalDays }}

#'Sort than Group By:
&gt;get-vegetable | sort color | format-table -GroupBy color -Property UPC,Count,Name,IsRoot

#' Group the objects by extensions, then take the group object and get the sums of the sizes
#' so at the end of the pipeline you have 'Group-info' objects, not file objects
&gt;dir c:\work -file -recurse | Group Extension | 
Select Count,Name,
@{Name="TotalKB";expression={$_.group | measure length -sum | select -ExpandProperty sum}} |
format-table -group Name -Property Count,TotalKB</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Help</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>example</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Help</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>example</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'You do not have to use all-uppercase letters, but the period preceding each help keyword 
'	(.SYNOPSIS, .DESCRIPTION) must be in the first column. 
 



# completed...
function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Write-Verbose "Connecting to $computer over $protocol"
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option
  
        Write-Verbose "Querying from $computer"
        $os_params = @{'ClassName'='Win32_OperatingSystem'
                       'CimSession'=$session}
        $os = Get-CimInstance @os_params

        $cs_params = @{'ClassName'='Win32_ComputerSystem'
                       'CimSession'=$session}
        $cs = Get-CimInstance @cs_params

        $sysdrive = $os.SystemDrive
        $drive_params = @{'ClassName'='Win32_LogicalDisk'
                          'Filter'="DeviceId='$sysdrive'"
                          'CimSession'=$session}
        $drive = Get-CimInstance @drive_params

        $proc_params = @{'ClassName'='Win32_Processor'
                         'CimSession'=$session}
        $proc = Get-CimInstance @proc_params |
                Select-Object -first 1

  
        Write-Verbose "Closing session to $computer"
        $session | Remove-CimSession
  
        Write-Verbose "Outputting for $computer"
        $obj = [pscustomobject]@{'ComputerName'=$computer
                   'OSVersion'=$os.version
                   'SPVersion'=$os.servicepackmajorversion
                   'OSBuild'=$os.buildnumber
                   'Manufacturer'=$cs.manufacturer
                   'Model'=$cs.model
                   'Procs'=$cs.numberofprocessors
                   'Cores'=$cs.numberoflogicalprocessors
                   'RAM'=($cs.totalphysicalmemory / 1GB)
                   'Arch'=$proc.addresswidth
                   'SysDriveFreeSpace'=$drive.freespace}
        Write-Output $obj
 
    } #foreach
} #PROCESS

END {}

} #function



# prettier...
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.

.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.

.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.

.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.

.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.

.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.

.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.

.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;



# more sections...
&lt;#
.INPUTS
System.String

.NOTES
version     : 1.0.0
last updated: 1 February, 2017

.LINK
https://powershell.org/forums/
.LINK
Get-CimInstance
.LINK
Get-WmiObject

#&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>HELP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>HELP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Example of getting help for 'Get-Command'
&gt; Get-Help Get-Command

&gt;Update-Help  {to get the updates}

#region Cmdlets

	# Get-Command - Retrieves a list of all system commands
	Get-Command
	
	# Can expand by searching for just a verb or noun
	Get-Command -verb "get"
	Get-Command -noun "service"
	
	# Get-Help can be used to explain a command 
	Get-Help Get-Command
	Get-Help Get-Command -examples		#show all the examples
	Get-Help Get-Command -detailed
	Get-Help Get-Command -full
	Get-Help Get-Command -Online   # PS 3 - VERY good for reading - This brings up default browser, and help on the command
	
	# Most commands can also be passed a -? paramter to get help
	Get-Command -?

#endregion Cmdlets



Get-Help 'cmdlet displays information
'The cmdlet has also an Aliases set in the shell by default as 'help' and 'man'. 

'We can also limit to what type of information we may want with the –Category parameter

  help -Category Cmdlet -Name *service*
  
  'One can select what parts of a help file we want to see by specifying the parameter for the level of information one wants

–Detailed 		'parameter is given it will show Parameter information and Examples.
–Full 			'parameter is given it will show a more detailed list of info for Parameters.
–Examples 		'parameter is given only examples are shown.
-full 			'option is used we get additional information on the parameters:

'Syntax

Required for required options or values ==&gt; they will not be enclosed in any bracket.
Options or values enclosed in [ ] are optional
Values are represent with the type they take between &lt; &gt;
Those values that can be lists are represented as &lt;type[ ]&gt; 
Those that have a predefined list of options it can take are represented as &lt; option1 | option2 | option3&gt;


'With PowerShell v3 the
 –ShowWindow 			'parameter was added to open a separate window that can be used as reference while one works construction a command
 
&gt; help about      	'This will list all conceptual topics.


Get-Verb 			'cmdlet to get the list of approved verbs for PowerShell. 

Get-Command 		'gets the commands from Windows PowerShell modules 

=======================================================================


' Using help optional parmameters and their values are shown in brackets
==========================================================================

' No mandatory params
(Get-Help -Name Get-Service -Detailed).syntax			'&lt;=== This requests help on the syntax

' Only Path is mandatory
(Get-Help -Name Get-Content -Detailed).syntax

'Get-Command to find Mandatory parameters in cmdlets
'Note can run this up to each period "." in the ISE to see what that part does
(Get-Command -Name 'Get-Content').Parameters.Path.Attributes

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>URL_WSDL_LookUp</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>URL_WSDL_LookUp</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.reddit.com/r/sysadmin/comments/2ls3ny/best_way_to_find_computer_age/

The basic to get the warranty info back from Dell, though is:
$Serial="XYZ" #(Would likely pipe this from a list or WMI
$proxy = New-WebServiceProxy -URI "http://xserv.dell.com/services/assetservice.asmx?WSDL" if (!$?) { Write-Error "Error accessing webservice" -warning; continue } $proxy.Url = "http://xserv.dell.com/services/AssetService.asmx" $WarrantyInformation = $proxy.GetAssetInformation(([guid]::NewGuid()).Guid, 'DellWarranty', $Serial) | Select-Object -ExpandProperty Entitlements
$WarrantyInformation.startdate | sort -unique | select -first 1


--==============


Workaround appears to be registering with techdirect.dell.com ( https://techdirect.dell.com/portal.30/Login.aspx ) and receiving an API key.
Then you can run something like:
Invoke-RestMethod -URI "https://api.dell.com/support/v2/assetinfo/header/tags.xml?svcta</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Computer_Age_using_WSDL_Lookup</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Computer_Age_using_WSDL_Lookup</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.reddit.com/r/sysadmin/comments/2ls3ny/best_way_to_find_computer_age/


'http://poshcode.org/4121 is a script I had at some point, though I'd use the below over that. I think the one I actually use now is slightly different but same API, I merged my HP and Dell lookups.
'The basic to get the warranty info back from Dell, though is:

$Serial="XYZ" #(Would likely pipe this from a list or WMI
$proxy = New-WebServiceProxy -URI "http://xserv.dell.com/services/assetservice.asmx?WSDL" if (!$?) { Write-Error "Error accessing webservice" -warning; continue } $proxy.Url = "http://xserv.dell.com/services/AssetService.asmx" $WarrantyInformation = $proxy.GetAssetInformation(([guid]::NewGuid()).Guid, 'DellWarranty', $Serial) | Select-Object -ExpandProperty Entitlements
$WarrantyInformation.startdate | sort -unique | select -first 1

'the last line would then give you your start date of your Dell warranty. You could pipe the list of serial #s by querying AD and polling each for WMI, but the preferred way in this case would be a list of system serial #s that you may have from another system, as then you wouldn't be dependent upon that system actually being online at the time to do the lookup of serial #. I have a powershell script to do similar w/ HP but it's a lot more involved.
'I personally use this for almost the same purpose--aging systems that are up for replacement--but we go by warranty expiration so it's the opposite date I am looking at. The only caveat on that end w/ Dell lookups is they include a super-long "Dell Digitial Delivery" period with a service level code "D" and "dell" entitlement type comes back with code "DL" that's also just a few days after the end of all entitlements; so you have to exclude warranty types with servicelevelcode set to "DL" or "D" to be really accurate. For start date it shouldn't matter, though.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-SubNetItems.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-SubNetItems.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Get-SubNetItems.ps1
'https://gallery.technet.microsoft.com/scriptcenter/SubNet-Scan-dad0311f

I ended up putting this in the MyFunctions Module


'This file Get-SubNetItems.ps1 contains only definition of Get-SubNetItems function. To use this tool try this:
'1) Load file with cmdlet definition. Don't forget first . It is important to load the cmdlets in the current namespace.
'PS&gt;. P:\Get-SubNetIte​ms.ps1

'2) And next try use function.

'Basic
PS&gt;Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.10
'Formated
Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.10 | Format-Table -Property Host, IP, OS_Name, OS_Ver, WMI  -AutoSize
'To File
Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.254 | Format-Table -Property Host, IP, OS_Name, OS_Ver, WMI  -AutoSize | Out-File C:\ListOfComputers.txt
===================================================================================
Function Get-SubNetItems
{
&lt;# 
	.SYNOPSIS 
		Scan subnet machines
		
	.DESCRIPTION 
		Use Get-SubNetItems to receive list of machines in specific IP range.

	.PARAMETER StartScanIP 
		Specify start of IP range.

	.PARAMETER EndScanIP
		Specify end of IP range.

	.PARAMETER Ports
		Specify ports numbers to scan if open or not.
		
	.PARAMETER MaxJobs
		Specify number of threads to scan.
		
	.PARAMETER ShowAll
		Show even adress is inactive.
	
	.PARAMETER ShowInstantly 
		Show active status of scaned IP address instanly. 
	
	.PARAMETER SleepTime  
		Wait time to check if threads are completed.
 
	.PARAMETER TimeOut 
		Time out when script will be break.

	.EXAMPLE 
		PS C:\&gt;$Result = Get-SubNetItems -StartScanIP 10.10.10.1 -EndScanIP 10.10.10.10 -ShowInstantly -ShowAll
		10.10.10.7 is active.
		10.10.10.10 is active.
		10.10.10.9 is active.
		10.10.10.1 is inactive.
		10.10.10.6 is active.
		10.10.10.4 is active.
		10.10.10.3 is inactive.
		10.10.10.2 is active.
		10.10.10.5 is active.
		10.10.10.8 is inactive.

		PS C:\&gt; $Result | Format-Table IP, Active, WMI, WinRM, Host, OS_Name -AutoSize

		IP           Active   WMI WinRM Host              OS_Name
		--           ------   --- ----- ----              -------
		10.10.10.1    False False False
		10.10.10.2     True  True  True pc02.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.3    False False False
		10.10.10.4     True  True  True pc05.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.5     True  True  True pc06.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.6     True  True  True pc07.mydomain.com Microsoft(R) Windows(R) Server 2003, Standard Edition
		10.10.10.7     True False False
		10.10.10.8    False False False
		10.10.10.9     True  True False pc09.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.10    True  True False pc10.mydomain.com Microsoft Windows XP Professional

	.EXAMPLE 
		PS C:\&gt; Get-SubNetItems -StartScanIP 10.10.10.2 -Verbose
		VERBOSE: Creating own list class.
		VERBOSE: Start scaning...
		VERBOSE: Starting job (1/20) for 10.10.10.2.
		VERBOSE: Trying get part of data.
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (0)
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (5)
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (10)
		VERBOSE: Trying get last part of data.
		VERBOSE: Geting job 10.10.10.2 result.
		VERBOSE: Removing job 10.10.10.2.
		VERBOSE: Scan finished.


		RunspaceId : d2882105-df8c-4c0a-b92c-0d078bcde752
		Active     : True
		Host       : pc02.mydomain.com
		IP         : 10.10.10.2
		OS_Name    : Microsoft Windows Server 2008 R2 Enterprise
		OS_Ver     : 6.1.7601 Service Pack 1
		WMI        : True
		WinRM      : True
		
	.EXAMPLE 	
		PS C:\&gt; $Result = Get-SubNetItems -StartScanIP 10.10.10.1 -EndScanIP 10.10.10.25 -Ports 80,3389,5900	

		PS C:\&gt; $Result | Select-Object IP, Host, MAC, @{l="Ports";e={[string]::join(", ",($_.Ports | Select-Object @{Label="Ports";Expression={"$($_.Port)-$($_.Status)"}} | Select-Object -ExpandProperty Ports))}} | Format-Table * -AutoSize
		
		IP          Host              MAC               Ports
		--          ----              ---               -----
		10.10.10.1                                      80-False, 3389-False, 5900-False
		10.10.10.2  pc02.mydomain.com 00-15-AD-0C-82-20 80-True, 3389-False, 5900-False
		10.10.10.5  pc05.mydomain.com 00-15-5D-1C-80-25 80-True, 3389-False, 5900-False
		10.10.10.7  pc07.mydomain.com 00-15-4D-0C-81-04 80-True, 3389-True, 5900-False
		10.10.10.9  pc09.mydomain.com 00-15-4A-0C-80-31 80-True, 3389-True, 5900-False
		10.10.10.10 pc10.mydomain.com 00-15-5D-02-1F-1C 80-False, 3389-True, 5900-False

	.NOTES 
		Author: Michal Gajda
		
		ChangeLog:
		v1.3
		-Scan items in subnet for MAC
		-Basic port scan on items in subnet
		-Fixed some small spelling bug
		
		v1.2
		-IP Range Ganerator upgrade
		
		v1.1
		-ProgressBar upgrade
		
		v1.0:
		-Scan subnet for items
		-Scan items in subnet for WMI Access
		-Scan items in subnet for WinRM Access
#&gt;

	[CmdletBinding(
		SupportsShouldProcess=$True,
		ConfirmImpact="Low" 
	)]	
	param(
		[parameter(Mandatory=$true)]
		[System.Net.IPAddress]$StartScanIP,
		[System.Net.IPAddress]$EndScanIP,
		[Int]$MaxJobs = 20,
		[Int[]]$Ports,
		[Switch]$ShowAll,
		[Switch]$ShowInstantly,
		[Int]$SleepTime = 5,
		[Int]$TimeOut = 90
	)

	Begin{}

	Process
	{
		if ($pscmdlet.ShouldProcess("$StartScanIP $EndScanIP" ,"Scan IP range for active machines"))
		{
			if(Get-Job -name *.*.*.*)
			{
				Write-Verbose "Removing old jobs."
				Get-Job -name *.*.*.* | Remove-Job -Force
			}
			
			$ScanIPRange = @()
			if($EndScanIP -ne $null)
			{
				Write-Verbose "Generating IP range list."
				# Many thanks to Dr. Tobias Weltner, MVP PowerShell and Grant Ward for IP range generator
				$StartIP = $StartScanIP -split '\.'
	  			[Array]::Reverse($StartIP)  
	  			$StartIP = ([System.Net.IPAddress]($StartIP -join '.')).Address 
				
				$EndIP = $EndScanIP -split '\.'
	  			[Array]::Reverse($EndIP)  
	  			$EndIP = ([System.Net.IPAddress]($EndIP -join '.')).Address 
				
				For ($x=$StartIP; $x -le $EndIP; $x++) {    
					$IP = [System.Net.IPAddress]$x -split '\.'
					[Array]::Reverse($IP)   
					$ScanIPRange += $IP -join '.' 
				}
			
			}
			else
			{
				$ScanIPRange = $StartScanIP
			}

			Write-Verbose "Creating own list class."
			$Class = @"
			public class SubNetItem {
				public bool Active;
				public string Host;
				public System.Net.IPAddress IP;
				public string MAC;
				public System.Object Ports;
				public string OS_Name;
				public string OS_Ver;
				public bool WMI;
				public bool WinRM;
			}
"@		

			Write-Verbose "Start scaning..."	
			$ScanResult = @()
			$ScanCount = 0
			Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete (0)
			Foreach($IP in $ScanIPRange)
			{
	 			Write-Verbose "Starting job ($((Get-Job -name *.*.*.* | Measure-Object).Count+1)/$MaxJobs) for $IP."
				Start-Job -Name $IP -ArgumentList $IP,$Ports,$Class -ScriptBlock{ 
				
					param
					(
					[System.Net.IPAddress]$IP = $IP,
					[Int[]]$Ports = $Ports,
					$Class = $Class 
					)
					
					Add-Type -TypeDefinition $Class
					
					if(Test-Connection -ComputerName $IP -Quiet)
					{
						#Get Hostname
						Try
						{
							$HostName = [System.Net.Dns]::GetHostbyAddress($IP).HostName
						}
						Catch
						{
							$HostName = $null
						}
						
						#Get WMI Access, OS Name and version via WMI
						Try
						{
							#I don't use Get-WMIObject because it havent TimeOut options. 
							$WMIObj = [WMISearcher]''  
							$WMIObj.options.timeout = '0:0:10' 
							$WMIObj.scope.path = "\\$IP\root\cimv2"  
							$WMIObj.query = "SELECT * FROM Win32_OperatingSystem"  
							$Result = $WMIObj.get()  

							if($Result -ne $null)
							{
								$OS_Name = $Result | Select-Object -ExpandProperty Caption
								$OS_Ver = $Result | Select-Object -ExpandProperty Version
								$OS_CSDVer = $Result | Select-Object -ExpandProperty CSDVersion
								$OS_Ver += " $OS_CSDVer"
								$WMIAccess = $true					
							}
							else
							{
								$WMIAccess = $false	
							}
						}	
						catch
						{
							$WMIAccess = $false					
						}
						
						#Get WinRM Access, OS Name and version via WinRM
						if($HostName)
						{
							$Result = Invoke-Command -ComputerName $HostName -ScriptBlock {systeminfo} -ErrorAction SilentlyContinue 
						}
						else
						{
							$Result = Invoke-Command -ComputerName $IP -ScriptBlock {systeminfo} -ErrorAction SilentlyContinue 
						}
						
						if($Result -ne $null)
						{
							if($OS_Name -eq $null)
							{
								$OS_Name = ($Result[2..3] -split ":\s+")[1]
								$OS_Ver = ($Result[2..3] -split ":\s+")[3]
							}	
							$WinRMAccess = $true
						}
						else
						{
							$WinRMAccess = $false
						}
						
						#Get MAC Address
						Try
						{
							$result= nbtstat -A $IP | select-string "MAC"
							$MAC = [string]([Regex]::Matches($result, "([0-9A-F][0-9A-F]-){5}([0-9A-F][0-9A-F])"))
						}
						Catch
						{
							$MAC = $null
						}
						
						#Get ports status
						$PortsStatus = @()
						ForEach($Port in $Ports)
						{
							Try
							{							
								$TCPClient = new-object Net.Sockets.TcpClient
								$TCPClient.Connect($IP, $Port)
								$TCPClient.Close()
								
								$PortStatus = New-Object PSObject -Property @{            
		        					Port		= $Port
									Status      = $true
								}
								$PortsStatus += $PortStatus
							}	
							Catch
							{
								$PortStatus = New-Object PSObject -Property @{            
		        					Port		= $Port
									Status      = $false
								}	
								$PortsStatus += $PortStatus
							}
						}

						
						$HostObj = New-Object SubNetItem -Property @{            
		        					Active		= $true
									Host        = $HostName
									IP          = $IP 
									MAC         = $MAC
									Ports       = $PortsStatus
		        					OS_Name     = $OS_Name
									OS_Ver      = $OS_Ver               
		        					WMI         = $WMIAccess      
		        					WinRM       = $WinRMAccess      
		        		}
						$HostObj
					}
					else
					{
						$HostObj = New-Object SubNetItem -Property @{            
		        					Active		= $false
									Host        = $null
									IP          = $IP  
									MAC         = $null
									Ports       = $null
		        					OS_Name     = $null
									OS_Ver      = $null               
		        					WMI         = $null      
		        					WinRM       = $null      
		        		}
						$HostObj
					}
				} | Out-Null
				$ScanCount++
				Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
				
				do
				{
					Write-Verbose "Trying get part of data."
					Get-Job -State Completed | Foreach {
						Write-Verbose "Geting job $($_.Name) result."
						$JobResult = Receive-Job -Id ($_.Id)

						if($ShowAll)
						{
							if($ShowInstantly)
							{
								if($JobResult.Active -eq $true)
								{
									Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
								}
								else
								{
									Write-Host "$($JobResult.IP) is inactive." -ForegroundColor Red
								}
							}
							
							$ScanResult += $JobResult	
						}
						else
						{
							if($JobResult.Active -eq $true)
							{
								if($ShowInstantly)
								{
									Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
								}
								$ScanResult += $JobResult
							}
						}
						Write-Verbose "Removing job $($_.Name)."
						Remove-Job -Id ($_.Id)
						Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
					}
					
					if((Get-Job -name *.*.*.*).Count -eq $MaxJobs)
					{
						Write-Verbose "Jobs are not completed ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs), please wait..."
						Sleep $SleepTime
					}
				}
				while((Get-Job -name *.*.*.*).Count -eq $MaxJobs)
			}
			
			$timeOutCounter = 0
			do
			{
				Write-Verbose "Trying get last part of data."
				Get-Job -State Completed | Foreach {
					Write-Verbose "Geting job $($_.Name) result."
					$JobResult = Receive-Job -Id ($_.Id)

					if($ShowAll)
					{
						if($ShowInstantly)
						{
							if($JobResult.Active -eq $true)
							{
								Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
							}
							else
							{
								Write-Host "$($JobResult.IP) is inactive." -ForegroundColor Red
							}
						}
						
						$ScanResult += $JobResult	
					}
					else
					{
						if($JobResult.Active -eq $true)
						{
							if($ShowInstantly)
							{
								Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
							}
							$ScanResult += $JobResult
						}
					}
					Write-Verbose "Removing job $($_.Name)."
					Remove-Job -Id ($_.Id)
					Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
				}
				
				if(Get-Job -name *.*.*.*)
				{
					Write-Verbose "All jobs are not completed ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs), please wait... ($timeOutCounter)"
					Sleep $SleepTime
					$timeOutCounter += $SleepTime				

					if($timeOutCounter -ge $TimeOut)
					{
						Write-Verbose "Time out... $TimeOut. Can't finish some jobs  ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs) try remove it manualy."
						Break
					}
				}
			}
			while(Get-Job -name *.*.*.*)
			
			Write-Verbose "Scan finished."
			Return $ScanResult | Sort-Object {"{0:d3}.{1:d3}.{2:d3}.{3:d3}" -f @([int[]]([string]$_.IP).split('.'))}
		}
	}
	
	End{}
}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_d_Select</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_d_Select</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Example_1_d_Select_properties


'use 'Select' (i.e. the alias) or 'Select-Object' (the full command name)
'To just select the 'Name' property:0
&gt;Get-Vegetable | Select -property Name

'OUTPUT
Name       
----       
corn       
tomato     
cucumber   
carrot     
radish     
peas       
turnip     
potato     
broccoli   
zucchini   
spinach    
cauliflower
pepper     
pepper     
pepper     
eggplant  

'And you can give the 'select' command a comma-delimited list:
Get-Vegetable | Select Name,Count,State
'NOTE 'State' would not return anything b/c if you look in the list above of properties, 'State' is not listed
'Rather use 'CookedState' which is the real name of the property

'To get all the properties that start w/ 'C' you can use a wild card:
Get-Vegetable | Select Name,C*

'To get the first root vegetable object:
&gt;Get-Vegetable -RootOnly | Select -First 1
--------------------------------------------------------------------------
'If you want to get a list of the property names, just select 1 object:
&gt;Get-Vegetable  | Select -First 1 -Property *
'OUTPUT

Name        : corn
Count       : 4
UPC         : 4945
CookedState : Roasted
IsRoot      : False
IsPeeled    : False
Color       : yellow
--------------------------------------------------------------------------
'To get the list of unique names: NOTE this is still outputting OBJECTS
&gt;Get-Vegetable | Select Name -Unique

'To get it to output TEXT, you have to expand the property
'This would look the same, but it would be TEXT
&gt;Get-Vegetable | Select -Unique -ExpandProperty Name


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_e_Expand_to_text</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_e_Expand_to_text</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'To get it to output TEXT, you have to expand the property
'This would look the same, but it would be TEXT
&gt;Get-Vegetable | Select -Unique -ExpandProperty Name</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_f_Group_Objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_f_Group_Objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
-------------------------------------------------------------------------GROUP

'Group-Object outputs a new type of object
Get-Vegetable | Group-Object -Property color
'OUTPUT
Count Name                      Group                                                                                                                                    
----- ----                      -----                                                                                                                                    
    2 yellow                    {Vegetable, Vegetable}                                                                                                                   
    3 red                       {Vegetable, Vegetable, Vegetable}                                                                                                        
    6 green                     {Vegetable, Vegetable, Vegetable, Vegetable...}                                                                                          
    1 orange                    {Vegetable}                                                                                                                              
    2 purple                    {Vegetable, Vegetable}                                                                                                                   
    1 brown                     {Vegetable}                                                                                                                              
    1 white                     {Vegetable}     
    
    'You can even see they MemberType of the new type of object:
&gt;Get-Vegetable | Group-Object -Property color | Get-Member
'OUTPUT
   TypeName: Microsoft.PowerShell.Commands.GroupInfo

Name        MemberType Definition                                                      
----        ---------- ----------                                                      
Equals      Method     bool Equals(System.Object obj)                                  
GetHashCode Method     int GetHashCode()                                               
GetType     Method     type GetType()                                                  
ToString    Method     string ToString()                                               
Count       Property   int Count {get;}                                                
Group       Property   System.Collections.ObjectModel.Collection[psobject] Group {get;}
Name        Property   string Name {get;}                                              
Values      Property   System.Collections.ArrayList Values {get;}   

'you can then work with that new object type, and sort it
Get-Vegetable | Group color | sort count -Descending
'OUTPUT:
Count Name                      Group                                                                                                                                    
----- ----                      -----                                                                                                                                    
    6 green                     {Vegetable, Vegetable, Vegetable, Vegetable...}                                                                                          
    3 red                       {Vegetable, Vegetable, Vegetable}                                                                                                        
    2 yellow                    {Vegetable, Vegetable}                                                                                                                   
    2 purple                    {Vegetable, Vegetable}                                                                                                                   
    1 orange                    {Vegetable}                                                                                                                              
    1 brown                     {Vegetable}                                                                                                                              
    1 white                     {Vegetable} 

'Now to actually see the names of the vegetables in the first of those new objects 

&gt;Get-Vegetable | Group color | sort count -Descending | select -first 1 -ExpandProperty group
'OUTPUT:
UPC     Count Name          State    Color     
---     ----- ----          -----    -----     
4722        1 cucumber      Raw      green     
4518       13 peas          Steamed  green     
4190       14 broccoli      Steamed  green     
4061       15 zucchini      Raw      green     
4483       16 spinach       Raw      green     
4723       16 pepper        Sauteed  green    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_i_Measure-Object_to_get_Count_and_Sum</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_i_Measure-Object_to_get_Count_and_Sum</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'1]: what the objects look like
&gt;Get-Vegetable -RootOnly
'OUTPUT
'==========================================
#'UPC     Count Name          State    Color     
#'---     ----- ----          -----    -----     
#'4782        5 carrot        Raw      orange    
#'4660        4 radish        Raw      red       
#'4481       16 turnip        Boiled   purple    
#'4916        8 potato        Fried    brown
     

'2] using 'Measure-Object' to get Count and Sum
&gt;Get-Vegetable -RootOnly | Measure-Object -Property count -Sum
'OUTPUT
'==========================================
#'Count    : 4
#'Average  : 
#'Sum      : 33
#'Maximum  : 
#'Minimum  : 
#'Property : Count


'3] look at the object coming out of the pipe:
&gt;Get-Vegetable -RootOnly | Measure count -sum | get-member
'OUTPUT
'==========================================
#'   TypeName: Microsoft.PowerShell.Commands.GenericMeasureInfo
#'
#'Name        MemberType Definition                                
#'----        ---------- ----------                                
#'Equals      Method     bool Equals(System.Object obj)            
#'GetHashCode Method     int GetHashCode()                         
#'GetType     Method     type GetType()                            
#'ToString    Method     string ToString()                         
#'Average     Property   System.Nullable[double] Average {get;set;}
#'Count       Property   int Count {get;set;}                      
#'Maximum     Property   System.Nullable[double] Maximum {get;set;}
#'Minimum     Property   System.Nullable[double] Minimum {get;set;}
#'Property    Property   string Property {get;set;}                
#'Sum         Property   System.Nullable[double] Sum {get;set;}
#'
   

'4] To just capture the 'sum' property and convert it to text:
Get-Vegetable -RootOnly | Measure count -sum | Select -ExpandProperty sum
'OUTPUT
'==========================================
#'33   </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_k_PropertyExpanding_to_text</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_k_PropertyExpanding_to_text</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'Objects come down the pipeline.
'Sometimes the object coming down the pipeline is a nested object
'Sometimes the object coming down the pipeline is an array, or array of nested objects

'This gets rid of the object and just gives us that property, but can only expand 1 property at a time
&gt;Get-Service winrm | Select -ExpandProperty RequiredServices
'OUTPUT
#'Status   Name               DisplayName                           
#'------   ----               -----------                           
#'Running  RPCSS              Remote Procedure Call (RPC)           
#'Running  HTTP               HTTP Service         
==============================================================
'1] when you do this to a list of objects with a single property "name" you get this:
'you get this in the text file:
'OUTPUT
=========
Name      '&lt;==== you get the name header 
----       
corn       
tomato     
cucumber   
carrot     
radish     
peas       
turnip     
potato     
broccoli   
zucchini   
spinach    
cauliflower
pepper     
eggplant   


'2] however if you expand the field you get this:
&gt;Get-Vegetable | Select -expandproperty Name -Unique
'OUTPUT
=========
corn     '&lt;==== you don't get the name header, b/c it is not an object
tomato     
cucumber   
carrot     
radish     
peas       
turnip     
potato     
broccoli   
zucchini   
spinach    
cauliflower
pepper     
eggplant

=============================================================
&gt;help Get-Vegetable -Parameter name

#'-Name &lt;String&gt;
#'    The name of a vegetable
#'    
#'    Required?                    false
#'    Position?                    0
#'    Default value                None
#'    Accept pipeline input?       True (ByPropertyName, ByValue) &lt;====
#'    Accept wildcard characters?  true
#'   

 'If you do this it won't work, b/c it is sending 'objects' with hidden characters to the file
 ' qne the parm needs a string
&gt;Get-Vegetable | Select Name -Unique | out-file c:\work\veglist.txt
&gt;get-content c:\work\veglist.txt | Where {$_ -like "c*"} | Get-Vegetable


'You can send the text into a file by expanding it
&gt;Get-Vegetable | Select -expandproperty Name -Unique | out-file c:\work\veglist.txt
&gt;get-content c:\work\veglist.txt | Where {$_ -like "c*"} | Get-Vegetable
'So now the names (that are text) are being piped back into the commandlet as a Parm

'Or pull the text directly, and then send it as a Parm to the commandlet
&gt;Get-Vegetable | Select -expandproperty Name -Unique | Where {$_ -like "c*"} |  Get-Vegetable

'OUTPUT
=======
#'UPC     Count Name          State    Color     
#'---     ----- ----          -----    -----     
#'4432        6 corn          Roasted  yellow    
#'4262        9 cucumber      Raw      green     
#'4166        8 carrot        Raw      orange    
#'4573       10 cauliflower   Steamed  white        


============================================================= .propertyname to expand a field
'This will output the expanded 'name' field as text
(get-vegetable).name

'Here you get a list of all the services that meet the criteria, as text, rather than objects
(get-service | where status -eq running).DisplayName | Sort | more

===============================================================================================
'NOT real clear on this
'NOTE: subitems to expand them, and then create variables out of them
								"$($_.name).txt"
								"$($_.count) entries"

get-eventlog application -EntryType Error,Warning | Group Source | foreach {
$file = Join-Path -path C:\work -ChildPath "$($_.name).txt"
"$($_.count) entries" | Out-File -FilePath $file
$_.group | foreach {
 $_ | Select TimeGenerated,EntryType | Out-File -FilePath $file -Append
 $_ | Select -ExpandProperty Message | Out-File -FilePath $file -Append
}
Get-Item $file
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Office</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Office</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Office</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Office</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Office


'you can

'Text
foreach ($computer in (

 Get-ADComputer -Filter  {OperatingSystem -Like '*SERVER*' }  | Select-Object -ExpandProperty Name
))

'or else generate txt files of computers
'Text
 Get-ADComputer -Filter  {OperatingSystem -Like '*SERVER*' }  | Select-Object -ExpandProperty Name &gt;&gt; c:\servers.txt</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Outlook</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_Mail_Profiles</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Outlook</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_Mail_Profiles</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://social.technet.microsoft.com/Forums/office/en-US/ec1e6f56-b7de-457f-9b66-7616100370ba/getitemproperty-hkcusoftwaremicrosoftoffice150outlookprofiles-gives-no-result?forum=winserverpowershell

'To see the list of MAIL profiles:
&gt; dir HKCU:\Software\Microsoft\Office\15.0\outlook\Profiles | select -ExpandProperty PSChildName

'When I look at it on my machine, it looks like the profiles key only has child keys and no values. 
'To get a list of the subkeys, you would use Get-ChildItem instead of Get-ItemProperty. 
'That being said, you should still be able to use Get-ItemProperty to get what you're after by adding an extra \* to the path:
HKCU:\Software\Microsoft\Office\15.0\outlook\Profiles\*\*</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Outlook</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Remove_Outlook_mail_profile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Outlook</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Remove_Outlook_mail_profile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1] Remote to the machine (using my local PowerShell)

	'if not able to remote to the machine then, VNC into it, and enable remote powershell on the machine first
	&gt;Enable-PSRemoting -Force
	
'2] CLOSE OUTLOOK FIRST	
	
'3] Confirm that the 'Outlook' mail profile exists:

	&gt;dir HKCU:\Software\Microsoft\Office\15.0\outlook\Profiles | select -ExpandProperty PSChildName
	'It should return 'Outlook'
	
'4] To delete all the profiles including 'Outlook':

&gt;	$reg="HKCU:\Software\Microsoft\Office\15.0\Outlook\Profiles"
	$child=(Get-ChildItem -Path $reg).name
	foreach($item in $child)
	{
	    Remove-item -Path registry::$item -Recurse #-ErrorAction Inquire -WhatIf
	}
	
'5] Then start Outlook, it comes up with a 'New Profile' pop-up window.
'	type: "Outlook" in the 'Profile Name' field, then hit [Enter]
'	The 'Add Account' window for Outlook pops up =&gt; [Next]
'	another pop-up: "You must restart Outlook for these changes to take effect"
'	[Finnish]</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Sample_Profile_0____PowerShellISEModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Sample_Profile_0____PowerShellISEModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

Function gig-commentIt
{
 &lt;#
   .Synopsis
    This function will add a remark #' character to beginning of line
   .Description
    This function will add a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to comment out
    a section of PowerShell code. 
   .Example
    Add-RemarkedText
    adds the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ("#'" + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-commentIt

Function gig-unCommentIt
{
 &lt;#
   .Synopsis
    This function will remove a remark #' character to beginning of line
   .Description
    This function will remove a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to clean up a 
    previously commentted out section of PowerShell code. 
   .Example
    gig-unCommentIt
    Removes the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($l -replace "#'",''),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-unCommentIt


Function gig-editProfile
{

 psedit $profile

 #'ISE $profile

} #'end function gig-editProfile

Function gig-addHelp
{
  &lt;#
   .Synopsis
    This function adds help at current insertion point 
   .Example
    add-help
    adds comment based help at current insertion point 
   .Notes
    NAME:  Add-Help
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016
    HSG: WES-09-11-10
    KEYWORDS: Scripting Techniques, Windows PowerShell ISE
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $helpText = @"
 &lt;#
   .Synopsis
    This does that 
   .Description
    This function does
   .Example
    Example-
    Example- accomplishes 
   .Parameter 
    The parameter
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS:
    HSG: 
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
"@
 $psise.CurrentFile.Editor.InsertText($helpText)
} #'end function gig-addHelp

Function gig-addHeaderToScript
{
  &lt;#
   .Synopsis
    This function adds header information to a script 
   .Example
    Add-HeaderToScript
    Adds header comments to script 
   .Example 
    AH
    Uses alias to add header comments to script
   .Notes
    NAME:  Add-HeaderToScript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS: $keyword
    HSG: $hsg
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($keyword, $comment, $hsg)
 $header = @"
#' -----------------------------------------------------------------------------
#' Script: $(split-path -Path $psISE.CurrentFile.FullPath -Leaf)
#' Author: glenn garson, JPHSA
#' Date: $(Get-Date)
#' Keywords: $keyword
#' comments: $comment
#'
#' -----------------------------------------------------------------------------
"@
 $psise.CurrentFile.Editor.InsertText($header)
} #'end function gig-addHeaderToScript

Function gig-getLogNameFromDate
{
  &lt;#
   .Synopsis
    Creates a log name from date
   .Description
    This script creates a log from a date. 
   .Example
    gig-getLogNameFromDate -path "c:\jumk" -name "log"
    Creates a file name like c:\JUNK\log20100914-122019.Txt but does not
    create the file. It returns the file name to calling code.
   .Example
    gig-getLogNameFromDate -path "c:\JUNK" -name "log" -Create
    Creates a file name like c:\JUNK\log20100914-122019.Txt and
    create the file. It returns the file name to calling code.
   .Parameter path
    path to log file
   .Parameter name
    base name of log file
   .Parameter create
    switch that determines whether log file or only name is created
   .inputs
    [string]
   .outputs
    [string]
   .Notes
    NAME:  gig-getLogNameFromDate
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 16:58:06
    KEYWORDS: parameter substitution, format specifier, string substitution
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param(
  [string]$path = "c:\JUNKC:\DATA\junkPowerShellTranscripts",
  [string]$name = "log",
  [switch]$Create
 )
 $logname = "{0}\{1}{2}.{3}" -f $path,$name, `
    (Get-Date -Format yyyyMMdd-HHmmss),"Txt"
 if($create) 
  { 
   New-Item -Path $logname -ItemType file -force | out-null
   $logname
  }
 else {$logname}
} #' end function gig-getLogNameFromDate

Function gig-start_ISE_Transcript
{
  &lt;#
   .Synopsis
    This captures output from a script to a created text file
    To use the gig-start_ISE_Transcript function, add the call to the function at the bottom of your script.
   .Example

    xxxxx...{your script}
    gig-start_ISE_Transcript -logname "c:\junk\log.txt"

    Copies output from script to file named xxxxlog.txt in c:\junk folder
   .Parameter logname
    the name and path of the log file.
   .inputs
    [string]
   .outputs
    [io.file]
   .Notes
    NAME:  gig-start_ISE_Transcript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 17:27:22
    KEYWORDS:
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
  Param(
   [string]$logname = (gig-getLogNameFromDate -path $transcriptHome -name "log" -Create)
  )
  $transcriptHeader = @"
**************************************
Windows PowerShell ISE Transcript Start
Start Time: $(get-date)
UserName: $env:username
UserDomain: $env:USERDNSDOMAIN
ComputerName: $env:COMPUTERNAME
Windows version: $((Get-WmiObject win32_operatingsystem).version)
**************************************
Transcript started. Output file is $logname
"@
 $transcriptHeader &gt;&gt; $logname
 $psISE.CurrentPowerShellTab.ConsolePane.Text &gt;&gt; $logname
 “Log saved to $logname”
} #'end function gig-start_ISE_Transcript

function gig-indentText_x_spaces
{
  &lt;#
   .Synopsis
    This function will indent text in the ISE a specific number
   .Description
    This function will indent selected text in the PowerShell ISE. These are
    real spaces, not tabs. Therefore this is appropriate for situations where
    an actual tab "`t" will not work. 
   .Example
    gig-indentText_x_spaces -space 5
    moves selected text five spaces 
   .Parameter spaces
    The number of spaces to indent the selected text. Note this number cannot
    be a negative number, and this function does not "unindent" the selected text.
   .Notes
    NAME:  gig-indentText_x_spaces
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 06/11/2012 17:16:29
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-6-17-12
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param([int]$space = 1)
 $tab = " " * $space
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($tab + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'end function gig-indentText_x_spaces

Function gig-editModule
{
  &lt;#
   .Synopsis
    This opens a module stored in the $env:PSModulePath location on a new tab in ISE 
   .Description
    This function uses Get-Module to retrieve a module from $env:PSModulePath and then
    it opens the module from that location into a new tab in ISE for editing. Wildcard
    characters that resolve to a single module are supported.
   .Example
    gig-editModule PowerShellISEModule
    gig-editModule PowerShellISEModule opens the PowerShellISEModule into a new tab in the
    ISE for editing 
  .Example
    gig-editModule PowerShellISE*
    gig-editModule PowerShellISE* opens the PowerShellISEModule into a new tab in the
    ISE for editing by using a wild card character for the module name
   .Parameter Name
    The name of the module. Wild cards that resolve to a single module are supported
   .Notes
    NAME:  gig-editModule
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 18:14:19
    KEYWORDS: Scripting Techniques, Modules
    HSG: WES-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($name)
 ISE (Get-Module -ListAvailable $name).path
} #'end function gig-editModule

Function gig-toggleOutlineView
{
  &lt;#
   .Synopsis
    This function toggles the outline view in the ISE 
   .Description
    This function toggles the outline view in the ISE. It will expand 
    or collapse all functions in the current script pane.
   .Example
    gig-toggleOutlineView
    gig-toggleOutlineView will either expand or collapse all functions 
   .Notes
    NAME:  gig-toggleOutlineView
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 19:28:37
    KEYWORDS: Scripting Techniques, Modules
    HSG: wes-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 3.0
 #&gt;
 $psise.CurrentFile.Editor.ToggleOutliningExpansion()
} #'end function gig-toggleOutlineView


#'added Functions from New-ModulesDrive.ps1
#' HSG-1-20-10
Function gig-newModuleDrives
{
&lt;#
    .SYNOPSIS
    Creates two PSDrives: myMods and sysMods
    .EXAMPLE
    gig-newModuleDrives
    Creates two PSDrives: myMods and sysMods. These correspond 
    to the users' modules folder and the system modules folder respectively. 
#&gt;
 $driveNames = "myMods","sysMods"

 For($i = 0 ; $i -le 1 ; $i++)
 {
  New-PsDrive -name $driveNames[$i] -PSProvider filesystem `
  -Root ($env:PSModulePath.split(";")[$i]) -scope Global |
  Out-Null
 } #'end For
} #'end gig-newModuleDrives

Function gig-getFileSystemDrives
{
&lt;#
    .SYNOPSIS
    Displays global PS Drives that use the Filesystem provider
    .EXAMPLE
    gig-getFileSystemDrives
    Displays global PS Drives that use the Filesystem provider
#&gt;
 Get-PSDrive -PSProvider FileSystem -scope Global
} #'end gig-getFileSystemDrives

Function gig-OpenPath
{
 &lt;#
   .Synopsis
    Opens a path in Explorer 
   .Description
    Opens a path in Explorer, default path is C:\, or the first parameter is the path
   .Example
    gig-OpenPath C:\Junk
    gig-OpenPath $moduleHome 
   .Parameter Path
    The path to open in Explorer
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/26/2016 17:31:28
    KEYWORDS:
    HSG: 
   .Link
     
 #'Requires -Version 2.0
 #&gt;
  Param(
  [string]$path = "C:\"
 )
 Invoke-Item -Path $path
 }
 
#' *** Alias ***
#'if(!(Test-Path alias:ah))
#' {
#'  New-Alias -Name ah -Value add-headertoscript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:abh))
#' {
#'  New-Alias -Name abh -Value Add-SBSBookHeaderToScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ahlp))
#' {
#'  New-Alias -Name ahlp -Value add-help -Description "MrEd alias" |
#'  Out-Null
#'  }
#'  if(!(Test-Path alias:ras))
#' {
#'  New-Alias -Name ras -Value Remove-AliasFromScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:gfsd))
#' {
#'  New-Alias -Name gfsd -Value gig-getFileSystemDrives -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:cs))
#' {
#'  New-Alias -Name cs -value Copy-ScriptToNewTab -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ar))
#' {
#'  New-Alias -Name ar -value Add-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:rr))
#' {
#'  New-Alias -Name rr -value Remove-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:em))
#' {
#'  New-Alias -Name em -value Edit-Module -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:iem))
#' {
#'  New-Alias -Name iem -value Import-EveryModule -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:sov))
#' {
#'  New-Alias -Name sov -value gig-toggleOutlineView -Description "MrEd alias" |
#'  Out-Null
#'  }



#' *** Variables ***
if(!(Test-Path variable:moduleHome))
{
 new-variable -name moduleHome -value "$env:userProfile\documents\WindowsPowerShell\Modules"
}
#'if(!(Test-Path variable:backupHome))
#'{
#' new-variable -name backupHome -value "$env:userProfile\documents\WindowsPowerShell\profileBackup"
#'}

if(!(Test-Path variable:TranscriptHome))
{
 new-variable -name TranscriptHome -value "C:\DATA\junkPowerShellTranscripts"
 #' new-variable -name TranscriptHome -value "$env:userProfile\documents\WindowsPowerShell\transcript"
}

if(!(Test-Path variable:myScripts))
{
 new-variable -name myScripts -value "C:\DATA\PowerShellScripts"
}

Set-Location $myScripts

Clear-Host

Export-ModuleMember -alias * -function * -variable *</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>SAMPLE_Profile_1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>SAMPLE_Profile_1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'http://www.zerrouki.com/powershell-profile-example/


&lt;#
.SYNOPSIS
    Microsoft.PowerShell_profile.ps1 - My PowerShell profile
.DESCRIPTION
    Microsoft.PowerShell_profile - Customizes the PowerShell console
.NOTES
    File Name   : Microsoft.PowerShell_profile.ps1
    Author      : Fabrice ZERROUKI - fabricezerrouki@hotmail.com
#&gt;
Set-Location D:\Documents\xxxxxx\PERSONNEL\powerscripts
$Shell=$Host.UI.RawUI
$size=$Shell.BufferSize
$size.width=120
$size.height=3000
$Shell.BufferSize=$size
$size=$Shell.WindowSize
$size.width=120
$size.height=30
$Shell.WindowSize=$size
 
$Shell.BackgroundColor="Black"
$Shell.ForegroundColor="White"
$Shell.CursorSize=10
 
function Get-Time {return $(Get-Date | ForEach {$_.ToLongTimeString()})}
function prompt
{
    Write-Host "[" -noNewLine
    Write-Host $(Get-Time) -ForegroundColor DarkYellow -noNewLine
    Write-Host "] " -noNewLine
    Write-Host $($(Get-Location).Path.replace($home,"~")) -ForegroundColor DarkGreen -noNewLine
    Write-Host $(if ($nestedpromptlevel -ge 1) { '&gt;&gt;' }) -noNewLine
    return "&gt; "
}
 
function ll
{
    param ($dir = ".", $all = $false)
 
    $origFg = $Host.UI.RawUI.ForegroundColor
    if ( $all ) { $toList = ls -force $dir }
    else { $toList = ls $dir }
 
    foreach ($Item in $toList)
    {
        Switch ($Item.Extension)
        {
            ".exe" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".hta" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".cmd" {$Host.UI.RawUI.ForegroundColor="DarkRed"}
            ".ps1" {$Host.UI.RawUI.ForegroundColor="DarkGreen"}
            ".html" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".htm" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".7z" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".zip" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".gz" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".rar" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            Default {$Host.UI.RawUI.ForegroundColor=$origFg}
        }
        if ($item.Mode.StartsWith("d")) {$Host.UI.RawUI.ForegroundColor="Gray"}
        $item
    }
    $Host.UI.RawUI.ForegroundColor = $origFg
}
 
function Edit-HostsFile {
    Start-Process -FilePath notepad -ArgumentList "$env:windir\system32\drivers\etc\hosts"
}
 
function rdp ($ip) {
    Start-Process -FilePath mstsc -ArgumentList "/admin /w:1024 /h:768 /v:$ip"
}
 
function tail ($file) {
Get-Content $file -Wait
}
 
function whoami {
    [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
}
 
function Reload-Profile {
    @(
        $Profile.AllUsersAllHosts,
        $Profile.AllUsersCurrentHost,
        $Profile.CurrentUserAllHosts,
        $Profile.CurrentUserCurrentHost
    ) | % {
        if(Test-Path $_) {
            Write-Verbose "Running $_"
            . $_
        }
    }    
}
 
function Check-SessionArch {
    if ([System.IntPtr]::Size -eq 8) { return "x64" }
    else { return "x86" }
}
 
function Test-Port {
[cmdletbinding()]
param(
[parameter(mandatory=$true)]
[string]$Target,
[parameter(mandatory=$true)]
[int32]$Port,
[int32]$Timeout=2000
)
$outputobj=New-Object -TypeName PSobject
$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostName -Value $Target
if(Test-Connection -ComputerName $Target -Count 2) {$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "ONLINE"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "OFFLINE"}            
$outputobj | Add-Member -MemberType NoteProperty -Name PortNumber -Value $Port
$Socket=New-Object System.Net.Sockets.TCPClient
$Connection=$Socket.BeginConnect($Target,$Port,$null,$null)
$Connection.AsyncWaitHandle.WaitOne($timeout,$false) | Out-Null
if($Socket.Connected -eq $true) {$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Success"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Failed"}            
$Socket.Close | Out-Null
$outputobj | Select TargetHostName, TargetHostStatus, PortNumber, Connectionstatus | Format-Table -AutoSize
}
 
Set-Alias powergui "C:\Program Files\PowerGUI\ScriptEditor.exe"
Set-Alias grep select-string
 
$MaximumHistoryCount=1024
$IPAddress=@(Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.DefaultIpGateway})[0].IPAddress[0]
$PSVersion=$host | Select-Object -ExpandProperty Version
$PSVersion=$PSVersion -replace '^.+@\s'
$SessionArch=Check-SessionArch
$Shell.WindowTitle="PowerFab rulez! ($SessionArch)"
 
Clear-Host
 
Write-Host "`r`nsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  ssssss`tHi Fab!" -nonewline; Write-Host "`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tComputerName`t`t" -nonewline
Write-Host $($env:COMPUTERNAME) -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tIP Address`t`t" -nonewline
Write-Host $IPAddress -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss`tUserName`t`t" -nonewline
Write-Host $env:UserDomain\$env:UserName -nonewline; Write-Host "`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Version`t" -nonewline
Write-Host $PSVersion -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Session`t" -nonewline
Write-Host $SessionArch -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss`n" -ForegroundColor Yellow
 
$LogicalDisk = @()
Get-WmiObject Win32_LogicalDisk -filter "DriveType='3'" | % {
    $LogicalDisk += @($_ | Select @{n="Name";e={$_.Caption}},
    @{n="Volume Label";e={$_.VolumeName}},
    @{n="Size (Gb)";e={"{0:N2}" -f ($_.Size/1GB)}},
    @{n="Used (Gb)";e={"{0:N2}" -f (($_.Size/1GB) - ($_.FreeSpace/1GB))}},
    @{n="Free (Gb)";e={"{0:N2}" -f ($_.FreeSpace/1GB)}},
    @{n="Free (%)";e={if($_.Size) {"{0:N2}" -f (($_.FreeSpace/1GB) / ($_.Size/1GB) * 100 )} else {"NAN"} }})
  }
$LogicalDisk | Format-Table -AutoSize | Out-String</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Sample_Profile_3__PowerShellISEModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Sample_Profile_3__PowerShellISEModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

Function gig-commentIt
{
 &lt;#
   .Synopsis
    This function will add a remark #' character to beginning of line
   .Description
    This function will add a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to comment out
    a section of PowerShell code. 
   .Example
    Add-RemarkedText
    adds the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ("#'" + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-commentIt

Function gig-unCommentIt
{
 &lt;#
   .Synopsis
    This function will remove a remark #' character to beginning of line
   .Description
    This function will remove a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to clean up a 
    previously commentted out section of PowerShell code. 
   .Example
    gig-unCommentIt
    Removes the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($l -replace "#'",''),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-unCommentIt


Function gig-editProfile
{

 psedit $profile

 #'ISE $profile

} #'end function gig-editProfile

Function gig-addHelp
{
  &lt;#
   .Synopsis
    This function adds help at current insertion point 
   .Example
    add-help
    adds comment based help at current insertion point 
   .Notes
    NAME:  Add-Help
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016
    HSG: WES-09-11-10
    KEYWORDS: Scripting Techniques, Windows PowerShell ISE
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $helpText = @"
 &lt;#
   .Synopsis
    This does that 
   .Description
    This function does
   .Example
    Example-
    Example- accomplishes 
   .Parameter 
    The parameter
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS:
    HSG: 
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
"@
 $psise.CurrentFile.Editor.InsertText($helpText)
} #'end function gig-addHelp

Function gig-addHeaderToScript
{
  &lt;#
   .Synopsis
    This function adds header information to a script 
   .Example
    Add-HeaderToScript
    Adds header comments to script 
   .Example 
    AH
    Uses alias to add header comments to script
   .Notes
    NAME:  Add-HeaderToScript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS: $keyword
    HSG: $hsg
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($keyword, $comment, $hsg)
 $header = @"
#' -----------------------------------------------------------------------------
#' Script: $(split-path -Path $psISE.CurrentFile.FullPath -Leaf)
#' Author: glenn garson, JPHSA
#' Date: $(Get-Date)
#' Keywords: $keyword
#' comments: $comment
#'
#' -----------------------------------------------------------------------------
"@
 $psise.CurrentFile.Editor.InsertText($header)
} #'end function gig-addHeaderToScript

Function gig-getLogNameFromDate
{
  &lt;#
   .Synopsis
    Creates a log name from date
   .Description
    This script creates a log from a date. 
   .Example
    gig-getLogNameFromDate -path "c:\jumk" -name "log"
    Creates a file name like c:\JUNK\log20100914-122019.Txt but does not
    create the file. It returns the file name to calling code.
   .Example
    gig-getLogNameFromDate -path "c:\JUNK" -name "log" -Create
    Creates a file name like c:\JUNK\log20100914-122019.Txt and
    create the file. It returns the file name to calling code.
   .Parameter path
    path to log file
   .Parameter name
    base name of log file
   .Parameter create
    switch that determines whether log file or only name is created
   .inputs
    [string]
   .outputs
    [string]
   .Notes
    NAME:  gig-getLogNameFromDate
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 16:58:06
    KEYWORDS: parameter substitution, format specifier, string substitution
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param(
  [string]$path = "c:\JUNKC:\DATA\junkPowerShellTranscripts",
  [string]$name = "log",
  [switch]$Create
 )
 $logname = "{0}\{1}{2}.{3}" -f $path,$name, `
    (Get-Date -Format yyyyMMdd-HHmmss),"Txt"
 if($create) 
  { 
   New-Item -Path $logname -ItemType file -force | out-null
   $logname
  }
 else {$logname}
} #' end function gig-getLogNameFromDate

Function gig-start_ISE_Transcript
{
  &lt;#
   .Synopsis
    This captures output from a script to a created text file
    To use the gig-start_ISE_Transcript function, add the call to the function at the bottom of your script.
   .Example

    xxxxx...{your script}
    gig-start_ISE_Transcript -logname "c:\junk\log.txt"

    Copies output from script to file named xxxxlog.txt in c:\junk folder
   .Parameter logname
    the name and path of the log file.
   .inputs
    [string]
   .outputs
    [io.file]
   .Notes
    NAME:  gig-start_ISE_Transcript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 17:27:22
    KEYWORDS:
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
  Param(
   [string]$logname = (gig-getLogNameFromDate -path $transcriptHome -name "log" -Create)
  )
  $transcriptHeader = @"
**************************************
Windows PowerShell ISE Transcript Start
Start Time: $(get-date)
UserName: $env:username
UserDomain: $env:USERDNSDOMAIN
ComputerName: $env:COMPUTERNAME
Windows version: $((Get-WmiObject win32_operatingsystem).version)
**************************************
Transcript started. Output file is $logname
"@
 $transcriptHeader &gt;&gt; $logname
 $psISE.CurrentPowerShellTab.ConsolePane.Text &gt;&gt; $logname
 “Log saved to $logname”
} #'end function gig-start_ISE_Transcript

function gig-indentText_x_spaces
{
  &lt;#
   .Synopsis
    This function will indent text in the ISE a specific number
   .Description
    This function will indent selected text in the PowerShell ISE. These are
    real spaces, not tabs. Therefore this is appropriate for situations where
    an actual tab "`t" will not work. 
   .Example
    gig-indentText_x_spaces -space 5
    moves selected text five spaces 
   .Parameter spaces
    The number of spaces to indent the selected text. Note this number cannot
    be a negative number, and this function does not "unindent" the selected text.
   .Notes
    NAME:  gig-indentText_x_spaces
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 06/11/2012 17:16:29
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-6-17-12
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param([int]$space = 1)
 $tab = " " * $space
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($tab + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'end function gig-indentText_x_spaces

Function gig-editModule
{
  &lt;#
   .Synopsis
    This opens a module stored in the $env:PSModulePath location on a new tab in ISE 
   .Description
    This function uses Get-Module to retrieve a module from $env:PSModulePath and then
    it opens the module from that location into a new tab in ISE for editing. Wildcard
    characters that resolve to a single module are supported.
   .Example
    gig-editModule PowerShellISEModule
    gig-editModule PowerShellISEModule opens the PowerShellISEModule into a new tab in the
    ISE for editing 
  .Example
    gig-editModule PowerShellISE*
    gig-editModule PowerShellISE* opens the PowerShellISEModule into a new tab in the
    ISE for editing by using a wild card character for the module name
   .Parameter Name
    The name of the module. Wild cards that resolve to a single module are supported
   .Notes
    NAME:  gig-editModule
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 18:14:19
    KEYWORDS: Scripting Techniques, Modules
    HSG: WES-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($name)
 ISE (Get-Module -ListAvailable $name).path
} #'end function gig-editModule

Function gig-toggleOutlineView
{
  &lt;#
   .Synopsis
    This function toggles the outline view in the ISE 
   .Description
    This function toggles the outline view in the ISE. It will expand 
    or collapse all functions in the current script pane.
   .Example
    gig-toggleOutlineView
    gig-toggleOutlineView will either expand or collapse all functions 
   .Notes
    NAME:  gig-toggleOutlineView
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 19:28:37
    KEYWORDS: Scripting Techniques, Modules
    HSG: wes-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 3.0
 #&gt;
 $psise.CurrentFile.Editor.ToggleOutliningExpansion()
} #'end function gig-toggleOutlineView


#'added Functions from New-ModulesDrive.ps1
#' HSG-1-20-10
Function gig-newModuleDrives
{
&lt;#
    .SYNOPSIS
    Creates two PSDrives: myMods and sysMods
    .EXAMPLE
    gig-newModuleDrives
    Creates two PSDrives: myMods and sysMods. These correspond 
    to the users' modules folder and the system modules folder respectively. 
#&gt;
 $driveNames = "myMods","sysMods"

 For($i = 0 ; $i -le 1 ; $i++)
 {
  New-PsDrive -name $driveNames[$i] -PSProvider filesystem `
  -Root ($env:PSModulePath.split(";")[$i]) -scope Global |
  Out-Null
 } #'end For
} #'end gig-newModuleDrives

Function gig-getFileSystemDrives
{
&lt;#
    .SYNOPSIS
    Displays global PS Drives that use the Filesystem provider
    .EXAMPLE
    gig-getFileSystemDrives
    Displays global PS Drives that use the Filesystem provider
#&gt;
 Get-PSDrive -PSProvider FileSystem -scope Global
} #'end gig-getFileSystemDrives

Function gig-OpenPath
{
 &lt;#
   .Synopsis
    Opens a path in Explorer 
   .Description
    Opens a path in Explorer, default path is C:\, or the first parameter is the path
   .Example
    gig-OpenPath C:\Junk
    gig-OpenPath $moduleHome 
   .Parameter Path
    The path to open in Explorer
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/26/2016 17:31:28
    KEYWORDS:
    HSG: 
   .Link
     
 #'Requires -Version 2.0
 #&gt;
  Param(
  [string]$path = "C:\"
 )
 Invoke-Item -Path $path
 }


 function gig-LoadNetworkPSDrives
{
#'    net use G: "\\Jphsa.org\shared\Data" 
#'    net use H: "\\Jphsa.org\shared\Users\ggarson\" 
#'    net use I: "\\Jphsa-ebhost2\AnasaziFiles\" 
#'    net use M: "\\Jphsa.org\shared\Data\MIS\" 
#'    net use N: "\\Jphsa-ebfile01\e$\" 
#'    net use P: "\\Jphsa.org\shared\Users\ggarson\PROJECTS"


    New-PSDrive -Name "G" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Data" -scope Global
    New-PSDrive -Name "H" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Users\ggarson\" -scope Global
    New-PSDrive -Name "I" -PSProvider "FileSystem" -Root "\\Jphsa-ebhost2\AnasaziFiles\" -scope Global
    New-PSDrive -Name "M" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Data\MIS\" -scope Global
    New-PSDrive -Name "N" -PSProvider "FileSystem" -Root "\\Jphsa-ebfile01\e$\" -scope Global
    New-PSDrive -Name "P" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Users\ggarson\PROJECTS"-scope Global


} 
 
#' *** Alias ***
#'if(!(Test-Path alias:ah))
#' {
#'  New-Alias -Name ah -Value add-headertoscript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:abh))
#' {
#'  New-Alias -Name abh -Value Add-SBSBookHeaderToScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ahlp))
#' {
#'  New-Alias -Name ahlp -Value add-help -Description "MrEd alias" |
#'  Out-Null
#'  }
#'  if(!(Test-Path alias:ras))
#' {
#'  New-Alias -Name ras -Value Remove-AliasFromScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:gfsd))
#' {
#'  New-Alias -Name gfsd -Value gig-getFileSystemDrives -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:cs))
#' {
#'  New-Alias -Name cs -value Copy-ScriptToNewTab -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ar))
#' {
#'  New-Alias -Name ar -value Add-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:rr))
#' {
#'  New-Alias -Name rr -value Remove-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:em))
#' {
#'  New-Alias -Name em -value Edit-Module -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:iem))
#' {
#'  New-Alias -Name iem -value Import-EveryModule -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:sov))
#' {
#'  New-Alias -Name sov -value gig-toggleOutlineView -Description "MrEd alias" |
#'  Out-Null
#'  }



#' *** Variables ***
if(!(Test-Path variable:moduleHome))
{
 new-variable -name moduleHome -value "$env:userProfile\documents\WindowsPowerShell\Modules"
}
#'if(!(Test-Path variable:backupHome))
#'{
#' new-variable -name backupHome -value "$env:userProfile\documents\WindowsPowerShell\profileBackup"
#'}

if(!(Test-Path variable:TranscriptHome))
{
 new-variable -name TranscriptHome -value "C:\DATA\junkPowerShellTranscripts"
 #' new-variable -name TranscriptHome -value "$env:userProfile\documents\WindowsPowerShell\transcript"
}

if(!(Test-Path variable:myScripts))
{
 new-variable -name myScripts -value "C:\DATA\PowerShellScripts"
}

Set-Location $myScripts

Clear-Host

gig-LoadNetworkPSDrives

Export-ModuleMember -alias * -function * -variable *

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Testing for the Presence of a Registry Key and Value</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Testing for the Presence of a Registry Key and Value</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://www.jonathanmedd.net/2014/02/testing-for-the-presence-of-a-registry-key-and-value.html

#' Test for existance of key (returns True if the path exists)
Invoke-Command -ComputerName IT-103520 -ScriptBlock { Test-Path HKLM:\Software\Microsoft\WindowsStore }

#' The test above does not test for values within a key THIS DOES NOT WORK, IT RETURNS FALSE INFORMATION
Invoke-Command -ComputerName IT-103520 -ScriptBlock { Test-Path HKLM:\Software\Microsoft\WindowsStore\RemoveWindowsStore}

============================================================================================================================USAGE: on local machine
#' This tests for the string value "zJunk" 
#' under the key path "HKLM:\Software\Microsoft\WindowsStore"
#' But it does not examine the actual string value for "zJunk"
function Test-RegistryValue_4 {
								param (							
										 [parameter(Mandatory=$true)]
										 [ValidateNotNullOrEmpty()]$Path,							
										[parameter(Mandatory=$true)]
										 [ValidateNotNullOrEmpty()]$Value
										)							
                                $c = 0
                                Get-Item -Path $Path | Select-Object -ExpandProperty property | ForEach-Object { 
                                                                                                                    if ($_ -match $Value) 
                                                                                                                        { $c=1 ; return $true} 
                                                                                                                }
                                if ($c -eq 0) 
                                    {return $false}
						
							}
====USAGE: on local machine

Test-RegistryValue_4 -Path 'HKLM:\Software\Microsoft\WindowsStore' -Value 'zJunk'

#' Returns False if the key is NOT there, and True if it is (even if the key itself does not have a value)
====================================================================================================
============================================================================================================================USAGE: on Remote machine

Invoke-Command -ComputerName IT-103520 -ScriptBlock {

                                                        function Test-RegistryValue_4 {
								                                                        param (							
										                                                         [parameter(Mandatory=$true)]
										                                                         [ValidateNotNullOrEmpty()]$Path,							
										                                                        [parameter(Mandatory=$true)]
										                                                         [ValidateNotNullOrEmpty()]$Value
										                                                        )							
                                                                                        $c = 0
                                                                                        Get-Item -Path $Path | Select-Object -ExpandProperty property | ForEach-Object { 
                                                                                                                                                                            if ($_ -match $Value) 
                                                                                                                                                                                { $c=1 ; return $true} 
                                                                                                                                                                        }
                                                                                        if ($c -eq 0) 
                                                                                            {return $false}
						
							                                                        };
                                                        Test-RegistryValue_4 -Path 'HKLM:\Software\Microsoft\WindowsStore' -Value Junk
                                                        #'Test-RegistryValue_4 -Path 'HKLM:\Software\Microsoft\WindowsStore' -Value RemoveWindowsStore
                                                    }

=================================================================


							
============================================================================================================================							</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>custom_Get-MachineInfo_with_Help_and_ErrorHandling_and_LogFile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>custom_Get-MachineInfo_with_Help_and_ErrorHandling_and_LogFile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            # Did we specify protocol fallback?
            # If so, try again. If we specified logging,
            # we won't log a problem here - we'll let
            # the logging occur if this fallback also
            # fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #if logging

                Get-MachineInfo @params
            } #if protocolfallback

            # if we didn't specify fallback, but we
            # did specify logging, then log the error,
            # because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } # if write to log

        } #try/catch
 
    } #foreach
} #PROCESS

END {}

} #function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>TrustedHosts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>TrustedHosts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

http://windowsitpro.com/windows/modify-trustedhosts-powershell


'to set TrustedHosts to every machine in your domain namespace use:

&gt;Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value '*.savilltech.net'

'To set to have no trusted hosts use:

Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value ''

'To avoid the prompt to make the change add -Force, for example:

Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value '' -Force


'To read the list:
 &gt;ls WSMan:\localhost\Client\TrustedHosts
 'OR
 &gt;Get-WSManInstance -ResourceURI winrm/config/client | select -ExpandProperty TrustedHosts
 =================================
 Set-Item WSMan:\localhost\Client\TrustedHosts -value 192.168.1.13
#'This sets the value to 192.168.1.13, it also overwrites any existing values
  

#' If you want to set a subnet you can use the PowerShell wildcard character
Set-Item WSMan:\localhost\Client\TrustedHosts -value 192.168.1.*  
  
#' both the examples above will overwrite the current value of the trustedhosts property
#' to add to instead of overwriting you need to use the concatenate dynamic parameter available in the WSMAN provider
#' Thanks to @alexandair for that bit of info

set-item WSMan:\localhost\Client\TrustedHosts -Value "192.168.0.*" -Concatenate
 =================================
 'multiple machines
 
 'a] 
 &gt;winrm set winrm/config/client '@{TrustedHosts="machineA,machineB"}'
 'if anyone gets an Error: Invalid use of command line ... response, try removing the single quotation marks
  
 'b] 
 &gt; Set-Item WSMan:\localhost\Client\TrustedHosts -Value 'machineA,machineB'

'to append to the list, the -Concatenate parameter can be used

Set-Item WSMan:\localhost\Client\TrustedHosts -Value 'machineC' -Concatenate

'c]
PS C:\&gt; $current=(get-item WSMan:\localhost\Client\TrustedHosts).value
PS C:\&gt; $current+=",testdsk23,alpha123"
PS C:\&gt; set-item WSMan:\localhost\Client\TrustedHosts –value $current
  =================================
 
 'The function has a single parameter – the computername that defaults to the local machine.
 function get-trustedhost {

	[CmdletBinding()]
	
	param (
	
			[string]$computername = $env:COMPUTERNAME
			
			)
	
	if (Test-Connection -ComputerName $computername -Quiet -Count 1) {
	
			Get-WSManInstance -ResourceURI winrm/config/client -ComputerName $computername | select -ExpandProperty TrustedHosts
	
	}
	
	else {
	
	Write-Warning -Message “$computername is unreachable”
	
	}

}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Setup_My_Profile_on_New_Machine</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>05_PowerShellISEModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Setup_My_Profile_on_New_Machine</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>05_PowerShellISEModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

Function gig-commentIt
{
 &lt;#
   .Synopsis
    This function will add a remark #' character to beginning of line
   .Description
    This function will add a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to comment out
    a section of PowerShell code. 
   .Example
    Add-RemarkedText
    adds the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ("#'" + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-commentIt

Function gig-unCommentIt
{
 &lt;#
   .Synopsis
    This function will remove a remark #' character to beginning of line
   .Description
    This function will remove a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to clean up a 
    previously commentted out section of PowerShell code. 
   .Example
    gig-unCommentIt
    Removes the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($l -replace "#'",''),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-unCommentIt


Function gig-editProfile
{

 psedit $profile

 #'ISE $profile

} #'end function gig-editProfile

Function gig-addHelp
{
  &lt;#
   .Synopsis
    This function adds help at current insertion point 
   .Example
    add-help
    adds comment based help at current insertion point 
   .Notes
    NAME:  Add-Help
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016
    HSG: WES-09-11-10
    KEYWORDS: Scripting Techniques, Windows PowerShell ISE
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $helpText = @"
 &lt;#
   .Synopsis
    This does that 
   .Description
    This function does
   .Example
    Example-
    Example- accomplishes 
   .Parameter 
    The parameter
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS:
    HSG: 
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
"@
 $psise.CurrentFile.Editor.InsertText($helpText)
} #'end function gig-addHelp

Function gig-addHeaderToScript
{
  &lt;#
   .Synopsis
    This function adds header information to a script 
   .Example
    Add-HeaderToScript
    Adds header comments to script 
   .Example 
    AH
    Uses alias to add header comments to script
   .Notes
    NAME:  Add-HeaderToScript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS: $keyword
    HSG: $hsg
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($keyword, $comment, $hsg)
 $header = @"
#' -----------------------------------------------------------------------------
#' Script: $(split-path -Path $psISE.CurrentFile.FullPath -Leaf)
#' Author: glenn garson, JPHSA
#' Date: $(Get-Date)
#' Keywords: $keyword
#' comments: $comment
#'
#' -----------------------------------------------------------------------------
"@
 $psise.CurrentFile.Editor.InsertText($header)
} #'end function gig-addHeaderToScript

Function gig-getLogNameFromDate
{
  &lt;#
   .Synopsis
    Creates a log name from date
   .Description
    This script creates a log from a date. 
   .Example
    gig-getLogNameFromDate -path "c:\jumk" -name "log"
    Creates a file name like c:\JUNK\log20100914-122019.Txt but does not
    create the file. It returns the file name to calling code.
   .Example
    gig-getLogNameFromDate -path "c:\JUNK" -name "log" -Create
    Creates a file name like c:\JUNK\log20100914-122019.Txt and
    create the file. It returns the file name to calling code.
   .Parameter path
    path to log file
   .Parameter name
    base name of log file
   .Parameter create
    switch that determines whether log file or only name is created
   .inputs
    [string]
   .outputs
    [string]
   .Notes
    NAME:  gig-getLogNameFromDate
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 16:58:06
    KEYWORDS: parameter substitution, format specifier, string substitution
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param(
  [string]$path = "c:\JUNKC:\DATA\junkPowerShellTranscripts",
  [string]$name = "log",
  [switch]$Create
 )
 $logname = "{0}\{1}{2}.{3}" -f $path,$name, `
    (Get-Date -Format yyyyMMdd-HHmmss),"Txt"
 if($create) 
  { 
   New-Item -Path $logname -ItemType file -force | out-null
   $logname
  }
 else {$logname}
} #' end function gig-getLogNameFromDate

Function gig-start_ISE_Transcript
{
  &lt;#
   .Synopsis
    This captures output from a script to a created text file
    To use the gig-start_ISE_Transcript function, add the call to the function at the bottom of your script.
   .Example

    xxxxx...{your script}
    gig-start_ISE_Transcript -logname "c:\junk\log.txt"

    Copies output from script to file named xxxxlog.txt in c:\junk folder
   .Parameter logname
    the name and path of the log file.
   .inputs
    [string]
   .outputs
    [io.file]
   .Notes
    NAME:  gig-start_ISE_Transcript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 17:27:22
    KEYWORDS:
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
  Param(
   [string]$logname = (gig-getLogNameFromDate -path $transcriptHome -name "log" -Create)
  )
  $transcriptHeader = @"
**************************************
Windows PowerShell ISE Transcript Start
Start Time: $(get-date)
UserName: $env:username
UserDomain: $env:USERDNSDOMAIN
ComputerName: $env:COMPUTERNAME
Windows version: $((Get-WmiObject win32_operatingsystem).version)
**************************************
Transcript started. Output file is $logname
"@
 $transcriptHeader &gt;&gt; $logname
 $psISE.CurrentPowerShellTab.ConsolePane.Text &gt;&gt; $logname
 “Log saved to $logname”
} #'end function gig-start_ISE_Transcript

function gig-indentText_x_spaces
{
  &lt;#
   .Synopsis
    This function will indent text in the ISE a specific number
   .Description
    This function will indent selected text in the PowerShell ISE. These are
    real spaces, not tabs. Therefore this is appropriate for situations where
    an actual tab "`t" will not work. 
   .Example
    gig-indentText_x_spaces -space 5
    moves selected text five spaces 
   .Parameter spaces
    The number of spaces to indent the selected text. Note this number cannot
    be a negative number, and this function does not "unindent" the selected text.
   .Notes
    NAME:  gig-indentText_x_spaces
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 06/11/2012 17:16:29
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-6-17-12
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param([int]$space = 1)
 $tab = " " * $space
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($tab + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'end function gig-indentText_x_spaces

Function gig-editModule
{
  &lt;#
   .Synopsis
    This opens a module stored in the $env:PSModulePath location on a new tab in ISE 
   .Description
    This function uses Get-Module to retrieve a module from $env:PSModulePath and then
    it opens the module from that location into a new tab in ISE for editing. Wildcard
    characters that resolve to a single module are supported.
   .Example
    gig-editModule PowerShellISEModule
    gig-editModule PowerShellISEModule opens the PowerShellISEModule into a new tab in the
    ISE for editing 
  .Example
    gig-editModule PowerShellISE*
    gig-editModule PowerShellISE* opens the PowerShellISEModule into a new tab in the
    ISE for editing by using a wild card character for the module name
   .Parameter Name
    The name of the module. Wild cards that resolve to a single module are supported
   .Notes
    NAME:  gig-editModule
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 18:14:19
    KEYWORDS: Scripting Techniques, Modules
    HSG: WES-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($name)
 ISE (Get-Module -ListAvailable $name).path
} #'end function gig-editModule

Function gig-toggleOutlineView
{
  &lt;#
   .Synopsis
    This function toggles the outline view in the ISE 
   .Description
    This function toggles the outline view in the ISE. It will expand 
    or collapse all functions in the current script pane.
   .Example
    gig-toggleOutlineView
    gig-toggleOutlineView will either expand or collapse all functions 
   .Notes
    NAME:  gig-toggleOutlineView
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 19:28:37
    KEYWORDS: Scripting Techniques, Modules
    HSG: wes-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 3.0
 #&gt;
 $psise.CurrentFile.Editor.ToggleOutliningExpansion()
} #'end function gig-toggleOutlineView


#'added Functions from New-ModulesDrive.ps1
#' HSG-1-20-10
Function gig-newModuleDrives
{
&lt;#
    .SYNOPSIS
    Creates two PSDrives: myMods and sysMods
    .EXAMPLE
    gig-newModuleDrives
    Creates two PSDrives: myMods and sysMods. These correspond 
    to the users' modules folder and the system modules folder respectively. 
#&gt;
 $driveNames = "myMods","sysMods"

 For($i = 0 ; $i -le 1 ; $i++)
 {
  New-PsDrive -name $driveNames[$i] -PSProvider filesystem `
  -Root ($env:PSModulePath.split(";")[$i]) -scope Global |
  Out-Null
 } #'end For
} #'end gig-newModuleDrives

Function gig-getFileSystemDrives
{
&lt;#
    .SYNOPSIS
    Displays global PS Drives that use the Filesystem provider
    .EXAMPLE
    gig-getFileSystemDrives
    Displays global PS Drives that use the Filesystem provider
#&gt;
 Get-PSDrive -PSProvider FileSystem -scope Global
} #'end gig-getFileSystemDrives

Function gig-OpenPath
{
 &lt;#
   .Synopsis
    Opens a path in Explorer 
   .Description
    Opens a path in Explorer, default path is C:\, or the first parameter is the path
   .Example
    gig-OpenPath C:\Junk
    gig-OpenPath $moduleHome 
   .Parameter Path
    The path to open in Explorer
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/26/2016 17:31:28
    KEYWORDS:
    HSG: 
   .Link
     
 #'Requires -Version 2.0
 #&gt;
  Param(
  [string]$path = "C:\"
 )
 Invoke-Item -Path $path
 }


 function gig-LoadNetworkPSDrives
{
#'    net use G: "\\Jphsa.org\shared\Data" 
#'    net use H: "\\Jphsa.org\shared\Users\ggarson\" 
#'    net use I: "\\Jphsa-ebhost2\AnasaziFiles\" 
#'    net use M: "\\Jphsa.org\shared\Data\MIS\" 
#'    net use N: "\\Jphsa-ebfile01\e$\" 
#'    net use P: "\\Jphsa.org\shared\Users\ggarson\PROJECTS"


    New-PSDrive -Name "G" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Data" -scope Global
    New-PSDrive -Name "H" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Users\ggarson\" -scope Global
    New-PSDrive -Name "I" -PSProvider "FileSystem" -Root "\\Jphsa-ebhost2\AnasaziFiles\" -scope Global
    New-PSDrive -Name "M" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Data\MIS\" -scope Global
    New-PSDrive -Name "N" -PSProvider "FileSystem" -Root "\\Jphsa-ebfile01\e$\" -scope Global
    New-PSDrive -Name "P" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Users\ggarson\PROJECTS"-scope Global


} 
 
#' *** Alias ***
#'if(!(Test-Path alias:ah))
#' {
#'  New-Alias -Name ah -Value add-headertoscript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:abh))
#' {
#'  New-Alias -Name abh -Value Add-SBSBookHeaderToScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ahlp))
#' {
#'  New-Alias -Name ahlp -Value add-help -Description "MrEd alias" |
#'  Out-Null
#'  }
#'  if(!(Test-Path alias:ras))
#' {
#'  New-Alias -Name ras -Value Remove-AliasFromScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:gfsd))
#' {
#'  New-Alias -Name gfsd -Value gig-getFileSystemDrives -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:cs))
#' {
#'  New-Alias -Name cs -value Copy-ScriptToNewTab -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ar))
#' {
#'  New-Alias -Name ar -value Add-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:rr))
#' {
#'  New-Alias -Name rr -value Remove-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:em))
#' {
#'  New-Alias -Name em -value Edit-Module -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:iem))
#' {
#'  New-Alias -Name iem -value Import-EveryModule -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:sov))
#' {
#'  New-Alias -Name sov -value gig-toggleOutlineView -Description "MrEd alias" |
#'  Out-Null
#'  }



#' *** Variables ***
if(!(Test-Path variable:moduleHome))
{
 new-variable -name moduleHome -value "$env:userProfile\documents\WindowsPowerShell\Modules"
}
#'if(!(Test-Path variable:backupHome))
#'{
#' new-variable -name backupHome -value "$env:userProfile\documents\WindowsPowerShell\profileBackup"
#'}

if(!(Test-Path variable:TranscriptHome))
{
 new-variable -name TranscriptHome -value "C:\DATA\junkPowerShellTranscripts"
 #' new-variable -name TranscriptHome -value "$env:userProfile\documents\WindowsPowerShell\transcript"
}

if(!(Test-Path variable:myScripts))
{
 new-variable -name myScripts -value "C:\DATA\PowerShellScripts"
}

Set-Location $myScripts

Clear-Host

gig-LoadNetworkPSDrives

Export-ModuleMember -alias * -function * -variable *

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_WMI</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_WMI</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_WMI</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_WMI</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_WMI

ref: http://www.darkoperator.com/blog/2013/1/31/introduction-to-wmi-basics-with-powershell-part-1-what-it-is.html

WMI (Windows Management Instrumentation)

Definitions
---------------
#'Class=the definition of an object
#'	e.g Win32_Share
#'	
#'Namespace=WMI Classes live inside namespaces
#'	e.g. root\CimV2	
#'	
#'Instance=A class can have zero, one or more instances
#'	e.g	One instance for each share
#'
#'Property=an attribute of an instance
#'	e.g. Name and Path of a specific Win32_share instance
#'
#'
#'Method=Something a WMI class instance can do
#'    e.g. Delete() a specific share
#'
#'Static method=something a WMI class can do
#'    e.g. Create() a new share
#'
#'Event=something that happens and can be acted on when it occurs

	
Where Does WMI/CIM Live?:
---------------------------------------
#' CIMOM (CIM Object Manager) 
#'    lives in WBEM Folder

        &gt;Get-ChildItem c:\Windows\System32\Wbem\Winmgmt.exe
#' WMI Providers 
#'    live in same location

        &gt;Get-ChildItem C:\Windows\System32\Wbem\*provider*.dll
        &gt;Get-ChildItem C:\Windows\System32\Wbem*.dll
        
#' The CIM Database
    &gt;Get-ChildItem c:\windows\system32\repository	
	
Where do WMI/CIM cmdlets live?
------------------------------	
#' The WMI cmdlets live in microsoft.powershell.managment
Get-Command –module microsoft.powershell.management

#' The CIM Cmdlets live in the CimCmdletsModule
Get-Command –module CimCmdlets


Correspnding cmdlets

		CIM Cmdlet
		=============
		Get-CimAssociatedInstance
		Get-CimClass
		Get-CimInstance
		Invoke-CimMethod
		New-CimInstance/SetCimInstance
		Remove-CimInstance
		Register-CimIndicationEvent
		New-CimSession
		Get-CimSession
		Remove-CimSession
		New-CimSessionOption
		
		
		WMI Cmdlet
		================
		UseWMI query with Get-WmiObject
		Use [WMIClass]
		Get-WMIObject
		Invoke-WmiMethod
		Set-WmiInstance
		Remove-WmiObject
		Register-WmiIEvent
		No equivalent
		No equivalent
		Noequivalent
		No equivalent



What is a WMI qualifier?
------------------------
#'    MSDN defines these as: a data string that provides more information about a class, 
#'        instance, property, method, or parameter.
#'    Think of it as an attribute – of a class, instance, property, method, or parameter.
#'
#'You use Get-CimClass to discover information about a class, including class, method and property 
#'qualifiers
--------------------- How to get the Qualifiers
#'Get-CimClass returns an object with key properties returned as arrays
#'    Pipe the output of Get-CimClass to Select-Object –Expand &lt;prop&gt; to expand any of the properties
---------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_WMI</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>writable_WMI_Properties</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_WMI</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>writable_WMI_Properties</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://blogs.technet.microsoft.com/heyscriptingguy/2014/01/29/use-powershell-to-manipulate-information-with-cim/
-----------------------------------------------
After you’ve found a property that you want to change, the process of changing it looks like this:

Retrieve the CIM instance by using Get-CimInstance, and assign to a variable.
Change the desired property value.
Call Set-CimInstance, and pass it in the variable.

 Let’s take a look at how to create a CIM session, so that we can perform work against remote computers. To create a CIM session, we simply use the New-CimSession cmdlet:
 &gt;$CimSession = New-CimSession -ComputerName sql01;
 'Get a list of printers:
 Get-CimInstance -CimSession $CimSession -Class Win32_Printer;
 
 'When you have completed a CIM session, you can clean it up by using the Remove-CimSession cmdlet:

Remove-CimSession -CimSession $CimSession;
------------------------------------------------
$ClassList = Get-CimClass;

 

foreach ($CimClass in $ClassList) {

    foreach ($CimProperty in $CimClass.CimClassProperties) {

        if ($CimProperty.Qualifiers.Name -contains 'write') {

            [PSCustomObject]@{

                ClassName = $CimClass.CimClassName;

                PropertyName = $CimProperty.Name;

                Writable = $true;

                };

        };

    };

};
------------------------------------------------
'OUTPUT:
---------
ClassName                        PropertyName                   Writable
---------                        ------------                   --------
__Trustee                        Domain                             True
__Trustee                        Name                               True
__Trustee                        SID                                True
__Trustee                        SidLength                          True
__Trustee                        SIDString                          True
Win32_Trustee                    Domain                             True
Win32_Trustee                    Name                               True
Win32_Trustee                    SID                                True
Win32_Trustee                    SidLength                          True
Win32_Trustee                    SIDString                          True
__ACE                            AccessMask                         True
__ACE                            AceFlags                           True
__ACE                            AceType                            True
__ACE                            GuidInheritedObjectType            True
__ACE                            GuidObjectType                     True
__ACE                            Trustee                            True
Win32_ACE                        AccessMask                         True
Win32_ACE                        AceFlags                           True
Win32_ACE                        AceType                            True
Win32_ACE                        GuidInheritedObjectType            True
Win32_ACE                        GuidObjectType                     True
Win32_ACE                        Trustee                            True
__SecurityDescriptor             DACL                               True
__SecurityDescriptor             Group                              True
__SecurityDescriptor             Owner                              True
__SecurityDescriptor             SACL                               True
Win32_SecurityDescriptor         DACL                               True
Win32_SecurityDescriptor         Group                              True
Win32_SecurityDescriptor         Owner                              True
Win32_SecurityDescriptor         SACL                               True
Win32_PageFileSetting            InitialSize                        True
Win32_PageFileSetting            MaximumSize                        True
Win32_PageFileSetting            Name                               True
Win32_AutochkSetting             UserInputDelay                     True
Win32_QuotaSetting               DefaultLimit                       True
Win32_QuotaSetting               DefaultWarningLimit                True
Win32_QuotaSetting               ExceededNotification               True
Win32_QuotaSetting               State                              True
Win32_QuotaSetting               VolumePath                         True
Win32_QuotaSetting               WarningExceededNotification        True
Win32_WMISetting                 ASPScriptDefaultNamespace          True
Win32_WMISetting                 ASPScriptEnabled                   True
Win32_WMISetting                 AutoStartWin9X                     True
Win32_WMISetting                 BackupInterval                     True
Win32_WMISetting                 BackupLastTime                     True
Win32_WMISetting                 EnableAnonWin9xConnections         True
Win32_WMISetting                 EnableEvents                       True
Win32_WMISetting                 EnableStartupHeapPreallocation     True
Win32_WMISetting                 HighThresholdOnClientObjects       True
Win32_WMISetting                 HighThresholdOnEvents              True
Win32_WMISetting                 LoggingDirectory                   True
Win32_WMISetting                 LoggingLevel                       True
Win32_WMISetting                 LowThresholdOnClientObjects        True
Win32_WMISetting                 LowThresholdOnEvents               True
Win32_WMISetting                 MaxLogFileSize                     True
Win32_WMISetting                 MaxWaitOnClientObjects             True
Win32_WMISetting                 MaxWaitOnEvents                    True
Win32_OSRecoveryConfiguration    AutoReboot                         True
Win32_OSRecoveryConfiguration    DebugFilePath                      True
Win32_OSRecoveryConfiguration    DebugInfoType                      True
Win32_OSRecoveryConfiguration    ExpandedDebugFilePath              True
Win32_OSRecoveryConfiguration    ExpandedMiniDumpDirectory          True
Win32_OSRecoveryConfiguration    KernelDumpOnly                     True
Win32_OSRecoveryConfiguration    MiniDumpDirectory                  True
Win32_OSRecoveryConfiguration    OverwriteExistingDebugFile         True
Win32_OSRecoveryConfiguration    SendAdminAlert                     True
Win32_OSRecoveryConfiguration    WriteDebugInfo                     True
Win32_OSRecoveryConfiguration    WriteToSystemLog                   True
Win32_DCOMApplicationSetting     AuthenticationLevel                True
Win32_DCOMApplicationSetting     RemoteServerName                   True
Win32_DCOMApplicationSetting     UseSurrogate                       True
ScriptingStandardConsumerSetting MaximumScripts                     True
ScriptingStandardConsumerSetting Timeout                            True
Win32_UserProfile                RoamingPreference                  True
Win32_VolumeUserQuota            Limit                              True
Win32_VolumeUserQuota            WarningLimit                       True
Win32_ShadowStorage              MaxSpace                           True
CIM_System                       Roles                              True
CIM_ComputerSystem               Roles                              True
CIM_UnitaryComputerSystem        Roles                              True
Win32_ComputerSystem             Roles                              True
Win32_ComputerSystem             AutomaticManagedPagefile           True
Win32_ComputerSystem             AutomaticResetBootOption           True
Win32_ComputerSystem             CurrentTimeZone                    True
Win32_ComputerSystem             EnableDaylightSavingsTime          True
Win32_ComputerSystem             SystemStartupDelay                 True
Win32_ComputerSystem             SystemStartupOptions               True
Win32_ComputerSystem             SystemStartupSetting               True
Win32_ComputerSystem             Workgroup                          True
CIM_ApplicationSystem            Roles                              True
Win32_NTDomain                   Roles                              True
Win32_NetworkAdapter             NetConnectionID                    True
CIM_Printer                      ErrorInformation                   True
Win32_Printer                    ErrorInformation                   True
Win32_Printer                    Attributes                         True
Win32_Printer                    Comment                            True
Win32_Printer                    DefaultPriority                    True
Win32_Printer                    Direct                             True
Win32_Printer                    DoCompleteFirst                    True
Win32_Printer                    DriverName                         True
Win32_Printer                    EnableBIDI                         True
Win32_Printer                    EnableDevQueryPrint                True
Win32_Printer                    Hidden                             True
Win32_Printer                    KeepPrintedJobs                    True
Win32_Printer                    Local                              True
Win32_Printer                    Location                           True
Win32_Printer                    Network                            True
Win32_Printer                    Parameters                         True
Win32_Printer                    PortName                           True
Win32_Printer                    PrintJobDataType                   True
Win32_Printer                    PrintProcessor                     True
Win32_Printer                    Priority                           True
Win32_Printer                    Published                          True
Win32_Printer                    Queued                             True
Win32_Printer                    RawOnly                            True
Win32_Printer                    SeparatorFile                      True
Win32_Printer                    Shared                             True
Win32_Printer                    ShareName                          True
Win32_Printer                    StartTime                          True
Win32_Printer                    UntilTime                          True
Win32_Printer                    WorkOffline                        True
Win32_Volume                     DriveLetter                        True
Win32_Volume                     IndexingEnabled                    True
Win32_Volume                     Label                              True
Win32_LogicalDisk                VolumeName                         True
Win32_MappedLogicalDisk          VolumeName                         True
Win32_DfsNode                    Description                        True
Win32_DfsNode                    Timeout                            True
Win32_UserAccount                Disabled                           True
Win32_UserAccount                FullName                           True
Win32_UserAccount                Lockout                            True
Win32_UserAccount                PasswordChangeable                 True
Win32_UserAccount                PasswordExpires                    True
Win32_UserAccount                PasswordRequired                   True
Win32_BaseService                State                              True
Win32_SystemDriver               State                              True
Win32_Service                    State                              True
Win32_TerminalService            State                              True
Win32_PrinterDriver              FilePath                           True
Win32_PrinterDriver              InfName                            True
Win32_PrinterDriver              SupportedPlatform                  True
Win32_PrinterDriver              Version                            True
Win32_Environment                Name                               True
Win32_Environment                VariableValue                      True
Win32_IP4RouteTable              Destination                        True
Win32_IP4RouteTable              InterfaceIndex                     True
Win32_IP4RouteTable              Mask                               True
Win32_IP4RouteTable              Metric1                            True
Win32_IP4RouteTable              Metric2                            True
Win32_IP4RouteTable              Metric3                            True
Win32_IP4RouteTable              Metric4                            True
Win32_IP4RouteTable              Metric5                            True
Win32_IP4RouteTable              NextHop                            True
Win32_IP4RouteTable              Type                               True
Win32_OperatingSystem            Description                        True
Win32_OperatingSystem            ForegroundApplicationBoost         True
Win32_NTEventlogFile             MaxFileSize                        True
Win32_NTEventlogFile             OverwriteOutDated                  True
Win32_IP4PersistedRouteTable     Destination                        True
Win32_IP4PersistedRouteTable     Mask                               True
Win32_IP4PersistedRouteTable     Metric1                            True
Win32_IP4PersistedRouteTable     NextHop                            True
Win32_Registry                   ProposedSize                       True
Win32_ProcessStartup             CreateFlags                        True
Win32_ProcessStartup             EnvironmentVariables               True
Win32_ProcessStartup             ErrorMode                          True
Win32_ProcessStartup             FillAttribute                      True
Win32_ProcessStartup             PriorityClass                      True
Win32_ProcessStartup             ShowWindow                         True
Win32_ProcessStartup             Title                              True
Win32_ProcessStartup             WinstationDesktop                  True
Win32_ProcessStartup             X                                  True
Win32_ProcessStartup             XCountChars                        True
Win32_ProcessStartup             XSize                              True
Win32_ProcessStartup             Y                                  True
Win32_ProcessStartup             YCountChars                        True
Win32_ProcessStartup             YSize                              True
Win32_DiskQuota                  Limit                              True
Win32_DiskQuota                  WarningLimit                       True</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions_String</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>concatenate</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions_String</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>concatenate</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://4sysops.com/archives/strings-in-powershell-replace-compare-concatenate-split-substring/


$h = "Hello" 
$w = "world"
$h + " " + $w

'Alternatively, you can expand the two strings within double quotes:

"$h $w"

"$h $w"

'This method is also suitable for concatenating the elements of a string array:

$st = @("Say hello", " world")
"$st"

'Another option for concatenating strings is the join operator. Its usage is perhaps a bit counterintuitive. 
'Normally, you place the operator in front of the string unless you want to separate the strings with a delimiter after the merge:

	
-join($h,$w)

'If you don’t like the result “Helloworld” in the example and you want to add a space between the two words, you have to call -join this way:
	
$h,$w -join " "</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>