<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>update_Group_Policy</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>update_Group_Policy</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Remotely
Invoke-Command -Computer -remotepC {gpupdate /force}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_InstalledSoftware_32_and_64_v0.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_InstalledSoftware_32_and_64_v0.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get_InstalledSoftware_32_and_64_v0.ps1

#'This Powershell script list all the installed application on both 32 and 64 bit applications, 
#'	particularly useful for people managing both 32-bit and 64-bit applications.
 
#'	This code also contains an EXCLUSION array where you can exclude list of program that you don't want to show.
#'
#'The function allows -ComputerName parameter so you can connect to any machines
#'Application architecture detection (32-bit or 64-bit) using Win32_processor
#'Output is Powershell console and GridView

#'https://gallery.technet.microsoft.com/scriptcenter/PowerShell-Installed-70d0c0f4

#'===================================================================================USAGE
Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================


Function Get-SoftwareList
{
Param(
[Parameter(Mandatory=$true)]
[string[]]$Computername)

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")

[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 
$donotwrite = $false

if($AppName.length -gt "0"){

 Foreach($exclude in $excludeArray) 
                        {
                        if($AppName.StartsWith($exclude) -eq $TRUE)
                            {
                            $donotwrite = $true
                            break
                            }
                        }
            if ($donotwrite -eq $false) 
                        {                        
            $Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "64-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
                        }





}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 
 $donotwrite = $false
         
                             



if($AppName.length -gt "0"){
 Foreach($exclude in $excludeArray) 
                        {
                        if($AppName.StartsWith($exclude) -eq $TRUE)
                            {
                            $donotwrite = $true
                            break
                            }
                        }
            if ($donotwrite -eq $false) 
                        {                        
            $Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
                        }
           }

 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

"#"*80
"Installed Software Application Report"
"Numner of Installed Application count : $($object.count)"
"Generated $(get-date)"
"Generated from $(gc env:computername)"
"#"*80

$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
$object|Out-GridView 


}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v3.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v3.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v3.ps1
#' The exclusion array has been replaced by the inclusion array (for finding Adobe software)
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v3
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $true
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

#'                             Foreach($exclude in $excludeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $true
#'                                                        break
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - START
                             Foreach($include in $includeArray) 
                                                    {
                                                    if($AppName.StartsWith($include) -eq $TRUE)
                                                        {
                                                        $donotwrite = $false
                                                        }
                                                    }
                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $true
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){
#'Foreach($exclude in $excludeArray) 
#'                        {
#'                        if($AppName.StartsWith($exclude) -eq $TRUE)
#'                            {
#'                            $donotwrite = $true
#'                            break
#'                            }
#'                        }

                        #'=================================================================  INCLUSION ARRAY - START
                            Foreach($include in $includeArray) 
                                                {
                                                if($AppName.StartsWith($include) -eq $TRUE)
                                                    {
                                                    $donotwrite = $false
                                                    }
                                                }
                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v4.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v4.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v4.ps1
#' All Applications, with the default Exclusion Array
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v4
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                             Foreach($exclude in $excludeArray) 
                                                    {
                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
                                                        {
                                                        $donotwrite = $true
                                                        break
                                                        }
                                                    }


                            #'=================================================================  INCLUSION ARRAY - START
    #'                         Foreach($include in $includeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($include) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $false
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                        Foreach($exclude in $excludeArray) 
                                                {
                                                if($AppName.StartsWith($exclude) -eq $TRUE)
                                                    {
                                                    $donotwrite = $true
                                                    break
                                                    }
                                                }


                        #'=================================================================  INCLUSION ARRAY - START
#'                            Foreach($include in $includeArray) 
#'                                                {
#'                                                if($AppName.StartsWith($include) -eq $TRUE)
#'                                                    {
#'                                                    $donotwrite = $false
#'                                                    }
#'                                                }

                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Classes_and_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_Object_using_Hash_table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Classes_and_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_Object_using_Hash_table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#
#' Demo 1 -- Create a new object, by defining the method 'Create-Object'
#' This is the most common method of creating objects
#' Create a Hash table then populate all the properties at once
#'-----------------------------------------------------------------------------#
function Create-Object ($Schema, $Table, $Comment)
{
  #' Build a hash table with the properties
  #' using the [ordered] tag means they will retain the order in which they are defined
  $properties = [ordered]@{ Schema = $Schema
                   Table = $Table
                   Comment = $Comment
                 }

  #' Start by creating an object of type PSObject using "New-Object"
  #' The class name is the 'TypeName' property, in this case use a generic built-in class
  #'  "New-Object" creates an object based on a Class
  
  $object = New-Object –TypeName PSObject -Property $properties

  #' Return the newly created object
  return $object
}


#' Now call the function (i.e. "Create-Object")

$myObject = Create-Object -Schema "MySchema" -Table "MyTable" -Comment "MyComment"
$myObject         #' &lt;=== This will echo back the three properties, and their values

#' Display in text. Note because it is an object need to wrap in $() to access a property
#' use string interpolation (i.e. $(xxx)  ) to reference the "Schema" property of the object 

"My Schema = $($myObject.Schema)"

$myObject.Schema = "New Schema"      #'&lt;=== update the property w/ a new value
$myObject.Comment = "New Comment"
$myObject							 #' &lt;=== This will echo back the three properties, and their values</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Classes_and_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Crreate_Object_adding_one_Member_at_time</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Classes_and_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Crreate_Object_adding_one_Member_at_time</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#'
#' Demo 2 -- Create a new object by adding properties one at a time (to SINGLE or MULTIPLE objects)
#' In the previous demo a property hash table was used to generate the object
#' Behind the scenes it does the equivalent of what this function does
#'-----------------------------------------------------------------------------#'
function Create-Object ($Schema, $Table, $Comment)
{
  #' Start by creating an EMPTY generic object of type PSObject
  $object = New-Object –TypeName psobject     

  #' SIMPLE syntac
  #' {as an Argument to a method (i.e. Add-Member) , this works for creation of ONE object}
  #' after creating it, then add the FIRST Member
  #' Add-Member by passing in input object 
  Add-Member -InputObject $object `
             –MemberType NoteProperty `			#'&lt;=== This is generic property
             –Name Schema `						#'&lt;=== this is the name of the property
             –Value $Schema						#'&lt;=== This is the value of the property


  #' ALTERNATE syntax, pipe the object as an input to Add-Member 
  #' {Pipe the object as input into the Method, could work for a COLLECTION of objects}
  #' Thus you could add a property to ALL the members of a collection  
  #' NOTE that with this syntax, 'object' could itself be a collection of objects
  #
  $object | Add-Member –MemberType NoteProperty `
                       –Name Table `
                       –Value $Table

  #' SECOND Member
  $object | Add-Member -MemberType NoteProperty `
                       -Name Comment `
                       -Value $Comment

  return $object
}

#'USAGE:

#'Create a new object
$myObject = Create-Object -Schema "MySchema" -Table "MyTable" -Comment "MyComment"
$myObject							 #' &lt;=== This will echo back the three properties, and their values

#' Display in text. Note because it is an object need to wrap in $() to access a property
"My Schema = $($myObject.Schema)"

$myObject.Schema = "New Schema"      #'&lt;=== update the property w/ a new value
$myObject.Comment = "New Comment"    #'&lt;=== update the property w/ a new value
$myObject							 #' &lt;=== This will echo back the three properties, and their values</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-DiskUsage______xml_Get-CimInstance</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-DiskUsage______xml_Get-CimInstance</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'USAGE: does local machine if there is no computername provided
&gt;Get-DiskUsage gives you the info
'This is actually the master function, 
&gt;Update-DiskXML
'This is used by the master function to create an XML file if it doesn't exist
&gt;New-DiskXML
=================================================================

#'SupportsShouldProcess turns on the WhatIf process
'So if you run it with the -WhatIf 


#'Get-DiskUsage : to retrieve the disk information and writes an object to the pipeline. 
------------------------------------------------------------------------
Function Get-DiskUsage {
[cmdletbinding()]
Param(
[Parameter(Position = 0,ValueFromPipeline)]
[string[]]$Computername = $env:Computername)

Begin {
    #define a hashtable of parameter values for Get-CimInstance
    $pm = @{
        Classname = 'Win32_logicaldisk'
        Filter = "drivetype=3" 
        ComputerName = $Null
        ErrorAction = 'stop'
    }
}

Process {
    foreach ($computer in $Computername) {
        Try {
            #set the next computername
            $pm.Computername = $Computer
            $d = Get-CimInstance @pm
            $d | Select @{Name="Date";Expression={(Get-Date).ToShortDateString()}},
                PSComputername,DeviceID,Size,Freespace,
                @{Name="PercentFree";Expression = {($_.freespace/$_.size)*100 -as [int]}} 
        }
        Catch {
            Write-Warning "[$computer] $($_.exception.message)"
        }
        
        
    }
}

End {
    #not used
}
}


' New-DiskXML: 
'	 creates an empty XML document that meets our requirements. 

Function New-DiskXML {
[cmdletbinding(SupportsShouldProcess)]
Param(
[Parameter(Position = 0, Mandatory, 
HelpMessage = "Enter the filename and path for the new disk XML file")]
[string]$Path
)

[xml]$doc = New-Object System.Xml.XmlDocument

#create declaration
$dec = $doc.CreateXmlDeclaration("1.0","UTF-8",$null)

#append to document
$doc.AppendChild($dec) | Out-Null

#create the outer node
$node = $doc.CreateNode("element","snapshots",$null)

$doc.AppendChild($node) | Out-Null

if ($PSCmdlet.ShouldProcess($path)) {
    $doc.Save($path)
}

}

'The function needs a parameter for the XML file and a group of computernames. 
'If the XML file doesn’t exist,
'	 we wrote another function, New-DiskXML, 
'	 to create an empty XML document that meets our requirements. 
'The Update-DiskXml command calls Get-DiskUsage 
'	to get drive information and then creates snapshot information which it appends to the main document.
Function Update-DiskXML {
[cmdletbinding(SupportsShouldProcess)]
Param(
[Parameter(Position = 0, Mandatory, 
HelpMessage = "Enter the filename and path for the disk XML file")]
[string]$Path,
[Parameter(ValueFromPipeline)]
[string[]]$Computername = $env:COMPUTERNAME
)

Begin {

    if (-Not (Test-Path -Path $path)) {
        #create the file if it doesn't exist
        New-DiskXML -Path $path
    }

    #resolve and convert the path to a filesystem
    $cpath = Convert-Path -Path $path

    #open the XML document
    [xml]$doc = Get-Content -Path $cpath

    #select the Snapshots node
    $snapshots = $doc.ChildNodes[1]  #or $doc.SelectSingleNode("snapshots")

    #property names
    $props = "Date","PSComputername","DeviceID","Size","Freespace","PercentFree"
}
Process {
    $data = Get-DiskUsage $Computername
    foreach ($item in $data) {
        $snap = $doc.CreateNode("element","snapshot",$null)

        #create an entry for each
        $props | foreach {
            $e = $doc.CreateElement($_)
            $e.InnerText = $item.$_
            $snap.AppendChild($e) | Out-Null
        }        
        $snapshots.AppendChild($snap) | Out-Null
    }    
}

End {

    if ($PSCmdlet.ShouldProcess($cpath)) {
        $doc.save($cpath)
 }
}

}

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Login__get_LoginInstancesFunction</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Login__get_LoginInstancesFunction</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USAGE:

&gt;Get-LoginInstance -ComputerName "LT-103111" -StartDate (Get-Date).AddDays(-1) -Verbose  | SELECT UserName, LoginTime, SessionType, LoginIpAddress



'Get-LoginInstance - Retrieve Local and Remote Computer Login/Logout Instances
https://gallery.technet.microsoft.com/scriptcenter/Get-LoginInstance-Retrieve-6437b1af

#'This script contains a function (Get-LoginInstance), 
#'    as well as two sub-functions (Get-LoginData and Get-LogoutData), 
#'    which are used to retrieve login and logout events from the Security event log on a local or remote computer, 
#'    and join them together to display login instance data.  
#'    Please use the native help bundled with the cmdlet for more information on ways to utilize/run this function.
#'
#'Additionally, please note that this cmdlet is reliant upon Remote Event Log Management, 
#'    which may need to be enabled on the target machine(s), 
#'    and due to its use of Get-WinEvent, can only work on Vista, 
#'    Server 2008 R2 and later Windows releases for consumer and enterprise markets, respectively.
#'
#'UPDATE - 10/23/14: I've revised the cmdlet to fix a few different areas - 
#'                    please download the latest version of this if you have a previous version of the script.  
#'                    Changes made to the latest version include:
#'
#'New sorting algorithm to ensure all login instances 
#'        (logins and logouts) and logins without corresponding logouts 
#'        appear in final collection, regardless of OS, account domain, etc.
#'Official support of PowerShell versions 2, 3 and 4 - Get-LoginInstance has now been tested and confirmed to work in all of those versions
#'Remove Desktop Window Manager (DWM) logins from final collection if present
#'Minor help file tweaks
=================================================================================
    -------------------------- EXAMPLE 1 --------------------------
    
    PS C:\&gt;Get-LoginInstance
    
    Retrieve all available login instances from the local computer within 
    the past week.
    
    
    
    
    -------------------------- EXAMPLE 2 --------------------------
    
    PS C:\&gt;Get-LoginInstance -ComputerName "GSR-242" -StartDate (Get-Date).AddMonths(-1) -Verbose
    
    Retrieve all available login instances from remote computer "GSR-242" 
    within the past month, displaying verbose output as well.

=================================================================================

#PowerShell Script Containing Function(s) Used to Retrieve Login &amp; Logout Instances from a Local or Remote Computer
#Developer: Andrew Saraceni (saraceni@wharton.upenn.edu)
#Date: 10/23/14

function Get-LoginInstance
{
    &lt;#
    .SYNOPSIS
    Retrieves login and logout instances from a local or remote computer.
    .DESCRIPTION
    Retrieves all interactive and remote-based logins from a specific 
    computer, then obtains all logouts and joins the instances together 
    via processing.  This information is retrieved from the Security 
    event logs on the computer, and thus can only pull data from logs 
    that have yet to turn over.

    Without parameters, a Get-LoginInstance command retrieves all logins 
    and logouts from the local computer within the past week.
    .PARAMETER ComputerName
    Specifies the computer from which to pull the login/logout 
    information.  The default value for this is the local computer.
    .PARAMETER StartDate
    Specifies the earliest (i.e. oldest) date from which to retrieve 
    logins/logouts.  The default value for this is one week before the 
    current date: (Get-Date).AddDays(-7)
    .PARAMETER EndDate
    Specifies the most recent date from which to retrieve logins/logouts.  
    The default value for this is the current date.
    .EXAMPLE
    Get-LoginInstance
    Retrieve all available login instances from the local computer within 
    the past week.
    .EXAMPLE
    Get-LoginInstance -ComputerName "GSR-242" -StartDate (Get-Date).AddMonths(-1) -Verbose
    Retrieve all available login instances from remote computer "GSR-242" 
    within the past month, displaying verbose output as well.
    .NOTES
    This cmdlet makes use of the Get-WinEvent cmdlet, which is only 
    available on Windows Vista, Windows Server 2008 R2 and later consumer 
    and enterprise verisons of Windows, respectively.

    Additionally, Remote Event Log Management will need to be enabled 
    via your firewall.  The following CMD prompt command can enable this 
    on a local computer:

    netsh advfirewall firewall set rule group=”remote event log management” new enable=yes
    #&gt;
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,Mandatory=$false)]
        [String]$ComputerName = $env:COMPUTERNAME,
        [Parameter(Position=1,Mandatory=$false)]
        [DateTime]$StartDate = (Get-Date).AddDays(-7),
        [Parameter(Position=2,Mandatory=$false)]
        [DateTime]$EndDate = (Get-Date)
    )

    function Get-LoginData
    {
        param($ComputerName,$StartDate,$EndDate)
        
        Write-Verbose "Getting Login Data from $ComputerName..."
        [Int32[]]$loginID = @(4624)

        try
        {
            $loginEvents = Get-WinEvent -ComputerName $ComputerName -FilterHashtable @{ LogName="Security"; ID=$loginID; StartTime=$StartDate; EndTime=$EndDate } -ErrorAction Stop
        }
        catch
        {
            Set-Variable -Name catchError -Value $_
            if ($catchError -match "No events were found that match the specified selection criteria.")
            {
                Write-Warning "No Login Events Found - Ending Login Collection"
            }
        }

        Write-Verbose "Converting Logins to XML &amp; Parsing Data for Better Readability..."
        foreach ($loginEvent in $loginEvents)
        {
            $xmlLoginEvent = [Xml]$loginEvent.ToXml()

            for ($i=0; $i -lt $xmlLoginEvent.Event.EventData.Data.Count; $i++)
            {            
                Add-Member -InputObject $loginEvent -MemberType NoteProperty -Name $xmlLoginEvent.Event.EventData.Data[$i].Name -Value $xmlLoginEvent.Event.EventData.Data[$i]."#Text" -Force
            }
        }

        $revisedLoginEvents = @()
        $xmlLoginEvents = $loginEvents | Where-Object { (($_.LogonType -eq "2") -or ($_.LogonType -eq "10")) -and ($_.TargetDomainName -ne "Window Manager") } | Select-Object -Property *
        foreach ($xmlLoginEvent in $xmlLoginEvents)
        {
            switch ($xmlLoginEvent.LogonType)
            {
                "2" {
                    $xmlLoginEvent.LogonType = "Login-Interactive"
                }
                "10" {
                    $xmlLoginEvent.LogonType = "Login-Remote"
                }
            }
            
            if (($xmlLoginEvent.IpAddress -eq "127.0.0.1") -or ($xmlLoginEvent.IpAddress -eq "::1"))
            {
                $xmlLoginEvent.IpAddress = $null
            }

            if ($xmlLoginEvent.IpPort -eq "0")
            {
                $xmlLoginEvent.IpPort = $null
            }
            
            $revisedLoginEvents += $xmlLoginEvent
        }
        
        return $revisedLoginEvents
    }

    function Get-LogoutData
    {
        param($ComputerName,$StartDate,$EndDate)

        Write-Verbose "Getting Logout Data from $ComputerName..."
        [Int32[]]$logoutID = @(4647)

        try
        {
            $logoutEvents = Get-WinEvent -ComputerName $ComputerName -FilterHashtable @{ LogName="Security"; ID=$logoutID; StartTime=$startDate; EndTime=$endDate } -ErrorAction Stop
        }
        catch
        {
            Set-Variable -Name catchError -Value $_
            if ($catchError -match "No events were found that match the specified selection criteria.")
            {
                Write-Warning "No Logout Events Found - Ending Logout Collection"
            }
        }

        Write-Verbose "Converting Logouts to XML &amp; Parsing Data for Better Readability..."
        foreach ($logoutEvent in $logoutEvents)
        {
            $xmlLogoutEvent = [Xml]$logoutEvent.ToXml()

            for ($i=0; $i -lt $xmlLogoutEvent.Event.EventData.Data.Count; $i++)
            {            
                Add-Member -InputObject $logoutEvent -MemberType NoteProperty -Name $xmlLogoutEvent.Event.EventData.Data[$i].name -Value $xmlLogoutEvent.Event.EventData.Data[$i]."#Text" -Force
            }
        }
        
        $revisedLogoutEvents = @()
        $xmlLogoutEvents = $logoutEvents | Select-Object -Property *
        foreach ($xmlLogoutEvent in $xmlLogoutEvents)
        {
            Add-Member -InputObject $xmlLogoutEvent -MemberType NoteProperty -Name "WorkstationName" -Value $ComputerName -Force

            $revisedLogoutEvents += $xmlLogoutEvent
        }
        
        return $revisedLogoutEvents
    }

    $finalLoginEvents = Get-LoginData -ComputerName $ComputerName -StartDate $StartDate -EndDate $EndDate
    $finalLogoutEvents = Get-LogoutData -ComputerName $ComputerName -StartDate $StartDate -EndDate $EndDate

    Write-Verbose "Creating Final Collection of Revised Login and Logout Instance Data..."
    $loginInstances = @()

    foreach ($finalLoginEvent in $finalLoginEvents)
    {
        $instanceProperties = @{
            ComputerName = $finalLoginEvent.WorkstationName
            UserName = $finalLoginEvent.TargetUserName
            AccountDomain = $finalLoginEvent.TargetDomainName
            LoginTime = $finalLoginEvent.TimeCreated
            LogoutTime = $null
            TargetLogonID = $finalLoginEvent.TargetLogonID
            Days = $null
            Hours = $null
            Minutes = $null
            Seconds = $null
            SessionType = $finalLoginEvent.LogonType
            LoginIpAddress = $finalLoginEvent.IpAddress
            LoginIpPort = $finalLoginEvent.IpPort
            LogonGuid = $finalLoginEvent.LogonGuid
        }

        $loginInstance = New-Object -TypeName PSObject -Property $instanceProperties

        foreach ($finalLogoutEvent in $finalLogoutEvents)
        {
            if (($finalLogoutEvent.WorkstationName -eq $finalLoginEvent.WorkstationName) -and ($finalLogoutEvent.TargetUserName -eq $finalLoginEvent.TargetUserName) -and ($finalLogoutEvent.TargetLogonID -eq $finalLoginEvent.TargetLogonID))
            {
                $loginInstance.LogoutTime = $finalLogoutEvent.TimeCreated
                $loginInstance.Days = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Days
                $loginInstance.Hours = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Hours
                $loginInstance.Minutes = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Minutes
                $loginInstance.Seconds = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Seconds
            }
        }

        $loginInstances += $loginInstance
    }

    $fullLoginInstances = $loginInstances | Where-Object { $_.LogoutTime -ne $null }
    $partialLoginInstances = $loginInstances | Where-Object { $_.LogoutTime -eq $null } | Sort-Object -Property LoginTime -Descending -Unique

    $fullLoginInstanceLoginTimes = $fullLoginInstances | Select-Object -ExpandProperty LoginTime
    $filteredPartialLoginInstances = @()
    
    foreach ($partialLoginInstance in $partialLoginInstances)
    {
        if ($fullLoginInstanceLoginTimes -notcontains $partialLoginInstance.LoginTime)
        {
            $filteredPartialLoginInstances += $partialLoginInstance
        }
    }

    $finalLoginInstances = @($fullLoginInstances) + @($filteredPartialLoginInstances) | Sort-Object -Property LoginTime -Descending -Unique

    return $finalLoginInstances | Select-Object -Property ComputerName, UserName, AccountDomain, LoginTime, LogoutTime, TargetLogonID, Days, Hours, Minutes, Seconds, SessionType, LoginIpAddress, LoginIpPort, LogonGuid
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_Reboot_Restart</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-PendingReboot</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_Reboot_Restart</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-PendingReboot</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gallery.technet.microsoft.com/scriptcenter/Get-PendingReboot-Query-bdb79542

https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/10/determine-pending-reboot-statuspowershell-style-part-1/
https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/11/determine-pending-reboot-statuspowershell-style-part-2/ 


'USAGE:
$Servers = Get-Content C:\DATA\2018_05_09__RespondToPing.txt
#'$Servers = Get-Content C:\DATA\TEST.txt
Get-PendingReboot -Computer $Servers -ErrorLog C:\DATA\2018_05_09__PendingRebootReport_ERRORS.txt | Export-Csv C:\DATA\2018_05_09__PendingRebootReport.csv -NoTypeInformation 



============================================================================


Function Get-PendingReboot
{
&lt;#
.SYNOPSIS
    Gets the pending reboot status on a local or remote computer.

.DESCRIPTION
    This function will query the registry on a local or remote computer and determine if the
    system is pending a reboot, from Microsoft updates, Configuration Manager Client SDK, Pending Computer 
    Rename, Domain Join or Pending File Rename Operations. For Windows 2008+ the function will query the 
    CBS registry key as another factor in determining pending reboot state.  "PendingFileRenameOperations" 
    and "Auto Update\RebootRequired" are observed as being consistant across Windows Server 2003 &amp; 2008.
	
    CBServicing = Component Based Servicing (Windows 2008+)
    WindowsUpdate = Windows Update / Auto Update (Windows 2003+)
    CCMClientSDK = SCCM 2012 Clients only (DetermineIfRebootPending method) otherwise $null value
    PendComputerRename = Detects either a computer rename or domain join operation (Windows 2003+)
    PendFileRename = PendingFileRenameOperations (Windows 2003+)
    PendFileRenVal = PendingFilerenameOperations registry value; used to filter if need be, some Anti-
                     Virus leverage this key for def/dat removal, giving a false positive PendingReboot

.PARAMETER ComputerName
    A single Computer or an array of computer names.  The default is localhost ($env:COMPUTERNAME).

.PARAMETER ErrorLog
    A single path to send error data to a log file.

.EXAMPLE
    PS C:\&gt; Get-PendingReboot -ComputerName (Get-Content C:\ServerList.txt) | Format-Table -AutoSize
	
    Computer CBServicing WindowsUpdate CCMClientSDK PendFileRename PendFileRenVal RebootPending
    -------- ----------- ------------- ------------ -------------- -------------- -------------
    DC01           False         False                       False                        False
    DC02           False         False                       False                        False
    FS01           False         False                       False                        False

    This example will capture the contents of C:\ServerList.txt and query the pending reboot
    information from the systems contained in the file and display the output in a table. The
    null values are by design, since these systems do not have the SCCM 2012 client installed,
    nor was the PendingFileRenameOperations value populated.

.EXAMPLE
    PS C:\&gt; Get-PendingReboot
	
    Computer           : WKS01
    CBServicing        : False
    WindowsUpdate      : True
    CCMClient          : False
    PendComputerRename : False
    PendFileRename     : False
    PendFileRenVal     : 
    RebootPending      : True
	
    This example will query the local machine for pending reboot information.
	
.EXAMPLE
    PS C:\&gt; $Servers = Get-Content C:\Servers.txt
    PS C:\&gt; Get-PendingReboot -Computer $Servers | Export-Csv C:\PendingRebootReport.csv -NoTypeInformation
	
    This example will create a report that contains pending reboot information.

.LINK
    Component-Based Servicing:
    http://technet.microsoft.com/en-us/library/cc756291(v=WS.10).aspx
	
    PendingFileRename/Auto Update:
    http://support.microsoft.com/kb/2723674
    http://technet.microsoft.com/en-us/library/cc960241.aspx
    http://blogs.msdn.com/b/hansr/archive/2006/02/17/patchreboot.aspx

    SCCM 2012/CCM_ClientSDK:
    http://msdn.microsoft.com/en-us/library/jj902723.aspx

.NOTES
    Author:  Brian Wilhite
    Email:   bcwilhite (at) live.com
    Date:    29AUG2012
    PSVer:   2.0/3.0/4.0/5.0
    Updated: 27JUL2015
    UpdNote: Added Domain Join detection to PendComputerRename, does not detect Workgroup Join/Change
             Fixed Bug where a computer rename was not detected in 2008 R2 and above if a domain join occurred at the same time.
             Fixed Bug where the CBServicing wasn't detected on Windows 10 and/or Windows Server Technical Preview (2016)
             Added CCMClient property - Used with SCCM 2012 Clients only
             Added ValueFromPipelineByPropertyName=$true to the ComputerName Parameter
             Removed $Data variable from the PSObject - it is not needed
             Bug with the way CCMClientSDK returned null value if it was false
             Removed unneeded variables
             Added PendFileRenVal - Contents of the PendingFileRenameOperations Reg Entry
             Removed .Net Registry connection, replaced with WMI StdRegProv
             Added ComputerPendingRename
#&gt;

[CmdletBinding()]
param(
	[Parameter(Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
	[Alias("CN","Computer")]
	[String[]]$ComputerName="$env:COMPUTERNAME",
	[String]$ErrorLog
	)

Begin {  }##'End Begin Script Block
Process {
  Foreach ($Computer in $ComputerName) {
	Try {
	    ##'Setting pending values to false to cut down on the number of else statements
	    $CompPendRen,$PendFileRename,$Pending,$SCCM = $false,$false,$false,$false
                        
	    ##'Setting CBSRebootPend to null since not all versions of Windows has this value
	    $CBSRebootPend = $null
						
	    ##'Querying WMI for build version
	    $WMI_OS = Get-WmiObject -Class Win32_OperatingSystem -Property BuildNumber, CSName -ComputerName $Computer -ErrorAction Stop

	    ##'Making registry connection to the local/remote computer
	    $HKLM = [UInt32] "0x80000002"
	    $WMI_Reg = [WMIClass] "\\$Computer\root\default:StdRegProv"
						
	    ##'If Vista/2008 &amp; Above query the CBS Reg Key
	    If ([Int32]$WMI_OS.BuildNumber -ge 6001) {
		    $RegSubKeysCBS = $WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\")
		    $CBSRebootPend = $RegSubKeysCBS.sNames -contains "RebootPending"		
	    }
							
	    ##'Query WUAU from the registry
	    $RegWUAURebootReq = $WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\")
	    $WUAURebootReq = $RegWUAURebootReq.sNames -contains "RebootRequired"
						
	    ##'Query PendingFileRenameOperations from the registry
	    $RegSubKeySM = $WMI_Reg.GetMultiStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\Session Manager\","PendingFileRenameOperations")
	    $RegValuePFRO = $RegSubKeySM.sValue

	    ##'Query JoinDomain key from the registry - These keys are present if pending a reboot from a domain join operation
	    $Netlogon = $WMI_Reg.EnumKey($HKLM,"SYSTEM\CurrentControlSet\Services\Netlogon").sNames
	    $PendDomJoin = ($Netlogon -contains 'JoinDomain') -or ($Netlogon -contains 'AvoidSpnSet')

	    ##'Query ComputerName and ActiveComputerName from the registry
	    $ActCompNm = $WMI_Reg.GetStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName\","ComputerName")            
	    $CompNm = $WMI_Reg.GetStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\","ComputerName")

	    If (($ActCompNm -ne $CompNm) -or $PendDomJoin) {
	        $CompPendRen = $true
	    }
						
	    ##'If PendingFileRenameOperations has a value set $RegValuePFRO variable to $true
	    If ($RegValuePFRO) {
		    $PendFileRename = $true
	    }

	    ##'Determine SCCM 2012 Client Reboot Pending Status
	    ##'To avoid nested 'if' statements and unneeded WMI calls to determine if the CCM_ClientUtilities class exist, setting EA = 0
	    $CCMClientSDK = $null
	    $CCMSplat = @{
	        NameSpace='ROOT\ccm\ClientSDK'
	        Class='CCM_ClientUtilities'
	        Name='DetermineIfRebootPending'
	        ComputerName=$Computer
	        ErrorAction='Stop'
	    }
	    ##'Try CCMClientSDK
	    Try {
	        $CCMClientSDK = Invoke-WmiMethod @CCMSplat
	    } Catch [System.UnauthorizedAccessException] {
	        $CcmStatus = Get-Service -Name CcmExec -ComputerName $Computer -ErrorAction SilentlyContinue
	        If ($CcmStatus.Status -ne 'Running') {
	            Write-Warning "$Computer`: Error - CcmExec service is not running."
	            $CCMClientSDK = $null
	        }
	    } Catch {
	        $CCMClientSDK = $null
	    }

	    If ($CCMClientSDK) {
	        If ($CCMClientSDK.ReturnValue -ne 0) {
		        Write-Warning "Error: DetermineIfRebootPending returned error code $($CCMClientSDK.ReturnValue)"          
		    }
		    If ($CCMClientSDK.IsHardRebootPending -or $CCMClientSDK.RebootPending) {
		        $SCCM = $true
		    }
	    }
            
	    Else {
	        $SCCM = $null
	    }

	    ##'Creating Custom PSObject and Select-Object Splat
	    $SelectSplat = @{
	        Property=(
	            'Computer',
	            'CBServicing',
	            'WindowsUpdate',
	            'CCMClientSDK',
	            'PendComputerRename',
	            'PendFileRename',
	            'PendFileRenVal',
	            'RebootPending'
	        )}
	    New-Object -TypeName PSObject -Property @{
	        Computer=$WMI_OS.CSName
	        CBServicing=$CBSRebootPend
	        WindowsUpdate=$WUAURebootReq
	        CCMClientSDK=$SCCM
	        PendComputerRename=$CompPendRen
	        PendFileRename=$PendFileRename
	        PendFileRenVal=$RegValuePFRO
	        RebootPending=($CompPendRen -or $CBSRebootPend -or $WUAURebootReq -or $SCCM -or $PendFileRename)
	    } | Select-Object @SelectSplat

	} Catch {
	    Write-Warning "$Computer`: $_"
	    ##'If $ErrorLog, log the file to a user specified location/path
	    If ($ErrorLog) {
	        Out-File -InputObject "$Computer`,$_" -FilePath $ErrorLog -Append
	    }				
	}			
  }##'End Foreach ($Computer in $ComputerName)			
}##'End Process

End {  }##'End End

}##'End Function Get-PendingReboot</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ExtendingOutputTypes </Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>script_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ExtendingOutputTypes </Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>script_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' example - see the bottom for notes
function Get-MachineInfo {
&lt;#'
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#'&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Try {
            Write-Verbose "Connecting to $computer over $protocol"
            $params = @{'ComputerName'=$Computer
                        'SessionOption'=$option
                        'ErrorAction'='Stop'}
            $session = New-CimSession @params
  
            Write-Verbose "Querying from $computer"
            $os_params = @{'ClassName'='Win32_OperatingSystem'
                           'CimSession'=$session}
            $os = Get-CimInstance @os_params

            $cs_params = @{'ClassName'='Win32_ComputerSystem'
                           'CimSession'=$session}
            $cs = Get-CimInstance @cs_params

            $sysdrive = $os.SystemDrive
            $drive_params = @{'ClassName'='Win32_LogicalDisk'
                              'Filter'="DeviceId='$sysdrive'"
                              'CimSession'=$session}
            $drive = Get-CimInstance @drive_params

            $proc_params = @{'ClassName'='Win32_Processor'
                             'CimSession'=$session}
            $proc = Get-CimInstance @proc_params |
                    Select-Object -first 1

  
            Write-Verbose "Closing session to $computer"
            $session | Remove-CimSession
  
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
                       
                       #'&lt;========= This is where you would 'add' things to the object
                       
            Write-Output $obj
        } Catch {
            Write-Warning "FAILED $computer on $protocol"
            
            #' Did we specify protocol fallback?
            #' If so, try again. If we specified logging,
            #' we won't log a problem here - we'll let
            #' the logging occur if this fallback also
            #' fails
            If ($ProtocolFallback) {
                If ($Protocol -eq 'Dcom') {
                    $newprotocol = 'Wsman'
                } else {
                    $newprotocol = 'Dcom'
                } #'if protocol

                Write-Verbose "Trying again with $newprotocol"
                $params = @{'ComputerName'=$Computer
                            'Protocol'=$newprotocol
                            'ProtocolFallback'=$False}
                
                If ($PSBoundParameters.ContainsKey('LogFailuresToPath')){
                    $params += @{'LogFailuresToPath'=$LogFailuresToPath}
                } #'if logging

                Get-MachineInfo @params
            } #'if protocolfallback

            #' if we didn't specify fallback, but we
            #' did specify logging, then log the error,
            #' because we won't be trying again
            If (-not $ProtocolFallback -and
                $PSBoundParameters.ContainsKey('LogFailuresToPath')){
                Write-Verbose "Logging to $LogFailuresToPath"
                $computer | Out-File $LogFailuresToPath -Append
            } #' if write to log

        } #'try/catch
 
    } #'foreach
} #'PROCESS

END {}

} #'function

===========================================================================================

#' this is the bit we'll change
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}
            Write-Output $obj



#' here's the change
            Write-Verbose "Outputting for $computer"
            $obj = [pscustomobject]@{'ComputerName'=$computer
                       'OSVersion'=$os.version
                       'SPVersion'=$os.servicepackmajorversion
                       'OSBuild'=$os.buildnumber
                       'Manufacturer'=$cs.manufacturer
                       'Model'=$cs.model
                       'Procs'=$cs.numberofprocessors
                       'Cores'=$cs.numberoflogicalprocessors
                       'RAM'=($cs.totalphysicalmemory / 1GB)
                       'Arch'=$proc.addresswidth
                       'SysDriveFreeSpace'=$drive.freespace}

            #' create a default display property set                          #'  &lt;==========display property set
            [string[]]$props = 'ComputerName','OSVersion','Cores','RAM'
            $ddps = New-Object -TypeName System.Management.Automation.PSPropertySet `
                               DefaultDisplayPropertySet, $props
            $pssm = [System.Management.Automation.PSMemberInfo[]]$ddps
            $obj | Add-Member -MemberType MemberSet `
                              -Name PSStandardMembers `
                              -Value $pssm

            Write-Output $obj

--------------------------------------------------
'USAGE of predefined group of properties:
&gt; $a | Select Computername,OSVersion,OSBuild,Arch
'shortens to this:
&gt; $a | Select OS
---------------------------------------------

#' more member types...
#'adding an alias, after the object is defined
$obj | Add-Member -MemberType AliasProperty `
                    -Name Free `
                    -Value SysDriveFreeSpace
                    
'USAGE
-------                    
&gt; $a.SysDriveFreeSpace

--------------------------------------------------------------

#'adding a script method, after the object is defined
$obj | Add-Member -MemberType ScriptMethod `
                    -Name Ping `
                    -Value { Test-NetConnection $this.computername }
                    
'USAGE of a Method
--------------
&gt;$a.ping()                    
                    
---------------------------------------------------------------
#'adding a script property, after the object is defined
$obj | Add-Member -MemberType ScriptProperty `
                    -Name TopProcesses `
                    -Value { 
                    Get-Process -ComputerName $this.computername |
                    Sort-Object -Property WorkingSet -Descending |
                    Select-Object -first 5
                    }
'USAGE of property
----------------
&gt;$a.TopProcesses


#' insert a custom name
$obj.psobject.TypeNames.Insert(0,"myMachineInfo")   &lt;=== The authors said this was flaky



#' extending with update-typedata
$myType = "myMachineInfo"

Update-TypeData -TypeName $myType -DefaultDisplayPropertySet 'ComputerName','OSVersion','Cores','RAM' -force

Update-TypeData -TypeName $myType -MemberType AliasProperty -MemberName Free `
                                  -Value SysDriveFreeSpace -force 

Update-TypeData -TypeName $myType -MemberType ScriptMethod -MemberName Ping `
                                  -Value { 
                                    Test-NetConnection $this.computername 
                                   } -force 

Update-TypeData -TypeName $myType -MemberType ScriptProperty -MemberName `
                              TopProcesses -Value { 
                              Get-Process -ComputerName $this.computername |
                              Sort-Object -Property WorkingSet -Descending |
                              Select-Object -first 5
                              } -force



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>COPY_From_one_directory_to_another_directory</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>COPY_From_one_directory_to_another_directory</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' You can import modules without including the path if you store it
#' in one of the default locations. To see this, look at the 
#' environment variable PSModulePath
$env:PSModulePath

#' We will use the 'User' location for modules. Note if you've not used
#' modules before, the WindowsPowerShell\Modules\ folder may not exist, 
#' so check first to see if you need to manually create. 

#' Here is the path to the user folder of modules for this machine
#' (if you are running on your own computer, you'll need to update for
#' your computer)
$userModulePath = 'C:\Users\rcain_000\Documents\WindowsPowerShell\Modules\'

#' Reminder here's the original path for the demos
$modulePath = 'C:\PS\Beginning PowerShell Scripting for Developers\demo\'

#' Name of our module
$moduleName = 'bpsd-m05-module-advanced-module'

#' First, we'll setup the new path for our module in the user folder,
#' then create that folder
$userModulePathBPSD = "$($userModulePath)$($moduleName)" 
New-Item -ItemType directory -Force $userModulePathBPSD

#' Note if you have made a lot of changes to the files (i.e. removing files 
#' from the module) you may wish to clean out the directory prior to copying
Remove-Item "$($userModulePathBPSD)\*.*"

#' Copy our module to the users module folder (force will overwrite if there)
Copy-Item "$($modulePath)bpsd-m05-module-advanced-*.*" `    #' &lt;===========COPY from SOURCE
          $userModulePathBPSD `								#' &lt;===========To Destination 
          -Force
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CREATE_Folder</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CREATE_Folder</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$env:PSModulePath

#' We will use the 'User' location for modules. Note if you've not used
#' modules before, the WindowsPowerShell\Modules\ folder may not exist, 
#' so check first to see if you need to manually create. 

#' Here is the path to the user folder of modules for this machine
#' (if you are running on your own computer, you'll need to update for
#' your computer)
$userModulePath = 'C:\Users\rcain_000\Documents\WindowsPowerShell\Modules\'

#' Reminder here's the original path for the demos
$modulePath = 'C:\PS\Beginning PowerShell Scripting for Developers\demo\'

#' Name of our module
$moduleName = 'bpsd-m05-module-advanced-module'

#' First, we'll setup the new path for our module in the user folder,
#' then create that folder
$userModulePathBPSD = "$($userModulePath)$($moduleName)" 
New-Item -ItemType directory -Force $userModulePathBPSD             #' &lt;==== CREATE the directory</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Help</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>example</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Help</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>example</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'You do not have to use all-uppercase letters, but the period preceding each help keyword 
'	(.SYNOPSIS, .DESCRIPTION) must be in the first column. 
 



# completed...
function Get-MachineInfo {
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.
.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.
.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.
.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.
.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.
.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.
.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.
.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline=$True,
                   Mandatory=$True)]
        [Alias('CN','MachineName','Name')]
        [string[]]$ComputerName,
        
        [string]$LogFailuresToPath,

        [ValidateSet('Wsman','Dcom')]
        [string]$Protocol = "Wsman",

        [switch]$ProtocolFallback
    )
 
 BEGIN {}

 PROCESS {
    foreach ($computer in $computername) {
 
        if ($protocol -eq 'Dcom') {
            $option = New-CimSessionOption -Protocol Dcom
        } else {
            $option = New-CimSessionOption -Protocol Wsman
        }
 
        Write-Verbose "Connecting to $computer over $protocol"
        $session = New-CimSession -ComputerName $computer `
                                  -SessionOption $option
  
        Write-Verbose "Querying from $computer"
        $os_params = @{'ClassName'='Win32_OperatingSystem'
                       'CimSession'=$session}
        $os = Get-CimInstance @os_params

        $cs_params = @{'ClassName'='Win32_ComputerSystem'
                       'CimSession'=$session}
        $cs = Get-CimInstance @cs_params

        $sysdrive = $os.SystemDrive
        $drive_params = @{'ClassName'='Win32_LogicalDisk'
                          'Filter'="DeviceId='$sysdrive'"
                          'CimSession'=$session}
        $drive = Get-CimInstance @drive_params

        $proc_params = @{'ClassName'='Win32_Processor'
                         'CimSession'=$session}
        $proc = Get-CimInstance @proc_params |
                Select-Object -first 1

  
        Write-Verbose "Closing session to $computer"
        $session | Remove-CimSession
  
        Write-Verbose "Outputting for $computer"
        $obj = [pscustomobject]@{'ComputerName'=$computer
                   'OSVersion'=$os.version
                   'SPVersion'=$os.servicepackmajorversion
                   'OSBuild'=$os.buildnumber
                   'Manufacturer'=$cs.manufacturer
                   'Model'=$cs.model
                   'Procs'=$cs.numberofprocessors
                   'Cores'=$cs.numberoflogicalprocessors
                   'RAM'=($cs.totalphysicalmemory / 1GB)
                   'Arch'=$proc.addresswidth
                   'SysDriveFreeSpace'=$drive.freespace}
        Write-Output $obj
 
    } #foreach
} #PROCESS

END {}

} #function



# prettier...
&lt;#
.SYNOPSIS
Retrieves specific information about one or more
computers, using WMI or CIM.

.DESCRIPTION
This command uses either WMI or CIM to retrieve
specific information about one or more computers.
You must run this command as a user who has permission
to remotely query CIM or WMI on the machines involved.
You can specify a starting protocol (CIM by default),
and specify that, in the event of a failure, the other
protocol be used on a per-machine basis.

.PARAMETER ComputerName
One or more computer names. When using WMI, this can
also be IP addresses. IP addresses may not work for CIM.

.PARAMETER LogFailuresToPath
A path and filename to write failed computer names to.
If omitted, no log will be written.

.PARAMETER Protocol
Valid values: Wsman (uses CIM) or Dcom (uses WMI). Will
be used for all machines. "Wsman" is the default.

.PARAMETER ProtocolFallback
Specify this to automatically try the other protocol if
a machine fails.

.EXAMPLE
Get-MachineInfo -ComputerName ONE,TWO,THREE
This example will query three machines.

.EXAMPLE
Get-ADUser -filter * | Select -Expand Name | Get-MachineInfo
This example will attempt to query all machines in AD.
#&gt;



# more sections...
&lt;#
.INPUTS
System.String

.NOTES
version     : 1.0.0
last updated: 1 February, 2017

.LINK
https://powershell.org/forums/
.LINK
Get-CimInstance
.LINK
Get-WmiObject

#&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_JSON</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>snippets_from_Training</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_JSON</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>snippets_from_Training</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' json
{
    "Name":  "bits",
    "DisplayName":  "Background Intelligent Transfer Service",
    "Status":  4
}



#' more json
[
    {
        "Name":  "BITS",
        "DisplayName":  "Background Intelligent Transfer Service",
        "Status":  4
    },
    {
        "Name":  "Bluetooth Device Monitor",
        "DisplayName":  "Bluetooth Device Monitor",
        "Status":  4
    },
    {
        "Name":  "Bluetooth OBEX Service",
        "DisplayName":  "Bluetooth OBEX Service",
        "Status":  4
    },
    {
        "Name":  "BrokerInfrastructure",
        "DisplayName":  "Background Tasks Infrastructure Service",
        "Status":  4
    },
    {
        "Name":  "Browser",
        "DisplayName":  "Computer Browser",
        "Status":  4
    },
    {
        "Name":  "BthHFSrv",
        "DisplayName":  "Bluetooth Handsfree Service",
        "Status":  1
    },
    {
        "Name":  "bthserv",
        "DisplayName":  "Bluetooth Support Service",
        "Status":  4
    }
]



#' nested objects
{
    "Name":  "bits",
    "DisplayName":  "Background Intelligent Transfer Service",
    "Status":  4,
    "RequiredServices":  [
                     {
                         "CanPauseAndContinue":  false,
                         "CanShutdown":  false,
                         "CanStop":  false,
                         "DisplayName":  "Remote Procedure Call (RPC)",
                         "DependentServices":  null,
                         "MachineName":  ".",
                         "ServiceName":  "RpcSs",
                         "ServicesDependedOn":  "DcomLaunch RpcEptMapper",
                         "ServiceHandle":  null,
                         "Status":  4,
                         "ServiceType":  32,
                         "StartType":  2,
                         "Site":  null,
                         "Container":  null
                     },
                     {
                         "CanPauseAndContinue":  false,
                         "CanShutdown":  false,
                         "CanStop":  true,
                         "DisplayName":  "COM+ Event System",
                         "DependentServices":  "igfxCUIService1.0.0.0 
                          COMSysApp SENS BITS",
                         "MachineName":  ".",
                         "ServiceName":  "EventSystem",
                         "ServicesDependedOn":  "rpcss",
                         "ServiceHandle":  null,
                         "Status":  4,
                         "ServiceType":  32,
                         "StartType":  2,
                         "Site":  null,
                         "Container":  null
                     }
                         ]
}



#' convert to json   &lt;==================================================== ConvertTo-Json
get-ciminstance win32_computersystem | convertto-json



#' now into a file &lt;====================================================== Output to a file
get-ciminstance win32_computersystem | convertto-json | out-file wmics.json
'OR
get-ciminstance win32_computersystem | convertto-json | set-content .\wmics2.json 



#' smaller data  (COMPRESSED)
get-ciminstance win32_computersystem | convertto-json -compress



#' filter first
get-ciminstance win32_computersystem -computername $env:computername | 
select PSComputername,Manufacturer,
@{Name="MemoryGB";Expression={$_.totalPhysicalmemory/1GB -as [int]}},
Number* | ConvertTo-Json



#' creates
{
    "PSComputerName":  "CLIENT01",
    "Manufacturer":  "LENOVO",
    "MemoryGB":  8,
    "NumberOfLogicalProcessors":  4,
    "NumberOfProcessors":  1
}

'if you want to create a json file, perhaps to hold configuration data or something similar, 
'	DON'T try to manually create the file. 
'	Instead, “objectify” your data in PowerShell and then convert to JSON. 


#' custom objects   '&lt;================================ Easiest way to build a JSON record(s)
[pscustomobject]@{
  Path = "C:\Scripts"
  LastModified = "1/1/2017"
  Count = 20
  Types = @(".ps1","psm1","psd1","json","xml")
} | ConvertTo-Json



#' creates
{
    "Path":  "C:\\Scripts",
    "LastModified":  "1/1/2017",
    "Count":  20,
    "Types":  [
                  ".ps1",
                  "psm1",
                  "psd1",
                  "json",
                  "xml"
              ]
}



#' metadata
[pscustomobject]@{
  Created = (Get-Date)
  Comment = "config data for script tool"
},
[pscustomobject]@{
  Path = "C:\Scripts"
  LastModified = "1/1/2017"
  Count = 20
  Types = @(".ps1","psm1","psd1","json","xml")
} | ConvertTo-Json 



#' creates
[
    {
        "Created":  {
                        "value":  "\/Date(1483398036020)\/",
                        "DisplayHint":  2,
                        "DateTime":  "Monday, January 2, 2017 6:00:36 PM"
                    },
        "Comment":  "config data for script tool"
    },
    {
        "Path":  "C:\\Scripts",
        "LastModified":  "1/1/2017",
        "Count":  20,
        "Types":  [
                      ".ps1",
                      "psm1",
                      "psd1",
                      "json",
                      "xml"
                  ]
    }
]



#' slight change
[pscustomobject]@{
  Created = (Get-Date).Tostring()   '&lt;============  To make it less complicated turn it into a string first
  Comment = "config data for script tool"
},



#' now results
{
        "Created":  "1/2/2017 6:03:40 PM",
        "Comment":  "config data for script tool"
    }



#' json snippet
 {
        "Name":  "wuauserv",
        "DisplayName":  "Windows Update",
        "Status":  1,
        "MachineName":  "chi-dc04",
        "Audit":  "12/01/16"
    },



#' convert from json
$in = get-content c:\work\audit.json | convertfrom-json         #'  &lt;=============== ConvertFrom-Json.

$in | get-member

$in[0..2]

$in[0..2] | Select Name,Displayname,
@{Name="Status";Expression = { $_.Status -as
System.ServiceProcess.ServiceControllerStatus]}},
@{Name="Audit";Expression= { $_.Audit -as [datetime]}},
@{Name="Computername";Expression = {$_.Machinename}}



#' again
get-content c:\work\audit.json | 
convertfrom-json | Select Name,Displayname,
@{Name="Status";Expression = { $_.Status -as [System.ServiceProcess.ServiceControllerStatus]}},
@{Name="Audit";Expression= { $_.Audit -as [datetime]}},
@{Name="Computername";Expression = {$_.Machinename}}



#' fix
get-content c:\work\audit.json | 
convertfrom-json | 
foreach { $_ | Select Name,Displayname,
@{Name="Status";Expression = { $_.Status -as [System.ServiceProcess.ServiceControllerStatus]}},
@{Name="Audit";Expression= { $_.Audit -as [datetime]}},
@{Name="Computername";Expression = {$_.Machinename}}
}





</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogParser =&gt; SQL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogParser =&gt; SQL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'This command asks Log Parser to filter out entries for pages 
#'	ending up in ".gif", ".jpg", and ".png", 
#'	regardless of the capitalization of the URL. 
#'	It also leaves out requests that generated the HTTP error code "404", 
#'	that is, "page not found".

#'Everything else is handed to the SQL output format, 
#'	which will save the records to the table specified in the INTO clause. 
#'	Also, this output format accepts a "database" parameter 
#'	that we can use to specify the name of the target database, 
#'	together with many other parameters that let us specify other properties of the connection 
#'	to the SQL database.

#'To do this, you could put the command above in a batch file, use the SCHTASKS.EXE utility to schedule the batch 
#'	file to run, say, every hour, and ' poof! ' you'd have an automated mechanism that periodically 
#'	uploads entries from your log files to your SQL database.
#'Note that every time you execute the command above, 
#'	Log Parser goes through all the log entries over and over, 
#'	uploading all of them multiple times to the database. 
#'	What we really need is a mechanism to say "only parse the log entries not parsed yet."
#'Here's where a new Log Parser 2.2 feature comes handy: the "incremental parsing" feature, 
#'	also know as "checkpointing."

Checkpoints
===========
#'Most Log Parser input formats support a parameter, called "iCheckpoint", 
#'	that tells the input format to save to a private data file (a "checkpoint" file) 
#'	the current state of all the files being parsed. 
#'	When you execute a query using a checkpoint file generated during a previous run, 
#'	the input format will only parse those portions of the input files that were not parsed before, that is, new entries only.


logparser "SELECT * INTO LogsTable FROM ex*.log WHERE TO_LOWERCASE (EXTRACT_EXTENSION(cs-uri-stem)) NOT IN ('gif';'jpg';'png') AND sc-status &lt;&gt; 404" -i:IISW3C -o:SQL -database:LogsDatabase

#'So, all you need to do is specify the name of a checkpoint file with the "iCheckpoint" parameter, as follows:

&gt;logparser "SELECT * INTO LogsTable FROM ex*.log WHERE TO_LOWERCASE (EXTRACT_EXTENSION(cs-uri-stem)) NOT IN ('gif';'jpg';'png') AND sc-status &lt;&gt; 404" -i:IISW3C -o:SQL -database:LogsDatabase -iCheckpoint:MyCheckpoint.lpc

#'The very first time you execute this command, 
#'	the "MyCheckpoint.lpc" file does not exist, 
#'	and the IISW3C input format parses all the entries in all the log files, 
#'	filtering and uploading the resulting data to the database. 
#'After parsing all the logs, the IISW3C input format saves the current size of each log file to the "MyCheckpoint.lpc" file.
#'When you execute the same command at a later time, 
#'	the IISW3C input format will load the checkpoint file 
#'	and will parse the logs starting at the position where they were left in the previous run, 
#'	thus processing, filtering, and uploading new log entries only. 
#'When completed, it will update the checkpoint file with the new size of the log files, 
#'	and the cycle repeats itself continually.


#'	-o:sql
#'	-database:AdventureWorks2012
#'	-server:localhost\sqlsrv2012
#'	-driver:"sql server"
#'	SELECT...into ScmEvents  {the SQL table}
&gt; logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" "select extract_token(EventTypeName, 0, ' ') as TypeEvent,  to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where SourceName = 'Service  Control Manager' and SID is not null"

'Delete
===========
#'there might also be times when you want to delete the data in the target table before inserting the new information. 
#'	To do so, you can use the -clearTable parameter with the sql output format, as shown in the following example:
#' IT IS MUCH MORE EFFICIENT TO USE SQL and run a truncate statement
&gt; logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on "select extract_token(EventTypeName, 0, ' ') as  TypeEvent, to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where SourceName =  'Service Control Manager' and SID is not null"

Insert data into table with IDENTITY Fields in table
====================================================
#'when you insert Log Parser data into a SQL Server table, 
#'    the number and position of fields must match the target table, 
#'    as was the case in the preceding two examples. 
#'However, there is one exception to the rule. 
#'    If the target table includes a column configured with the IDENTITY property, 
#'    you can specify that no data be inserted into that column. 
#'    Let’s re-create our target table to demonstrate how this works. 
#'The following T-SQL again creates the ScmEvents table, but this time includes the EventID column, 
#'    which is configured with the IDENTITY property:

USE AdventureWorks2012;
GO
IF OBJECT_ID('ScmEvents','U')IS NOT NULL
DROP TABLEScmEvents;
GO
CREATETABLE dbo.ScmEvents
(
  EventIDint primarykey identity,
  TypeEventvarchar(25) NOT NULL,
  DateGenerateddatetime NOT NULL,
  SecurityIDvarchar(50) NULL
);
GO

#'When using Log Parser to insert data into a table with an IDENTITY column, 
#'    we can use the -ignoreIdCols parameter with the sql output format to prevent the utility from trying to insert data into that column. 
#'    The following example includes the -ignoreIdCols parameter with it set to on:

logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on -ignoreIdCols:on "select extract_token(EventTypeName,  0, ' ') as TypeEvent, to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where  SourceName = 'Service Control Manager' and SID is not null"

CreateTable
============
#'When you run the command, Log Parser will create the table in the target database if the table does not already exist. 
#'However, if you were to run this command without including the -createTable parameter and the table did not exist, 
#'Log Parser would return an error.

&gt;logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on -createTable:on "select extract_token(EventTypeName, 0,  ' ') as TypeEvent, to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where  SourceName = 'Service Control Manager' and SID is not null"


Query in External File
========================
#'When your SQL query becomes too unwieldy, 
#'    you can put the SQL in a separate file and call that file from your Log Parser command. 
#'For example, suppose we save the query in the previous example to the file C:\DataFiles\EvtQuery.sql

#'Once we’ve created the file for our query, we can modify our command as follows:

logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on -createTable:on file:c:\datafiles\evtquery.sql
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-Help___Update-Help</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-Help___Update-Help</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>I had to run 'Update-Help' 
from the PS comand line, rather than the ISE




#' More help on modules
Get-Help about_modules

#' Other about topics
Get-Help about*</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-PendingReboot</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-PendingReboot</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gallery.technet.microsoft.com/scriptcenter/Get-PendingReboot-Query-bdb79542

https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/10/determine-pending-reboot-statuspowershell-style-part-1/
https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/11/determine-pending-reboot-statuspowershell-style-part-2/ 


'USAGE:
$Servers = Get-Content C:\DATA\2018_04_20__RespondToPing.txt 
Get-PendingReboot -Computer $Servers | Export-Csv C:\DATA\PendingRebootReport.csv -NoTypeInformation 

============================================================================


Function Get-PendingReboot
{
&lt;#
.SYNOPSIS
    Gets the pending reboot status on a local or remote computer.

.DESCRIPTION
    This function will query the registry on a local or remote computer and determine if the
    system is pending a reboot, from Microsoft updates, Configuration Manager Client SDK, Pending Computer 
    Rename, Domain Join or Pending File Rename Operations. For Windows 2008+ the function will query the 
    CBS registry key as another factor in determining pending reboot state.  "PendingFileRenameOperations" 
    and "Auto Update\RebootRequired" are observed as being consistant across Windows Server 2003 &amp; 2008.
	
    CBServicing = Component Based Servicing (Windows 2008+)
    WindowsUpdate = Windows Update / Auto Update (Windows 2003+)
    CCMClientSDK = SCCM 2012 Clients only (DetermineIfRebootPending method) otherwise $null value
    PendComputerRename = Detects either a computer rename or domain join operation (Windows 2003+)
    PendFileRename = PendingFileRenameOperations (Windows 2003+)
    PendFileRenVal = PendingFilerenameOperations registry value; used to filter if need be, some Anti-
                     Virus leverage this key for def/dat removal, giving a false positive PendingReboot

.PARAMETER ComputerName
    A single Computer or an array of computer names.  The default is localhost ($env:COMPUTERNAME).

.PARAMETER ErrorLog
    A single path to send error data to a log file.

.EXAMPLE
    PS C:\&gt; Get-PendingReboot -ComputerName (Get-Content C:\ServerList.txt) | Format-Table -AutoSize
	
    Computer CBServicing WindowsUpdate CCMClientSDK PendFileRename PendFileRenVal RebootPending
    -------- ----------- ------------- ------------ -------------- -------------- -------------
    DC01           False         False                       False                        False
    DC02           False         False                       False                        False
    FS01           False         False                       False                        False

    This example will capture the contents of C:\ServerList.txt and query the pending reboot
    information from the systems contained in the file and display the output in a table. The
    null values are by design, since these systems do not have the SCCM 2012 client installed,
    nor was the PendingFileRenameOperations value populated.

.EXAMPLE
    PS C:\&gt; Get-PendingReboot
	
    Computer           : WKS01
    CBServicing        : False
    WindowsUpdate      : True
    CCMClient          : False
    PendComputerRename : False
    PendFileRename     : False
    PendFileRenVal     : 
    RebootPending      : True
	
    This example will query the local machine for pending reboot information.
	
.EXAMPLE
    PS C:\&gt; $Servers = Get-Content C:\Servers.txt
    PS C:\&gt; Get-PendingReboot -Computer $Servers | Export-Csv C:\PendingRebootReport.csv -NoTypeInformation
	
    This example will create a report that contains pending reboot information.

.LINK
    Component-Based Servicing:
    http://technet.microsoft.com/en-us/library/cc756291(v=WS.10).aspx
	
    PendingFileRename/Auto Update:
    http://support.microsoft.com/kb/2723674
    http://technet.microsoft.com/en-us/library/cc960241.aspx
    http://blogs.msdn.com/b/hansr/archive/2006/02/17/patchreboot.aspx

    SCCM 2012/CCM_ClientSDK:
    http://msdn.microsoft.com/en-us/library/jj902723.aspx

.NOTES
    Author:  Brian Wilhite
    Email:   bcwilhite (at) live.com
    Date:    29AUG2012
    PSVer:   2.0/3.0/4.0/5.0
    Updated: 27JUL2015
    UpdNote: Added Domain Join detection to PendComputerRename, does not detect Workgroup Join/Change
             Fixed Bug where a computer rename was not detected in 2008 R2 and above if a domain join occurred at the same time.
             Fixed Bug where the CBServicing wasn't detected on Windows 10 and/or Windows Server Technical Preview (2016)
             Added CCMClient property - Used with SCCM 2012 Clients only
             Added ValueFromPipelineByPropertyName=$true to the ComputerName Parameter
             Removed $Data variable from the PSObject - it is not needed
             Bug with the way CCMClientSDK returned null value if it was false
             Removed unneeded variables
             Added PendFileRenVal - Contents of the PendingFileRenameOperations Reg Entry
             Removed .Net Registry connection, replaced with WMI StdRegProv
             Added ComputerPendingRename
#&gt;

[CmdletBinding()]
param(
	[Parameter(Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
	[Alias("CN","Computer")]
	[String[]]$ComputerName="$env:COMPUTERNAME",
	[String]$ErrorLog
	)

Begin {  }##'End Begin Script Block
Process {
  Foreach ($Computer in $ComputerName) {
	Try {
	    ##'Setting pending values to false to cut down on the number of else statements
	    $CompPendRen,$PendFileRename,$Pending,$SCCM = $false,$false,$false,$false
                        
	    ##'Setting CBSRebootPend to null since not all versions of Windows has this value
	    $CBSRebootPend = $null
						
	    ##'Querying WMI for build version
	    $WMI_OS = Get-WmiObject -Class Win32_OperatingSystem -Property BuildNumber, CSName -ComputerName $Computer -ErrorAction Stop

	    ##'Making registry connection to the local/remote computer
	    $HKLM = [UInt32] "0x80000002"
	    $WMI_Reg = [WMIClass] "\\$Computer\root\default:StdRegProv"
						
	    ##'If Vista/2008 &amp; Above query the CBS Reg Key
	    If ([Int32]$WMI_OS.BuildNumber -ge 6001) {
		    $RegSubKeysCBS = $WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\")
		    $CBSRebootPend = $RegSubKeysCBS.sNames -contains "RebootPending"		
	    }
							
	    ##'Query WUAU from the registry
	    $RegWUAURebootReq = $WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\")
	    $WUAURebootReq = $RegWUAURebootReq.sNames -contains "RebootRequired"
						
	    ##'Query PendingFileRenameOperations from the registry
	    $RegSubKeySM = $WMI_Reg.GetMultiStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\Session Manager\","PendingFileRenameOperations")
	    $RegValuePFRO = $RegSubKeySM.sValue

	    ##'Query JoinDomain key from the registry - These keys are present if pending a reboot from a domain join operation
	    $Netlogon = $WMI_Reg.EnumKey($HKLM,"SYSTEM\CurrentControlSet\Services\Netlogon").sNames
	    $PendDomJoin = ($Netlogon -contains 'JoinDomain') -or ($Netlogon -contains 'AvoidSpnSet')

	    ##'Query ComputerName and ActiveComputerName from the registry
	    $ActCompNm = $WMI_Reg.GetStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName\","ComputerName")            
	    $CompNm = $WMI_Reg.GetStringValue($HKLM,"SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\","ComputerName")

	    If (($ActCompNm -ne $CompNm) -or $PendDomJoin) {
	        $CompPendRen = $true
	    }
						
	    ##'If PendingFileRenameOperations has a value set $RegValuePFRO variable to $true
	    If ($RegValuePFRO) {
		    $PendFileRename = $true
	    }

	    ##'Determine SCCM 2012 Client Reboot Pending Status
	    ##'To avoid nested 'if' statements and unneeded WMI calls to determine if the CCM_ClientUtilities class exist, setting EA = 0
	    $CCMClientSDK = $null
	    $CCMSplat = @{
	        NameSpace='ROOT\ccm\ClientSDK'
	        Class='CCM_ClientUtilities'
	        Name='DetermineIfRebootPending'
	        ComputerName=$Computer
	        ErrorAction='Stop'
	    }
	    ##'Try CCMClientSDK
	    Try {
	        $CCMClientSDK = Invoke-WmiMethod @CCMSplat
	    } Catch [System.UnauthorizedAccessException] {
	        $CcmStatus = Get-Service -Name CcmExec -ComputerName $Computer -ErrorAction SilentlyContinue
	        If ($CcmStatus.Status -ne 'Running') {
	            Write-Warning "$Computer`: Error - CcmExec service is not running."
	            $CCMClientSDK = $null
	        }
	    } Catch {
	        $CCMClientSDK = $null
	    }

	    If ($CCMClientSDK) {
	        If ($CCMClientSDK.ReturnValue -ne 0) {
		        Write-Warning "Error: DetermineIfRebootPending returned error code $($CCMClientSDK.ReturnValue)"          
		    }
		    If ($CCMClientSDK.IsHardRebootPending -or $CCMClientSDK.RebootPending) {
		        $SCCM = $true
		    }
	    }
            
	    Else {
	        $SCCM = $null
	    }

	    ##'Creating Custom PSObject and Select-Object Splat
	    $SelectSplat = @{
	        Property=(
	            'Computer',
	            'CBServicing',
	            'WindowsUpdate',
	            'CCMClientSDK',
	            'PendComputerRename',
	            'PendFileRename',
	            'PendFileRenVal',
	            'RebootPending'
	        )}
	    New-Object -TypeName PSObject -Property @{
	        Computer=$WMI_OS.CSName
	        CBServicing=$CBSRebootPend
	        WindowsUpdate=$WUAURebootReq
	        CCMClientSDK=$SCCM
	        PendComputerRename=$CompPendRen
	        PendFileRename=$PendFileRename
	        PendFileRenVal=$RegValuePFRO
	        RebootPending=($CompPendRen -or $CBSRebootPend -or $WUAURebootReq -or $SCCM -or $PendFileRename)
	    } | Select-Object @SelectSplat

	} Catch {
	    Write-Warning "$Computer`: $_"
	    ##'If $ErrorLog, log the file to a user specified location/path
	    If ($ErrorLog) {
	        Out-File -InputObject "$Computer`,$_" -FilePath $ErrorLog -Append
	    }				
	}			
  }##'End Foreach ($Computer in $ComputerName)			
}##'End Process

End {  }##'End End

}##'End Function Get-PendingReboot</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>HELP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>HELP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Example of getting help for 'Get-Command'
&gt; Get-Help Get-Command

&gt;Update-Help  {to get the updates}

#region Cmdlets

	# Get-Command - Retrieves a list of all system commands
	Get-Command
	
	# Can expand by searching for just a verb or noun
	Get-Command -verb "get"
	Get-Command -noun "service"
	
	# Get-Help can be used to explain a command 
	Get-Help Get-Command
	Get-Help Get-Command -examples		#show all the examples
	Get-Help Get-Command -detailed
	Get-Help Get-Command -full
	Get-Help Get-Command -Online   # PS 3 - VERY good for reading - This brings up default browser, and help on the command
	
	# Most commands can also be passed a -? paramter to get help
	Get-Command -?

#endregion Cmdlets



Get-Help 'cmdlet displays information
'The cmdlet has also an Aliases set in the shell by default as 'help' and 'man'. 

'We can also limit to what type of information we may want with the –Category parameter

  help -Category Cmdlet -Name *service*
  
  'One can select what parts of a help file we want to see by specifying the parameter for the level of information one wants

–Detailed 		'parameter is given it will show Parameter information and Examples.
–Full 			'parameter is given it will show a more detailed list of info for Parameters.
–Examples 		'parameter is given only examples are shown.
-full 			'option is used we get additional information on the parameters:

'Syntax

Required for required options or values ==&gt; they will not be enclosed in any bracket.
Options or values enclosed in [ ] are optional
Values are represent with the type they take between &lt; &gt;
Those values that can be lists are represented as &lt;type[ ]&gt; 
Those that have a predefined list of options it can take are represented as &lt; option1 | option2 | option3&gt;


'With PowerShell v3 the
 –ShowWindow 			'parameter was added to open a separate window that can be used as reference while one works construction a command
 
&gt; help about      	'This will list all conceptual topics.


Get-Verb 			'cmdlet to get the list of approved verbs for PowerShell. 

Get-Command 		'gets the commands from Windows PowerShell modules 

=======================================================================


' Using help optional parmameters and their values are shown in brackets
==========================================================================

' No mandatory params
(Get-Help -Name Get-Service -Detailed).syntax			'&lt;=== This requests help on the syntax

' Only Path is mandatory
(Get-Help -Name Get-Content -Detailed).syntax

'Get-Command to find Mandatory parameters in cmdlets
'Note can run this up to each period "." in the ISE to see what that part does
(Get-Command -Name 'Get-Content').Parameters.Path.Attributes

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>REBOOT_into_Boot_Options_Local_or_Remote_computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>REBOOT_into_Boot_Options_Local_or_Remote_computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Can put the commands in a text file that ends in .bat and run as a batch

'The shutdown command is a Command Prompt command that can be used to shut down, restart, log off, or hibernate your own computer.

'You run shutdown from the command prompt or PowerShell interface. What you can do however is create shortcuts so that you don't 
	'have to write the commands each time you want to use them, but can simply click on the shortcut instead to run them. 

'The shutdown command can also be used to remotely shut down or restart a computer you have access to over a network.

shutdown /a -- This command stops a shut down or reboot process. 
				Can be useful if Windows Update decided that it is time to reboot the PC, 
				or if your actions or other programs started the process.
shutdown /s -- The shutdown command. This shuts down the computer when you run it.
shutdown /r -- Shuts down the computer, and restarts it afterwards.
shutdown /g -- Like shutdown /r, but will restart any registered program when the system has loaded.
shutdown /h -- Hibernates the local computer.
shutdown /l -- Logs off the current user.
shutdown /p -- Turns the computer off without prior warnings. Equals running shutdown /s /f /t 0

/m \\computer -- Specify a remote computer that you want to run the command on.

/e -- This enables documentation for the shutdown of the computer.
/i -- Show the graphics user interface. Must be the first option of the command, 
		and all other switches are ignored (as the graphical user interface is loaded).
/hybrid -- Shuts the computer down, and enables Fast Startup.
			 Must be used with /s
/t 0 -- Sets the timeout period before the shutdown. 
			The default is 30 seconds, and you may speed things up by setting /t 0.
/f -- Forces running programs to terminate without user warning.  Also /force.

/c "remark" -- Adds a comment that explains the reason for the shutdown or restart of the computer. 
	Supports a maximum of 512 characters, and is displayed on the shutdown prompt.
/d -- Adds a reason for the restart using a system of codes. 
		Basically, /d p:1:2 indicates a planned shutdown because of a hardware installation, 
		while /d u:1:2 a user defined shutdown because of a hardware installation. 
		You can leave out p and u to set an unplanned reason for the shutdown. 
		The table with major and minor reasons is displayed when you run shutdown /?.
/o -- This command restarts the PC and loads the Advanced Boot Menu on the next start. Needs to be run with /r
-----------------------------------------------------
'Run a fast shutdown. This forces applications to close, and sets the

shutdown /s /f /t:0

------------------------------------------------------
'This command shuts down the remote computer ComputerXYZ after 300 seconds forcefully, 
'	adds a reason for the shutdown, and displays the comment in the shutdown prompt.

shutdown /m \\ComputerXYZ /s /f /d p:1:2 /c "Computer will restart for maintenance, save your work" /t 300</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Repository</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Repository</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

&gt;Get-PSRepository
#' Default response:
Name                      InstallationPolicy   SourceLocation                                                                                                            
----                      ------------------   --------------                                                                                                            
PSGallery                 Untrusted            https://www.powershellgallery.com/api/v2/   

#'To find a module in the available repository, with a given 'tag'
&gt;Find-Module -tag sqlserver

#'Response from command above:
Version    Name                                Repository           Description                                                                                          
-------    ----                                ----------           -----------                                                                                          
21.0.17178 SqlServer                           PSGallery            This module allows SQL Server developers, administrators and business intelligence professionals t...
0.9.62     dbatools                            PSGallery            The community module that enables SQL Server Pros to automate database development and server admi...
1.0.0.3    mlSqlPs                             PSGallery            SQL Server Desired State Configuration module. Modified from xSqlPs and will contain all custom re...
0.0.2.8    ReportingServicesTools              PSGallery            Provides extra functionality for SSRS (SQL Server Reporting Services).                               
1.0.1      InvokeQuery                         PSGallery            Query any database!                                                                                  
0.9.0      dbareports                          PSGallery            Dopest dba dashboards ever                                                                           
1.1.0.3    SQLHelper                           PSGallery            A single lightweight powershell module with cmdlets to query/update databases with any .net provid...
1.13       Write-ObjectToSQL                   PSGallery            Writes an object into a database table. If the table does not exist it will be created based on th...
1.6.4      Invoke-SqlCmd2                      PSGallery            Invoke-SqlCmd2                                                                                       
1.0.0      cSQLServerJDBCXA                    PSGallery            Enable JDBC XA Transactions on SQL Server for enable JDBC XA Transactions on SQL Server              
0.9.1.0    SQLAutoRestores                     PSGallery            To automate the restore of SQL Server database for testing and compliance checking                   
1.3.0.0    Kelverion.IntegrationModule.SqlS... PSGallery            The Kelverion Integration Module for SQL Server enables easy interaction with on premise and Azure...
0.0.5      Database                            PSGallery            Database meta package                                                                                
1.0.0.4    SQLServerUpdatesModule              PSGallery            The module can parse information about updates with http://sqlserverupdates.com/. Next, it checks ...
0.9.1      SQLDiagAPI                          PSGallery            This is a module to work with the SQL Server Diagnostics (Preview) API. See https://blogs.msdn.mic...
1.0.0.1    SQLServerJobsModule                 PSGallery            The script allows you to generate a job report from several servers. Allows you to specify a time ...

#' Then to get info about the first one in the list:
&gt; find-module sqlserver | Select-Object *

#' To install the module if you want it (into one of the folders in my module path)
&gt;install-module sqlserver

#' after installing it, confirm that it is available:
&gt;get-module sqlserver -ListAvailable

#' Then see what commands are in it:
&gt;get-command -module sqlserver | more</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Visual_Studio_to_DEBUG_PowerShell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Visual_Studio_to_DEBUG_PowerShell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
PowerShell Tools for Visual Studio 2015 (or through VS extensions and updates)
https://visualstudiogallery.msdn.microsoft.com/c9eb3ba8-0c59-4944-9a62-6eee37294597

YouTube: https://www.youtube.com/watch?v=g4lJOoVJmjM

Not watched yet:
https://www.youtube.com/watch?v=9s12jVG8cYI</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Modules</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_01_Advanced_Module_and_Path_to_make_it_Easier</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Modules</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_01_Advanced_Module_and_Path_to_make_it_Easier</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#''Example_01_Advanced_Module_and_Path_to_make_it_Easier

#'-----------------------------------------------------------------------------#
#' Module Path
#'-----------------------------------------------------------------------------#

#' You can import modules without including the path if you store it
#' in one of the default locations. To see this, look at the 
#' environment variable PSModulePath
$env:PSModulePath

#' We will use the 'User' location for modules. Note if you've not used
#' modules before, the WindowsPowerShell\Modules\ folder may not exist, 
#' so check first to see if you need to manually create. 

#' Here is the path to the user folder of modules for this machine
#' (if you are running on your own computer, you'll need to update for
#' your computer)
$userModulePath = 'C:\Users\rcain_000\Documents\WindowsPowerShell\Modules\'

#' Reminder here's the original path for the demos
$modulePath = 'C:\PS\Beginning PowerShell Scripting for Developers\demo\'

#' Name of our module
$moduleName = 'bpsd-m05-module-advanced-module'

#' First, we'll setup the new path for our module in the user folder,
#' then CREATE that folder
$userModulePathBPSD = "$($userModulePath)$($moduleName)" 
New-Item -ItemType directory -Force $userModulePathBPSD

#' Note if you have made a lot of changes to the files (i.e. removing files 
#' from the module) you may wish to clean out the directory prior to copying
Remove-Item "$($userModulePathBPSD)\*.*"

#' Copy our module to the users module folder (force will overwrite if there)
Copy-Item "$($modulePath)bpsd-m05-module-advanced-*.*" `
          $userModulePathBPSD `
          -Force

#' Validate the files are there
Get-ChildItem $userModulePathBPSD 

#' It's not loaded into memory yet! 
Get-Module

#' Now you can import the bpsd-m05-module-advanced-module without the path
Import-Module -Force $moduleName

#' Verify it is loaded
Get-Module

#' Test
Write-A
Write-B
Write-M

#' Unload the module
Remove-Module $moduleName

#' Verify it is unloaded
Get-Module</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Modules</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_01_Advanced_Module_USAGE.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Modules</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_01_Advanced_Module_USAGE.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' Here is the path to the demo folder, and the name of the module manifest
#' (update for your computer as needed)
$modulePath = 'C:\PS\Beginning PowerShell Scripting for Developers\demo\'
$moduleName = 'bpsd-m05-module-advanced-module-manifest'

#' We will import the module manifest file using the full path
$module = "$($modulePath)$($moduleName).psd1"

#' To use a module, you first need to import it
Import-Module -Force $module

#' Now the functions are available
Write-A
Write-B
Write-M

#' Write-APrivate wasn't exported and hence isn't visible, causes error
Write-APrivate

#' You can manually unload the module, or when your session ends it will
#' be automatically be unloaded.
Remove-Module $moduleName

#' Verify it is unloaded
Get-Module





</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Object_CUSTOM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_METHOD_for_Object</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Object_CUSTOM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_METHOD_for_Object</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'If you need to add a script method to an object, 
'	you can do it with Add-Member and a ScriptBlock. 
'You have to use the this automatic varialbe reference the current object. 
'Here is a scriptblock to turn a object into a hashtable.

$ScriptBlock = {
    $hashtable = @{}
    foreach( $property in $this.psobject.properties.name )
    {
        $hashtable[$property] = $this.$property
    }
    return $hashtable
}

'Then we add it to our object as a script property.

$memberParam = @{
    MemberType ScriptMethod
    InputObject $myobject
    Name "ToHashtable"
    Value $scriptBlock
}
Add-Member @memberParam

'Then we can call our function like this:

$myObject.ToHashtable()


==============================================================ScriptProperty

$TypeData = @{
    TypeName = 'My.Object'
    MemberType = 'ScriptProperty'
    MemberName = 'UpperCaseName'
    Value = {$this.Name.toUpper()}
}
Update-TypeData @TypeData

#'You can do this before your object is created or after and it will still work. 
#'This is what makes this different then using Add-Member with a script property. 
#'When you use Add-Member the way I refferenced earlier, 
#'	it only exists on that specific instance of the object. 
#'This one applies to all objects with this TypeName.
#'

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Object_CUSTOM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>DefaultPropertySet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Object_CUSTOM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>DefaultPropertySet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'If I need to access or see those other properties, they are still there.

$myObject | Format-List *

========================================================================
'Powershell decides for us what properties to display by default. 
'A lot of the native commands have a .ps1xml formating file that does all the heavy lifting.

'there is another way for us to do this on our custom object using just Powershell. 
'We can give it a MemberSet for it to use.

$defaultDisplaySet = 'Name','Language'
$defaultDisplayPropertySet = New-Object System.Management.Automation.PSPropertySet(‘DefaultDisplayPropertySet’,[string[]]$defaultDisplaySet)
$PSStandardMembers = [System.Management.Automation.PSMemberInfo[]]@($defaultDisplayPropertySet)
$MyObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers

'Now when my object just falls to the shell, it will only show those properties by default.

=====================================================================================
'using Update-TypeData to specify the default properties.

$TypeData = @{
    TypeName = 'My.Object'
    DefaultDisplayPropertySet = 'Name','Language'
}
Update-TypeData @TypeData</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_b_CustomProperties</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_b_CustomProperties</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Example_1_b_CustomProperties

@{Name = 'something' ; Expression = {&lt;your code&gt;}}

'1] Create a special hashtable
'	Name and Expresion are required keys
'	'Name' is what you call the property
'	'Expression' is code that will execute, and the resulting value will be the value of the property
'		uses "$_" to reference the current object in the pipeline
'2] A custom property can rename an existing property, or define something new


&gt;Get-Vegetable | Select Name,Color,@{Name="ColorValue";Expression={$_.color.value__}} | sort Color
'OUTPUT
Name         Color ColorValue
----         ----- ----------
cucumber     green          0
peas         green          0
broccoli     green          0
zucchini     green          0
spinach      green          0
pepper       green          0
tomato         red          1
radish         red          1
pepper         red          1
cauliflower  white          2
corn        yellow          3
pepper      yellow          3
carrot      orange          4
turnip      purple          5
eggplant    purple          5
potato       brown          6
==============================================================================
'EXAMPLE
&gt;Get-Process | Sort cpu -Descending | 
select -first 10 -property ID,Name,CPU,StartTime,
@{Name="Runtime";Expression={(Get-Date)-$_.starttime}}

==============================================================
'1] show the properties of the object
&gt;get-service bits  | select *
'OUTPUT
==============
#'Name                : bits
#'RequiredServices    : {RpcSs, EventSystem}
#'CanPauseAndContinue : False
#'CanShutdown         : False
#'CanStop             : True
#'DisplayName         : Background Intelligent Transfer Service
#'DependentServices   : {}
#'MachineName         : .
#'ServiceName         : bits
#'ServicesDependedOn  : {RpcSs, EventSystem}
#'ServiceHandle       : SafeServiceHandle
#'Status              : Running
#'ServiceType         : Win32ShareProcess
#'StartType           : Manual
#'Site                : 
#'Container           : 

'2] Now use a property in a Custom Property, in order to rename the property

get-service -ComputerName HOMETOWER | select Displayname,Status,
@{Name="Computername";Expression={$_.machinename}} 

'OUTPUT
==========
#'
#'DisplayName                                             Status Computername
#'-----------                                             ------ ------------
#'Acronis Scheduler2 Service                             Stopped HOMETOWER   
#'Adobe Acrobat Update Service                           Stopped HOMETOWER   
#'Application Experience                                 Stopped HOMETOWER   
==============================================================
'More examples:
get-service -computername win10ent | select Displayname,Status,
@{Name="Computername";Expression={$_.machinename}} | Out-GridView -title "Services"

cls

dir -Path c:\work -file -Recurse | Select Name,
@{Name="SizeKB";Expression={[math]::round($_.length/1Kb,2)}},
@{Name="Modified";Expression={$_.lastwritetime}},
@{Name="ModifiedAge";Expression={(Get-Date) - $_.lastwritetime}},
@{Name="Path";Expression={$_.fullname}},
@{Name="Computername";Expression={$env:computername}}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CREATE_RegistryKeyProperty_and_populate_its_Value</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CREATE_RegistryKeyProperty_and_populate_its_Value</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'CREATE_RegistryKeyProperty_and_populate_its_Value

https://blogs.technet.microsoft.com/heyscriptingguy/2015/04/02/update-or-add-registry-key-value-with-powershell/
=====================================================================================
$registryPath = "HKLM:\Software\Microsoft\WindowsStore"
$Name = "RemoveWindowsStore"
$value = "1"

IF(!(Test-Path $registryPath))
	{
		New-Item -Path $registryPath -Force | Out-Null
		New-ItemProperty -Path $registryPath -Name $name -Value $value -PropertyType DWORD -Force | Out-Null
	}
 ELSE 
 	{
    	New-ItemProperty -Path $registryPath -Name $name -Value $value -PropertyType DWORD -Force | Out-Null
    }
    
========================================================================================

'I could use Get-ItemProperty to verify if a registry key property value exists. 
'If the registry key property does not exist, the error message is very specific. It is shown here:

PS C:\&gt; (Get-ItemProperty -Path HKCU:\Software\ScriptingGuys\Scripts -Name version).version

#'ERROR MESSAGE
'----------------
#'Get-ItemProperty : Property version does not exist at path HKEY_CURRENT_USER\Software\ScriptingGuys\Scripts.
#'At line:1 char:2
#'+ (Get-ItemProperty -Path HKCU:\Software\ScriptingGuys\Scripts -Name version).vers ...
#'+  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : InvalidArgument: (version:String) [Get-ItemProperty], PSArgumentException
#'    + FullyQualifiedErrorId : System.Management.Automation.PSArgumentException,Microsoft.PowerShell.Commands.GetItemPropertyCommand

    
    

'If the registry key itself does not exist, I get a different error message. This is shown here:

PS C:\&gt; (Get-ItemProperty -Path HKCU:\Software\ScriptingGuys\Scripts -Name version).version

#'ERROR MESSAGE
'----------------
#'Get-ItemProperty : Cannot find path 'HKCU:\Software\ScriptingGuys\Scripts' because it does not exist.
#'At line:1 char:2
#'+ (Get-ItemProperty -Path HKCU:\Software\ScriptingGuys\Scripts -Name version).vers ...
#'+  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : ObjectNotFound: (HKCU:\Software\ScriptingGuys\Scripts:String) [Get-ItemProperty],
#'    ItemNotFoundException
#'    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetItemPropertyCommand


The first error message complains about the PROPERTY, the second error complains about the PATH.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>DoesRemoveWindowsStoreExist_if_So_WhatIsItsValue_v4</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>DoesRemoveWindowsStoreExist_if_So_WhatIsItsValue_v4</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$file_WindowsVersionsInfo &lt;=== This file was not created. What was the problem? 0959 did not show up in the Windows List

#'DoesRemoveWindowsStoreExist_if_So_WhatIsItsValue_v4.ps1
#' 1] Ping the computer
#' 2] Write the name of those that ping into the file Ping_Returned_2018_05_01.txt
#'    Write the name of those that did NOT ping into the file Ping_DidNOT_2018_05_01.txt
#' 3] For those that pinged check the OS version
#'    Write the name of Win10 computers into the file OS_Win10_2018_05_01.txt
#'    Write the name of Other OS into the file OS_NOT_Win10_2018_05_01.txt
#' 4] For the Win10 computers: store in file: 
#'    Three columns: OS, RemoveWindowsStore_Exists, RemoveWindowsStore_Value

#'============================================

$Path_forFiles = "C:\DATA\"
$file_INPUT_computerList = $Path_forFiles + "2018_05_01_ALL_computers.txt"
$file_PingReturned = $Path_forFiles + "2018_05_01_Ping_Returned.txt"
$file_PingNOTReturned = $Path_forFiles + "2018_05_01_Ping_DidNOT.txt"
$file_WindowsVersionsInfo =  $Path_forFiles + "2018_05_01_WindowsVersion.csv"    #' NOTE: CSV
$file_OS_Win10 = $Path_forFiles + "2018_05_01_OS_Win10.txt"
$file_WindowsStoreINFO  = $Path_forFiles + "2018_05_01_WindowsStoreINFO.csv"    #' NOTE: CSV

$registryPath = "HKLM:\Software\Microsoft\WindowsStore"
$RegitryValueName = "RemoveWindowsStore"
$value = "1"

#' 1] Ping the computer
#' 2] Write the name of those that ping into the file Ping_Returned_2018_05_01.txt
#'    Write the name of those that did NOT ping into the file Ping_DidNOT_2018_05_01.txt
$Computers = get-content $file_INPUT_computerList;
foreach ($computer in $Computers) {
    write-host $computer   
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path $file_PingReturned
		}else{
			Add-Content -value $computer -path $file_PingNOTReturned
		}
	}

#' 3] For those that pinged check the OS version
#'    Write the name of Win10 computers into the file OS_Win10_2018_05_01.txt
#'    Write the name of Other OS into the file OS_NOT_Win10_2018_05_01.txt

 
$theComputerOSinfo = @()
$computers = Get-Content $file_PingReturned 
$i=0
$count = $computers.count
foreach($computer in $computers)
    {
        $i++
        Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
        -PercentComplete ($i/$count*100)
        $info = @{}
        $version = 0
        try{
            #'================================================================================

                        write-host "responded to PING:"$computer -ForegroundColor Green 
                        #'--------------------------------------------------------------------------------
                        $OperatingSystem = Get-WmiObject -ComputerName $computer -Class Win32_OperatingSystem
                        #'--------------------------------------------------------------------------------
                        $BuildNumber = $OperatingSystem.BuildNumber 
                        write-host "Build Number:"$BuildNumber -ForegroundColor White                  
                        switch  ($BuildNumber)
                        {
                            10240 {$Build = "1507, Threshold 1, N/A,  July 29, 2015"}
                            10586 {$Build = "1511, Threshold 2, November Update,  2015/11/10"}
                            14393 {$Build = "1607, Redstone 1, 2016/08/02"}
                            15063 {$Build = "1703, Redstone 2, Creators Update, 2017/04/05"}
                            16299 {$Build = "1709, Redstone 3, Fall Creators Update, 2017/10/17"}
                            17134 {$Build = "1803, Redstone 4, Early 2018"}
                            17650 {$Build = "1809, Redstone 5, Late 2018"}
                            default {$Build = "default"}
                        }
                        write-host "Build:"$Build -ForegroundColor White 

                        #'--------------------------------------------------------------------------------
                        $OS = $OperatingSystem.Version  
                        write-host "OS:"$OS -ForegroundColor Yellow                  
                        switch  ($OS)
                        {
                            "10.0.16299" {$OSName = "Windows 10 (1709)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.15063" {$OSName = "Windows 10 (1703)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.14393" {$OSName = "Windows 10 (1607)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.10586" {$OSName = "Windows 10 (1511)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.10240" {$OSName = "Windows 10"; Add-Content -value $computer -path $file_OS_Win10}
                            "6.3.9600" {$OSName = "Windows 8.1 (Update 1)"}
                            "6.3.9200" {$OSName = "Windows 8.1"}
                            "6.2.9200" {$OSName = "Windows 8"}
                            "6.1.7601" {$OSName = "Windows 7 SP1"}
                            "6.1.7600" {$OSName = "Windows 7"}
                            "6.0.6002" {$OSName = "Windows Vista SP2"}
                            "6.0.6001" {$OSName = "Windows Vista SP1"}
                            "6.0.6000" {$OSName = "Windows Vista"}
                            "5.1.2600" {$OSName = "Windows XP"}
                            default {$OSName = "default"}
                        }
                        write-host "OSName:"$OSName -ForegroundColor Yellow 
            #'================================================================================
            }
 
 
            catch
            {
                        $OperatingSystem  = 'Not Installed/Not Available'
            }

            $info.Computer = $computer
            $info.OSName= $OSName
            $info.Build =  $Build
            $info.BuildNumber =  $BuildNumber
            $info.OSversion = $OS

            $object = new-object -TypeName PSObject -Property $info
            $theComputerOSinfo += $object
}
$theComputerOSinfo | select computer,OSName,Build, BuildNumber,OSversion  | Export-Csv -NoTypeInformation -Path $file_WindowsVersionsInfo

#' 4] For the Win10 computers: store in file:  $file_WindowsStoreINFO
#'    Three columns: OS, RemoveWindowsStore_Exists, RemoveWindowsStore_Value

$return_object = @()

foreach ($computer in (Get-Content $file_OS_Win10)){

  write-verbose "Getting Windows Store Info on $computer..." -Verbose
  $return_object += Invoke-Command -ComputerName "$computer" -ScriptBlock {
                                                                            #'=====================================================================================
                                                                            write-verbose "1]" -Verbose
                                                                            $info2 = @{}
                                                                            $registryPath = "HKLM:\Software\Microsoft\WindowsStore"
                                                                            $Name = "RemoveWindowsStore"
                                                                            $value = "1"
                                                                            write-verbose "2]" -Verbose
                                                                            try{
                                                                                    IF(!(Test-Path $registryPath))
	                                                                                    {
                                                                                            $registryPathExists = "1"
                                                                                            $registryPathValue = (Get-ItemProperty -Path $registryPath -Name $RegitryValueName).$RegitryValueName
	                                                                                    }
                                                                                     ELSE 
 	                                                                                    {
    	                                                                                    $registryPathExists = "0"
                                                                                            $registryPathValue = "n/a"
                                                                                        }
 			                                                                      }
			                                                                  catch{
		                                                                                $registryPathExists = "error"
                                                                                        $registryPathValue = "error"
		      	                                                                   }

                                                                            #' ------------------------------------------------------------

                                                                            write-verbose "3]" -Verbose
                                                                            Write-Host "-&gt; computer"$Using:computer
                                                                            Write-Host "-&gt; registryPathExists"$registryPathExists
                                                                            Write-Host "-&gt; registryPathValue"$registryPathValue
                                                                            New-Object -TypeName PSCustomObject -Property @{Host=$env:computername; registryPathExists=$registryPathExists; registryPathValue=$registryPathValue}
                                                                            write-verbose "4]" -Verbose

                                                                           #'========================================================================================
                                                                            Write-Host "ScriptBlock Loop Done: " -ForegroundColor Green
                                                                            #'return $info2
                                                                            } 
                                                        Write-Host "6] Loop for computer is done"$computer -ForegroundColor Green
                                                        
                                                        
                                                    }
                                                    write-verbose "7] all computers have been looped" -Verbose
                                                   
                                                   #'| SELECT computer,registryPathExists,registryPathValue
                                                    $return_object | select Host, registryPathExists, registryPathValue  | Export-Csv -NoTypeInformation -Path $file_WindowsStoreINFO
                                                    write-output ("Done with all computers")
                                                     $return_object | select Host, registryPathExists, registryPathValue  | Format-List









</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ScheduledTask</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_ScheduledTask</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ScheduledTask</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_ScheduledTask</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_ScheduledTask

'difference between Create Basic Task and Create Task?
'The "Create Basic Task" is done through a wizard and does not have all of the advanced options as doing it manually with the "Create Task" one instead


'We can configure a scheduled task to update each day the PowerShell help files either from the internet or from a share as in the example above:

Register-ScheduledJob -Name UpdatePSHelp `

  -ScheduledJobOption @{RunElevated=$true} `
  -ScriptBlock {Update-Help -Force -Verbose} `
  -Trigger @{At='6:00 AM';Frequency='Daily'} 

'We can take a look at the output of the scheduled jobs with:

 Get-Job -Name UpdateHelp | Receive-Job </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Server</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>does_server_need_a_Reboot</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Server</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>does_server_need_a_Reboot</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>



\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
http://ilovepowershell.com/2015/09/10/how-to-check-if-a-server-needs-a-reboot/
' It turns out that a simple way to identify servers that are pending reboot is to check the registry.
'There are a couple of places to check.
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired
'Is where patches installed through automatic updates register the need to reboot.
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending
'Is another place where pending reboots can be identified.
HKLM\SYSTEM\CurrentControlSet\Control\Session Manager
'Is yet another. Finally, there is Configuration Manager which, if present, can be queried via WMI.
#'a function that I really like to check all four locations. 
#'I’ll need to wrap it up with some parameters to check remote computers, 
#'	but in general it was a great start. 
#'I’ve adapted the function to return $true on the first condition that satisfies, 
#'	since I only care about whether the computer is pending a reboot, 
#'	and not where the source of the reboot is comping from.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
'USAGE
&gt; Test-PendingReboot
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#Adapted from https://gist.github.com/altrive/5329377
#Based on &lt;http://gallery.technet.microsoft.com/scriptcenter/Get-PendingReboot-Query-bdb79542&gt;
function Test-PendingReboot
{
 if (Get-ChildItem "HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -EA Ignore) { return $true }
 if (Get-Item "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired" -EA Ignore) { return $true }
 if (Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name PendingFileRenameOperations -EA Ignore) { return $true }
 try { 
   $util = [wmiclass]"\\.\root\ccm\clientsdk:CCM_ClientUtilities"
   $status = $util.DetermineIfRebootPending()
   if(($status -ne $null) -and $status.RebootPending){
     return $true
   }
 }catch{}
 
 return $false
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SQL</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>from_PowerShell_TrainingClass</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SQL</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>from_PowerShell_TrainingClass</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' create a connection
```PowerShell
$conn = New-Object -Type System.Data.SqlClient.SqlConnection
$conn.ConnectionString = 'Server=SQL1;Database=MyDB;Trusted_Connection=True;'
$conn.Open()
```
#'You can leave the connection open for your entire script; 
'	`be sure to run $conn.Close() when you’re done, though. 
'	It’s not a tragedy to not close the connection; 
'	when your script ends, the connection object will vanish, 
'	and SQL Server will automatically close the connection a bit later. 


'We always put our query in a variable, because that makes it easy to output the query text by using Write-Verbose. 
'	That’s a great way to debug queries that aren’t working, 
'	since you get to see the actual query text with all the variables “filled-in.” 



#' for an Instance Connection:
Server=SERVER\INSTANCE;Database=DATABASE;Trusted_Connected=True;


#' INSERT model
INSERT INTO &lt;tablename&gt;
    (Column1, Column2, Column3)
    VALUES (Value1, Value2, Value3)


#' INSERT example
$ComputerName = "SERVER2"
$OSVersion = "Win2012R2"
$query = "INSERT INTO OSVersion (ComputerName,OS) VALUES('$ComputerName','$OSVersion')"



#' DELETE model
DELETE FROM &lt;tablename&gt; WHERE &lt;criteria&gt;


#' DELETE example
$query = "DELETE FROM OSVersions WHERE ComputerName = '$ComputerName'"



#' UPDATE model
UPDATE &lt;tablename&gt;
   SET &lt;column&gt; = &lt;value&gt;, &lt;column&gt; = &lt;value&gt;
   WHERE &lt;criteria&gt;


#' UPDATE example
$query = "UPDATE DiskSpaceTracking `
          SET FreeSpaceOnSysDrive = $freespace `
          WHERE ComputerName = '$ComputerName'"



#' SELECT model
SELECT &lt;column&gt;,&lt;column&gt;
       FROM &lt;tablename&gt;
       WHERE &lt;criteria&gt;
       ORDER BY &lt;column&gt;


#' SELECT example
$query = "SELECT DiskSpace,DateChecked `
          FROM DiskSpaceTracking `
          WHERE ComputerName = '$ComputerName' `
          ORDER BY DateChecked DESC"



#' CREATE TABLE model
CREATE TABLE &lt;tablename&gt; (
    &lt;column&gt; &lt;type&gt;,
    &lt;column&gt; &lt;type&gt;
)



#' Set up to run a query '&lt;==================================================== RUN QUERY
$command = New-Object -Type System.Data.SqlClient.SqlCommand
$command.Connection = $conn
$command.CommandText = $query



#' Run INSERT/UPDATE/DELETE '&lt;==================================================== RUN ExecuteNonQuery
$command.ExecuteNonQuery()



#' Run SELECT '&lt;===================================================  SELECT
$reader = $command.ExecuteReader()



#' Read through rows
while ($reader.read()) {
  #'do something with the data
}



#' Full example   '&lt;===========================================================  FULL EXAMPLE     
$conn = New-Object -Type System.Data.SqlClient.SqlConnection
$conn.ConnectionString = 'Server=SQL1;Database=MyDB;Trusted_Connection=True;'
$conn.Open()

$query = "SELECT ComputerName,DiskSpace,DateTaken FROM DiskTracking"

$command = New-Object -Type System.Data.SqlClient.SqlCommand
$command.Connection = $conn
$command.CommandText = $query
$reader = $command.ExecuteReader()

while ($reader.read()) {
    [psobject]$props = @{'ComputerName' = $reader.GetValue(0)
                         'DiskSpace' = $reader.GetValue(1)
                         'DateTaken' = $reader.GetValue(2)
                        }
}

$conn.Close()



#' Let it figure out ordinals for you
while ($reader.read()) {
    [psobject]$props = @{
    'ComputerName' = $reader.GetValue($reader.getordinal("computername"))
    'DiskSpace' = $reader.GetValue($reader.getordinal("diskspace"))
    'DateTaken' = $reader.GetValue($reader.getordinal("datetaken"))
    }
}




#' Invoke-Sqlcmd    '&lt;===========================================================  SQLCMD
Invoke-Sqlcmd "Select Computername,Diskspace,DateTaken from DiskTracking" `
-Database MyDB



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Windows_10</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_Windows_VersionForComputerList_v2.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Windows_10</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_Windows_VersionForComputerList_v2.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get_Windows_VersionForComputerList_v2.ps1

#'$outfile = 'C:\data\computers_WindowsVersion.csv'
#'$infile = 'c:\data\computers.txt'



#' 1] Ping the computers and get the ones that respond:******************************************************************************************************************************    

$inTestcomputers = Get-Content -Path 'c:\data\2018_04_20_ALL_computerObjectsInActiveDirectory.txt'
$outRespondToPing = 'C:\DATA\2018_04_20__RespondToPing.txt'
$TEST = 'C:\DATA\TEST.txt'
'Run part 1 to see which machines ping
'Then using the list of the ones that PING'd get the Windows version
'NOTE: the servers were all wrong




$outDidNOTrespondToPING = 'C:\DATA\2018_04_20__DidNOTrespondToPING.txt'
$outfile = 'C:\data\2018_04_20__WindowsVersion.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $inTestcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path $outRespondToPing
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path $outDidNOTrespondToPING 
		}
	}


#' 2] ******************************************************************************************************************************   
#'           $TEST = 'C:\DATA\TEST.txt'  
$outRespondToPing = 'C:\DATA\2018_04_20__RespondToPing.txt'
$outfile = 'C:\data\2018_04_20__WindowsVersion.csv'
 
           $theComputerOSinfo = @()
                    $computers = Get-Content $outRespondToPing
                    $i=0
                    $count = $computers.count
                    foreach($computer in $computers)
                     {
                            $i++
                            Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
                            -PercentComplete ($i/$count*100)
                            $info = @{}
                            $version = 0
                            try{
                                #'================================================================================

                                            write-host "responded to PING:"$computer -ForegroundColor Green 
                                            #'--------------------------------------------------------------------------------
                                            $OperatingSystem = Get-WmiObject -ComputerName $computer -Class Win32_OperatingSystem
                                            #'--------------------------------------------------------------------------------
                                            $BuildNumber = $OperatingSystem.BuildNumber 
                                            write-host "Build Number:"$BuildNumber -ForegroundColor White                  
                                            switch  ($BuildNumber)
                                            {
                                                10240 {$Build = "1507, Threshold 1, N/A,  July 29, 2015"}
                                                10586 {$Build = "1511, Threshold 2, November Update,  2015/11/10"}
                                                14393 {$Build = "1607, Redstone 1, 2016/08/02"}
                                                15063 {$Build = "1703, Redstone 2, Creators Update, 2017/04/05"}
                                                16299 {$Build = "1709, Redstone 3, Fall Creators Update, 2017/10/17"}
                                                17134 {$Build = "1803, Redstone 4, Early 2018"}
                                                17650 {$Build = "1809, Redstone 5, Late 2018"}
                                                default {$Build = "default"}
                                            }
                                            write-host "Build:"$Build -ForegroundColor White 
                                            #'$Build 

                                            #'--------------------------------------------------------------------------------
                                            #'$OperatingSystem = Get-WmiObject -ComputerName IT-1241 -Class Win32_OperatingSystem
                                            $OS = $OperatingSystem.Version  
                                            write-host "OS:"$OS -ForegroundColor Yellow                  
                                            switch  ($OS)
                                            {
                                                "10.0.16299" {$OSName = "Windows 10 (1709)"}
                                                "10.0.15063" {$OSName = "Windows 10 (1703)"}
                                                "10.0.14393" {$OSName = "Windows 10 (1607)"}
                                                "10.0.10586" {$OSName = "Windows 10 (1511)"}
                                                "10.0.10240" {$OSName = "Windows 10"}
                                                "6.3.9600" {$OSName = "Windows 8.1 (Update 1) or Server"}
                                                "6.3.9200" {$OSName = "Windows 8.1 or Server "}
                                                "6.2.9200" {$OSName = "Windows 8"}
                                                "6.1.7601" {$OSName = "Windows 7 SP1"}
                                                "6.1.7600" {$OSName = "Windows 7"}
                                                "6.0.6002" {$OSName = "Windows Vista SP2"}
                                                "6.0.6001" {$OSName = "Windows Vista SP1"}
                                                "6.0.6000" {$OSName = "Windows Vista"}
                                                "5.1.2600" {$OSName = "Windows XP"}
                                                default {$OSName = "default"}
                                            }
                                            write-host "OSName:"$OSName -ForegroundColor Yellow 
                                #'================================================================================
                                }
 
 
                                catch
                                {
                                            $OperatingSystem  = 'Not Installed/Not Available'
                                }

                                $info.Computer = $computer
                                $info.OSName= $OSName
                                $info.Build =  $Build
                                $info.BuildNumber =  $BuildNumber
                                $info.OSversion = $OS

                                $object = new-object -TypeName PSObject -Property $info
                                $theComputerOSinfo += $object
                    }
                    $theComputerOSinfo | select computer,OSName,Build, BuildNumber,OSversion  | Export-Csv -NoTypeInformation -Path $outfile
#'    }


  write-output ("Done")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_WMI</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WMIExplorer.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_WMI</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WMIExplorer.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'  https://gallery.technet.microsoft.com/scriptcenter/89c759b7-20b4-49e8-98a8-3c8fbdb2dd69
#' WmiExplorer.ps1  
#'  
#' A GUI WMI explorer and WMI Method Help generator  
#'  
#' /\/\o\/\/ 2006  
#' www.ThePowerShellGuy.com  
#'  
#' load Forms NameSpace  
[void][System.Reflection.Assembly]::LoadWithPartialName("System.windows.forms")   
   
#'region BuildTheForm build in C# then translated to powershell  
#'region Make the form  
$frmMain = new-object Windows.Forms.form    
$frmMain.Size = new-object System.Drawing.Size @(800,600)    
$frmMain.text = "/\/\o\/\/'s PowerShell WMI Explorer"   
#'endregion Make the form  
#'region Define Used Controls  
$MainMenu = new-object System.Windows.Forms.MenuStrip  
$statusStrip = new-object System.Windows.Forms.StatusStrip  
$FileMenu = new-object System.Windows.Forms.ToolStripMenuItem  
$ToolMenu = new-object System.Windows.Forms.ToolStripMenuItem('&amp;tools')  
$miQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;Query (run)')  
$miSelectQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;SelectQuery')  
$miSelectQuery.add_Click({$sq | out-propertyGrid;$wmiSearcher.Query = $sq})  
[void]$ToolMenu.DropDownItems.Add($miSelectQuery)  
$miRelatedObjectQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;RelatedObjectQuery')  
$miRelatedObjectQuery.add_Click({$roq | out-propertyGrid;$wmiSearcher.Query = $roq})  
[void]$ToolMenu.DropDownItems.Add($miRelatedObjectQuery)  
$miRelationshipQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;RelationshipQuery')  
$miRelationshipQuery.add_Click({$rq | out-propertyGrid ;$wmiSearcher.Query = $rq})  
[void]$ToolMenu.DropDownItems.Add($miRelationshipQuery)  
$oq = new-object System.Management.ObjectQuery  
$eq = new-object System.Management.EventQuery  
$sq = new-object System.Management.SelectQuery  
$roq = new-object System.Management.RelatedObjectQuery  
$rq = new-object System.Management.RelationshipQuery  
$wmiSearcher = [wmisearcher]''  
[void]$ToolMenu.DropDownItems.Add($miQuery)  
$miQuery.add_Click({  
    $wmiSearcher | out-propertyGrid  
    $moc = $wmiSearcher.get()  
    $DT =  new-object  System.Data.DataTable  
    $DT.TableName = $lblClass.text  
    $Col =  new-object System.Data.DataColumn  
    $Col.ColumnName = "WmiPath"  
    $DT.Columns.Add($Col)  
    $i = 0  
    $j = 0 ;$lblInstances.Text = $j; $lblInstances.Update()  
    $MOC |  
    ForEach-Object {  
        $j++ ;$lblInstances.Text = $j; $lblInstances.Update()  
        $MO = $_  
         
        #' Make a DataRow  
        $DR = $DT.NewRow()  
        $Col =  new-object System.Data.DataColumn  
        $DR.Item("WmiPath") = $mo.__PATH  
        $MO.psbase.properties |  
        ForEach-Object {  
         
            $prop = $_  
             
            If ($i -eq 0)  {  
     
                #' Only On First Row make The Headers  
                 
                $Col =  new-object System.Data.DataColumn  
                $Col.ColumnName = $prop.Name.ToString()  
   
                $prop.psbase.Qualifiers |  
                ForEach-Object {  
                    If ($_.Name.ToLower() -eq "key") {  
                        $Col.ColumnName = $Col.ColumnName + "*"  
                    }  
                }  
                $DT.Columns.Add($Col)   
            }  
             
            #' fill dataRow   
             
            if ($prop.value -eq $null) {  
                $DR.Item($prop.Name) = "[empty]"  
            } ElseIf ($prop.IsArray) {  
                $DR.Item($prop.Name) =[string]::Join($prop.value ,";")  
            } Else {  
                $DR.Item($prop.Name) = $prop.value  
                #'Item is Key try again with *  
                trap{$DR.Item("$($prop.Name)*") = $prop.Value.tostring();continue}  
            }  
        } #'end ForEach  
        #' Add the row to the DataTable  
         
        $DT.Rows.Add($DR)  
        $i += 1  
    }  
    $DGInstances.DataSource = $DT.psObject.baseobject    
    $status.Text = "Retrieved $j Instances"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
})#'$miQuery.add_Click  
 
$miQuit = new-object System.Windows.Forms.ToolStripMenuItem('&amp;quit')  
$miQuit.add_Click({$frmMain.close()})   
$SplitContainer1 = new-object System.Windows.Forms.SplitContainer  
$splitContainer2 = new-object System.Windows.Forms.SplitContainer  
$splitContainer3 = new-object System.Windows.Forms.SplitContainer  
$grpComputer = new-object System.Windows.Forms.GroupBox  
$grpNameSpaces = new-object System.Windows.Forms.GroupBox  
$grpClasses = new-object System.Windows.Forms.GroupBox  
$grpClass = new-object System.Windows.Forms.GroupBox  
$grpInstances = new-object System.Windows.Forms.GroupBox  
$grpStatus = new-object System.Windows.Forms.GroupBox  
$txtComputer = new-object System.Windows.Forms.TextBox  
$btnConnect = new-object System.Windows.Forms.Button  
$btnInstances = new-object System.Windows.Forms.Button  
$tvNameSpaces = new-object System.Windows.Forms.TreeView  
$lvClasses = new-object System.Windows.Forms.ListView  
$clbProperties = new-object System.Windows.Forms.CheckedListBox  
$clbProperties.CheckOnClick = $true  
$lbMethods = new-object System.Windows.Forms.ListBox  
$label1 = new-object System.Windows.Forms.Label  
$label2 = new-object System.Windows.Forms.Label  
$lblServer = new-object System.Windows.Forms.Label  
$lblPath = new-object System.Windows.Forms.Label  
$lblNameSpace = new-object System.Windows.Forms.Label  
$label6 = new-object System.Windows.Forms.Label  
$lblClass = new-object System.Windows.Forms.Label  
$label10 = new-object System.Windows.Forms.Label  
$lblClasses = new-object System.Windows.Forms.Label  
$label12 = new-object System.Windows.Forms.Label  
$lblProperties = new-object System.Windows.Forms.Label  
$label8 = new-object System.Windows.Forms.Label  
$lblMethods = new-object System.Windows.Forms.Label  
$label14 = new-object System.Windows.Forms.Label  
$lblInstances = new-object System.Windows.Forms.Label  
$label16 = new-object System.Windows.Forms.Label  
$dgInstances = new-object System.Windows.Forms.DataGridView  
$TabControl = new-object System.Windows.Forms.TabControl  
$tabPage1 = new-object System.Windows.Forms.TabPage  
$tabInstances = new-object System.Windows.Forms.TabPage  
$rtbHelp = new-object System.Windows.Forms.RichTextBox  
$tabMethods = new-object System.Windows.Forms.TabPage  
$rtbMethods = new-object System.Windows.Forms.RichTextBox  
#'endregion Define Used Controls         
#'region Suspend the Layout  
$splitContainer1.Panel1.SuspendLayout()  
$splitContainer1.Panel2.SuspendLayout()  
$splitContainer1.SuspendLayout()  
$splitContainer2.Panel1.SuspendLayout()  
$splitContainer2.Panel2.SuspendLayout()  
$splitContainer2.SuspendLayout()  
$grpComputer.SuspendLayout()  
$grpNameSpaces.SuspendLayout()  
$grpClasses.SuspendLayout()  
$splitContainer3.Panel1.SuspendLayout()  
$splitContainer3.Panel2.SuspendLayout()  
$splitContainer3.SuspendLayout()  
$grpClass.SuspendLayout()  
$grpStatus.SuspendLayout()  
$grpInstances.SuspendLayout()  
$TabControl.SuspendLayout()  
$tabPage1.SuspendLayout()  
$tabInstances.SuspendLayout()  
$FrmMain.SuspendLayout()  
#'endregion Suspend the Layout  
#'region Configure Controls  
[void]$MainMenu.Items.Add($FileMenu)  
[void]$MainMenu.Items.Add($ToolMenu)  
$MainMenu.Location = new-object System.Drawing.Point(0, 0)  
$MainMenu.Name = "MainMenu"  
$MainMenu.Size = new-object System.Drawing.Size(1151, 24)  
$MainMenu.TabIndex = 0  
$MainMenu.Text = "Main Menu"  
#'  
#' statusStrip1  
#'  
$statusStrip.Location = new-object System.Drawing.Point(0, 569)  
$statusStrip.Name = "statusStrip"  
$statusStrip.Size = new-object System.Drawing.Size(1151, 22);  
$statusStrip.TabIndex = 1  
$statusStrip.Text = "statusStrip"  
$splitContainer1.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer1.Location = new-object System.Drawing.Point(0, 24)  
$splitContainer1.Name = "splitContainer1"  
$splitContainer1.Panel1.Controls.Add($splitContainer2)  
$splitContainer1.Panel2.Controls.Add($splitContainer3)  
$splitContainer1.Size = new-object System.Drawing.Size(1151, 545)  
$splitContainer1.SplitterDistance = 372  
$splitContainer1.TabIndex = 2  
$splitContainer2.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$splitContainer2.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer2.Location = new-object System.Drawing.Point(0, 0)  
$splitContainer2.Name = "splitContainer2"  
$splitContainer2.Orientation = [System.Windows.Forms.Orientation]::Horizontal  
$splitContainer2.Panel1.BackColor = [System.Drawing.SystemColors]::Control  
$splitContainer2.Panel1.Controls.Add($grpNameSpaces)  
$splitContainer2.Panel1.Controls.Add($btnConnect)  
$splitContainer2.Panel1.Controls.Add($grpComputer)  
$splitContainer2.Panel2.Controls.Add($grpClasses)  
$splitContainer2.Size = new-object System.Drawing.Size(372, 545)  
$splitContainer2.SplitterDistance = 302  
$splitContainer2.TabIndex = 0  
#'  
#' fileMenu  
#'  
[void]$fileMenu.DropDownItems.Add($miQuit)  
$fileMenu.Name = "fileMenu"  
$fileMenu.Size = new-object System.Drawing.Size(35, 20)  
$fileMenu.Text = "&amp;File"  
$grpComputer.Anchor = "top, left, right"  
$grpComputer.Controls.Add($txtComputer)  
$grpComputer.Location = new-object System.Drawing.Point(12, 3)  
$grpComputer.Name = "grpComputer"  
$grpComputer.Size = new-object System.Drawing.Size(340, 57)  
$grpComputer.TabIndex = 0  
$grpComputer.TabStop = $false  
$grpComputer.Text = "Computer"  
$txtComputer.Anchor = "top, left, right"  
$txtComputer.Location = new-object System.Drawing.Point(7, 20)  
$txtComputer.Name = "txtComputer"  
$txtComputer.Size = new-object System.Drawing.Size(244, 20)  
$txtComputer.TabIndex = 0  
$txtComputer.Text = "."  
 
$btnConnect.Anchor = "top, right"  
$btnConnect.Location = new-object System.Drawing.Point(269, 23);  
$btnConnect.Name = "btnConnect"  
$btnConnect.Size = new-object System.Drawing.Size(75, 23)  
$btnConnect.TabIndex = 1  
$btnConnect.Text = "Connect"  
$btnConnect.UseVisualStyleBackColor = $true  
#'  
#' grpNameSpaces  
#'  
$grpNameSpaces.Anchor = "Bottom, top, left, right"  
$grpNameSpaces.Controls.Add($tvNameSpaces)  
$grpNameSpaces.Location = new-object System.Drawing.Point(12, 67)  
$grpNameSpaces.Name = "grpNameSpaces"  
$grpNameSpaces.Size = new-object System.Drawing.Size(340, 217)  
$grpNameSpaces.TabIndex = 2  
$grpNameSpaces.TabStop = $false  
$grpNameSpaces.Text = "NameSpaces"  
#'  
#' grpClasses  
#'  
$grpClasses.Anchor = "Bottom, top, left, right"  
$grpClasses.Controls.Add($lvClasses)  
$grpClasses.Location = new-object System.Drawing.Point(12, 14)  
$grpClasses.Name = "grpClasses"  
$grpClasses.Size = new-object System.Drawing.Size(340, 206)  
$grpClasses.TabIndex = 0  
$grpClasses.TabStop = $False  
$grpClasses.Text = "Classes"  
#'  
#' tvNameSpaces  
#'  
$tvNameSpaces.Anchor = "Bottom, top, left, right"  
$tvNameSpaces.Location = new-object System.Drawing.Point(7, 19)  
$tvNameSpaces.Name = "tvNameSpaces"  
$tvNameSpaces.Size = new-object System.Drawing.Size(325, 184)  
$tvNameSpaces.TabIndex = 0  
#'  
#' tvClasses  
#'  
$lvClasses.Anchor = "Bottom, top, left, right"  
$lvClasses.Location = new-object System.Drawing.Point(7, 19)  
$lvClasses.Name = "tvClasses"  
$lvClasses.Size = new-object System.Drawing.Size(325, 172)  
$lvClasses.TabIndex = 0  
$lvClasses.UseCompatibleStateImageBehavior = $False  
$lvClasses.ShowItemToolTips = $true  
$lvClasses.View = 'Details'  
$colName = $lvClasses.Columns.add('Name')  
$colname.Width = 160  
$colPath = $lvClasses.Columns.add('Description')  
$colname.Width = 260  
$colPath = $lvClasses.Columns.add('Path')  
$colname.Width = 260  
#'  
#' splitContainer3  
#'  
$splitContainer3.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$splitContainer3.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer3.Location = new-object System.Drawing.Point(0, 0)  
$splitContainer3.Name = "splitContainer3"  
$splitContainer3.Orientation = [System.Windows.Forms.Orientation]::Horizontal  
#'  
#' splitContainer3.Panel1  
#'  
$splitContainer3.Panel1.Controls.Add($grpStatus)  
$splitContainer3.Panel1.Controls.Add($grpClass)  
#'  
#' splitContainer3.Panel2  
#'  
$splitContainer3.Panel2.Controls.Add($TabControl)  
$splitContainer3.Size = new-object System.Drawing.Size(775, 545)  
$splitContainer3.SplitterDistance = 303  
$splitContainer3.TabIndex = 0  
#'  
#' grpClass  
#'  
$grpClass.Anchor = "Bottom, top, left, right"  
$grpClass.Controls.Add($lblInstances)  
$grpClass.Controls.Add($label16)  
$grpClass.Controls.Add($lblMethods)  
$grpClass.Controls.Add($label14)  
$grpClass.Controls.Add($lblProperties)  
$grpClass.Controls.Add($label8)  
$grpClass.Controls.Add($lblClass)  
$grpClass.Controls.Add($label10)  
$grpClass.Controls.Add($lbMethods)  
$grpClass.Controls.Add($clbProperties)  
$grpClass.Controls.Add($btnInstances)  
$grpClass.Location = new-object System.Drawing.Point(17, 86)  
$grpClass.Name = "grpClass"  
$grpClass.Size = new-object System.Drawing.Size(744, 198)  
$grpClass.TabIndex = 0  
$grpClass.TabStop = $False  
$grpClass.Text = "Class"  
#'  
#' btnInstances  
#'  
$btnInstances.Anchor = "Bottom, Left"  
$btnInstances.Location = new-object System.Drawing.Point(6, 169);  
$btnInstances.Name = "btnInstances";  
$btnInstances.Size = new-object System.Drawing.Size(96, 23);  
$btnInstances.TabIndex = 0;  
$btnInstances.Text = "Get Instances";  
$btnInstances.UseVisualStyleBackColor = $true  
#'  
#' grpStatus  
#'  
$grpStatus.Anchor = "Top,Left,Right"  
$grpStatus.Controls.Add($lblClasses)  
$grpStatus.Controls.Add($label12)  
$grpStatus.Controls.Add($lblNameSpace)  
$grpStatus.Controls.Add($label6)  
$grpStatus.Controls.Add($lblPath)  
$grpStatus.Controls.Add($lblServer)  
$grpStatus.Controls.Add($label2)  
$grpStatus.Controls.Add($label1)  
$grpStatus.Location = new-object System.Drawing.Point(17, 3)  
$grpStatus.Name = "grpStatus"  
$grpStatus.Size = new-object System.Drawing.Size(744, 77)  
$grpStatus.TabIndex = 1  
$grpStatus.TabStop = $False  
$grpStatus.Text = "Status"  
#'  
#' label1  
#'  
$label1.AutoSize = $true  
$label1.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label1.Location = new-object System.Drawing.Point(7, 20)  
$label1.Name = "label1"  
$label1.Size = new-object System.Drawing.Size(62, 16)  
$label1.TabIndex = 0  
$label1.Text = "Server :"  
#'  
#' label2  
#'  
$label2.AutoSize = $true  
$label2.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label2.Location = new-object System.Drawing.Point(7, 41)  
$label2.Name = "label2"  
$label2.Size = new-object System.Drawing.Size(51, 16)  
$label2.TabIndex = 1  
$label2.Text = "Path  :"  
#'  
#' lblServer  
#'  
$lblServer.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblServer.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblServer.Location = new-object System.Drawing.Point(75, 20)  
$lblServer.Name = "lblServer"  
$lblServer.Size = new-object System.Drawing.Size(144, 20)  
$lblServer.TabIndex = 2  
#'  
#' lblPath  
#'  
$lblPath.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblPath.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblPath.Location = new-object System.Drawing.Point(75, 40)  
$lblPath.Name = "lblPath"  
$lblPath.Size = new-object System.Drawing.Size(567, 20)  
$lblPath.TabIndex = 3  
#'  
#' lblNameSpace  
#'  
$lblNameSpace.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblNameSpace.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblNameSpace.Location = new-object System.Drawing.Point(337, 20)  
$lblNameSpace.Name = "lblNameSpace"  
$lblNameSpace.Size = new-object System.Drawing.Size(144, 20)  
$lblNameSpace.TabIndex = 5  
#'  
#' label6  
#'  
$label6.AutoSize = $true  
$label6.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label6.Location = new-object System.Drawing.Point(229, 20)  
$label6.Name = "label6"  
$label6.Size = new-object System.Drawing.Size(102, 16)  
$label6.TabIndex = 4  
$label6.Text = "NameSpace :"  
#'  
#' lblClass  
#'  
$lblClass.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblClass.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblClass.Location = new-object System.Drawing.Point(110, 26)  
$lblClass.Name = "lblClass"  
$lblClass.Size = new-object System.Drawing.Size(159, 20)  
$lblClass.TabIndex = 11  
#'  
#' label10  
#'  
$label10.AutoSize = $true  
$label10.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label10.Location = new-object System.Drawing.Point(6, 26)  
$label10.Name = "label10"  
$label10.Size = new-object System.Drawing.Size(55, 16)  
$label10.TabIndex = 10  
$label10.Text = "Class :"  
#'  
#' lblClasses  
#'  
$lblClasses.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblClasses.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblClasses.Location = new-object System.Drawing.Point(595, 21)  
$lblClasses.Name = "lblClasses"  
$lblClasses.Size = new-object System.Drawing.Size(47, 20)  
$lblClasses.TabIndex = 9  
#'  
#' label12  
#'  
$label12.AutoSize = $true  
$label12.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label12.Location = new-object System.Drawing.Point(487, 21)  
$label12.Name = "label12"  
$label12.Size = new-object System.Drawing.Size(76, 16)  
$label12.TabIndex = 8  
$label12.Text = "Classes  :"  
#'  
#' clbProperties  
#'  
$clbProperties.Anchor = "Bottom, top,left"  
$clbProperties.FormattingEnabled = $true  
$clbProperties.Location = new-object System.Drawing.Point(510, 27)  
$clbProperties.Name = "clbProperties"  
$clbProperties.Size = new-object System.Drawing.Size(220, 160)  
$clbProperties.TabIndex = 1  
#'  
#' lbMethods  
#'  
$lbMethods.Anchor = "Bottom, top, Left"  
$lbMethods.FormattingEnabled = $true  
$lbMethods.Location = new-object System.Drawing.Point(280, 27)  
$lbMethods.Name = "lbMethods"  
$lbMethods.Size = new-object System.Drawing.Size(220, 160)  
$lbMethods.TabIndex = 2  
#'  
#' lblProperties  
#'  
$lblProperties.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblProperties.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblProperties.Location = new-object System.Drawing.Point(110, 46)  
$lblProperties.Name = "lblProperties"  
$lblProperties.Size = new-object System.Drawing.Size(119, 20)  
$lblProperties.TabIndex = 13  
#'  
#' label8  
#'  
$label8.AutoSize = $true  
$label8.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label8.Location = new-object System.Drawing.Point(6, 46)  
$label8.Name = "label8"  
$label8.Size = new-object System.Drawing.Size(88, 16)  
$label8.TabIndex = 12  
$label8.Text = "Properties :"  
#'  
#' lblMethods  
#'  
$lblMethods.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblMethods.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblMethods.Location = new-object System.Drawing.Point(110, 66)  
$lblMethods.Name = "lblMethods"  
$lblMethods.Size = new-object System.Drawing.Size(119, 20)  
$lblMethods.TabIndex = 15  
#'  
#' label14  
#'  
$label14.AutoSize = $true  
$label14.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label14.Location = new-object System.Drawing.Point(6, 66)  
$label14.Name = "label14"  
$label14.Size = new-object System.Drawing.Size(79, 16)  
$label14.TabIndex = 14  
$label14.Text = "Methods  :"  
#'  
#' lblInstances  
#'  
$lblInstances.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblInstances.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblInstances.Location = new-object System.Drawing.Point(110, 86)  
$lblInstances.Name = "lblInstances"  
$lblInstances.Size = new-object System.Drawing.Size(119, 20)  
$lblInstances.TabIndex = 17  
#'  
#' label16  
#'  
$label16.AutoSize = $true  
$label16.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label16.Location = new-object System.Drawing.Point(6, 86)  
$label16.Name = "label16"  
$label16.Size = new-object System.Drawing.Size(82, 16)  
$label16.TabIndex = 16  
$label16.Text = "Instances :"  
#'  
#' grpInstances  
#'  
$grpInstances.Anchor = "Bottom, top, left, right"  
$grpInstances.Controls.Add($dgInstances)  
$grpInstances.Location = new-object System.Drawing.Point(17, 17)  
$grpInstances.Name = "grpInstances"  
$grpInstances.Size = new-object System.Drawing.Size(744, 202)  
$grpInstances.TabIndex = 0  
$grpInstances.TabStop = $False  
$grpInstances.Text = "Instances"  
#'  
#' dgInstances  
#'  
$dgInstances.Anchor = "Bottom, top, left, right"  
$dgInstances.ColumnHeadersHeightSizeMode = [System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode]::AutoSize  
$dgInstances.Location = new-object System.Drawing.Point(10, 19)  
$dgInstances.Name = "dgInstances"  
$dgInstances.Size = new-object System.Drawing.Size(728, 167)  
$dgInstances.TabIndex = 0  
$dginstances.ReadOnly = $true  
#' TabControl  
#'  
$TabControl.Controls.Add($tabPage1)  
$TabControl.Controls.Add($tabInstances)  
$TabControl.Controls.Add($tabMethods)  
$TabControl.Dock = [System.Windows.Forms.DockStyle]::Fill  
$TabControl.Location = new-object System.Drawing.Point(0, 0)  
$TabControl.Name = "TabControl"  
$TabControl.SelectedIndex = 0  
$TabControl.Size = new-object System.Drawing.Size(771, 234)  
$TabControl.TabIndex = 0  
#'  
#' tabPage1  
#'  
$tabPage1.Controls.Add($rtbHelp)  
$tabPage1.Location = new-object System.Drawing.Point(4, 22)  
$tabPage1.Name = "tabPage1"  
$tabPage1.Padding = new-object System.Windows.Forms.Padding(3)  
$tabPage1.Size = new-object System.Drawing.Size(763, 208)  
$tabPage1.TabIndex = 0  
$tabPage1.Text = "Help"  
$tabPage1.UseVisualStyleBackColor = $true  
#'  
#' tabInstances  
#'  
$tabInstances.Controls.Add($grpInstances)  
$tabInstances.Location = new-object System.Drawing.Point(4, 22)  
$tabInstances.Name = "tabInstances"  
$tabInstances.Padding = new-object System.Windows.Forms.Padding(3)  
$tabInstances.Size = new-object System.Drawing.Size(763, 208)  
$tabInstances.TabIndex = 1  
$tabInstances.Text = "Instances"  
$tabInstances.UseVisualStyleBackColor = $true  
#'  
#' richTextBox1  
#'  
$rtbHelp.Dock = [System.Windows.Forms.DockStyle]::Fill  
$rtbHelp.Location = new-object System.Drawing.Point(3, 3)  
$rtbHelp.Name = "richTextBox1"  
$rtbHelp.Size = new-object System.Drawing.Size(757, 202)  
$rtbHelp.TabIndex = 0  
$rtbHelp.Text = ""  
#'  
#' tabMethods  
#'  
$tabMethods.Location = new-object System.Drawing.Point(4, 22)  
$tabMethods.Name = "tabMethods"  
$tabMethods.Padding = new-object System.Windows.Forms.Padding(3)  
$tabMethods.Size = new-object System.Drawing.Size(763, 208)  
$tabMethods.TabIndex = 2  
$tabMethods.Text = "Methods"  
$tabMethods.UseVisualStyleBackColor = $true  
 
        $rtbMethods.Dock = [System.Windows.Forms.DockStyle]::Fill  
        $rtbMethods.Font = new-object System.Drawing.Font("Lucida Console",8 )  
        $rtbMethods.DetectUrls = $false  
        $tabMethods.controls.add($rtbMethods)  
         
#'endregion Configure Controls  
#' Configure  Main Form  
#'region frmMain  
 
#'  
$frmMain.AutoScaleDimensions = new-object System.Drawing.SizeF(6, 13)  
$frmMain.AutoScaleMode = [System.Windows.Forms.AutoScaleMode]::Font  
$frmMain.ClientSize = new-object System.Drawing.Size(1151, 591)  
$frmMain.Controls.Add($splitContainer1)  
$frmMain.Controls.Add($statusStrip)  
$frmMain.Controls.Add($MainMenu)  
$frmMain.MainMenuStrip = $mainMenu  
$FrmMain.Name = "frmMain"  
$FrmMain.Text = "/\/\o\/\/ PowerShell WMI Browser"  
$mainMenu.ResumeLayout($false)  
$mainMenu.PerformLayout()  
$MainMenu.ResumeLayout($false)  
$MainMenu.PerformLayout()  
$splitContainer1.Panel1.ResumeLayout($false)  
$splitContainer1.Panel2.ResumeLayout($false)  
$splitContainer1.ResumeLayout($false)  
$splitContainer2.Panel1.ResumeLayout($false)  
$splitContainer2.Panel2.ResumeLayout($false)  
$splitContainer2.ResumeLayout($false)  
$grpComputer.ResumeLayout($false)  
$grpComputer.PerformLayout()  
$grpNameSpaces.ResumeLayout($false)  
$grpClasses.ResumeLayout($false)  
$splitContainer3.Panel1.ResumeLayout($false)  
$splitContainer3.Panel2.ResumeLayout($false)  
$splitContainer3.ResumeLayout($false)  
$grpClass.ResumeLayout($false)  
$grpClass.PerformLayout()  
$grpStatus.ResumeLayout($false)  
$grpStatus.PerformLayout()  
$grpInstances.ResumeLayout($false)  
$TabControl.ResumeLayout($false)  
$tabPage1.ResumeLayout($false)  
$tabInstances.ResumeLayout($false)  
$frmMain.ResumeLayout($false)  
$FrmMain.PerformLayout()  
$status = new-object System.Windows.Forms.ToolStripStatusLabel  
$status.BorderStyle = 'SunkenInner'  
$status.BorderSides = 'All'  
$status.Text = "Not Connected"  
[void]$statusStrip.Items.add($status)  
$slMessage = new-object System.Windows.Forms.ToolStripStatusLabel  
$slMessage.BorderStyle = 'SunkenInner'  
$slMessage.BorderSides = 'All'  
$slMessage.Text = ""  
[void]$statusStrip.Items.add($slMessage)  
#'endregion frmMain  
#'endregion  
#'region Helper Functions  
Function out-PropertyGrid {  
  Param ($Object,[switch]$noBase,[Switch]$array)  
  $PsObject = $null  
  if ($object) {  
      $PsObject = $object  
  }Else{  
     if ($Array.IsPresent) {  
         $PsObject = @()  
         $input |ForEach-Object {$PsObject += $_}  
     }Else{  
         $input |ForEach-Object {$PsObject = $_}  
     }  
  }  
  if ($PsObject){  
      $form = new-object Windows.Forms.Form   
      $form.Size = new-object Drawing.Size @(600,600)   
      $PG = new-object Windows.Forms.PropertyGrid   
      $PG.Dock = 'Fill'   
      $form.text = "$psObject"   
      if ($noBase.IsPresent) {"no";  
          $PG.selectedobject = $psObject   
      }Else{  
          $PG.selectedobject = $psObject.PsObject.baseobject   
      }   
      $form.Controls.Add($PG)   
      $Form.Add_Shown({$form.Activate()})    
      $form.showdialog()  
  }  
} #'Function out-PropertyGrid  
Function Update-Status {  
  $script:computer = $Script:NameSpaces.__SERVER  
  $txtComputer.Text = $script:computer  
  $lblPath.Text = $Script:NameSpaces.__PATH                                 
  $lblProperties.Text = $Script:NameSpaces.__PROPERTY_COUNT                                 
  $lblClass.Text = $Script:NameSpaces.__RELPATH                                     
  $lblServer.Text = $script:Computer  
  $lblnamespace.Text = $Script:NameSpaces.__NAMESPACE  
} #' Function Update-Status  
Function Set-StatusBar ([Drawing.Color]$Color,$Text) {  
  $status.BackColor = $color  
  $status.Text = $text  
  $statusstrip.Update()    
}  
#'endregion Helper Functions  
#'################### Main ###############################  
#'region Global Variables  
$FontBold = new-object System.Drawing.Font("Microsoft Sans Serif",8,[Drawing.FontStyle]'Bold' )  
$fontNormal = new-object System.Drawing.Font("Microsoft Sans Serif",8,[Drawing.FontStyle]'Regular')  
$fontCode = new-object System.Drawing.Font("Lucida Console",8 )  
#' Create Script Variables for WMI Connection  
$Script:ConnectionOptions = new-object System.Management.ConnectionOptions  
$script:WmiConnection = new-object system.management.ManagementScope  
$script:WmiClass = [wmiClass]''  
#' NamespaceCaching , Make HashTable to store Treeview Items  
$script:nsc = @{}  
#' Make DataSet for secondary Cache  
$Script:dsCache = new-object data.dataset  
if (-not ${Global:WmiExplorer.dtClasses}){  
    ${Global:WmiExplorer.dtClasses} = new-object data.datatable  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Path',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Namespace',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('name',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Description',[string]))  
    ${Global:WmiExplorer.dtClasses}.tablename = 'Classes'  
}  
#'endregion  
#'region Control Handlers  
#' Add Delegate Scripts to finetune the WMI Connection objects to the events of the controls  
$slMessage.DoubleClickEnabled = $true  
$slMessage.add_DoubleClick({$error[0] | out-PropertyGrid})  
$lblNameSpace.add_DoubleClick({$script:WmiConnection | out-PropertyGrid})  
$lblserver.add_DoubleClick({$Script:ConnectionOptions | out-PropertyGrid})  
$lblClass.add_DoubleClick({$script:WmiClass | out-PropertyGrid})  
 
$btnConnect.add_click({ConnectToComputer})  
$TVNameSpaces.add_DoubleClick({GetClassesFromNameSpace})  
$lvClasses.Add_DoubleClick({GetWmiClass})  
$btnInstances.add_Click({GetWmiInstances})  
$dgInstances.add_DoubleClick({OutputWmiInstance})  
$lbMethods.Add_DoubleClick({GetWmiMethod})  
$clbProperties.add_Click({  
  trap{Continue}  
  $DGInstances.Columns.Item(($this.SelectedItem)).visible = -not $clbProperties.GetItemChecked($this.SelectedIndex)  
})  
$TVNameSpaces.add_AfterSelect({  
    if ($this.SelectedNode.name -ne $Computer){  
        $lblPath.Text = "$($script:WmiConnection.path.path.replace('\root',''))\$($this.SelectedNode.Text)"   
    }  
   
    $lblProperties.Text = $Script:NameSpaces.__PROPERTY_COUNT                                 
    $lblServer.Text = $Script:NameSpaces.__SERVER  
    $lblnamespace.Text = $this.SelectedNode.Text  
    if ($this.SelectedNode.tag -eq "NotEnumerated") {  
        (new-object system.management.managementClass(  
                "$($script:WmiConnection.path.path.replace('\root',''))\$($this.SelectedNode.Text):__NAMESPACE")  
        ).PSbase.getInstances() | Sort-Object $_.name |  
        ForEach-Object {  
          $TN = new-object System.Windows.Forms.TreeNode  
          $TN.Name = $_.name  
          $TN.Text = ("{0}\{1}" -f $_.__NameSpace,$_.name)  
          $TN.tag = "NotEnumerated"  
          $this.SelectedNode.Nodes.Add($TN)  
        }  
         
        #' Set tag to show this node is already enumerated  
        $this.SelectedNode.tag = "Enumerated"  
    }  
    $mp = ("{0}\{1}" -f $script:WmiConnection.path.path.replace('\root','') , $this.SelectedNode.text)  
    $lvClasses.Items.Clear()  
    if($Script:nsc.Item("$mp")){ #' in Namespace cache  
        $lvClasses.BeginUpdate()  
        $lvClasses.Items.AddRange(($nsc.Item( "$mp")))  
        $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
        $lvClasses.EndUpdate()  
        $lblClasses.Text = $lvClasses.Items.count  
    } else {  
        if(${Global:WmiExplorer.dtClasses}.Select("Namespace='$mp'")){ #' In DataTable Cache  
            $status.BackColor = 'beige'  
            $status.Text = "$mp : Classes in Cache, DoubleClick NameSpace to retrieve Classes"  
        } else {  
            $status.BackColor = 'LightSalmon'  
            $status.Text = "$mp : Classes not recieved yet, DoubleClick NameSpace to retrieve Classes"  
        }  
    }  
}) #' $TVNameSpaces.add_AfterSelect  
#'endregion  
#'region Processing Functions  
#'region ConnectToComputer  
#' Connect to Computer  
Function ConnectToComputer {  
     
    $computer = $txtComputer.Text  
    Set-StatusBar 'beige' "Connecting to : $computer"  
     
    #' Try to Connect to Computer  
    &amp;{  
        trap {  
            Set-StatusBar 'Red' "Connecting to : $computer Failed"  
            $slMessage.Text = "$_.message"  
            Continue  
        }  
        &amp;{  
            #' Connect to WMI root  
             
            $script:WmiConnection.path = "\\$computer\root"  
            $script:WmiConnection.options = $Script:ConnectionOptions  
            $script:WmiConnection.Connect()  
             
            #' Get Avaiable NameSpaces  
     
            $opt = new-object system.management.ObjectGetOptions  
            $opt.UseAmendedQualifiers = $true  
            $Script:NameSpaces = new-object System.Management.ManagementClass(  
                $script:WmiConnection,[Management.ManagementPath]'__Namespace',$opt  
            )  
            Update-Status  
            #' Create a TreeNode for the WMI Root found  
            $computer = $txtComputer.Text  
            $TNRoot = new-object System.Windows.Forms.TreeNode("Root")  
            $TNRoot.Name = $Computer  
            $TNRoot.Text = $lblPath.Text  
            $TNRoot.tag = "Enumerated"  
             
            #' Create NameSpaces List  
             
            $Script:NameSpaces.PSbase.getInstances() | Sort-Object $_.name |  
            ForEach-Object {  
                $TN = new-object System.Windows.Forms.TreeNode  
                $TN.Name = $_.name  
                $TN.Text = ("{0}\{1}" -f $_.__NameSpace,$_.name)  
                $TN.tag = "NotEnumerated"  
                [void]$TNRoot.Nodes.Add($TN)  
            }  
            #' Add to Treeview  
            $tvNameSpaces.Nodes.clear()  
            [void]$TVNamespaces.Nodes.Add($TNRoot)  
             
            #' update StatusBar  
            Set-StatusBar 'YellowGreen' "Connected to : $computer"  
        }  
    }  
} #' ConnectToComputer  
#'endregion  
#'region GetClasseFromNameSpace  
#' Get Classes on DoubleClick on Namespace in TreeView  
Function GetClassesFromNameSpace {  
  if ($this.SelectedNode.name -ne $script:computer){  
    #' Connect to WMI Namespace  
         
    $mp = ("{0}\{1}" -f $script:WmiConnection.path.path.replace('\root','') , $this.SelectedNode.text)  
      #' Update Status  
         
      $lvClasses.BeginUpdate()  
      $lvClasses.Items.Clear()  
      $i = 0 ;$lblClasses.Text = $i; $lblclasses.Update()  
    if($Script:nsc.Item("$mp")){ #'in Namespace Cache, so just attach to ListView again  
         
        $lvClasses.Items.AddRange(($nsc.Item( "$mp")))  
        #' $lvClasses.Items.AddRange(([System.Windows.Forms.ListViewItem[]]($nsc.Item( "$mp") |  
            #' where {$_.name -like 'win32_*'})))  
        $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
        $i = $lvClasses.Items.count  
    } else { #'Not In NameSpace Cache  
      if(${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'")){ #' In DataTable cache, so get from there  
        $status.Text = "loading cache from $($this.SelectedNode.name)"  
        $statusStrip.Update()  
        ${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'") |  
        foreach {  
            $i++  
            $LI = New-Object system.Windows.Forms.ListViewItem  
            $li.Name = $_.name  
            $li.Text = $_.name  
            $li.SubItems.add($_.description)  
            $li.SubItems.add($_.path)  
            $li.ToolTipText = ($_.description)  
            $lvClasses.Items.add($li)  
            $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
            $lblClasses.Text = $lvClasses.Items.count  
        }  
      } else { #' Not in any Cache , Load WMI Classes  
        Set-StatusBar 'Khaki' "Getting Classes from $($this.SelectedNode.name)"  
        $mc = new-object System.Management.ManagementClass($mp,$opt)  
        $eo = New-Object system.management.EnumerationOptions  
        $eo.EnumerateDeep = $true  
        $eo.UseAmendedQualifiers = $true  
        $Mc.psbase.GetSubclasses($eo) |  
        ForEach-Object  {  
            $i++ ; if ($i%10 -eq 0){$lblClasses.Text = $i;$lblclasses.Update() }  
            Trap{$script:Description = "[Empty]";continue}  
            $script:description = $_.psbase.Qualifiers.item("description").value  
            ${Global:WmiExplorer.dtClasses}.Rows.Add($_.__path,$mp,$_.name,$description)  
            $LI = New-Object system.Windows.Forms.ListViewItem  
            $li.Name = $_.name  
            $li.Text = $_.name  
            $li.SubItems.add($description)  
            $li.SubItems.add($_.__path)  
            $li.ToolTipText = $description  
            $lvClasses.Items.add($li)  
        }  
        $status.Text = "Ready, Retrieved $i Classes from $mp"  
      } #'if(${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'"))  
      $lvClasses.Sorting = 'Ascending'  
      $lvClasses.Sort()  
      $script:nsc.Add($mp,(([System.Windows.Forms.ListViewItem[]]($lvClasses.Items)).clone()))  
       
    }  
    $lvClasses.EndUpdate()  
    $this.selectedNode.BackColor = 'AliceBlue'  
    $lblClasses.Text = $i;$lblclasses.Update()  
    $status.BackColor = 'YellowGreen'  
    $statusStrip.Update()  
  } #'if($Script:nsc.Item("$mp"))  
     
} #' GetClassesFromNameSpace  
#'endregion  
#'region GetWmiClass  
Function GetWmiClass {  
    #' Update Status  
     
    $status.Text = "Retrieving Class"  
    $status.BackColor = 'Khaki'  
    $statusstrip.Update()  
    $lblClass.Text =  $this.SelectedItems |ForEach-Object {$_.name}  
    $lblPath.text = $this.SelectedItems |ForEach-Object {"$($_.SubItems[2].text)"}  
     
    #' Add HelpText  
     
    $rtbHelp.Text = ""  
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext("$($lblClass.Text)`n`n")  
    $rtbHelp.selectionFont  = $fontNormal  
    $rtbHelp.appendtext(($this.SelectedItems |ForEach-Object {"$($_.SubItems[1].text)"}))  
    $rtbHelp.appendtext("`n")  
    $path = $lblPath.text  
     
    $opt = new-object system.management.ObjectGetOptions  
    $opt.UseAmendedQualifiers = $true  
     
    $script:WmiClass = new-object system.management.ManagementClass($path,$opt)  
    #' Add Property Help  
     
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext("`n$($lblClass.Text) Properties :`n`n")  
    $rtbHelp.selectionFont  = $fontNormal  
     
    $i = 0 ;$lblProperties.Text = $i; $lblProperties.Update()  
    $clbproperties.Items.Clear()  
    $clbProperties.Items.add('WmiPath',$False)  
             
    $script:WmiClass.psbase.properties |  
    ForEach-Object {  
        $i++ ;$lblProperties.Text = $i; $lblProperties.Update()  
        $clbProperties.Items.add($_.name,$true)  
        $rtbHelp.selectionFont  = $fontBold  
        $rtbHelp.appendtext("$($_.Name) :`n" )  
        &amp;{  
            Trap {$rtbHelp.appendtext("[Empty]");Continue}  
            $rtbHelp.appendtext($_.psbase.Qualifiers["description"].value)  
        }  
        $rtbHelp.appendtext("`n`n")  
    } #' ForEach-Object  
     
    #' Create Method Help  
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext( "$($lblClass.Text) Methods :`n`n" )  
    $i = 0 ;$lblMethods.Text = $i; $lblMethods.Update()  
    $lbmethods.Items.Clear()  
     
    $script:WmiClass.psbase.Methods |  
    ForEach-Object {  
        $i++ ;$lblMethods.Text = $i; $lblMethods.Update()  
        $lbMethods.Items.add($_.name)  
        $rtbHelp.selectionFont  = $fontBold  
        $rtbHelp.appendtext("$($_.Name) :`n")  
        &amp;{  
            Trap {$rtbHelp.Text += "[Empty]"}  
            $rtbHelp.appendtext($_.Qualifiers["description"].value)  
        }  
        $rtbHelp.appendtext("`n`n" )  
    } #'ForEach-Object  
      
    $tabControl.SelectedTab = $tabpage1  
    $status.Text = "Retrieved Class"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
} #' GetWmiClass  
#'endregion  
#'region GetWmiInstances  
Function GetWmiInstances {  
    $status.Text = "Getting Instances for $($lblClass.text)"  
    $status.BackColor = 'Red'  
    $statusstrip.Update()  
    $tabControl.SelectedTab = $tabInstances  
    $MC = new-object system.management.ManagementClass $lblPath.text  
    $MOC = $MC.PSbase.getInstances()  
     
    #'trap{"Class Not found";break}  
     
    $DT =  new-object  System.Data.DataTable  
    $DT.TableName = $lblClass.text  
    $Col =  new-object System.Data.DataColumn  
    $Col.ColumnName = "WmiPath"  
    $DT.Columns.Add($Col)  
    $i = 0  
    $j = 0 ;$lblInstances.Text = $j; $lblInstances.Update()  
    $MOC | ForEach-Object {  
        $j++ ;$lblInstances.Text = $j; $lblInstances.Update()  
        $MO = $_  
         
        #' Make a DataRow  
        $DR = $DT.NewRow()  
        $Col =  new-object System.Data.DataColumn  
         
        $DR.Item("WmiPath") = $mo.__PATH  
        $MO.psbase.properties |  
        ForEach-Object {  
            $prop = $_  
            If ($i -eq 0)  {  
     
                #' Only On First Row make The Headers  
                 
                $Col =  new-object System.Data.DataColumn  
                $Col.ColumnName = $prop.Name.ToString()  
                $prop.psbase.Qualifiers | ForEach-Object {  
                    If ($_.Name.ToLower() -eq "key") {  
                        $Col.ColumnName = $Col.ColumnName + "*"  
                    }  
                }  
                $DT.Columns.Add($Col)   
            }  
             
            #' fill dataRow   
             
            if ($prop.value -eq $null) {  
                $DR.Item($prop.Name) = "[empty]"  
            }  
            ElseIf ($prop.IsArray) {  
                                $ofs = ";"  
                $DR.Item($prop.Name) ="$($prop.value)"  
                                $ofs = $null  
            }  
            Else {  
                $DR.Item($prop.Name) = $prop.value  
                #'Item is Key try again with *  
                trap{$DR.Item("$($prop.Name)*") = $prop.Value.tostring();continue}  
            }  
        }  
        #' Add the row to the DataTable  
        $DT.Rows.Add($DR)  
        $i += 1  
    }  
    $DGInstances.DataSource = $DT.psObject.baseobject  
        $DGInstances.Columns.Item('WmiPath').visible =  $clbProperties.GetItemChecked(0)   
    $status.Text = "Retrieved $j Instances"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
} #' GetWmiInstances  
#'endregion  
#'region OutputWmiInstance  
Function OutputWmiInstance {  
    if ( $this.SelectedRows.count -eq 1 ) {  
        if (-not $Script:InstanceTab) {$Script:InstanceTab = new-object System.Windows.Forms.TabPage  
            $Script:InstanceTab.Name = 'Instance'  
            $Script:rtbInstance = new-object System.Windows.Forms.RichTextBox  
            $Script:rtbInstance.Dock = [System.Windows.Forms.DockStyle]::Fill  
            $Script:rtbInstance.Font = $fontCode  
            $Script:rtbInstance.DetectUrls = $false  
            $Script:InstanceTab.controls.add($Script:rtbInstance)  
            $TabControl.TabPages.add($Script:InstanceTab)  
        }  
        $Script:InstanceTab.Text = "Instance = $($this.SelectedRows | ForEach-Object {$_.DataboundItem.wmiPath.split(':')[1]})" 
        $Script:rtbInstance.Text = $this.SelectedRows |ForEach-Object {$_.DataboundItem |Format-List  * | out-String -width 1000 } 
        $tabControl.SelectedTab = $Script:InstanceTab  
    }  
}  #' OutputWmiInstance  
#'endregion  
#'region GetWmiMethod  
Function GetWmiMethod {  
    $WMIMethod = $this.SelectedItem  
    $WmiClassName = $script:WmiClass.__Class  
    $tabControl.SelectedTab = $tabMethods  
    #'$rtbmethods.ForeColor = 'Green'  
    $rtbMethods.Font  = new-object System.Drawing.Font("Microsoft Sans Serif",8)  
    $rtbMethods.text = ""  
    $rtbMethods.selectionFont  = $fontBold  
     
    $rtbMethods.AppendText(("{1} Method : {0} `n" -f $this.SelectedItem , $script:WmiClass.__Class))  
    $rtbMethods.AppendText("`n")  
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("OverloadDefinitions:`n")  
    $rtbMethods.AppendText("$($script:WmiClass.$WMIMethod.OverloadDefinitions)`n`n")  
    $Qualifiers=@()  
    $script:WmiClass.psbase.Methods[($this.SelectedItem)].Qualifiers | ForEach-Object {$qualifiers += $_.name}  
    #'$rtbMethods.AppendText( "$qualifiers`n" )  
    $static = $Qualifiers -Contains "Static"   
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText( "Static : $static`n" )  
    If ($static) {   
         $rtbMethods.AppendText( "A Static Method does not an Instance to act upon`n`n" )  
         $rtbMethods.AppendText("`n")  
     
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Sample Of Connecting to a WMI Class`n`n")  
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $SB = new-Object text.stringbuilder  
         $SB = $SB.Append('$Computer = "') ; $SB = $SB.AppendLine(".`"")  
         $SB = $SB.Append('$Class = "') ; $SB = $SB.AppendLine("$WmiClassName`"")    
         $SB = $SB.Append('$Method = "') ; $SB = $SB.AppendLine("$WmiMethod`"`n")  
         $SB = $SB.AppendLine('$MC = [WmiClass]"\\$Computer\' + "$($script:WmiClass.__NAMESPACE)" + ':$Class"')    
         #'$SB = $SB.Append('$MP.Server = "') ; $SB = $SB.AppendLine("$($MP.Server)`"")    
         #'$SB = $SB.Append('$MP.NamespacePath = "') ; $SB = $SB.AppendLine("$($script:WmiClass.__NAMESPACE)`"")    
         #'$SB = $SB.AppendLine('$MP.ClassName = $Class')  
         $SB = $SB.AppendLine("`n")     
         #'$SB = $SB.AppendLine('$MC = new-object system.management.ManagementClass($MP)')    
         $rtbMethods.AppendText(($sb.tostring()))  
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Getting information about the methods`n`n")  
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText(  
             '$mc' + "`n" +  
             '$mc | Get-Member -membertype Method' + "`n" +  
             "`$mc.$WmiMethod"  
         )  
    } Else {  
         $rtbMethods.AppendText( "This is a non Static Method and needs an Instance to act upon`n`n" )  
         $rtbMethods.AppendText( "The Example given will use the Key Properties to Connect to a WMI Instance : `n`n" )  
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Example Of Connecting to an Instance`n`n")  
     
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $SB = new-Object text.stringbuilder  
         $SB = $SB.AppendLine('$Computer = "."')  
         $SB = $SB.Append('$Class = "') ; $SB = $SB.AppendLine("$WmiClassName.`"")    
         $SB = $SB.Append('$Method = "') ; $SB = $SB.AppendLine("$WMIMethod`"")  
         $SB = $SB.AppendLine("`n#' $WmiClassName. Key Properties :")    
         $Filter = ""    
         $script:WmiClass.psbase.Properties | ForEach-Object {    
           $Q = @()  
           $_.psbase.Qualifiers | ForEach-Object {$Q += $_.name}   
           $key = $Q -Contains "key"   
           If ($key) {    
             $CIMType = $_.psbase.Qualifiers["Cimtype"].Value    
             $SB = $SB.AppendLine("`$$($_.Name) = [$CIMType]")    
             $Filter += "$($_.name) = `'`$$($_.name)`'"     
           }    
         }    
         $SB = $SB.Append("`n" + '$filter=');$SB = $SB.AppendLine("`"$filter`"")    
         $SB = $SB.AppendLine('$MC = get-WMIObject $class -computer $Computer -Namespace "' +  
             "$($script:WmiClass.__NAMESPACE)" + '" -filter $filter' + "`n")  
         $SB = $SB.AppendLine('#' $MC = [Wmi]"\\$Computer\Root\CimV2:$Class.$filter"')   
         $rtbMethods.AppendText(($sb.tostring()))  
    }   
    $SB = $SB.AppendLine('$InParams = $mc.psbase.GetMethodParameters($Method)')  
    $SB = $SB.AppendLine("`n")  
    #' output Method Parameter Help  
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("`n`n$WmiClassName. $WMIMethod Method :`n`n")   
    $q = $script:WmiClass.PSBase.Methods[$WMIMethod].Qualifiers | foreach {$_.name}  
    if ($q -contains "Description") {  
         $rtbMethods.AppendText(($script:WmiClass.psbase.Methods[$WMIMethod].psbase.Qualifiers["Description"].Value))  
    }   
   
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("`n`n$WMIMethod Parameters :`n")   
  #' get the Parameters   
    
  $inParam = $script:WmiClass.psbase.GetMethodParameters($WmiMethod)  
  $HasParams = $False   
  if ($true) {   
    trap{$rtbMethods.AppendText('[None]') ;continue}    
    $inParam.PSBase.Properties | foreach {   
      $Q = $_.Qualifiers | foreach {$_.name}  
      #' if Optional Qualifier is not present then Parameter is Mandatory   
      $Optional = $q -contains "Optional"  
      $CIMType = $_.Qualifiers["Cimtype"].Value   
      $rtbMethods.AppendText("`nName = $($_.Name) `nType = $CIMType `nOptional = $Optional")  
      #' write Parameters to Example script   
      if ($Optional -eq $TRUE) {$SB = $SB.Append('#' ')}   
      $SB = $SB.Append('$InParams.');$SB = $SB.Append("$($_.Name) = ");$SB = $SB.AppendLine("[$CIMType]")   
      if ($q -contains "Description") {$rtbMethods.AppendText($_.Qualifiers["Description"].Value)}  
      $HasParams = $true    
    }   
  }  
  #' Create the Rest of the Script  
  $rtbMethods.selectionFont  = $fontBold  
  $rtbMethods.AppendText("`n`nTemplate Script :`n")   
  #' Call diferent Overload as Method has No Parameters   
  If ($HasParams -eq $True) {   
      $SB = $SB.AppendLine("`n`"Calling $WmiClassName. : $WMIMethod with Parameters :`"")   
      $SB = $SB.AppendLine('$inparams.PSBase.properties | select name,Value | format-Table')   
      $SB = $SB.AppendLine("`n" + '$R = $mc.PSBase.InvokeMethod($Method, $inParams, $Null)')   
  }Else{   
      $SB = $SB.AppendLine("`n`"Calling $WmiClassName. : $WMIMethod `"")   
      $SB = $SB.AppendLine("`n" + '$R = $mc.PSBase.InvokeMethod($Method,$Null)')   
  }   
  $SB = $SB.AppendLine('"Result :"')   
  $SB = $SB.AppendLine('$R | Format-list' + "`n`n")  
  #' Write Header of the Sample Script :   
   
  $rtbMethods.SelectionColor = 'Green'  
  $rtbMethods.SelectionFont = $fontCode  
  $rtbMethods.AppendText(@"  
#' $WmiClassName. $WMIMethod-Method Template Script"   
#' Created by PowerShell WmiExplorer  
#' /\/\o\/\/ 2006  
#' www.ThePowerShellGuy.com  
#'  
#' Fill InParams values before Executing   
#' InParams that are Remarked (#) are Optional  
"@  
  )  
  $rtbMethods.SelectionColor = 'Black'  
  #'$rtbMethods.SelectionFont = $fontCode  
  $rtbMethods.AppendText("`n`n" + $SB)  
  $rtbMethods.SelectionFont = new-object System.Drawing.Font("Lucida Console",6 )  
  $rtbMethods.AppendText("`n`n Generated by the PowerShell WMI Explorer  /\/\o\/\/ 2006" )  
         
} #' GetWmiMethod  
#'endregion  
#'endregion  
#' Show the Form  
$FrmMain.Add_Shown({$FrmMain.Activate()})  
   
trap {Write-Host $_ ;$status.Text = "unexpected error";$slMessage.Text = "$_.message";continue}  
&amp; {  
    [void]$FrmMain.showdialog()  
}  
#' Resolve-Error $Error[0] | out-string</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_XML</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>RollYourOwn_xml_data</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_XML</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>RollYourOwn_xml_data</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># get some data
$data = Get-Hotfix -ComputerName $env:computername | 
Select Caption,InstalledOn,InstalledBy,HotfixID,Description



# create name map
$map = [ordered]@{
    'update-id' = 'HotFixID'
    'update-type' = 'Description'
    'install-date' = 'InstalledOn'
    'install-by' = 'InstalledBy'
    caption = 'Caption'
}



# new XML doc
[xml]$Doc = New-Object System.Xml.XmlDocument



# doc properties
$dec = $Doc.CreateXmlDeclaration("1.0","UTF-8",$null)
$doc.AppendChild($dec) | Out-Null



# append info
$text = @"

Hotfix Inventory
$(Get-Date)

"@

$doc.AppendChild($doc.CreateComment($text)) | Out-Null



# create node
$root = $doc.CreateNode("element","Computer",$null)
$name = $doc.CreateElement("Name")
$name.InnerText = $env:computername
$root.AppendChild($name) | Out-Null



# updates
$hf = $doc.CreateNode("element","Updates",$null)



# add items
foreach ($item in $data) {
    $h = $doc.CreateNode("element","Update",$null)
    #create the entry values from the mapping hash table
    $map.GetEnumerator() | foreach {
      $e = $doc.CreateElement($_.Name)
      $e.innerText = $item.$($_.value)
      #append to Update
      $h.AppendChild($e) | Out-Null
    }
    #append the element
    $hf.AppendChild($h) | Out-Null
}



# finish up
$root.AppendChild($hf) | Out-Null
$doc.AppendChild($root) | Out-Null
$doc.Save("c:\work\hotfix.xml")



# final XML
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--
Hotfix Inventory
02/06/2017 15:11:44
--&gt;
&lt;Computer&gt;
  &lt;Name&gt;CLI01&lt;/Name&gt;
  &lt;Updates&gt;
    &lt;Update&gt;
      &lt;update-id&gt;KB2899189_Microsoft-Windows-CameraCodec-Package&lt;/update-id&gt;
      &lt;update-type&gt;Update&lt;/update-type&gt;
      &lt;install-date&gt;12/11/2013 00:00:00&lt;/install-date&gt;
      &lt;install-by&gt;NT AUTHORITY\SYSTEM&lt;/install-by&gt;
      &lt;caption&gt;http://support.microsoft.com/kb/2899189&lt;/caption&gt;
    &lt;/Update&gt;
    &lt;Update&gt;
      &lt;update-id&gt;KB2693643&lt;/update-id&gt;
      &lt;update-type&gt;Update&lt;/update-type&gt;
      &lt;install-date&gt;11/26/2013 00:00:00&lt;/install-date&gt;
      &lt;install-by&gt;CLI01\Jeff&lt;/install-by&gt;
      &lt;caption&gt;
      &lt;/caption&gt;
    &lt;/Update&gt;
...
  &lt;/Updates&gt;
&lt;/Computer&gt;

</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>