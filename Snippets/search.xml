<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Calculated_Columns</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_DAX_Calculated_Columns</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Calculated_Columns</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_DAX_Calculated_Columns</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_DAX_Calculated_Columns

'when you look at Measures in the DATA view you don't see it's column or individual values, rather you have to put it into a Table Visual to see it's value
'when you look at a Calculated Column in the DATA view you see a column, and values in every row.

the ICON of a calculated column is a little SIGMA inside a square

'Calculated Columns: "Expands" a table by adding columns defined ba a defined ???
'					They can only look in the row that they are in. 
'						DAX for a calculated column does not see relationships (i.e. to other tables), but you can use relationship FUNCTIONS to see other tables
'							
'			b/c Calculated columns are actual values that are stored in the dataset, then can be used in Slicers/Filters
'			AND when a DAX calculation takes a long time, it might be advantagous to put them into a Calculated column that can be created ahead of time (e.g. SSRS scheduler)

'vs.
'Measures : "Summarizes" all the data into a single value
'			works with whole columns of data and condense them into a single value
'			Computed at run time, stored temporarily
'			Limited by a Filter Context, which are ALL the filters applied by the user


			
----------------------------------------------------------------------------------
'SO if you created two columns in a Visual (e.g. Table) and one was based on a Calculated Column using data from a Related table, 
'	and the other was based on a Measure using data from a Related table, then the Calculated-based Rank would remain unchanged as you
'	apply filters to the related Table, but the Measure-based Rank would change as you applied filters to the related Table.

'e.g. for a Calculated Column
Ranking =        RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))

'e.g. for a MEASURE Column
RankingMeasure = RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))		
---------------------------------------------------------------------------------
			
'Column calculations are computed at time of refresh, and then stored with the table

'They are limited to the row context: They can only look in the row that they are in.

---SIMPLE
'.e.g. 
Gross Sales = [Price] * [Quantity] * (1-[Discount])

---RELATED TABLE
'e.g. calculated value based on column in another table related by [ProductID]
'			uses color from a related table
Color = RELATED(Products[Color]) 'used to pull to a many table from a one table in a 'Many-to-one' relationship

---INTERATOR 'Takes 2 parameters: related table name, and an expression
'e.g. want Total Sales by product between 2 related tables, related by [ProductID] 
'		want the calculation done in the ONE end of the 1-to-Many relationship
SUMX : sums values from a related table  - This is the interator function
RELATEDTABLE: the related table for SUMX
TotalSales = SUMX(RELATEDTABLE(SalesOrderDetail),SalesOrderDetail[LineTotal])</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Filtering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>create_TABLE_from_FILTER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Filtering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>create_TABLE_from_FILTER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' FILTER outputs a temporary table

'1] Modeling {tab} =&gt; New Table {icon in Ribon} =&gt; {formula bar} Table =

'2] Rename 'Table' =&gt; TenDollarDiscount

'3] Enter the following Formula:

		TenDollarDiscount = FILTER(SalesOrderDetail, SalesOrderDetail[OrderQty] * SalesOrderDetail[UnitPrice] * SalesOrderDetail[UnitPriceDiscount] &gt; 10)
		'OR
		TenDollarDiscount =	FILTER(
						  			SalesOrderDetail, 
						  			SalesOrderDetail[OrderQty] * SalesOrderDetail[UnitPrice] * SalesOrderDetail[UnitPriceDiscount] &gt; 10
						  		   )
						  		   
'4] Now you have a table with the Columns (not including Measures) from the table [SalesOrderDetail]</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Filtering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>FILTER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Filtering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>FILTER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
NOTE: 
'FILTER 
'		is both a table function, 
'		and an Iterator which goes through each row and tests the boolean expression
'		when the boolean is TRUE it stays in the results.
'		as compared with CALCULATE, b/c CALCULATE is NOT an Iterator.
'	Since it returns a table, it is almost always used as an input to other functions (e.g. CALCULATE, SUMX)
' if CALCULATE will do the same job, then use it b/c iterators are slower

FILTER: 'for advanced filters, designed to be flexible, and when evaluating multiple Columns
		' for comparing to an aggregate function or measure
		' Returns a Table, for example to a function that requires a table input
		' i.e. it builds a new table, in mmemory, of the rows that meet the filter criteria.
		
FILTER 'is an Iterator

'Syntax: 
			FILTER(
					&lt;table&gt;
					,&lt;filter&gt;
				  )
			 
			table:	
			' The table to be filtered. The table can also be an expression that results in a table.	
			
			filter:	 
			 ' A Boolean expression that is to be evaluated for each row of the table. 
			 ' For example, [Amount] &gt; 0 or [Region] = "France"
			 ' Use RELATED to access a column in a related table in a FILTER iterator.
			 ' Differs from filter statement in CALCULATE, b/c you can use MEASURES in the boolean statements
'e.g. 		
Measure Name := CALCULATE ( SUM ( [Total] ), FILTER (Sales, QTY * Price &lt; 100 ) )

'e.g.
AverageDiscountGreaterthanTen = 
		CALCULATE(
					AVERAGE(SalesOrderDetail[UnitPriceDiscount])
					,FILTER(													'&lt;== The filter comes 2nd in CALCULATE
				  			SalesOrderDetail, 
				  			SalesOrderDetail[OrderQty] * SalesOrderDetail[UnitPrice] * SalesOrderDetail[UnitPriceDiscount] &gt; 10
				  		   )
				  )
=====================================================================================	
'CALCULATE_vs_similar_results_with FILTER

https://www.red-gate.com/simple-talk/databases/sql-server/bi-sql-server/using-the-filter-function-in-dax/


2018 sales using CALCULATE = CALCULATE(
										    SUMX(
										        Sales,
										        [Price]*[Quantity]
										    ),
										    YEAR(Sales[SalesDate]) = 2018			'&lt;== The filter comes 2nd in CALCULATE
										)
										
'vs:										

2018 sales = SUMX(
					    FILTER(								'&lt;== The filter comes 1st in SUMX
					        Sales,
					        YEAR(Sales[SalesDate])=2018
					    ),
					    [Price]*[Quantity]
					)
					
'This will give exactly the same results as the formula using CALCULATE above. 
'The CALCULATE function will run more quickly because 
'	it doesn’t have to iterate down each row in the table testing a condition.	

 ==============================================CALCULATE TABLE as an alternative to FILTER
 
 'FILTER
 --------
 FILTER(
	 		KEEPFILTERS(
	 						VALUES(Products[Color] ) 
	 					), 
	 		Products[Color] = "RED"
 		)
 		
 'vs.
 'CALCULATETABLE performs better
 ------------------
 CALCULATETABLE(
	 				Products,
	 				Products[Color] = "RED"
	 			)
	 			
'vs TREATAS

KEEPFILTERS( TREATAS( {"Red"}, Products[Color] ))
	 			
 ==============================================	 			  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Filtering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Nested_FILTER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Filtering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Nested_FILTER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' EXAMPLE: Combining Conditions by Nesting Functions
2018 American sales using nesting = SUMX(
										    FILTER(
										        FILTER(
										            Sales,
										            RELATED(Country[CountryName])="USA"
										        ),
										        YEAR(Sales[SalesDate])=2018
										    ),
										    [Price]*[Quantity]
										)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Filtering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>TREATAS_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Filtering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>TREATAS_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'to use a filter on one table, like the filter used on another table there are Alternatives to TREATAS 
'suchas : relatiohships, Intersect, TREATAS, Contains

'One reason you might not be able to create a needed relationship is that it would result in
'	multiple paths between two tables, and thus crreate ambigouity.
'SO we use a 'virtual relationship' (e.g. TREATAS) to allow us to do the calculation, speed does suffer in this case.
-------------------------------------------------------------------------------------------
'In the following example, the model contains two unrelated product tables. 
'	If a user applies a filter to DimProduct1[ProductCategory] 
'	selecting Bikes, Seats, Tires, the same filter, Bikes, Seats, Tires is applied to DimProduct2[ProductCategory].

CALCULATE(
			SUM(Sales[Amount]), 
			TREATAS(VALUES(DimProduct1[ProductCategory]), DimProduct2[ProductCategory])
		 )

---------------------------------------a calculated table example:
TREATAS Demo = 
VAR StoreID =               //'This is a 1 column table, we want it to have a relatiohship to the physical table: 'Store Lookup'
{
    "1",
    "2",
    "3",
    "4",
    "5",
    "6"
}
RETURN
TREATAS(
    StoreID,
    'Store Lookup'[store_id]       //'All the values that match the one above will be returned
)		 
	
------------------------------------------------------------------------------------------
Bean Goal (TREATAS) = 
CALCULATE(
    SUM(
        'UNION Demo'[Bean/Teas Goal]
    ),
    TREATAS(
        SUMMARIZE(
            'Calendar',
            'Calendar'[Year_ID],
            'Calendar'[Month_Name]
        ),
        'UNION Demo'[Year],
        'UNION Demo'[Month]
    )
)
		 
-------------------------------------------------------------------------------------------

'  TREATAS can be used as an alternative syntax to apply 
'  a filter in CALCULATE/CALCULATETABLE
DEFINE
    MEASURE Sales[Sales Trendy Colors] =
        CALCULATE (
            [Sales Amount],
            'Product'[Color] IN { "Red", "White", "Blue" }
        )
    MEASURE Sales[Sales Trendy Colors 2] =
        CALCULATE (
            [Sales Amount],
            TREATAS ( { "Red", "White", "Blue" }, 'Product'[Color] )
        )
EVALUATE
SUMMARIZECOLUMNS (
    'Product'[Brand],
    "Sales Trendy Colors", [Sales Trendy Colors],
    "Sales Trendy Colors 2", [Sales Trendy Colors 2]
)

-------------------------------------------------------------------------------------------
'  TREATAS changes the data lineage of a table and it is
'  used to convert values to the desired filtering column.
DEFINE
    MEASURE Sales[NumOfCustomersInStoreCity] =
        VAR StoreCities = VALUES ( Store[City] )
        RETURN
            CALCULATE (
                COUNTROWS ( Customer ),
                TREATAS ( StoreCities, Customer[City] )
            )
    MEASURE Sales[NumOfCustomersInStoreCountry] =
        VAR StoreCountries = VALUES ( Store[CountryRegion] )
        RETURN
            CALCULATE (
                COUNTROWS ( Customer ),
                TREATAS ( StoreCountries, Customer[CountryRegion] )
            )
EVALUATE
SELECTCOLUMNS (
    VALUES ( Store[Continent] ),
    "Continent", Store[Continent],
    "NumOfStores", CALCULATE ( COUNTROWS ( Store ) ),
    "NumOfCustomersInStoreCity", [NumOfCustomersInStoreCity],
    "NumOfCustomersInStoreCountry", [NumOfCustomersInStoreCountry]
)

-------------------------------------------------------------------------------------------

'  TREATAS can be used with tables with multiple columns,
'  in that case you need to provide the new lineage for each 
'  column of the table.
DEFINE
    MEASURE Sales[NumOfCustomersInStoreCity] =
        VAR StoreCities = SUMMARIZE ( Store, Store[CountryRegion], Store[City] )
        RETURN
            CALCULATE (
                COUNTROWS ( Customer ),
                TREATAS ( StoreCities, Customer[CountryRegion], Customer[City] )
            )
    MEASURE Sales[NumOfCustomersInStoreCountry] =
        VAR StoreCountries = VALUES ( Store[CountryRegion] )
        RETURN
            CALCULATE (
                COUNTROWS ( Customer ),
                TREATAS ( StoreCountries, Customer[CountryRegion] )
            )
EVALUATE
SELECTCOLUMNS (
    VALUES ( Store[Continent] ),
    "Continent", Store[Continent],
    "NumOfStores", CALCULATE ( COUNTROWS ( Store ) ),
    "NumOfCustomersInStoreCity", [NumOfCustomersInStoreCity],
    "NumOfCustomersInStoreCountry", [NumOfCustomersInStoreCountry]
)

================================================================================

DAX STUDIO EXAMPLE:
===================
'for 2 tables: Date and Advertising, with no existing relationship between them
'Advertising: granularity, or rows, is Month and year
'Date: granularity, or rows, are Dates, with Month and Year columns

'for this measure:

Total Advertising = 
CALCULATE (
    SUM ( Advertising[AdvertisingAmount] ),
    TREATAS (
        SUMMARIZE ( 'Date', 'Date'[Year], 'Date'[MonthNumber] ),
        Advertising[Year],
        Advertising[Month Number]
    )
)

'MICROSOFT DOCUMENTATION says: 
'		The number of columns specified must match the number of columns in the table expression and be in the same order.
'So, the SUMMARIZE phrase lists the two columns:  'Date'[Year], 'Date'[MonthNumber]
'	those 2 columns correspond to Advertising[Year] and Advertising[Month Number] reespectively

1] 'the TREATAS clause
--------------------------
EVALUATE 
TREATAS (
        SUMMARIZE ( 'Date', 'Date'[Year], 'Date'[MonthNumber] ),			'--&lt;== use this filter 
        Advertising[Year],													'--&lt;== apply it to these columns
        Advertising[Month Number]											'--&lt;== apply it to these columns
    )

OUTPUT
=====================
YEAR    Month Number
2014	1
2014	2
2014	3
2014	4
2014	5
2014	6
2014	7
2014	8
2014	9
2014	10
2014	11
2014	12
    
2] 'Use the TREATAS clause, as a FILTER, in a CALCULATE statement and applied to the Advertising table

EVALUATE 
{
	 CALCULATE (
	    SUM ( Advertising[AdvertisingAmount] ),
	    TREATAS (
	        SUMMARIZE ( 'Date', 'Date'[Year], 'Date'[MonthNumber] ),
	        Advertising[Year],
	        Advertising[Month Number]
	    )
	)
}
    
OUTPUT  {with no external filter context}
=====================    
220 		'{a scalar}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Filtering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>TREATAS_UseCases_or_General_Patterns</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Filtering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>TREATAS_UseCases_or_General_Patterns</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://radacad.com/building-a-virtual-relationship-in-power-bi-basics-of-treatas-dax-function#wpcf7-f3863-p12939-o1

USE CASEs
============================================================================================================
1] 'Treat the table_expression like a specified column(s) to transfer the filter
============================================================================================================
'Think of it as this:
	Treat &lt;table_expression&gt; As &lt;column 1&gt;,&lt;column 2&gt;
	    
SalesAmount using TreatAs = 
		CALCULATE(
				    SUM(FactInternetSales[SalesAmount]),
				    TREATAS(
				    		VALUES(DimCustomer[CustomerKey])		//'The VALUES part of the statement is because the EXPRESSION part should be returning a table not a column.  
				    		,FactInternetSales[CustomerKey]			//'		VALUES is returning the unique list of DimCustomer[CustomerKey] column.
				    	   )
				 )
		
'So in this USE CASE, if there was a ROW CONTEXT filtering DimCustomer[CustomerKey], 
'	then the SUM would respond like there is a similar ROW CONTEXT filtering FactInternetSales[CustomerKey]
'	even though there is no relationship between the two tables;
'Or in other words; 
'	If DimCustomer[CustomerKey] is filtered to show only CustomerKey XYZ, 
'	then FactInternetSales[CustomerKey] would be also filtered to show only CustomerKey XYZ.
	    
'You can use other options such as below too:
TREATAS(
			SELECTCOLUMNS(							//'The SELECTCOLUMNS part of the statement is because the EXPRESSION part should be returning a table not a column. 
							DimCustomer
							,'CustomerKey'
								,DimCustomer[CustomerKey]
						  )
			,FactInternetSales[CustomerKey]
		 )	
		 
 'BUT this will not work, b/c this will give you an ERROR that you cannot use a column name in the expression that expects a table expression.	
 
 TREATAS(
 			DimCustomer[CustomerKey]
 			,FactInternetSales[CustomerKey]
 		)	 
==================================== 		
 2] 'Using Scalar Values and TREATAS
====================================
	'you can even use TREATAS with a scalar table definition; you can use a table constructor ( {} ) to build a table in DAX expression.
	
	Customers with High School Eduction = 
									CALCULATE(
											    COUNTROWS(DimCustomer),
											    TREATAS(
												    		{'High School'}
												    		,DimCustomer[EnglishEducation]
												    	)
										 	)
	'and the result will be count of all customers with their EnglishEducation as High School, regardless of the actual EnglishEducation row context	
	

====================================
3] 'Virtual Relationship Using TREATAS
====================================
Here you can use TREATAS to build various virtual relationships to the DimDate table:

'a measure for Order Date;
qty by order date = 
					CALCULATE(
					    SUM(FactInternetSales[OrderQuantity]),
					    TREATAS(
					        VALUES(DimDate[DateKey]),
					        FactInternetSales[OrderDateKey]
					    ))
' one for Ship Date;
qty by ship date = 
					CALCULATE(
					    SUM(FactInternetSales[OrderQuantity]),
					    TREATAS(
					        VALUES(DimDate[DateKey]),
					        FactInternetSales[ShipDateKey]
					    ))










</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Filtering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>VAR_and_debug_of_FILTER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Filtering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>VAR_and_debug_of_FILTER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>



==============================================================================
'Here’s another way to write the nested FILTER function:

2018 American sales using nesting = SUMX(
    FILTER(
        FILTER(
            Sales,
            RELATED(Country[CountryName])="USA"
        ),
        YEAR(Sales[SalesDate])=2018
    ),
    [Price]*[Quantity]
)
----------------------------------------------------------
US sales in 2018 = 
	//' create a variable to hold the sales in the USA
	VAR UsaSalesTable =  FILTER(
								    Sales,
								    RELATED(Country[CountryName])="USA"
								)
	//' create another variable to filter this to show
	//' only sales in 2008
	VAR UsaSales2018 = FILTER(
							    UsaSalesTable,
							    YEAR(Sales[SalesDate])=2018
							)
	//' finally, calculates sales for these figures
	RETURN SUMX(
				    UsaSales2018,
				    [Price]*[Quantity]
				)
==============================================================================				</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_ITERATOR_and_AGGREGATOR_functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_ITERATOR_and_AGGREGATOR_functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://elias-nordlinder.medium.com/dax-series-4-iterators-and-aggregators-dba4314c0292


NOTE:
'the only differences between the Iterators, such as SUMX, and the aggregator, 
' such as SUM, is the table parameter as the first parameter in the iterator (‘Sales’).
'When the Expression only is a column, such as ‘Sales’[Quantity] the two can be used interchangeable

'As long as you want to write an expression that is not a single column, you must use an iterator.
===================================================================================================
'Iteration functions 
--------------------
' take in (at least) two parameters to work, which means that they do not work by only sending in a column. 
' The first parameter 
		'that iterators works on are the table that they need to “scan”.
' The second parameter
	'They need the virtual table that the expression, which is the second parameter, should iterate over.
	'The second parameter is often an expression that the iterator will evaluate for each row in the table.

'	move row-by-row through the table
'	does a calculation, or retrieves some data	
'	Then aggregates it when it is all done

e.g.
	 X = SUMX(
				Sales,
				Sales[Order Quantity]
			  )
'the iterator SUMX require the table, Sales, and the Expression, 
'	which in this case is just the column, to compute the order quantity.



'They work like calculated columns 
'	so Interation functions, which are aggregation functions, are similar to calculated columns

SUMX
COUNTX
AVERAGEX
MINX
MAXX
RANKX

===================================================================================================
'Aggregator Functions
---------------------
'Aggregators are functions that aggregate values of a column in a table and return a single value.
e.g.
	Y = SUM(Sales[Order Quantity])


'They could work while only taking in one parameter, i.e. a column

SUM' Total Quantity = SUM ( ‘Sales’[Quantity] )
MAX' Max Sales = MAX ( ‘Sales’[Quantity] )
MIN' Min Sales = MIN ( ‘Sales’[Quantity] )
AVERAGE' Average Sales = AVERAGE ( ‘Sales’[Quantity] )


=========================================================================MORE details about ITERATORS

'The second parameter can be a single column like " Sales[Order Quantity] ", 
'	but it can also be a specific expression like the example below.
Total Sales = 
SUMX (
    Sales,
    Sales[Order Quantity] * Sales[Unit Price] * (1 - Sales[Discount Applied] )
    )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ADDCOLUMNS_combined_with_SELECTCOLUMNS</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ADDCOLUMNS_combined_with_SELECTCOLUMNS</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'Adds a Measure, to a column containing the 'Customers'[Customer Name] from the 'Customers' table
EVALUATE
    ADDCOLUMNS(
        SELECTCOLUMNS(
            'Customers',
            "Customer Name", 'Customers'[Customer Name]
            ),
        "Sales Amount", [Sales Amount]
        )
---------------------------------------------------------- note ROW CONTEXT differs for inner vs outer function
DEFINE 
MEASURE _Measures[Sales Amount] = 
        SUMX(
            'Online Sales',
            'Online Sales'[Sales Quantity] * 'Online Sales'[Unit Price] - 'Online Sales'[Discount Amount]
        )



EVALUATE
    ADDCOLUMNS(										//' ROW CONTEXT is: the Color column, that was generated by the inner SELECTCOLUMNS function
        SELECTCOLUMNS(								//' ROW CONTEXT is: the row of the Producs table
            Products,
            "Color", Products[Color],				//' This puts a column with the color from the Products Table 
            "Product Amount", [Sales Amount]		//' This generates the [Sales Amount] for each row of the Products Table
            ),
        "Color Sales Amount", [Sales Amount]		//' At this point the only row context is the colum of 'Color' from the SELECTCOLUMNS step, so this is the Total Sales Amount corresponding to the color
        )

  ----------------------------------------------------------create a calculated table
  
  aCalculatedTable = 
				ADDCOLUMNS(
				    FILTER(
				        'Employee Lookup',
				        'Employee Lookup'[staff_id] IN {6,16,31}
				    ),
				    "Manager Name &amp; Store",
				    'Employee Lookup'[first_name] &amp; " " &amp; 'Employee Lookup'[last_name] &amp; "-" &amp; 'Employee Lookup'[location]
				)
			</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>AVERAGEX_moving_average</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>AVERAGEX_moving_average</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>



===========================================================================EXAMPLES==========================

'using MAX, FILTER &amp; ALL to create a 30-day rolling time period (based on latest transaction date)
Moving Average (AVERAGEX) = 
							VAR LastTransactionDate =  MAX('Calendar'[Transaction_Date])				//'Use the latest date available
							VAR AverageDay = 30								//' 30 day average
							VAR PeriodInVisual = 							//'The rolling window
												FILTER(																		//' This is the table expression for the FILTER function
												    ALL(
												        'Calendar'[Transaction_Date]
												    ),
												    AND(																	//'This is the filter expression for the FILTER function
												        'Calendar'[Transaction_Date] &gt; LastTransactionDate - AverageDay,
												        'Calendar'[Transaction_Date] &lt;= LastTransactionDate
												    )
												)
							VAR OutPut =										//'gets the daily average over the days in 'Calendar' filtered by PeriodInVisual
										CALCULATE(
										    AVERAGEX(							//'would work for SUMX or COUNTX, etc to get the moving SUM or COUNT respectively
												        'Calendar',
												        [Profit]
												    ),
										    PeriodInVisual
							)
RETURN
OutPut</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>AVERAGEX</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>AVERAGEX</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>AVERAGEX
'Calculates the average (arithmetic mean) of a set of expressions evaluated over a table.

'SYNTAX
AVERAGEX(
		&lt;table&gt;
		,&lt;expression&gt;
		)
		
table	
'Name of a physical table, or table expression that specifies the rows over which the aggregation can be performed.
expression	
'An expression with a scalar result, which will be evaluated for each row of the table in the first argument.		

Return value
'A decimal number.

NOTES:

'AVERAGE and AVERAGEX do NOT count days with zero sales when computing an average. To evaluate an 
'	average over a date range that includes dates with no sales, use DIVIDE &amp; COUNTROWS instead

'The AVERAGEX function enables you to evaluate expressions for each row of a table, 
'	and then take the resulting set of values and calculate its arithmetic mean. 
'	Therefore, the function takes a table as its first argument, and an expression as the second argument.

'In all other respects, 
'	AVERAGEX follows the same rules as AVERAGE. 
'	You cannot include non-numeric or null cells. 
'	Both the table and expression arguments are required.

'When there are no rows to aggregate, 
'	the function returns a blank. 
'	When there are rows, but none of them meet the specified criteria, then the function returns 0.


=========================================================================EXAMPLES======================
= AVERAGEX(
			InternetSales
			, InternetSales[Freight]+ InternetSales[TaxAmt]
		  )  
		  
--------------
'REMEMBER: To evaluate an 
'			average over a date range that includes dates with no sales, use DIVIDE &amp; COUNTROWS instead

Average Daily Sales (AVERAGEX) = 
									AVERAGEX(
									    'Calendar',
									    [Customer Sales]
									)		  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>COUNTX</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>COUNTX</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>




=============================EXAMPLES============================================
COUNTX():
	'Syntax: 
	COUNTX(
			&lt;table&gt;
			,&lt;expression&gt;
		   )
		   

table	
	'The table containing the rows to be counted.
	'The first argument must always be a table, or any expression that returns a table
expression	
	'An expression that returns the set of values that contains the values you want to count.
	' The second argument is the column or expression that is searched by COUNTX.		   
		   
		   
	'COUNTX function counts the number of rows which are non-empty when 
	'evaluating an expression over a table.
	'This function cannot be used for boolean values.

------------------------------------------------------
'The following formula returns a count of all rows in the Product table that have a list price.
COUNTX(
		Product,
		[ListPrice]
	  )  
	  
---------------------------------------------------	  
'The following formula illustrates how 
' 	to pass a filtered table to COUNTX for the first argument. 
'The formula uses a filter expression to get only the rows in the Product table that meet the condition, 
'	ProductSubCategory = "Caps", 
'	and then counts the rows in the resulting table that have a list price. 
'The FILTER expression applies to the table Products but uses a value that you look up in the related table, ProductSubCategory.


COUNTX(
		FILTER(
				Product,
				RELATED(ProductSubcategory[EnglishProductSubcategoryName])="Caps"
				), 
		Product[ListPrice]
	   )
---------------------------------------------------------------------------------------
Quantity Resources =
						COUNTX (
						
								'This will exclude only the blank rows of WorkLocation
								Quantity Resources =
								COUNTX (
									    FILTER (
										        Resource Actual,
										        Resource Actual[Category] = "Hours"
										            &amp;&amp; Resource Actual[Quantity] &gt; 0
										            &amp;&amp; NOT ISBLANK ( Resource Actual[Work Location] )
									   		   ),
									    Resource Actual[Name]
								)
								
---------------------------------------------------------------------------------------------
'I am trying to filter all Males with a grade of either C,D or E and to give me the count of rows. 	
CALCULATE(
         COUNTROWS(Grades),
            FILTER(Grades,Grades[Gender]="M"),
            FILTER(Grades,
                 Grades[Grade]="c" || Grades[Grade]="d" || Grades[Grade]="e")

        )								
---------------------------------------------------------------------------------------------
'This will exclude the name completely from the count, if they contain atleast one blank value in Work Location

Quantity Resources =
						VAR _BlankWL =
						    SELECTCOLUMNS (
						        FILTER ( Resource Actual, LEN ( Resource Actual[Work Location] ) = 0 ),
						        "Name", [Name]
						    )
						RETURN
						    COUNTX (
						        FILTER (
						            Resource Actual,
						            Resource Actual[Category] = "Hours"
						                &amp;&amp; Resource Actual[Quantity] &gt; 0
						                &amp;&amp; NOT Resource Actual[Work Location] IN { _BlankWL }
						        ),
						        Resource Actual[Name]
						    )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>MAXX</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>MAXX</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


'SYNTAX
MAXX(
		&lt;table&gt;
		,&lt;expression&gt;
	)  

table	
'	The table containing the rows for which the expression will be evaluated.
expression	
'	The expression to be evaluated for each row of the table.
		
NOTES
=======
' The table argument to the MAXX function can be a table name, 
'	or an expression that evaluates to a table. 
'	The second argument indicates the expression to be evaluated for each row of the table.

'Of the values to evaluate, only the following are counted:
'	Numbers
'	Texts
'	Datesmon
'Blank values are skipped. TRUE/FALSE values are not supported.		
		
RETURN
'The largest value.		
		
====================================================================================		
'EXAMPLES		
	
= MAXX(
		InternetSales
		, InternetSales[TaxAmt]+ InternetSales[Freight]
	  )		
		
-----------------------------------------------------------------
= MAXX(
			FILTER(
					InternetSales
					,[SalesTerritoryCode]="5"
				   )
			, InternetSales[TaxAmt]+ InternetSales[Freight]
		)
		
		
		
------------------------------------------------------------------		
= MAXX( VALUES( Location[Name] ) ),		'NOT SURE why the author used VALUES
		[Total Sales]
	  )		</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>RANKX</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>RANKX</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Returns the ranking of a number in a list of numbers for each row in the table argument

RANKX(
		&lt;table&gt;
		, &lt;expression&gt;
		[, &lt;value&gt;
		[, &lt;order&gt;
		[, &lt;ties&gt;]]]
	)  

table
'Any DAX expression that returns a table of data over which the expression is evaluated.

expression
'Any DAX expression that returns a single scalar value. The expression is evaluated for each row of table, 
'	to generate all possible values for ranking. See the remarks section to understand 
'	the function behavior when expression evaluates to BLANK.

value
'(Optional) Any DAX expression that returns a single scalar value whose rank is to be found.
'			by default, the value in the current row is used. 
'See the remarks section to understand the function's behavior when value is not found in the expression.

'When the value parameter is omitted, the value of expression at the current row is used instead.

order
'(Optional) A value that specifies how to rank value, low to high or high to low:
	ASC
	DESC

ties
'(Optional) An enumeration that defines how to determine ranking when there are ties.

	Skip	'DEFAULT: The next rank value, after a tie, is the rank value of the tie plus the count of tied values. 
	'For example if five (5) values are tied with a rank of 11 then the next value will receive a rank of 16 (11 + 5).

	'This is the default value when ties parameter is omitted.
	Dense	'The next rank value, after a tie, is the next rank value. 
	'	For example if five (5) values are tied with a rank of 11 then the next value will receive a rank of 12.
	
NOTE:
'If your "Total" row is showing a rank of 1, use IF &amp; HASONEVALUE with RANKX to exclude it from the rank	
==============================EXAMPLES======================================================================

Rank of Customer Sales (RANKX) = 
									IF(
									    HASONEVALUE(							//'without this the Total row would be 1
									        'Product Lookup'[product_category]
									    ),
									    RANKX(
									        ALL(
									            'Product Lookup'[product_category]
									        ),
									        [Customer Sales]
									    )
									)
============================================================================================================================================
' in a Matrix visual:
'Suppose there are 2 categorical columns: YEAR, and Product, 
'				   1 Value: [Sales Total]
'To rank the Sales Total both categorical columsn this would be ok:

 'Given this measure (which is blank when there is not sales)
 Total Sales = SUM(Sales[SalesAmount])


RankX_EXCLUDE_BLANKS_Sales_WithinEachYear = 
		IF(
		   NOT ( ISBLANK( [Total Sales]) ),
		    RANKX(
		            FILTER(ALL(Products[Product]), [Total Sales] &lt;&gt; 0),
		            [Total Sales], ,
		            DESC,
		            Dense
		            )
		)

'But if we want to rank the Product Sales within each year then you need to do this:
'The problem with this is that it includes all the rows with a NULL or Zero value for [Total Sales]
RankX_Sales_WithinEachYear = RANKX(
					                    ALL(Products[Product]),
					                    [Total Sales], ,
					                    DESC,
					                    Dense
									)	
========================================================================================================Show x ranked values
0]' A table with a list of ranks to consider (e.g. table: TopNFilter with these 2 colums)
	TopNValue	TopNName
	3			Top 3
	5			Top 5
	...			...
	100			All

00]' A slicer that lists the values in the table, a user picks a value then the measures go to work 

1]' Ranking Measure

	Ranking by Quarterly Average = 
						CALCULATE( 
									RANKX ( 
											ALLSELECTED( customer ) 
											, [Quarterly Average Revenue] 
										   ) ,
									ALL ( DateTable[Year] ) 
								  )
2]' Then the measure that pulls out the top X ranked values, otherwise Blank:
	TopNFiltered Revenue = IF ( 
								[Ranking by Quarterly Average] &lt;= MAX(TopNFilter[TopNValue]) 
								, [Final Measure for Revenue] 
								, BLANK() 
							  ) 
								
									</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SELECTCOLUMNS</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SELECTCOLUMNS</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>SELECTCOLUMNS

'SELECTCOLUMNS returns a table with selected columns from the table plus any new columns 
'	specified by the DAX expression(s)
'SELECTCOLUMNS starts from a blank table

'SELECTCOLUMNS is an Iterator function
'	so when used with CALCULATE or CALCULATETABLE a context transition will occur
' if there are multiple/duplicate rows then there would be  multiple/duplicate in the output
'	and as such no aggregation of multple columns is taking place


'ADDCOLUMNS and SELECTCOLUMNS are nearly identical and behave similarly with an
'	exception, SELECTCOLUMNS starts from a blank table whereas ADDCOLUMNS starts
'	with the entire original table and tacks on columns


'Usefull for creating Calculated Tables

SELECTCOLUMNS(
				&lt;table&gt;									//' source of the selected columns
				, &lt;name&gt;, &lt;scalar_expression&gt; 			//' Selects these columns from &lt;table&gt; to keep.		
				[, &lt;name&gt;, &lt;scalar_expression&gt;]…
				) 

table	'Any DAX expression that returns a table, physical or virtual (e.g. from FILTER)
		'There will be one row in the output for each row that of the Table
		' if there are multiple/duplicate rows then there would be  multiple/duplicate in the output
name	'The name given to the column, enclosed in double quotes.
		' b/c it is working within a row context it can access the column name directly
expression	'Any expression that returns a scalar value like a column reference, integer, or string value.
			'can be columns from the source table, or measures
			'This works b/c SELECTCOLUMNS is an Iterator, and processes each row individually
			
'It is also doing a context transition, b/c every reference to a MEASURE is rewritten to expand the MEASURE
'	surrounded by a CALCULATE, and when you execute a CALCULATE in a Row context you have a context transition
'	Caution: may end up with inflated results from duplicate data

============================================EXAMPLES===============================================



SELECTCOLUMNS(
				Info
				, "StateCountry", [State]&amp;", "&amp;[Country]
				)

----------------------------------------------------------------
EVALUATE
    SELECTCOLUMNS(
        Customers,										//'Source table
        "Customer Name",'Customers'[Customer Name],		//'Column from the Source table
        "Sales Amount", [Sales Amount],					//'a MEASURE
        "Profit Margin %", [Profit Margin %]			//'a MEASURE
        )
        
-----------------------------------------------------------------Calculated Table:

theCalculatedTable = 
					SELECTCOLUMNS(
								    FILTER(
								        'Employee Lookup',
								        'Employee Lookup'[staff_id] IN {6,16,31}
								    	  ),
								    "Employee ID", 
								    'Employee Lookup'[staff_id],
								    "Manager Name &amp; Store",
								    'Employee Lookup'[first_name] &amp; " " &amp; 'Employee Lookup'[last_name] &amp; "-" &amp; 'Employee Lookup'[location]
							   	)
        
----------------------------------------------------------------
Calendar 4 =
			VAR BaseCalendar =
			    CALENDAR ( DATE ( 2016, 1, 1 ), DATE ( 2018, 12, 31 ) )
		
			VAR RenamedCalendar =
			    SELECTCOLUMNS ( 
			    				BaseCalendar, 
			    				"Calendar[Date]", [Date] 
			    				)
		
			VAR Calendar_1 =
			    SELECTCOLUMNS (
						        RenamedCalendar,
						        "Date", 'Calendar'[Date],
						        "Year", YEAR ( Calendar[Date] ),
						        "Month Number", MONTH ( Calendar[Date] ),
						        "Month", FORMAT ( Calendar[Date], "mmmm" ),
						        "Year Month", FORMAT ( Calendar[Date], "mmm yy" 
						        )
			    )
			
			VAR Calendar_2 =
			    ADDCOLUMNS ( 
			    				Calendar_1, 
			    				"Year Month Number", [Year] * 12 + [Month Number] - 1 
			    			)
			
			RETURN
			    Calendar_2



============================================= 'turns a virtual table into a table


EVALUATE 
var campaigns = 
	
	SUMMARIZE( 
				Map_DealerCode_Campaign,
				Map_DealerCode_Campaign[Campaign],
				"whatever", COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])
			  )
VAR renamedCampaignCols = 
			SELECTCOLUMNS( 
							campaigns, 
							"campaigns[whatever]", [whatever] 
						  )

RETURN
renamedCampaignCols

============================================= 'Useing a virtual 
EVALUATE 
var campaigns = 
	
	SUMMARIZE( 
				Map_DealerCode_Campaign,
				Map_DealerCode_Campaign[Campaign],
				"whatever", COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])
			  )
VAR renamedCampaignCols = SELECTCOLUMNS( campaigns, "campaigns[whatever]", [whatever] )

var theTotal = SUMX(SELECTCOLUMNS( campaigns, "campaigns[whatever]", [whatever] ), [Whatever] )


var theTotal2 = SUMX(renamedCampaignCols, [Whatever])

RETURN
{theTotal2}			'You can use either theTotal, or theTotal2 here and it works in DAX Studio


================================='One of the Data columns (i.e. 'Customers'[Customer Name]) , and A Measure (i.e. [Sales Amount]
'WITHOUT a filter

EVALUATE
    ADDCOLUMNS(
        SELECTCOLUMNS(
            'Customers',
            "Customer Name", 'Customers'[Customer Name]
            ),
        "Sales Amount", [Sales Amount]
        )


================================='One of the Data columns (i.e. 'Customers'[Customer Name]) , and A Measure (i.e. [Sales Amount]
'WITH a filter
EVALUATE
	//' CALCULATETABLE lets us add the filter for [Brand Name]
    CALCULATETABLE(
        ADDCOLUMNS(
            SELECTCOLUMNS(
            	//'The Row header is Customer
                'Customers',
                "Customer Name", 'Customers'[Customer Name]
                ),
            //'ADD a column for the Measure
            "Sales Amount", [Sales Amount]
            ),
        'Products'[Brand Name] = "Contoso"
        )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SUMX</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SUMX</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>SUMX
'Returns the sum of an expression evaluated for each row in a table

'If you do not need to filter the column, use the SUM function.
'Returns the sum of an expression evaluated for each row in a table:   
	SUMX(&lt;table&gt;, &lt;expression&gt;)
'Only the numbers in the column are counted. Blanks, logical values, and text are ignored.
  
SYNTAX
	SUMX(
			&lt;table&gt;				//'Can be a physical table, or an expression like FILTER
			, &lt;expression&gt;
		)
		
		 
	&lt;table&gt; 
	'	can be a phydical table, or a virtual table, e.g. resulting from a FILTER statement, or from a VALUES statment
	'	The table containing the rows for which the expression will be evaluated.
	 &lt;expression&gt;
	 'The expression to be evaluated for each row of the table.
	'The second argument is a column that contains the numbers you want to sum, or an expression that evaluates to a column. 
	'where:  expression=The expression to be evaluated for each row of the table.
	
Return value
'A decimal number.	
	
-------------------------------------------------------------

'The following example 
'		first filters the table, InternetSales, on the expression, ShippingTerritoryID = 5, 
'		and then returns the sum of all values in the column, Freight. 
'In other words, the expression returns the sum of freight charges for only the specified sales area.
SUMX(
		FILTER(
				InternetSales, 
				InternetSales[SalesTerritoryID]=5
				),
		[Freight])  

-------------------------------------------------------

SUMX(Sales,
		Sales[Quantity] * Related('Product'[Current Price])
	)
	
'The following example first filters the table, InternetSales, on the expression, ShippingTerritoryID = 5, 
'	and then returns the sum of all values in the column, Freight.	

= SUMX(  FILTER(InternetSales, InternetSales[SalesTerritoryID]=5)  ,
			[Freight]
	  )

' Conditional Sum	  
= SUMX( Sales,
		IF( [Total Sales] &gt; 2000, [Total Sales], 0)  ) 

----------------------------------------------------------
SUMX (
    VALUES ( 'Date'[Calendar Year Month Number] ),
    IF (												
        AND (
            [Sales Amount] &lt;&gt; 0,
            [Sales LY] &lt;&gt; 0
        ),
        [Sales Amount] - [Sales LY]
    )
'EXAMPLE
	'The following example 
	'	first filters the table, [InternetSales], on the expression, { ShippingTerritoryID = 5 } 
	'	and then returns the sum of all values in the column, Freight. 
	'In other words, the expression returns the sum of freight charges for only the specified sales area.
	= SUMX(
			FILTER(
					InternetSales
					, InternetSales[SalesTerritoryID]=5
					)
			,[Freight]
			) 	
'EXAMPLE:

	2018 sales = SUMX(
						    FILTER(								'&lt;== The filter comes 1st in SUMX
						        Sales,
						        YEAR(Sales[SalesDate])=2018
						    ),
						    [Price]*[Quantity]
						)
'EXAMPLE: using a RELATED table in the FILTER statement
	American sales = SUMX(
							    FILTER(
							        Sales,
							        RELATED(Country[CountryName])="USA"
							    ),
							    [Price]*[Quantity]
'EXAMPLE 1:2 combining 2 filters, one of them in a RELATED table
	2018 American sales = SUMX(
								    FILTER(
								        Sales,
								        AND(											--&lt;==' AND function insteasd of &amp;&amp; 
								            RELATED(Country[CountryName])="USA",          
								            YEAR(Sales[SalesDate])=2018
								        )
								    ),
								    [Price]*[Quantity]
								)
'	2:2 - Here’s the same measure, but using the &amp;&amp; symbols:	
	2018 American sales using &amp;&amp; = SUMX(
									    FILTER(
									        Sales,
									        RELATED(Country[CountryName])="USA" &amp;&amp;			--&lt;==' &amp;&amp; insteasd of AND function
									        YEAR(Sales[SalesDate])=2018
									    ),
									    [Price]*[Quantity]
									)		
' EXAMPLE: Combining Conditions by Nesting Functions
2018 American sales using nesting = SUMX(
										    FILTER(
										        FILTER(
										            Sales,
										            RELATED(Country[CountryName])="USA"
										        ),
										        YEAR(Sales[SalesDate])=2018
										    ),
										    [Price]*[Quantity]
										)
					</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ALL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ALL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ALL 'removes filter context from the table or columns named


Can be used as:
1]' A CALCULATE filter modifier
'and
2]' a Table fumction

1]' A CALCULATE filter modifier
===============================
'Returns all the rows in a table, or all the values in a column, 
'	ignoring any filters that might have been applied. 
'This function is useful for clearing filters and creating calculations on all the rows in a table.

SYNTAX:
ALL( 
		[&lt;table&gt; | &lt;column&gt;
		[, &lt;column&gt;
		[, &lt;column&gt;[,…]]]] 
	)  
	
table	
'	The table that you want to clear filters on.
column	
'	The column that you want to clear filters on.

'The argument to the ALL function must be either a reference to a base table or a reference to a base column. 
'You cannot use table expressions or column expressions with the ALL function.	

2]' a Table fumction
======================

//' Returns all the UNIQUE rows of the table, b/c all filters are removed
EVALUATE
    ALL( 'Products' )

//' Returns all rows of the table, b/c all filters are removed, including the blue filter
EVALUATE
    CALCULATETABLE(
        ALL( 'Products' ),
        Products[Color] = "Blue"
        )
//' Returns all rows of the table, b/c all filters are removed,
EVALUATE
    CALCULATETABLE(
        ALL( 'Products' ),
        VALUES( 'Products'[Color] )
        )        
//' Returns all the UNIQUE rows of the column
EVALUATE
    ALL( 'Products'[Color] )

//' returns all unique combinations of both columns
EVALUATE
    ALL( 'Products'[Color], 'Products'[Unit Price] )    

//' returns all unique combinations of both columns
EVALUATE
    SUMMARIZE(
        Products,
        Products[Color],
        Products[Unit Price]
        )

//' b/c CALCULATE runs from the outside to the inside, the inner one is the only one that matters b/c it uses ALL to remove all the filters
EVALUATE
{
    CALCULATE(
        CALCULATE(
            CALCULATE(
                CALCULATE(
                    [Sales Amount],
                    ALL( 'Online Sales' )
                    ),
                'Products'[Color] = "Red"
                ),
            Customers[Country] = "Germany"
            ),
        'Calendar'[Date Key] = DATE(2008,4,12)
        )
}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATE_1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATE_1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' CALCULATE is NOT an ITERATOR

'NOTE: When a MEASURE is referenced in a DAX expression, it is always surrounded by a CALCULATE statement

'SYNTAX
CALCULATE(
			&lt;expression&gt;
			[, &lt;filter1&gt; 
			[, &lt;filter2&gt; 
			[, …]
			]])

RETURNS
----------
'a scaler value

NOTE:
'WITHOUT a filter parameter, the Row Context is passed in as a Filter context, so the expression parameter is evaluated
' on each row, under the row context
'WITH a filter parameter, all the external filters (and Row Context) are replaced by the filter parameter.

'CALCULATE allows you to evaluate an expresson in a modified Filter context
'example: I want to see Total Sales, BUT not for the Current Filter, rather for "Last Year", 
'		so take whatever the current year is and modify it to give me last years total sales
' or even though I am on the row for Australia, I want the total sales for the U.S.

'CALCULATE also performs "CONTEXT TRANSITION" i.e. Row Context is converted to Filter Context

-------------------------------------------------------------------------------------

	&lt;expression&gt;
		'CALCULATE: This is some expression, Measure, or scaler Function, that would be operating in the present filter context
		'CALCULATETABLE: The is some table, or Table Function, that would be operating in the present filter context
		
		
	 &lt;filter1&gt; 
	 	'List of simple boolean filter expressions (note these requre simple, fixed values; you cannot create filters based on MEASURES)
	 	'	as compared to FILTER which can use MEASURES
	 	'	so If you want to use a measure to filter with, use a FILTER statement as the filter Expression.
	 
		'The filter replaces the present filter context with a new filter context, and THEN the &lt;expression&gt; is resolved
		'you can’t use a measure in the filtering part of a CALCULATE function; you can only refer to columns
		
		'CALCULATE filter expressions accept both boolean &amp; table functions (individually or
			'at the same time!), but all filter arguments are automatically converted into a table
			
		'Any time you use write a function that contains a logical statement (IN, &gt;,&lt;, =, etc.) you’re creating a
			'table (internally processed with FILTER &amp; ALL)
			
		'the FILTER function can be used to create a virtual table &lt;filter&gt; for CALCULATE
		
		'The filters are evaluated from last, to first.,
-------------------------------------------------------------------------------------	
	

'There's also the CALCULATETABLE function. 
'	It performs exactly the same functionality, except it modifies the filter context applied to an expression that returns a table object.



'The expression used as the first parameter is essentially the same as a measure.
'the 'filters' over-ride existing filters that are already being applied.

Filters can be:
-----------------
'	Boolean filter expressions
'	Table filter expressions
'	Filter modification functions
'When there are multiple filters, they're evaluated by using the AND logical operator. 
'That means all conditions must be TRUE at the same time.

BOOLEAN FILTER EXPRESSIONS
--------------------------
'A Boolean expression filter is an expression that evaluates to TRUE or FALSE. There are several rules that they must abide by:
'	They can reference only a single column.
'	They cannot reference measures.
'	They cannot use a nested CALCULATE function.
'	They cannot use functions that scan or return a table, including aggregation functions.

'Table filter expression


'EXAMPLE
'you might already have a MEASURE: 

	Number of Products = COUNTROWS('Product')
	
'but you could create a second measure that only looks at that calculation when the unit cost is &gt; $100

	Number of Products OVER 100 = CALCULATE(
											[Number of Products], 
											'Product'[UnitCost] &gt; 100
											)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATE_AllSelected</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATE_AllSelected</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.sqlbi.com/articles/the-definitive-guide-to-allselected/
https://www.goodly.co.in/dax-allselected/dax-allselected-shadow-filter-context/


ALLSELECTED

'gig: In practical terms it lets the calculation proceed in a visual (e.g. a table) using all the filter contexts (i.e. in all the slicers)

'Is most usefull when you want to restore the filter context outside the current visual

'The easiest way to use ALLSELECTED is to never use it in a piece of DAX code that can be called by an Iterator
'	Iterators create additional Shadow Filter contexts
'	NOTE: When a MEASURE is executed inside a Table or Matrix Visual, it actually executes inside of an "ADDCOLUMN"  or "SUMMARIZECOLUMNs"
'		that is created by the visual, i.e. the Visual uses  "ADDCOLUMN"  or "SUMMARIZECOLUMNs", so the visual is creating the
'		Shadow Filter Context that ALLSELECTED is taking advantage of.

'ALLSELECTED works fine when it is used in a measure that is used as a top level measure in a report. You should never
'	start an iteration that calls inside 

'Removes context filters from columns and rows in the current query, while retaining all other context filters or explicit filters.
'The ALLSELECTED function gets the context that represents all rows and columns in the query, while keeping explicit filters and contexts other than row and column filters. 
'	This function can be used to obtain visual totals in queries.

'SYNTAX
ALLSELECTED(
			[&lt;tableName&gt; | &lt;columnName&gt;
			[, &lt;columnName&gt;
			[, &lt;columnName&gt;[,…]]]]
			 )
			 
tableName	
'	The name of an existing table, using standard DAX syntax.
'	This parameter cannot be an expression. This parameter is optional.

'	Applies the last available shadow filter context on any column that has one, in the target table
'	If no shadow filter context exists the normal, current, filter context is used.

columnName	
'	The name of an existing column using standard DAX syntax, usually fully qualified. 
'	It cannot be an expression. This parameter is optional.	

'	Applies the last available shadow filter context on the target column
'	If no shadow filter context exists, all column values are returned.

() 'i.e. neithr Table nor column name is provided
'	This is the same as specifying all columns in the table and applies the last available shadow filter context on the columns
'	If no shadow filter context exists, all column values are returned.


NOTES
'If there is one argument, the argument is either tableName or columnName. 
'	If there is more than one argument, they must be columns from the same table.

'This function is different from ALL() because it retains all filters explicitly set within the query, and it retains all context filters other than row and column filters.



=============================================================================================
'Example of a Numerator over Denominator, where the denominator is all the Brands that are selected in the slicer


'This MEASURE should be discarding the slicer context, and just taking into account the row context (i.e. the brand)
Sales Amount = 
        SUMX(
            'Online Sales',
            Online Sales[Sales Quantity] * Online Sales[Unit Price] - Online Sales[Discount Amount]
        )


Total Sales Percent of Whole = 
    DIVIDE(
        [Sales Amount],							//' This measure just takes into account the row (i.e. Brand) that is in, in the table.
        CALCULATE(
            [Sales Amount],
            ALLSELECTED(Products[Brand Name])	//' This is all the brands selected by the slicer
        )
    )
    
---------------------------------------------------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATE_CrossFilter</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATE_CrossFilter</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>CROSSFILTERR
'	cannot deactivate an activer relationship, it just changes direction in which the filter flows

'SYNTAX
CROSSFILTER(
				&lt;columnName1&gt;
				, &lt;columnName2&gt;
				, &lt;direction&gt;
			)  
			
columnName1	
'usually represents the many side of the relationship to be used; 
'	if the arguments are given in reverse order the function will swap them before using them. This argument cannot be an expression.		

columnName2
'usually represents the one side or lookup side of the relationship to be used; 
'	if the arguments are given in reverse order the function will swap them before using them. This argument cannot be an expression.

Direction
	None 
	' No cross-filtering occurs along this relationship.
	Both 
	' OK for 1=&gt;Many
	' Filters on either side filters the other side.
	OneWay 
	' NOT for one-to-one relationship, NOR  many-to-many relationship
	' 	Filters on the one side or the lookup side of a relationship filter the other side. 
	'	This option cannot be used with a one-to-one relationship . 
	'	Don’t use this option on a many-to-many relationship because it is unclear which side is the lookup side; 
	'	use OneWay_LeftFiltersRight or OneWay_RightFiltersLeft instead.
	OneWay_LeftFiltersRight 
	' NOT for one-to-one relationship, NOR  many-to-one relationship
	'	Filters on the side of &lt;columnName1&gt; filter the side of &lt;columnName2&gt;. 
	'	This option cannot be used with a one-to-one or many-to-one relationship.
	OneWay_RightFiltersLeft 
	' NOT for one-to-one relationship, NOR  many-to-one relationship
	'	Filters on the side of &lt;columnName2&gt; filter the side of &lt;columnName1&gt;. 
	'	This option cannot be used with a one-to-one or many-to-one relationship.

NOTES

'In the case of a 1:1 relationship, there is no difference between the one and both direction.

'CROSSFILTER can only be used in functions that take a filter as an argument, 
'	for example: 
		CALCULATE
		CALCULATETABL
		CLOSINGBALANCEMONTH
		CLOSINGBALANCEQUARTER
		CLOSINGBALANCEYEAR
		OPENINGBALANCEMONTH
		OPENINGBALANCEQUARTER
		OPENINGBALANCEYEAR
		TOTALMTD
		TOTALQTD
		TOTALYTD 

'CROSSFILTER uses existing relationships in the model, identifying relationships by their ending point columns.

'In CROSSFILTER, the cross-filtering setting of a relationship is not important; 
'	that is, whether the relationship is set to filter one, or both directions in the model does not affect the usage of the function. 
'	CROSSFILTER will override any existing cross-filtering setting.

'An error is returned if any of the columns named as an argument is not part of a relationship 
'	or the arguments belong to different relationships.

'If CALCULATE expressions are nested, and more than one CALCULATE expression contains a CROSSFILTER function, 
'	then the innermost CROSSFILTER is the one that prevails in case of a conflict or ambiguity.


=======================================================================================================EXAMPLES

'Suppose you have 2 tables [Dealers] 1 =&gt; * [Sales], i.e. 1 to many, with the direction of the 'filter' from [Dealers] =&gt;  [Sales]
'So if you use [Sales] in the &lt;filter1&gt; of a CALCULATE function to filter the &lt;expression&gt; you will not get the expected results

'SYNTAX
CALCULATE(
			&lt;expression&gt;
			[, &lt;filter1&gt; 	&lt;== You need to use CROSSFILTERR If the active relationship of this does not allow it to filter the &lt;expression&gt;
			[, &lt;filter2&gt; 
			[, …]
			]])
		
'So this will NOT give you the right results, it will not actually 'filter' so you will actually get the TOTAL number of distinct rows in the whole table

		EVALUATE
		{
		    CALCULATE(
		        DISTINCTCOUNT(Dealers[Row Id]),
		        Sales[Date of Sale] = DATE(2018,4,12)
		        )        
		}

'The Solutiuon is to use CROSSFILTER, and just for the calculation use 'BOTH' (or 2)


	EVALUATE
	{
	    CALCULATE(
	        DISTINCTCOUNT(Dealers[Row Id]),
	        Sales[Date of Sale] = DATE(2018,4,12),
	        CROSSFILTER(Sales[Dealer Row Id], Dealers[Row Id], BOTH)
	        )        
	}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATE_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATE_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'SYNTAX
CALCULATE ( 
			&lt;Expression&gt; 			'&lt;=== Scaler Value, often this is a previously created MEASURE, or calculation
			[, &lt;Filter&gt; 			'Filters are OPTIONAL, Filters are tables, NOT scaler values
			[, &lt;Filter&gt; 			'	and if they clash with a visual filter, the Calculate Filter wins
			[, … ] 					'	Calculate filters should not clash with one another
			] 
			] 
		  )
------------------------------------------------CALCULATE without the FILTER syntax
1] 'cannot use a MEASURE in the FILTER, (i.e. second argument) in the simple syntax rather, it must be a Column.
' e.g. of something that does not work:
                         =============
 SalesOver 10k = CALCULATE(
 							[No Employees]
 							, [Tot Salaries] &gt; 100						&lt;&lt; ERROR: cannot use MEASURE in the filter Expression
 						  )
 
 ERROR: 'CALCULATE has been used in a TRUE/FALSE expression that is used as a table filter expression  
 BUT, this is OK:                                        

SalesOver 10k = CALCULATE(
							[No Employees]
							, FILTER(									&lt;&lt; OK: b/c use MEASURE in the FILTER statement, as the filter expression
										Emeployee
										, [Tot Salaries] &gt; 100			&lt;&lt; the MEASURE
									)
						 )

' The results of the filter cannot be a table, it must be a scaler: number, text, date


------------------------------------------------FILTER is what is used by DAX engine whenm you write a simple filter
Suppose there are three rows in visual, each 

'This is the way you can write it
Measure1 = 
	CALCULATE ( 
				[Sales Amount], 			'--&lt;== this is a MEASURE
				Product[Color] = "Green" 	'This filter is applied like a FILTER statement that uses ALL()
			   )							'   i.e. it ignores the external filters

'But the DAX engine translates it to this:	{so the one ABOVE,a nd BELOW are identical}		 
Measure1 = 
	CALCULATE ( 
				[Sales Amount], 			'--&lt;== this is a MEASURE
				FILTER(
					ALL(Product[Color] ),			'&lt;= This means: FILTER will ignore the  'outer filters' on the color
					Product[Color] = "Green" 		' without using ALL, This filter would be applied in addition to the external filters
			   )
' IF you write the FILTER statement , and leave out ALL() then it takes into account the external filters			   
Measure1 = 
	CALCULATE ( 
				[Sales Amount], 			'--&lt;== this is a MEASURE
				FILTER(
					(Product[Color] ),			'&lt;= This means: FILTER take into account the  'outer filters' on the color
					Product[Color] = "Green" 		' without using ALL, This filter is applied IN ADDITION to the external filters
			   )			   			 
			   			 
------------------------------------------------ Context Transition Example	

'CALCULATE performs Context Transition
'So the SUMX sums the sales over just the Currently interated year, as the AVERAGEX iterates over the years
MEASURE Sales[Yearly Avg] =
	AVERAGEX (
		VALUES( theDateTable[Calendar Year] ),
			CALCULATE(						'&lt;== This occurs in the row context created as The AVERAGEX iterates over the table: theDateTable
						SUMX( Sales, Sales[Quantity] * Sales[Net Price] )
					  )
			  )
 'and this is equivalent to this
 MEASURE Sales[Yearly Avg] =
	AVERAGEX (
		VALUES( theDateTable[Calendar Year] ),
			[Sales Amount]							'this is true if [Sales Amount] is a Measure that expands to tp tje SUMX clause (above)
			  )
   
------------------------------------------------ example of the 4 evaluation steps
'Calculate evaluation steps

' 1] Evaluation of filter arguments
' 2] Content transition			&lt;==	"ALL" can get rid of context transition
' 3] Evaluation of CALCULATE Modifiers
' 4] Application of filter arguments and KEEPFILTERS

 Sales[Test] =
 	AVERAGEX (
 		VALUES ( theDateTable[Calendar Year] ),			'--&lt;== AverageX is iterating over the VALUES
 		CALCULATE (
 			[Sales Amount],								'--&lt;== [Sales Amount] is the expression to compute for CALCULATE
 			Product[Category] = "Audio"							' one FILTER argument
 		  KEEPFILTERS( Product[Color] IN {"Red", "Blue"}),		' another Filter argument, that modifies the external filters
 		  USERELATIONSHIP(Sales[Delivery Date], theDateTable[Date])	' a global modifer that changes the relatiohship
 		 )

		   
------------------------------------------------		   
		   
https://www.youtube.com/watch?v=Vz-38fJ4asc

'Example:
'1] There are three channels: Affiliate, Organic, Promotional
'2] There is a measure:
	Total Sales = SUM(Sales[Sales])			--&lt;=== MEASURE
	
'This Measure can be used in a table with a row for each channel, but the value will be the same on each row, 
	'as for the 'affiliate' row channel, so it doesn't work well im the table

Affiliate Sales = 
		CALCULATE(
					[Total Sales],
					Sales[Channel] = "Affiliate"
				  )

'But if you want the Total on each row, in order to get percent of each Total for each channel, then 
'	calculating the Total does make sense:
Total Sales = 
		CALCULATE(
					[Total Sales],
					ALL(Sales[Channel])
				  )
				  
'To get the percent of total sales using a measure:

Prcnt Total Sales =
	DIVIDE(
		[Total Sales],							--&lt;=== MEASURE					
		CALCULATE(
					[Total Sales],				--&lt;=== MEASURE
					ALL(Sales[Channel])
				  )					
				  
'To get the Sales, Same Time Last Year, create a new Measure
SalesLastYear = 
		CALCULATE(
					[Total Sales],
					SAMEPERIODLASTYEAR('Calendar'[Date])
				 )
				 
'To get the Sales Growth Percentage over last year:
SalesGrowthOverLastYear = 
	    [Total Sales] /
		CALCULATE(
					[Total Sales],
					SAMEPERIODLASTYEAR('Calendar'[Date])
				 )
				 
'But when the denominator or numerator are missing you will get ugly results.
'So to fix that:

SalesGrowthOverLastYear = 
	VAR LastYearSales = 
						CALCULATE(
									[Total Sales],
									SAMEPERIODLASTYEAR('Calendar'[Date])
								 )				 
	RETURN
		IF(
			[Total Sales] &lt;&gt; BLANK() &amp;&amp;
			LastYearSales &lt;&gt; BLANK(),
			[Total Sales]/LastYearSales
	)
=================================================================================================
'Example: 4 tables:
' Country ==&gt; City ==&gt; Sales &lt;== Product	
--------------------------------------------------------------------------ALL				  
				  

'Measure that shows the pcnt a given product is of all the products				  
Pcnt of all products = DIVIDE(
								 
								    //' the numerator: number of sales for the current filter context
								    COUNT(Sales[SalesId]),
								    //' the denominator: number of sales for the current filter
								    //' context, but for ALL products
								    CALCULATE(
								        COUNT(Sales[SalesId]),
								        ALL('Product'[ProductName])
								    )
								)				  
				  
'Measure that shows the number of sales as a percentage of the total for all cities and for all products				  
Pcnt of all products and cities = DIVIDE( 
											    //' divide the number of sales ...
											    COUNT(Sales[SalesId]),
											    //' ... by the number of sales for all products and
											    //' cities
											    CALCULATE(
											        COUNT(Sales[SalesId]),
											        ALL('Product'[ProductName]),
											        ALL(City[CityName])
											    )
											)				  
--------------------------------------------------------------------------ALLEXCEPT
'a measure which would show each product/city’s contribution to the grand total for each country:
Pcnt relaxing everything but country = DIVIDE(
											    //' divide the number of sales ...
											    COUNT(Sales[SalesId]),
											    //' ... by the number of sales, keeping only the 
											    //' country constraint
											    CALCULATE(
											        COUNT(Sales[SalesId]),
											        ALLEXCEPT(
											            Sales,
											            Country[CountryName]
											        )
											    )
											)											
------------------------------------------------------------------MODIFIERS
'REMOVEFILTERS from a table, note it would be equivalent to an ALL()
CALCULATE(
			[Customer Sales],
			REMOVEFILTERS( ‘Store Lookup')
		)
'REMOVEFILTERS from a column											
CALCULATE(
			[Customer Sales],
			REMOVEFILTERS(‘Store Lookup’[store_id])
		 )										
----------------------------
'KEEPFILTERS: So when the external context is Store ID = 5, then this will show results, otherwise blank														
measureX = 
			CALCULATE(
			    [Profit],
			    KEEPFILTERS(
						        'Store Lookup'[store_id] = 5
						    )	
						    
'vs. this one: this will show "Store ID = 5" results for every row, and situation

measureX = 
			CALCULATE(
				    [Profit],
				    'Store Lookup'[store_id] = 5
					 )
----------------------------

																	
																	
																	
																	
																	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATE_with_filters_and_context</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATE_with_filters_and_context</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'CALCULATE_with_filters_and_context

'CALCULATE's reason for being is to modify the evaluation context, which is either the filter context or the row context

'CALCULATE creates a new filter context by merging it's filter PARMs with any existing outer filter context

'Filters are evaluated in the outer filter context and then combined together using a logical AND
'If a column is specified in multiple filters, the resulting values are the intersection of the total set of values. In 
'	other words, a logical AND is used


============================ 'w/ a Table and 2 filter Parms
Test Measure = 
				CALCULATE(
				        [Total Sales],								//'&lt;==== The table
				        FILTER(										//'&lt;==== a Filter
				                CreditCards,
				                CreditCards[Card Name] = "Visa"
				        )
				        ,FILTER(									//'&lt;==== a Filter
				            Dealers,
				            [Commission Percentage] * 9.0
				        )
				)
				
=================================================================================================	BOOLEAN FILTERS, since March 2021	
============NOTE:  the multiple columns belong to the SAME table		
'As of March 2021: https://www.sqlbi.com/articles/specifying-multiple-filter-conditions-in-calculate/
'This syntax now works. NOTE:  the multiple columns belong to the SAME table

Red or Contoso Sales :=
CALCULATE (
    [Sales Amount],
    'Product'[Color] = "Red" || 'Product'[Brand] = "Contoso"
)
 
'PRIOR to march 2021 only supported conditions specifying a single column reference, b/c under the hood this was converted to a FILTER statement

LEGACY ' This is the way it worked PRIOR to March 2021
------
'When you wrote this:

Red :=
CALCULATE (
    [Sales Amount],
    'Product'[Color] = "Red"
)

'Under the hood it was converted to this:

Red Sales :=
CALCULATE (
    [Sales Amount],
    FILTER (
        ALL ( 'Product'[Color] ),				    	//' Note use of ALL											
        'Product'[Color] = "Red"
    )
)

'AND that conversion did NOT work for Multiple columns

'Referencing multiple columns in the same predicate was not possible. 
'	In those cases, a multicolumn filter required the complete syntax, as in the following example:

Red or Contoso Sales :=
CALCULATE (
    [Sales Amount],
    FILTER (
        ALL ( 'Product'[Color], 'Product'[Brand] ),						    	//' Note use of ALL
        'Product'[Color] = "Red" || 'Product'[Brand] = "Contoso"
    )
)

==================================================================================================This IGNORES Slicers &amp; external context
'Valid since March 2021
'This ignores outer filters, inother words the filter expression overrides the external filters (e.g. Slicers)
'As of March 2021 this  is now a valid DAX expression: NOTE does NOT have KEEPFILTERS

Big Sales Amount Overrides Filter :=
CALCULATE (
    [Sales Amount],
    Sales[Quantity] * Sales[Net Price] &gt; 1000
)

'Internally, this code is executed as the following expression:

Big Sales Amount Overrides Filter :=
CALCULATE (
    [Sales Amount],
    FILTER (
        ALL ( Sales[Quantity], Sales[Net Price] ),					    	//' Note use of ALL
        Sales[Quantity] * Sales[Net Price] &gt; 1000
    )
)

'The filter overrides any existing filter on Sales[Quantity] and Sales[Net Price]. 
'For example, a slicer with a filter on Sales[Quantity] would be ignored by the Big Sales Amount Overrides Filter measure. 
'	In order to keep the existing filter on a slicer, 
'	you can use KEEPFILTERS as in the Big Sales Amount measure shown at the beginning of the article:
 ================================================================================================= using 2 columns in a filter expression
 ============NOTE:  the multiple columns belong to the SAME table
'This is the new best practice 
Big Sales Amount :=
CALCULATE (
    [Sales Amount],
    KEEPFILTERS ( Sales[Quantity] * Sales[Net Price] &gt; 1000 )
)

'This is sub-optimal, and should NOT be used.
Big Sales Amount :=
CALCULATE (
    [Sales Amount],
    FILTER (
        Sales,
        Sales[Quantity] * Sales[Net Price] &gt; 1000
    )
)

 =================================================================================================Ex. Override external vs Allow External filters
 ============NOTE:  the multiple columns belong to the SAME table
 //' If a column value is specified in a filter, it replaces the selection of the current context for that column (unless KEEPFILTERS is used)
 DEFINE
 	//'KEEPFILTERS =&gt; retain external context
    MEASURE Sales[Big Sales Amount] =
        CALCULATE (
            [Sales Amount],
            KEEPFILTERS ( Sales[Quantity] * Sales[Net Price] &gt; 1000 )
        )
    //' there is no KEEPFILTERS, so it overrides external    
    MEASURE Sales[Big Sales Amount Overrides Filter] =					 
        CALCULATE (
            [Sales Amount],
            Sales[Quantity] * Sales[Net Price] &gt; 1000
        )
EVALUATE
SUMMARIZECOLUMNS (
    Sales[Quantity],
    "Sales Amount", [Sales Amount],
    "Big Sales Amount", [Big Sales Amount],
    "Big Sales Amount Overrides Filter", [Big Sales Amount Overrides Filter]
)
 ================================================================================================= STILL INVALID - Columns from different Tables
 'The columns specified in one same predicate MUST belong to the same table. 
 '	The following expression is therefore still invalid in DAX:
 
 Sales Multiple or Red :=
								CALCULATE (
								    [Sales Amount],
								    Sales[Quantity] &gt; 1 || 'Product'[Color] = "Red"
								)
 
----------------------------------------Instead use CROSSJOIN ------------------------------------- This is VALID
 Sales[Sales Multiple or Red] =
						        CALCULATE (
						            [Sales Amount],
						            FILTER (
						                CROSSJOIN ( ALL ( Sales[Quantity] ), ALL ( 'Product'[Color] ) ),		   //' Note use of ALL
						                Sales[Quantity] &gt; 1 || 'Product'[Color] = "Red"
						            )
						        )
 ================================================================================================= 	Filters are evaluated from the last to the first					 
 'NESTED calculate
 'These three EVALUATE statements are the equivalent
 EVALUATE
{
	CALCULATE(
			[Sales Amount]
			,Products[Brand Name] = "Contoso"
			,Customers[Country]="Canada" || Customers[Country] = "China"
			,'Calendar'[Calendar Month] = 200701
			)

}

EVALUATE
{
	CALCULATE(
		CALCULATE(
			[Sales Amount]
			)
			,Products[Brand Name] = "Contoso"
			,Customers[Country]="Canada" || Customers[Country] = "China"
			,'Calendar'[Calendar Month] = 200701
			)

}


EVALUATE
{
	CALCULATE(
			CALCULATE(
						CALCULATE(
							[Sales Amount]
							)
					,Products[Brand Name] = "Contoso"
					)
			,Customers[Country]="Canada" || Customers[Country] = "China"
			,'Calendar'[Calendar Month] = 200701
			)

}
 ================================================================================================= 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATETABLE_vs_FILTER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATETABLE_vs_FILTER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Recomendatiuon: Use CALCULATE instead of FILTER when possible b/c it is faster
 
 
 ==============================================CALCULATE TABLE as an alternative to FILTER
 
 'FILTER
 --------
 FILTER(
	 		KEEPFILTERS(
	 						VALUES(Products[Color] ) 
	 					), 
	 		Products[Color] = "RED"
 		)
 		
 'vs.
'CALCULATETABLE performs better
 ------------------
 CALCULATETABLE(
	 				Products,
	 				Products[Color] = "RED"
	 			)
 ==============================================CALCULATE is faster than FILTER

 'This iterates over the entire 'Online Sales' table b/c FILTER is an ITERATOR
 EVALUATE
{
    COUNTROWS(
        FILTER(
            'Online Sales',
            RELATED(Products[Color]) = "Blue"
            )
        )
}

'This iterates over the 'Products' table b/c DAX rewrites the query see next section
EVALUATE
{
    COUNTROWS(
        CALCULATETABLE(
            'Online Sales',
            Products[Color] = "Blue"
            )
        )
}
==============================================
General recommendation: use CALCUATETABLE instead of FILTER

//'  'Online Sales' table, has 12 million rows
//'   Products has 2500 rows

//'QUERY #1
//'FILTER is an Iterator
//'This version iterates over the entire 'Online Sales' table, for 12 million rows
EVALUATE
{
    COUNTROWS(
        FILTER(
            'Online Sales',
            RELATED(Products[Color]) = "Blue"           
            )
        )
}

//'QUERY #2
//' Calculate version is about 12% faster
//'This version Iterates over the Products table b/c DAX rewrites the query. In converts the boolean to a FILTER function.
EVALUATE
{
    COUNTROWS(
        CALCULATETABLE(
            'Online Sales',
            Products[Color] = "Blue"     
            )
        )
}


//'QUERY #2, re-written the way the DAX engine will run it
EVALUATE
{
    COUNTROWS (
        CALCULATETABLE (
            'Online Sales',
            FILTER ( ALL ( Products[Color] ), Products[Color] = "Blue" )
        )
    )
}

==============================================

// General recommendation: 
//'	Use CALCULATETABLE when you can, 
//' BUT if you want to use a boolean comparison with a MEASURE then you need to use a FILTER

//' This will have an ERROR: A function 'PLACEHOLDER' has been used in a True/False expression that is used as a table filter expression. This is not allowed.
EVALUATE
    CALCULATETABLE(
        'Products',
        [Sales Amount] &gt; 100000		//'Remember the DAX engine wants to rewrite this boolean expression (which includes the measure) 
        							// 'in terms of a table to use the FILTER function, but there is no table
        							// ' this would need a Row context to work, and we don't have one, and if it did it would have to iterate over the whole Sales table
        )
        
 //' However when you use FILTER, you have a row context and the measure can be used
 
EVALUATE
    FILTER(
        'Products',
        [Sales Amount] &gt; 100000
        )
==============================================order of INNER vs OUTER    


//' FILTER within a FILTER: Inner first, then outer FILTER
EVALUATE
    FILTER(
        FILTER(
            Products;
            [Sales Amount] &gt;= 100000
            );
        [Profit Margin] &gt; 25,0
        )
        
 //' CALCULATETABLE within a CALCULATETABLE : Outer first, then the inner, same is true for CALCULATE   
 EVALUATE
    CALCULATETABLE(
        CALCULATETABLE(
            Products;
            Products[Color] = "Blue"
            );
        Products[Brand Name] = "Contoso"
        )
           </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Filter_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Filter_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/filter-functions-dax

' FILTER functions output a temporary table
' Filters do not propogate in a Row Context, i.e. in Calculated Columns

ADDMISSINGITEMS
ALL
	'Returns all the rows in a table, or all the values in a column, 
	'	ignoring any filters that might have been applied. 
	'	This function is useful for clearing filters 
	'	and creating calculations on all the rows in a table.
	

ALLEXCEPT
ALLNOBLANKROW
ALLSELECTED
CALCULATE	'to override filters, designed to be fast, can use multiple filter statements: Single column to fixed value
			'Evaluates an expression in a context that is modified by the specified filters.
			'It works fastest w/out filters

			'Syntax: 'CALCULATE ( Expression, Filter )
					CALCULATE(&lt;expression&gt;,&lt;filter1&gt;,&lt;filter2&gt;…)  
					'where the expression is some function (often and aggregate function) of the data
					
			'e.g.
			BlackAveragePrice = CALCULATE(AVERAGE(SalesOrderDetail[UnitPrice]), Products[Color] = "Black")
			'If this measure were added to a table, where each row is a different color, it would override the GUI
			'	filters and still show the average black price, regardless of which color was sliced.			
CALCULATETABLE
CROSSFILTER function
		'Specifies cross filtering direction to be used in the evaluation of a DAX expression. 
		'	The relationship is defined by naming, as arguments, the two columns that serve as endpoints.
		'SYNTAX: 	CROSSFILTER(&lt;columnName1&gt;, &lt;columnName2&gt;, &lt;direction&gt;)  

		columnName1	'The name of an existing column, using standard DAX syntax and fully qualified, This argument cannot be an expression.
		columnName2	The name of an existing column, using standard DAX syntax  This argument cannot be an expression.
		Direction	The cross-filter direction to be used. Must be one of the following:		
			None ' No cross-filtering occurs along this relationship.			
			Both ' Filters on either side filters the other side.			
			OneWay ' Filters on the one side or the lookup side of a relationship filter the other side. This option cannot be used with a one-to-one relationship 			
			OneWay_LeftFiltersRight ' Filters on the side of &lt;columnName1&gt; filter the side of &lt;columnName2&gt;. This option cannot be used with a one-to-one or many-to-one relationship.			
			OneWay_RightFiltersLeft ' Filters on the side of &lt;columnName2&gt; filter the side of &lt;columnName1&gt;. This option cannot be used with a one-to-one or many-to-one relationship.
			
			
DISTINCT 'returns a one column table that contains the unique values in a column,
		 '  OR Multiple columnswith distinct combination of values, for a table expression argument
		 
		'e.g.  Notice: DISTINCT gets rid of the duplicates
		Colors = CONCATENATEX(DISTINCT(Products[Color]),Products[Color], ", ")

EARLIER
EARLIEST
FILTER
FILTERS
HASONEFILTER
HASONEVALUE
ISCROSSFILTERED
ISFILTERED
KEEPFILTERS

RELATED ' use on the Many side of a Many to one relationship between the Fact and the Dimension table
	'=&gt; used in Row-Context: so used in CALCULATED Columns, but not in MEASURES
	' outputs a temporary table
	OR
	'grabs values from columns using existing relationships 

	'e.g. of grabbing a field [Sales Territory Region] from another table (e.g. Sales Territory) 
	'	to show up in the calling table, and name the new 'column': [Temperature Key]
	'	as well as grabbing the [Month Number Of Year] field from the 'Date' table 
	
	
	Temperature Key = 
					//'NOTE: do not have to specify the ON field of the JOIN, b/c that is taken care of by the existing Relationship
					RELATED('Sales Territory'[Sales Territory Region])
					&amp;
					RELATED('Date'[Month Number Of Year])
					


RELATEDTABLE ' use on the One side of a One to Many relationship between the Dimension and the Fact table
	'=&gt; used in Row-Context: so used in CALCULATED Columns, but not in MEASURES
	' outputs a temporary table of just the rows related by the JOIN
	'One common use for this is in a Dimension table that is getting multiple rows from a Fact table
	'	where the Dimsion table is 1-to-Many with the Fact table
	
	'e.g. Count the rows from the Fact table (i.e. 'Internet Sales') into the Dimension table where the calculated column is (i.e. column: [Total Transactions])
	'		this uses the relationship between the two tables 
                     COUNTROWS(
                                 RELATEDTABLE('Internet Sales')
                                )
	'SO even though filtering is de-activated in a calculated column, the function RELATEDTABLE allows you to use the relationhip to 'filter' the rows 
	'	from the related table using a column that relates them between the two tables.
	
SELECTEDVALUE
	Syntax: SELECTEDVALUE(&lt;columnName&gt;[, &lt;alternateResult&gt;])  
	'Returns the value when the context for columnName has been filtered down to one distinct value only. Otherwise returns alternateResult.
	'In earlier versions of DAX, this requirement was safely achieved by using a pattern involving three DAX functions; 
	'	IF, HASONEVALUE and VALUES.
	'  The following measure definition presents an example. 
	'It calculates the sales tax amount, but only for sales made to Australian customers.

		Australian Sales Tax =
		IF(
		    HASONEVALUE(Customer[Country-Region]),
		    IF(
		        VALUES(Customer[Country-Region]) = "Australia",
		        [Sales] * 0.10
		    )
		)
		
		'now is replaced by:
		
		Australian Sales Tax =
		IF(
		    SELECTEDVALUE(Customer[Country-Region]) = "Australia",
		    [Sales] * 0.10
		)
		

SUBSTITUTEWITHINDEX
USERELATIONSHIP
'Engage an inactive relationship between related columns, in which case the active relationship will automatically become inactive.
VALUES
	e.g. To get list of unique value to creat a Filter Table
	Table = VALUES('sourceTableName'[fieldNameToSearch])
	
	When a column name is given, returns a single column table of unique values.
	When a Table is given, returns a table with the same columns
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>HASONEFILTER_for_Measure_in_RowContext_and_Totals_row</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>HASONEFILTER_for_Measure_in_RowContext_and_Totals_row</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>HASONEFILTER_for_Measure_in_RowContext_and_Totals_row

======================================================================================================
1] 'Measure tht works in Row Context, but not in Zero Row filters (on Totals row)

Applications_Received = COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])

2] 'Measure that works in just the Totals Row, or zero Row Context
	' the SUMMARIZE builds a 3 row table for calculations
	' the SELECTCOLUMNS lets you use the virtual table like a realtable
	' the SELECTCOLUMNS renames the virtual column to somethng that you can use, and just picks out the column to Aggregate
	' finally SUMX adds up the values

TotalApplicationsForAllCampaings = 

var campaigns = 	
	SUMMARIZE( 
				Map_DealerCode_Campaign,
				Map_DealerCode_Campaign[Campaign],
				"theCount", COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])
			  )
VAR renamedCampaignCols = SELECTCOLUMNS( campaigns, "campaigns[theCount]", [theCount] )

var TotalForAllCampaings = SUMX(renamedCampaignCols, [theCount])

RETURN
TotalForAllCampaings

3] 'Measure that is used in the table, and works in both Row Context and Totals row

Total_Applications = 
var Total_Applications = 
	IF(
		HASONEFILTER(Map_DealerCode_Campaign[Campaign]),
        MEASURES_1[Applications_Received],
		MEASURES_1[TotalApplicationsForAllCampaings]
	  )	

RETURN
Total_Applications

======================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>HASONEFILTER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>HASONEFILTER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
SYNTAX: 
	HASONEVALUE(&lt;columnName&gt;)  

columnName	'The name of an existing column, using standard DAX syntax. It cannot be an expression.

Return value
	'TRUE when the context for columnName has been filtered down to one distinct value only. Otherwise is FALSE.

'An equivalent expression for HASONEVALUE() is 
	COUNTROWS(VALUES(&lt;columnName&gt;)) = 1.


EXAMPLE:
'The following measure formula verifies if the context is being sliced by one value in order to estimate a percentage against a predefined scenario; 
'	in this case you want to compare Reseller Sales against sales in 2007, 
'	then you need to know if the context is filtered by single years. 
'Also, if the comparison is meaningless you want to return BLANK.

= IF(
		HASONEVALUE(DateTime[CalendarYear]),
		SUM(ResellerSales_USD[SalesAmount_USD])
		/
		CALCULATE(
					SUM(ResellerSales_USD[SalesAmount_USD]),
					DateTime[CalendarYear]=2007
				   )
		,BLANK()
	)

Example: 'a measure that shows one if there is a filter, and 0 if there is no filter.
		 ' drop this into a table that has a total row at the bottom:

OneIfThereIsAfilter = 
	IF(
		HASONEFILTER(Map_DealerCode_Campaign[Campaign]),		
		2,
		1
	  )	
	  
	  

 -------------------------------------
 	MEASURE Sales[Audio only] =
		CALCULATE(
					HASONEVALUE('Product'[Category] ),
					 'Product'[Category = "Audio"
				 )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>HASONEVALUE_for_tableTotal</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>HASONEVALUE_for_tableTotal</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'For situationi where the Row Context Column is StockTable[ProductName]
'	each row of the table has one value of StockTable[ProductName]
'	for the rows, the naive Measure (i.e. [Tot Amount])  works in Row Context, but not in the 'Total' row
'	and the "Total" row has 'multiple values' 
'
RightTotalAmount = IF(
						HASONEVALUE(StockTable[ProductName]),
						[Tot Amount],									
						SUMX(										' Do this if it is the 'Total' row, i.e. not just one value
								VALUES(StockTable[ProductName])		'&lt;== use the table of DISTINCT StockTable[ProductName]
								,[Tot Amount]						' 		and for that table calculate the measure
							 )
					 )
					 
===================================================================================my Examnple

'This works in the Row Context, but not necessarily in the TOTAL row hence "_RCX"
Applications_Received_RC = COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])

------------------------

'This is the one to use in the Visual, but it leverages the '_RC' version

Applications_Received = IF(
						HASONEVALUE(Map_DealerCode_Campaign[Campaign]),
						[Applications_Received_RC],									
						SUMX(													//' Do this if it is the 'Total' row, i.e. not just one value
								VALUES(Map_DealerCode_Campaign[Campaign])		//'&lt;== use the table StockTable[ProductName]
								,[Applications_Received_RC]						//' 		and for that table calculate the measure
							 )
					 )
					 
					 
					 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>IN</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>IN</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


SELECT DISTINCT EnglishCountryRegionName
FROM DimGeography
WHERE CountryRegionCode IN ('US', 'CA', 'AU' )
'In DAX you can use a similar syntax if the IN operator is available (it was introduced in 2016):

EVALUATE
CALCULATETABLE (
    VALUES ( Geography[Country Region Name] ),
    Geography[Country Region Code] IN { "US", 'CA', 'AU' }
)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Statistical_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Statistical_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/statistical-functions-dax

' Filters do not propogate in a Row Context, i.e. in Calculated Columns
----------------------------------------------------------------------------------
'SO if you created two columns in a Visual (e.g. Table) and one was based on a Calculated Column using data from a Related table, 
'	and the other was based on a Measure using data from a Related table, then the Calculated-based Rank would remain unchanged as you
'	apply filters to the related Table, but the Measure-based Rank would change as you applied filters to the related Table.

'e.g. for a Calculated Column
Ranking =        RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))

'e.g. for a MEASURE Column
RankingMeasure = RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))		
---------------------------------------------------------------------------------

ADDCOLUMNS
APPROXIMATEDISTINCTCOUNT
AVERAGE
AVERAGEA

AVERAGEX
 		'e.g.
 		AverageGrossSales = AVERAGEX(SalesOrderDetail, SalesOrderDetail[OrderQty] * SalesOrderDetail[UnitPrice] * (1 - SalesOrderDetail[UnitPriceDiscount]))
 		
BETA.DIST
BETA.INV
CHISQ.INV
CHISQ.INV.RT
CONFIDENCE.NORM
CONFIDENCE.T

COUNT():
	'The COUNT function counts the number of cells in a column that contains 
	'values of the whole number or integer or string datatype excluding the 
	'blank cell. It even counts the cell with repeated values.
	' only count non-empty cells  and are not sensitive to repetitive values 
	'in cells.
	Apps = COUNT(FactApplication[Client_App_ID])
	
	'EXAMPLE: show 0 if there are none, 1 if there are some
	' add a zero to convert the blanks to zero, then use "&gt;" to create boolean, then INT to convert back to 0/1
	INT((COUNT(FactApplication[Client_App_ID]) + 0) &gt; 0)

COUNTA():
	'COUNTA function can also count the boolean values (True or False) 
	'whereas count function returns an error .
	' only count non-empty cells  and are not sensitive to repetitive values 
	'in cells.

	Measure  = CALCULATE(
							COUNTA(	Table[Column1] )
							,ALLEXCEPT(
										Table
										,Table[Column1]
									   )
					     )

COUNTX():
	'Syntax: COUNTX(&lt;table&gt;,&lt;expression&gt;)
	'COUNTX function counts the number of rows which are non-empty when 
	'evaluating an expression over a table.
	'This function cannot be used for boolean values.

COUNTAX():
	'Syntax: COUNTAX(&lt;table&gt;,&lt;expression&gt;)
	'similar to COUNTX function with the only difference being that COUNTAX function can operate on boolean values.	

COUNTBLANKS():
	'Syntax: COUNTBLANK(&lt;column&gt;)
	' calculate the number of blanks present in a column.
	 NumbOfRowNumbersWithBlanks = COUNTBLANK('tableName'[columnName])
	
COUNTROWS():
	'Syntax : COUNTROWS(&lt;table&gt;)
	'NOTE: can use FILTERs in place of &lt;table&gt;
	'counts the number of rows in the specified table, or in a table defined by an expression .


CROSSJOIN
	'e.g. Cross Join 3 tables
	RowHeader_Territory_Segment = CROSSJOIN(RowHeaders,Segments,Territories)
DATATABLE function
DISTINCTCOUNT():
	'Syntax: DISTINCTCOUNT(&lt;column&gt;)
	' returns the number of unique values present in a column.
	'It counts NULL as a unique value

DISTINCTCOUNTNOBLANK
	' returns the number of unique values present in a column.
	'It DOES NOT counts NULL as a unique value
	
	CALCULATE( 
				DISTINCTCOUNT(DimDealer[DealerCode]),
				FILTER(DimDealer,DimDealer[DealerActive] = True())
			  )
	
	
EXPON.DIST
GENERATE
GENERATEALL
GEOMEAN
GEOMEANX
MAX
	'This takes the Max from a column, but does not let you filter by some category
MAXA
MAXX
	'This takes the Max from an expression, where the expression is what let's us 'filter' 
	'	down to just some rows
	
	Last Purchase Date for each Customer = 
	    //'return the MAX value from the set of returned rows
	    MAXX(
	            RELATEDTABLE(Internet Sales),     //'Work on the related set of rows from the table, related by the relationship (i.e. the customer)
	            Internet Sales[Order Date]       // 'for each row returned, return this field
	        )	
MEDIAN
MEDIANX
MIN
MINA
MINX
NORM.DIST
NORM.INV
NORM.S.DIST
NORM.S.INV (DAX)
PERCENTILE.EXC
PERCENTILE.INC
PERCENTILEX.EXC
PERCENTILEX.INC
POISSON.DIST
RANK.EQ
RANKX
	RANKX(&lt;table&gt;, &lt;expression&gt;[, &lt;value&gt;[, &lt;order&gt;[, &lt;ties&gt;]]])  
	'e.g. create a MEASURE: for each product (in TABLE_1: Products), go through each row in another table (TABLE_2: SalesOrderDetail)
	
	Ranking = RANKX(
					ALL(Products), 
					SUMX(
							RELATEDTABLE(SalesOrderDetail), 
							SalesOrderDetail[GrossSales])
						)
					)
	'NOTE: if you used  SUMX(SalesOrderDetail, SalesOrderDetail[GrossSales]) 
	'	then it would sum up all the rows, rather than just the related rows
	'NOTE: if we did not use ALL (for [Products] table) then it would only rank for the filtered rows of [Products], and not give us an overall Rank


ROW
SAMPLE
SELECTCOLUMNS
SIN
SINH
SQRTPI
STDEV.P
STDEV.S
STDEVX.P
STDEVX.S
SUMMARIZE
	'SYNTAX
	SUMMARIZE (&lt;table&gt;, &lt;groupBy_columnName&gt;[, &lt;groupBy_columnName&gt;]…[, &lt;name&gt;, &lt;expression&gt;]…)
	'Returns a summary table for the requested totals over a set of groups.
	&lt;expression&gt;	'Any DAX expression that returns a single scalar value, where the expression is to be evaluated multiple times (for each row/context).
T.DIST
T.DIST.2T
T.DIST.RT
T.INV
T.INV.2t
TAN
TANH
TOPN
VAR.P
VAR.S
VARX.P
VARX.S
XIRR
XNPV
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SUMMARIZECOLUMNS_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SUMMARIZECOLUMNS_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

zzz = 
    SUMMARIZECOLUMNS(
        DimDealer[DealerCode],														--&lt;== groupBy_ColumnName
        "DealersWithAtLeastOneApplication",											--&lt;== Name
        IF (CALCULATE( COUNT(FactApplication[Client_App_ID])) &gt; 0, BLANK(),1)		--&lt;== Expression
    )
    
'SAME Table in all inputs    
= SUMX ( 
   		SUMMARIZECOLUMNS 
   			(
   				Salesperson[Salesperson],  											--&lt;== groupBy_ColumnName
   				FILTER (Sales, Sales[Region]="South"), 								--&lt;== FilterTable
   				"Sales Amount", SUMX (Sales, Sales[Sales Amount])), 				--&lt;== Name &amp; Expression
   				[Sales Amount]														--&lt;== Expression
) 

'Typical usage without a filter   
Sales by Year and Color new style =
SUMMARIZECOLUMNS (
    Date[Calendar Year],  															--&lt;== groupBy_ColumnName
    Product[Color],	  																--&lt;== roupBy_ColumnName
    "Sales Amount", SUMX ( Sales, Sales[Quantity] * Sales[Unit Price] )				--&lt;== Name  &amp; Expression
) 

'Typical usage without a filter, and without a new Name for the resulting expression
Sales by Year and Color summarizecolumns =
SUMMARIZECOLUMNS (
    Date[Calendar Year],															--&lt;== groupBy_ColumnName
    Product[Color],																	--&lt;== groupBy_ColumnName
    Sales																			--&lt;== Expression
)


'Creates a CROSS JOIUN of the groupBy_ColumnNames
Sales by Year and Color crossjoin implicit =
SUMMARIZECOLUMNS (
    Date[Calendar Year],															--&lt;== groupBy_ColumnName
    Product[Color]																	--&lt;== groupBy_ColumnName
)

'Because with SUMMARIZECOLUMNS you do not have a row context to the columns you are grouping, you must use VALUES to retrieve such a value from the filter context, 
Sales by Year and Color correction summarizecolumns =
SUMMARIZECOLUMNS (
    Date[Calendar Year Number],														--&lt;== groupBy_ColumnName
    Product[Color],																	--&lt;== groupBy_ColumnName
    "Sales Amount",																	--&lt;== Name
    VAR delta = VALUES ( Date[Calendar Year Number] ) - 2007						--&lt;== Expression
    VAR correction = 1 + ( delta / 100 )											--&lt;== Expression
    RETURN																			--&lt;== Expression
        correction 																	--&lt;== Expression
            * SUMX ( Sales, [Quantity] * Sales[Unit Price] )						--&lt;== Expression
)

---------------------------------------------------------------------------------
'CREATE TABLE - This works to, but has an error in the Visual
DealersSubmittingApps = 
//'SUMMARIZECOLUMNS only shows the non-Zero counts
//'   so all of these dealers had at least One App
VAR TABLE_CountClientAppPerDealer = SUMMARIZECOLUMNS(
                        				DimDealer[DealerCode],
                        				"DealersWithAtLeastOneApplication",
                        				COUNT(FactApplication[Client_App_ID])
                    					)
RETURN
COUNTROWS(TABLE_CountClientAppPerDealer)

---------------------------------------------------------------------------------

----------------------------------------------------------'fine for using a MEASURE, and does not need base table
DEFINE 
MEASURE _Measures[Sales Amount] = 
        SUMX(
            'Online Sales',
            'Online Sales'[Sales Quantity] * 'Online Sales'[Unit Price] - 'Online Sales'[Discount Amount]
        )

EVALUATE
    SUMMARIZECOLUMNS(
        'Products'[Category],
        'Customers'[Country],
        'Calendar'[Calendar Month Label],
        "Sales Amount", [Sales Amount]
        )
----------------------------------------------------------

EVALUATE
    SUMMARIZECOLUMNS(
        'Products'[Category],
        'Customers'[Country],
        'Calendar'[Calendar Month Label],
        //' use the CALCULATETABLE to provide the 'filter table'
        CALCULATETABLE(
            'Calendar',
            'Calendar'[Calendar Month Label] = "April"
            ),
        "Sales Amount", [Sales Amount]
        )
----------------------------------------------------------' 2 filtering operations, and 3 measures added
EVALUATE
    SUMMARIZECOLUMNS(
        'Products'[Category],
        'Customers'[Country],
        'Calendar'[Calendar Month Label],
        CALCULATETABLE(
            'Calendar',
            'Calendar'[Calendar Month Label] = "April"
            ),
        CALCULATETABLE(
            'Products',
            'Products'[Brand Name] = "Fabrikam"
            ),
        "Sales Amount", [Sales Amount],
        "Profit", [Profit],
        "Profit Margin %", [Profit Margin %]
        )
----------------------------------------------------------

--' This generates year and category totals only
EVALUATE
	SUMMARIZECOLUMNS (
	    'Calendar'[Calendar Year],
	    Products[Category],
	    //' name the Subcategory, but it actually creates the Category sub-totals, with a flag (true/false) named " "Is Year and Category sub-Total" 
	    //' BUT you can not include the column "Products[SubCategory]" in the list of columns to summarize
	    ROLLUPADDISSUBTOTAL ( Products[SubCategory], "Is Year and Category sub-Total" ),
	    "Sales Amount", [Sales Amount],
	    "Profit", [Profit],
	    "Profit Margin %", [Profit Margin %]  
	)
	ORDER BY
	    Products[Category],
	    'Calendar'[Calendar Year]

----------------------------------------------------------

-- 'This generates a year total, category total but no grand total
EVALUATE
SUMMARIZECOLUMNS (
    'Calendar'[Calendar Year],
    ROLLUPADDISSUBTOTAL (
					        Products[Category],  "Is Year Total",
					        Products[SubCategory], "Is Category Total"
   						 ),
    "Sales Amount", [Sales Amount],
    "Profit", [Profit],
    "Profit Margin %", [Profit Margin %]
)
ORDER BY
    Products[Category],
    'Calendar'[Calendar Year]

----------------------------------------------------------This rolls up all the category, and also produces a grand-total

--' This generates a grand total, yearly totals and category totals
EVALUATE
	SUMMARIZECOLUMNS (
	    ROLLUPADDISSUBTOTAL ( 
	        'Calendar'[Calendar Year],"Is Grand Total",
	        Products[Category],"Is Year Total",
	        Products[SubCategory],"Is Category Total" 
	        ),
	    "Sales Amount", [Sales Amount],
	    "Profit", [Profit],
	    "Profit Margin %", [Profit Margin %]  
	    
	)
	ORDER BY
	    Products[Category],
	    'Calendar'[Calendar Year]
		
---------------------------------------------------------- only produces the grand-total, but not the category sub-totals

--' This is similar to the prior query except it only generates grand totals.
EVALUATE
	SUMMARIZECOLUMNS (
	    ROLLUPADDISSUBTOTAL (
	        ROLLUPGROUP (
	            'Calendar'[Calendar Year],
	            Products[Category],
	            Products[SubCategory]
	        ),
	        "Is Grand Total"
	    ),
	    "Sales Amount", [Sales Amount],
	    "Profit", [Profit],
	    "Profit Margin %", [Profit Margin %]
	)
	ORDER BY
	    Products[Category],
	    'Calendar'[Calendar Year]


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SUMMARIZE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SUMMARIZE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Microsoft says you may get wrong results if you use Aggregation functions in the  &lt;expression&gt;, inside a SUMMARIZE function

'Best Practice is to use it like SELECT DISTINCT * in SQL
' and if you use a FILTER to construct the &lt;table&gt; then that acts like the WHERE statement.

'SUMMARIZE creates a summary of the input table grouped by the specified columns
'	it is NOT an AGGREGATION function, instead it returns all unique combinations
'	of values based on the columns selected

SUMMARIZE (
			&lt;table&gt;, 
			&lt;groupBy_columnName&gt;		
			[, &lt;groupBy_columnName&gt;]…
			[, &lt;name&gt;, &lt;expression&gt;]…		//' This is DEPRECATED
		   )
		   
table	
'Any DAX expression that returns a table of data.
groupBy_ColumnName	
'(Optional) The qualified name of an existing column used to create summary groups based on the values found in it. 
'	This parameter cannot be an expression.
' the column can be in other tables besides the Source table, as long as there is a many to one relationship
'		from the source to the group by column 
' With multiple &lt;groupBy_columnName&gt;, you will get all the combinations of those categories
name	
'The name given to a total or summarize column, enclosed in double quotes.
expression	
'Any DAX expression that returns a single scalar value, where the expression is to be evaluated multiple times (for each row/context).		   


========================================================================'to create from a filtered subset of the rows
example 1] aCalculatedTable = 
					SUMMARIZE(
					    FILTER(
					        'Sales by Store',
					        'Sales by Store'[quantity_sold] &gt;=3
					    ),
					    'Sales by Store'[customer_id],
					    'Sales by Store'[quantity_sold]
					)
--------------------------------------------------------------------------
example 2 Unsold Pastries = 
						SUMMARIZE(
									    FILTER(
											        'Food Inventory',
											        'Food Inventory'[quantity_sold] &lt;&gt; 'Food Inventory'[quantity_start_of_day]
											    ),
									    'Food Inventory'[transaction_date],
									    'Food Inventory'[store_id],
									    'Food Inventory'[quantity_sold],
									    'Food Inventory'[quantity_start_of_day],
									    'Product Lookup'[current_retail_price],
									    'Product Lookup'[product]
									)
================ DEPRECATED PATTERN vs. BEST PRACTICES PATTERN for Aggregation

DEPRECATED PATTERN
------------------
//'NOTE: this is not a best practive, b/c MS recognizes that there are performance issues with this pattern (i.e. aggregations within Summarize)
//' and MS says you could get unexpected (i.e. wrong results) with complex expressions
//' NO problem with generating the set of unique category combinations, the problem is with aggregating data using the SUMMARIZE function

EVALUATE
    SUMMARIZE(
        'Online Sales',
        'Products'[Category],
        'Customers'[Country],
        'Calendar'[Calendar Month Label],
        "Sales Amount", [Sales Amount]		//'This aggregates, for the groupBy columns as row-contexts for the MEASURE
        )
 
 BEST PRACTICES PATTERN
 ---------------------       
 //' A much better pattern for getting the aggregate is this:
 //' 1] Use SUMMARIZE to get the combinations of the categories
 //' 2] Then use ADDCOLUMNS to get the aggregate columns
         
  EVALUATE
    ADDCOLUMNS(
        SUMMARIZE(
            'Online Sales',
            'Products'[Category],
            'Customers'[Country],
            'Calendar'[Calendar Month Label]
            ),
        "Sales Amount", [Sales Amount],
        "Total Cost", [Total Cost]
        )
      


      
================  'SUMMARIZE function, with a CALCULATETABLE  as the 'table' parameter  
'introduce the filter (i.e. "January) inside the CALCULATETABLE, then group by the subsequent columns

'1] This gives you the group-by columns:

EVALUATE
    SUMMARIZE(
        'Online Sales',
        'Products'[Category],
        'Customers'[Country],
        'Calendar'[Calendar Month Label]
        )

'2] HOWEVER, if you want to just get the categories for "January": replace the simple table (i.e. 'Online Sales') with a filtered version
EVALUATE
    SUMMARIZE(
        CALCULATETABLE(
            'Online Sales',
            'Calendar'[Calendar Month Label] = "January"
            ),
        'Products'[Category],
        'Customers'[Country],
        'Calendar'[Calendar Month Label]
        )
      
================  'SUMMARIZE function, inside a CALCULATETABLE    
'This returns a table with a list of Dates, where they meet the criteria in the last 3 rows      
CALCULATETABLE(
		SUMMARIZE(
					Sales, 
					Date[date]
				 ),
		Date[Year] = 2018,
		Date[Month Number] = 6,
		Store[StoreKey] = 430
		)


================'Here is the measure that could be created from the SELECTCOLUMNS part	

Sales Past Year SameDayLastYear =
VAR DatesToConsider = 
		SELECTCOLUMNS(
						ADDCOLUMNS(
									SUMMARIZE(
												Sales, 
												Store[StoreKey], 
												Date[date]
											  ),
								 	"@PreviousYearDate", DATE(
											 					YEAR(Date[Date]) - 1,
											 					MONTH(Date[Date]),
											 					DAY(Date[Date])
											 				)
								 	),
					 "StoreKey", Store[StoreKey],
					 "DateKey", [@PreviousYearDate]
					 )
VAR result = 
	CALCULATE(
		[Sales Amount],
		DatesToConsider		
		)
RETURN
	Result	
	
					 
================ AGGREGATION is DEPRECATED!
 example 
 'returns a summary of the reseller sales grouped around the calendar year 
 '	and the product category name, 
 'this result table allows you to do analysis over the reseller sales by year and product category.

SUMMARIZE(ResellerSales_USD  
      , DateTime[CalendarYear]  
      , ProductCategory[ProductCategoryName]  
      , "Sales Amount (USD)", SUM(ResellerSales_USD[SalesAmount_USD])  		'simple aggregates may be ok, but should be avoided
      , "Discount Amount (USD)", SUM(ResellerSales_USD[DiscountAmount])   	'simple aggregates may be ok, but should be avoided
      )  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_HowTo</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SeeWhatValuesAreResultingFromA_ROW_context_CONCATENATEX</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_HowTo</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SeeWhatValuesAreResultingFromA_ROW_context_CONCATENATEX</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Example, to see what values of the column 'Product'[Product] are being used by a measure in a particular row context

'creat this measure, and drop it into the Table, or Matrix visual, 
'	and then it will show which products are being counted in that row
ProductValuesVisibleInThisRowContext =  
										CONCATENATEX(
										            Product,
										            'Product'[Product],
										            " , "
										)
										
'This would show the values on seperate lines:

ProductValuesVisibleInThisRowContext =  
										CONCATENATEX(
										            Product,
										            'Product'[Product],
										            UNICHAR(10)
										)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_JOIN___Intercect_UNION_CrossJOIN</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CROSSJOIN</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_JOIN___Intercect_UNION_CrossJOIN</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CROSSJOIN</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Returns a table that contains the Cartesian product of all rows from all tables in the arguments. 
The columns in the new table are all the columns in all the argument tables.
CROSSJOIN is not an Iterator

SYNTAX
------
CROSSJOIN(
			&lt;table&gt;, 		
			&lt;table&gt;
			[, &lt;table&gt;]…
		) 
		
table	
'	Any DAX expression that returns a table of data, or physical tables	 

'Column names from table arguments must all be different in all tables or an error is returned.

'The total number of rows returned by CROSSJOIN() is equal to the product of the number of rows from all tables in the arguments; 
'	also, the total number of columns in the result table is the sum of the number of columns in all tables. 
'For example, if TableA has rA rows and cA columns, and TableB has rB rows and cB columns, and TableC has rC rows and cC column; 
'	then, the resulting table has rA × rb × rC rows and cA + cB + cC columns.


EXAMPLES
===========

'Calculated Table: cartesion product of unique rows in 2 columns, then crossjoin with just one store ID
CROSSJOIN Demo = 
				CROSSJOIN(
						    VALUES(
						        	'Product Lookup'[product_category]
						    	  ),
						    VALUES(
						        	'Product Lookup'[product_group]
						    	  ),
						    FILTER(
							        VALUES(
							        		'Store Lookup'[store_id]
							    		  ),
							    	'Store Lookup'[store_id] = 3
						   		  )
						)



EVALUATE
CALCULATETABLE (
    ADDCOLUMNS (
        CROSSJOIN (
            VALUES ( 'Product'[Color] ),
            VALUES ( 'Product'[Category] )
        ),
        "#Prods", CALCULATE ( COUNTROWS ( 'Product' ) )
    ),
    'Product'[Category] IN { "TV and Video", "Computers" }
)
ORDER BY [Category], [Color]

==========================================

//'This would throw an error:
EVALUATE
    ADDCOLUMNS(
        CROSSJOIN(
            'Products'[Category],	
            'Products'[Brand Name] 			//'This would not work, it would error: A single value for column "Brand Name" in table "Products" cannot be determined
            ),
        "Sales Amount", [Sales Amount] + 0
        )
    ORDER BY Products[Category], Products[Brand Name] 

//'This one would work, to show all combinations of the Category and the Brand Name, with Zero where there were no Sales
EVALUATE
    ADDCOLUMNS(
        CROSSJOIN(
            VALUES('Products'[Category]),
            VALUES('Products'[Brand Name])
            ),
        "Sales Amount", [Sales Amount] + 0
        )
    ORDER BY Products[Category], Products[Brand Name]    

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Logic_statements</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>IF_function_in_DAX</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Logic_statements</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>IF_function_in_DAX</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.youtube.com/watch?v=EmCJTGA3NRA


IF 	'Row Context needs to be created while referring column value in a Measure

AND	'allows only 2 conditions (Mandatory) instead use &amp;&amp;

	AND(Logical1,Logical2)
	
OR	'allows only 2 conditions (Mandatory) instead use ||

	OR(Logical1,Logical2)
	
	
-----------------------------------------------------
'A calculated column has row context, so you can use Columns in the formula for the IF
IF_calculatedColumn = 
	IF(
		Sales[Sales Channel] = "Affiliate",		'--&lt;== This is the test
		Sales[Value] * 0.1						'--&lt;== in this example, the False part has been left off, which results in a Blan
	  )
---------------------
ERROR:!!!
'You can not use a column in the MEASURE formula for the IF, b/c Measure does not have row context
'	if you try to do so the formula will have an error.
'So you have to artificially create it with an iterator function that goes row by row
'I gues by using the SUMX you now have a row by row calculation, then the Row Context kicks in 
'	and if that row corresponds to "Affilliate" then the calculation occurs, BUT just for that row !!
IF_Measure =
	SUMX(
		Sales,
		IF(
			Sales[Sales Channel] = "Affiliate"				--&lt;== This is referring to a Column
			Sales[Value] * 0.1
		   )
		)
----------------------
'Here is a MEASURE, that seems to work in the visual, but it is using a MEASURE in the Comparison
'	whereas the previous example uses a 'column' in the comparison

SalesGT100_Measure =
	IF(
		[Total Sales] &gt;= 100,
		"Yes"
	  )
-----------------------

'Using AND in the IF clause

AndInIFmeasure = 
	SUMX(
		Sales
		IF(
			Sales[Sales Channel] = "Organnic" &amp;&amp;
			FORMAT(Sales[Date], "ddd") = "Sun",
			Sales[Value] * 0.20
		  )
		 )
		 
		 
=======================================Example 

TotalDiscountMeasure =
	SUMX(
			Sales,
			IF(Sales[Discount Applied] = True(),
			[Total Sales] * 0.1						--&lt;== 'uses a Measure, that does not need Row Context
			   )
		)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Logic_statements</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>IF_in_SUMMARIZECOLUMNS</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Logic_statements</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>IF_in_SUMMARIZECOLUMNS</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'This must be a Calculated Column b/c it is using a column in the IF function
zzz = 
    SUMMARIZECOLUMNS(
        DimDealer[DealerCode],
        "DealersWithAtLeastOneApplication",
        IF (CALCULATE( COUNT(FactApplication[Client_App_ID])) &gt; 0, BLANK(),1)
    )
    
 'TRY the idea in the snippet "IF_function_in_DAX" to see if that trick will work</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Logic_statements</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>use_IF_in_a_Measure_to_either_return_a_scaler_or_a_Message</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Logic_statements</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>use_IF_in_a_Measure_to_either_return_a_scaler_or_a_Message</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'test whether there is only one city for a country, and in this event show its name; 
'	otherwise, you could show a message saying that there are multiple cities. 
Cities = IF(
			    //' if there is  one city for the current 
			    //' filter context ...
			    COUNTROWS(VALUES(City[CityName])) = 1,
			    //' ... shows the city's name
			    VALUES(City[CityName]),
			    //' Otherwise, show a message
			    "More than one city"
			) 
			
Cities = IF(
			    //' if there is  one city for the current 
			    //' filter context ...
			    HASONEVALUE(City[CityName]),
			    //' ... shows the city's name
			    VALUES(City[CityName]),
			    //' Otherwise, show a message
			    "More than one city"
			)
			

Cities = IF(
			    //' if there is  one city for the current 
			    //' filter context ...
			    DISTINCTCOUNT(City[CityName]) = 1,
			    //' ... shows the city's name
			    VALUES(City[CityName]),
			    //' Otherwise, show a message
			    "More than one city"
			)	
			
Cities = IF(
			    //' if there is one city for the current 
			    //' filter context ...
			    DISTINCTCOUNT(City[CityName]) = 1,
			    //' ... shows the city's name
			    VALUES(City[CityName]),
			    //' Otherwise, list all city names    
			    CONCATENATEX(
			        VALUES(City[CityName]),
			        City[CityName],
			        ",",
			        City[CityName],
			        ASC
			    )
			)								</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Measures</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_DAX_Measures</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Measures</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_DAX_Measures</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_DAX_Measures

'NOTE: When a MEASURE is referenced in a DAX expression, it is always surrounded by a CALCULATE statement

Measure names must be unique within a .pbix file
You could store the all in one table and then just reference them wherever you need to use them.
BEST PRACTICE: when referencing a column in a DAX calculatiton, always preface it with the Table name, 
	so that you can easily use the measure where ever you want and you will know what it is referring to.
	
'Referencing a MEASURE in a row Context (e.g. a Calculated column) generates a row context transition b/c of the automatic
'	CALCULATE statement that wraps every measure. 	

'when you look at Measures in the DATA view you don't see it's column or individual values, rather you have to put it into a Table Visual to see it's value
'when you look at a Calculated Column in the DATA view you see a column, and values in every row.

the ICON of a MEASURE column is a little CALCULATOR inside a square 

'Calculated Columns: "Expands" a table by adding columns defined ba a defined ???
'					They can only look in the row that they are in.
'vs.
'Measures : "Summarizes" all the data into a single value
'			works with whole columns of data and condense them into a single value
'			Computed at run time, stored temporarily
'			Limited by a Filter Context, which are ALL the filters applied by the user

----------------------------------------------------------------------------------
'SO if you created two columns in a Visual (e.g. Table) and one was based on a Calculated Column using data from a Related table, 
'	and the other was based on a Measure using data from a Related table, then the Calculated-based Rank would remain unchanged as you
'	apply filters to the related Table, but the Measure-based Rank would change as you applied filters to the related Table.

'e.g. for a Calculated Column
Ranking =        RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))

'e.g. for a MEASURE Column
RankingMeasure = RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))		
---------------------------------------------------------------------------------
'e.g.
Total Gross Sales := SUM( Sales[Gross Sales] )  'where Sales[Gross Sales] is Table[field])

'To make sure you are applying the measure to the right table, right click on the table {in Data View}

'You can create Measures in tables with no data

'When you create a 'MEASURE' in the 'Fields' panel of a Table, 
'	and you look at the table in Data View, 
'	you do NOT see a column for the measure
'HOWEVER, you can drag n drop the MEASURE from the 'Fields' panel, into the 'Values' field of a Matrix visualization (for example)
'	and it will show up as a column in the Matrix Visualization

'You can NOT use a MEASURE in a SLICER

CALCULATE 'is good for writing Measures

'You can move a Measure:
Visualization View =&gt; Select the Measure {located in some table} =&gt; Modeling {top menu}
	=&gt; Home Table:xxxTable {drop down}  =&gt; {pick some other table}
---------------------------------------------------------------------------------
'A measure can only use in it's formula: (a) other measures or (b) functions of regular columns (e.g. SUM(someColumn), but it can not use a simple column.	
'Example:
Net Sales = sum(Sales[SalesAmount])-sum(Sales[TotalCost])-sum(Sales[ReturnAmount])-sum(Sales[DiscountAmount])
'Whereas here is a calculated column
Net Sales Calc = Sales[SalesAmount]-Sales[TotalCost]-Sales[ReturnAmount]-Sales[DiscountAmount]
'If you use the Meausure's formulate (i.e. with the Aggregate functions) in a Calculated column then every row has the same value:
Net Sales Calc using Aggregates = sum(Sales[SalesAmount])-sum(Sales[TotalCost])-sum(Sales[ReturnAmount])-sum(Sales[DiscountAmount])</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Measures</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>examples_MEASURE_using_SUMX_to_do_RowByRow_calculations</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Measures</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>examples_MEASURE_using_SUMX_to_do_RowByRow_calculations</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
---------------------------------------------------------------------------------------
'You can not create a Measure that will do a calculation on the values in the rows
'NOTE: it would work for a Calculated Column b/c a Calculated Column has Row Context, BUT not for a Measure
'THIS WILL NOT WORK:
zDIFF = ( DateTable[isMTD] + DateTable[isLastMonth]  )

'But you can trick it by using an ITERATING FUNCTION like SUMX, which creates a Row Context as it iterates

zDIFF = 
    SUMX(
        DateTable,									--&lt;== This gets you into the table
        DateTable[isMTD] + DateTable[isLastMonth]	--&lt;== This calculation is done as it iterates row, by row
    )
    
---------------------------------------------------------------------------------------

    
'LIKEWISE, you can use the same trick to implement an "IF" statement inside a measure


IF_Measure =
	SUMX(
		Sales,
		IF(
			Sales[Sales Channel] = "Affiliate",				--&lt;== This is referring to a Column
			Sales[Value] * 0.1
		   )
		)
		
---------------------------------another IF example

TotalDiscountMeasure =
	SUMX(
			Sales,
			IF(Sales[Discount Applied] = True(),
			[Total Sales] * 0.1						--&lt;== 'uses a Measure, that does not need Row Context
			   )
		)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Measures</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>mimic_slicer_FilterContext_in_DAX_STUDIO</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Measures</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>mimic_slicer_FilterContext_in_DAX_STUDIO</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
 
 
 EVALUATE
{
	CALCULATE(
			[Sales Amount]													//'&lt;======= the Measure
			,Products[Brand Name] = "Contoso"								//'&lt;======= the Slicer value
			,Customers[Country]="Canada" || Customers[Country] = "China"	//'&lt;======= the Slicer value		
			,Calendar[Calendar Month] = 200701								//'&lt;======= the row Context
			)

}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Misc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>create_ROW_NUMBER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Misc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>create_ROW_NUMBER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://radacad.com/generating-row-number-in-power-bi-visualization-using-dax
Example in a table:[Product] with a column that has a unique field: [ProductKey]
1] use a Calculted column 
2] DAX formula:
	RowNumber = RANKX(ALL('TableName'),[UniqueFieldName])	
	RowNumber = RANKX(ALL('Product'),[ProductKey])
	
'Need to use ALL so that when the there is a filter, it will take into account the whole table


'Or can use multiple columns that have unique combinations
Row Number = RANKX(
					ALL(DimProduct[EnglishProductName],DimProduct[Color])
					,[Internet Sales]
					)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Relationhships</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CROSSFILTER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Relationhships</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CROSSFILTER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>CROSSFILTER
'Specifies the cross-filtering direction to be used in a calculation for a relationship that exists between two columns.

'SYNTAX
CROSSFILTER(
			&lt;columnName1&gt;, 		//'usually represents the many side of the relationship to be used
			&lt;columnName2&gt;,		//' usually represents the one side or lookup side of the relationship to be used
			&lt;direction&gt;
		   )  
		   
columnName1	
'The name of an existing column, using standard DAX syntax and fully qualified, 
'	that usually represents the many side of the relationship to be used; 
'if the arguments are given in reverse order the function will swap them before using them. This argument cannot be an expression.
columnName2	
'The name of an existing column, using standard DAX syntax and fully qualified, 
'	that usually represents the one side or lookup side of the relationship to be used; 
'	if the arguments are given in reverse order the function will swap them before using them. This argument cannot be an expression.
Direction	
'The cross-filter direction to be used. Must be one of the following:

	None 
	'No cross-filtering occurs along this relationship.
	
	Both 
	'Filters on either side filters the other side.
	
	OneWay 
	'Filters on the one side or the lookup side of a relationship filter the other side. 
	'	This option cannot be used with a one-to-one relationship . 
	'	Don’t use this option on a many-to-many relationship because it is unclear which side is the lookup side; 
	'	use OneWay_LeftFiltersRight or OneWay_RightFiltersLeft instead.
	
	OneWay_LeftFiltersRight 
	'Filters on the side of &lt;columnName1&gt; filter the side of &lt;columnName2&gt;. 
	'This option cannot be used with a one-to-one or many-to-one relationship.
	
	OneWay_RightFiltersLeft 
	'Filters on the side of &lt;columnName2&gt; filter the side of &lt;columnName1&gt;. 
	'	This option cannot be used with a one-to-one or many-to-one relationship.		   
	
	
	
EXAMPLE
========================
'suppose you have these three tables:
Calendar =&gt; Sales by Store &lt;= Employee lookup
'well then when you have a date selected in the row, and you want to know how 
'	many employees worked that day, the date row context won't let you can't the rows of employees b/c it is 1-way relationship
'	b/c the direction of the relatioship does not flow from the 'Calendar' to the 'Employee Lookup'

	
Number of Employees (CROSSFILTER Measure) = 
CALCULATE(
    COUNTROWS(
        'Employee Lookup'
    ),
    CROSSFILTER(
        'Sales by Store'[staff_id],			//' Many-side first
        'Employee Lookup'[staff_id],		//' then the One-side (or PK)
        Both
    )	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Relationhships</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>problems_creating_Relationships</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Relationhships</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>problems_creating_Relationships</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1]ERROR: 
"We cannot create a relatioship between 'Table1'[field1] and 'Table2'[field1]."
"This could be because there is missing intermediate data to connect the two columns"

'TRY:
The columns can not have the Summation Symbol (Sigma) which indicates that 
PowerBI will provide summations for the column b/c they are numeric, in a visual.
But we want to use the column as an Identifier column

So: go to the model (not the query) select the table and column =&gt; Modeling {tab} =&gt;
	Default Summarization Count {drop-down} =&gt; {change it to "Do Not Summarize"}
	
Another problem is duplicates:
In that case go back to the Query, and using the Filter drop-down, 
	remove a category that is creating duplicates
	
'2] ERROR:	
"You can't create a relationship between these two columns because one of the 
" columns must have unique values

In that case go back to the Query, and using the Filter drop-down, 
	remove a category that is creating duplicates
	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Relationhships</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>RELATED</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Relationhships</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>RELATED</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>RELATED
'Since this function requires row context, in can only be used as a calculated column or as part 
'	of an iterator function that cycles through all rows in a table (FILTER, SUMX, MAXX, etc)


'SYNTAX
RELATED(&lt;column&gt;)  

column	
'The column that contains the values you want to retrieve.
'The column named must reference a table on the "one" side of a relationship (e.g. Many-to-One)
'	i.e. accesses columns from an expanded table

NOTES
=====
'The RELATED function requires that a relationship exists between the current table and the table with related information. 
'	You specify the column that contains the data that you want, 
'		and the function follows an existing many-to-one relationship to fetch the value from the specified column in the related table. 
'	If a relationship does not exist, you must create a relationship.

'When the RELATED function performs a lookup, 
'	it examines all values in the specified table regardless of any filters that may have been applied.

'The RELATED function needs a row context; 
'	therefore, it can only be used in calculated column expression, 
'		where the current row context is unambiguous, 
'		or as a nested function in an expression that uses a table scanning function. 
'A table scanning function, 
'	such as SUMX, gets the value of the current row value and then scans another table for instances of that value.

'The RELATED function cannot be used to fetch a column across a limited relationship.


This is not backed by testing: Row context propogation: Iterators vs (Revisers &amp; FILTER)
========================
'Iterator functions (SUMX, RANKX, etc.) use row context to evaluate row level calculations so they don't 
'	need to use RELATED or RELATEDTABLE functions
'CALCULATE and FILTER creates/modifies Filter Context) and therefore the Row context doesn't 
'	automatically propagate through table relationships so they need to use RELATED or RELATEDTABLE functions
	
'EXAMPLES
===========
FILTER( 
		'InternetSales_USD', 
		RELATED(
				'SalesTerritory'[SalesTerritoryCountry]
				)&lt;&gt;"United States"
	  )

'for a calculated column
'in this case if you remove RELATED you get an ERROR: 
		' A single value for column 'product_group' in table 'Product Lookup' cannot be determined.
Product Group = 
				RELATED(
				    'Product Lookup'[product_group]
				)
				
'for a Measure
'in this case if you remove RELATED you get an ERROR:
'		'A single value for column 'current_wholesale_price' in table 'Product Lookup' cannot be determined.
Wholesale Cost = 
				SUMX(
					    'Sales by Store',
					    'Sales by Store'[quantity_sold] * RELATED(
																        'Product Lookup'[current_wholesale_price]
																    )
					)				</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Relationhships</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>RELATEDTABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Relationhships</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>RELATEDTABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>RELATEDTABLE
'Evaluates a table expression in a context modified by the given filters.
'The RELATEDTABLE function will travel through the existing relationship between tables, 
'	and will populate a list of rows (sub-table) from the give table

'RELATEDTABLE is a shortcut for CALCULATETABLE (with no logical expression) and performs a
'	context transition from row context to filter context, in order to return only the rows
' which satisfy the filter condition

'SYNTAX
RELATEDTABLE(&lt;tableName&gt;)

tableName	
'The name of an existing table using standard DAX syntax. It cannot be an expression.
'Must reference a table on the "many" side of a many-to-one relationship

NOTE
=====
'The RELATEDTETABLE function changes the context in which the data is filtered, 
'	and evaluates the expression in the new context that you specify.
'RELATEDTETABLE is commonly used with aggregators like COUNTROWS, SUMX, AVERAGEX, etc

'This function is a shortcut for CALCULATETABLE function with no logical expression.


This is not backed by testing: Row context propogation: Iterators vs (Revisers &amp; FILTER)
========================
'Iterator functions (SUMX, RANKX, etc.) use row context to evaluate row level calculations so they don't 
'	need to use RELATED or RELATEDTABLE functions
'CALCULATE and FILTER creates/modifies Filter Context) and therefore the Row context doesn't 
'	automatically propagate through table relationships so they need to use RELATED or RELATEDTABLE functions


EXAMPLES
=================

SUMX( 
		RELATEDTABLE('InternetSales_USD')  
    	 , [SalesAmount_USD]
    ) 

'Calculated Column (aggregation)
' the related table is tied to this calculated column's table by the Product ID, so I think it is creating a virtual table of rows with the same Product IT
'	to be used as the &lt;table&gt; by SUMX, and then the column 'Food Inventory'[quantity_start_of_day] in the Virtual Table is summed up.
Number of Food Items Made = 
							SUMX(
							    RELATEDTABLE(								//'&lt;== This is doing the context transition for the SUMX on each row
										        'Food Inventory'
										    ),
									   'Food Inventory'[quantity_start_of_day]
									)        </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Studio</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>DMV_or_SQL_Queries_That_work_in_DAX_STUDIO</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Studio</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>DMV_or_SQL_Queries_That_work_in_DAX_STUDIO</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--'NOTE: you can not use JOINs, and many other TSQL statements in DAX STUDIO


--' Query to retrieve all tables in a model
--' the ID is referenced in the Columns DMV
--' the SystemFlags column: 2=system generated
select * from $SYSTEM.TMSCHEMA_TABLES

--' Query to get all columns (note the SortByColumnId column)
--' [SortByColumnID] tells you that that column is sorted by another column, with that other columns ID shown in the [SortByColumnID] column
Select * From $SYSTEM.TMSCHEMA_COLUMNS

--' Query to get all calculated columns, the ID refers to the ID of the Table {see the first DMV, above}
--' NOTE: [type] = 2 means calculated
Select * From $SYSTEM.TMSCHEMA_COLUMNS Where [type] = 2

--' Query to get all measures
select * from $SYSTEM.TMSCHEMA_MEASURES

--' Query to get all dependencies
select * from $system.discover_calc_dependency

--' Get unique row counts for all tables and columns
--' [ROWS_COUNT] is the field
select * from $SYSTEM.DISCOVER_STORAGE_TABLES order by rows_count desc

--' Query to get all the roles, associated permissions and role memberships defined in the model
select * from $SYSTEM.TMSCHEMA_Roles
select * from $SYSTEM.TMSCHEMA_TABLE_PERMISSIONS
select * from $SYSTEM.TMSCHEMA_Role_Memberships

--' Query to get all the KPIs defined in the model
select * from $SYSTEM.TMSCHEMA_KPIS

--' Query to get session information
select * from $SYSTEM.DISCOVER_SESSIONS

--' Query to get all relationships
select * from $SYSTEM.TMSCHEMA_RELATIONSHIPS

--' Queries to get hierarchy information
select * from $SYSTEM.TMSCHEMA_ATTRIBUTE_HIERARCHIES
select * from $SYSTEM.TMSCHEMA_ATTRIBUTE_HIERARCHY_STORAGES

--' Query to get information about each model:
select * from $SYSTEM.TMSCHEMA_MODEL

--' Query to get information about each partition:
select * from $SYSTEM.TMSCHEMA_PARTITIONS

--' Query to get perspective information:
select * from $SYSTEM.TMSCHEMA_PERSPECTIVES

--' Query to get catalog information (especially compatibility level):
--' The [COMPATIBILITY_LEVEL] may be useful
select * from $SYSTEM.DBSCHEMA_CATALOGS 



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Studio</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>MEASURE_defined_in_query</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Studio</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>MEASURE_defined_in_query</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'NOTE: to get the definition of a MEASURE, into DAX STUDIO without having to retype it:
Right Click the Measure in the Metadata pane =&gt; Define Measure
'To get the Measures that depend on a particular MEASURE from the MetaData:
Right Click the Measure in the Metadata pane =&gt; Define Dependent Measures

======================================================================================== 'Define a local MEASURE
DEFINE																	//'&lt;== required in DAX STUDIO to create the MEASURE
    MEASURE 															//'Need to tell it which TABLE will host the MEASURE
    	'Customers'[Number Of Sales] = 
    									COUNTROWS( 'Online Sales' )
																		//' BUT it will not persist there after the query runs
EVALUATE
    CALCULATETABLE(
        ADDCOLUMNS(
            SELECTCOLUMNS(
                'Customers',
                "Customer Name", 'Customers'[Customer Name]
                ),
            "Sales Amount", [Sales Amount],			//' first MEASURE (defined outside this query)
            "Number of Sales", [Number of Sales]	//' second MEASURE (defined inside this query)
            ),
        'Products'[Brand Name] = "Contoso"
        )

======================================================================================== 'DEFINE multiple Local MEASURES, and override one from the .pbix
DEFINE
    MEASURE 'Customers'[Number Of Sales] =
        COUNTROWS ( 'Online Sales' )
        
    //' This one actually overrides an existing MEASURE in the .pbix file, locally, during the execution of the query    
    MEASURE 'Online Sales'[Sales Amount] =
        SUMX (
	            'Online Sales',
	            'Online Sales'[Sales Quantity] * 'Online Sales'[Unit Price] - 'Online Sales'[Discount Amount]
        	 ) / 100

EVALUATE
CALCULATETABLE (
    ADDCOLUMNS (
        SELECTCOLUMNS ( 'Customers', "Customer Name", 'Customers'[Customer Name] ),
        "Sales Amount", [Sales Amount],
        "Profit", [Profit],							//' &lt;== This [Profit] would be the measure defined in .pbix, not in DATA STUDIO
        "Number of Sales", [Number of Sales]
    ),
    'Products'[Brand Name] = "Contoso"
)        
========================================================================================'Locally define the measure [Profit],rather than use the one from .pbix
DEFINE
    
MEASURE _Measures[Profit] = [Sales Amount] - [Total Cost]

MEASURE _Measures[Sales Amount] = SUMX(
            'Online Sales',
            'Online Sales'[Sales Quantity] * 'Online Sales'[Unit Price] - 'Online Sales'[Discount Amount]
        ) / 100
        
MEASURE _Measures[Total Cost] = SUMX(
        'Online Sales',
        'Online Sales'[Unit Cost] * 'Online Sales'[Sales Quantity]
    ) / 100

MEASURE 'Customers'[Number Of Sales] =
        COUNTROWS ( 'Online Sales' )
        
EVALUATE
CALCULATETABLE (
    ADDCOLUMNS (
        SELECTCOLUMNS ( 'Customers', "Customer Name", 'Customers'[Customer Name] ),
        "Sales Amount", [Sales Amount],
        "Profit", [Profit],
        "Number of Sales", [Number of Sales]
    ),
    'Products'[Brand Name] = "Contoso"
)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Studio</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Simulate_Row_Context_and_Filters</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Studio</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Simulate_Row_Context_and_Filters</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
' Single Measure
EVALUATE
    CALCULATETABLE(
        { [Sales Amount] },					'&lt;== the Measure
        //'These simulate the external filter context
        Customers[Country] = "Canada",
        Products[Color] = "Blue",
        'Calendar'[Date Key] = DATE(2008,4,12)
        )
        
'Multiple Measures: outputs a table with 4 rows in 1 column
EVALUATE
    CALCULATETABLE(
        { [Sales Amount], [Total Cost], [Profit], [Profit Margin %] },
        Customers[Country] = "Canada",
        Products[Color] = "Blue",
        'Calendar'[Date Key] = DATE(2008,4,12)
        )
'Multiple Measures: outputs a table with 1 rows in 4 column      
EVALUATE
    CALCULATETABLE(
        { ( [Sales Amount], [Total Cost], [Profit], [Profit Margin %] ) },
        Customers[Country] = "Canada",
        Products[Color] = "Blue",
        'Calendar'[Date Key] = DATE(2008,4,12)
        )      </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_TABLE</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>VirtualTables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_TABLE</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>VirtualTables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>============================================= 'turns a virtual table into a table


EVALUATE 
var campaigns = 
	
	SUMMARIZE( 
				Map_DealerCode_Campaign,
				Map_DealerCode_Campaign[Campaign],
				"whatever", COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])
			  )
VAR renamedCampaignCols = 
			SELECTCOLUMNS( 
							campaigns, 
							"campaigns[whatever]", [whatever] 
						  )

RETURN
renamedCampaignCols

============================================= 'Useing a virtual 
EVALUATE 
var campaigns = 
	
	SUMMARIZE( 
				Map_DealerCode_Campaign,
				Map_DealerCode_Campaign[Campaign],
				"whatever", COUNT(IndirectAuto_CBTJITSQL02_JIT[applicationID])
			  )
VAR renamedCampaignCols = SELECTCOLUMNS( campaigns, "campaigns[whatever]", [whatever] )

var theTotal = SUMX(SELECTCOLUMNS( campaigns, "campaigns[whatever]", [whatever] ), [Whatever] )


var theTotal2 = SUMX(renamedCampaignCols, [Whatever])

RETURN
{theTotal2}			'You can use either theTotal, or theTotal2 here and it works in DAX Studio

============================================================================ refer to a field from a Virtual Table
Cashing Dealers = 
VAR DealersWithFundedLoans =
    SUMMARIZE (
        DimDealer,
        DimDealer[DealerCode],
        "zeroOne",
            COUNTROWS (
                CALCULATETABLE ( FactApplication, FactApplication[FundingStatus] = 202 )
            ) + 0)
VAR def = COUNTAX(FILTER(DealersWithFundedLoans,[zeroOne]&lt;&gt;0),[zeroOne])
RETURN 
def</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Time_Intelligence</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>FUNCTIONS_for_TimeIntelligence</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Time_Intelligence</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>FUNCTIONS_for_TimeIntelligence</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Performance-to-Date
====================
DATESYTD
DATESQTD
DATESMTD

Time Period Shift  aka Previous Period Pattern
==================     =======================
SAMEPERIODLASTYEAR
DATEADD
PARALLELPERIOD
PREVIOUSYEAR
	'Quarter/Month/Day
NEXTYEAR
	'Quarter/Month/Day

Running Total '(moving average os is the running total divided by the number of periods)
===================
DATESINPERIOD

#######################################################################################################################

DATEADD 'for previous periods
========
---------------------------------------------------------------------------------------------------------------------------
'EXAMPLE
	
	'example to calculate the MEASURE for a previous month
	CALCULATE(
				MEASURE, 
				DATEADD(
							CALENDAR[DATE]
							,-1,			' # of intervals
							MONTH			'Interval tpe: DAY, MONTH, QUARTER, YEAR
						)
			 )
			 
---------------------------------------------------------------------------------------------------------------------------		 
	Prev Month Revenue = CALCULATE(
									[Total Revenue]
									,DATEADD(
												AW_Calendar_Lookup[Date]
												,-1
												,MONTH
											)
								  )	
								  
---------------------------------------------------------------------------------------------------------------------------								  	 
DATESBETWEEN
=============	
		'equivalent in this example to MTD							  	 
		EVALUATE
		{
			CALCULATE(
				CALCULATE(
					[Sales Amount],
					DATESBETWEEN(
						'Calendar'[Date],
						STARTOFMONTH(LastDate('Calendar'[Date])), 
						LASTDATE('Calendar'[Date])
						)
					),
				'Calendar'[Date] = DATE(2008,4,12)
				)
		}								  	 
---------------------------------------------------------------------------------------------------------------------------
DATESINPERIOD	'Running Total
=============

---------------------------------------------------------------------------------------------------------------------------
'EXAMPLE
	CALCULATE(
				MEASURE
				, DATESINPERIOD(
									CALENDAR[DATE]
									, MAX[Calendar[DATE])								//'START parm for the DATESINPERIOD function
									,-10												//'NumberOfIntervals parm, use negative (-) for previous periods
									,DAY												//'Interval parm: DAY, MONTH, QUARTER, YEAR
							   )
			 )
---------------------------------------------------------------------------------------------------------------------------			 
10-day Rolling Revenue = CALCULATE(
									[Total Revenue]
									, DATESINPERIOD(
													AW_Calendar_Lookup[Date]
													, MAX(AW_Calendar_Lookup[Date])
													,-10
													,DAY)
									)			 
			 
---------------------------------------------------------------------------------------------------------------------------
'NOTE: Moving Averages
	'To calculate Moving Average, use the running total calculation above and divide by the number of intervals

DATESMTD 'Month to date
=======
		'-------------------------------------------------------------------------
		'-- DATESMTD: Returns a table that contains a column of the dates for the 
		'--			 month to date, in the current context.
		'--
		'--			 Note: Internally this function is re-written to use the
		'--			 	   DATESBETWEEN function.
		-------------------------------------------------------------------------
		
		EVALUATE
		{
			CALCULATE(
				CALCULATE(
					[Sales Amount],
					--COUNTROWS('Calendar'),
					DATESMTD('Calendar'[Date])
					),
				'Calendar'[Date] = DATE(2008,4,12)
				)
		}		
		
		EVALUATE
		{
			CALCULATE(
				CALCULATE(
					[Sales Amount],
					DATESBETWEEN(
						'Calendar'[Date],
						STARTOFMONTH(LastDate('Calendar'[Date])), 
						LASTDATE('Calendar'[Date])
						)
					),
				'Calendar'[Date] = DATE(2008,4,12)
				)
		}
		
		
DATESQTD 'quarter to date
========
		'-------------------------------------------------------------------------
		'-- DATESQTD: Returns a table that contains a column of the dates for the 
		'--			 quarter to date, in the current context.
		'--
		'--			 Note: Internally this function is re-written to use the
		'--			 	   DATESBETWEEN function.
		'-------------------------------------------------------------------------
		
		EVALUATE
		{
			CALCULATE(
				CALCULATE(
					[Sales Amount],
					//'--COUNTROWS('Calendar'),
					DATESQTD('Calendar'[Date])
					),
				'Calendar'[Date] = DATE(2008,6,12)
				)
		}		
		
		EVALUATE
		{
			CALCULATE(
				CALCULATE(
					[Sales Amount],
					DATESBETWEEN(
						'Calendar'[Date],
						STARTOFQUARTER(LastDate('Calendar'[Date])), 
						LASTDATE('Calendar'[Date])
						)
					),
				'Calendar'[Date] = DATE(2008,6,12)
				)
		}
		
DATESYTD 'year to date
========
'Returns a table that contains a column of the dates for the year to date, in the current context.

'SYNTAX
	DATESYTD(
				&lt;dates&gt; 
				[,&lt;year_end_date&gt;]
			)  
			
	dates	
	'	A column that contains dates.
	year_end_date	
	'	(optional) A literal string with a date that defines the year-end date. The default is December 31.			
	
Return value
'A table containing a single column of date values.	
---------------------------------------------------------------------------------------------------------------------------
'EXAMPLE
	
	CALCULATE(
				SUM(
						InternetSales_USD[SalesAmount_USD])			//&lt;&lt;== e.g. using SUM on a field
						, DATESYTD(DateTime[DateKey]
			  		)
			  ) 
---------------------------------------------------------------------------------------------------------------------------
	
	'for reference in the second statement, here is the MEASURE
	Total Revenue = SUMX(
							AW_Sales, AW_Sales[OrderQuantity] * RELATED(AW_Product_Lookup[ProductPrice])
						)			  
				  
	YTD Revenue = CALCULATE(
								[Total Revenue]							//&lt;== example without the SUM, b/c the SUM is in the MEASURE
								, DATESYTD(AW_Calendar_Lookup[Date])	//&lt;== this acts like the filter for the MEASURE
							)		
							
		'-------------------------------------------------------------------------
		'-- DATESYTD: Returns a table that contains a column of the dates for the 
		'--			 year to date, in the current context.
		'--
		'--			 Note: Internally this function is re-written to use the
		'--			 	   DATESBETWEEN function.
		'-------------------------------------------------------------------------
		
		EVALUATE
		{
			CALCULATE(
				CALCULATE(
					[Sales Amount],
					--COUNTROWS('Calendar'),
					DATESYTD('Calendar'[Date])
					),
				'Calendar'[Date] = DATE(2008,6,12)
				)
		}		
		
		EVALUATE
		{
			CALCULATE(
				CALCULATE(
					[Sales Amount],
					DATESBETWEEN(
						'Calendar'[Date],
						STARTOFYEAR(LastDate('Calendar'[Date])), 
						LASTDATE('Calendar'[Date])
						)
					),
				'Calendar'[Date] = DATE(2008,6,12)
				)
		}
											   
									   
---------------------------------------------------------------------------------------------------------------------------							
ENDOFMONTH
==========
		'------------------------------------------------------------------------------------
		'-- ENDOFMONTH: Finds the date in the current context of the dates table and
		'--			   returns the date of the first of the month of that date.
		'------------------------------------------------------------------------------------
		
		EVALUATE
		{
			CALCULATE(
				ENDOFMONTH('Calendar'[Date]),
				'Calendar'[Date] = DATE(2008,4,12)
				)
		}
---------------------------------------------------------------------------------------------------------------------------
ENDOFQUARTER
============

	'------------------------------------------------------------------------------------
	'-- ENDOFQUARTER: Finds the date in the current context of the dates table and
	'--			     returns the date of the last day of the quarter.
	'------------------------------------------------------------------------------------
	
	EVALUATE
	{
		CALCULATE(
			ENDOFQUARTER('Calendar'[Date]),
			'Calendar'[Date] = DATE(2008,4,12)
			)
	}
---------------------------------------------------------------------------------------------------------------------------
ENDOFYEAR
==============
'------------------------------------------------------------------------------------
'-- ENDOFYEAR: Finds the date in the current context of the dates table and
'--			  returns the date of the last day of the year.
'------------------------------------------------------------------------------------

EVALUATE
{
	CALCULATE(
		ENDOFYEAR('Calendar'[Date]),
		'Calendar'[Date] = DATE(2008,4,12)
		)
}
---------------------------------------------------------------------------------------------------------------------------
NEXTDAY
==============

'-- NEXTDAY: Returns a table that contains a column of all dates representing the 
'--          day that occurs after the current date in the dates column, given the 
'--          current context.
'--
'------------------------------------------------------------------------------------------------------

EVALUATE
{
	'-- Return the day previous to the date contained in the filter
	CALCULATE(
		NEXTDAY('Calendar'[Date]),
		'Calendar'[Date] = DATE(2008,4,12)
		)
}

EVALUATE
{
	'-- Calculate total sales in the Contols database occuring the day after the current context date
	CALCULATE(
		CALCULATE(
			[Sales Amount],
			NEXTDAY('Calendar'[Date])			
			),
		'Calendar'[Date] = DATE(2008,4,12)
		)
}

---------------------------------------------------------------------------------------------------------------------------
NEXTMONTH
==============
'-- NEXTMONTH: Returns a table that contains a column of all dates representing the 
'--            month that occurs after the current date in the dates column, given the 
'--            current context.
'------------------------------------------------------------------------------------------------------

EVALUATE
{
	-- Calculate total sales in the Contols database occuring in the month after the current context date
	CALCULATE(
		CALCULATE(
			[Sales Amount],
			NEXTMONTH('Calendar'[Date])			
			),
		'Calendar'[Date] = DATE(2008,4,12)
		)
}

---------------------------------------------------------------------------------------------------------------------------
NEXTQUARTER
==============
'------------------------------------------------------------------------------------------------------
'-- NEXTQUARTER: Returns a table that contains a column of all dates representing the 
'--            	quarter that occurs after the current date in the dates column, given the 
'--            	current context.
'------------------------------------------------------------------------------------------------------

EVALUATE
{
	-- Calculate total sales in the Contols database occuring in the month after the current context date
	CALCULATE(
		CALCULATE(
			[Sales Amount],
			NEXTQUARTER('Calendar'[Date])			
			),
		'Calendar'[Date] = DATE(2008,4,12)
		)
}
---------------------------------------------------------------------------------------------------------------------------
NEXTYEAR
==============
'------------------------------------------------------------------------------------------------------
'-- NEXTYEAR: Returns a table that contains a column of all dates representing the 
'--           year that occurs after the current date in the dates column, given the 
'--           current context.
'------------------------------------------------------------------------------------------------------

EVALUATE
{
	-- Calculate total sales in the Contols database occuring in the month after the current context date
	CALCULATE(
		CALCULATE(
			[Sales Amount],
			NEXTYEAR('Calendar'[Date])			
			),
		'Calendar'[Date] = DATE(2008,4,12)
		)
}

---------------------------------------------------------------------------------------------------------------------------
PARALLELPERIOD
==============
'Returns a table that contains a column of dates that represents a period parallel to the dates in the specified dates column, 
' in the current context, with the dates shifted a number of intervals either forward in time or back in time.

'PARALLELPERIOD computes the entire period in the interval (i.e. entire year, quarter, etc.)
'	Values in total rows may not reflect the expected total if partial periods are present =&gt; FUNKY totals

'The PARALLELPERIOD function is similar to the DATEADD function 
'	except that PARALLELPERIOD always returns full periods at the given granularity level instead of the partial periods that DATEADD returns. 
'For example, 
'	if you have a selection of dates that starts at June 10 and finishes at June 21 of the same year, 
'	and you want to shift that selection forward by one month then the PARALLELPERIOD function will return all dates from the next month 
'		(July 1 to July 31); 
'	however, 
'	if DATEADD is used instead, then the result will include only dates from 
'		July 10 to July 21.


'SYNTAX
PARALLELPERIOD(
				&lt;dates&gt;
				,&lt;number_of_intervals&gt;
				,&lt;interval&gt;
			  )  
			  

dates	
'A column that contains dates.
number_of_intervals	
'An integer that specifies the number of intervals to add to or subtract from the dates.
interval	
'The interval by which to shift the dates. The value for interval can be one of the following: year, quarter, month.			  
			  
'Example
--------
'The following sample formula creates a measure that calculates the previous year sales for Internet sales.
= CALCULATE(
			SUM(InternetSales_USD[SalesAmount_USD])
			, PARALLELPERIOD(
								DateTime[DateKey]
								,-1
								,year)
							)		
---------------------------------------------------------------------------------------------------------------------------								
PREVIOUSDAY								  
============

'------------------------------------------------------------------------------------------------------
'-- PREVIOUSDAY: Returns a table that contains a column of all dates representing the 
'--              day that is previous to the current date in the dates column, given the 
'--              current context.
'--
------------------------------------------------------------------------------------------------------

EVALUATE
{
	//' Return the day previous to the date contained in the filter
	CALCULATE(
		PREVIOUSDAY('Calendar'[Date]),				//'&lt;=== Returns a table with a single row and a single column, so OK to use as 1st parm of CALCULATE
		'Calendar'[Date] = DATE(2008,4,12)
		)
}								  
								  
EVALUATE		//' The outer CALCULATE sets the Date context, for the inner CALCULATE
{
	//' Calculate total sales in the Contols database occuring the day before the current context date
	CALCULATE(
		CALCULATE(
			[Sales Amount],
			PREVIOUSDAY('Calendar'[Date])			
			),
		'Calendar'[Date] = DATE(2008,4,12)
		)
}
---------------------------------------------------------------------------------------------------------------------------								
PREVIOUSDMONTH								  
============								  
		'------------------------------------------------------------------------------------------------------
		'-- PREVIOUSMONTH: Returns a table that contains a column of all dates representing the 
		'--                month that is previous to the current date in the dates column, given the 
		'--                current context.
		'--
		'------------------------------------------------------------------------------------------------------
		
		EVALUATE 
		{
			== ERROR
			//' It won't work b/c PREVIOUSMONTH returns a column with multiple values0
			CALCULATE(
				PREVIOUSMONTH('Calendar'[Date]),
				'Calendar'[Date] = DATE(2008,4,12)
				)
		}
		
		EVALUATE
		{
		//' Calculate total sales in the Contols database occuring in the month prior to the current context date
			CALCULATE(
				CALCULATE(
					''COUNTROWS('Calendar'),  //'&lt;== if you use this you would see it is return 30 days of the month
					[Sales Amount],			  //' the measure would aggregate all the rows 
					PREVIOUSMONTH('Calendar'[Date])			
					),
				'Calendar'[Date] = DATE(2008,4,12)
				)
		}	
---------------------------------------------------------------------------------------------------------------------------								
PREVIOUSQUARTER								  
============			
		'------------------------------------------------------------------------------------------------------
		'-- PREVIOUSQUARTER: Returns a table that contains a column of all dates representing the 
		'--                  quarter that is previous to the current date in the dates column, given the 
		'--                  current context.
		'--
		'------------------------------------------------------------------------------------------------------
		
		EVALUATE
		{
			-- Calculate total sales in the Contols database occuring in the month prior to the current context date
			CALCULATE(
				CALCULATE(
					--COUNTROWS('Calendar'),
					[Sales Amount],
					PREVIOUSQUARTER('Calendar'[Date])			
					),
				'Calendar'[Date] = DATE(2008,4,12)
				)
		}									  
---------------------------------------------------------------------------------------------------------------------------								
PREVIOUSYEAR								  
============									  
		'------------------------------------------------------------------------------------------------------
		'-- PREVIOUSYEAR: Returns a table that contains a column of all dates representing the 
		'--               year that is previous to the current date in the dates column, given the 
		'--               current context.
		'--
		'------------------------------------------------------------------------------------------------------
		
		EVALUATE
		{
			-- Calculate total sales in the Contols database occuring in the month prior to the current context date
			CALCULATE(
				CALCULATE(
					[Sales Amount],
					PREVIOUSYEAR('Calendar'[Date])			
					),
				'Calendar'[Date] = DATE(2007,4,12)
				)
		}
									  



---------------------------------------------------------------------------------------------------------------------------				  
STARTOFMONTH
============			  
		'------------------------------------------------------------------------------------
		'-- STARTOFMONTH: Finds the date in the current context of the dates table and
		'--				 returns the date of the first of the month of that date.
		'------------------------------------------------------------------------------------
		
		EVALUATE
		{
			CALCULATE(
				STARTOFMONTH('Calendar'[Date]),
				'Calendar'[Date] = DATE(2008,4,12)
				)
		}		  
							)			  
---------------------------------------------------------------------------------------------------------------------------				  
STARTOFQUARTER	
==============		  
		'------------------------------------------------------------------------------------
		'-- STARTOFQUARTER: Finds the date in the current context of the dates table and
		'--				   returns the date of the first day of the quarter.
		'------------------------------------------------------------------------------------
		
		EVALUATE
		{
			CALCULATE(
				STARTOFQUARTER('Calendar'[Date]),
				'Calendar'[Date] = DATE(2008,4,12)
				)
		}
---------------------------------------------------------------------------------------------------------------------------
STARTOFYEAR
==============					  
'------------------------------------------------------------------------------------
'-- STARTOFYEAR: Finds the date in the current context of the dates table and
'--				returns the date of the first day of the year.
'------------------------------------------------------------------------------------

EVALUATE
{
	CALCULATE(
		STARTOFYEAR('Calendar'[Date]),
		'Calendar'[Date] = DATE(2008,4,12)
		)
}			  
			  
---------------------------------------------------------------------------------------------------------------------------			  
TOTALMTD			  
==============			  
			  -------------------------------------------------------------------------
				-- TOTALMTD: Evaluates the value of the expression for the month to date, 
				--   		 in the current context.
				--
				-- 			 Note: Internally TOTALMTD is re-written to use DATESMTD.
				-------------------------------------------------------------------------
				
				EVALUATE
				{
					CALCULATE(
						TOTALMTD(
							[Sales Amount],
							'Calendar'[Date]
							),
					'Calendar'[Date] = DATE(2008,4,12)
					)
				}
				
				EVALUATE
				{
					CALCULATE(
						CALCULATE(
							[Sales Amount],
							DATESMTD('Calendar'[Date])
							),
					'Calendar'[Date] = DATE(2008,4,12)
					)
				}
---------------------------------------------------------------------------------------------------------------------------			  
TOTALQTD			  
==============
			'----------------------------------------------------------------------------
			'-- TOTALQTD: Evaluates the value of the expression for the quarter to date, 
			'--   		 in the current context.
			'--
			'-- 			 Note: Internally TOTALQTD is re-written to use DATESQTD.
			'----------------------------------------------------------------------------
			
			EVALUATE
			{
				CALCULATE(
					TOTALQTD(
						[Sales Amount],
						'Calendar'[Date]
						),
				'Calendar'[Date] = DATE(2008,6,12)
				)
			}
			
			EVALUATE
			{
				CALCULATE(
					CALCULATE(
						[Sales Amount],
						DATESQTD('Calendar'[Date])
						),
				'Calendar'[Date] = DATE(2008,6,12)
				)
			}
---------------------------------------------------------------------------------------------------------------------------			  
TOTALQTD			  
==============			
		'----------------------------------------------------------------------------
		'-- TOTALYTD: Evaluates the value of the expression for the quarter to date, 
		'--   		 in the current context.
		'--
		'-- 			 Note: Internally TOTALYTD is re-written to use DATESYTD.
		'----------------------------------------------------------------------------
		
		EVALUATE
		{
			CALCULATE(
				TOTALYTD(
					[Sales Amount],
					'Calendar'[Date]
					),
			'Calendar'[Date] = DATE(2008,6,12)
			)
		}
		
		EVALUATE
		{
			CALCULATE(
				CALCULATE(
					[Sales Amount],
					DATESYTD('Calendar'[Date])
					),
			'Calendar'[Date] = DATE(2008,6,12)
			)
		}



















			  
			  
			  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_Dates</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>01__01_DateTable_function</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_Dates</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>01__01_DateTable_function</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>01__01_DateTable_function


'Name this function: fn_createDateTable, do it in Query Editor (new blank query)
==============================Advanced Editor====================
(StartDate as date, EndDate as date)=&gt;

let
    //Capture the date range from the parameters
    StartDate = #date(Date.Year(StartDate), Date.Month(StartDate), 
    Date.Day(StartDate)),
    EndDate = #date(Date.Year(EndDate), Date.Month(EndDate), 
    Date.Day(EndDate)),

    //Get the number of dates that will be required for the table
    GetDateCount = Duration.Days(EndDate - StartDate),

    //Take the count of dates and turn it into a list of dates
    GetDateList = List.Dates(StartDate, GetDateCount, 
    #duration(1,0,0,0)),

    //Convert the list into a table
    DateListToTable = Table.FromList(GetDateList, 
    Splitter.SplitByNothing(), {"Date"}, null, ExtraValues.Error),

    //Create various date attributes from the date column
    //Add Year Column
    YearNumber = Table.AddColumn(DateListToTable, "Year", 
    each Date.Year([Date])),

    //Add Quarter Column
    QuarterNumber = Table.AddColumn(YearNumber , "Quarter", 
    each "Q" &amp; Number.ToText(Date.QuarterOfYear([Date]))),

    //Add Week Number Column
    WeekNumber= Table.AddColumn(QuarterNumber , "Week of Year Number", 
    each Date.WeekOfYear([Date])),

    //Add Month Number Column
    MonthNumber = Table.AddColumn(WeekNumber, "Month Number", 
    each Date.Month([Date])),

    //Add Month Name Column
    MonthName = Table.AddColumn(MonthNumber , "Month", 
    each Date.ToText([Date],"MMMM")),

    //Add Day of Week Column
    DayOfWeek = Table.AddColumn(MonthName , "Day of Week", 
    each Date.ToText([Date],"dddd"))

in
    DayOfWeek
    
 ============================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_Dates</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>DATE_Table_1_record_every14days_using_LIST_functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_Dates</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>DATE_Table_1_record_every14days_using_LIST_functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
		
'FINAL CODE
========================================================================================		
		
let
    referencedate = Number.From(#"Reference Date"),
    startdate = Number.From(Date.StartOfYear(#"Reference Date")),
    enddate = Number.From(Date.EndOfYear(#"Reference Date")),
    list1 = List.Generate(()=&gt;referencedate, each _ &lt;=enddate, each _+14),
    list2 = List.Generate(()=&gt;startdate, each _ &lt;referencedate, each _-14),
    dates = List.Combine({list2,list1}),
    #"Converted to Table" = Table.FromList(dates, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
    #"Changed Type" = Table.TransformColumntypes(#"Converted to Table",{{"Column1", type date}}),
    #"Renamed Columns" = Table.RenameColumns(#"Changed Type",{{"Column1", "Dates"}})
in
    #"Renamed Columns"
======================================================================================== 


'This M-Code produces a date List for every day from start to end of the present year
'=====================================================================================
let
    startdate = Number.From(Date.StartOfYear(DateTime.Date(DateTime.FixedLocalNow()))),
    enddate = Number.From(Date.EndOfYear(DateTime.Date(DateTime.FixedLocalNow()))),
    Source = {startdate..enddate},
    #"Converted to Table" = Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
    #"Changed Type" = Table.TransformColumntypes(#"Converted to Table",{{"Column1", type date}}),
    #"Renamed Columns" = Table.RenameColumns(#"Changed Type",{{"Column1", "Dates"}})
in
    #"Renamed Columns"

' BUT we want a List of dates, every 14 days, on Fridays, for the year
'============================================================

1] 'Create a reference day from a Blank Query, this is a Friday
	'Turn a string value into a DATE value using the Date.From function
	= Date.From("8/23/2019")

2] 'Then start the second query w/ a List.Generate Function
	' start with zero, increase each value in the list by increments of 2
	' until we reach 10, then the loop stops
	' the underscore serves as a 'variable' in conjunction with'each' for the LIST function

	= List.Generate(()=&gt;0, each _ &lt;=10, each _+2)
	
	'OUTPUT
	------------
		0
		2
		4
		6
		8
		10
		
	'Then convert to a table: Transform {menu} =&gt; [To Table]	
	= Table.FromList(Source, Splitter.SplitByNothing(), null, null, ExtraValues.Error)	
		
	'Then change datatype to DATE: in the header of the column
	= Table.TransformColumnTypes(#"Converted to Table",{{"Column1", type date}})
	
	'This is proof-of-concept that we can go from a list of numbers to a DATES table
		
3] 'Remove the last two steps from the query back to this:		
	= List.Generate(()=&gt;0, each _ &lt;=10, each _+2)	
		
	' and go into the advanced editor:
	
		let
		    Source = List.Generate(()=&gt;0, each _ &lt;=10, each _+2)
		in
		    Source		
			
4] 'Add the Parms, and test to look at the 'enddate'

		let
		    referencedate = Number.From(#"Reference Date"),
		    startdate = Number.From(Date.StartOfYear(#"Reference Date")),
		    enddate = Number.From(Date.EndOfYear(#"Reference Date"))
		    Source = List.Generate(()=&gt;0, each _ &lt;=10, each _+2)
		in
		    enddate
		
	'OUTPUT
	========
	43830	
		
5] 'Modify the 'source' using reference date,enddate, and jumping 14 days at atime:
		let
		    referencedate = Number.From(#"Reference Date"),
		    startdate = Number.From(Date.StartOfYear(#"Reference Date")),
		    enddate = Number.From(Date.EndOfYear(#"Reference Date")),
			Source = List.Generate(()=&gt;referencedate, each _ &lt;=enddate, each _+14)
		in
		    Source		
		
	'OUTPUT
	========
		43700
		43714
		43728
		43742
		43756
		43770
		43784
		43798
		43812
		43826			
				
6] 'MODIFY the M-Code: create 2 lists, one counting up, the other counting down.
	' exclude the reference date (i.e. remove "=") from list2, so that it is not duplicated
	'NOTE: put the pair of lists within brackets (i.e. list characters}
	'Put list2 before list1 to get them in the right order
	
		let
			referencedate = Number.From(#"Reference Date"),
			startdate = Number.From(Date.StartOfYear(#"Reference Date")),
			enddate = Number.From(Date.EndOfYear(#"Reference Date")),
			list1 = List.Generate(()=&gt;referencedate, each _ &lt;=enddate, each _+14),
			list2 = List.Generate(()=&gt;startdate, each _ &lt;referencedate, each _-14),
			dates = List.Combine({list2,list1})
			
		in
			dates
			
	'OUTPUT is whole numbers
	=========
		43700
		43714
		43728
		43742
		...
		29648
		29634
		29620		
		
7] 'Convert Whole numbers to DATEs		
	Transform {menu} =&gt; [To Table]
	{and convert to DATE type}
		
	'OUTPUT
	=======
	1/1/2019
	12/18/2018
	12/4/2018
	11/20/2018
	11/6/2018
	10/23/2018
	10/9/2018
	...
	12/23/1980
	12/9/1980
	11/25/1980
	11/11/1980
	10/28/1980
	10/14/1980
	9/30/1980
	9/16/1980			
		
   </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_Dates</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>DateTable_DevinKnight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_Dates</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>DateTable_DevinKnight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://devinknightsql.com/2015/06/16/creating-a-date-dimension-with-power-query/


'This query is actually a function that accepts parameters so you will see that it’s waiting for you to invoke it with values.

a) Get Data =&gt; Blank Query =&gt; Replace everything in the Advanced Editor with this code

'This creates a 'Function' in the Query pane of the Query Editor, rename it: orig_Fn_createDateTable

b) ' Double click the function, when it opens populate the StartDate, and EndDate =&gt; click [Invoke]

c) ' it crates a new table in the Query Pane =&gt; rename it "theDateTable"
	' Modify the data types of each column (right click and choose the column header)
	
d) 'Close and Apply the Query editor windowm, and you will see the "theDataTable" table in the list of tables

e) 'Then set up the relationships in the Relationship view
===Advanced Editor===========================================================================================

//Create Date Dimension
= (StartDate as date, EndDate as date)=&gt;

let
    //Capture the date range from the parameters
    StartDate = #date(Date.Year(StartDate), Date.Month(StartDate), 
    Date.Day(StartDate)),
    EndDate = #date(Date.Year(EndDate), Date.Month(EndDate), 
    Date.Day(EndDate)),

    //Get the number of dates that will be required for the table
    GetDateCount = Duration.Days(EndDate - StartDate),

    //Take the count of dates and turn it into a list of dates
    GetDateList = List.Dates(StartDate, GetDateCount, 
    #duration(1,0,0,0)),

    //Convert the list into a table
    DateListToTable = Table.FromList(GetDateList, 
    Splitter.SplitByNothing(), {"Date"}, null, ExtraValues.Error),

    //Create various date attributes from the date column
    //Add Year Column
    YearNumber = Table.AddColumn(DateListToTable, "Year", 
    each Date.Year([Date])),

    //Add Quarter Column
    QuarterNumber = Table.AddColumn(YearNumber , "Quarter", 
    each "Q" &amp; Number.ToText(Date.QuarterOfYear([Date]))),

    //Add Week Number Column
    WeekNumber= Table.AddColumn(QuarterNumber , "Week of Year Number", 
    each Date.WeekOfYear([Date])),

    //Add Month Number Column
    MonthNumber = Table.AddColumn(WeekNumber, "Month Number", 
    each Date.Month([Date])),

    //Add Month Name Column
    MonthName = Table.AddColumn(MonthNumber , "Month", 
    each Date.ToText([Date],"MMMM")),

    //Add Day of Week Column
    DayOfWeek = Table.AddColumn(MonthName , "Day of Week", 
    each Date.ToText([Date],"dddd"))

in
    DayOfWeek

================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_PowerQuery</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LIST_functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_PowerQuery</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LIST_functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

LIST.Count
LIST.Min
LIST.Max
LIST.Sum
LIST.Average

CREATE LISTS
---------------
LIST.Dates
LIST.Numbers
LIST.Random

Converting to Lists
-------------------
Binary.ToList
Table.ToList
Text.ToList

List.Generate - creates a new list using loop logic
List.Sort 	  - puts a list in numerical order
List.Combine  - creates a new list from two or more lists</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>M_PowerQuery</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LIST_object</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>M_PowerQuery</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LIST_object</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>List Object = ordered sequence of values 
M language classifies lists, records and tables as structured values
List objects use Curly braces


To create a simple List
=================================================================================
Home =&gt; Get Data =&gt; Blank Query

		= {2,5,"a","c"}
		
		
To create a list from 1 to 365
-------------------------
Home =&gt; Get Data =&gt; Blank Query
		
		= {1..365}
		= {1,3,5..365}	&lt;== This creates a list from 1 to 365, but with just odd numbers 		
		
To create a list of single characters
-------------------------
Home =&gt; Get Data =&gt; Blank Query		
				
		= Text.ToList("hello world")
		
To create a list of dates from today to 10 days from now
-------------------------
Home =&gt; Get Data =&gt; Blank Query			
		'List.Dates(start,count,steps)
		= List.Dates(DateTime.Date(DateTime.FixedLocalNow()),10,#duration(1,0,0,0))
		
'DateTime.Date = gets the DATE for Now()
'Duration Function, for 1 day: #duration(1,0,0,0)
'		#duration(days as number, hours as number, minutes as number, seconds as number) as duration


To create a LIST object by referencing a column in a table
============================================================
1] via a Table name
   ---------------------------------------------------------------
   to get a list from query:
   create a blank query and reference the
   	a) query name:
   		"Population by Zip Code"
   	b) the column name in the query:
   		[Zip Code]
   		
   	Like this:
   = #"Population by Zip Code"[Zip Code]

2] via a query step name {using a Short cut to get the M-code}
   ---------------------------------------------------------------
	- Starting from an existing query 
	=&gt; select a column (e.g. ZipCode column where the last step of query is named "Changed Type") 
	=&gt; {right-click} =&gt; {select from right click menu:} Drill Down 
	=&gt; {it opens a new step in the query, and in the address bar we see: "= #"Changed type"[Zip Code]"}
		{note this is the previous step of the query, and the name of the column}
	{NOTE: that code is a quick short cut to the 'list' by referencing the 'step' and the 'column'}
	
	
	SO, if you create a blank query, and then put in this M-code, you get a LIST object 
		= #"Changed Type"[Zip Code]
		</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Map_Drives</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>from_BCC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Map_Drives</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>from_BCC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'********************************************************************************
'This login scripts will do the following items for non-People Trak Users
'	Map all user drives based on group user belongs to
'	write a record to a database to track PC make and Models
'	Write a record to a database to track user logon times
'	Set the local time on the user PC to match the server
'********************************************************************************

strComputer="."
on error resume next


'****************
'   Variables
'****************

Dim WSHNetwork
Dim wshShell
Dim wshSysEnv
Dim nReturnCode
Dim FSO
Dim strUsername
Dim strUseName
Dim strUserDomain
Dim objGroupDict

'*********************************************************
'	DRIVE MAPPING SECTION OF SCRIPT
'*********************************************************

Set WSHNetwork = WScript.CreateObject("WScript.Network")
Set FSO = CreateObject("Scripting.FileSystemObject")

'**** Wait Until User is Logged In ****

strUserName = ""
While strUserName = ""
WScript.Sleep 1000 ' 1 second
strUserName = WSHNetwork.UserName
Wend
strUserDomain = WSHNetwork.UserDomain

'**** Insert the user's account "Member Of" tab info ****


Set ObjGroupDict = CreateMemberOfObject(strUserDomain, strUserName)

'****Remove drive letters first****

	WshNetwork.RemoveNetworkDrive "G:", True, false
	WshNetwork.RemoveNetworkDrive "H:", True, false
	WshNetwork.RemoveNetworkDrive "J:", True, false
	WshNetwork.RemoveNetworkDrive "K:", True, false
	WshNetwork.RemoveNetworkDrive "Q:", True, false
	WshNetwork.RemoveNetworkDrive "S:", True, false
	WshNetwork.RemoveNetworkDrive "T:", True, false
	WshNetwork.RemoveNetworkDrive "U:", True, false
	WshNetwork.RemoveNetworkDrive "V:", True, false
	WshNetwork.RemoveNetworkDrive "W:", True, false
	WshNetwork.RemoveNetworkDrive "X:", True, false
	WshNetwork.RemoveNetworkDrive "Y:", True, false
	WshNetwork.RemoveNetworkDrive "Z:", True, false

'****Map Drive based on Group Membership****

'*********** Boutte **********

If MemberOf(ObjGroupDict, "BoutteLA") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "BoutteLA") Then
WSHNetwork.MapNetworkDrive "t:", "\\bcc-bouttedcfs\Boutteshare"
End If

If MemberOf(ObjGroupDict, "BoutteLA") Then
WSHNetwork.MapNetworkDrive "u:", "\\bcc-bouttedcfs\Users\" &amp; WSHNetwork.UserName
End If

'*********** Concrete Paving **********

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** Executive **********

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "j:", "\\bcc-explorer2\XPLRF"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "k:", "\\bcc-explorer2\XPLR"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** HR **********

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "H:", "\\bcc-explorer2\xplrf\barriere\images"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "J:", "\\bcc-explorer2\xplr"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "K:", "\\bcc-explorer2\XPLRF"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If


'*********** Gravel Pit **********

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If


'*********** Interns**********

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "y:", "\\bcc-bouttedcfs\BoutteShare"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "z:", "\\bcc-nshore\1A_Northshore"
End If

'*********** New Orleans **********

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** North Shore **********

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "s:", "\\bcc-nshore\1A_Northshore"
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "u:", "\\bcc-nshore\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "z:", "\\ts-frank2\share\archive"
End If

'*********** South Shore **********

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** All Common **********

WSHNetwork.MapNetworkDrive "g:", "\\BCC-CONTROL\PeopleTrak"
WSHNetwork.MapNetworkDrive "q:", "\\bcc-hcss\HCSS"
WSHNetwork.MapNetworkDrive "w:", "\\BCC-FS1\Public"
WSHNetwork.MapNetworkDrive "x:", "\\bcc-explorer2\CLI"
'==========================================================CUSTOM MAPPINGS
WSHNetwork.MapNetworkDrive "y:", "\\bcc-explorer\d$"
WSHNetwork.MapNetworkDrive "z:", "\\bcc-explorer3\d$"

'==========================================================

'**** Group Membership Function Subroutines ****

Function MemberOf(ObjDict, strKey)

MemberOf = CBool(ObjGroupDict.Exists(strKey))

End Function


Function CreateMemberOfObject(strDomain, strUserName)

Dim objUser, objGroup

Set CreateMemberOfObject = CreateObject("Scripting.Dictionary")
CreateMemberOfObject.CompareMode = vbTextCompare
Set objUser = GetObject("WinNT://" _
&amp; strDomain &amp; "/" _
&amp; strUserName &amp; ",user")
For Each objGroup In objUser.Groups
CreateMemberOfObject.Add objGroup.Name, "-"
Next
Set objUser = Nothing

End Function

'*****************************************************
'	END OF DRIVE MAPPING SECTION
'*****************************************************


'*****************************************************
'	SECTION TO SET LOCAL COMPUTER TIME
'*****************************************************
strComputer="."
Set WshNetwork = WScript.CreateObject("WScript.Network")
Set wshShell = WScript.CreateObject("Wscript.Shell")
Set wshSysEnv = wshShell.Environment("SYSTEM")
If (wshSysEnv("OS") = "Windows_NT") Then
    nReturnCode = wshShell.Run("net time /domain:" &amp; wshNetwork.UserDomain &amp; " /set /yes", 0, TRUE)
    Else
	WScript.Echo "This Logon Script Supports only Windows 2000 or Windows XP" &amp; vbNewLine &amp; "Exiting..."
    Set wshNetwork = Nothing
    Set wshShell = Nothing
    WScript.Quit(1)
End If

'*****************************************************
result=Msgbox("Good To Go!",vbYesNo+vbInformation, "")
'*****************************************************


Set wshNetwork = Nothing
Set wshShell = Nothing
WScript.Quit(nReturnCode)

'*****************************************************
'	END OF SETTING LOCAL TIME
'*****************************************************













</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>NETSH</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PSEXEC_Sysinternals_NETSH_for_multipleComputers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>NETSH</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PSEXEC_Sysinternals_NETSH_for_multipleComputers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.serverwatch.com/server-tutorials/using-netsh-to-manage-remote-servers-and-workstations.html

#'Netsh lacks an easy way to simultaneously manage multiple remote machines. 
#'Though you could get creative with the built-in remote functionality, 
#'    like incorporating multiple remote addresses in batch files and other scripts, 
#'    you might have better luck pursuing other options.
#'
#'For instance, 
#'    utilizing the PsExec utility from Windows Sysinternals allows you to push out Netsh (or any other commands) 
#'    to multiple machines at once.
#'
#'Once you download PsExec, 
#'    open a Command Prompt to the folder containing it and try the following command to access the CLI of a remote machine:
#'
#'psexec \\hostname -u domain\admin -p password cmd
#'
#'If the remote machine is Windows Vista or higher, 
#'    you may need to use the -h option to have the process run with the account's elevated token.
#'
#'Once you've established that you can gain remote access, 
#'    you can also run netsh commands directly, for instance:
#'
psexec \\hostname -u domain\admin -p password cmd.exe /c netsh.exe interface ip show config
#'
#'If an interactive CLI isn't needed — 
#'    for example, if you're running a command that doesn't provide output — 
#'        consider adding the psexec -d option. 
#'        This option tells it not to wait for the process to terminate. 
#'    On the other hand, 
#'        if you'd like the program to be interactive on the desktop of the remote machine, 
#'        consider the -i option.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>NETSH</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Remote</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>NETSH</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Remote</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.serverwatch.com/server-tutorials/using-netsh-to-manage-remote-servers-and-workstations.html
-------------------------------------------------------------------
#'If you run into connectivity issues with remote machines, 
#'    ensure the Remote Registry service is running on the remote computer. 
#'If it is not, then Windows may display a "Network Path Not Found" error message. 
#'    Additionally, verify File and Printer Sharing for Microsoft Networks is enabled in the network connection properties of the remote machine. 
#'As always, ensure there aren't any firewalls blocking the traffic.
#'
#'If connectivity issues persist, try the following Registry edit:
#'
#'Open RegEdit on the remote machine and navigate to
#'
 
#'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System
#'Add a new DWORD value called 

    "LocalAccountTokenFilterPolicy," 
#'if it doesn't already exist, and ensure its value is set to 
    "1"
#'Reboot the remote machine.
-------------------------------------------------------------------


'Open a Command Prompt and enter the following command 
'to access the Netsh CLI on a remote machine:

netsh -r hostname -u domain\admin -p password

'Once you've established that you can gain remote access, 
'you can also run netsh commands directly. For instance, here's how to obtain the IP configuration:

netsh -r hostname -u domain\admin -p password interface ip show config

'For the -r option, you can also use the IP address or FQDN 
' in addition to the host name of remote machines.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Add_User_to_AD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Add_User_to_AD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>param($FirstName,$MiddleInitial,$LastName,$Location = 'OU=Corporate Users',$Title)

## Not the best use of storing the password clear text
## Google on using stored secure strings on the file system as a way to get around this
$DefaultPassword = 'p@$$w0rd12'
$DomainDn = (Get-AdDomain).DistinguishedName
$DefaultGroup = 'Gigantic Corporation Inter-Intra Synergy Group'

$Username = "$($FirstName.SubString(0,1))$LastName"
## Check if an existing user already has the first intial/last name username taken
try    {
        if (Get-ADUser $Username) {
                                    ## If so, check to see if the first initial/middle initial/last name is taken.
                                    $Username = "$($FirstName.SubString(0,1))$MiddleInitial$LastName"
                                    if (Get-AdUser $Username) {
                                                                    Write-Warning "No acceptable username schema could be created"
                                                                    return
                                                                }
                                    }
        } 
catch   {

        }

#'Hash Table with all the parms I will need for the New-AdUser method
$NewUserParams = @{
    'UserPrincipalName' = $Username
    'Name' = $Username
    'GivenName' = $FirstName
    'Surname' = $LastName
    'Title' = $Title
    'SamAccountName' = $Username
    'AccountPassword' = (ConvertTo-SecureString $DefaultPassword -AsPlainText -Force)
    'Enabled' = $true
    'Initials' = $MiddleInitial
    'Path' = "$Location,$DomainDn"       #'&lt;=== Creates a fully distinguished name
    'ChangePasswordAtLogon' = $true
}

New-AdUser @NewUserParams                #'&lt;==== Pass a whole hash table of parms to the method
Add-ADGroupMember -Identity $DefaultGroup -Members $Username</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>All_Groups_and_All_Members</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>All_Groups_and_All_Members</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://serverfault.com/questions/532945/list-all-groups-and-their-members-with-powershell-on-win2008r2


'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
'#LIST_AD_Groups_and_Members.ps1
Import-Module ActiveDirectory

$Groups = (Get-AdGroup -filter * | Where {$_.name -like "**"} | select name -ExpandProperty name)

$Table = @()

$Record = @{
  "Group Name" = ""
  "Name" = ""
  "Username" = ""
}


Foreach ($Group in $Groups) {

  $Arrayofmembers = Get-ADGroupMember -identity $Group -recursive | select name,samaccountname

  foreach ($Member in $Arrayofmembers) {
    $Record."Group Name" = $Group
    $Record."Name" = $Member.name
    $Record."UserName" = $Member.samaccountname
    $objRecord = New-Object PSObject -property $Record
    $Table += $objrecord

  }
}

$Table | export-csv "C:\temp\SecurityGroups.csv" -NoTypeInformation

'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

$Groups = Get-ADGroup -Properties * -Filter * -SearchBase "OU=Groups,DC=corp,DC=ourcompany,DC=Com" 
Foreach($G In $Groups)
{
    Write-Host $G.Name
    Write-Host "-------------"
    $G.Members
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Cmdlets for Managing Active Directory</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Cmdlets for Managing Active Directory</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'Get info about the domain:
&gt; Get-ADDomain

'Get info about a user
Get-ADUser ajones

'filter domain for a user 
&gt; Get-ADUser –Filter {Surname –eq “Hess”}
&gt; Get-ADUser –Filter {GivenName –eq “Ken”}


'Get Membership in groups:
Get-ADPrincipalGroupMembership –Identity khess


'GEt list of disabled User accounts
&gt; Search-ADAccount –AccountDisabled –UserOnly |FT Name</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CONSTANTS_used_in_AD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CONSTANTS_used_in_AD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Here is a list of the Constants used in VBScript, WSH, Windows, and Active Directory\ADSI.
http://www.kouti.com/samplescripts/AllConstants.vbs.txt

The script example below provides how constants are used in PowerShell.
-------------------------------------------------------------------------
Set-Variable -name ADS_UF_ACCOUNTDISABLE -value 2 -option constant
$objUser = [ADSI]“LDAP://CN=FirstName LastName,OU=TestOUUsers,OU=TestOU,DC=MyDomain,DC=msft”
$objUser.put(“userAccountControl”,$ADS_UF_ACCOUNTDISABLE)

$objUser.setInfo()

---------------------------------------------------------------------

In the file, when you see a value given as &amp;H…. it means hexadecimal.
' -------------------------------------------------------------------------
'       Related to the book Inside Active Directory, ISBN 0-201-61621-1
'       Copyright (C) 2002 by Sakari Kouti
'       Version: November 16, 2001
'       (see http://www.kouti.com)
' You have a royalty-free right to use, modify, reproduce and distribute
' this script (and/or any modified version) in any way you find useful,
' provided that you agree that Addison-Wesley or Sakari Kouti has no
' warranty, obligations or liability for the script. If you modify
' the script, you must retain this copyright notice.
' -------------------------------------------------------------------------

' ===============================================================
' See CH10-10 IncludeExample.wsf for an example of how to include
' this file in your script.
' ===============================================================

' This file includes all the constant defitions that are used in the
' script samples of the Inside Active Directory book, as well as some
' other constant defitions. The constants represent the following
' categories:
' - VBScript
' - WSH
' - Windows
' - Active Directory/ADSI

' ---------------------------------------------------------------
' Category: VBScript
' ---------------------------------------------------------------

'Error codes
Const E_VBS_OBJECT_REQUIRED = 424
'For more error codes, see VBScript help

'OpenTextFile method options
Const ForReading = 1

' ---------------------------------------------------------------
' Category: WSH
' ---------------------------------------------------------------

'WshShell Run method options
Const WAIT_ON_RETURN = True
Const HIDE_WINDOW = 0
'For more options, see WSH help

' ---------------------------------------------------------------
' Category: Windows
' ---------------------------------------------------------------

'NTFS ACE options

'NTFS ACE options: AccessMask
Const FILE_READ_DATA            = &amp;H1     'file &amp; pipe
Const FILE_LIST_DIRECTORY       = &amp;H1     'folder
Const FILE_WRITE_DATA           = &amp;H2     'file &amp; pipe
Const FILE_ADD_FILE             = &amp;H2     'folder
Const FILE_APPEND_DATA          = &amp;H4     'file
Const FILE_ADD_SUBDIRECTORY     = &amp;H4     'folder
Const FILE_CREATE_PIPE_INSTANCE = &amp;H4     'named pipe
Const FILE_READ_EA              = &amp;H8     'file &amp; folder
Const FILE_WRITE_EA             = &amp;H10    'file &amp; folder
Const FILE_EXECUTE              = &amp;H20    'file
Const FILE_TRAVERSE             = &amp;H20    'folder
Const FILE_DELETE_CHILD         = &amp;H40    'folder
Const FILE_READ_ATTRIBUTES      = &amp;H80    'all
Const FILE_WRITE_ATTRIBUTES     = &amp;H100   'all
Const DELETE                    = &amp;H10000
Const READ_CONTROL              = &amp;H20000
Const WRITE_DAC                 = &amp;H40000
Const WRITE_OWNER               = &amp;H80000
Const SYNCHRONIZE               = &amp;H100000
Const ACCESS_SYSTEM_SECURITY    = &amp;H1000000
Const GENERIC_ALL               = &amp;H10000000
Const GENERIC_EXECUTE           = &amp;H20000000
Const GENERIC_WRITE             = &amp;H40000000
Const GENERIC_READ              = &amp;H80000000

Const FULL_CONTROL              = &amp;H1F01FF  '14 permissions
Const MODIFY                    = &amp;H1301BF  '11 permissions

'NTFS ACE options: ACE flags
Const OBJECT_INHERIT_ACE                = &amp;H1
Const CONTAINER_INHERIT_ACE             = &amp;H2
Const NO_PROPAGATE_INHERIT_ACE          = &amp;H4
Const INHERIT_ONLY_ACE                  = &amp;H8
Const INHERITED_ACE                     = &amp;H10
Const SUCCESSFUL_ACCESS_ACE_FLAG        = &amp;H40
Const FAILED_ACCESS_ACE_FLAG            = &amp;H80

'NTFS ACE options: ACE types
Const ACCESS_ALLOWED_ACE_TYPE           = &amp;H0
Const ACCESS_DENIED_ACE_TYPE            = &amp;H1
Const SYSTEM_AUDIT_ACE_TYPE             = &amp;H2
Const SYSTEM_ALARM_ACE_TYPE             = &amp;H3
Const ACCESS_ALLOWED_COMPOUND_ACE_TYPE  = &amp;H4
Const ACCESS_ALLOWED_OBJECT_ACE_TYPE    = &amp;H5
Const ACCESS_DENIED_OBJECT_ACE_TYPE     = &amp;H6
Const SYSTEM_AUDIT_OBJECT_ACE_TYPE      = &amp;H7
Const SYSTEM_ALARM_OBJECT_ACE_TYPE      = &amp;H8

'NTFS ACE options: Flags
Const ADS_OBJECT_TYPE_PRESENT           = &amp;H1
Const ADS_INHERITED_OBJECT_TYPE_PRESENT = &amp;H2

' ---------------------------------------------------------------
' Category: Active Directory/ADSI
' ---------------------------------------------------------------

'Security descriptor control flags
Const ADS_SD_CONTROL_SE_OWNER_DEFAULTED       = &amp;H0001
Const ADS_SD_CONTROL_SE_GROUP_DEFAULTED       = &amp;H0002
Const ADS_SD_CONTROL_SE_DACL_PRESENT          = &amp;H0004
Const ADS_SD_CONTROL_SE_DACL_DEFAULTED        = &amp;H0008
Const ADS_SD_CONTROL_SE_SACL_PRESENT          = &amp;H0010
Const ADS_SD_CONTROL_SE_SACL_DEFAULTED        = &amp;H0020
Const ADS_SD_CONTROL_SE_DACL_AUTO_INHERIT_REQ = &amp;H0100
Const ADS_SD_CONTROL_SE_SACL_AUTO_INHERIT_REQ = &amp;H0200
Const ADS_SD_CONTROL_SE_DACL_AUTO_INHERITED   = &amp;H0400
Const ADS_SD_CONTROL_SE_SACL_AUTO_INHERITED   = &amp;H0800
Const ADS_SD_CONTROL_SE_DACL_PROTECTED        = &amp;H1000
Const ADS_SD_CONTROL_SE_SACL_PROTECTED        = &amp;H2000
Const ADS_SD_CONTROL_SE_SELF_RELATIVE         = &amp;H8000
  
'AD ACE options

'AD ACE options: AccessMask
Const ADS_RIGHT_DS_CREATE_CHILD        = &amp;H1
Const ADS_RIGHT_DS_DELETE_CHILD        = &amp;H2
Const ADS_RIGHT_ACTRL_DS_LIST          = &amp;H4
Const ADS_RIGHT_DS_SELF                = &amp;H8
Const ADS_RIGHT_DS_READ_PROP           = &amp;H10
Const ADS_RIGHT_DS_WRITE_PROP          = &amp;H20
Const ADS_RIGHT_DS_DELETE_TREE         = &amp;H40
Const ADS_RIGHT_DS_LIST_OBJECT         = &amp;H80
Const ADS_RIGHT_DS_CONTROL_ACCESS      = &amp;H100
Const ADS_RIGHT_DELETE                 = &amp;H10000
Const ADS_RIGHT_READ_CONTROL           = &amp;H20000
Const ADS_RIGHT_WRITE_DAC              = &amp;H40000
Const ADS_RIGHT_WRITE_OWNER            = &amp;H80000
Const ADS_RIGHT_SYNCHRONIZE            = &amp;H100000
Const ADS_RIGHT_ACCESS_SYSTEM_SECURITY = &amp;H1000000
Const ADS_RIGHT_GENERIC_ALL            = &amp;H10000000
Const ADS_RIGHT_GENERIC_EXECUTE        = &amp;H20000000
Const ADS_RIGHT_GENERIC_WRITE          = &amp;H40000000
Const ADS_RIGHT_GENERIC_READ           = &amp;H80000000

Const ADS_RIGHT_FULL_CONTROL           = &amp;HF01FF

'AD ACE options: ACE flags
Const ADS_ACEFLAG_INHERIT_ACE              = &amp;H2
Const ADS_ACEFLAG_NO_PROPAGATE_INHERIT_ACE = &amp;H4
Const ADS_ACEFLAG_INHERIT_ONLY_ACE         = &amp;H8
Const ADS_ACEFLAG_INHERITED_ACE            = &amp;H10
Const ADS_ACEFLAG_SUCCESSFUL_ACCESS        = &amp;H40
Const ADS_ACEFLAG_FAILED_ACCESS            = &amp;H80

'AD ACE options: ACE types
Const ADS_ACETYPE_ACCESS_ALLOWED           = 0
Const ADS_ACETYPE_ACCESS_DENIED            = &amp;H1
Const ADS_ACETYPE_SYSTEM_AUDIT             = &amp;H2
Const ADS_ACETYPE_ACCESS_ALLOWED_OBJECT    = &amp;H5
Const ADS_ACETYPE_ACCESS_DENIED_OBJECT     = &amp;H6
Const ADS_ACETYPE_SYSTEM_AUDIT_OBJECT      = &amp;H7

'AD ACE options: Flags
Const ADS_FLAG_OBJECT_TYPE_PRESENT           = &amp;H1
Const ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT = &amp;H2

'Some schemaIDGUIDs
Const SCHEMAIDGUID_USER         = "{BF967ABA-0DE6-11D0-A285-00AA003049E2}"
Const SCHEMAIDGUID_GROUP        = "{BF967A9C-0DE6-11D0-A285-00AA003049E2}"
Const SCHEMAIDGUID_COMPUTER     = "{BF967A86-0DE6-11D0-A285-00AA003049E2}"
Const SCHEMAIDGUID_CONTACT      = "{5CB41ED0-0E4C-11D0-A286-00AA003049E2}"
Const SCHEMAIDGUID_OU           = "{BF967AA5-0DE6-11D0-A285-00AA003049E2}"
Const SCHEMAIDGUID_PRINTER      = "{BF967AA8-0DE6-11D0-A285-00AA003049E2}"

'Some extended rights
Const GUID_ACCOUNT_RESTRICTIONS = "{4C164200-20C0-11D0-A768-00AA006E0529}"
Const GUID_VALIDATED_SPN        = "{F3A64788-5306-11D1-A9C5-0000F80367C1}"
Const GUID_VALIDATED_DNSHOST    = "{72E39547-7B18-11D1-ADEF-00C04FD8D5CD}"
Const GUID_RESET_PASSWORD       = "{00299570-246D-11D0-A768-00AA006E0529}"

'ADs Types
Const ADSTYPE_INVALID                = 0
Const ADSTYPE_DN_STRING              = 1
Const ADSTYPE_CASE_EXACT_STRING      = 2
Const ADSTYPE_CASE_IGNORE_STRING     = 3
Const ADSTYPE_PRINTABLE_STRING       = 4
Const ADSTYPE_NUMERIC_STRING         = 5
Const ADSTYPE_BOOLEAN                = 6
Const ADSTYPE_INTEGER                = 7
Const ADSTYPE_OCTET_STRING           = 8
Const ADSTYPE_UTC_TIME               = 9
Const ADSTYPE_LARGE_INTEGER          = 10
Const ADSTYPE_PROV_SPECIFIC          = 11
Const ADSTYPE_OBJECT_CLASS           = 12
Const ADSTYPE_CASEIGNORE_LIST        = 13
Const ADSTYPE_OCTET_LIST             = 14
Const ADSTYPE_PATH                   = 15
Const ADSTYPE_POSTALADDRESS          = 16
Const ADSTYPE_TIMESTAMP              = 17
Const ADSTYPE_BACKLINK               = 18
Const ADSTYPE_TYPEDNAME              = 19
Const ADSTYPE_HOLD                   = 20
Const ADSTYPE_NETADDRESS             = 21
Const ADSTYPE_REPLICAPOINTER         = 22
Const ADSTYPE_FAXNUMBER              = 23
Const ADSTYPE_EMAIL                  = 24
Const ADSTYPE_NT_SECURITY_DESCRIPTOR = 25
Const ADSTYPE_UNKNOWN                = 26
Const ADSTYPE_DN_WITH_BINARY         = 27
Const ADSTYPE_DN_WITH_STRING         = 28
  
'Error codes
Const E_ADS_PROPERTY_NOT_FOUND        = &amp;H8000500D
Const ERROR_OBJECT_ALREADY_EXISTS     = &amp;H80071392
Const ERROR_DS_NO_ATTRIBUTE_OR_VALUE  = &amp;H8007200A
Const ERROR_DS_NO_SUCH_OBJECT         = &amp;H80072030
Const ERROR_DS_UNWILLING_TO_PERFORM   = &amp;H80072035

'Schema searchFlags
Const ATTR_INDEXED                    = &amp;H1
Const ATTR_INDEXED_OVER_CONT_AND_ATTR = &amp;H2
Const ATTR_PART_OF_ANR_SET            = &amp;H4
Const ATTR_SURVIVE_DELETION           = &amp;H8
Const ATTR_COPY_WITH_USER             = &amp;H10

'Schema systemFlags
Const ATTR_NOT_REPLICATED             = &amp;H1
Const ATTR_IS_CONSTRUCTED             = &amp;H4
Const ATTR_IS_BASE_SCHEMA             = &amp;H10

'User account options
Const UF_SCRIPT                          = &amp;H0001
Const UF_ACCOUNTDISABLE                  = &amp;H0002
Const UF_HOMEDIR_REQUIRED                = &amp;H0008
Const UF_LOCKOUT                         = &amp;H0010
Const UF_PASSWD_NOTREQD                  = &amp;H0020
Const UF_PASSWD_CANT_CHANGE              = &amp;H0040
Const UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED = &amp;H0080
Const UF_DONT_EXPIRE_PASSWD              = &amp;H10000
Const UF_MNS_LOGON_ACCOUNT               = &amp;H20000
Const UF_SMARTCARD_REQUIRED              = &amp;H40000
Const UF_TRUSTED_FOR_DELEGATION          = &amp;H80000
Const UF_NOT_DELEGATED                   = &amp;H100000
Const UF_USE_DES_KEY_ONLY                = &amp;H200000
Const UF_DONT_REQUIRE_PREAUTH            = &amp;H400000

Const UF_TEMP_DUPLICATE_ACCOUNT          = &amp;H0100 'local account
Const UF_NORMAL_ACCOUNT                  = &amp;H0200 'global account
Const UF_INTERDOMAIN_TRUST_ACCOUNT       = &amp;H0800 'incoming trust
Const UF_WORKSTATION_TRUST_ACCOUNT       = &amp;H1000 'ws or ms comp
Const UF_SERVER_TRUST_ACCOUNT            = &amp;H2000 'dc computer

'Group scopes and types
Const ADS_GROUP_TYPE_GLOBAL_GROUP        = &amp;H2
Const ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP  = &amp;H4
Const ADS_GROUP_TYPE_LOCAL_GROUP         = &amp;H4
Const ADS_GROUP_TYPE_UNIVERSAL_GROUP     = &amp;H8
Const ADS_GROUP_TYPE_SECURITY_ENABLED    = &amp;H80000000

'Well-known GUIDs
Const GUID_USERS_CONTAINER               = "a9d1ca15768811d1aded00c04fd8d5cd"
Const GUID_COMPUTRS_CONTAINER            = "aa312825768811d1aded00c04fd8d5cd"
Const GUID_SYSTEMS_CONTAINER             = "ab1d30f3768811d1aded00c04fd8d5cd"
Const GUID_DOMAIN_CONTROLLERS_CONTAINER  = "a361b2ffffd211d1aa4b00c04fd7d83a"
Const GUID_INFRASTRUCTURE_CONTAINER      = "2fbac1870ade11d297c400c04fd8d5cd"
Const GUID_DELETED_OBJECTS_CONTAINER     = "18e2ea80684f11d2b9aa00c04f79f805"
Const GUID_LOSTANDFOUND_CONTAINER        = "ab8153b7768811d1aded00c04fd8d5cd"

'Service status codes
Const ADS_SERVICE_STOPPED                = 1
Const ADS_SERVICE_START_PENDING          = 2
Const ADS_SERVICE_STOP_PENDING           = 3
Const ADS_SERVICE_RUNNING                = 4
Const ADS_SERVICE_CONTINUE_PENDING       = 5
Const ADS_SERVICE_PAUSE_PENDING          = 6
Const ADS_SERVICE_PAUSED                 = 7
Const ADS_SERVICE_ERROR                  = 8

'OpenDSObject authentication mode
Const ADS_SECURE_AUTHENTICATION          = &amp;H1
Const ADS_USE_ENCRYPTION                 = &amp;H2
Const ADS_USE_SSL                        = &amp;H2
Const ADS_READONLY_SERVER                = &amp;H4
Const ADS_PROMPT_CREDENTIALS             = &amp;H8
Const ADS_NO_AUTHENTICATION              = &amp;H10
Const ADS_FAST_BIND                      = &amp;H20
Const ADS_USE_SIGNING                    = &amp;H40
Const ADS_USE_SEALING                    = &amp;H80
Const ADS_USE_DELEGATION                 = &amp;H100
Const ADS_SERVER_BIND                    = &amp;H200

'ADO/LDAP referral chasing options
Const ADS_CHASE_REFERRALS_NEVER          = 0
Const ADS_CHASE_REFERRALS_SUBORDINATE    = &amp;H20
Const ADS_CHASE_REFERRALS_EXTERNAL       = &amp;H40
Const ADS_CHASE_REFERRALS_ALWAYS         = &amp;H60  '&amp;H20 + &amp;H40

'ADO/LDAP search scope options
Const ADS_SCOPE_BASE                     = 0
Const ADS_SCOPE_ONELEVEL                 = 1
Const ADS_SCOPE_SUBTREE                  = 2

'PutEx modes
Const ADS_PROPERTY_CLEAR                 = 1
Const ADS_PROPERTY_UPDATE                = 2
Const ADS_PROPERTY_APPEND                = 3
Const ADS_PROPERTY_DELETE                = 4

'IADsNameTranslate name types
Const ADS_NAME_TYPE_1779                    = 1
Const ADS_NAME_TYPE_CANONICAL               = 2
Const ADS_NAME_TYPE_NT4                     = 3
Const ADS_NAME_TYPE_DISPLAY                 = 4
Const ADS_NAME_TYPE_DOMAIN_SIMPLE           = 5
Const ADS_NAME_TYPE_ENTERPRISE_SIMPLE       = 6
Const ADS_NAME_TYPE_GUID                    = 7
Const ADS_NAME_TYPE_UNKNOWN                 = 8
Const ADS_NAME_TYPE_USER_PRINCIPAL_NAME     = 9
Const ADS_NAME_TYPE_CANONICAL_EX            = 10
Const ADS_NAME_TYPE_SERVICE_PRINCPAL_NAME   = 11
Const ADS_NAME_TYPE_SID_OR_SID_HISTORY_NAME = 12</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Count_DistributionGroups</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Count_DistributionGroups</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Import-Module activedirectory 
$a = (Get-ADGroup -filter 'GroupCategory -eq "Distribution"').count 
Write-Host "There are" $a "total distribution groups in Active Directory." </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Count_SecurityGroups</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Count_SecurityGroups</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Import-Module activedirectory 
$a = (Get-ADGroup -filter 'GroupCategory -eq "security"').count 
Write-Host "There are" $a "total security groups in Active Directory." </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_newADUser.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_newADUser.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'create a temporary user in Active Directory
#'This requires the ActiveDirectory PowerShell module from RSAT

Param(
    [Parameter(Mandatory, HelpMessage = "Enter the user name like 'Al Fredo'")]
    [String]$Name,
    [string]$Title,
    [string]$Description,
    [string]$Department
)

Write-Host "Creating temporary AD Account for $Name." -ForegroundColor Cyan
#'split the name into first and last name
$first = $name.split(' ')[0]
$last = $name.split(' ')[1]

#'create the samaccountname
if ($last.Length -gt 13) {
    $accountname = "$($first[0])$($last.Substring(0,13))"		#'In case the name is too long
}
else {
    $accountname = "$($first[0])$last"   
}
$upn = "$accountname@company.pri"

#'create a password
#'use these characters as the source
#'no o(scar) or l(arry) characters to avoid confusing with zero and one.
$seed = "abcdefghijkmnpqrstuvwxyz0192837465)!(@*#'&amp;$^"
#'get 9 random characters
$random9 = $seed.ToCharArray() | get-random -count 9
#'join back to a string
$randomstring = $random9 -join ""

#'this is a regular expression pattern to match on any character from a to z
[regex]$rx = "[a-z]"
#'get the first matching alphabet character
$firstalpha = $rx.match($randomstring).value
#'replace the first alphabet character with its upper case version
$plaintext = $randomstring.Replace($firstalpha, $firstalpha.toUpper())

#'convert the password to a secure string for the New-ADUser cmdlet
$password = ConvertTo-SecureString -String $plaintext -AsPlainText -Force

#'define a hashtable of parameter values to splat to New-ADUser
$new = @{
    DisplayName           = $Name
    GivenName             = $first
    Surname               = $last
    Name                  = $accountName
    samaccountname        = $accountName
    UserPrincipalName     = $upn
    enabled               = $True
    AccountExpirationDate = (Get-Date).AddDays(180).Date			#' 180 day temp user
    AccountPassword       = $password
    path                  = "OU=Employees,DC=company,DC=pri"
    Title                 = $Title
    Department            = $Department
    Description           = $Description
    ErrorAction           = "Stop"
}

Try {
    New-ADUser @new
    Write-Host "Created user $accountname that expires $($new.AccountExpirationDate). Password is $plaintext." -ForegroundColor Green
}
Catch {
    $wsh = new-object -com wscript.shell
    $msg = "Failed to create user $Name. $($_.exception.message)"
    #'display a popup warning and force user to click ok
    $wsh.Popup($msg, -1, "New User", 0 + 48)
}
Finally {
    Write-Host "Finished $($myinvocation.MyCommand)" -ForegroundColor Cyan
}


&lt;#'
demo usage

$p = @{
    Name = "Matilda Fuzziwick" 
    Title = "Shipping Clerk" 
    Department = "Sales"
    Description = "Seasonal hire"
}
 
.\Create-newADUser.ps1 @p
 
get-aduser mfuzziwick -Properties title,department,description

#'try to create the user again

#'reset demo
 get-aduser mfuzziwick | remove-aduser -confirm:$false

#'&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Find_Accounts_With_Expired_Passwords</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Find_Accounts_With_Expired_Passwords</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>This did not give me results, but You have to read the article:
https://mcpmag.com/articles/2015/04/30/3-ways-to-keep-active-directory-clean.aspx


$InactiveDays = 30
$MaxPasswordAge = (Get-ADDefaultDomainPasswordPolicy).MaxPasswordAge.Days


Search-AdAccount -PasswordExpired -UsersOnly | Where-Object {((Get-Date) - (Get-AdUser -Filter "samAccountName -eq $_.SamAccountName").PasswordLastSet) -lt ($MaxPasswordAge + $InactiveDays)}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>find_Disabled_Accounts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>find_Disabled_Accounts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Search-AdAccount -AccountDisabled   | Select DistinguishedName</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Finding_Inactive_Accounts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Finding_Inactive_Accounts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'to find all accounts that haven't been active in 30 days,

Search-AdAccount -AccountInactive -Timespan 30.00:00:00


Search-AdAccount -AccountInactive -Timespan 30.00:00:00  | Select DistinguishedName, LastLogonDate</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>gig-RemotelyQueryUserProfile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>gig-RemotelyQueryUserProfile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function gig-RemotelyQueryUserProfile {
                                 &lt;#
                                   .Synopsis
                                    gets a list of user profiles on a computer
                                   .Description
                                    From: https://4sysops.com/archives/remotely-query-user-profile-information-with-powershell/

                                   .Parameter 
                                    ValueFromPipeline = 
                                   .Parameter 
                                    ComputerName = defaults to local
                                   .Notes
                                   .EXAMPLE: 
                                   Example 1 - {for local} 
                                   gig-RemotelyQueryUser  
                                            
                                            &gt; gig-RemotelyQueryUser -ComputerName WBSQL1   {for remote}
                                    AUTHOR: glenn garson, JPHSA
                                    LASTEDIT: 12/28/2016 13:45:05
                                    KEYWORDS:
                                    HSG: 
                                   .Link
                                     Http://www.ScriptingGuys.com
                                 #'Requires -Version 2.0
                                 #&gt;
								[cmdletbinding()]
                                param (
                                [parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
                                [string[]]$ComputerName = $env:computername
                                )            
 
                                foreach ($Computer in $ComputerName) {
                                 $Profiles = Get-WmiObject -Class Win32_UserProfile -Computer $Computer -ea 0
                                 foreach ($profile in $profiles) {
                                  try {
                                      $objSID = New-Object System.Security.Principal.SecurityIdentifier($profile.sid)
                                      $objuser = $objsid.Translate([System.Security.Principal.NTAccount])
                                      $objusername = $objuser.value
                                  } catch {
                                        $objusername = $profile.sid
                                  }
                                  switch($profile.status){
                                   1 { $profileType="Temporary" }
                                   2 { $profileType="Roaming" }
                                   4 { $profileType="Mandatory" }
                                   8 { $profileType="Corrupted" }
                                   default { $profileType = "LOCAL" }
                                  }
                                  $User = $objUser.Value
                                  $ProfileLastUseTime = ([WMI]"").Converttodatetime($profile.lastusetime)
                                  $OutputObj = New-Object -TypeName PSobject
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ComputerName -Value $Computer.toUpper()
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfileName -Value $objusername
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfilePath -Value $profile.localpath
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfileType -Value $ProfileType
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name IsinUse -Value $profile.loaded
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name IsSystemAccount -Value $profile.special
                                  $OutputObj
  
                                 }
                                }
							}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>groups</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>groups</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Import-Module ActiveDirectory

$Groups = (Get-AdGroup -filter * | Where {$_.name -like "**"} | select name -ExpandProperty name)

$Table = @()

$Record = @{
  "Group Name" = ""
  "Name" = ""
  "Username" = ""
}


Foreach ($Group in $Groups) {

  $Arrayofmembers = Get-ADGroupMember -identity $Group -recursive | select name,samaccountname

  foreach ($Member in $Arrayofmembers) {
    $Record."Group Name" = $Group
    $Record."Name" = $Member.name
    $Record."UserName" = $Member.samaccountname
    $objRecord = New-Object PSObject -property $Record
    $Table += $objrecord

  }
}

$Table | export-csv "C:\temp\SecurityGroups.csv" -NoTypeInformation

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Inactive_Users</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Inactive_Users</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://www.adaxes.com/blog/cleanup-active-directory-with-powershell.html



#requires -version 2
&lt;#
.SYNOPSIS
  Find and manage inactive Active Directory users.
.DESCRIPTION
  This script allows you to specify the criteria required to identify inactive users within your AD environment. This script also allows
  for the management of found users. Management of users includes one or more of the following options:
    - Reporting
    - Disabling Users
    - Deleting Users
.PARAMETER SearchScope
  Optional. Determines the search scope of what type of user you would like to include in the inactive user search. Options available are:
   - All                        : Default option. All user types including all standard users, service accounts and never logged on accounts.
   - OnlyInactiveUsers          : Only standard user accounts. This option excludes service accounts and never logged on accounts.
   - OnlyServiceAccounts        : Only server accounts. This option excludes standard user accounts and never logged on accounts.
   - OnlyNeverLoggedOn          : Only never logged on accounts. This option excludes standard user accounts and service accounts.
   - AllExceptServiceAccounts   : All user account types excluding service accounts.
   - AllExceptNeverLoggedOn     : All user account types excluding never logged on accounts.
   Note: If not specified, the default search scope is All (i.e. all user accounts, service accounts and never logged on accounts).
.PARAMETER DaysInactive
  Optional. The number of days a user account hasn't logged into the domain for in order to classify it as inactive. The default option is 90
  days, which means any user account that hasn't logged into the domain for 90 days or more is considered inactive and therefore managed by this
  script.
.PARAMETER ServiceAccountIdentifier
  Optional. The username prefix or postfix that is used to indetify a service account from a standard user account. The default option is 'svc'.
  Determining whether an account is a service account is useful in order to be able to include or exclude service accounts from the search scope.
  Note: For more information see the help information on the parameter SearchScope. 
  Example: All accounts with the prefix or postfix of svc (e.g. svc-MyAccount or MyAccount-svc) are identified as service accounts and can
  therefore be included or exclueded from the search scope.
.PARAMETER ReportFilePath
  Optional. This is the location where the report of inactive users will be saved to. If this parameter is not specified, the default location the
  report is saved to is C:\InactiveUsers.csv.
  Note: When specifying the file path, you MUST include the file name with the extension of .csv. Example: 'C:\MyReport.csv'.
.PARAMETER DisableUsers
  Optional. If this parameter is specified, this script will disable the inactive users found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT disable any inactive users found.
.PARAMETER DeleteUsers
  Optional. If this parameter is specified, this script will delete the inactive users found based on the search scope specified.
  Note: If this parameter is not specified, then by default this script WILL NOT delete any inactive users found.
.INPUTS
  None.
.OUTPUTS
  Report of inactive users found. See ReportFilePath parameter for more information.
.NOTES
  Version:        1.0
  Author:         Luca Sturlese
  Creation Date:  16.07.2016
  Purpose/Change: Initial script development
.EXAMPLE
  Execution of script using default parameters. Default execution performs reporting of inactive AD user only, not disabling or deleting any accounts.
  By default the report is saved in C:\.
  .\Find-ADInactiveUsers.ps1
.EXAMPLE
  Reporting and disabling all user accounts, except never logged on accounts. Storing the report in C:\Reports.
  .\Find-ADInactiveUsers.ps1 -SeachScope AllExceptNeverLoggedOn -ReportFilePath 'C:\Reports\DisabledUsers.csv' -DisableUsers
.EXAMPLE
  Find &amp; delete all inactive users (not service accounts) that haven't logged in for the last 30 days. Include never logged on accounts in this search.
  .\Find-ADInactiveUsers.ps1 -SeachScope AllExceptServiceAccounts -DaysInactive 30 -DeleteUsers
.EXAMPLE
  Delete all user accounts that have never been logged into. Store the report in C:\Reports.
  .\Find-ADInactiveUsers.ps1 -SeachScope OnlyNeverLoggedOn -ReportFilePath 'C:\Reports\NotLoggedOnAccounts.csv' -DeleteUsers
#&gt;

#---------------------------------------------------------[Script Parameters]------------------------------------------------------

Param (
  [Parameter(Mandatory = $false)][string][ValidateSet('All', 'OnlyInactiveUsers', 'OnlyServiceAccounts', 'OnlyNeverLoggedOn', 'AllExceptServiceAccounts', 'AllExceptNeverLoggedOn')]$SearchScope = 'All',
  [Parameter(Mandatory = $false)][int]$DaysInactive = 90,
  [Parameter(Mandatory = $false)][string]$ServiceAccountIdentifier = 'svc',
  [Parameter(Mandatory = $false)][string]$ReportFilePath = 'C:\InactiveUsers.csv',
  [Parameter(Mandatory = $false)][switch]$DisableUsers = $false,
  [Parameter(Mandatory = $false)][switch]$DeleteUsers = $false
)

#---------------------------------------------------------[Initialisations]--------------------------------------------------------

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'

#Import Modules &amp; Snap-ins
Import-Module ActiveDirectory

#----------------------------------------------------------[Declarations]----------------------------------------------------------

#Set Inactive Date:
$InactiveDate = (Get-Date).Adddays(-($DaysInactive))

#-----------------------------------------------------------[Functions]------------------------------------------------------------

Function Find-Accounts {
  Param ()

  Begin {
    Write-Host "Finding inactive user accounts based on search scope specified [$SearchScope]..."
  }

  Process {
    Try {
      #Set Service Account Identifier
      $ServiceAccountIdentifier = '*' + $ServiceAccountIdentifier + '*'

      Switch ($SearchScope) {
        'All' {
          $global:Results = Get-ADUser -Filter { (LastLogonDate -lt $InactiveDate -or LastLogonDate -notlike "*") -and (Enabled -eq $true) } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'OnlyInactiveUsers' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true -and SamAccountName -notlike $ServiceAccountIdentifier } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'OnlyServiceAccounts' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true -and SamAccountName -like $ServiceAccountIdentifier } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'OnlyNeverLoggedOn' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -notlike "*" -and Enabled -eq $true } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'AllExceptServiceAccounts' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true -and SamAccountName -notlike $ServiceAccountIdentifier -or LastLogonDate -notlike "*" } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        'AllExceptNeverLoggedOn' {
          $global:Results = Get-ADUser -Filter { LastLogonDate -lt $InactiveDate -and Enabled -eq $true } -Properties LastLogonDate | Select-Object @{ Name="Username"; Expression = {$_.SamAccountName} }, Name, LastLogonDate, DistinguishedName
        }

        Default {
          Write-Host -BackgroundColor Red "Error: An unknown error occcurred. Can't determine search scope. Exiting."
          Break
        }
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }

    End {
      If ($?) {
        Write-Host 'Completed Successfully.'
        Write-Host ' '
      }
    }
  }
}

Function Create-Report {
  Param ()

  Begin {
    Write-Host "Creating report of inactive users in specified path [$ReportFilePath]..."
  }

  Process {
    Try {
      #Check file path to ensure correct
      If ($ReportFilePath -notlike '*.csv') {
        $ReportFilePath = Join-Path -Path $ReportFilePath -ChildPath '\InactiveUsers.csv'
      }

      # Create CSV report
      $global:Results | Export-Csv $ReportFilePath -NoTypeInformation
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Disable-Accounts {
  Param ()

  Begin {
    Write-Host 'Disabling inactive users...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Disable-ADAccount -Identity $Item.DistinguishedName
        Write-Host "$($Item.Username) - Disabled"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

Function Delete-Accounts {
  Param ()

  Begin {
    Write-Host 'Deleting inactive users...'
  }

  Process {
    Try {
      ForEach ($Item in $global:Results){
        Remove-ADUser -Identity $Item.DistinguishedName -Confirm:$false
        Write-Host "$($Item.Username) - Deleted"
      }
    }

    Catch {
      Write-Host -BackgroundColor Red "Error: $($_.Exception)"
      Break
    }
  }

  End {
    If ($?) {
      Write-Host 'Completed Successfully.'
      Write-Host ' '
    }
  }
}

#-----------------------------------------------------------[Execution]------------------------------------------------------------

Find-Accounts
Create-Report

If ($DisableUsers) {
  Disable-Accounts
}

If ($DeleteUsers) {
  Delete-Accounts
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>List_of_users_in_OrganizationUnit</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>List_of_users_in_OrganizationUnit</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'http://www.itprocentral.com/quick-hint-listing-all-users-from-a-specific-ou-using-powershell/
Import-Module ActiveDirectory
Get-ADUser -SearchBase “OU=Argentina,dc=apatricio,dc=local” -Filter * -ResultSetSize 5000 | Select Name,SamAccountName

e.g. Canonical name of object: jphsa.org/Generic Users

'These two examples work,with the description field:
Import-Module ActiveDirectory
Get-ADUser -SearchBase “OU=Generic Users,dc=JPHSA,dc=ORG” -Filter * -ResultSetSize 5000 | Select Name,SamAccountName,description | Format-list


Import-Module ActiveDirectory
Get-ADUser -SearchBase “OU=Generic Users,dc=JPHSA,dc=ORG” -Filter * -ResultSetSize 5000 -Properties Description | Select *</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Locked_User_Account_Find_and_Unlock</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Locked_User_Account_Find_and_Unlock</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://blogs.technet.microsoft.com/heyscriptingguy/2011/08/31/use-powershell-to-find-locked-out-user-accounts/

import-module ActiveDirectory

Search-ADAccount –LockedOut

Search-ADAccount -LockedOut | Unlock-ADAccount

Search-ADAccount –LockedOut</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LockedOut_Expiring_Disabled_InActive_Expired_NeverExpires</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LockedOut_Expiring_Disabled_InActive_Expired_NeverExpires</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&gt; Search-ADAccount -AccountDisabled
&gt; Search-ADAccount -AccountExpired
&gt; Search-ADAccount -AccountExpiring
&gt; Search-ADAccount -AccountInactive
&gt; Search-ADAccount -LockedOut
&gt; Search-ADAccount -PasswordExpired
&gt; Search-ADAccount -PasswordNeverExpires</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Modify_User</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Modify_User</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' Uses $Attributes Hashtable for the various properties that you want to 

param ([string]$Username, [hashtable]$Attributes)

    try {
            ## Attempt to find the username
            $UserAccount = Get-AdUser -Identity $Username
            if (!$UserAccount) {
	                                ## If the username isn't found throw an error and exit
	                                Write-Error "The username '$Username' does not exist"
	                                return
                                }
        } 
  catch {

        }

## The $Attributes parameter will contain only the parameters for the Set-AdUser cmdlet other than
## Password.  If the password is in $Attributes it needs to be treated differently, i.e. need to use:Set-ADAccountPassword, then delete it from $Attributes .
if ($Attributes.ContainsKey('Password')) {
	                                            $UserAccount | Set-ADAccountPassword -Reset -NewPassword (ConvertTo-SecureString -AsPlainText $Attributes.Password -Force)
	                                            ## Remove the password key because we'll be passing this hashtable directly to Set-AdUser later
	                                            $Attributes.Remove('Password')
                                          }

$UserAccount | Set-AdUser @Attributes


#' USAGE ======================================================================================================
#' the parameter names (i.e. Hash Table Keys) must be spelled just like the Parameters of the method be called
#' e.g. 'givenName' and 'surname' keys in the Hashtable are the same as the PARMs of Set-AdUser  

&gt; .\Set-MyAdUser.ps1 -Username rsmith -Attributes @{givenName = "Trudy"; surname = 'smithley'}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PageSize_to_exceed_the_default_limit_of_1000</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PageSize_to_exceed_the_default_limit_of_1000</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://powershelltutorial.net/ActiveDirectory/

'it really doesn’t matter what value you set for the property. 
'As long as the value is set it will return more than the default of 1,000 records (default is 0).


'After the server has found the number of objects that are specified by the PageSize property, 
'	it will stop searching and return the results to the client. 
'	When the client requests more data, the server will restart the search where it left off.


$Search = New-Object DirectoryServices.DirectorySearcher([ADSI]“”)
$Search.filter = “(&amp;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=65536))”
$Search.PageSize = 1000
$results = $Search.Findall()
Foreach($result in $results){
$User = $result.GetDirectoryEntry()
$user.DistinguishedName
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Resolve_SID</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Resolve_SID</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function Resolve-SID($stringSid) {
  $objSID = New-Object System.Security.Principal.SecurityIdentifier($stringSid) 
  $objUser = $objSID.Translate([System.Security.Principal.NTAccount]) 
  $objUser.Value
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Resolve_User</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Resolve_User</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function Resolve-User($user) {
  $objUser = New-Object System.Security.Principal.NTAccount($user) 
  $objSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier]) 
  $objSID.Value
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>restore_deleted_AD_User</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>restore_deleted_AD_User</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'If you have a modern version of Active Directory, you have the opportunity to enable the Active Directory Recycle Bin. Once enabled, 
'	you have a chance to recover a deleted item once it has been removed from Active Directory.

$dn = (Get-ADObject -SearchBase (get-addomain).deletedobjectscontainer -IncludeDeletedObjects -filter "samaccountname -eq '$Username'").distinguishedname
Restore-ADObject -identity $dn

#'On the first line, we’re getting the DistinguishedName for the deleted user. 
#'    The DN changes when a user gets deleted because it’s in the Recycle Bin now. 
#'    Where’s your deleted objects container? Well it’s easily found 
#'    with the (Get-ADDomain).DeletedObjectsContainer part of line 1. 
#'All we’re doing is searching for AD objects in the deleted objects container 
#'    whose username matches the one we’re looking for. We need to make sure the -IncludeDeletedObjects flag 
#'    is set or nothing that’s deleted will be returned.
#'
#'On the second line, we’re just using the Restore-ADObject cmdlet to restore the object at the DN we found above.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Search_AD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Search_AD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'Save the code below as FindUser.ps1

$User = Read-Host “Enter the Users’ Logon Name”
$Search = New-Object DirectoryServices.DirectorySearcher([ADSI]“”)
$Search.filter = “(&amp;(objectClass=user)(sAMAccountName=$User))”
$Search.Findall()
=======================================================================
'a report of all AD accounts with the password set “Not to Expire.”
'Save code as PassNotExp.ps1

$Search = New-Object DirectoryServices.DirectorySearcher([ADSI]“”)
$Search.filter = “(&amp;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=65536))”
$results = $Search.Findall()
Foreach($result in $results){
$User = $result.GetDirectoryEntry()
$user.DistinguishedName
}

'What if you wanted to pull the Logon Names? Just make the following change
'	 to the last line in the script – $user.sAMAccountName

=======================================================================
' get a list of all users in a specific OU.

'If you wanted to search not only the Disabled Account OU but any sub OUs 
'	you would modify the search scope as follows:
$Search.SearchScopt = “SubTree”
---------------------------------------------------------------
$ADsPath = [ADSI]“LDAP://OU=Disabled Accounts,DC=MyDomain,DC=Msft”
$Search = New-Object DirectoryServices.DirectorySearcher($ADsPath)
$Search.filter = “(objectClass=user)”
$Search.PageSize = 1000
$Search.SearchScope = “OneLevel” $results = $Search.Findall()
Foreach($result in $results){
$User = $result.GetDirectoryEntry()
$user.DistinguishedName
}
=======================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>unLock</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>unLock</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Unlock-QADUser jsmith
'or
Unlock-ADAccount</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>User_Attributes</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>User_Attributes</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Import-Module activedirectory
New-PSDrive -PSProvider activedirectory -Name theUsers -Root "AD:\CN=Users,DC=jphsa,DC=org"
Set-Location theUsers:
PS:CN=Users&gt;Get-ADUser ggarson -Properties * | Select-Object -First 1  | Select *

'OUTPUT
===================

AccountExpirationDate                : 
accountExpires                       : 9223372036854775807
AccountLockoutTime                   : 
AccountNotDelegated                  : False
adminCount                           : 1
AllowReversiblePasswordEncryption    : False
AuthenticationPolicy                 : {}
AuthenticationPolicySilo             : {}
BadLogonCount                        : 0
badPasswordTime                      : 131733782693735230
badPwdCount                          : 0
CannotChangePassword                 : False
CanonicalName                        : jphsa.org/Users/Glenn Garson
Certificates                         : {}
City                                 : 
CN                                   : Glenn Garson
codePage                             : 0
Company                              : JPHSA
CompoundIdentitySupported            : {False}
Country                              : 
countryCode                          : 0
Created                              : 12/19/2016 8:38:16 AM
createTimeStamp                      : 12/19/2016 8:38:16 AM
Deleted                              : 
Department                           : ADMIN - IT
Description                          : 12/19/2016
DisplayName                          : Glenn Garson
DistinguishedName                    : CN=Glenn Garson,CN=Users,DC=jphsa,DC=org
Division                             : 
DoesNotRequirePreAuth                : False
dSCorePropagationData                : {6/5/2018 1:58:26 AM, 6/1/2018 1:51:18 PM, 6/1/2018 9:28:57 AM, 6/1/2018 8:36:38 AM...}
EmailAddress                         : ggarson@jphsa.org
EmployeeID                           : 309645
EmployeeNumber                       : 
Enabled                              : True
Fax                                  : 
GivenName                            : Glenn
HomeDirectory                        : \\jphsa.org\shared\Users\ggarson
HomedirRequired                      : False
HomeDrive                            : H:
homeMDB                              : CN=EB EX13 Mailbox Database,CN=Databases,CN=Exchange Administrative Group 
                                       (FYDIBOHF23SPDLT),CN=Administrative Groups,CN=JPHSA,CN=Microsoft 
                                       Exchange,CN=Services,CN=Configuration,DC=jphsa,DC=org
HomePage                             : 
HomePhone                            : 
Initials                             : 
instanceType                         : 4
isDeleted                            : 
KerberosEncryptionType               : {None}
LastBadPasswordAttempt               : 6/13/2018 10:44:29 AM
LastKnownParent                      : 
lastLogoff                           : 0
lastLogon                            : 131751002617905998
LastLogonDate                        : 7/3/2018 11:37:37 AM
lastLogonTimestamp                   : 131751094573927303
legacyExchangeDN                     : /o=JPHSA/ou=Exchange Administrative Group (FYDIBOHF23SPDLT)/cn=Recipients/cn=Glenn Garson442
LockedOut                            : False
lockoutTime                          : 0
logonCount                           : 25838
LogonWorkstations                    : 
mail                                 : ggarson@jphsa.org
mailNickname                         : ggarson
Manager                              : CN=Gary Lamprecht,CN=Users,DC=jphsa,DC=org
mDBUseDefaults                       : True
MemberOf                             : {CN=jphsa411Secure_Admin,OU=Groups,DC=jphsa,DC=org, CN=Recipient Management Customized,OU=Microsoft 
                                       Exchange Security Groups,DC=jphsa,DC=org, CN=SQL_SERVER_Alerts,OU=Email Distribution 
                                       Groups,DC=jphsa,DC=org, CN=Managed Availability Servers,OU=Microsoft Exchange Security 
                                       Groups,DC=jphsa,DC=org...}
MNSLogonAccount                      : False
MobilePhone                          : 
Modified                             : 7/3/2018 11:37:48 AM
modifyTimeStamp                      : 7/3/2018 11:37:48 AM
msDS-SupportedEncryptionTypes        : 0
msDS-User-Account-Control-Computed   : 0
msExchDelegateListBL                 : {CN=JPHSA-IT,OU=Room Scheduling,DC=jphsa,DC=org}
msExchHomeServerName                 : /o=JPHSA/ou=Exchange Administrative Group (FYDIBOHF23SPDLT)/cn=Configuration/cn=Servers/cn=WBEXCH1
msExchMailboxGuid                    : {156, 211, 243, 3...}
msExchMailboxSecurityDescriptor      : System.DirectoryServices.ActiveDirectorySecurity
msExchMobileMailboxFlags             : 1
msExchPoliciesIncluded               : {ad4d4934-ef44-4faa-9487-102d017d1d23, {26491cfc-9e50-4857-861b-0cb8df22b5d7}}
msExchRBACPolicyLink                 : CN=Default Role Assignment Policy,CN=Policies,CN=RBAC,CN=JPHSA,CN=Microsoft 
                                       Exchange,CN=Services,CN=Configuration,DC=jphsa,DC=org
msExchRecipientDisplayType           : 1073741824
msExchRecipientTypeDetails           : 1
msExchShadowMailNickname             : ggarson
msExchShadowProxyAddresses           : {SMTP:ggarson@jphsa.org, X400:C=US;A= ;P=JPHSA;O=Exchange;S=Garson;G=Glenn;}
msExchTextMessagingState             : {302120705, 16842751}
msExchUMDtmfMap                      : {reversedPhone:0521932405, emailAddress:4427766, lastNameFirstName:42776645366, 
                                       firstNameLastName:45366427766}
msExchUserAccountControl             : 0
msExchUserCulture                    : en-US
msExchVersion                        : 88218628259840
msExchWhenMailboxCreated             : 12/19/2016 9:11:51 AM
Name                                 : Glenn Garson
nTSecurityDescriptor                 : System.DirectoryServices.ActiveDirectorySecurity
ObjectCategory                       : CN=Person,CN=Schema,CN=Configuration,DC=jphsa,DC=org
ObjectClass                          : user
ObjectGUID                           : a74a1229-fd6b-40cb-b69d-27198807911b
objectSid                            : S-1-5-21-3427687756-3683169169-49774839-12106
Office                               : IT - EB
OfficePhone                          : 5042391250
Organization                         : 
OtherName                            : 
PasswordExpired                      : False
PasswordLastSet                      : 6/20/2018 3:12:13 PM
PasswordNeverExpires                 : False
PasswordNotRequired                  : False
physicalDeliveryOfficeName           : IT - EB
POBox                                : 
PostalCode                           : 
PrimaryGroup                         : CN=Domain Users,OU=Groups,DC=jphsa,DC=org
primaryGroupID                       : 513
PrincipalsAllowedToDelegateToAccount : {}
ProfilePath                          : 
ProtectedFromAccidentalDeletion      : False
proxyAddresses                       : {SMTP:ggarson@jphsa.org, X400:C=US;A= ;P=JPHSA;O=Exchange;S=Garson;G=Glenn;}
publicDelegatesBL                    : {CN=JPHSA-IT,OU=Room Scheduling,DC=jphsa,DC=org, CN=IT Calendar,OU=Room Scheduling,DC=jphsa,DC=org}
pwdLastSet                           : 131739991334792846
SamAccountName                       : ggarson
sAMAccountType                       : 805306368
ScriptPath                           : logonIT.bat
sDRightsEffective                    : 15
ServicePrincipalNames                : {}
showInAddressBook                    : {CN=All Users,CN=All Address Lists,CN=Address Lists Container,CN=JPHSA,CN=Microsoft 
                                       Exchange,CN=Services,CN=Configuration,DC=jphsa,DC=org, CN=Default Global Address List,CN=All Global 
                                       Address Lists,CN=Address Lists Container,CN=JPHSA,CN=Microsoft 
                                       Exchange,CN=Services,CN=Configuration,DC=jphsa,DC=org}
SID                                  : S-1-5-21-3427687756-3683169169-49774839-12106
SIDHistory                           : {}
SmartcardLogonRequired               : False
sn                                   : Garson
State                                : 
StreetAddress                        : 
Surname                              : Garson
telephoneNumber                      : 5042391250
textEncodedORAddress                 : X400:C=US;A= ;P=JPHSA;O=Exchange;S=Garson;G=Glenn;
Title                                : IT Technical Support Specialist II
TrustedForDelegation                 : False
TrustedToAuthForDelegation           : False
UseDESKeyOnly                        : False
userAccountControl                   : 512
userCertificate                      : {}
UserPrincipalName                    : ggarson@jphsa.org
uSNChanged                           : 20008229
uSNCreated                           : 1325114
whenChanged                          : 7/3/2018 11:37:48 AM
whenCreated                          : 12/19/2016 8:38:16 AM
PropertyNames                        : {AccountExpirationDate, accountExpires, AccountLockoutTime, AccountNotDelegated...}
AddedProperties                      : {}
RemovedProperties                    : {}
ModifiedProperties                   : {}
PropertyCount                        : 137</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>User_Create</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>User_Create</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
http://powershelltutorial.net/ActiveDirectory/
#'This example create a new user object called FirstName LastName in the TestOUUsers OU.

$Class = “User”
$strUserName = “CN=FirstName LastName”
$objADSI = [ADSI]“LDAP://OU=TestOUUsers,OU=TestOU,DC=MyDomain,DC=msft”
$objUser = $objADSI.Create($Class, $strUserName)
$objUser.Put(“sAMAccountName”, “jdoe”)
$objUser.setInfo()

'SetInfo commits our change by writing to the object into Active Directory database. 
=============================================================================

#'This time our code is going to bind to the user object we created (FirstName LastName) 
'	and use the put method to set the attribute value and the setInfo method 
'	to commit our changes to the AD database. 

'If you are unsure of what data type to use with an AD attribute (property) it
'	 is listed in the syntax column on the properties page for the AD object in ADSIEdit.

$objUser = [ADSI]“LDAP://CN=FirstName LastName,OU=TestOUUsers,OU=TestOU,DC=MyDomain,DC=msft”
$objUser.put(“givenName”, “FirstName”)
$objUser.put(“initials”, “D.”)
$objUser.put(“sn”, “LastName”)
$objUser.put(“DisplayName”, “LastName, FirstName”)
$objUser.put(“description”, “IT Manager”)
$objUser.put(“PhysicalDeliveryOfficeName”, “Building 44 suite 195″)
$objUser.put(“telephoneNumber”, “555-555-5555″)
$objUser.put(“mail”, “FirstNameLastName@MyDomain.msft”)
$objUser.setInfo()
--------------------------------------------------------------------------- "," in string=&gt; error
'As shown, when binding to an AD object we used the ADsPath 
'	with each entry separated by a commma (,)

'It is not uncommon to see this as some companies use “Last name, First name” 
'	as a standard to sort objects alphabetically. 
'	Do the following with the FirstName LastName account:

'locate “FirstName LastName” in ADUC
'Right-Click on FirstName LastName and rename to LastName, FirstName. This renames the CN.
'Refresh ADUC.
'Now let’s attempt to bind using the modify script. In bold is the change. 
'	Save the script as ModJdoe2.ps1

$objUser = [ADSI]“LDAP://CN=LastName, FirstName,OU=TestOUUsers,OU=TestOU,DC=MyDomain,DC=msft”
$objUser.put(“givenName”, “FirstName”)
$objUser.put(“initials”, “D.”)
$objUser.put(“sn”, “LastName”)
$objUser.put(“DisplayName”, “LastName, FirstName”)
$objUser.put(“description”, “IT Manager”)
$objUser.put(“PhysicalDeliveryOfficeName”, “Building 44 suite 195″)
$objUser.put(“telephoneNumber”, “555-555-5555″)
$objUser.put(“mail”, “FirstNameLastName@MyDomain.msft”)
$objUser.setInfo()

'When running the script we get an error: “An invalid dn syntax has been specified.”

'We need to tell PowerShell that the comma separating the Last and First name 
'	is part of the CN and not a separator for the DN (distinguished name). 
'	We do this by adding the back slash character.

'Modify the LDAP binding as follows:
$objUser = [ADSI]“LADP://CN=LastName\, FirstName,OU=TestOUUsers,OU=TestOU,DC=MyDomain,DC=org”

'The script will run without the syntax error.
---------------------------------------------------------------------------

'The script example below provides how constants are used in PowerShell.
-------------------------------------------------------------------------
Set-Variable -name ADS_UF_ACCOUNTDISABLE -value 2 -option constant
$objUser = [ADSI]“LDAP://CN=FirstName LastName,OU=TestOUUsers,OU=TestOU,DC=MyDomain,DC=msft”
$objUser.put(“userAccountControl”,$ADS_UF_ACCOUNTDISABLE)

$objUser.setInfo()

---------------------------------------------------------------------

'Setting Users Address Tab Information:

$objUser.put(“streetAddress”, “12345 First St.”)
$objUser.put(“postOfficeBox”, “PO Box 12345″)
$objUser.put(“l”, “Newport Beach”)
$objUser.put(“st”, “California”)
$objUser.put(“postalCode”, “12345″)
$objUser.put(“co”, “USA”)

'Setting User Profile Tab:

$objUser.put(“profilePath”, “\\FileServerName\%username%”)
$objUser.put(“ScriptPath”, “logon.ps1″)
$objUser.put(“homeDrive”, “H:”)
$objUser.put(“homeDirectory”, “\\FilesServerName\%username%”)

'Setting User Telephone Tab:

$objUser.put(“homePhone”, “(555)555-5555″)
$objUser.put(“pager”, “(555)555-5555″)
$objUser.put(“mobile”, “(555)555-5555″)
$objUser.put(“facsimileTelephoneNumber”, “(555)555-5555″)
$objUser.put(“ipPhone”, “(555)555-5555″)
$objUser.put(“info”, “User can be contacted by pager 24 hours a day.”

'Setting User Oganization Tab:

$objUser.put(“Title”, “The Boss”)
$objUser.put(“Department”, “Human Resources”)
$objUser.put(“Company”, “NWTraders”)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>USER_descriptions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>USER_descriptions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


Get-ADUser -Properties Description -Filter * | Select-Object SamAccountName, Name, Description, Enabled -First 10


=======================================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>User_set_Attribute__example_Set_EmployeeID</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>User_set_Attribute__example_Set_EmployeeID</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Import-Module activedirectory

New-PSDrive -PSProvider activedirectory -Name theUsers -Root "AD:\CN=Users,DC=jphsa,DC=org"

Set-Location theUsers:

'First try WhatIf
Set-ItemProperty -Filter "SamAccountName=ggarson" -Path *  -Name EmployeeID -Value 309645zz -WhatIf

'This actually does the change
Set-ItemProperty -Filter "SamAccountName=ggarson" -Path *  -Name EmployeeID -Value 309645zz</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>userAccountControl_field_in_AD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>userAccountControl_field_in_AD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://powershelltutorial.net/ActiveDirectory/

'The User Account Control attribute requires an integer data type
'you can see it in the Attribute Editor tab of the User's properties

Ads Constant								Hex Value	Decimal Value
ADS_UF_SCRIPT								0x0001	1
ADS_UF_ACCOUNTDISABLE						0x0002	2
ADS_UF_HOMEDIR_REQUIRED						0x0008	8
ADS_UF_LOCKOUT								0x0010	16
ADS_UF_PASSWD_NOTREQD						0x0020	32
ADS_UF_PASSWD_CANT_CHANGE					0x0040	64
ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED		0x0080	128
ADS_UF_TEMP_DUPLICATE_ACCOUNT				0x0100	256
ADS_UF_NORMAL_ACCOUNT						0x0200	512
ADS_UF_INTERDOMAIN_TRUST_ACCOUNT			0x0800	2048
ADS_UF_WORKSTATION_TRUST_ACCOUNT			0x1000	4096
ADS_UF_SERVER_TRUST_ACCOUNT					0x2000	8192
ADS_UF_DONT_EXPIRE_PASSWD					0x10000	65536
ADS_UF_MNS_LOGON_ACCOUNT					0x20000	131072
ADS_UF_SMARTCARD_REQUIRED					0x40000	262144
ADS_UF_TRUSTED_FOR_DELEGATION				0x80000	524288
ADS_UF_NOT_DELEGATED						0x100000	1048576
ADS_UF_USE_DES_KEY_ONLY						0x200000	2097152
ADS_UF_DONT_REQUIRE_PREAUTH					0x400000	4194304
ADS_UF_PASSWORD_EXPIRED						0x800000	8388608
ADS_UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION	0x1000000	16777216

example user with value 546

#'So the value of 546 represents an answer to an equation. 
#'It is the decimal values (Flags) added together that gives us the value for the attribute. 
#'
#' 
#'I’ve introduced a term called a Constant. 
#'A constant is a variable with one major difference.
 
#' A variable’s value can be changed where a Constant’s value always stays the same throughout the script. 
#'
#'Using the Decimal Value column in the table let’s look at what type of Control has been set on FirstName’s Account. 
#'By process of elimination we figure the puzzle out like this:
#'
#'1. Looking at FirstName’s control value of 546, 
#'    what is the highest attribute number we can start with? 
#'    Should be 512… correct? So we know this is a NORMAL_ACCOUNT (basically a user account). 
#'    Subtract 512 from 546 and we have 34 left over.
#'
#'2. With 34 left over, what is the next attribute number we can apply? 
#'    Should be PASSWD_NOTREQD which has a decimal value of 32. 
#'    Subtract 32 from 34 and we should have a value of 2 left over.
#'
#'3. What’s the next value that is assigned? ACCOUNTDISABLE has a decimal value of 2. 
#'    Subtract 2 from 2 and we have no value left over.
#'
#'So, according to the userAccountControl attribute; 
#'    FirstName LastName is a Normal account that doesn’t require a password and is currently disabled.

'Just by looking at the ACCOUNTDISABLE flag, 
'	it should be apparent that we can enable the account by removing a decimal value of 2 
'	from the current userAccountControl attribute. 

$objUser = [ADSI]“LDAP://CN=FirstName LastName,OU=TestOUUsers,OU=TestOU,DC=MyDomain,DC=msft”
$objUser.put(“userAccountControl”, 544)
$objUser.SetInfo()

#'Important: The userAccessControl attribute holds only one integer, 
#'    which is the sum of all the integer values for each Control Flag 
#'    that you wish to set. Keep this in mind when changing this attribute. 
#'Let’s say you have a user account with the attribute set to 8388608 (Password Expired). 
#'    Your boss has asked that you disable the account but he also wants to make sure 
#'    the password stays expired should someone at the help desk get duped into re-enabling the account. 
#'In this case you would want to set the userAccessControl attribute to 8388610. 
#'Can you see why changing the attribute to a value of just 2 would be an issue? 
#'If you disabled the account using the value of 2 (ACCOUNTDISABLE) you have removed the value of 8388608
#'     and now the Password is not expired. 
#'Hope that makes sense… You can get into a lot of trouble setting attributes, so be careful and thorough.
#'


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>UserAcctCreate.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>UserAcctCreate.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># HR System Interface
Write-Host “Welcome to MyDomain HR System”
# Set Variables from User Input
$FirstName = Read-Host “Enter Employee’s First Name”
$LastName = Read-Host “Enter Employee’s Last Name”
$DisplayName = ($LastName + “, ” + $FirstName)
$Discription = Read-Host “Enter Empolyee’s Title”
$Office = Read-Host “Enter Employee’s Location”
$Phone = Read-Host “Enter Employee’s Phone Number”
$CN = (“CN=” + $FirstName + ” ” + $LastName)
$Class = “User”
$strUserName = $CN

#connect to AD and create user
$objADSI = [ADSI]“LDAP://OU=TestOUUsers,OU=TestOU,DC=NWTraders,DC=Mstf”
$objUser = $objADSI.Create($Class, $strUserName)
$objUser.Put(“sAMAccountName”, $FirstName)

# Commit the object in AD
$objUser.setInfo()

#Set General Tab Properties
#Bind to the user Object
$objADSI = [ADSI]“LDAP://$CN,OU=TestOUUsers,OU=TestOU,DC=NWTraders,DC=Mstf”
$objUser.Put(“givenName”, “$firstName”)
$objUser.Put(“SN”, “$LastName”)
$objUser.Put(“DisplayName”, “$DisplayName”)
$objUser.Put(“description”, “$Discription”)
$objUser.Put(“PhysicalDeliveryOfficeName”, “$office”)
$objUser.Put(“telephoneNumber”, “$phone”)

#set UserAccessControl
$objUser.put(“userAccountControl”, 544)

#Commit changes
$objUser.setInfo()</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_and_DotNet</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Add_method_to_existing_object_from_a_Pipe</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_and_DotNet</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Add_method_to_existing_object_from_a_Pipe</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#'
#' Demo 10 - Add to an existing object
#' Get-ChildItem will get list of files in the given folder
#' This demo adds a 'function' (i.e. a script block) to the objects returned by 'Get-ChildItem' 
#'-----------------------------------------------------------------------------#'

#' Define the custom script method that returns a value based on the extension of the file object
$script = { 
            $retValue = "Unknown"

            if($this.Extension -eq '.ps1')
            {
              $retValue = 'Script'
            }
            else
            {
              $retValue = 'Not A Script'
            }

            return $retValue
          }

#' Load a variable with a collection of file objects
Set-Location "C:\DATA\psScripts"
$items = Get-ChildItem

#' Add script property to the each file object in bulk
$items | Add-Member -MemberType ScriptMethod `                          #'&lt;====== Pipe the collection of objects to Add-Member (to add the script block)
                    -Name 'ScriptType' `
                    -Value $script                                      #'&lt;====== The 'Value' is the script block


#' Now, for illustrative purposes, add another property to 
#' each item using a foreach loop
$itemCount = 0
foreach($item in $items)
{
  $itemCount++

  #' Add a note property, setting it to the current item counter
  #' Could have also used $item | Add-Member...
  Add-Member -InputObject $item `
             –MemberType NoteProperty `
             –Name ItemNumber `
             –Value $itemCount
  
  #' Display the results of the file object with the new 
  #' property and script (function) added
  "$($item.ItemNumber): $($item.Name) = $($item.ScriptType())"
}
#'======================================================OUTPUT================
#'  1: Count_And_List_Sessions_on_BCC-EXPLORER3.ps1 = Script
#'  2: email_LIST_of_REMOTE_logins_for_all_SERVERS_on_our_Network.psf.ps1 = Script
#'  3: Get-IPDetails.PS1 = Script
#'  4: Get-MachineIPDetails.PS1 = Script
#'  5: Get-SubNetItems.txt = Not A Script
#'  6: Get-UserSession.ps1 = Script
#'  7: LIST_to_CSV_All_Groups_All_Users.ps1 = Script
#'  8: LogOff_DisconnectedSessions_on_server.ps1 = Script
#'  9: Query_Remote_Sessions_on_a_Server.ps1 = Script
#'  10: Set_Environment_To_Include_Modules.ps1 = Script</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_InstalledSoftware_32_and_64_v0.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_InstalledSoftware_32_and_64_v0.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get_InstalledSoftware_32_and_64_v0.ps1

#'This Powershell script list all the installed application on both 32 and 64 bit applications, 
#'	particularly useful for people managing both 32-bit and 64-bit applications.
 
#'	This code also contains an EXCLUSION array where you can exclude list of program that you don't want to show.
#'
#'The function allows -ComputerName parameter so you can connect to any machines
#'Application architecture detection (32-bit or 64-bit) using Win32_processor
#'Output is Powershell console and GridView

#'https://gallery.technet.microsoft.com/scriptcenter/PowerShell-Installed-70d0c0f4

#'===================================================================================USAGE
Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================


Function Get-SoftwareList
{
Param(
[Parameter(Mandatory=$true)]
[string[]]$Computername)

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")

[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 
$donotwrite = $false

if($AppName.length -gt "0"){

 Foreach($exclude in $excludeArray) 
                        {
                        if($AppName.StartsWith($exclude) -eq $TRUE)
                            {
                            $donotwrite = $true
                            break
                            }
                        }
            if ($donotwrite -eq $false) 
                        {                        
            $Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "64-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
                        }





}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 
 $donotwrite = $false
         
                             



if($AppName.length -gt "0"){
 Foreach($exclude in $excludeArray) 
                        {
                        if($AppName.StartsWith($exclude) -eq $TRUE)
                            {
                            $donotwrite = $true
                            break
                            }
                        }
            if ($donotwrite -eq $false) 
                        {                        
            $Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
                        }
           }

 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

"#"*80
"Installed Software Application Report"
"Numner of Installed Application count : $($object.count)"
"Generated $(get-date)"
"Generated from $(gc env:computername)"
"#"*80

$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
$object|Out-GridView 


}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_USAGE_v5.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_USAGE_v5.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get-InstalledSoftware_32_And_64_USAGE_v5.ps1

$testcomputers = Get-Content -Path 'C:\DATA\2018_06_12_TEST.txt'


#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\2018_06_12_ALL_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\2018_06_12_ALL_DidNOTrespondToPing.txt
		}
	}

cls

$goodComputerList = Get-Content 'C:\DATA\2018_06_12_ALL_RespondToPing.txt';
foreach ($computer in $goodComputerList) {
                                            Write-Host "Processing "$computer -ForegroundColor Yellow
                                            Get-SoftwareList_v5 -Computername $computer -outfile C:\DATA\2018_06_12_Update_Audit.csv
                                         }#'Get-InstalledSoftware_32_And_64_USAGE_v5.ps1

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v3.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v3.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v3.ps1
#' The exclusion array has been replaced by the inclusion array (for finding Adobe software)
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v3
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $true
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

#'                             Foreach($exclude in $excludeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $true
#'                                                        break
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - START
                             Foreach($include in $includeArray) 
                                                    {
                                                    if($AppName.StartsWith($include) -eq $TRUE)
                                                        {
                                                        $donotwrite = $false
                                                        }
                                                    }
                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $true
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){
#'Foreach($exclude in $excludeArray) 
#'                        {
#'                        if($AppName.StartsWith($exclude) -eq $TRUE)
#'                            {
#'                            $donotwrite = $true
#'                            break
#'                            }
#'                        }

                        #'=================================================================  INCLUSION ARRAY - START
                            Foreach($include in $includeArray) 
                                                {
                                                if($AppName.StartsWith($include) -eq $TRUE)
                                                    {
                                                    $donotwrite = $false
                                                    }
                                                }
                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v3_USAGE.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v3_USAGE.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get-InstalledSoftware_32_And_64_USAGE_v3_v4.ps1

$testcomputers = Get-Content -Path 'C:\DATA\2018_06_06_TEST.txt'


#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\2018_06_06_ALL_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\2018_06_06_ALL_DeadPCs.txt
		}
	}

cls

$goodComputerList = Get-Content 'C:\DATA\2018_06_06_ALL_RespondToPing.txt';
foreach ($computer in $goodComputerList) {
                                            Write-Host "Processing "$computer -ForegroundColor Yellow
                                            Get-SoftwareList_v4 -Computername $computer -outfile C:\DATA\2018_06_06_Adobe_Audit.csv
                                         }</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v4.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v4.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v4.ps1
#' All Applications, with the default Exclusion Array
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v4
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

$excludeArray = ("Security Update for Windows",
"Update for Windows",
"Update for Microsoft .NET",
"Security Update for Microsoft",
"Hotfix for Windows",
"Hotfix for Microsoft .NET Framework",
"Hotfix for Microsoft Visual Studio 2007 Tools",
"Hotfix")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                             Foreach($exclude in $excludeArray) 
                                                    {
                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
                                                        {
                                                        $donotwrite = $true
                                                        break
                                                        }
                                                    }


                            #'=================================================================  INCLUSION ARRAY - START
    #'                         Foreach($include in $includeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($include) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $false
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                        Foreach($exclude in $excludeArray) 
                                                {
                                                if($AppName.StartsWith($exclude) -eq $TRUE)
                                                    {
                                                    $donotwrite = $true
                                                    break
                                                    }
                                                }


                        #'=================================================================  INCLUSION ARRAY - START
#'                            Foreach($include in $includeArray) 
#'                                                {
#'                                                if($AppName.StartsWith($include) -eq $TRUE)
#'                                                    {
#'                                                    $donotwrite = $false
#'                                                    }
#'                                                }

                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-InstalledSoftware_32_And_64_v5.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-InstalledSoftware_32_And_64_v5.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'===================================================================================
#'Get-InstalledSoftware_32_And_64_v5.ps1
#' All Applications, withOUT the default Exclusion Array, the inclusion array is being ignored
#' This version takes an OutFile
#'===================================================================================

Function Get-SoftwareList_v5
{
Param(
    [Parameter(Mandatory=$true)]
    [string[]]$Computername,
    [Parameter(Mandatory=$true)]
    [string] $outfile
)

#'===================================================================================USAGE
#'Get-SoftwareList -Computername &lt;Computername&gt;
#'===================================================================================

#Registry Hives

$Object =@()

#'$excludeArray = ("Security Update for Windows",
#'"Update for Windows",
#'"Update for Microsoft .NET",
#'"Security Update for Microsoft",
#'"Hotfix for Windows",
#'"Hotfix for Microsoft .NET Framework",
#'"Hotfix for Microsoft Visual Studio 2007 Tools",
#'"Hotfix")

$excludeArray = ("whateverXXX")
#'=================================================================  INCLUSION ARRAY
$includeArray = ("Adobe")
#'=================================================================  INCLUSION ARRAY
[long]$HIVE_HKROOT = 2147483648
[long]$HIVE_HKCU = 2147483649
[long]$HIVE_HKLM = 2147483650
[long]$HIVE_HKU = 2147483651
[long]$HIVE_HKCC = 2147483653
[long]$HIVE_HKDD = 2147483654

Foreach($EachServer in $Computername){
$Query = Get-WmiObject -ComputerName $EachServer -query "Select AddressWidth, DataWidth,Architecture from Win32_Processor" 
foreach ($i in $Query)
{
 If($i.AddressWidth -eq 64){            
 $OSArch='64-bit'
 }            
Else{            
$OSArch='32-bit'            
}
}

Switch ($OSArch)
{


 "64-bit"{
$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}
$Hive = $HIVE_HKLM
$RegKey_64BitApps_64BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_64BitOS = "Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_64BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)
{  # Loop Trhough All Returned SubKEys
ForEach ($Name in $SubKeys.sNames)
 {
$SubKey = "$RegKey_64BitApps_64BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

$donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                             Foreach($exclude in $excludeArray) 
                                                    {
                                                    if($AppName.StartsWith($exclude) -eq $TRUE)
                                                        {
                                                        $donotwrite = $true
                                                        break
                                                        }
                                                    }


                            #'=================================================================  INCLUSION ARRAY - START
    #'                         Foreach($include in $includeArray) 
#'                                                    {
#'                                                    if($AppName.StartsWith($include) -eq $TRUE)
#'                                                        {
#'                                                        $donotwrite = $false
#'                                                        }
#'                                                    }

                            #'=================================================================  INCLUSION ARRAY - END
                            if ($donotwrite -eq $false) 
                                        {                        
                                        $Object += New-Object PSObject -Property @{
                                        Appication = $AppName;
                                        Architecture  = "64-BIT";
                                        ServerName = $EachServer;
                                        Version = $Version;
                                        Publisher= $Publisher;
                                        }
                          }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




}

  }}

 

#############################################################################

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_64BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{

  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {

    $SubKey = "$RegKey_32BitApps_64BitOS\$Name"

$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

         
                             

 $donotwrite = $false
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
if($AppName.length -gt "0"){

                        Foreach($exclude in $excludeArray) 
                                                {
                                                if($AppName.StartsWith($exclude) -eq $TRUE)
                                                    {
                                                    $donotwrite = $true
                                                    break
                                                    }
                                                }


                        #'=================================================================  INCLUSION ARRAY - START
#'                            Foreach($include in $includeArray) 
#'                                                {
#'                                                if($AppName.StartsWith($include) -eq $TRUE)
#'                                                    {
#'                                                    $donotwrite = $false
#'                                                    }
#'                                                }

                        #'=================================================================  INCLUSION ARRAY - END
                        if ($donotwrite -eq $false) 
                                    {                        
                                    $Object += New-Object PSObject -Property @{
                                                                                Appication = $AppName;
                                                                                Architecture  = "32-BIT";
                                                                                ServerName = $EachServer;
                                                                                Version = $Version;
                                                                                Publisher= $Publisher;
                                                                                }
                                     }
                           }
#'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 

    }

 

}

 

} #End of 64 Bit

######################################################################################

###########################################################################################

 

"32-bit"{

 

$RegProv = GWMI -Namespace "root\Default" -list -computername $EachServer| where{$_.Name -eq "StdRegProv"}

$Hive = $HIVE_HKLM

$RegKey_32BitApps_32BitOS = "Software\Microsoft\Windows\CurrentVersion\Uninstall"

#############################################################################

# Get SubKey names

$SubKeys = $RegProv.EnumKey($HIVE, $RegKey_32BitApps_32BitOS)

# Make Sure No Error when Reading Registry

if ($SubKeys.ReturnValue -eq 0)

{  # Loop Through All Returned SubKEys

  ForEach ($Name in $SubKeys.sNames)

  {
$SubKey = "$RegKey_32BitApps_32BitOS\$Name"
$ValueName = "DisplayName"
$ValuesReturned = $RegProv.GetStringValue($Hive, $SubKey, $ValueName)
$AppName = $ValuesReturned.sValue
$Version = ($RegProv.GetStringValue($Hive, $SubKey, "DisplayVersion")).sValue 
$Publisher = ($RegProv.GetStringValue($Hive, $SubKey, "Publisher")).sValue 

if($AppName.length -gt "0"){

$Object += New-Object PSObject -Property @{
            Appication = $AppName;
            Architecture  = "32-BIT";
            ServerName = $EachServer;
            Version = $Version;
            Publisher= $Publisher;
           }
           }

  }}

}#End of 32 bit

} # End of Switch

}

#$AppsReport

$column1 = @{expression="ServerName"; width=15; label="Name"; alignment="left"}
$column2 = @{expression="Architecture"; width=10; label="32/64 Bit"; alignment="left"}
$column3 = @{expression="Appication"; width=80; label="Appication"; alignment="left"}
$column4 = @{expression="Version"; width=15; label="Version"; alignment="left"}
$column5 = @{expression="Publisher"; width=30; label="Publisher"; alignment="left"}

#'"#"*80
#'"Installed Software Application Report"
#'"Numner of Installed Application count : $($object.count)"
#'"Generated $(get-date)"
#'"Generated from $(gc env:computername)"
#'"#"*80


$object |Format-Table $column1, $column2, $column3 ,$column4, $column5
#' $object|Out-GridView 
$object| select * | Export-Csv -Append -NoTypeInformation -Path $outfile

}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_browser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_Get_DefaultBrowser_from_list_of_remote_computers.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_browser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_Get_DefaultBrowser_from_list_of_remote_computers.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'NOTE info in:
'https://newoldthing.wordpress.com/2007/03/23/how-does-your-browsers-know-that-its-not-the-default-browser/



cls

$computers = Get-Content 'computers.txt';


$text = Get-Date -format yyyy_M_d_h_m_s
$text | Set-Content 'computers_defaultBrowser.txt'

foreach ($computer in $computers) {
                                    $Value = 'null'
                                    Write-Host $computer
                                    $computer | Add-Content 'computers_defaultBrowser.txt'

                                    $ComputerIsThere = Test-Connection -Computername $computer -BufferSize 16 -Count 1 -Quiet

                                    if ($ComputerIsThere -eq "True")
                                        {
                                            Get-Service -ComputerName $computer -Name RemoteRegistry | Start-Service
									        $Registry = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $computer)
									        $RegistryKey = $Registry.OpenSubKey("SOFTWARE\\Classes\\http\\shell\\open\\command")
									        #Get (Default) Value
									        $Value = $RegistryKey.GetValue("")
 
									        $Value
                                            $Value | Add-Content 'computers_defaultBrowser.txt'
                                        }
                                    else
                                        {
                                        $Value = "$computer ' is not there'" 
                                        Write-Host $Value
                                        $Value | Add-Content 'computers_defaultBrowser.txt'
                                        }


                                    } </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_calculations</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Measure-Object_sum_average_first_last_Example</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_calculations</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Measure-Object_sum_average_first_last_Example</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#requires -version 5.0

&lt;#
JSON Processing script for Toolmaking book

Process the directory of JSON files and create a summary report in the
form of an object with these properties:

    Number of files processed
    Total number of items processed
    Average number of items processed
    Total number of Errors
    Average number of Errors
    Total number of Warnings
    Average number of Warnings
    StartDate (the earliest run date value)
    EndDate (the last run date value)

#&gt;

[cmdletbinding()]
Param(
[Parameter(Position = 0, Mandatory, HelpMessage = "Enter the path with the json test data")]
[ValidateNotNullorEmpty()]    
[string]$Path
)

Write-Verbose "Starting $($MyInvocation.MyCommand)"

Write-Verbose "Processing files from $Path"

$files = Get-ChildItem -Path $path -Filter *.dat

Write-Verbose "Found $($files.count) files."
$data = foreach ($file in $files) {
    Write-Verbose "Converting $($file.name)"
    Get-Content -Path $file.fullname | ConvertFrom-Json |
    Select-Object @{Name="Date";Expression={$_.RunDate -as [datetime]}},
    Errors,Warnings,@{name = "ItemCount"; expression = {$_.'Items processed'}}
}

#sort the data to get the first and last dates
$sorted = $data | Sort-Object Date 
$first =  $sorted[0].Date
$last = $sorted[-1].Date

Write-Verbose "Measuring data"
# The $stats variable will be an array of measurements for each property
$stats = $data | Measure-Object errors,warnings,ItemCount -sum -average

Write-Verbose "Creating summary result"
[PSCustomObject]@{
    NumberFiles = $data.count
    TotalItemsProcessed = $stats[2].sum
    AverageItemsProcessed = $stats[2].Average
    TotalErrors = $stats[0].sum
    AverageErrors = $stats[0].average
    TotalWarnings = $stats[1].sum
    AverageWarnings = $stats[1].Average
    StartDate = $first
    EndDate = $last
}

Write-Verbose "Ending $($MyInvocation.MyCommand)"

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-ComputerModel.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-ComputerModel.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://gallery.technet.microsoft.com/scriptcenter/Get-ComputerModel-Get-6f430d83

function Get-ComputerModel
{
&lt;#
.SYNOPSIS
   Get model of remote computer.

.DESCRIPTION
    This function will get the model and Manufacturer of a remote computer by using the "get-wmiobject Win32_ComputerSystem" command.

.EXAMPLE
   Get-ComputerModel -Computername computer1

   Get's the model for computer1.

.EXAMPLE
   Get-ComputerModel -Computername computer1 -credential (Get-Credential)

   Get's the model for computer1 and prompts for the credentials to use.

.EXAMPLE
   Get-ComputerModel -Computername computer1 | Format-Table

   Get's the model for computer1 and formats output into table.

.EXAMPLE
   Get-ComputerModel -Computername Computer1,Computer2 | Export-Csv -Path C:\test.csv -NoTypeInformation

   Get's the model for computer1 and computer2 and exports it to a CSV file.

.EXAMPLE
   Get-ADDomainController -Filter * | Get-ComputerModel

   This examples get's the computer models of all DC's.  It requires the get-addomaincontroller Active Directory module.

.NOTES

.LINK
    
#&gt;
    [CmdletBinding()]
    Param
    (
        #The Computername/IP Address of the remote computer.
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromPipeline=$true,
                   Position=0)]
        [Alias('Name', 'IPv4Address', 'CN')]
        [string[]]$Computername,

        [Parameter(Mandatory=$False)]
        [System.Management.Automation.PSCredential]$credential
    )

    Begin
    {
    }
    Process
    {

    $Computername | ForEach-Object {
        $parms = @{}
        if ($credential) { $parms.Add('Credential', $credential)}

        $Results = @{"Status"=""
                        "Name"="$_"
                        "Manufacturer"=""
                        "Model"=""}     

        Write-Verbose -Message "Checking to see if $_ is online..."
        If (Test-Connection -ComputerName $_ -Count 1 -Quiet -BufferSize 100 ) {       
            try {
                Write-Verbose -Message "Running WMI query on $_"
                $computerResults = Get-WMIObject -ComputerName $_ -class Win32_ComputerSystem @parms -ErrorAction Stop

                $Results["Status"] = "Online"
                $Results["Manufacturer"] = "$($computerResults.Manufacturer)"
                $Results["Model"] = $($computerResults.Model)

            } catch {
                $Results["Status"] = "Failed: $($_.Exception.Message)"
            }
        }
        Else {
            $Results["Status"] = "Failed: $Computername is Offline."
        }

        return New-Object PSobject -Property $Results | Select-Object Name, Model, Manufacturer, Status
    }


    }
    End
    {
    }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Local_Administrators__get_from_REMOTE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Local_Administrators__get_from_REMOTE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function get-localadmins{
  [cmdletbinding()]
  Param(
  [string]$computerName
  )
  $group = get-wmiobject win32_group -ComputerName $computerName -Filter "LocalAccount=True AND SID='S-1-5-32-544'"
  $query = "GroupComponent = `"Win32_Group.Domain='$($group.domain)'`,Name='$($group.name)'`""
  $list = Get-WmiObject win32_groupuser -ComputerName $computerName -Filter $query
  $list | %{$_.PartComponent} | % {$_.substring($_.lastindexof("Domain=") + 7).replace("`",Name=`"","\")}
}


get-localadmins it-3013</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Local_Administrators_JPHSA</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Local_Administrators_JPHSA</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get-List_LocalAdmins_for_Remote_Computers_given_List_v2.ps1





#'=============================================================================================================

$Computers = get-content C:\DATA\2018_08_24__computers.txt;

foreach ($computer in $Computers) {
    #verify computer is online
    if (Test-Connection -ComputerName $Computer -Count 2 -Quiet) {					#' &lt;===========HERE is the PING

        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\2018_08_24__RespondToPing.txt


        Try {
        	#'=====================================================================================Do Something

              $theTargetFolderAndFileName = "C:\DATA\2018_08_24__LocalAdmins.csv"

              $computerName= $computer

              $group = get-wmiobject win32_group -ComputerName $computerName -Filter "LocalAccount=True AND SID='S-1-5-32-544'"
              $query = "GroupComponent = `"Win32_Group.Domain='$($group.domain)'`,Name='$($group.name)'`""
              $list = Get-WmiObject win32_groupuser -ComputerName $computerName -Filter $query
              $computerName
              $list | %{$_.PartComponent} | % {$_.substring($_.lastindexof("Domain=") + 7).replace("`",Name=`"","\")}

              $step1 = ($list | %{$_.PartComponent} | % {$_.substring($_.lastindexof("Domain=") + 7).replace("`",Name=`"","\")})


              $step2 = ForEach ($record in $step1)
                {
                    [PSCustomObject]@{
                                        Domain_Admin = $record.Replace('"','')
                                        Computer = $computerName
                                     }#EndPSCustomObject
                } 

              $step2 | Select-Object -Property Domain_Admin, Computer  | Export-Csv -Append -Path $theTargetFolderAndFileName
            #'=====================================================================================END Do Something
        }
        Catch {
            Write-host "Can't get Local Admin data from $($Computer.ToUpper()). %($_.Exception.Message)." -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\2018_08_24__Exceptions.txt
        }
    } #if can not ping
    else {
        	write-warning "responded to PING:"$computer 
			Add-Content -value $computer -path C:\DATA\2018_08_24__RespondToPing_NOT.txt
    }
} #foreach computer


$wsh = new-object -com wscript.shell
$wsh.Popup("Done",10,"PowerShell Automation",0+64)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Login__get_LoginInstancesFunction</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Login__get_LoginInstancesFunction</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USAGE:

&gt;Get-LoginInstance -ComputerName "LT-103111" -StartDate (Get-Date).AddDays(-1) -Verbose  | SELECT UserName, LoginTime, SessionType, LoginIpAddress



'Get-LoginInstance - Retrieve Local and Remote Computer Login/Logout Instances
https://gallery.technet.microsoft.com/scriptcenter/Get-LoginInstance-Retrieve-6437b1af

#'This script contains a function (Get-LoginInstance), 
#'    as well as two sub-functions (Get-LoginData and Get-LogoutData), 
#'    which are used to retrieve login and logout events from the Security event log on a local or remote computer, 
#'    and join them together to display login instance data.  
#'    Please use the native help bundled with the cmdlet for more information on ways to utilize/run this function.
#'
#'Additionally, please note that this cmdlet is reliant upon Remote Event Log Management, 
#'    which may need to be enabled on the target machine(s), 
#'    and due to its use of Get-WinEvent, can only work on Vista, 
#'    Server 2008 R2 and later Windows releases for consumer and enterprise markets, respectively.
#'
#'UPDATE - 10/23/14: I've revised the cmdlet to fix a few different areas - 
#'                    please download the latest version of this if you have a previous version of the script.  
#'                    Changes made to the latest version include:
#'
#'New sorting algorithm to ensure all login instances 
#'        (logins and logouts) and logins without corresponding logouts 
#'        appear in final collection, regardless of OS, account domain, etc.
#'Official support of PowerShell versions 2, 3 and 4 - Get-LoginInstance has now been tested and confirmed to work in all of those versions
#'Remove Desktop Window Manager (DWM) logins from final collection if present
#'Minor help file tweaks
=================================================================================
    -------------------------- EXAMPLE 1 --------------------------
    
    PS C:\&gt;Get-LoginInstance
    
    Retrieve all available login instances from the local computer within 
    the past week.
    
    
    
    
    -------------------------- EXAMPLE 2 --------------------------
    
    PS C:\&gt;Get-LoginInstance -ComputerName "GSR-242" -StartDate (Get-Date).AddMonths(-1) -Verbose
    
    Retrieve all available login instances from remote computer "GSR-242" 
    within the past month, displaying verbose output as well.

=================================================================================

#PowerShell Script Containing Function(s) Used to Retrieve Login &amp; Logout Instances from a Local or Remote Computer
#Developer: Andrew Saraceni (saraceni@wharton.upenn.edu)
#Date: 10/23/14

function Get-LoginInstance
{
    &lt;#
    .SYNOPSIS
    Retrieves login and logout instances from a local or remote computer.
    .DESCRIPTION
    Retrieves all interactive and remote-based logins from a specific 
    computer, then obtains all logouts and joins the instances together 
    via processing.  This information is retrieved from the Security 
    event logs on the computer, and thus can only pull data from logs 
    that have yet to turn over.

    Without parameters, a Get-LoginInstance command retrieves all logins 
    and logouts from the local computer within the past week.
    .PARAMETER ComputerName
    Specifies the computer from which to pull the login/logout 
    information.  The default value for this is the local computer.
    .PARAMETER StartDate
    Specifies the earliest (i.e. oldest) date from which to retrieve 
    logins/logouts.  The default value for this is one week before the 
    current date: (Get-Date).AddDays(-7)
    .PARAMETER EndDate
    Specifies the most recent date from which to retrieve logins/logouts.  
    The default value for this is the current date.
    .EXAMPLE
    Get-LoginInstance
    Retrieve all available login instances from the local computer within 
    the past week.
    .EXAMPLE
    Get-LoginInstance -ComputerName "GSR-242" -StartDate (Get-Date).AddMonths(-1) -Verbose
    Retrieve all available login instances from remote computer "GSR-242" 
    within the past month, displaying verbose output as well.
    .NOTES
    This cmdlet makes use of the Get-WinEvent cmdlet, which is only 
    available on Windows Vista, Windows Server 2008 R2 and later consumer 
    and enterprise verisons of Windows, respectively.

    Additionally, Remote Event Log Management will need to be enabled 
    via your firewall.  The following CMD prompt command can enable this 
    on a local computer:

    netsh advfirewall firewall set rule group=”remote event log management” new enable=yes
    #&gt;
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,Mandatory=$false)]
        [String]$ComputerName = $env:COMPUTERNAME,
        [Parameter(Position=1,Mandatory=$false)]
        [DateTime]$StartDate = (Get-Date).AddDays(-7),
        [Parameter(Position=2,Mandatory=$false)]
        [DateTime]$EndDate = (Get-Date)
    )

    function Get-LoginData
    {
        param($ComputerName,$StartDate,$EndDate)
        
        Write-Verbose "Getting Login Data from $ComputerName..."
        [Int32[]]$loginID = @(4624)

        try
        {
            $loginEvents = Get-WinEvent -ComputerName $ComputerName -FilterHashtable @{ LogName="Security"; ID=$loginID; StartTime=$StartDate; EndTime=$EndDate } -ErrorAction Stop
        }
        catch
        {
            Set-Variable -Name catchError -Value $_
            if ($catchError -match "No events were found that match the specified selection criteria.")
            {
                Write-Warning "No Login Events Found - Ending Login Collection"
            }
        }

        Write-Verbose "Converting Logins to XML &amp; Parsing Data for Better Readability..."
        foreach ($loginEvent in $loginEvents)
        {
            $xmlLoginEvent = [Xml]$loginEvent.ToXml()

            for ($i=0; $i -lt $xmlLoginEvent.Event.EventData.Data.Count; $i++)
            {            
                Add-Member -InputObject $loginEvent -MemberType NoteProperty -Name $xmlLoginEvent.Event.EventData.Data[$i].Name -Value $xmlLoginEvent.Event.EventData.Data[$i]."#Text" -Force
            }
        }

        $revisedLoginEvents = @()
        $xmlLoginEvents = $loginEvents | Where-Object { (($_.LogonType -eq "2") -or ($_.LogonType -eq "10")) -and ($_.TargetDomainName -ne "Window Manager") } | Select-Object -Property *
        foreach ($xmlLoginEvent in $xmlLoginEvents)
        {
            switch ($xmlLoginEvent.LogonType)
            {
                "2" {
                    $xmlLoginEvent.LogonType = "Login-Interactive"
                }
                "10" {
                    $xmlLoginEvent.LogonType = "Login-Remote"
                }
            }
            
            if (($xmlLoginEvent.IpAddress -eq "127.0.0.1") -or ($xmlLoginEvent.IpAddress -eq "::1"))
            {
                $xmlLoginEvent.IpAddress = $null
            }

            if ($xmlLoginEvent.IpPort -eq "0")
            {
                $xmlLoginEvent.IpPort = $null
            }
            
            $revisedLoginEvents += $xmlLoginEvent
        }
        
        return $revisedLoginEvents
    }

    function Get-LogoutData
    {
        param($ComputerName,$StartDate,$EndDate)

        Write-Verbose "Getting Logout Data from $ComputerName..."
        [Int32[]]$logoutID = @(4647)

        try
        {
            $logoutEvents = Get-WinEvent -ComputerName $ComputerName -FilterHashtable @{ LogName="Security"; ID=$logoutID; StartTime=$startDate; EndTime=$endDate } -ErrorAction Stop
        }
        catch
        {
            Set-Variable -Name catchError -Value $_
            if ($catchError -match "No events were found that match the specified selection criteria.")
            {
                Write-Warning "No Logout Events Found - Ending Logout Collection"
            }
        }

        Write-Verbose "Converting Logouts to XML &amp; Parsing Data for Better Readability..."
        foreach ($logoutEvent in $logoutEvents)
        {
            $xmlLogoutEvent = [Xml]$logoutEvent.ToXml()

            for ($i=0; $i -lt $xmlLogoutEvent.Event.EventData.Data.Count; $i++)
            {            
                Add-Member -InputObject $logoutEvent -MemberType NoteProperty -Name $xmlLogoutEvent.Event.EventData.Data[$i].name -Value $xmlLogoutEvent.Event.EventData.Data[$i]."#Text" -Force
            }
        }
        
        $revisedLogoutEvents = @()
        $xmlLogoutEvents = $logoutEvents | Select-Object -Property *
        foreach ($xmlLogoutEvent in $xmlLogoutEvents)
        {
            Add-Member -InputObject $xmlLogoutEvent -MemberType NoteProperty -Name "WorkstationName" -Value $ComputerName -Force

            $revisedLogoutEvents += $xmlLogoutEvent
        }
        
        return $revisedLogoutEvents
    }

    $finalLoginEvents = Get-LoginData -ComputerName $ComputerName -StartDate $StartDate -EndDate $EndDate
    $finalLogoutEvents = Get-LogoutData -ComputerName $ComputerName -StartDate $StartDate -EndDate $EndDate

    Write-Verbose "Creating Final Collection of Revised Login and Logout Instance Data..."
    $loginInstances = @()

    foreach ($finalLoginEvent in $finalLoginEvents)
    {
        $instanceProperties = @{
            ComputerName = $finalLoginEvent.WorkstationName
            UserName = $finalLoginEvent.TargetUserName
            AccountDomain = $finalLoginEvent.TargetDomainName
            LoginTime = $finalLoginEvent.TimeCreated
            LogoutTime = $null
            TargetLogonID = $finalLoginEvent.TargetLogonID
            Days = $null
            Hours = $null
            Minutes = $null
            Seconds = $null
            SessionType = $finalLoginEvent.LogonType
            LoginIpAddress = $finalLoginEvent.IpAddress
            LoginIpPort = $finalLoginEvent.IpPort
            LogonGuid = $finalLoginEvent.LogonGuid
        }

        $loginInstance = New-Object -TypeName PSObject -Property $instanceProperties

        foreach ($finalLogoutEvent in $finalLogoutEvents)
        {
            if (($finalLogoutEvent.WorkstationName -eq $finalLoginEvent.WorkstationName) -and ($finalLogoutEvent.TargetUserName -eq $finalLoginEvent.TargetUserName) -and ($finalLogoutEvent.TargetLogonID -eq $finalLoginEvent.TargetLogonID))
            {
                $loginInstance.LogoutTime = $finalLogoutEvent.TimeCreated
                $loginInstance.Days = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Days
                $loginInstance.Hours = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Hours
                $loginInstance.Minutes = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Minutes
                $loginInstance.Seconds = (New-TimeSpan -Start $finalLoginEvent.TimeCreated -End $finalLogoutEvent.TimeCreated).Seconds
            }
        }

        $loginInstances += $loginInstance
    }

    $fullLoginInstances = $loginInstances | Where-Object { $_.LogoutTime -ne $null }
    $partialLoginInstances = $loginInstances | Where-Object { $_.LogoutTime -eq $null } | Sort-Object -Property LoginTime -Descending -Unique

    $fullLoginInstanceLoginTimes = $fullLoginInstances | Select-Object -ExpandProperty LoginTime
    $filteredPartialLoginInstances = @()
    
    foreach ($partialLoginInstance in $partialLoginInstances)
    {
        if ($fullLoginInstanceLoginTimes -notcontains $partialLoginInstance.LoginTime)
        {
            $filteredPartialLoginInstances += $partialLoginInstance
        }
    }

    $finalLoginInstances = @($fullLoginInstances) + @($filteredPartialLoginInstances) | Sort-Object -Property LoginTime -Descending -Unique

    return $finalLoginInstances | Select-Object -Property ComputerName, UserName, AccountDomain, LoginTime, LogoutTime, TargetLogonID, Days, Hours, Minutes, Seconds, SessionType, LoginIpAddress, LoginIpPort, LogonGuid
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_info</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Profile_function_toRemoveLocalUserProfile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_info</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Profile_function_toRemoveLocalUserProfile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gallery.technet.microsoft.com/scriptcenter/Remove-UserProfile-Remove-96e27a3b

#'This script contains a function (Remove-UserProfile) which is used to remove user profiles, 
#'    and additional contents of the C:\Users directory (if specified) on a local computer.  
#' Parameters exist to "Exclude" one or more user profiles from being removed, 
#'    remove only profiles "Before" a date when they have not been accessed, 
#'    and to invoke a "DirectoryCleanup" to remove additional files/folders (i.e. non-profiles) within the C:\Users directory.  
#'    Per profile, the profile object itself and all associated registry keys are removed 
#'        if the profile meets the criteria defined via the cmdlet's parameters.
#'
#'This cmdlet requires adminisrative privileges to run effectively. 
#'    Furthermore, this cmdlet is not intended to be used on Virtual Desktop Infrastructure (VDI) environments 
#'    or others which utilize persistent storage on alternate disks, 
#'    or any configurations which utilize another directory other than C:\Users to store user profiles.  
#'This cmdlet is designed to function with PowerShell versions 2 and above.

'USAGE
-------
#'Remove all non-active and non-system designated user profiles from the local computer. 
Remove-UserProfile 
 
#'Remove all non-active and non-system designated user profiles not used within the past month, displaying verbose output as well. 
Remove-UserProfile -Before (Get-Date).AddMonths(-1) -Verbose 
 
#'Remove all non-active and non-system designated user profiles except "labadmin" and "desktopuser", and remove additional non-profile files/folders within C:\Users as well. 
Remove-UserProfile -Exclude @("labadmin", "desktopuser") -DirectoryCleanup 
 
#'Invoke Remove-UserProfile on a Remote Computer 
$scriptBlock = { 
    function Remove-UserProfile 
    { 
        ... 
    } 
 
    Remove-UserProfile 
} 
 
Invoke-Command -ComputerName "GWS-F20" -ScriptBlock $scriptBlock 
 
#'Invoke Remove-UserProfile on Many Remote Computers, Passing in Arguments 
#'This Example Utilizes Windows Workflow Foundation Technology, Available in PowerShell V3 and Above 
$scriptBlock = { 
    function Remove-UserProfile 
    { 
        ... 
    } 
 
    Remove-UserProfile -Exclude $args 
} 
 
$compArray = @() 
Get-Content -Path "\\path\to\computers.txt" | ForEach-Object { $compArray += $_ } 
 
$excludedList = @("labadmin", "desktopuser") 
 
Invoke-Command -ComputerName $compArray -ScriptBlock $scriptBlock -ArgumentList $excludedList -ThrottleLimit 50

==================================================================================================================

#PowerShell Script Containing Function Used to Remove User Profiles &amp; Additional Remnants of C:\Users Directory
#Developer: Andrew Saraceni (saraceni@wharton.upenn.edu)
#Date: 12/22/14

#Requires -Version 2.0

function Remove-UserProfile
{
    &lt;#
    .SYNOPSIS
    Removes user profiles and additional contents of the C:\Users 
    directory if specified.
    .DESCRIPTION
    Gathers a list of profiles to be removed from the local computer, 
    passing on exceptions noted via the Exclude parameter and/or 
    profiles newer than the date specified via the Before parameter.  
    If desired, additional files and folders within C:\Users can also 
    be removed via use of the DirectoryCleanup parameter.

    Once gathered, miscellaneous items are first removed from the 
    C:\Users directory if specified, followed by the profile objects 
    themselves and all associated registry keys per profile.  A listing 
    of current items within the C:\Users directory is returned 
    following the profile removal process.
    .PARAMETER Exclude
    Specifies one or more profile names to exclude from the removal 
    process.
    .PARAMETER Before
    Specifies a date from which to remove profiles before that haven't 
    been accessed since that date.
    .PARAMETER DirectoryCleanup
    Removes additional files/folders (i.e. non-profiles) within the 
    C:\Users directory.
    .EXAMPLE
    Remove-UserProfile
    Remove all non-active and non-system designated user profiles 
    from the local computer.
    .EXAMPLE
    Remove-UserProfile -Before (Get-Date).AddMonths(-1) -Verbose
    Remove all non-active and non-system designated user profiles 
    not used within the past month, displaying verbose output as well.
    .EXAMPLE
    Remove-UserProfile -Exclude @("labadmin", "desktopuser") -DirectoryCleanup
    Remove all non-active and non-system designated user profiles 
    except "labadmin" and "desktopuser", and remove additional 
    non-profile files/folders within C:\Users as well.
    .NOTES
    Even when not specifying the Exclude parameter, the following 
    profiles are not removed when utilizing this cmdlet:
    C:\Windows\ServiceProfiles\NetworkService 
    C:\Windows\ServiceProfiles\LocalService 
    C:\Windows\system32\config\systemprofile 
    C:\Users\Public
    C:\Users\Default

    Aside from the original profile directory (within C:\Users) 
    itself, the following registry items are also cleared upon 
    profile removal via WMI:
    "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\{SID of User}"
    "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileGuid\{GUID}" SidString = {SID of User}
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\{SID of User}"

    Additionally, any currently loaded/in use profiles will not be 
    removed.  Regarding miscellaneous non-profile items, hidden items 
    are not enumerated or removed from C:\Users during this process.

    This cmdlet requires adminisrative privileges to run effectively.
      
    This cmdlet is not intended to be used on Virtual Desktop 
    Infrastructure (VDI) environments or others which utilize 
    persistent storage on alternate disks, or any configurations 
    which utilize another directory other than C:\Users to store 
    user profiles.
    #&gt;
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,Mandatory=$false)]
        [String[]]$Exclude,
        [Parameter(Position=1,Mandatory=$false)]
        [DateTime]$Before,
        [Parameter(Position=2,Mandatory=$false)]
        [Switch]$DirectoryCleanup
    )

    Write-Verbose "Gathering List of Profiles on $env:COMPUTERNAME to Remove..."

    $userProfileFilter = "Loaded = 'False' AND Special = 'False'"
    $cleanupExclusions = @("Public", "Default")

    if ($Exclude)
    {
        foreach ($exclusion in $Exclude)
        {
            $userProfileFilter += "AND NOT LocalPath LIKE '%$exclusion'"
            $cleanupExclusions += $exclusion
        }
    }

    if ($Before)
    {
        $userProfileFilter += "AND LastUseTime &lt; '$Before'"

        $keepUserProfileFilter = "Special = 'False' AND LastUseTime &gt;= '$Before'"
        $profilesToKeep = Get-WmiObject -Class Win32_UserProfile -Filter $keepUserProfileFilter -ErrorAction Stop

        foreach ($profileToKeep in $profilesToKeep)
        {
            try
            {
                $userSID = New-Object -TypeName System.Security.Principal.SecurityIdentifier($($profileToKeep.SID))
                $userName = $userSID.Translate([System.Security.Principal.NTAccount])
                
                $keepUserName = $userName.Value -replace ".*\\", ""
                $cleanupExclusions += $keepUserName
            }
            catch [System.Security.Principal.IdentityNotMappedException]
            {
                Write-Warning "Cannot Translate SID to UserName - Not Adding Value to Exceptions List"
            }
        }
    }

    $profilesToDelete = Get-WmiObject -Class Win32_UserProfile -Filter $userProfileFilter -ErrorAction Stop

    if ($DirectoryCleanup)
    {
        $usersChildItem = Get-ChildItem -Path "C:\Users" -Exclude $cleanupExclusions

        foreach ($usersChild in $usersChildItem)
        {
            if ($profilesToDelete.LocalPath -notcontains $usersChild.FullName)
            {    
                try
                {
                    Write-Verbose "Additional Directory Cleanup - Removing $($usersChild.Name) on $env:COMPUTERNAME..."
                    
                    Remove-Item -Path $($usersChild.FullName) -Recurse -Force -ErrorAction Stop
                }
                catch [System.InvalidOperationException]
                {
                    Write-Verbose "Skipping Removal of $($usersChild.Name) on $env:COMPUTERNAME as Item is Currently In Use..."
                }
            }
        }
    }

    foreach ($profileToDelete in $profilesToDelete)
    {
        Write-Verbose "Removing Profile $($profileToDelete.LocalPath) &amp; Associated Registry Keys on $env:COMPUTERNAME..."
                
        Remove-WmiObject -InputObject $profileToDelete -ErrorAction Stop
    }

    $finalChildItem = Get-ChildItem -Path "C:\Users" | Select-Object -Property Name, FullName, LastWriteTime
                
    return $finalChildItem
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_Reboot_Restart</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-PendingReboot_USAGE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_Reboot_Restart</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-PendingReboot_USAGE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get-PendingReboot_USAGE.ps1


$testcomputers = Get-Content -Path 'C:\DATA\2018_06_28_computers.txt'


#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\2018_06_28_ALL_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\2018_06_28_ALL_DeadPCs.txt
		}
	}

cls

$goodComputerList = Get-Content 'C:\DATA\2018_06_28_ALL_RespondToPing.txt';

Get-PendingReboot -Computer $goodComputerList -ErrorLog C:\DATA\2018_06_28__PendingRebootReport_ERRORS.txt | Export-Csv C:\DATA\2018_06_28__PendingRebootReport.csv -NoTypeInformation 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Computer_Remote_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Post_image_steps_for_new_Win10_computers.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Computer_Remote_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Post_image_steps_for_new_Win10_computers.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Post_image_steps_for_new_Win10_computers.ps1

Set-Location C:\DATA\PowerShellScripts

$theOriginalComputerName = 'DESKTOP-c0ebkmo'
$theNewComputerName = 'IT-0997'

#' for the username use the format: jphsa01\ggarson
$DomanCred = Get-Credential -Credential jphsa01\ggarson

#' for the username use the format: $theOriginalComputerName\administrator
#'$LocalCred_OrigComputer = Get-Credential
$LocalCred_OrigComputer = Get-Credential -Credential $theOriginalComputerName\administrator

#' for the username use the format: $theNewComputerName\administrator
#'$LocalCred_NewComputer = Get-Credential
$LocalCred_NewComputer = Get-Credential -Credential $theNewComputerName\administrator
#'=============================================================================================================================

#' 0] Test connection
Test-Connection -ComputerName $theOriginalComputerName -Count 1

#' 1] Set Administrator password, 
#'    note "pspasswd" from SysInternals is in the PATH, assume that the account (U.whatever, P.abc) already exists, and is an Administrator on the computr.

#'pspasswd64 -accepteula

#'Set the password
pspasswd64 \\$theOriginalComputerName Administrator “JPHSA@Work” -u whatever -p abc123

#'Enable the Administrator
psexec \\$theOriginalComputerName -s  -u whatever -p abc123  -h -d net user "Administrator" /active:yes

#' confirm

#-=============================================Confirm that both the Administrator and whatever are administrators of the computer

psexec \\$theOriginalComputerName  -s net localgroup administrators
#'psexec \\$theOriginalComputerName  -u whatever -p abc123 -s  net localgroup administrators


#'===============================================

#' 2a] Remove the old computer from the Domain

Remove-ADComputer -Identity $theNewComputerName -Credential $DomanCred

#' 2b] RUN: SynchronizeActiveDirectoryOnAll_DC.ps1

.\SynchronizeActiveDirectoryOnAll_DC.ps1

#' 3a] Rename the computer to the old name. Assume it is not in the Domain Yet.

Rename-Computer -ComputerName $theOriginalComputerName -NewName $theNewComputerName -LocalCredential $LocalCred_OrigComputer  -Force -PassThru -Restart

#' WAIT FOR IT TO RESTART

#' 3b] run: SynchronizeActiveDirectoryOnAll_DC.ps1
.\SynchronizeActiveDirectoryOnAll_DC.ps1

#' 4a] Add the computer to the Domain

Add-Computer -ComputerName $theNewComputerName -LocalCredential $LocalCred_NewComputer –DomainName jphsa.org –Credential $DomanCred -restart -Force

#' 4b] run: SynchronizeActiveDirectoryOnAll_DC.ps1
.\SynchronizeActiveDirectoryOnAll_DC.ps1

#' 4c] Move the computer object to the correct OU

#' WAIT FOR IT TO RESTART

#' 5] Remove the original user: whatever

Invoke-Command -ComputerName $theNewComputerName  -ScriptBlock {Remove-LocalUser -Name "whatever"}

#' confirm

#'=============================================Confirm that  Administrator is and administrator of the computer, and that whatever is gone

psexec \\$theNewComputerName  -s  net localgroup administrators


#'===============================================


#'====Activate the Windows License {enter PSSession}


Enter-PSSession –ComputerName $theNewComputerName

    $key = 'PNXMC-RQGXT-KRPDY-9YY9T-8TYPF'
    slmgr -ipk $key

    powercfg.exe /hibernate off

    Set-TimeZone -Name "Central Standard Time"

Exit-PSSession
#'==========================================

Invoke-Command -ComputerName $theNewComputerName -FilePath C:\DATA\PowerShellScripts\00_AcrobatReader_MakeDefaultForNewUserProfiles_inWin10.ps1

Invoke-Command -ComputerName $theNewComputerName -FilePath C:\DATA\PowerShellScripts\000_IE_ratherThan_Edge_MakeDefaultForNewUserProfiles_inWin10.ps1
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>$Error___built_in_Variable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>$Error___built_in_Variable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'To clear it:
&gt; $Error.Clear()

'To see all the errors that have occured since it was last cleared:
&gt; $Error | % {$_.exception}

'To get basic info from First error:

=======================================Example
&gt;Get-Content C:   '{To generate error}
'OUTPUT
-------------------------------------------------------
#'Get-Content : Access to the path 'C:\DATA\PowerShellScripts' is denied.
#'At line:1 char:1
#'+ Get-Content C:
#'+ ~~~~~~~~~~~~~~
#'    + CategoryInfo          : PermissionDenied: (C:\DATA\PowerShellScripts:String) [Get-Content], UnauthorizedAccessException
#'    + FullyQualifiedErrorId : GetContentReaderUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetContentCommand


&gt;$Error.Count
'OUTPUT
-------------------------------------------------------
1



&gt;$Error[0].CategoryInfo
'OUTPUT
-------------------------------------------------------
Category   : PermissionDenied
Activity   : Get-Content
Reason     : UnauthorizedAccessException
TargetName : C:\DATA\PowerShellScripts       '{This is the folder which was selected when the code ran}
TargetType : String


&gt;$Error[0].CategoryInfo.Category
'OUTPUT
-------------------------------------------------------
PermissionDenied</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>ErrorVariable___EV</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>ErrorVariable___EV</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Get-Content C:\JUNK\doesNotExist.txt -ErrorVariable eX -ErrorAction SilentlyContinue
if ($eX.count -gt 0)
    {
         Write-Host "The Error: $eX" -foregroundcolor green
    }
-----------------------------------------------------------
$computername = 'localhost'
Try 
    {
        $evertThingIsOK = $true
 		$os = Get-WmiObject -ComputerName $computername -ErrorAction Stop -ErrorVariable eX
     }
Catch
    {
        $computername | Out-File C:\JUNK\error.txt -Append
        Write-Warning "Error trying to talk to $computername : $eV"
        $evertThingIsOK = $false
    }
if ($evertThingIsOK)
    {
    #' Do stuff
    }</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>example_StoreErrorsInFile_clearErrors</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>example_StoreErrorsInFile_clearErrors</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$ErrorActionPreference = "SilentlyContinue"
Clear-Content C:\JUNK\log.txt
$names = Get-Content C:\JUNK\ComputerList.txt
foreach ($name in $names)
    {
        $wmi = Get-WmiObject win32_operatingsystem -ComputerName $name -ErrorAction SilentlyContinue -ErrorVariable eX
        if ($eX.Count -gt 0)
            {
                Add-Content C:\JUNK\log.txt $name
                Write-Host "Error on $name" -ForegroundColor DarkMagenta
                $eX.Clear()
            }
        else
            {
                Write-Host "$name is on build " ($wmi.buildnumber)
            }
    }</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LOOP_to_Catch_and_store_Errors_in_File</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LOOP_to_Catch_and_store_Errors_in_File</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'WhichComputers_RPCServerIsUnavailable_v1.ps1

$cred1 = Get-Credential  #' Run Once

$testcomputers = Get-Content -Path 'C:\DATA\2018_06_06_run_0_List_to_TEST.txt'


#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\2018_06_06_run_0_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\2018_06_06_run_0_didNOTping.txt
		}
	}

#'=============================================================================

$servers = Get-Content  -Path 'c:\data\2018_06_06_run_0_RespondToPing.txt'
$error.Clear() 
ForEach ($server in $servers) {
  Try {

    write-host "TRY:"$server -ForegroundColor Green        
    gwmi win32_operatingsystem -computer $server -credential $cred1 -ErrorAction Stop   
    write-host "No Error:"$server -ForegroundColor Yellow  
    Add-Content -value $server -path C:\DATA\2018_06_06_run_0_WMI_is_OK.txt
    } 
  Catch {
    write-host "CATCH:"$server -ForegroundColor Red
    Add-Content -value $server -path C:\DATA\2018_06_06_run_0_RPCServerIsUnavaible.txt #'-ErrorAction Continue  
    $errorNote = $server + ", " + $Error[0].CategoryInfo.Category + ", " + $Error[0].CategoryInfo.Reason
    write-host $errorNote -ForegroundColor Red
    Add-Content -value $errorNote -path C:\DATA\2018_06_06_run_0_Errors.txt
    }
  Finally {
    $error.Clear() 
    Write-Host "errors cleared"  
    }
  }

 #' [System.Windows.MessageBox]::Show('DONE') 
 write-host "DONE!" -ForegroundColor Red



 #'gwmi win32_operatingsystem -computer LT-1036 -credential $cred1 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Event_Logs</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Event_Logs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Event_Logs</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Event_Logs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Event_Logs

#'There will be permission issues when querying certain Event Logs



#'Get list of Event Logs, on local host:

Get-WinEvent -ListLog * -ComputerName localhost | where { $_.RecordCount }

#' To just get the 'LogName' field, from the Log List, on local host:

(Get-WinEvent -ListLog * -ComputerName localhost | where { $_.RecordCount }).LogName



-------------------
Log = Application
Source = UltraVNC
Event ID = 1 
Task Category = (1)
----------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Event_Logs</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_differentTypesOfErrors_OutputEachTypeToASeperateFile_usesSubExpressionToGetTheFileNames</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Event_Logs</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_differentTypesOfErrors_OutputEachTypeToASeperateFile_usesSubExpressionToGetTheFileNames</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' Creates a file for each 'Source' of errors in the EventLog
#' Writes the errors of that type to the appropriate file
#' Targets the C:\junk folder
#' shows a count of the number of errors
#' Uses a SubExpression to get the 'name' of the error, and thus name the file



get-eventlog application -EntryType Error,Warning | Group Source | foreach {
$file = Join-Path -path C:\junk -ChildPath "$($_.name).txt"
"$($_.count) entries" | Out-File -FilePath $file
$_.group | foreach {
 $_ | Select TimeGenerated,EntryType | Out-File -FilePath $file -Append
 $_ | Select -ExpandProperty Message | Out-File -FilePath $file -Append
}
Get-Item $file
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Event_Logs</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_Events_in_Time_Window</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Event_Logs</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_Events_in_Time_Window</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'=========START Get-WinEventWithin.ps1 =============================================================
param([string]$ComputerName = 'localhost',[datetime]$StartTimestamp,[datetime]$EndTimestamp)


#'Get-WinEvent lets you query ALL event log sources, and is faster than Get-EventLog
#'  "where { $_.RecordCount }" gets rid of all the event logs with no events
$Logs = (Get-WinEvent -ListLog * -ComputerName $ComputerName | where { $_.RecordCount }).LogName

$FilterTable = @{
	                'StartTime' = $StartTimestamp
	                'EndTime' = $EndTimestamp
	                'LogName' = $Logs
                }
		
Get-WinEvent -ComputerName $ComputerName -FilterHashtable $FilterTable -ErrorAction 'SilentlyContinue'

#'=========END Get-WinEventWithin.ps1 =============================================================

#'USAGE

 .\Get-WinEventWithin.ps1 -StartTimestamp '11-18-16 04:00' -EndTimestamp '11-18-16 05:10' 

 #'To get count of the events
 (.\Get-WinEventWithin.ps1 -StartTimestamp '11-18-16 04:00' -EndTimestamp '11-18-16 05:10').Count</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Event_Logs</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_most_recent_Event_Errors</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Event_Logs</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_most_recent_Event_Errors</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
$filename = "$(Get-Date -Format "yyyy_M_d_h_m_s")-Error_12072.csv"
get-eventlog -LogName application -Newest 10000 -EntryType Error | where {$_.EventID -eq "12072"} | Export-Csv -Append -NoType -Path "$Env:userprofile\Desktop\PS\$filename"
----------------------------------------------------------------------------------------------------
get-eventlog -LogName system -Newest 10 -EntryType Error		'From the 'system' event log

'OUTPUT
==========
#'
#'   Index Time          EntryType   Source                 InstanceID Message                                                                                             
#'   ----- ----          ---------   ------                 ---------- -------                                                                                             
#'    2653 Oct 05 18:53  Error       Service Control M...   3221232495 The Connected Devices Platform Service service terminated with the following error: ...             
#'    2650 Oct 05 18:51  Error       DCOM                        10016 The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may no...
#'    2609 Oct 02 19:42  Error       DCOM                        10016 The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may no...
#'    2599 Oct 02 18:12  Error       Service Control M...   3221232495 The Connected Devices Platform Service service terminated with the following error: ...             
#'    2596 Oct 02 18:10  Error       DCOM                        10016 The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may no...


'Format it better
&gt;get-eventlog -LogName system -Newest 10 -EntryType Error | Select Time,Source,Message
'OUPUT
===========
#'Time Source                  Message                                                                                                                                     
#'---- ------                  -------                                                                                                                                     
#'     Service Control Manager The Connected Devices Platform Service service terminated with the following error: ...                                                     
#'     DCOM                    The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may not have the necessary registry informatio...
#'     DCOM                    The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may not have the necessary registry informatio...
#'     Service Control Manager The Connected Devices Platform Service service terminated with the following error: ...                                                     
#'     DCOM                    The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may not have the necessary registry informatio...
#'     DCOM                    The description for Event ID '10010' in Source 'DCOM' cannot be found.  The local computer may not have the necessary registry informatio...

#'

'Use 'get-member' to look at the properties, and you can see that 'time' is really called something else
&gt;get-eventlog -LogName system -Newest 1 | get-member

'OUTPUT
==========
#'   TypeName: System.Diagnostics.EventLogEntry#system/Service Control Manager/1073748869
#'
#'Name                      MemberType     Definition                                                                                                                      
#'----                      ----------     ----------                                                                                                                      
#'Disposed                  Event          System.EventHandler Disposed(System.Object, System.EventArgs)                                                                   
#'CreateObjRef              Method         System.Runtime.Remoting.ObjRef CreateObjRef(type requestedType)                                                                 
#'Dispose                   Method         void Dispose(), void IDisposable.Dispose()                                                                                      
#'Equals                    Method         bool Equals(System.Diagnostics.EventLogEntry otherEntry), bool Equals(System.Object obj)                                        
#'GetHashCode               Method         int GetHashCode()                                                                                                               
#'GetLifetimeService        Method         System.Object GetLifetimeService()                                                                                              
#'GetObjectData             Method         void ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingC...
#'GetType                   Method         type GetType()                                                                                                                  
#'InitializeLifetimeService Method         System.Object InitializeLifetimeService()                                                                                       
#'ToString                  Method         string ToString()                                                                                                               
#'Category                  Property       string Category {get;}                                                                                                          
#'CategoryNumber            Property       int16 CategoryNumber {get;}                                                                                                     
#'Container                 Property       System.ComponentModel.IContainer Container {get;}                                                                               
#'Data                      Property       byte[] Data {get;}                                                                                                              
#'EntryType                 Property       System.Diagnostics.EventLogEntryType EntryType {get;}                                                                           
#'Index                     Property       int Index {get;}                                                                                                                
#'InstanceId                Property       long InstanceId {get;}                                                                                                          
#'MachineName               Property       string MachineName {get;}                                                                                                       
#'Message                   Property       string Message {get;}                                                                                                           
#'ReplacementStrings        Property       string[] ReplacementStrings {get;}                                                                                              
#'Site                      Property       System.ComponentModel.ISite Site {get;set;}                                                                                     
#'Source                    Property       string Source {get;}                                                                                                            
#'TimeGenerated             Property       datetime TimeGenerated {get;}     &lt;================                                                                                              
#'TimeWritten               Property       datetime TimeWritten {get;}       &lt;================                                                                                                   
#'UserName                  Property       string UserName {get;}                                                                                                          
#'EventID                   ScriptProperty System.Object EventID {get=$this.get_EventID() -band 0xFFFF;} 


&gt;get-eventlog system -Newest 10 -EntryType Error | Select TimeGenerated,Source,Message
'OUTPUT
===============
#'TimeGenerated        Source                  Message                                                                                                                     
#'-------------        ------                  -------                                                                                                                     
#'10/5/2017 6:53:47 PM Service Control Manager The Connected Devices Platform Service service terminated with the following error: ...                                     
#'10/5/2017 6:51:43 PM DCOM                    The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may not have the necessary reg...
#'10/2/2017 7:42:06 PM DCOM                    The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may not have the necessary reg...
#'10/2/2017 6:12:59 PM Service Control Manager The Connected Devices Platform Service service terminated with the following error: ...                                     
#'10/2/2017 6:10:54 PM DCOM                    The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may not have the necessary reg...
#'10/1/2017 6:09:00 PM DCOM                    The description for Event ID '10010' in Source 'DCOM' cannot be found.  The local computer may not have the necessary reg...
#'10/1/2017 6:08:59 PM DCOM                    The description for Event ID '10016' in Source 'DCOM' cannot be found.  The local computer may not have the necessary reg...
#'10/1/2017 3:34:23 PM DCOM                    The description for Event ID '10010' in Source 'DCOM' cannot be found.  The local computer may not have the necessary reg...
#'10/1/2017 3:32:23 PM Service Control Manager The Connected Devices Platform Service service terminated with the following error: ...                                     
#'10/1/2017 3:32:23 PM DCOM                    The description for Event ID '10010' in Source 'DCOM' cannot be found.  The local computer may not have the necessary reg...
 
#'

'This may be easier to read:
&gt;get-eventlog system -Newest 10 -EntryType Error | Select TimeGenerated,Source,Message | format-list

'These are the events counted by 'source' groups, and sorted by count:
&gt;get-eventlog system | Group Source  -NoElement | Sort Count -Descending | Select -first 10 
'OUTPUT
=========
#'588 Microsoft-Windows-Kern...
#'  336 Service Control Manager  
#'  298 Microsoft-Windows-Filt...
#'  296 Microsoft-Windows-Wind...
#'  179 Microsoft-Windows-Kern...
#'  132 DCOM                     
#'  125 EventLog                 
#'  112 Microsoft-Windows-Kern...
#'   70 Microsoft-Windows-Ntfs   
#'   60 Microsoft-Windows-Kern...
#'

'To make it easier to read, we can pipe it to: | Out-GridView
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FOLDERS_Count_of_files_in_each_subFolder_AndTotalSize</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FOLDERS_Count_of_files_in_each_subFolder_AndTotalSize</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>dir G:\Data\Christin -Directory | 			#'Get Each Directory
foreach -begin { $h=@{} ; 			#'BEFORE: Initialize an empty hash table
                 $results=@() 		#'		 Initialize an empty array
               } -process {  		
               						#'Get a directory of every directory that comes through the initial command
               						#	'	and Pipe it to 'Measure-Object'
                            $stat = dir $_.FullName -file -Recurse | Measure-Object -Property length -sum
                            $h.Path = $_.fullname
                            $h.Files = $stat.count
                            $h.TotalSize = $stat.sum
                            $results+=[pscustomobject]$h	#'Create a custom object, and add the custom object to the array
                           } -end { 	#'Write the results to the Pipeline after the middle section is done
                                        $results 
                                    }
                                    
'OUTPUT
========================
#'Path                                             Files  TotalSize
#'----                                             -----  ---------
#'G:\Data\Christin\26Mckinnishcove                     8   44234296
#'G:\Data\Christin\8brentwood                          1      16116
#'G:\Data\Christin\AudubonGutters                      8    3092840
#'G:\Data\Christin\Bike                                8    1619742
#'G:\Data\Christin\BirthCertificate                    1    2045627
#'G:\Data\Christin\BLOG_CC_CreativeConcepts          369  443978908
#'G:\Data\Christin\CelesteHouse                       10    2388822
#'G:\Data\Christin\ChristinFolder_From_BV_Computer   464 1099051460
#'G:\Data\Christin\ComForce                            6    9216101
#'G:\Data\Christin\creditcard                         16   11680278
#'
                                    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FOLDERS_that_do_not_inherit_permissions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FOLDERS_that_do_not_inherit_permissions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

=========================
https://stackoverflow.com/questions/25126877/getting-names-of-folders-that-do-not-inherit-permissions

'CMD
&gt;DIR "C:\temp" -directory -recurse | GET-ACL | where {$_.Access.IsInherited -eq $false}

'POWERSHELL:
'The concept is: if a folder has at least 1 inherited access rule, 
'	then inheritance is enabled, 
'	if it has 0 inherited rules, inheritance is disabled.
&gt; Get-ChildItem C:\temp -recurse | Select @{Name='Path';Expression={$_.FullName}},@{Name='InheritedCount';Expression={(Get-Acl $_.FullName | Select -ExpandProperty Access | Where { $_.IsInherited }).Count}} | Where { $_.InheritedCount -eq 0 } | Select Path

=================================================================

'	You can use Add-Member to add the path as a property on each ACE object:
'	I also wrapped Get-Acl in a try block because it throws terminating errors.
dir c:\temp -Directory -Recurse | ForEach-Object {
    $Path = $_.FullName
    try {
        Get-Acl $Path | 
            select -ExpandProperty Access | 
            where { $_.IsInherited -eq $false } | 
            Add-Member -MemberType NoteProperty -Name Path -Value $Path -PassThru
    }
    catch {
        Write-Error $_
    }
}

================================================================
#'https://www.experts-exchange.com/questions/28395713/How-to-enumerate-which-folders-are-not-inheriting-permissions-from-parent-folder.html

NOTE: the output did not make sense, it only listed the subfolders, not sub-sub folders
	  and the output did not match what I was observing in the permissions

#requires -version 3

$Path = "c:\temp"
$Folders = Get-ChildItem $Path -Directory -Recurse
$statuses = @()

Foreach ($Folder in $Folders)
{
    $ACLs = Get-Acl -Path $Folder.fullname | ForEach-Object { $_.Access }
    Foreach ($ACL in $ACLs)
    {
        if (!($ACL.IsInherited))
        {
                $status = [ordered]@{ 
                FolderPath = $Folder.Fullname;
                IsInherited = $ACL.IsInherited;
                InheritanceFlags = $ACL.InheritanceFlags;
                PropagationFlags = $ACL.PropagationFlags }
            $statuses += (New-Object -TypeName PSObject -Property $status)
            break;
        }
        
    }
}
$statuses | Export-Csv -Path c:\temp\report.csv -Encoding ASCII -NoTypeInformation </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>get_Number_ofFiles_andTheirTotalSize_in_a_Directory</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>get_Number_ofFiles_andTheirTotalSize_in_a_Directory</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'In the Temp folder:
dir $env:temp -file -Recurse | Measure-Object Length -sum | 
Select Count,@{Name="SumMB";Expression = {[math]::round($_.sum/1mb,3)}}


'OUTPUT
=========
Count  SumMB
-----  -----
  292 169.84
  
  
-----------------------------------------------------------------------------

&gt;dir C:\Data -file -Recurse | Measure-Object Length -sum | 
Select Count,@{Name="SumMB";Expression = {[math]::round($_.sum/1mb,3)}}

Count SumMB
----- -----
  109 0.469
  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Insert_Line_At_Top_of_File</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Insert_Line_At_Top_of_File</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
$path = 'C:\DATA\PowerShellScript_LOGS\Kill_All_User_Sessions_LOG.txt'
$pathTempFile = 'C:\DATA\PowerShellScript_LOGS\Kill_All_User_Sessions_LOG_TEMP.txt'
$TheDateTime = Get-Date -format yyyy_M_d_h_m_s
$text = 'Script run at: ' +  $TheDateTime

if (Test-Path $path) {
    $text | Set-Content $pathTempFile
    Get-Content $path -ReadCount 5000 |
    Add-Content $pathTempFile 
    Remove-item $path 
    Rename-Item $pathTempFile -NewName $path
} else {
   $text | Set-Content $path
} 

////////////////////////////////////////////////////////////////////////////////////


'http://stackoverflow.com/questions/31999448/insert-line-of-text-to-the-top-of-a-long-text-file-using-powershell

$header = 'This is my header line'
$files = Get-Childitem '&lt;filespec&gt;'


foreach ($file in $files)
 {
   $header | Set-Content tempfile.txt
   Get-Content $file -ReadCount 5000 |
    Add-Content tempfile.txt
   Remove-item $file
   Rename-Item tempfile.txt -NewName $file
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>List_files_under_directory_with_ProgressBar</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>List_files_under_directory_with_ProgressBar</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$dir = 'G:\Data'			' &lt;=======This is the directory that it will search

$files = [System.IO.Directory]::EnumerateFiles($dir, '*.*', 'AllDirectories') | % {$_}
$index = 0
$total = @($files).Count
$starttime = $lasttime = Get-Date
gci $dir -recurse -File | % {
    $index++
    $currtime = (Get-Date) - $starttime
    $avg = $currtime.TotalSeconds / $index
    $last = ((Get-Date) - $lasttime).TotalSeconds
    $left = $total - $index
    $WrPrgParam = @{
        Activity = (
            "Get-FolderOwner $(Get-Date -f s)",
            "Total: $($currtime -replace '\..*')",
            "Avg: $('{0:N2}' -f $avg)",
            "Last: $('{0:N2}' -f $last)",
            "ETA: $('{0:N2}' -f ($avg * $left / 60))",
            "min ($([string](Get-Date).AddSeconds($avg*$left) -replace '^.* '))"
        ) -join ' '
        Status = "$index of $total ($left left) [$('{0:N2}' -f ($index / $total * 100))%]"
        CurrentOperation = "File: $($_.FullName)"
        PercentComplete = $index / $total * 100
    }
    Write-Progress @WrPrgParam
    $lasttime = Get-Date

    $_ | select directoryname, name, length, @{n='Owner';e={(Get-Acl $_.fullname).Owner}}, creationtime, lastwritetime
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Read_from_File</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Read_from_File</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Get-Content C:\Scripts\Test.txt			'In turn, Windows PowerShell displays the contents of the file in the console window:


'assign the returned information to a variable
$a = Get-Content C:\Scripts\Test.txt
'When Get-Content reads a text file and stashes the contents in a variable, the data is stored as an array, 
'	with each line in the file 
'	(determined by the presence of a carriage return-linefeed character) 
'	representing a single item in the array

'For example, do you want to look at only the first three lines in the text file?
'the first item in an array is always item 0.
(Get-Content C:\Scripts\Test.txt)[0 .. 2]

'another way to display just the first x number of lines in a text file is to use the –totalcount parameter
'Get-Content will retrieve only the first three lines in the file Test.txt:
Get-Content C:\Scripts\Test.txt -totalcount 3

'what about the last three lines in the text file? 
(Get-Content C:\Scripts\Test.txt)[-1 .. -3]
'The -1 represents the last item in the array. 
'The index number -2 represents the second-to-the-last item in the array, and so on.

'If you want to grab specific lines from the middle of the text file then use a command like this:
(Get-Content C:\Scripts\Test.txt)[3 .. 5]


'How can we open that file, sort the contents, and then display the sorted contents?
(Get-Content C:\Scripts\Test.txt) | Sort-Object

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Format_Commands_to_change_output_vie</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>format-table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Format_Commands_to_change_output_vie</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>format-table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'Select the fields and order
&gt;dir c:\work\*.dat | format-table -property Fullname,length,lastwritetime

#'With a custom property
&gt;&gt;Get-Process Notepad | Format-Table ProcessName, @{Label="TotalRunningTime"; Expression={(Get-Date) - $_.StartTime}}

#'Custom property
&gt;dir c:\work\*.dat | format-table -property Fullname,Name,
@{Name="Size";Expression={$_.length}},lastwritetime,
@{Name="Age(Days)";Expression = { (Get-Date)-$_.lastwritetime | Select -ExpandProperty TotalDays }}

#'Sort than Group By:
&gt;get-vegetable | sort color | format-table -GroupBy color -Property UPC,Count,Name,IsRoot

#' Group the objects by extensions, then take the group object and get the sums of the sizes
#' so at the end of the pipeline you have 'Group-info' objects, not file objects
&gt;dir c:\work -file -recurse | Group Extension | 
Select Count,Name,
@{Name="TotalKB";expression={$_.group | measure length -sum | select -ExpandProperty sum}} |
format-table -group Name -Property Count,TotalKB</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions_Numeric</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>aggregate</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions_Numeric</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>aggregate</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#
# useful agregate
#
function count
{
    BEGIN { $x = 0 }
    PROCESS { $x += 1 }
    END { $x }
}

function product
{
    BEGIN { $x = 1 }
    PROCESS { $x *= $_ }
    END { $x }
}

function sum
{
    BEGIN { $x = 0 }
    PROCESS { $x += $_ }
    END { $x }
}

function average
{
    BEGIN { $max = 0; $curr = 0 }
    PROCESS { $max += $_; $curr += 1 }
    END { $max / $curr }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions_String</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>concatenate</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions_String</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>concatenate</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://4sysops.com/archives/strings-in-powershell-replace-compare-concatenate-split-substring/


$h = "Hello" 
$w = "world"
$h + " " + $w

'Alternatively, you can expand the two strings within double quotes:

"$h $w"

"$h $w"

'This method is also suitable for concatenating the elements of a string array:

$st = @("Say hello", " world")
"$st"

'Another option for concatenating strings is the join operator. Its usage is perhaps a bit counterintuitive. 
'Normally, you place the operator in front of the string unless you want to separate the strings with a delimiter after the merge:

	
-join($h,$w)

'If you don’t like the result “Helloworld” in the example and you want to add a space between the two words, you have to call -join this way:
	
$h,$w -join " "</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions_String</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Extracting_substrings</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions_String</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Extracting_substrings</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'The method Substring has a similar purpose because it can extract a part of the string. However, instead of using delimiters, you have to specify the position and length of the string that you want to extract:
("Hello world").Substring(2,5)
'This command results in “llo w”, which corresponds to the substring with a length of five characters that begins at the third character (counting begins at 0!).</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions_String</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>SEARCH_and_REPLACE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions_String</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>SEARCH_and_REPLACE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Replace is the simplest of these methods and doesn’t support regular expressions.
	
("Hello World").Replace("Hello","New")

'A counterpart to the -match operator doesn’t exist. However, 
'PowerShell supports several methods that specialize on a particular search type. 
'For instance, StartsWith and EndsWith determine whether a string begins or ends with a certain character or string, 
'respectively. Likewise, Contains tells you if a string contains a certain substring:

("Hello world").Contains("ll")
'The above command results in True. To calculate the position of a character or substring in the string, IndexOf is at your disposal:


("Hello world").IndexOf("ll")

'Don’t forget that counting starts at 0!</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PARAMETER_ValidateScript</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PARAMETER_ValidateScript</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'ValidateScript tests for true before it continues


function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateCount(1, 5)]
		[string[]]$Name,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateRange(1, 5)]
		[int]$Count = 1,
		
		[Parameter()]
		[ValidateNotNull()]
		[ValidateRange(512MB, 1024MB)]
		[int]$MemoryStartupBytes,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('1', '2')]
		[int]$Generation = 2,
		
		[Parameter()]
		[ValidateScript({
	        if (-not (Test-Path -Path $_ -PathType Container))
	        {
		        throw "The folder [$_] does not exist. Try another"
	        }
	        else
	        {
		        $true
            }
        })]
		[ValidatePattern('^C:\\')]
		[string]$Path = 'C:\somebogusfolder',
	
		[Parameter()]
		[AllowNull()]
		[string]$OperatingSystem,

		[Parameter(Mandatory)]
		[AllowNull()]
		[string]$AllowNullParam
	)
}

#region ValidateScript
New-VirtualMachine -Name 'MYNEWVM' -Path 'C:\somebogusfolder' ## fails if detects exception, $true otherwise

#region Make the output prettier

#[ValidateScript({
#	if (-not (Test-Path -Path $_ -PathType Container))
#	{
#		throw "The folder [$_] does not exist. Try another"
#	}
#	else
#	{
#		$true
#	}
#})]

#endregion

#region Other ValidateScript examples
#[ValidateScript({
#	if (Test-Connection -ComputerName $_ -Quiet -Count 1)
#	{
#		throw "The computer [$_] is offline. Try another"
#	}
#	else
#	{
#		$true
#	}
#})]
#endregion

#endregion

#region ValidatePattern
New-VirtualMachine -Name 'MYNEWVM' -Path 'Z:\'
'C:\somefolder' -match '^C:\\'
#endregion

#region ValidateSet
New-VirtualMachine -Name 'MYNEWVM' -Generation

help New-VirtualMachine
#endregion

#region ValidateRange
New-VirtualMachine -Name 'MYNEWVM' -MemoryStartupBytes 128MB
New-VirtualMachine -Name 'MYNEWVM' -Count 10
#endregion

#region ValidateCount
New-VirtualMachine -Name 'MYNEWVM','MYOTHERVM'
#endregion

#region Null attributes
New-VirtualMachine -Name 'MYNEWVM' -NullParamTest $null
New-VirtualMachine -Name 'MYNEWVM' -NullParamTest ''
## Change param to [ValidateNotNull]
New-VirtualMachine -Name 'MYNEWVM' -NullParamTest ''

New-VirtualMachine -Name 'MYNEWVM' -AllowNullParam '' ## Only applies to mandatory parameters
#endregion</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PARAMETER_validation_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PARAMETER_validation_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>PARAMETER_validation_examples


function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateCount(1, 5)]
		[string[]]$Name,			'&lt;=== This is asking for a collection of strings
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateRange(1, 5)]
		[int]$Count = 1,
		
		[Parameter()]
		[ValidateNotNull()]
		[ValidateRange(512MB, 1024MB)]
		[int]$MemoryStartupBytes,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('1', '2')]
		[int]$Generation = 2,
		
		[Parameter()]
		[ValidateScript({
			if (Test-Connection -ComputerName $_ -Quiet -Count 1)
			{
				throw "The computer [$_] is offline. Try another"
			}
			else
			{
				$true
			}
		})]
		[ValidatePattern('^C:\\')]
		[string]$Path = 'C:\somebogusfolder',
		
		[Parameter()]
		[AllowNull()]
		[string]$OperatingSystem,
		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[string]$NullParamTest,
		
		[Parameter()]
		[AllowNull()]
		[string]$AllowNullParam
	)
}

'When you run this the (Mandatory) declaration will cause it to challenge you for the Parm, if it is not supplied
New-VirtualMachine
'It would responde by challenging you for the name:    &gt;Name[0]:

New-VirtualMachine -Name 'MYNEWVM'
'In this case it would just take the name

#region Get-Help to find Mandatory parameters in cmdlets

## Using help optional parmameters and their values are shown in brackets
==========================================================================

## No mandatory params
(Get-Help -Name Get-Service -Detailed).syntax			'&lt;=== This requests help on the syntax

## Only Path is mandatory
(Get-Help -Name Get-Content -Detailed).syntax

#endregion

#region Get-Command to find Mandatory parameters in cmdlets

(Get-Command -Name 'Get-Content').Parameters.Path.Attributes

#endregion</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PIPELINE_functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PIPELINE_functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Param  xxxx
[Parameter(ValueFromPipeline=$True)]

=====================================================
# It is possible to PIPELINE enable your functions
# These are referred to as ADVANCED functions
function Get-PSFiles ()
{
  # The begin block executes once at the start of the function for the RETURN VALUE (retval)
  begin  { $retval = "Here are some PowerShell files: `r`n" }    # `r`n = carriage return line feed

  # The process block is executed once for each object being
  # passed in from the pipe
  process { 
            if ($_.Name -like "*.ps1")
            { 
              $retval += "`t$($_.Name)`r`n"             #concatenate to the retval, TAB, and CRLF
              # Note this line could also be rendered as
              #$retval = $retval + "`t" + $_.Name + "`r`n" 
              # `t     Tab Character
              # `r     Carriage Return
              # `n     Line Feed
              # $( )   Tells PS to evaute the expression in () first then return it
              # $_     The current object being passed in the pipeline
              # .Name  The name property of the current object 
            }
          }
  
  # The end block executes once, after the rest of the function
  end { return $retval }          
}





Clear-Host
Set-Location "C:\PS\Beginning PowerShell Scripting for Developers\demo"
Get-ChildItem | Get-PSFiles




$output = Get-ChildItem | Get-PSFiles


$output.GetType()          #This would show as a single string, so can not be used as objects being passed into an array
                           # and you can not pipeline the individual objects

Clear-Host
$i = 0
foreach($f in $output)
{
  $i++
  "$i : $f"     #This would produce a line w/ a number for each item, but if you run this you get only one number
                # even though the line feeds would make it show up on different lines.
}

#==========================================================================================================
# To pipeline the output, push the output in the process area
function Get-PSFiles ()
{
  begin  { }    # &lt;=== empty

      process { 
                if ($_.Name -like "*.ps1")
                { 
                  $retval = "`tPowerShell file is $($_.Name)"
                  $retval  # This is the equivalent of: return $retval
                           # so some people use "return" but you can just call it, like this to return it
                           # In this case there is no CRLF, the $retval is just sent right back out
                }
              }
  
  end { }       # &lt;===  empty       
}

$output = Get-ChildItem | Get-PSFiles
$output.GetType()          # IN THIS CASE it will show that it is an ARRAY of objects, and no longer a single string

#NOW when you iterate you will get the counter with a new value on each line

Clear-Host
$i = 0
foreach($f in $output)
{
  $i++
  "$i : $f"
}


#HERE is a second piping function using "process"

function Write-SomeText ()
{
  # begin  { }            # &lt;== NOTE: These are commented out

  process { 
            $retval = "Here is the output: $($_)"          
            $retval
          }
  
  # end { }            # &lt;== NOTE: These are commented out          
}


Clear-Host
Set-Location "C:\PS\Beginning PowerShell Scripting for Developers\demo"
# NOW COMBINE BOTH OF THE PIPing functions
Get-ChildItem | Get-PSFiles | Write-SomeText



# Similar to original function but truly pipelined
"Here are some PowerShell files: `r`n"
Get-ChildItem | Get-PSFiles 


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_HASH_table</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>HASH_Table_as_PARM_for_a_Method</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_HASH_table</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>HASH_Table_as_PARM_for_a_Method</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'Hash Table with all the parms I will need for the New-AdUser method
$NewUserParams = @{
    'UserPrincipalName' = $Username
    'Name' = $Username
    'GivenName' = $FirstName
    'Surname' = $LastName
    'Title' = $Title
    'SamAccountName' = $Username
    'AccountPassword' = (ConvertTo-SecureString $DefaultPassword -AsPlainText -Force)
    'Enabled' = $true
    'Initials' = $MiddleInitial
    'Path' = "$Location,$DomainDn"       #'&lt;=== Creates a fully distinguished name
    'ChangePasswordAtLogon' = $true
}


#' USAGE ======================================================================================================
New-AdUser @NewUserParams                #'&lt;==== Pass a whole hash table of parms to the method


#' USAGE ======================================================================================================
#' the parameter names (i.e. Hash Table Keys) must be spelled just like the Parameters of the method be called
#' e.g. 'givenName' and 'surname' keys in the Hashtable are the same as the PARMs of Set-AdUser  

&gt; .\Set-MyAdUser.ps1 -Username rsmith -Attributes @{givenName = "Trudy"; surname = 'smithley'}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_HASH_table</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Query_EventLog_BetweenDateTimes_using_a_FilterHashTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_HASH_table</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Query_EventLog_BetweenDateTimes_using_a_FilterHashTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'=====START: Get-WinEventWithin.ps1 ========================================================================

param([string]$ComputerName = 'localhost',[datetime]$StartTimestamp,[datetime]$EndTimestamp)


#'Get-WinEvent lets you query ALL event log sources, and is faster than Get-EventLog
#'  "where { $_.RecordCount }" gets rid of all the event logs with no events
$Logs = (Get-WinEvent -ListLog * -ComputerName $ComputerName | where { $_.RecordCount }).LogName

$FilterTable = @{
	                'StartTime' = $StartTimestamp
	                'EndTime' = $EndTimestamp
	                'LogName' = $Logs
                }
		
Get-WinEvent -ComputerName $ComputerName -FilterHashtable $FilterTable -ErrorAction 'SilentlyContinue'
#'=====END: Get-WinEventWithin.ps1 ========================================================================

#'USAGE:===========================
&gt; .\Get-WinEventWithin.ps1 -StartTimestamp '11-18-16 04:00' -EndTimestamp '11-18-16 05:10' 

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Input</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>get_input_from_User_at_console</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Input</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>get_input_from_User_at_console</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'Sample script using Read-Host

# HR System Interface
Write-Host “Welcome to MyDomain HR System”
# Set Variables from User Input
$FirstName = Read-Host “Enter Employee’s First Name”
$LastName = Read-Host “Enter Employee’s Last Name”
$DisplayName = ($LastName + “, ” + $FirstName)
$Discription = Read-Host “Enter Empolyee’s Title”
$Office = Read-Host “Enter Employee’s Location”
$Phone = Read-Host “Enter Employee’s Phone Number”
$CN = (“CN=” + $FirstName + ” ” + $LastName)
$Class = “User”
$strUserName = $CN

#connect to AD and create user
$objADSI = [ADSI]“LDAP://OU=TestOUUsers,OU=TestOU,DC=NWTraders,DC=Mstf”
$objUser = $objADSI.Create($Class, $strUserName)
$objUser.Put(“sAMAccountName”, $FirstName)

# Commit the object in AD
$objUser.setInfo()

#Set General Tab Properties
#Bind to the user Object
$objADSI = [ADSI]“LDAP://$CN,OU=TestOUUsers,OU=TestOU,DC=NWTraders,DC=Mstf”
$objUser.Put(“givenName”, “$firstName”)
$objUser.Put(“SN”, “$LastName”)
$objUser.Put(“DisplayName”, “$DisplayName”)
$objUser.Put(“description”, “$Discription”)
$objUser.Put(“PhysicalDeliveryOfficeName”, “$office”)
$objUser.Put(“telephoneNumber”, “$phone”)

#set UserAccessControl
$objUser.put(“userAccountControl”, 544)

#Commit changes
$objUser.setInfo()</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Input</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-Content</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Input</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-Content</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
LINE BREAKS issue

Get-Content : 'will split the file at the newlines, 
			  'effectively removing the line breaks. 
			  
			  'Use the -Raw switch to read the file as a single string, keeping the newlines intact:
			  'The -Raw parameter will bring the entire contents in as a multi-line string.

				$Contents = get-content $File -Raw

				'vs this, which strips out the newlines:

				$Contents = Get-Content $File

'The -ReadCount parameter on Get-Content defines how many lines that Get-Content will read at once.

 'This example will count how many times each error shows up in the $Path. 
 'This pipeline can process each line as it is read from the file.
 
$dataset = @{}
Get-Content -Path $path -ReadCount 15 |
    Where-Object {$PSItem -match 'error'} |
    ForEach-Object {$dataset[$PSItem] += 1}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_IP_Port_Telnet_WindowsSockets</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PingListComputers_GetIPAddress</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_IP_Port_Telnet_WindowsSockets</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PingListComputers_GetIPAddress</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://social.technet.microsoft.com/Forums/lync/en-US/f54a477e-c23f-407d-9337-a2e6fd44a741/ping-machine-names-and-return-ips?forum=ITCG

----------------------------------------------------------

$servers = Get-Content "hosts.txt"
ForEach ($server in $servers) {
 Try {
  $IP = ((Test-Connection -ea stop -Count 1 -comp $server).IPV4Address).IPAddresstoString
  "$server - UP - $($IP)" &gt;&gt; "log.txt"
  } 
 Catch {
  Write-Warning "$_"
  "$server - Down - $($_)" &gt;&gt; "log.txt"
  }
 }
 
 ----------------------------------------------------------
 
 $servers = Get-Content  -Path 'c:\data\2018_05_09_ALL_ComputerListFromAD.txt'
$report = @()
ForEach ($server in $servers) {
  Try {
    $tempreport = New-Object PSObject
    $IP = ((Test-Connection -ea stop -Count 1 -comp $server).IPV4Address).IPAddresstoString
    $tempreport | Add-Member NoteProperty Server $server
    $tempreport | Add-Member NoteProperty Status "Up"
    $tempreport | Add-Member NoteProperty IP $ip
    $report += $tempreport
    } 
  Catch {
    $tempreport = New-Object PSObject
    $tempreport | Add-Member NoteProperty Server $server
    $tempreport | Add-Member NoteProperty Status "Down"  
    $report += $tempreport  
    }
  }
$report | Export-Csv -NoTypeInformation "c:\data\2018_05_09_ComputerIPlist.csv"</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_JSON</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>example_read_multiple_files_read_data_DoCalculations</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_JSON</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>example_read_multiple_files_read_data_DoCalculations</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#requires -version 5.0

&lt;#
JSON Processing script for Toolmaking book

Process the directory of JSON files and create a summary report in the
form of an object with these properties:

    Number of files processed
    Total number of items processed
    Average number of items processed
    Total number of Errors
    Average number of Errors
    Total number of Warnings
    Average number of Warnings
    StartDate (the earliest run date value)
    EndDate (the last run date value)

#&gt;

[cmdletbinding()]
Param(
[Parameter(Position = 0, Mandatory, HelpMessage = "Enter the path with the json test data")]
[ValidateNotNullorEmpty()]    
[string]$Path
)

Write-Verbose "Starting $($MyInvocation.MyCommand)"

Write-Verbose "Processing files from $Path"

$files = Get-ChildItem -Path $path -Filter *.dat

Write-Verbose "Found $($files.count) files."
$data = foreach ($file in $files) {
    Write-Verbose "Converting $($file.name)"
    Get-Content -Path $file.fullname | ConvertFrom-Json |
    Select-Object @{Name="Date";Expression={$_.RunDate -as [datetime]}},
    Errors,Warnings,@{name = "ItemCount"; expression = {$_.'Items processed'}}
}

#sort the data to get the first and last dates
$sorted = $data | Sort-Object Date 
$first =  $sorted[0].Date
$last = $sorted[-1].Date

Write-Verbose "Measuring data"
# The $stats variable will be an array of measurements for each property
$stats = $data | Measure-Object errors,warnings,ItemCount -sum -average

Write-Verbose "Creating summary result"
[PSCustomObject]@{
    NumberFiles = $data.count
    TotalItemsProcessed = $stats[2].sum
    AverageItemsProcessed = $stats[2].Average
    TotalErrors = $stats[0].sum
    AverageErrors = $stats[0].average
    TotalWarnings = $stats[1].sum
    AverageWarnings = $stats[1].Average
    StartDate = $first
    EndDate = $last
}

Write-Verbose "Ending $($MyInvocation.MyCommand)"

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_JSON</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>snippets_from_Training</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_JSON</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>snippets_from_Training</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' json
{
    "Name":  "bits",
    "DisplayName":  "Background Intelligent Transfer Service",
    "Status":  4
}



#' more json
[
    {
        "Name":  "BITS",
        "DisplayName":  "Background Intelligent Transfer Service",
        "Status":  4
    },
    {
        "Name":  "Bluetooth Device Monitor",
        "DisplayName":  "Bluetooth Device Monitor",
        "Status":  4
    },
    {
        "Name":  "Bluetooth OBEX Service",
        "DisplayName":  "Bluetooth OBEX Service",
        "Status":  4
    },
    {
        "Name":  "BrokerInfrastructure",
        "DisplayName":  "Background Tasks Infrastructure Service",
        "Status":  4
    },
    {
        "Name":  "Browser",
        "DisplayName":  "Computer Browser",
        "Status":  4
    },
    {
        "Name":  "BthHFSrv",
        "DisplayName":  "Bluetooth Handsfree Service",
        "Status":  1
    },
    {
        "Name":  "bthserv",
        "DisplayName":  "Bluetooth Support Service",
        "Status":  4
    }
]



#' nested objects
{
    "Name":  "bits",
    "DisplayName":  "Background Intelligent Transfer Service",
    "Status":  4,
    "RequiredServices":  [
                     {
                         "CanPauseAndContinue":  false,
                         "CanShutdown":  false,
                         "CanStop":  false,
                         "DisplayName":  "Remote Procedure Call (RPC)",
                         "DependentServices":  null,
                         "MachineName":  ".",
                         "ServiceName":  "RpcSs",
                         "ServicesDependedOn":  "DcomLaunch RpcEptMapper",
                         "ServiceHandle":  null,
                         "Status":  4,
                         "ServiceType":  32,
                         "StartType":  2,
                         "Site":  null,
                         "Container":  null
                     },
                     {
                         "CanPauseAndContinue":  false,
                         "CanShutdown":  false,
                         "CanStop":  true,
                         "DisplayName":  "COM+ Event System",
                         "DependentServices":  "igfxCUIService1.0.0.0 
                          COMSysApp SENS BITS",
                         "MachineName":  ".",
                         "ServiceName":  "EventSystem",
                         "ServicesDependedOn":  "rpcss",
                         "ServiceHandle":  null,
                         "Status":  4,
                         "ServiceType":  32,
                         "StartType":  2,
                         "Site":  null,
                         "Container":  null
                     }
                         ]
}



#' convert to json   &lt;==================================================== ConvertTo-Json
get-ciminstance win32_computersystem | convertto-json



#' now into a file &lt;====================================================== Output to a file
get-ciminstance win32_computersystem | convertto-json | out-file wmics.json
'OR
get-ciminstance win32_computersystem | convertto-json | set-content .\wmics2.json 



#' smaller data  (COMPRESSED)
get-ciminstance win32_computersystem | convertto-json -compress



#' filter first
get-ciminstance win32_computersystem -computername $env:computername | 
select PSComputername,Manufacturer,
@{Name="MemoryGB";Expression={$_.totalPhysicalmemory/1GB -as [int]}},
Number* | ConvertTo-Json



#' creates
{
    "PSComputerName":  "CLIENT01",
    "Manufacturer":  "LENOVO",
    "MemoryGB":  8,
    "NumberOfLogicalProcessors":  4,
    "NumberOfProcessors":  1
}

'if you want to create a json file, perhaps to hold configuration data or something similar, 
'	DON'T try to manually create the file. 
'	Instead, “objectify” your data in PowerShell and then convert to JSON. 


#' custom objects   '&lt;================================ Easiest way to build a JSON record(s)
[pscustomobject]@{
  Path = "C:\Scripts"
  LastModified = "1/1/2017"
  Count = 20
  Types = @(".ps1","psm1","psd1","json","xml")
} | ConvertTo-Json



#' creates
{
    "Path":  "C:\\Scripts",
    "LastModified":  "1/1/2017",
    "Count":  20,
    "Types":  [
                  ".ps1",
                  "psm1",
                  "psd1",
                  "json",
                  "xml"
              ]
}



#' metadata
[pscustomobject]@{
  Created = (Get-Date)
  Comment = "config data for script tool"
},
[pscustomobject]@{
  Path = "C:\Scripts"
  LastModified = "1/1/2017"
  Count = 20
  Types = @(".ps1","psm1","psd1","json","xml")
} | ConvertTo-Json 



#' creates
[
    {
        "Created":  {
                        "value":  "\/Date(1483398036020)\/",
                        "DisplayHint":  2,
                        "DateTime":  "Monday, January 2, 2017 6:00:36 PM"
                    },
        "Comment":  "config data for script tool"
    },
    {
        "Path":  "C:\\Scripts",
        "LastModified":  "1/1/2017",
        "Count":  20,
        "Types":  [
                      ".ps1",
                      "psm1",
                      "psd1",
                      "json",
                      "xml"
                  ]
    }
]



#' slight change
[pscustomobject]@{
  Created = (Get-Date).Tostring()   '&lt;============  To make it less complicated turn it into a string first
  Comment = "config data for script tool"
},



#' now results
{
        "Created":  "1/2/2017 6:03:40 PM",
        "Comment":  "config data for script tool"
    }



#' json snippet
 {
        "Name":  "wuauserv",
        "DisplayName":  "Windows Update",
        "Status":  1,
        "MachineName":  "chi-dc04",
        "Audit":  "12/01/16"
    },



#' convert from json
$in = get-content c:\work\audit.json | convertfrom-json         #'  &lt;=============== ConvertFrom-Json.

$in | get-member

$in[0..2]

$in[0..2] | Select Name,Displayname,
@{Name="Status";Expression = { $_.Status -as
System.ServiceProcess.ServiceControllerStatus]}},
@{Name="Audit";Expression= { $_.Audit -as [datetime]}},
@{Name="Computername";Expression = {$_.Machinename}}



#' again
get-content c:\work\audit.json | 
convertfrom-json | Select Name,Displayname,
@{Name="Status";Expression = { $_.Status -as [System.ServiceProcess.ServiceControllerStatus]}},
@{Name="Audit";Expression= { $_.Audit -as [datetime]}},
@{Name="Computername";Expression = {$_.Machinename}}



#' fix
get-content c:\work\audit.json | 
convertfrom-json | 
foreach { $_ | Select Name,Displayname,
@{Name="Status";Expression = { $_.Status -as [System.ServiceProcess.ServiceControllerStatus]}},
@{Name="Audit";Expression= { $_.Audit -as [datetime]}},
@{Name="Computername";Expression = {$_.Machinename}}
}





</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Logging__forSecurity</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>enable_Auditing_and_Logging</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Logging__forSecurity</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>enable_Auditing_and_Logging</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>enable_Auditing_and_Logging

Practical PowerShell Security: Enable Auditing and Logging with DSC
https://blogs.technet.microsoft.com/ashleymcglone/2017/03/29/practical-powershell-security-enable-auditing-and-logging-with-dsc/

#'Requirements
#'    We are assuming that the target system already has WMF 5.x installed or upgraded. Each of these enhancement will require the following settings:
#'
#'    Script block logging
#'        HKLM:\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
#'            EnableScriptBlockLogging, 1
#'            EnableScriptBlockInvocationLogging, 1
#'        It may also be a good idea to increase the log size. The Microsoft-Windows-PowerShell/Operational log is 15MB by default.
#'    System-wide transcription
#'        Create a directory to hold transcripts
#'            Set permissions on the directory to prevent tampering. (I chose SDDL for the shortest code here.)
#'            Trim the transcript directory contents on an interval to avoid filling the drive (if local).
#'            We are going to use a local directory for now. Lee recommends pointing it to a share off-box.
#'        HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription
#'            EnableTranscripting, 1
#'            IncludeInvocationHeader,1
#'            OutputDirectory, [Path]
#'    Protected event logging (can be used together with Windows Event Forwarding)
#'        Requires Windows 10 or Windows Server 2016
#'        Requires a document encryption certificate
#'        HKLM:\Software\Policies\Microsoft\Windows\EventLog\ProtectedEventLogging
#'            EnableProtectedEventLogging, 1
#'            EncryptionCertificate, [Certificate]

Now that we have an outline of the settings required, we can move those into a DSC configuration. 
You can view the code on my GitHub account here: https://github.com/GoateePFE/BlogScripts/blob/master/PSSecDSC.ps1

That script does this:
#'Script Block Logging
#'    Two registry resources set the values.
#'    Then for good measure we use a script resource to increase the size of the PowerShell event log.
#'Transcription
#'    Three registry resources set the values.
#'    We need a file resource to create the directory to hold the transcript files.
#'    Then two script resources set the permissions on the directory and remove any old files. We probably could have used an external resource to set the directory permissions, but I want to keep this using in-box resources for simplicity. Keeping the transcript directory clean requires that you set the DSC Local Configuration Manager (LCM) to ApplyAndAutocorrect.
#'    NOTE: Remove the file and script resources if you send the transcripts to a remote UNC share path.
#'    NOTE: If you use a local path, have fun trying to read the transcript files. Also, the trim files script resource will likely generate warnings trying to clear old files.
#'Protected Event Logging
#'    I’m going to skip this one due to a couple reasons:
#'    Right now we do not have a way to request a certificate in a configuration, and then pass that data to another resource in the same configuration. Writing a custom resource for that wouldn’t be practical, because I’m trying to keep this to in-box DSC resources for now.
#'    Most customers already have an event collection tool (SIEM). If not, then explore the xWindowsEventForwarding resource module.
#'Fit and Finish
#'    Notice that the configuration has the following parameters:
#'    TranscriptPath – Directory where you want to put the transcript files. Can be local or UNC path.
#'    TranscriptDays – How many days of transcripts do you wish to retain?
#'    EventLogSizeInMB – Size to set for the PowerShell log to hold the additional content generated.
#'BONUS
#'    For completeness I threw in a configuration to disable the transcription and logging.
#'    I also threw in a couple lines to query the event logs for your new events.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_LogParser(IIS)=&gt;SQL__ScheduleTask</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_LogParser(IIS)=&gt;SQL__ScheduleTask</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

https://support.software.dell.com/appassure/kb/144451



'1] Open Task Scheduler

	'Open Task Scheduler, create folder named "JPHSA" 
	' Right click the folder, and Create a new task "IIS_to_SQL_W3SVC1". Name it and set your security options.

		'GENERAL {Tag}
		--------------
			'Name: IIS_to_SQL_W3SVC1 
			'Location: \JPHSA
			'Author: JPHSA01\ggarson
			'Description: run LogParser, sets the Checkpoint, and moves new data to table on SQL Server. Runs under JPHSA01\IIS_SQL_DomainAdmin
			'When running the task, use the following user account
			'	JPHSA01\IIS_SQL_DomainAdmin
			'(x) Run whether user is logged on or not
			'[x] Run with highest privileges
			'Configure for: Windows Server 2012
			 
			 
	'Check "Run with highest privileges" as our scripts need to run as admin.  
	', 
	'enable the 'Run whether user is logged on or not' radio button.
'2] Triggers {tag}

	'Click on the Triggers tab and set your schedule or event that will trigger the running of your PowerShell script. 

		'Triggers {Tag}
		--------------
		'[New]
		' On a Schedule: Daily, at 5:30:00 am, Start on 3/24/2017
	
	
'3] Action {Tag}

	'Click on the Actions tab and click on New.
	'Action: Start a program
	'Program/script: Powershell.exe
	'You don't need to put a path as it should already be on your system.
	
		'Actions {Tag}
		--------------
		'Action: Start a program
		'Program/script: Powershell.exe
		'Add arguments: C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe -NoLogo -NonInteractive -File "C:\DATA\PowerShellScripts\IIS_Log_W3SVC1_to_SQL_task_v0.ps1"
		
	'When I clicked [ok] it challenged me for the credentials of: JPHSA01\IIS_SQL_DomainAdmin
	p.iis_sql_23.56		
	'Message:
		This task requires that the user account specified has Log on as batch job rights.
		For more information about setting this policy, see the Task Security Context topic
		in Help	
	'To give the user rights:
			
'			Go to the Start menu
'			Run
'			Type secpol.msc
'			and press Enter
'			The Local Security Policy manager opens
'			Go to Security Settings - Local Policies - User Rights Assignment node
'			Double click Log on as a batch job on the right side
'			Click Add User or Group...
'			Select 'JPHSA01\IIS_SQL_DomainAdmin' and click OK
				
'4] Set Argument

	'First you need to set the ExecutionPolicy. You have two options here, you can set the ExecutionPolicy on the machine or you can do it on a per-script basis. 
	'	Read the PowerShell ExecutionPolicy link below as it talks about or you can issue the command:

	Get-Help About_execution_policies

	'To set the execution policy globally, you can issue this command from within PowerShell:

	Set-ExecutionPolicy Unrestricted

	'Or use one of the other settings available depending on your environment. 
	'In the context of this how-to, however, we want to set the execution policy on a per script basis and open up security for us to run the script. 
	'This security policy will only be in effect for the script we are running and not compromise security otherwise.
	'That means we use the following Argument:

	-ExecutionPolicy Bypass -File c:\temp\agent_repl.ps1

'5] Save and Test</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>gig_WorkingExamples_on_JPHSA-EBWEB2</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>gig_WorkingExamples_on_JPHSA-EBWEB2</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#' This works b/c logparser.exe is in the environmental path.
&gt; logparser.exe “SELECT Top 10 cs-uri-stem, Count(*) FROM C:\inetpub\logs\LogFiles\W3SVC1\u_ex170308.log Group By cs-uri-stem Order by cs-uri-stem desc” –i:w3c

#'This does all the log files in the folder:
logparser.exe “SELECT Top 10 cs-uri-stem, Count(*) FROM C:\inetpub\logs\LogFiles\W3SVC1\* Group By cs-uri-stem Order by cs-uri-stem desc” –i:w3c

&gt; logparser.exe “SELECT *  FROM C:\inetpub\logs\LogFiles\W3SVC1\u_ex170308.log” –i:w3c

#'These are the output fields from previous statement:
#'LogFilename
#'RowNumber
#'date
#'time
#'s-ip
#'cs-method
#'cs-uri-stem
#'cs-uri-query                          
#'s-port
#'cs-username
#'c-ip
#'cs(User-Agent)  

#'Get help on the web log format:
&gt;logparser -h -i:IISW3C

#'SELECT and create Table:
logparser.exe –i:w3c  -o:sql -server:WBSQL1\DEV  -database:JUNK -driver:"sql server" -clearTable:on -createTable:on  “SELECT * INTO LogsTable FROM C:\inetpub\logs\LogFiles\W3SVC1\u_ex170308.log”

#'SELECT  create Table with Identity field, and checkpoint named: MyCheckpoint (NOTE the inoput format is not the same)
#' but this clears the table
logparser.exe  –i:IISW3C   -iCheckpoint:Checkpoint_W3SVC1.lpc   -ignoreIdCols:on  -o:sql -server:WBSQL1\PROD  -database:d4_IIS_Logs -driver:"sql server" -clearTable:on -createTable:on “SELECT * INTO jnk3_T001_W3SVC1_JPHSA411 FROM C:\inetpub\logs\LogFiles\W3SVC1\*” 

======================
#' First to create the SQL table
logparser.exe  –i:IISW3C   -iCheckpoint:Checkpoint_W3SVC1_b.lpc   -ignoreIdCols:on  -o:sql -server:WBSQL1\PROD  -database:d4_IIS_Logs -driver:"sql server"  -createTable:on “SELECT * INTO jnk3_T001_W3SVC1_JPHSA411 FROM C:\inetpub\logs\LogFiles\W3SVC1\*” 
#' This should just add to the table, but was unable to test
logparser.exe  –i:IISW3C   -iCheckpoint:Checkpoint_W3SVC1_b.lpc   -ignoreIdCols:on  -o:sql -server:WBSQL1\PROD  -database:d4_IIS_Logs -driver:"sql server"   “SELECT * INTO jnk3_T001_W3SVC1_JPHSA411 FROM C:\inetpub\logs\LogFiles\W3SVC1\*” 
==========================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>help</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>help</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Microsoft (R) Log Parser Version 2.2.10
Copyright (C) 2004 Microsoft Corporation. All rights reserved.

Usage:   LogParser [-i:&lt;input_format&gt;] [-o:&lt;output_format&gt;] &lt;SQL query&gt; |
                   file:&lt;query_filename&gt;[?param1=value1+...]
                   [&lt;input_format_options&gt;] [&lt;output_format_options&gt;]
                   [-q[:ON|OFF]] [-e:&lt;max_errors&gt;] [-iw[:ON|OFF]]
                   [-stats[:ON|OFF]] [-saveDefaults] [-queryInfo]

         LogParser -c -i:&lt;input_format&gt; -o:&lt;output_format&gt; &lt;from_entity&gt;
                   &lt;into_entity&gt; [&lt;where_clause&gt;] [&lt;input_format_options&gt;]
                   [&lt;output_format_options&gt;] [-multiSite[:ON|OFF]]
                   [-q[:ON|OFF]] [-e:&lt;max_errors&gt;] [-iw[:ON|OFF]]
                   [-stats[:ON|OFF]] [-queryInfo]

 -i:&lt;input_format&gt;   :  one of IISW3C, NCSA, IIS, IISODBC, BIN, IISMSID,
                        HTTPERR, URLSCAN, CSV, TSV, W3C, XML, EVT, ETW,
                        NETMON, REG, ADS, TEXTLINE, TEXTWORD, FS, COM (if
                        omitted, will guess from the FROM clause)
 -o:&lt;output_format&gt;  :  one of CSV, TSV, XML, DATAGRID, CHART, SYSLOG,
                        NEUROVIEW, NAT, W3C, IIS, SQL, TPL, NULL (if omitted,
                        will guess from the INTO clause)
 -q[:ON|OFF]         :  quiet mode; default is OFF
 -e:&lt;max_errors&gt;     :  max # of parse errors before aborting; default is -1
                        (ignore all)
 -iw[:ON|OFF]        :  ignore warnings; default is OFF
 -stats[:ON|OFF]     :  display statistics after executing query; default is
                        ON
 -c                  :  use built-in conversion query
 -multiSite[:ON|OFF] :  send BIN conversion output to multiple files
                        depending on the SiteID value; default is OFF
 -saveDefaults       :  save specified options as default values
 -restoreDefaults    :  restore factory defaults
 -queryInfo          :  display query processing information (does not
                        execute the query)


Examples:
 LogParser "SELECT date, REVERSEDNS(c-ip) AS Client, COUNT(*) FROM file.log
            WHERE sc-status&lt;&gt;200 GROUP BY date, Client" -e:10
 LogParser file:myQuery.sql?myInput=C:\temp\ex*.log+myOutput=results.csv
 LogParser -c -i:BIN -o:W3C file1.log file2.log "ComputerName IS NOT NULL"

Help:
 -h GRAMMAR                  : SQL Language Grammar
 -h FUNCTIONS [ &lt;function&gt; ] : Functions Syntax
 -h EXAMPLES                 : Example queries and commands
 -h -i:&lt;input_format&gt;        : Help on &lt;input_format&gt;
 -h -o:&lt;output_format&gt;       : Help on &lt;output_format&gt;
 -h -c                       : Conversion help</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>IIS_CustomField_input</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>IIS_CustomField_input</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
=========
'use the TRIM function around your string. 
	'This way, you can type any string you want as a custom extra field in a Log Parser Query.
'Reference : http://logparserplus.com/Functions#function_TRIM
'For example, I do it in this query (used to retrieve the Average and Max time) :
logparser -i:IISW3C -rtp:-1 -o:NAT -headers:OFF -iw:ON "SELECT TRIM('my-website-custom-extra-column-name.com') AS siteName, TRIM('foo-bar-custom-extra-column-name') AS fooBar, AVG(time-taken) As AverageTimeTaken, MAX(time-taken) As MaxTimeTaken, COUNT(*) As Hits, TO_LOWERCASE(cs-uri-stem) As Uri FROM C:\inetpub\yourwebsite.com\ex*.log TO c:\myOutputParsedLog.txt WHERE (Extract_Extension(To_Lowercase(cs-uri-stem)) IN ('aspx')) GROUP BY TO_LOWERCASE(cs-uri-stem) ORDER BY AverageTimeTaken DESC"
=========
use option -iHeaderFile to define your own fields. logparser -h will prove additional inforamtion</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogParser and PowerShell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogParser and PowerShell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

#'Here is the same command line query example from the last post but with PowerShell.

&amp; ./logparser.exe “SELECT Top 10 cs-uri-stem, Count(*) FROM D:Logsex081110.log Group By cs-uri-stem Order by cs-uri-stem desc” –i:w3c

#'Here is a simple powershell script using Log Parser. This is a little easier to follow than the batch file example in the last post.

PowerShell

$infile = "D:TempLPTest.log"

$query = @"
SELECT Top 10 cs-uri-stem, Count(*)
FROM $infile
Group By cs-uri-stem
Order by cs-uri-stem desc	
"@

$result = &amp; C:LogParserlogparser.exe $query -i:w3c

$infile = "D:TempLPTest.log"
 
$query = @"
SELECT Top 10 cs-uri-stem, Count(*)
FROM $infile
Group By cs-uri-stem
Order by cs-uri-stem desc	
"@
 
$result = &amp; C:LogParserlogparser.exe $query -i:w3c</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogParser_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogParser_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://logparserplus.com/Functions#function_TRIM

Function listing


ADD
ADD( addend1 &lt;any type&gt;, addend2 &lt;any type&gt; )
Calculates the sum of two values. Returns a value of the same type as its arguments.
Type: arithmetical

See also: SUB DIV MUL
AVG
AVG( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the average among all the values, or only the DISTINCT values, of the specified field-expression.
Type: aggregate

BIT_AND
BIT_AND( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Calculates the bitwise AND of two values.
Type: arithmetical

See also: BIT_NOT BIT_OR BIT_SHL BIT_SHR BIT_XOR
BIT_NOT
BIT_NOT( arg &lt;INTEGER&gt; )
Calculates the bitwise NOT of a value.
Type: arithmetical

See also: BIT_AND BIT_OR BIT_SHL BIT_SHR BIT_XOR
BIT_OR
BIT_OR( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Calculates the bitwise OR of two values.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_SHL BIT_SHR BIT_XOR
BIT_SHL
BIT_SHL( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Shifts a value left by a specified number of bits.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_OR BIT_SHR BIT_XOR
BIT_SHR
BIT_SHR( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Shifts a value right by a specified number of bits.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_OR BIT_SHL BIT_XOR
BIT_XOR
BIT_XOR( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Calculates the bitwise XOR of two values.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_OR BIT_SHL BIT_SHR
CASE
CASE &lt;field_expression&gt; WHEN &lt;field_expression&gt; THEN &lt;field_expression&gt; [ ... ] [ ELSE &lt;field_expression&gt; ] END
Compares the argument of the CASE statement with the arguments of the WHEN statements, returning the argument of a THEN statement when a match is found. If no match is found, returns the argument of the ELSE statement, or NULL if no ELSE statement is provided.
Type: miscellaneous

COALESCE
COALESCE( arg1 &lt;any type&gt;, arg2 &lt;any type&gt; [, ....] )
Returns the first non-NULL value among its arguments.
Type: miscellaneous

COMPUTER_NAME
COMPUTER_NAME()
Returns the NetBIOS name of the local computer.
Type: system information

COUNT
COUNT( [ DISTINCT | ALL ] * ) | ( [ DISTINCT | ALL ] &lt;field_expr_list&gt; )
Returns the number of items in a group.
Type: aggregate
COUNT(DISTINCT cs-uri-stem) AS [Distinct Requests]
Returns a count of how many distinct files were requested.
DIV
DIV( dividend &lt;INTEGER | REAL&gt;, divisor &lt;INTEGER | REAL&gt; )
Calculates the quotient of two values.
Type: arithmetical
DIV(sc-bytes, 1024) AS [KB Sent]
Converts bytes sent from the server to the client to Kilobytes (KB).
DIV(DIV(sc-bytes, 1024), 1024) AS [MB Sent]
Converts bytes sent from the server to the client to Megabytes (MB).
See also: MUL ADD SUB
EXP
EXP( argument &lt;INTEGER | REAL&gt; )
Calculates e (the Natural logarithm base) raised to the power of the specified argument.
Type: arithmetical

See also: EXP10
EXP10
EXP10( argument &lt;INTEGER | REAL&gt; )
Calculates 10 raised to the power of the specified argument.
Type: arithmetical

See also: EXP
EXTRACT_EXTENSION
EXTRACT_EXTENSION( filepath &lt;STRING&gt; )
Returns the file extension portion of a file path.
Type: string manipulation
EXTRACT_EXTENSION(cs-uri-stem) AS [File Extension]
Extracts the file extension for requests. Returns nothing for those without an extension.
EXTRACT_EXTENSION(cs-uri-stem) NOT IN ('jpg';'png';'gif';'ico')
When used in a WHERE clause, excludes requests for common image formats.
See also: EXTRACT_FILENAME EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_FILENAME
EXTRACT_FILENAME( filepath &lt;STRING&gt; )
Returns the filename portion of a file path.
Type: string manipulation
EXTRACT_FILENAME(cs-uri-stem) AS [File Requested]
Extracts the file name for requests.
See also: EXTRACT_EXTENSION EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_PATH
EXTRACT_PATH( filepath &lt;STRING&gt; )
Returns the directory path portion of a file path.
Type: string manipulation
EXTRACT_PATH(cs-uri-stem) AS [Path Requested]
Extracts the path of a request. The trailing slash (/) is removed.
See also: EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_PREFIX
EXTRACT_PREFIX( argument &lt;STRING&gt;, index &lt;INTEGER&gt;, separator &lt;STRING&gt; )
Returns a substring beginning at the first character and up to, but not including, the specified instance of the separator.
Type: string manipulation

See also: EXTRACT_SUFFIX EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_SUFFIX
EXTRACT_SUFFIX( argument &lt;STRING&gt;, index &lt;INTEGER&gt;, separator &lt;STRING&gt; )
Returns a substring beginning after the specified instance of the separator and up to the end of the string.
Type: string manipulation

See also: EXTRACT_PREFIX EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_TOKEN
EXTRACT_TOKEN( argument &lt;STRING&gt;, index &lt;INTEGER&gt; [ , separator &lt;STRING&gt; ] )
Splits the string into substrings at each point where the separator occurs, and returns the substring with the specified index.
Type: string manipulation
EXTRACT_TOKEN(cs(Referer), 2, '/') AS [Referring Domain]
Returns full domain of the site referring traffic to this resource.
See also: EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_VALUE
EXTRACT_VALUE
EXTRACT_VALUE( argument &lt;STRING&gt;, key &lt;STRING&gt; [ , separator &lt;STRING&gt; ] )
Parses "key=value" pairs in the string, returning the value corresponding to the specified key.
Type: string manipulation

See also: EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN
FLOOR
FLOOR( argument &lt;REAL&gt; )
Returns the integral part of the specified argument.
Type: arithmetical

See also: ROUND QNTFLOOR_TO_DIGIT QNTROUND_TO_DIGIT
GROUPING
GROUPING( &lt;field_expr&gt; )
Returns a value of 1 when the row is added by the ROLLUP operator of the GROUP BY clause, or 0 when the row is not the result of ROLLUP. GROUPING is used to distinguish the NULL values returned by ROLLUP from standard NULL values. The NULL returned as the result of a ROLLUP operation is a special use of NULL. It acts as a value placeholder in the result set and means "all".
Type: aggregate

HASHMD5_FILE
HASHMD5_FILE( filePath &lt;STRING&gt; )
Calculates the MD5 hash of the content of a file and returns its hexadecimal representation.
Type: miscellaneous

HASHSEQ
HASHSEQ( value &lt;STRING&gt; )
Returns a unique, sequential integer for each distinct value of the argument.
Type: miscellaneous

HEX_TO_ASC
HEX_TO_ASC( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of a series of bytes into a string where the bytes belonging to the 0x20-0x7F range have been converted to ASCII characters.
Type: string manipulation

See also: HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_INT HEX_TO_PRINT
HEX_TO_HEX16
HEX_TO_HEX16( hexString &lt;STRING&gt; [ , bigEndian &lt;INTEGER&gt; ] )
Converts the hexadecimal representation of a series of bytes into another hexadecimal representation in which bytes are grouped into 16-bit WORDs.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_INT HEX_TO_PRINT
HEX_TO_HEX32
HEX_TO_HEX32( hexString &lt;STRING&gt; [ , bigEndian &lt;INTEGER&gt; ] )
Converts the hexadecimal representation of a series of bytes into another hexadecimal representation in which bytes are grouped into 32-bit DWORDs.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX8 HEX_TO_INT HEX_TO_PRINT
HEX_TO_HEX8
HEX_TO_HEX8( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of a series of bytes into another hexadecimal representation in which bytes are grouped into 8-bit octets.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_INT HEX_TO_PRINT
HEX_TO_INT
HEX_TO_INT( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of an integer into the integer itself.
Type: conversion

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_PRINT
HEX_TO_PRINT
HEX_TO_PRINT( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of a series of bytes into a string where the bytes corresponding to printable ASCII characters have been converted to the characters themselves.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_INT
IN_ROW_NUMBER
IN_ROW_NUMBER()
Returns the current input record number.
Type: miscellaneous

See also: OUT_ROW_NUMBER
INDEX_OF
INDEX_OF( string &lt;STRING&gt;, searchStr &lt;STRING&gt; )
Returns the character position where the first occurrence of a search substring occurs in a string.
Type: string manipulation

See also: LAST_INDEX_OF
INT_TO_IPV4
INT_TO_IPV4( ipV4Address &lt;INTEGER&gt; )
Converts a 32-bit integer into the string representation of an IPV4 address.
Type: conversion

See also: IPV4_TO_INT
IPV4_TO_INT
IPV4_TO_INT( ipV4Address &lt;STRING&gt; )
Converts the string representation of an IPV4 address into a 32-bit integer.
Type: conversion

See also: INT_TO_IPV4
LAST_INDEX_OF
LAST_INDEX_OF( string &lt;STRING&gt;, searchStr &lt;STRING&gt; )
Returns the character position where the last occurrence of a search substring occurs in a string.
Type: string manipulation

See also: INDEX_OF
LOG
LOG( argument &lt;INTEGER | REAL&gt; )
Calculates the Natural logarithm of the specified argument.
Type: arithmetical

See also: LOG10
LOG10
LOG10( argument &lt;INTEGER | REAL&gt; )
Calculates the base-10 logarithm of the specified argument.
Type: arithmetical

See also: LOG
LTRIM
LTRIM( string &lt;STRING&gt; )
Removes whitespace characters from the beginning of a string.
Type: string manipulation

See also: RTRIM TRIM
MAX
MAX( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the maximum value among all the values of the specified field-expression.
Type: aggregate
MAX(sc-bytes) AS [Maximum Bytes Sent]
Returns the maximum number of bytes sent from the server to the client, across all requests.
See also: MIN
MIN
MIN( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the minimum value among all the values of the specified field-expression.
Type: aggregate
MIN(sc-bytes) AS [Minimum Bytes Sent]
Returns the minimum number of bytes sent from the server to the client, across all requests.
See also: MAX
MOD
MOD( dividend &lt;INTEGER | REAL&gt;, divisor &lt;INTEGER | REAL&gt; )
Calculates the remainder of the division of two numbers.
Type: arithmetical

MUL
MUL( multiplicand &lt;INTEGER | REAL&gt;, multiplier &lt;INTEGER | REAL&gt; )
Calculates the product of two values.
Type: arithmetical
MUL(PROPCOUNT(*), 100)
When used with another field and a simple GROUP BY, returns the percentage of requests by that field. See example query HTTP status codes and percentage of total.
See also: DIV ADD SUB
OUT_ROW_NUMBER
OUT_ROW_NUMBER()
Returns the current output record number.
Type: miscellaneous

See also: IN_ROW_NUMBER
PROPCOUNT
PROPCOUNT( * ) [ ON ( &lt;on_field_expr_list&gt; ) ] | ( &lt;field_expr_list&gt; ) [ ON ( &lt;on_field_expr_list&gt; ) ]
Returns the ratio of the COUNT aggregate function calculated on a group to the COUNT aggregate function calculated on a hierarchically higher group.
Type: aggregate

PROPSUM
PROPSUM( &lt;field_expr&gt; ) [ ON ( &lt;on_field_expr_list&gt; ) ]
Returns the ratio of the SUM aggregate function calculated on a group to the SUM aggregate function calculated on a hierarchically higher group.
Type: aggregate

QNTFLOOR_TO_DIGIT
QNTFLOOR_TO_DIGIT( value &lt;INTEGER&gt;, digits &lt;INTEGER&gt; )
Truncates a number to a specified number of significant digits, masking the remaining digits to zero.
Type: arithmetical

See also: QNTROUND_TO_DIGIT FLOOR ROUND
QNTROUND_TO_DIGIT
QNTROUND_TO_DIGIT( value &lt;INTEGER&gt;, digits &lt;INTEGER&gt; )
Rounds a number to a specified number of significant digits, masking the remaining digits to zero.
Type: arithmetical

See also: QNTFLOOR_TO_DIGIT FLOOR ROUND
QUANTIZE
QUANTIZE( argument &lt;INTEGER | REAL | TIMESTAMP&gt;, quantization &lt;INTEGER | REAL&gt; )
Truncates a value to the nearest multiple of another value.
Type: arithmetical
QUANTIZE(TO_TIMESTAMP(date, time), 3600)
Returns date/times to the hour. (In other words, drops the minutes.)
REPLACE_CHR
REPLACE_CHR( string &lt;STRING&gt;, searchCharacters &lt;STRING&gt;, replaceString &lt;STRING&gt; )
Replaces each occurrence of a character in a given set of characters with a string.
Type: string manipulation

REPLACE_IF_NOT_NULL
REPLACE_IF_NOT_NULL( argument &lt;any type&gt;, replaceValue &lt;any type&gt; )
Returns the second argument when the first argument is not NULL, and NULL otherwise.
Type: miscellaneous

REPLACE_STR
REPLACE_STR( string &lt;STRING&gt;, searchString &lt;STRING&gt;, replaceString &lt;STRING&gt; )
Replaces each occurrence of a substring with a string.
Type: string manipulation

RESOLVE_SID
RESOLVE_SID( sid &lt;STRING&gt; [ , computerName &lt;STRING&gt; ] )
Resolves a SID and returns its full account name.
Type: system information

REVERSEDNS
REVERSEDNS( ipAddress &lt;STRING&gt; )
Resolves an IP address and returns the corresponding host name.
Type: system information
REVERSEDNS(c-ip)
Returns the host name for the client's IP address.
ROT13
ROT13( string &lt;STRING&gt; )
Encodes or decodes a string using the ROT13 algorithm.
Type: string manipulation

ROUND
ROUND( argument &lt;REAL&gt; )
Returns the integer closest to the specified argument.
Type: arithmetical

See also: FLOOR QNTFLOOR_TO_DIGIT QNTROUND_TO_DIGIT
RTRIM
RTRIM( string &lt;STRING&gt; )
Removes whitespace characters from the end of a string.
Type: string manipulation

See also: LTRIM TRIM
SEQUENCE
SEQUENCE( [ startValue &lt;INTEGER&gt; ] )
Returns a unique sequential integer associated with the current input record number.
Type: miscellaneous

SQR
SQR( argument &lt;INTEGER | REAL&gt; )
Calculates the square of the specified argument.
Type: arithmetical

SQRROOT
SQRROOT( argument &lt;INTEGER | REAL&gt; )
Calculates the square root of the specified argument.
Type: arithmetical

STRCAT
STRCAT( string1 &lt;STRING&gt;, string2 &lt;STRING&gt; )
Appends one string to another.
Type: string manipulation

STRCNT
STRCNT( string &lt;STRING&gt;, token &lt;STRING&gt; )
Returns the number of occurrences of a substring in a string.
Type: string manipulation
STRCNT(cs-uri-stem, '/') AS [Request Depth]
Returns the depth of a requested file.
STRLEN
STRLEN( string &lt;STRING&gt; )
Returns the length of a string.
Type: string manipulation

STRREPEAT
STRREPEAT( string &lt;STRING&gt;, count &lt;INTEGER&gt; )
Creates a string by repeating a substring a given number of times.
Type: string manipulation

STRREV
STRREV( string &lt;STRING&gt; )
Reverses the characters in a string.
Type: string manipulation

SUB
SUB( minuend &lt;any type&gt;, subtrahend &lt;any type&gt; )
Calculates the difference of two values.
Type: arithmetical
TO_DATE(SUB(TO_LOCALTIME(SYSTEM_TIMESTAMP()), TIMESTAMP('0000-01-08', 'yyyy-MM-dd')))
Gets the date seven days ago, based on the current local date/time.
See also: ADD DIV MUL
SUBSTR
SUBSTR( string &lt;STRING&gt;, start &lt;INTEGER&gt; [ , length &lt;INTEGER&gt; ])
Returns a substring beginning at a specified location and having a specified length. The &lt;start&gt; of &lt;string&gt; begins at 0.
Type: string manipulation

SUM
SUM( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the sum of all the values, or only the DISTINCT values, of the specified field-expression.
Type: aggregate
SUM(sc-bytes) AS [Total Bytes Sent]
Returns the total number of bytes sent from the server to the client.
SYSTEM_DATE
SYSTEM_DATE()
Returns the current system date in Universal Time Coordinates (UTC) time.
Type: system information

See also: SYSTEM_TIME SYSTEM_TIMESTAMP
SYSTEM_TIME
SYSTEM_TIME()
Returns the current system time of the day in Universal Time Coordinates (UTC) time.
Type: system information

See also: SYSTEM_DATE SYSTEM_TIMESTAMP
SYSTEM_TIMESTAMP
SYSTEM_TIMESTAMP()
Returns the current system date and time in Universal Time Coordinates (UTC) time.
Type: system information
TO_LOCALTIME(SYSTEM_TIMESTAMP) AS [CurrentLocalTime]
Get the current date and time, converted to local time.
SUB(TO_LOCALTIME(SYSTEM_TIMESTAMP()), TIMESTAMP('0000-01-01 00:03', 'yyyy-MM-dd HH:mm'))
Get the local time 3 minutes ago.
See also: SYSTEM_DATE SYSTEM_TIME
SYSTEM_UTCOFFSET
SYSTEM_UTCOFFSET()
Returns the current system timezone and daylight saving offset relative to Universal Time Coordinates (UTC) time.
Type: system information

TO_DATE
TO_DATE( timestamp &lt;TIMESTAMP&gt; )
Converts a full timestamp into a date-only timestamp.
Type: conversion

See also: TO_TIME
TO_HEX
TO_HEX( argument &lt;INTEGER | STRING&gt; )
Returns the hexadecimal representation of an integer or of the characters in a string.
Type: conversion

TO_INT
TO_INT( argument &lt;any type&gt; )
Converts a value of the REAL, STRING, or TIMESTAMP data type into a value of the INTEGER data type.
Type: conversion

TO_LOCALTIME
TO_LOCALTIME( timestamp &lt;TIMESTAMP&gt; )
Converts a timestamp from Universal Time Coordinates (UTC) time into local time.
Type: conversion
TO_LOCALTIME(TO_TIMESTAMP(date, time)) AS [LocalTime]
Create a timestamp from the date and time of a request and convert it to local time.
See also: TO_UTCTIME
TO_LOWERCASE
TO_LOWERCASE( string &lt;STRING&gt; )
Returns a string where all alphabetic characters have been converted to lowercase.
Type: string manipulation

See also: TO_UPPERCASE
TO_REAL
TO_REAL( argument &lt;any type&gt; )
Converts a value of the INTEGER, STRING, or TIMESTAMP data type into a value of the REAL data type.
Type: conversion

TO_STRING
TO_STRING( argument &lt;INTEGER | REAL&gt; ) | ( timestamp &lt;TIMESTAMP&gt;, format &lt;STRING&gt; )
Converts a value of the REAL or INTEGER data type into a value of the STRING data type.
Type: conversion
TO_STRING(TO_LOCALTIME(TO_TIMESTAMP(date, time)), 'yyyy-MM-dd') AS [Day]
Converts the date and time of a request to local time, and then outputs the day as a string (2010-03-22).
TO_TIME
TO_TIME( timestamp &lt;TIMESTAMP&gt; )
Converts a full timestamp into a time-only timestamp.
Type: conversion
TO_TIME(TO_LOCALTIME(QUANTIZE(TO_TIMESTAMP(date, time), 3600))) AS [Hour]
Create a timestamp from the date and time of a request, drops the minutes from the time, converts it to local time, and pulls just the time.
See also: TO_LOCALTIME TO_DATE
TO_TIMESTAMP
TO_TIMESTAMP( dateTime1 &lt;TIMESTAMP&gt;, dateTime2 &lt;TIMESTAMP&gt; ) | ( string &lt;STRING&gt;, format &lt;STRING&gt; ) ( seconds &lt;INTEGER | REAL&gt; )
Parses a string representing a timestamp and returns a value of the TIMESTAMP data type. See also Microsoft Log Parser timestamp formats by James Skemp. There seems to be no difference between using TO_TIMESTAMP() and just TIMESTAMP().
Type: conversion
TO_TIMESTAMP(date, time)
Converts the date and time of a request into a timestamp, for use with other functions.
TO_TIMESTAMP('2009-02-06', 'yyyy-MM-dd')
Creates a timestamp of the date February 6, 2009.
TO_TIMESTAMP('2010-02-15 10:15', 'yyyy-MM-dd HH:mm')
Creates a timestamp of February 25, 2010, at 10:15 in the morning.
TO_TIMESTAMP('24 Jun 2011 13:22:21', 'dd MMM yyyy HH:mm:ss')
Creates a timestamp of a date/time in 'short' format.
TO_UPPERCASE
TO_UPPERCASE( string &lt;STRING&gt; )
Returns a string where all alphabetic characters have been converted to uppercase.
Type: string manipulation

See also: TO_LOWERCASE
TO_UTCTIME
TO_UTCTIME( timestamp &lt;TIMESTAMP&gt; )
Converts a timestamp from local time into Universal Time Coordinates (UTC) time.
Type: conversion

See also: TO_LOCALTIME
TRIM
TRIM( string &lt;STRING&gt; )
Removes whitespace characters from the beginning and end of a string.
Type: string manipulation

See also: LTRIM RTRIM
URLESCAPE
URLESCAPE( url &lt;STRING&gt; [ , codepage &lt;INTEGER&gt; ] )
Converts a string to the URL-encoded form suitable for transmission as an HTTP query string.
Type: string manipulation

See also: URLUNESCAPE
URLUNESCAPE
URLUNESCAPE( url &lt;STRING&gt; [ , codepage &lt;INTEGER&gt; ] )
Converts a URL-encoded string into its plain, unencoded form.
Type: string manipulation

See also: URLESCAPE
WIN32_ERROR_DESCRIPTION
WIN32_ERROR_DESCRIPTION( win32ErrorCode &lt;INTEGER&gt; )
Returns the text message associated with a numeric Windows error code.
Type: miscellaneous</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Use Logparser and Powershell to produce a single CSV output from IIS logs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Use Logparser and Powershell to produce a single CSV output from IIS logs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://gallery.technet.microsoft.com/office/Use-Logparser-and-59eaa5e5
#' Use Logparser and Powershell to produce a single CSV output from IIS logs

============================
I wanted to combine powershell and logparser to get me a single csv file of user activity on my ASPX website.

The following script acheives that by doing the following

It connects to a root IIS log repository. 
	Although the script looks at a single location, 
	it would be fairly simple to collect the logs from several servers first 
	(renaming them, possibly with the server name appended to give them a unique name) 
My IIS logs are generated fresh each day (the default) 
	so I used the create date to determine what day each log relates to.
I considered a week to be a reasonable block of time to track activity.  
	Therefore, I loop over the list of files and copy them into a week by week folder (named YYYY-WW)
Logparser then comes into action, 
	producing a single csv file for each set of logs for the week (i.e. for each folder)
You can modify the SELECT statement as needed, 
	but I was only interested in who hit which page, 
	where it was in the site and what their average and maximum rendering time was
Logparser will output some paths that I dont want in the report.  
	As my site is a SharePoint site, I'm not interested (in this instance) 
	so I strip them out of the file via the $unwantedPaths parameter.
The prepared files are then grouped into one single output file (Logs.csv) that I can pivot and present in Excel
 

Feel free to change structure and final output to suit your needs 
	- the script should give the basic building blocks to get a decent usage report out quickly.  
	The other advantage is that it will only do work if new data exists.  
	So, if you delete the output directories or files or new logs exist then you'll get new output.

It should go without saying that you'll need to have installed logparser on your machine before running this file.
==================================
Function CopyLogFile ($LogFile, [ref]$FoldersToProcess) { 
 
     
    $YearWeekOfFile = get-date ($LogFile.CreationTime) -UFormat %Y-%V 
    $savePath = Join-Path -Path $weeklyLogRootFolder -ChildPath $YearWeekOfFile 
    CreateFolderIfNotExists $savePath 
     
    $logFileDestinationPath = Join-Path -Path $savePath -ChildPath $LogFile.Name 
     
    if ((Test-Path $logFileDestinationPath) -eq $false) { 
        Copy-Item -Path $LogFile.FullName -Destination $logFileDestinationPath 
        $FoldersToProcess.value += $savePath 
    } 
     
     
} 
Function CreateFolderIfNotExists ($FolderPath) { 
 
    if ((Test-Path $FolderPath) -eq $false) { 
        New-Item -Path $FolderPath -Type Directory 
    } 
 
} 
 
Function PathIsWanted ($RequestPath) { 
    $pathIsWanted = $true 
    foreach($path in $unwantedPaths) { 
        if ($RequestPath -like "$($path)*") { 
            $pathIsWanted = $false 
            break 
        } 
    } 
    $pathIsWanted 
} 
 
#Modify this section with your own values 
 
$rawLogFileRoot = "\\SERVER\c$\inetpub\logs\LogFiles\FOLDER" 
$unwantedPaths = "/_layouts/", "/apps/", "/Lists/", "/_catalogs/", "/_vti_bin/", "/themes", "/Workflow" 
$weeklyLogRootFolder = "C:\temp\logs\" 
$outputCSVLocation = "C:\temp\logs\csvOutput\" 
 
#End of variables to be modified 
 
 
#You may need to modify the exe path of Logparser.exe as well as the SELECT script you wish to run 
#I only wanted aspx pages from my site 
$logParserExe = "C:\Program Files (x86)\Log Parser 2.2\LogParser.exe" 
$logParserSQL =  "`"SELECT '{0}' AS Date, cs-username, STRCAT(EXTRACT_PATH(cs-uri-stem),'/') AS RequestPath, " 
$logParserSQL += "EXTRACT_FILENAME(cs-uri-stem) AS RequestedFile, COUNT(*) AS TotalHits, Max(time-taken) AS MaxTime, " 
$logParserSQL += "AVG(time-taken) AS AvgTime INTO {2} FROM {1}\*.log WHERE cs-username  IS NOT NULL AND " 
$logParserSQL += "SUBSTR(STRREV(EXTRACT_FILENAME(cs-uri-stem)),0,5) = 'xpsa.'   GROUP BY cs-username, cs-uri-stem ORDER BY TotalHits DESC`"" 
#  "STRREV(EXTRACT_FILENAME(cs-uri-stem)),0,5) = 'xpsa.'" gives us aspx pages only 
$logParserParams = "-i:IISW3C" , "-o:CSV" 
 
 
CreateFolderIfNotExists $weeklyLogRootFolder 
CreateFolderIfNotExists $outputCSVLocation 
 
$FoldersToProcess = @() 
 
$rawLogFiles = Get-ChildItem $rawLogFileRoot 
 
 
foreach ($logFile in $rawLogFiles) { 
    CopyLogFile -logFile $logFile -FoldersToProcess ([ref] $FoldersToProcess) 
} 
$FoldersToProcess = $FoldersToProcess | select -uniq 
 
#Log Parsing section 
if ($FoldersToProcess -ne $null) { 
 
    foreach ($folderToProcess in $FoldersToProcess) { 
        $yearWeekName = $folderToProcess.Replace($weeklyLogRootFolder, '') 
        $outputCSV = Join-Path -Path $outputCSVLocation -ChildPath ($yearWeekName + ".csv") 
        $logParserParamsInput = ([string]::Format($logParserSQL, $yearWeekName, $folderToProcess, $outputCSV)), $logParserParams[0], $logParserParams[1] 
         
        Start-Process -NoNewWindow -FilePath $logParserExe -ArgumentList $logParserParamsInput -wait 
 
        #Now process the CSV file - removing unwanted page entries 
        $data = Import-Csv -Path $outputCSV | ?{$unwantedPaths -notcontains $_.RequestPath}  
        $data | Where-Object { (PathIsWanted $_.RequestPath) -eq $true } | Export-CSV -Path $outputCSV -NoTypeInformation 
         
    } 
} 
 
 
$outputFile = $null 
$outputFilePath = Join-Path -Path $outputCSVLocation -ChildPath "Logs.csv" 
 
 
$resultFiles = Get-Childitem $outputCSVLocation  
$firstItem = $true 
if ($resultFiles -ne $null) { 
    foreach ($resultFile in ($resultFiles | ?{$_.Name -ne "Logs.csv"})) { 
        if ($firstItem) { 
            Copy-Item $resultFile.FullName $outputFilePath 
            $firstItem = $false 
        } 
        else { 
            get-content $resultFile.FullName | Select -Skip 1 | Add-Content $outputFilePath 
        } 
    } 
} 
 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_script_with_parm</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_script_with_parm</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'01_script_with_parm.ps1
#'requires -version 5.0
#'requires -module Storage

Param(
    [string[]]$Computername = $env:COMPUTERNAME
)

foreach ($computer in $Computername) {
    #verify computer is online
    if (Test-Connection -ComputerName $Computer -Count 2 -Quiet) {					#' &lt;===========HERE is the PING

        #still using Try/Catch because a computer may be online, but there
        #might be other issues connecting such as invalid credentials.
        Try {
        	#'=====================================================================================Do Something
            Write-Host "Getting volume data from $($computer.toUpper())" -ForegroundColor Cyan
            #get all volumes that have a DriveLetter assigned
            Get-Volume -CimSession $computer -ErrorAction Stop | Where-Object {$_.DriveLetter} |
                Select-Object @{Name = "Computername"; Expression = {$_.PSComputername.ToUpper()}},
            @{Name = "Drive"; Expression = {$_.DriveLetter}}, 
            FileSystem,
            @{Name = "SizeGB"; Expression = {$_.size / 1gb -as [int32]}},
            @{Name = "FreeGB"; Expression = {[math]::Round($_.SizeRemaining / 1gb, 2)}},
            @{Name = "PctFree"; Expression = {[math]::Round(($_.SizeRemaining / $_.size) * 100, 2)}}
            #'=====================================================================================END Do Something
        }
        Catch {
            Write-Warning "Can't get volume data from $($Computer.ToUpper()). %($_.Exception.Message)."
        }
    } #if test is ok
    else {
        Write-Warning "Can't ping $($Computer.ToUpper())."
    }
} #foreach computer</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>comparison_operators_Examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>comparison_operators_Examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


1 -eq 1
1 -lt 5
1 -gt 5

#not case sensitive
'jeff' -eq 'Jeff'
'jeff' -ceq 'Jeff'		'ceq is a comparison operator that will test if one numeric or string expression is equal to another
						'ceq is a case-sensitive match and will ignore wildcards.
'jeff' -like 'je*'
'jeff' -notlike 'je*'

#match uses regular expressions
'jeff' -match "^J"
'srv03' -match "\w+\d{1,3}"

'Use "$_." with Brackets for "where"
Get-Vegetable | where {$_.count -gt 10 -and $_.color -eq 'green'} | sort count -Descending</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>If_PING_put_in_one_file_otherwise_another_File_ColorCode</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>If_PING_put_in_one_file_otherwise_another_File_ColorCode</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
$testcomputers = Get-Content -Path 'C:\DATA\ALL_jphsa.txt'
$exportLocation = 'C:\DATA\OfficeVersions.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\ALL_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\ALL_DeadPCs.txt
		}
	}
	
======================================================================
#'Get-InstalledSoftware_32_And_64_USAGE_v3_v4.ps1

$testcomputers = Get-Content -Path 'C:\DATA\2018_06_06_TEST.txt'


#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\2018_06_06_ALL_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\2018_06_06_ALL_DeadPCs.txt
		}
	}

cls

$goodComputerList = Get-Content 'C:\DATA\2018_06_06_ALL_RespondToPing.txt';
foreach ($computer in $goodComputerList) {
                                            Write-Host "Processing "$computer -ForegroundColor Yellow
                                            Get-SoftwareList_v4 -Computername $computer -outfile C:\DATA\2018_06_06_Adobe_Audit.csv
                                         }	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Loop_PING_inside_the_Loop_then_DoSomething</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Loop_PING_inside_the_Loop_then_DoSomething</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'USAGE
------------------------------------------------------------------------------USAGE: Local machine
&gt; PingThenDoSomething.ps1
#' OUTPUT
---------
Getting volume data from HOMETOWERVM05


Computername : HOMETOWERVM05
Drive        : D
FileSystem   : 
SizeGB       : 0
FreeGB       : 0
PctFree      : 

Computername : HOMETOWERVM05
Drive        : C
FileSystem   : NTFS
SizeGB       : 199
FreeGB       : 134.36
PctFree      : 67.36
------------------------------------------------------------------------------USAGE: Remachine, from script file

&gt; .\PingThenDoSomething.ps1 -Computername IT-1111


===========================================================================

#' PingThenDoSomething.ps1
#'requires -version 5.0
#'requires -module Storage

Param(
    [string[]]$Computername = $env:COMPUTERNAME
)

foreach ($computer in $Computername) {
    #verify computer is online
    if (Test-Connection -ComputerName $Computer -Count 2 -Quiet) {					#' &lt;===========HERE is the PING

        #still using Try/Catch because a computer may be online, but there
        #might be other issues connecting such as invalid credentials.
        Try {
        	#'=====================================================================================Do Something
            Write-Host "Getting volume data from $($computer.toUpper())" -ForegroundColor Cyan
            #get all volumes that have a DriveLetter assigned
            Get-Volume -CimSession $computer -ErrorAction Stop | Where-Object {$_.DriveLetter} |
                Select-Object @{Name = "Computername"; Expression = {$_.PSComputername.ToUpper()}},
            @{Name = "Drive"; Expression = {$_.DriveLetter}}, 
            FileSystem,
            @{Name = "SizeGB"; Expression = {$_.size / 1gb -as [int32]}},
            @{Name = "FreeGB"; Expression = {[math]::Round($_.SizeRemaining / 1gb, 2)}},
            @{Name = "PctFree"; Expression = {[math]::Round(($_.SizeRemaining / $_.size) * 100, 2)}}
            #'=====================================================================================END Do Something
        }
        Catch {
            Write-Warning "Can't get volume data from $($Computer.ToUpper()). %($_.Exception.Message)."
        }
    } #if test is ok
    else {
        Write-Warning "Can't ping $($Computer.ToUpper())."
    }
} #foreach computer</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LOOP_ping_TEST_Store_Errors_in_seperate_File</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LOOP_ping_TEST_Store_Errors_in_seperate_File</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'WhichComputers_RPCServerIsUnavailable_v0.ps1

$cred1 = Get-Credential  #' Run Once

$testcomputers = Get-Content -Path 'C:\DATA\2018_06_06_run_0_List_to_TEST.txt'


#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\2018_06_06_run_0_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\2018_06_06_run_0_didNOTping.txt
		}
	}

#'=============================================================================

$servers = Get-Content  -Path 'c:\data\2018_06_06_run_0_RespondToPing.txt'
$error.Clear() 
ForEach ($server in $servers) {
  Try {

    write-host "TRY:"$server -ForegroundColor Green        
    gwmi win32_operatingsystem -computer $server -credential $cred1 -ErrorAction Stop   
    write-host "No Error:"$server -ForegroundColor Yellow  
    Add-Content -value $server -path C:\DATA\2018_06_06_run_0_WMI_is_OK.txt
    } 
  Catch {
    write-host "CATCH:"$server -ForegroundColor Red
    Add-Content -value $server -path C:\DATA\2018_06_06_run_0_RPCServerIsUnavaible.txt #'-ErrorAction Continue  
    $errorNote = $server + ", " + $Error[0].CategoryInfo.Category + ", " + $Error[0].CategoryInfo.Reason
    write-host $errorNote -ForegroundColor Red
    Add-Content -value $errorNote -path C:\DATA\2018_06_06_run_0_Errors.txt
    }
  Finally {
    $error.Clear() 
    Write-Host "errors cleared"  
    }
  }

 #' [System.Windows.MessageBox]::Show('DONE') 
 write-host "DONE!" -ForegroundColor Red



 #'gwmi win32_operatingsystem -computer LT-1036 -credential $cred1 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Loop_Through_Records_from_TEXT_file_DoSomething_Export_To_Excel_file</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Loop_Through_Records_from_TEXT_file_DoSomething_Export_To_Excel_file</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'#Loop_Through_Records_from_TEXT_file_DoSomething_Export_To_Excel_file


#### Spreadsheet Location 
 $DirectoryToSaveTo = "c:\" 
 $date=Get-Date -format "yyyy-MM-d" 
 $Filename="Patchinfo-$($patch)" 
 
  
 ###InputLocation 
 $Computers = Get-Content "c:\computers.txt" 
 

  
 
  
# before we do anything else, are we likely to be able to save the file? 
# if the directory doesn't exist, then create it 
if (!(Test-Path -path "$DirectoryToSaveTo")) #create it if not existing 
  { 
  New-Item "$DirectoryToSaveTo" -type directory | out-null 
  } 
   
 
 
#Create a new Excel object using COM  
$Excel = New-Object -ComObject Excel.Application 
$Excel.visible = $True 
$Excel = $Excel.Workbooks.Add() 
$Sheet = $Excel.Worksheets.Item(1) 
 
$sheet.Name = 'Patch status - ' 
#Create a Title for the first worksheet 
$row = 1 
$Column = 1 
$Sheet.Cells.Item($row,$column)= 'Patch status'  
 
$range = $Sheet.Range("a1","f2") 
$range.Merge() | Out-Null 
$range.VerticalAlignment = -4160 
 
#Give it a nice Style so it stands out 
$range.Style = 'Title' 
 
#Increment row for next set of data 
$row++;$row++ 
 
#Save the initial row so it can be used later to create a border 
#Counter variable for rows 
$intRow = $row 
$xlOpenXMLWorkbook=[int]51 
 
#Read thru the contents of the Servers.txt file 
 
$Sheet.Cells.Item($intRow,1)  ="Name" 
$Sheet.Cells.Item($intRow,2)  ="status" 
$Sheet.Cells.Item($intRow,3)  ="Patch status" 
$Sheet.Cells.Item($intRow,4)  ="OS" 
$Sheet.Cells.Item($intRow,5)  ="SystemType" 
$Sheet.Cells.Item($intRow,6)  ="Last Boot Time" 
 
 
for ($col = 1; $col –le 6; $col++) 
     { 
          $Sheet.Cells.Item($intRow,$col).Font.Bold = $True 
          $Sheet.Cells.Item($intRow,$col).Interior.ColorIndex = 48 
          $Sheet.Cells.Item($intRow,$col).Font.ColorIndex = 34 
     } 
 
$intRow++ 
 
 
#Function GetStatusCode 
#{  
#    Param([int] $StatusCode)   
#    switch($StatusCode) 
#    { 
#        0         {"Success"} 
#        11001   {"Buffer Too Small"} 
#        11002   {"Destination Net Unreachable"} 
#        11003   {"Destination Host Unreachable"} 
#        11004   {"Destination Protocol Unreachable"} 
#        11005   {"Destination Port Unreachable"} 
#        11006   {"No Resources"} 
#        11007   {"Bad Option"} 
#        11008   {"Hardware Error"} 
#        11009   {"Packet Too Big"} 
#        11010   {"Request Timed Out"} 
#        11011   {"Bad Request"} 
#        11012   {"Bad Route"} 
#        11013   {"TimeToLive Expired Transit"} 
#        11014   {"TimeToLive Expired Reassembly"} 
#        11015   {"Parameter Problem"} 
#        11016   {"Source Quench"} 
#        11017   {"Option Too Big"} 
#        11018   {"Bad Destination"} 
#        11032   {"Negotiating IPSEC"} 
#        11050   {"General Failure"} 
#        default {"Failed"} 
#    } 
#} 
 
 
 
Function GetUpTime 
{ 
    param([string] $LastBootTime) 
    $Uptime = (Get-Date) - [System.Management.ManagementDateTimeconverter]::ToDateTime($LastBootTime) 
    "Days: $($Uptime.Days); Hours: $($Uptime.Hours); Minutes: $($Uptime.Minutes); Seconds: $($Uptime.Seconds)"  
} 
 
 
foreach ($Computer in $Computers)         
			 {                    #'&lt;===========   Loop Starts
 
				TRY 
					{ 
							$OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer 
							$sheetS = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Computer 
							$date = Get-Date 
					} 
  
				CATCH 
					{ 
							$pcnotfound = "true" 
					} 


				 #### Pump Data to Excel 
				 if ($pcnotfound -eq "true") 
				 { 

				 $sheet.Cells.Item($intRow, 1) = $computer 
				 $sheet.Cells.Item($intRow, 2) = "PC Not Found" 
				 } 
				 else 
				 { 
				 $sheet.Cells.Item($intRow, 1) = $computer 
				 $sheet.Cells.Item($intRow, 2) = $status 
				 $Sheet.Cells.Item($intRow, 3) = $kbinstall 
				 $sheet.Cells.Item($intRow, 4) = $OSRunning 
				 $Sheet.Cells.Item($intRow, 5) = $SystemType 
				 $sheet.Cells.Item($intRow, 6) = $uptime 
				 } 
 
  
				$intRow = $intRow + 1 
				 $pcnotfound = "false" 
			 }                       #'&lt;===========   Loop Ends
 
$erroractionpreference = “SilentlyContinue”  
 
$Sheet.UsedRange.EntireColumn.AutoFit() 
########################################333 
 
 
 
############################################################## 
 
$filename = "$DirectoryToSaveTo$filename.xlsx" 
#if (test-path $filename ) { rm $filename } #delete the file if it already exists 
$Sheet.UsedRange.EntireColumn.AutoFit() 
$Excel.SaveAs($filename, $xlOpenXMLWorkbook) #save as an XML Workbook (xslx) 
$Excel.Saved = $True 
$Excel.Close() 
$Excel.DisplayAlerts = $False 
$Excel.quit()</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Loop_ThroughComputers_MultiColumnOutput_toFile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Loop_ThroughComputers_MultiColumnOutput_toFile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://filedb.experts-exchange.com/incoming/2015/11_w47/1030521/get-officeversion.ps1..txt
=============================================================================================
#'USAGE
$testcomputers = Get-Content -Path 'C:\DATA\DeskTops_AIO_EB_2018_04_03.txt'
$exportLocation = 'C:\DATA\OfficeVersions.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path C:\DATA\ComputersThatRespondToPing.txt
		}else{
			Add-Content -value $computer -path C:\DATA\DeadPCs.txt
		}
	}
	
#'Proceed with inventory of Live PCs
#'get-officeversion $testcomputers $exportLocation
get-officeversion -Infile C:\DATA\ComputersThatRespondToPing.txt -outfile C:\DATA\GetOffice_results.txt


=============================================================================================
&lt;#
.Synopsis
   Get-OfficeVersion 
.DESCRIPTION
   Gets the Office version from a list of computernames and returns a CSV of the Computername and Office Version (if available)
.EXAMPLE
 get-officeversion c:\test\servers.txt c:\test\officeversions.csv
.EXAMPLE
 get-officeversion -infile c:\test\servers.txt -outfile c:\test\officeversions.csv
.NOTES
   General notes
.PARAMETER infile
A path and a filename to a text file contains a list of the computernames or ip addresses to check the office version.
.PARAMETER Outfile
A path and filename of the output .csv file

#&gt;
function Get-OfficeVersion
{
#'..................................................................................................FUNCTION - START
param(
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $Infile,
    
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $outfile
    )
#$outfile = 'C:\temp\office.csv'
#$infile = 'c:\temp\servers.txt'
Begin
    {
    }
 Process
    {
    #'************************************************************************************************PROCESS - START
		    $office = @()
		    $computers = Get-Content $infile
		    $i=0
		    $count = $computers.count   
		    foreach($computer in $computers)
		     {
		      #'=======================================================================================FOREACH - START
		     $i++
		     Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
		      -PercentComplete ($i/$count*100)
		        $info = @{}
		        $version = 0
			    try{
				          $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $computer) 
				          $reg.OpenSubKey('software\Microsoft\Office').GetSubKeyNames() |
				          	ForEach-Object {
									            if ($_ -match '(\d+)\.') 
										            {
										              if ([int]$matches[1] -gt $version) 
											              {
											                $version = $matches[1]
											              }
										            }    
			      						}
				          if ($version) {
								            Write-Debug("$computer : found $version")
								            switch($version) {
												                "7" {$officename = 'Office 97' }
												                "8" {$officename = 'Office 98' }
												                "9" {$officename = 'Office 2000' }
												                "10" {$officename = 'Office XP' }
												                "11" {$officename = 'Office 97' }
												                "12" {$officename = 'Office 2003' }
												                "13" {$officename = 'Office 2007' }
												                "14" {$officename = 'Office 2010' }
												                "15" {$officename = 'Office 2013' }
												                "16" {$officename = 'Office 2016' }
												                default {$officename = 'Unknown Version'}
												            }
								    
								          }
			      }
			  catch{
		          $officename = 'Not Installed/Not Available'
		      	   }
			  $info.Computer = $computer
			  $info.Name= $officename
			  $info.version =  $version
			
			  $object = new-object -TypeName PSObject -Property $info
			  $office += $object
			#'=======================================================================================FOREACH - END  
		    }
		    $office | select computer,version,name | Export-Csv -NoTypeInformation -Path $outfile
		  
		    
		    
    #'************************************************************************************************PROCESS - END		    
    }
    
    
#'..................................................................................................FUNCTION - END    
}
  write-output ("Done")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>TRY_WriteToFile_CATCH_WriteToFile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>TRY_WriteToFile_CATCH_WriteToFile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code> $servers = Get-Content  -Path 'c:\data\2018_05_09_ALL_ComputerListFromAD.txt'
$report = @()
ForEach ($server in $servers) {
  Try {
    $tempreport = New-Object PSObject
    $IP = ((Test-Connection -ea stop -Count 1 -comp $server).IPV4Address).IPAddresstoString
    $tempreport | Add-Member NoteProperty Server $server
    $tempreport | Add-Member NoteProperty Status "Up"
    $tempreport | Add-Member NoteProperty IP $ip
    $report += $tempreport
    } 
  Catch {
    $tempreport = New-Object PSObject
    $tempreport | Add-Member NoteProperty Server $server
    $tempreport | Add-Member NoteProperty Status "Down"  
    $report += $tempreport  
    }
  }
$report | Export-Csv -NoTypeInformation "c:\data\2018_05_09_ComputerIPlist.csv"</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WaitForReboot_Remote_Computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WaitForReboot_Remote_Computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--------------------------------------------------------------------------------
https://4sysops.com/archives/add-a-computer-to-an-active-directory-domain-with-powershell/

function Add-AcmeComputer {

						    param(
								        [string[]]$ComputerName,
								        [string]$Domain,
								        [switch]$Wait
								    )
						 
						    foreach ($computer in $ComputerName) 
						    {
						    
						    
						        if (-not (Test-Connection -ComputerName $computer -Quiet -Count 1)) 
							        {
							            Write-Warning "Could not ping computer [$computer]"
							        } 
						        else 
							        {
							            Write-Information "[$computer] is being added to domain [$Domain]..."   #' &lt;===== Message: what is occuring
							            
							            #'========================================================================Actions
							            Add-Computer -ComputerName $computer -Domain $Domain -Restart
							            #'========================================================================            
							           
							            if ($Wait.IsPresent) 
							            	{
							                #' Give it some time to go offline
							                while (Test-Connection -ComputerName $computer -Quiet -Count 1) 
										                {
										                    Start-Sleep -Seconds 2
										                }
							 
							                #' It's now offline, wait for it to come back
							                while (-not (Test-Connection -ComputerName $computer -Quiet -Count 1)) 
										                {
										                    Start-Sleep -Seconds 2
										                    Write-Information "[$computer] rebooted and is back!"
										                }
							            	}
							            Write-Information "[$computer] was added to domain [$Domain]..."
							        }
						    }
						}
--------------------------------------------------------------------------------
'Waiting for restart
https://itknowledgeexchange.techtarget.com/powershell/waiting-for-restart/
--------------------------------------------------------------------------------
'Restart server and wait for service to be available
http://community.idera.com/powershell/ask_the_experts/f/learn_powershell_from_don_jones-24/23349/restart-server-and-wait-for-service-to-be-available

--------------------------------------------------------------------------------
https://www.sapien.com/forums/viewtopic.php?t=7226

function WaitForWMI{
     Param(
           $computername
     )
     $msg='Timed out after {1:N0} seconds connecting to {0}.  Trying again'
     $starttime=[datetime]::Now
     While(!(GWMI Win32_Bios -computername $computername -ea 0)){
           Write-Host ( $msg -f $computername, $([datetime]::Now -$starttime).TotalSeconds) -fore green
     }
      Write-Host ('Host {0} conncted at {1}'  -f $computername, [datetime]::Now) -fore blue -back white
}
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WHILE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WHILE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
# While
Clear-Host
$i = 1
while ($i -le 5)
{
  "`$i = $i"
  $i = $i + 1		#you have to increment the counter
}


# While won't execute if condition is already true
Clear-Host
$i = 6
while ($i -le 5)
{
  "`$i = $i"
  $i = $i + 1
}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Menus_and_Controllers</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>choice_menu</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Menus_and_Controllers</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>choice_menu</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'' Creates a Pop-Window with choices in the ISE, or some choices in the non-ISE 



#'this will give you a graphical menu in the PowerShell ISE.

Function Invoke-Choice {
[CmdletBinding()]
Param()

#'a nested function to prompt for the computername
Function promptComputer {
[CmdletBinding()]
Param()

$Computername = Read-Host "Enter a computername or press Enter to use the localhost"
if ($Computername -notmatch "\w+") {
    $computername = $env:COMPUTERNAME
}
#'write the result to the pipeline
$Computername

} #'promptComputer

#'initialize a collection for the ChoiceDescription objections
$coll = @() 

#' The &amp; makes the S the choice character
$a = [System.Management.Automation.Host.ChoiceDescription]::new("Running &amp;Services")
$a.HelpMessage = "Get Running Services"
#'customize the object and add some PowerShell code to run
$a | Add-Member -MemberType ScriptMethod -Name Invoke -Value {
    $computer = promptComputer
    Get-service -ComputerName $computer | where {$_.status -eq "running"}
} -force

#'add the item to the collection
$coll+=$a

$b = [System.Management.Automation.Host.ChoiceDescription]::new("Top &amp;Processes")
$b.HelpMessage = "Get top processes sorted by workingset"
$b | Add-Member -MemberType ScriptMethod -Name Invoke -Value {
    $computer = promptComputer
    Get-Process -ComputerName $computer | sort WS -Descending | select -first 10} -force
$coll+=$b

$c = [System.Management.Automation.Host.ChoiceDescription]::new("&amp;Disk Status")
$c.HelpMessage = "Get fixed disk information"
$c | Add-Member -MemberType ScriptMethod -Name Invoke -Value {
    $computer = promptComputer
    Get-Ciminstance -classname win32_logicaldisk -filter "drivetype=3" -ComputerName $computer
 } -force
$coll+=$c

$q = [System.Management.Automation.Host.ChoiceDescription]::new("&amp;Quit")    
$q.HelpMessage = "Quit and exit"
$coll+=$q

#'loop through and keep displaying the menu until the user quits
$running = $true
do {
    $r = $host.ui.PromptForChoice("Help Desk Menu","Select a task:",$coll,3)
    if ($r -lt $coll.count-1) {
        #'call the custom method on the selected object
        $coll[$r].invoke() | Out-Host
    } else {
        #'quit and bail out
        Write-Host "Have a nice day." -ForegroundColor Green
        $running = $False
    } 
} while ($running) 

}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Menus_and_Controllers</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>ProcessController</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Menus_and_Controllers</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>ProcessController</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>This is a script to run and then output HTML report

#'USAGE:
&gt; s:\eventlogreport.ps1 -computername (Get-content s:\servers.txt) 

=====================================================================




#'Requires -version 5.0

[cmdletbinding()]
Param(
[Parameter(Position = 0, Mandatory)]
[ValidateNotNullorEmpty()]
[string[]]$Computername,

[ValidateSet("Error","Warning","Information","SuccessAudit","FailureAudit")]
[string[]]$EntryType = @("Error","Warning"),

[ValidateSet("System","Application","Security",
"Active Directory Web Services","DNS Server")]
[string]$Logname = "System",

[datetime]$After = (Get-Date).AddHours(-24),

[Alias("path")]
[string]$OutputPath = "c:\work",

[string]$SendTo
)

#'get log data
Write-Host "Gathering $($EntryType -join ",") entries from $logname after $after from $($computername -join ",")"  -ForegroundColor cyan

$logParams = @{
    Computername = $Computername
    EntryType = $EntryType
    Logname = $Logname
    After = $After
}

$data = Get-EventLog @logParams

#'create html report
$fragments = @()                                    #'' &lt;==== Array to build the pieces for the report
$fragments += "&lt;H1&gt;Summary from $After&lt;/H1&gt;"
$fragments += "&lt;H2&gt;Count by server&lt;/H2&gt;"
$fragments += $data | group -Property Machinename  | 
Sort Count -Descending | Select Count,Name |
ConvertTo-HTML -As table -Fragment
$fragments += "&lt;H2&gt;Count by source&lt;/H2&gt;"
$fragments += $data | group -Property source  | 
Sort Count -Descending | Select Count,Name |
ConvertTo-HTML -As table -Fragment

$fragments += "&lt;H2&gt;Detail&lt;/H2&gt;"
$fragments += $data | Select Machinename,TimeGenerated,Source,EntryType,Message |
 ConvertTo-html -as Table -Fragment

$head = @"
&lt;Title&gt;Event Log Summary&lt;/Title&gt;
&lt;style&gt;
h2 {
width:95%;
background-color:#'7BA7C7;
font-family:Tahoma;
font-size:10pt; 
font-color:Black;
}
body { background-color:#'FFFFFF;
       font-family:Tahoma;
       font-size:10pt; }
td, th { border:1px solid black; 
         border-collapse:collapse; }
th { color:white;
     background-color:black; }
table, tr, td, th { padding: 2px; margin: 0px }
tr:nth-child(odd) {background-color: lightgray}
table { width:95%;margin-left:5px; margin-bottom:20px;}
&lt;/style&gt;
"@

#' build the HTML 
$html = ConvertTo-Html -Body $fragments -PostContent "&lt;h6&gt;$(Get-Date)&lt;/h6&gt;" -Head $head

#'save results to a file
$filename = Join-path -Path $OutputPath -ChildPath "$(Get-Date -UFormat '%Y%m%d_%H%M')_EventlogReport.htm"
Write-Host "Saving file to $filename" -ForegroundColor Cyan

Set-content -Path $filename -Value $html -Encoding Ascii

#'email as an html message
if ($SendTo) {
    $mailparams = @{
        To = $SendTo
        Subject = "Event Log Report" 
        Body = ($html| out-string) 
        BodyAsHtml = $True
    }

    Write-Host "Sending email to $($mailparams.to)" -ForegroundColor Cyan
    Send-MailMessage @mailParams

}

#'end of script</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>count</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>count</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'This will get you count:

get-alias | measure

'You can work with the result as with object:

$m$ = get-alias | measure
$m.Count

'And if you would like to have aliases in some variable also, you can use Tee-Object:

$m = get-alias | tee -Variable aliases | measure
$m.Count

'===================================================================

$Counter = $(get-alias | measure).Count

'===================================================================

get-alias | measure | % { $_.Count }

'===================================================================
'This just returns the Count property of the array returned by the antecedent sub-expression:

@(Get-Alias).Count

'This applies to Powershell v3
(get-alias).count

'===================================================================

'You can put an arbitrarily complex expression in place of Get-Alias, for example:

@(Get-Process | ? { $_.ProcessName -eq "svchost" }).Count

'The initial at-sign (@) is necessary for a robust solution. 
'As long as the answer is two or greater you will get an equivalent answer with or without the @, 
'but when the answer is zero or one you will get no output unless you have the @ sign! 
'(It forces the Count property to exist by forcing the output to be an array.)

'The above is true for PowerShell V2. One of the new features of
' PowerShell V3 is that you do have a Count property even for singletons, 
'so the at-sign becomes unimportant for this scenario.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_cmdlet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_cmdlet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://techibee.com/powershell/powershell-get-ip-address-subnet-gateway-dns-serves-and-mac-address-details-of-remote-computer/1367

'You can save this script to a PS1 fil(say Get-IPDetails.PS1) and run it against list of computers you need. Below is one example.

'USAGE
&gt; .\Get-IPDetails.ps1 -ComputerName MyPC1 | ft - Autosize




=======================================================================

[cmdletbinding()]            
param (            
 [parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]            
    [string[]]$ComputerName = $env:computername            
)                        
            
begin {}            
process {            
 foreach ($Computer in $ComputerName) {            
  if(Test-Connection -ComputerName $Computer -Count 1 -ea 0) {            
   try {            
    $Networks = Get-WmiObject Win32_NetworkAdapterConfiguration -ComputerName $Computer -EA Stop | ? {$_.IPEnabled}            
   } catch {            
        Write-Warning "Error occurred while querying $computer."            
        Continue            
   }            
   foreach ($Network in $Networks) {            
    $IPAddress  = $Network.IpAddress[0]            
    $SubnetMask  = $Network.IPSubnet[0]            
    $DefaultGateway = $Network.DefaultIPGateway            
    $DNSServers  = $Network.DNSServerSearchOrder            
    $IsDHCPEnabled = $false            
    If($network.DHCPEnabled) {            
     $IsDHCPEnabled = $true            
    }            
    $MACAddress  = $Network.MACAddress            
    $OutputObj  = New-Object -Type PSObject            
    $OutputObj | Add-Member -MemberType NoteProperty -Name ComputerName -Value $Computer.ToUpper()            
    $OutputObj | Add-Member -MemberType NoteProperty -Name IPAddress -Value $IPAddress            
    $OutputObj | Add-Member -MemberType NoteProperty -Name SubnetMask -Value $SubnetMask            
    $OutputObj | Add-Member -MemberType NoteProperty -Name Gateway -Value $DefaultGateway            
    $OutputObj | Add-Member -MemberType NoteProperty -Name IsDHCPEnabled -Value $IsDHCPEnabled            
    $OutputObj | Add-Member -MemberType NoteProperty -Name DNSServers -Value $DNSServers            
    $OutputObj | Add-Member -MemberType NoteProperty -Name MACAddress -Value $MACAddress            
    $OutputObj            
   }            
  }            
 }            
}            
            
end {}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>IsAComputerThere</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>IsAComputerThere</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'True if it responds:
cls
$ComputerIsThere = Test-Connection -Computername 10.11.54.51 -BufferSize 16 -Count 1 -Quiet
$ComputerIsThere</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Patch_Query_list_of_Computers_to_see_if_a_patch_is_installed</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Patch_Query_list_of_Computers_to_see_if_a_patch_is_installed</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://gallery.technet.microsoft.com/scriptcenter/Powershell-Query-a-patch-67cf35f8

#'The script uses GET-HOTFIX powershell cmdlet to query local or remote computers 
#'    to gather the patch/hotfix state either installed or missing on the list of servers based on the KB number. 
#'    It also queries and reports other basic OS details like OS version, system type , ping connectivity check and last boot time etc. 
#'These information is consolidate and saved into excel format to provide better human readable format.
#'
#' 
#'
#'The script, by default reads the list of servers from "C:\Computers.txt" , prompts for user input for kb number and saves the generated excel report to "C:\patchinfo*.xlsx"
#'
#'It doesn't overwrite the file automatically if the file exist by the name to avoid accidental deletion.
#'
#'The computer on which the script is run should have excel 2007 or later installed.


  
#### Spreadsheet Location 
 $DirectoryToSaveTo = "c:\" 
 $date=Get-Date -format "yyyy-MM-d" 
 $Filename="Patchinfo-$($patch)" 
 
  
 ###InputLocation 
 $Computers = Get-Content "c:\computers.txt" 
 # Enter KB to be checked here 
 $Patch = Read-Host 'Enter the KB number ? - eg: KB3011780 ' 
  
 
  
# before we do anything else, are we likely to be able to save the file? 
# if the directory doesn't exist, then create it 
if (!(Test-Path -path "$DirectoryToSaveTo")) #create it if not existing 
  { 
  New-Item "$DirectoryToSaveTo" -type directory | out-null 
  } 
   
 
 
#Create a new Excel object using COM  
$Excel = New-Object -ComObject Excel.Application 
$Excel.visible = $True 
$Excel = $Excel.Workbooks.Add() 
$Sheet = $Excel.Worksheets.Item(1) 
 
$sheet.Name = 'Patch status - ' 
#Create a Title for the first worksheet 
$row = 1 
$Column = 1 
$Sheet.Cells.Item($row,$column)= 'Patch status'  
 
$range = $Sheet.Range("a1","f2") 
$range.Merge() | Out-Null 
$range.VerticalAlignment = -4160 
 
#Give it a nice Style so it stands out 
$range.Style = 'Title' 
 
#Increment row for next set of data 
$row++;$row++ 
 
#Save the initial row so it can be used later to create a border 
#Counter variable for rows 
$intRow = $row 
$xlOpenXMLWorkbook=[int]51 
 
#Read thru the contents of the Servers.txt file 
 
$Sheet.Cells.Item($intRow,1)  ="Name" 
$Sheet.Cells.Item($intRow,2)  ="status" 
$Sheet.Cells.Item($intRow,3)  ="Patch status" 
$Sheet.Cells.Item($intRow,4)  ="OS" 
$Sheet.Cells.Item($intRow,5)  ="SystemType" 
$Sheet.Cells.Item($intRow,6)  ="Last Boot Time" 
 
 
for ($col = 1; $col –le 6; $col++) 
     { 
          $Sheet.Cells.Item($intRow,$col).Font.Bold = $True 
          $Sheet.Cells.Item($intRow,$col).Interior.ColorIndex = 48 
          $Sheet.Cells.Item($intRow,$col).Font.ColorIndex = 34 
     } 
 
$intRow++ 
 
 
Function GetStatusCode 
{  
    Param([int] $StatusCode)   
    switch($StatusCode) 
    { 
        0         {"Success"} 
        11001   {"Buffer Too Small"} 
        11002   {"Destination Net Unreachable"} 
        11003   {"Destination Host Unreachable"} 
        11004   {"Destination Protocol Unreachable"} 
        11005   {"Destination Port Unreachable"} 
        11006   {"No Resources"} 
        11007   {"Bad Option"} 
        11008   {"Hardware Error"} 
        11009   {"Packet Too Big"} 
        11010   {"Request Timed Out"} 
        11011   {"Bad Request"} 
        11012   {"Bad Route"} 
        11013   {"TimeToLive Expired Transit"} 
        11014   {"TimeToLive Expired Reassembly"} 
        11015   {"Parameter Problem"} 
        11016   {"Source Quench"} 
        11017   {"Option Too Big"} 
        11018   {"Bad Destination"} 
        11032   {"Negotiating IPSEC"} 
        11050   {"General Failure"} 
        default {"Failed"} 
    } 
} 
 
 
 
Function GetUpTime 
{ 
    param([string] $LastBootTime) 
    $Uptime = (Get-Date) - [System.Management.ManagementDateTimeconverter]::ToDateTime($LastBootTime) 
    "Days: $($Uptime.Days); Hours: $($Uptime.Hours); Minutes: $($Uptime.Minutes); Seconds: $($Uptime.Seconds)"  
} 
 
 
foreach ($Computer in $Computers) 
 { 
 
 TRY { 
 $OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer 
 $sheetS = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Computer 
 $sheetPU = Get-WmiObject -Class Win32_Processor -ComputerName $Computer 
 $drives = Get-WmiObject -ComputerName $Computer Win32_LogicalDisk | Where-Object {$_.DriveType -eq 3} 
 $pingStatus = Get-WmiObject -Query "Select * from win32_PingStatus where Address='$Computer'" 
 $OSRunning = $OS.caption + " " + $OS.OSArchitecture + " SP " + $OS.ServicePackMajorVersion 
 $systemType=$sheetS.SystemType 
 $date = Get-Date 
 $uptime = $OS.ConvertToDateTime($OS.lastbootuptime) 
   
 if  
 ($kb=get-hotfix -id $Patch -ComputerName $computer -ErrorAction 2) 
 
 { 
 $kbinstall="$patch is installed" 
 } 
 else 
 { 
 $kbinstall="$patch is not installed" 
 } 
 
  
  
 if($pingStatus.StatusCode -eq 0) 
    { 
        $Status = GetStatusCode( $pingStatus.StatusCode ) 
    } 
else 
    { 
    $Status = GetStatusCode( $pingStatus.StatusCode ) 
       } 
 } 
  
 CATCH 
 { 
 $pcnotfound = "true" 
 } 
 #### Pump Data to Excel 
 if ($pcnotfound -eq "true") 
 { 
 #$sheet.Cells.Item($intRow, 1) = "PC Not Found" 
 $sheet.Cells.Item($intRow, 1) = $computer 
 $sheet.Cells.Item($intRow, 2) = "PC Not Found" 
 } 
 else 
 { 
 $sheet.Cells.Item($intRow, 1) = $computer 
 $sheet.Cells.Item($intRow, 2) = $status 
 $Sheet.Cells.Item($intRow, 3) = $kbinstall 
 $sheet.Cells.Item($intRow, 4) = $OSRunning 
 $Sheet.Cells.Item($intRow, 5) = $SystemType 
 $sheet.Cells.Item($intRow, 6) = $uptime 
 } 
 
  
$intRow = $intRow + 1 
 $pcnotfound = "false" 
 } 
 
$erroractionpreference = “SilentlyContinue”  
 
$Sheet.UsedRange.EntireColumn.AutoFit() 
########################################333 
 
 
 
############################################################## 
 
$filename = "$DirectoryToSaveTo$filename.xlsx" 
#if (test-path $filename ) { rm $filename } #delete the file if it already exists 
$Sheet.UsedRange.EntireColumn.AutoFit() 
$Excel.SaveAs($filename, $xlOpenXMLWorkbook) #save as an XML Workbook (xslx) 
$Excel.Saved = $True 
$Excel.Close() 
$Excel.DisplayAlerts = $False 
$Excel.quit() </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PING_Test-Connection</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PING_Test-Connection</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Test-Connection www.cnbc.com -Count 1000</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Selecting_Objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Selecting_Objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'The Select-Object cmdlets allows us to select from a collection of objects the ones we want when we specify the index position of the item. 
'Just like all programing languages we start our count with 0.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -Index 0,1,2,3,4 

'The Select-Object cmdlets allows us to select from a collection of objects the ones we want when we specify the index position of the item. 
'	Just like all programing languages we start our count with 0.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -Index 0,1,2,3,4 

'We can also use the range notation, 
'	this will return an array of number for the range and we can pass those to the index parameter.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -Index (0..4)

'Select the first number of objects, the last number of objects or even skip a certain number.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -first 5 

'The select-object cmdlets also allows us to create and rename an objects property, 
'	this is very useful when the property name is not to descriptive and when we are passing from one comdlet to another 
'	where the next cmdlet accepts and processes objects by Property Name. 
'	The way it works is that we create a hash with 2 values in it, 
'	one is Name which is the name we want for the property and the other is expressions 
'	which is a script block whose returning value will be set as the value of the property we named.

PS &gt; Get-Process | Select-Object -Property name,@{name = 'PID'; expression = {$_.id}} 				'&lt;== NOT CLEAR where the renameing is being done

'One thing that we have to be very careful with when using Select-Object 
'	is that when we select property names using it actually generates a new object 
'	of the same type with only those properties that we selected and strips out the rest. </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Services_for_List_of_Remote_computers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Services_for_List_of_Remote_computers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Services_for_List_of_Remote_computers


https://social.technet.microsoft.com/Forums/ie/en-US/edd9d9f6-1b03-411c-8785-dc3de53359bd/script-to-get-list-of-remote-services-filtered-based-on-log-on-as-account?forum=winserverpowershell

#'You can use the Win32_Service WMI Class
#'For example, to find out the list of services running under the Local System Account 
#'    on a remote computer named Demo123, 
#'       you may use the following code:


Get-WMIObject Win32_Service -ComputerName Demo123 | Where-Object{$_.StartName -eq 'LocalSystem'} | Sort-Object -Property StartName | Format-Table Name, StartName

#'To run this as a script,
#'Input all server names in a text file (one on each line)
#'

$compArray = get-content C:\Scripts\Servers.txt
foreach($strComputer in $compArray)
{
Get-WMIObject Win32_Service -ComputerName $strComputer | Where-Object{$_.StartName -eq 'LocalSystem'} | Sort-Object -Property StartName | Format-Table Name, StartName
}
---------------------------------------------------------------------------

&gt;Get-Service -ComputerName "Server02"

-----------------------------

&gt; Get-Service -Name "WinRM" -ComputerName "localhost", "Server01", "Server02" | Format-Table -Property MachineName, Status, Name, DisplayName -auto


---------------------------------------------------------------------------
https://social.technet.microsoft.com/Forums/windowsserver/en-US/75b3dcde-af1e-4d87-9eff-ce923b090ef8/get-services-from-remote-computers?forum=winserverpowershell

#'I recommend to import the server names from a textfile:
#'$server = Get-Content -path C:\User\Test\Desktop\...
$server = get-content -path C:\DATA\PowerShellScripts\computers.txt

#'After that you are going through a foreach-loop to execute the code for each server:
$server | foreach { (Get-Service -Name ccm* -computername $_) |
 Select-Object Status, Name, DisplayName | 
ConvertTo-HTML | Out-File "C:\DATA\PowerShellScripts\computerServicesList.htm"}

-------------------------------------------------------------

$array = @()            
foreach($i in (gc computers.txt)) {            
 $svc = Get-Service winrm -ComputerName $i -ea "0"            
 $obj = New-Object psobject -Property @{            
  Name = $svc.name            
  Status = $svc.status            
  Computer = $i            
  }            
 $array += $obj            
}                      
$array | Select Computer,Name,Status | FT -AutoSize</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Modules</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>default_path_for_Modules</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Modules</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>default_path_for_Modules</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'To get the value of the PSModulePath environment variable, use either of the following commands.
$Env:PSModulePath
[Environment]::GetEnvironmentVariable("PSModulePath")
==========================================================================

'By default, the PSModulePath environment variable value contains the following system and user module directories, but you can add to and edit the value.
$PSHome\Modules (%Windir%\System32\WindowsPowerShell\v1.0\Modules) 

'This location is reserved for modules that ship with Windows. Do not install modules to this location.
$Home\Documents\WindowsPowerShell\Modules (%UserProfile%\Documents\WindowsPowerShell\Modules)

%Windir%\System32\WindowsPowerShell\v1.0\Modules 
(for Win 7 = C:\Windows\System32\WindowsPowerShell\v1.0\Modules)

$Env:ProgramFiles\WindowsPowerShell\Modules (%ProgramFiles%\WindowsPowerShell\Modules)

==========================================================================

'To add a module path to value of the PSModulePath environment variable value, 
'use the following command format. 
'This format uses the SetEnvironmentVariable method of the System.Environment class to make a session-independent change 
'to the PSModulePath environment variable.

#Save the current value in the $p variable.
$p = [Environment]::GetEnvironmentVariable("PSModulePath")

#Add the new path to the $p variable. Begin with a semi-colon separator.
$p += ";C:\DATA\psModules\"

#Add the paths in $p to the PSModulePath value.
[Environment]::SetEnvironmentVariable("PSModulePath",$p)

==========================================================================
'Where to Install Modules
--------------------------

'you want the module to be available for your user account only;
$home\Documents\WindowsPowerShell\Modules\&lt;Module Folder&gt;\&lt;Module Files&gt;

e.g.: C:\Users\glenn\Documents\WindowsPowerShell\Modules

'Installing Modules for all Users
$EnvProgramFiles\WindowsPowerShell\Modules\&lt;Module Folder&gt;\&lt;Module Files&gt;


#'Each module should be stored in a sub folder of either of these paths 
#'and typically be the name of the module – within that folder 
#'you will then store the files that make up the module. 
#'At the least, we need a *.psm1 file. In this file could be placed 
#'a number of functions or variables that make up the module. 
#'In addition it is possible to place PowerShell scripts in *.ps1 files 
#'in the module’s folder and reference them in the *.psm1 file. 
#'As a final touch, a module manifest file can be created 
#'which will give a more professional and rounded feel to your module, 
#'but we will come on to manifests later.

==========================================================================
'for more details: 
https://msdn.microsoft.com/en-us/library/dd878350(v=vs.85).aspx</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_List_Features_Roles__local_server.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_List_Features_Roles__local_server.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Import-Module ServerManager
$Arr = Get-WindowsFeature | Where-Object {$_.Installed -match “True”} | Select-Object -Property Name
$loopCount = $Arr.Count
For($i=0; $i -le $loopCount; $i++) {
    Write-Host $Arr[$i]
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CheckListOfComputers_ThenInventory_Live_computers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CheckListOfComputers_ThenInventory_Live_computers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

$testcomputers = Get-Content -Path 'C:\computers.txt'
$exportLocation = 'C:\PCInventory.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path C:\LivePCs.txt
		}else{
			Add-Content -value $computer -path C:\DeadPCs.txt
		}
	}
	
#'Proceed with inventory of Live PCs

$computers = Get-Content -Path 'C:\LivePCs.txt'

foreach ($computer in $computers) {
	...
	}
	
http://www.signalwarrant.com/computer-inventory-script-powershell/

# On error the script will continue silently without 
$erroractionpreference = "SilentlyContinue"
 
# TXT file containing the computers your pinging
$testcomputers = gc -Path "C:\scripts\computers.txt"
 
# Looking through the txt file above and counting computer names.
$test_computer_count = $testcomputers.Length;
$x = 0;
 
write-host -foregroundcolor cyan ""
write-host -foregroundcolor cyan "Testing $test_computer_count computers, this may take a while."
 
foreach ($computer in $testcomputers) {
        # I only send 2 echo requests to speed things up, if you want the defaut 4 
        # delete the -count 2 portion
   if (Test-Connection -ComputerName $computer -Quiet -count 2){
        # The path to the livePCs.txt file, change to meet your needs
        Add-Content -value $computer -path c:\scripts\livePCs.txt
        }else{
        # The path to the deadPCs.txt file, change to meet your needs
        Add-Content -value $computer -path c:\scripts\deadPCs.txt
        }
    $testcomputer_progress = [int][Math]::Ceiling((($x / $test_computer_count) * 100))
 # Progress bar
    Write-Progress  "Testing Connections" -PercentComplete $testcomputer_progress -Status "Percent Complete - $testcomputer_progress%" -Id 1;
 Sleep(1);
    $x++;
 
} 
 
================================================================================ 
write-host -foregroundcolor cyan ""
write-host -foregroundcolor cyan "Testing Connection complete"
write-host -foregroundcolor cyan ""
 
$ComputerName = gc -Path "C:\scripts\livePCs.txt"
 
$computer_count = $ComputerName.Length;
# The results of the script are here
$exportLocation = "C:\scripts\pcInventory.csv"
$i = 0;
 foreach ($Computer in $ComputerName){
   $Bios =get-wmiobject win32_bios -Computername $Computer
   $Hardware = get-wmiobject Win32_computerSystem -Computername $Computer
   $Sysbuild = get-wmiobject Win32_WmiSetting -Computername $Computer
   $OS = gwmi Win32_OperatingSystem -Computername $Computer
   $Networks = Get-WmiObject Win32_NetworkAdapterConfiguration -ComputerName $Computer | ? {$_.IPEnabled}
   $driveSpace = gwmi win32_volume -computername $Computer -Filter 'drivetype = 3' | 
   select PScomputerName, driveletter, label, @{LABEL='GBfreespace';EXPRESSION={"{0:N2}" -f($_.freespace/1GB)} } |
   Where-Object { $_.driveletter -match "C:" }
   $cpu = Get-WmiObject Win32_Processor  -computername $computer
   $username = Get-ChildItem "\\$computer\c$\Users" | Sort-Object LastWriteTime -Descending | Select Name, LastWriteTime -first 1
   $totalMemory = [math]::round($Hardware.TotalPhysicalMemory/1024/1024/1024, 2)
   $lastBoot = $OS.ConvertToDateTime($OS.LastBootUpTime) 
 
   #write-host -foregroundcolor yellow "Found $computer"
   $computer_progress = [int][Math]::Ceiling((($i / $computer_count) * 100))
 # Progress bar
    Write-Progress  "Gathering Hardware Info" -PercentComplete $computer_progress -Status "Percent Complete - $computer_progress%" -Id 1;
 Sleep(1);
    $i++;
   foreach ($Network in $Networks) {
    $IPAddress  = $Network.IpAddress[0]
    $MACAddress  = $Network.MACAddress
    $systemBios = $Bios.serialnumber
    $OutputObj  = New-Object -Type PSObject
    $OutputObj | Add-Member -MemberType NoteProperty -Name ComputerName -Value $Computer.ToUpper()
    $OutputObj | Add-Member -MemberType NoteProperty -Name Manufacturer -Value $Hardware.Manufacturer
    $OutputObj | Add-Member -MemberType NoteProperty -Name Model -Value $Hardware.Model
    $OutputObj | Add-Member -MemberType NoteProperty -Name CPU_Info -Value $cpu.Name
    $OutputObj | Add-Member -MemberType NoteProperty -Name SystemType -Value $Hardware.SystemType
    $OutputObj | Add-Member -MemberType NoteProperty -Name BuildVersion -Value $SysBuild.BuildVersion
    $OutputObj | Add-Member -MemberType NoteProperty -Name OS -Value $OS.Caption
    $OutputObj | Add-Member -MemberType NoteProperty -Name SPVersion -Value $OS.csdversion
    $OutputObj | Add-Member -MemberType NoteProperty -Name SerialNumber -Value $systemBios
    $OutputObj | Add-Member -MemberType NoteProperty -Name IPAddress -Value $IPAddress
    $OutputObj | Add-Member -MemberType NoteProperty -Name MACAddress -Value $MACAddress
    $OutputObj | Add-Member -MemberType NoteProperty -Name UserName -Value $username.Name
    $OutputObj | Add-Member -MemberType NoteProperty -Name Last-Login -Value $username.LastWriteTime
    $OutputObj | Add-Member -MemberType NoteProperty -Name C:_GBfreeSpace -Value $driveSpace.GBfreespace
    $OutputObj | Add-Member -MemberType NoteProperty -Name Total_Physical_Memory -Value $totalMemory
    $OutputObj | Add-Member -MemberType NoteProperty -Name Last_Reboot -Value $lastboot
    $OutputObj | Export-Csv $exportLocation -Append
   }
} 
 
 write-host -foregroundcolor cyan "Script is complete, the results are here: $exportLocation"</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-SubNetItems.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-SubNetItems.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Get-SubNetItems.ps1
'https://gallery.technet.microsoft.com/scriptcenter/SubNet-Scan-dad0311f

I ended up putting this in the MyFunctions Module


'This file Get-SubNetItems.ps1 contains only definition of Get-SubNetItems function. To use this tool try this:
'1) Load file with cmdlet definition. Don't forget first . It is important to load the cmdlets in the current namespace.
'PS&gt;. P:\Get-SubNetIte​ms.ps1

'2) And next try use function.

'Basic
PS&gt;Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.10
'Formated
Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.10 | Format-Table -Property Host, IP, OS_Name, OS_Ver, WMI  -AutoSize
'To File
Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.254 | Format-Table -Property Host, IP, OS_Name, OS_Ver, WMI  -AutoSize | Out-File C:\ListOfComputers.txt
===================================================================================
Function Get-SubNetItems
{
&lt;# 
	.SYNOPSIS 
		Scan subnet machines
		
	.DESCRIPTION 
		Use Get-SubNetItems to receive list of machines in specific IP range.

	.PARAMETER StartScanIP 
		Specify start of IP range.

	.PARAMETER EndScanIP
		Specify end of IP range.

	.PARAMETER Ports
		Specify ports numbers to scan if open or not.
		
	.PARAMETER MaxJobs
		Specify number of threads to scan.
		
	.PARAMETER ShowAll
		Show even adress is inactive.
	
	.PARAMETER ShowInstantly 
		Show active status of scaned IP address instanly. 
	
	.PARAMETER SleepTime  
		Wait time to check if threads are completed.
 
	.PARAMETER TimeOut 
		Time out when script will be break.

	.EXAMPLE 
		PS C:\&gt;$Result = Get-SubNetItems -StartScanIP 10.10.10.1 -EndScanIP 10.10.10.10 -ShowInstantly -ShowAll
		10.10.10.7 is active.
		10.10.10.10 is active.
		10.10.10.9 is active.
		10.10.10.1 is inactive.
		10.10.10.6 is active.
		10.10.10.4 is active.
		10.10.10.3 is inactive.
		10.10.10.2 is active.
		10.10.10.5 is active.
		10.10.10.8 is inactive.

		PS C:\&gt; $Result | Format-Table IP, Active, WMI, WinRM, Host, OS_Name -AutoSize

		IP           Active   WMI WinRM Host              OS_Name
		--           ------   --- ----- ----              -------
		10.10.10.1    False False False
		10.10.10.2     True  True  True pc02.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.3    False False False
		10.10.10.4     True  True  True pc05.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.5     True  True  True pc06.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.6     True  True  True pc07.mydomain.com Microsoft(R) Windows(R) Server 2003, Standard Edition
		10.10.10.7     True False False
		10.10.10.8    False False False
		10.10.10.9     True  True False pc09.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.10    True  True False pc10.mydomain.com Microsoft Windows XP Professional

	.EXAMPLE 
		PS C:\&gt; Get-SubNetItems -StartScanIP 10.10.10.2 -Verbose
		VERBOSE: Creating own list class.
		VERBOSE: Start scaning...
		VERBOSE: Starting job (1/20) for 10.10.10.2.
		VERBOSE: Trying get part of data.
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (0)
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (5)
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (10)
		VERBOSE: Trying get last part of data.
		VERBOSE: Geting job 10.10.10.2 result.
		VERBOSE: Removing job 10.10.10.2.
		VERBOSE: Scan finished.


		RunspaceId : d2882105-df8c-4c0a-b92c-0d078bcde752
		Active     : True
		Host       : pc02.mydomain.com
		IP         : 10.10.10.2
		OS_Name    : Microsoft Windows Server 2008 R2 Enterprise
		OS_Ver     : 6.1.7601 Service Pack 1
		WMI        : True
		WinRM      : True
		
	.EXAMPLE 	
		PS C:\&gt; $Result = Get-SubNetItems -StartScanIP 10.10.10.1 -EndScanIP 10.10.10.25 -Ports 80,3389,5900	

		PS C:\&gt; $Result | Select-Object IP, Host, MAC, @{l="Ports";e={[string]::join(", ",($_.Ports | Select-Object @{Label="Ports";Expression={"$($_.Port)-$($_.Status)"}} | Select-Object -ExpandProperty Ports))}} | Format-Table * -AutoSize
		
		IP          Host              MAC               Ports
		--          ----              ---               -----
		10.10.10.1                                      80-False, 3389-False, 5900-False
		10.10.10.2  pc02.mydomain.com 00-15-AD-0C-82-20 80-True, 3389-False, 5900-False
		10.10.10.5  pc05.mydomain.com 00-15-5D-1C-80-25 80-True, 3389-False, 5900-False
		10.10.10.7  pc07.mydomain.com 00-15-4D-0C-81-04 80-True, 3389-True, 5900-False
		10.10.10.9  pc09.mydomain.com 00-15-4A-0C-80-31 80-True, 3389-True, 5900-False
		10.10.10.10 pc10.mydomain.com 00-15-5D-02-1F-1C 80-False, 3389-True, 5900-False

	.NOTES 
		Author: Michal Gajda
		
		ChangeLog:
		v1.3
		-Scan items in subnet for MAC
		-Basic port scan on items in subnet
		-Fixed some small spelling bug
		
		v1.2
		-IP Range Ganerator upgrade
		
		v1.1
		-ProgressBar upgrade
		
		v1.0:
		-Scan subnet for items
		-Scan items in subnet for WMI Access
		-Scan items in subnet for WinRM Access
#&gt;

	[CmdletBinding(
		SupportsShouldProcess=$True,
		ConfirmImpact="Low" 
	)]	
	param(
		[parameter(Mandatory=$true)]
		[System.Net.IPAddress]$StartScanIP,
		[System.Net.IPAddress]$EndScanIP,
		[Int]$MaxJobs = 20,
		[Int[]]$Ports,
		[Switch]$ShowAll,
		[Switch]$ShowInstantly,
		[Int]$SleepTime = 5,
		[Int]$TimeOut = 90
	)

	Begin{}

	Process
	{
		if ($pscmdlet.ShouldProcess("$StartScanIP $EndScanIP" ,"Scan IP range for active machines"))
		{
			if(Get-Job -name *.*.*.*)
			{
				Write-Verbose "Removing old jobs."
				Get-Job -name *.*.*.* | Remove-Job -Force
			}
			
			$ScanIPRange = @()
			if($EndScanIP -ne $null)
			{
				Write-Verbose "Generating IP range list."
				# Many thanks to Dr. Tobias Weltner, MVP PowerShell and Grant Ward for IP range generator
				$StartIP = $StartScanIP -split '\.'
	  			[Array]::Reverse($StartIP)  
	  			$StartIP = ([System.Net.IPAddress]($StartIP -join '.')).Address 
				
				$EndIP = $EndScanIP -split '\.'
	  			[Array]::Reverse($EndIP)  
	  			$EndIP = ([System.Net.IPAddress]($EndIP -join '.')).Address 
				
				For ($x=$StartIP; $x -le $EndIP; $x++) {    
					$IP = [System.Net.IPAddress]$x -split '\.'
					[Array]::Reverse($IP)   
					$ScanIPRange += $IP -join '.' 
				}
			
			}
			else
			{
				$ScanIPRange = $StartScanIP
			}

			Write-Verbose "Creating own list class."
			$Class = @"
			public class SubNetItem {
				public bool Active;
				public string Host;
				public System.Net.IPAddress IP;
				public string MAC;
				public System.Object Ports;
				public string OS_Name;
				public string OS_Ver;
				public bool WMI;
				public bool WinRM;
			}
"@		

			Write-Verbose "Start scaning..."	
			$ScanResult = @()
			$ScanCount = 0
			Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete (0)
			Foreach($IP in $ScanIPRange)
			{
	 			Write-Verbose "Starting job ($((Get-Job -name *.*.*.* | Measure-Object).Count+1)/$MaxJobs) for $IP."
				Start-Job -Name $IP -ArgumentList $IP,$Ports,$Class -ScriptBlock{ 
				
					param
					(
					[System.Net.IPAddress]$IP = $IP,
					[Int[]]$Ports = $Ports,
					$Class = $Class 
					)
					
					Add-Type -TypeDefinition $Class
					
					if(Test-Connection -ComputerName $IP -Quiet)
					{
						#Get Hostname
						Try
						{
							$HostName = [System.Net.Dns]::GetHostbyAddress($IP).HostName
						}
						Catch
						{
							$HostName = $null
						}
						
						#Get WMI Access, OS Name and version via WMI
						Try
						{
							#I don't use Get-WMIObject because it havent TimeOut options. 
							$WMIObj = [WMISearcher]''  
							$WMIObj.options.timeout = '0:0:10' 
							$WMIObj.scope.path = "\\$IP\root\cimv2"  
							$WMIObj.query = "SELECT * FROM Win32_OperatingSystem"  
							$Result = $WMIObj.get()  

							if($Result -ne $null)
							{
								$OS_Name = $Result | Select-Object -ExpandProperty Caption
								$OS_Ver = $Result | Select-Object -ExpandProperty Version
								$OS_CSDVer = $Result | Select-Object -ExpandProperty CSDVersion
								$OS_Ver += " $OS_CSDVer"
								$WMIAccess = $true					
							}
							else
							{
								$WMIAccess = $false	
							}
						}	
						catch
						{
							$WMIAccess = $false					
						}
						
						#Get WinRM Access, OS Name and version via WinRM
						if($HostName)
						{
							$Result = Invoke-Command -ComputerName $HostName -ScriptBlock {systeminfo} -ErrorAction SilentlyContinue 
						}
						else
						{
							$Result = Invoke-Command -ComputerName $IP -ScriptBlock {systeminfo} -ErrorAction SilentlyContinue 
						}
						
						if($Result -ne $null)
						{
							if($OS_Name -eq $null)
							{
								$OS_Name = ($Result[2..3] -split ":\s+")[1]
								$OS_Ver = ($Result[2..3] -split ":\s+")[3]
							}	
							$WinRMAccess = $true
						}
						else
						{
							$WinRMAccess = $false
						}
						
						#Get MAC Address
						Try
						{
							$result= nbtstat -A $IP | select-string "MAC"
							$MAC = [string]([Regex]::Matches($result, "([0-9A-F][0-9A-F]-){5}([0-9A-F][0-9A-F])"))
						}
						Catch
						{
							$MAC = $null
						}
						
						#Get ports status
						$PortsStatus = @()
						ForEach($Port in $Ports)
						{
							Try
							{							
								$TCPClient = new-object Net.Sockets.TcpClient
								$TCPClient.Connect($IP, $Port)
								$TCPClient.Close()
								
								$PortStatus = New-Object PSObject -Property @{            
		        					Port		= $Port
									Status      = $true
								}
								$PortsStatus += $PortStatus
							}	
							Catch
							{
								$PortStatus = New-Object PSObject -Property @{            
		        					Port		= $Port
									Status      = $false
								}	
								$PortsStatus += $PortStatus
							}
						}

						
						$HostObj = New-Object SubNetItem -Property @{            
		        					Active		= $true
									Host        = $HostName
									IP          = $IP 
									MAC         = $MAC
									Ports       = $PortsStatus
		        					OS_Name     = $OS_Name
									OS_Ver      = $OS_Ver               
		        					WMI         = $WMIAccess      
		        					WinRM       = $WinRMAccess      
		        		}
						$HostObj
					}
					else
					{
						$HostObj = New-Object SubNetItem -Property @{            
		        					Active		= $false
									Host        = $null
									IP          = $IP  
									MAC         = $null
									Ports       = $null
		        					OS_Name     = $null
									OS_Ver      = $null               
		        					WMI         = $null      
		        					WinRM       = $null      
		        		}
						$HostObj
					}
				} | Out-Null
				$ScanCount++
				Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
				
				do
				{
					Write-Verbose "Trying get part of data."
					Get-Job -State Completed | Foreach {
						Write-Verbose "Geting job $($_.Name) result."
						$JobResult = Receive-Job -Id ($_.Id)

						if($ShowAll)
						{
							if($ShowInstantly)
							{
								if($JobResult.Active -eq $true)
								{
									Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
								}
								else
								{
									Write-Host "$($JobResult.IP) is inactive." -ForegroundColor Red
								}
							}
							
							$ScanResult += $JobResult	
						}
						else
						{
							if($JobResult.Active -eq $true)
							{
								if($ShowInstantly)
								{
									Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
								}
								$ScanResult += $JobResult
							}
						}
						Write-Verbose "Removing job $($_.Name)."
						Remove-Job -Id ($_.Id)
						Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
					}
					
					if((Get-Job -name *.*.*.*).Count -eq $MaxJobs)
					{
						Write-Verbose "Jobs are not completed ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs), please wait..."
						Sleep $SleepTime
					}
				}
				while((Get-Job -name *.*.*.*).Count -eq $MaxJobs)
			}
			
			$timeOutCounter = 0
			do
			{
				Write-Verbose "Trying get last part of data."
				Get-Job -State Completed | Foreach {
					Write-Verbose "Geting job $($_.Name) result."
					$JobResult = Receive-Job -Id ($_.Id)

					if($ShowAll)
					{
						if($ShowInstantly)
						{
							if($JobResult.Active -eq $true)
							{
								Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
							}
							else
							{
								Write-Host "$($JobResult.IP) is inactive." -ForegroundColor Red
							}
						}
						
						$ScanResult += $JobResult	
					}
					else
					{
						if($JobResult.Active -eq $true)
						{
							if($ShowInstantly)
							{
								Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
							}
							$ScanResult += $JobResult
						}
					}
					Write-Verbose "Removing job $($_.Name)."
					Remove-Job -Id ($_.Id)
					Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
				}
				
				if(Get-Job -name *.*.*.*)
				{
					Write-Verbose "All jobs are not completed ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs), please wait... ($timeOutCounter)"
					Sleep $SleepTime
					$timeOutCounter += $SleepTime				

					if($timeOutCounter -ge $TimeOut)
					{
						Write-Verbose "Time out... $TimeOut. Can't finish some jobs  ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs) try remove it manualy."
						Break
					}
				}
			}
			while(Get-Job -name *.*.*.*)
			
			Write-Verbose "Scan finished."
			Return $ScanResult | Sort-Object {"{0:d3}.{1:d3}.{2:d3}.{3:d3}" -f @([int[]]([string]$_.IP).split('.'))}
		}
	}
	
	End{}
}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Input_ListOfComputers_Output_ListThatRespondToATest</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Input_ListOfComputers_Output_ListThatRespondToATest</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

$testcomputers = Get-Content -Path 'C:\computers.txt'
$exportLocation = 'C:\PCInventory.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path C:\LivePCs.txt
		}else{
			Add-Content -value $computer -path C:\DeadPCs.txt
		}
	}
	
#'Proceed with inventory of Live PCs

$computers = Get-Content -Path 'C:\LivePCs.txt'

foreach ($computer in $computers) {
	...
	}
-------------------------------------------------------------------------	
FROM: http://www.signalwarrant.com/computer-inventory-script-powershell/

# On error the script will continue silently without 
$erroractionpreference = "SilentlyContinue"
 
# TXT file containing the computers your pinging
$testcomputers = gc -Path "C:\scripts\computers.txt"
 
# Looking through the txt file above and counting computer names.
$test_computer_count = $testcomputers.Length;
$x = 0;
 
write-host -foregroundcolor cyan ""
write-host -foregroundcolor cyan "Testing $test_computer_count computers, this may take a while."
 
foreach ($computer in $testcomputers) {
        # I only send 2 echo requests to speed things up, if you want the defaut 4 
        # delete the -count 2 portion
   if (Test-Connection -ComputerName $computer -Quiet -count 2){
        # The path to the livePCs.txt file, change to meet your needs
        Add-Content -value $computer -path c:\scripts\livePCs.txt
        }else{
        # The path to the deadPCs.txt file, change to meet your needs
        Add-Content -value $computer -path c:\scripts\deadPCs.txt
        }
    $testcomputer_progress = [int][Math]::Ceiling((($x / $test_computer_count) * 100))
 # Progress bar
    Write-Progress  "Testing Connections" -PercentComplete $testcomputer_progress -Status "Percent Complete - $testcomputer_progress%" -Id 1;
 Sleep(1);
    $x++;
 
} 
 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>IP_address_details_for_Remote_computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>IP_address_details_for_Remote_computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://techibee.com/powershell/powershell-get-ip-address-subnet-gateway-dns-serves-and-mac-address-details-of-remote-computer/1367

'You can save this script to a PS1 fil(say Get-IPDetails.PS1) and run it against list of computers you need. Below is one example.

'USAGE

&gt; .\Get-IPDetails.ps1 -ComputerName BCC-EXPLORER3 | Format-table -AutoSize




=======================================================================

[cmdletbinding()]            
param (            
 [parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]            
    [string[]]$ComputerName = $env:computername            
)                        
            
begin {}            
process {            
 foreach ($Computer in $ComputerName) {            
  if(Test-Connection -ComputerName $Computer -Count 1 -ea 0) {            
   try {            
    $Networks = Get-WmiObject Win32_NetworkAdapterConfiguration -ComputerName $Computer -EA Stop | ? {$_.IPEnabled}            
   } catch {            
        Write-Warning "Error occurred while querying $computer."            
        Continue            
   }            
   foreach ($Network in $Networks) {            
    $IPAddress  = $Network.IpAddress[0]            
    $SubnetMask  = $Network.IPSubnet[0]            
    $DefaultGateway = $Network.DefaultIPGateway            
    $DNSServers  = $Network.DNSServerSearchOrder            
    $IsDHCPEnabled = $false            
    If($network.DHCPEnabled) {            
     $IsDHCPEnabled = $true            
    }            
    $MACAddress  = $Network.MACAddress            
    $OutputObj  = New-Object -Type PSObject            
    $OutputObj | Add-Member -MemberType NoteProperty -Name ComputerName -Value $Computer.ToUpper()            
    $OutputObj | Add-Member -MemberType NoteProperty -Name IPAddress -Value $IPAddress            
    $OutputObj | Add-Member -MemberType NoteProperty -Name SubnetMask -Value $SubnetMask            
    $OutputObj | Add-Member -MemberType NoteProperty -Name Gateway -Value $DefaultGateway            
    $OutputObj | Add-Member -MemberType NoteProperty -Name IsDHCPEnabled -Value $IsDHCPEnabled            
    $OutputObj | Add-Member -MemberType NoteProperty -Name DNSServers -Value $DNSServers            
    $OutputObj | Add-Member -MemberType NoteProperty -Name MACAddress -Value $MACAddress            
    $OutputObj            
   }            
  }            
 }            
}            
            
end {} </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PING_List_Create_file_of_LIVE_and_DEAD_machines</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PING_List_Create_file_of_LIVE_and_DEAD_machines</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$testcomputers = Get-Content -Path 'C:\DATA\DeskTops_AIO_EB_2018_04_03.txt'


#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path C:\DATA\ComputersThatRespondToPing.txt
		}else{
			Add-Content -value $computer -path C:\DATA\DeadPCs.txt
		}
	}

#'EXAMLE - Proceed with inventory of Live PCs
get-officeversion 'C:\DATA\ComputersThatRespondToPing.txt' 'C:\DATA\OfficeVersions.csv'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_a_Get-Members</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_a_Get-Members</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Example_1_a_Get-Members

--------------------------------------------------------------------------
'use "Get-Member" to get the 'Properties' and 'Methods' of an object
&gt;Get-Vegetable | Get-Member

'OUTPUT

   TypeName: Vegetable       '&lt;========== Here is the type of each object (i.e. row)above

Name        MemberType Definition                    
----        ---------- ----------                    
Equals      Method     bool Equals(System.Object obj)		'&lt;===== Built in by Microsoft
GetHashCode Method     int GetHashCode()     				'&lt;===== Built in by Microsoft        
GetType     Method     type GetType()       				'&lt;===== Built in by Microsoft         
Peel        Method     void Peel()                   
Prepare     Method     void Prepare(Status State)    
ToString    Method     string ToString()         			'&lt;===== Built in by Microsoft    
Color       Property   VegColor Color {get;set;}     
CookedState Property   Status CookedState {get;set;} 
Count       Property   int Count {get;set;}          
IsPeeled    Property   bool IsPeeled {get;set;}      
IsRoot      Property   bool IsRoot {get;set;}        
Name        Property   string Name {get;set;}        
UPC         Property   int UPC {get;set;}  

--------------------------------------------------------------------------
'To see just the object (from the output) properties
&gt;Get-Vegetable | Get-Member -MemberType Properties | more

'OUPUT
   TypeName: Vegetable

Name        MemberType Definition                   
----        ---------- ----------                   
Color       Property   VegColor Color {get;set;}    
CookedState Property   Status CookedState {get;set;}
Count       Property   int Count {get;set;}         
IsPeeled    Property   bool IsPeeled {get;set;}     
IsRoot      Property   bool IsRoot {get;set;}       
Name        Property   string Name {get;set;}       
UPC         Property   int UPC {get;set;}   

'#notice that default output names may not match actual property names
--------------------------------------------------------------------------
'Or to just get the Methods
Get-Vegetable | Get-Member -MemberType Method

'OR get just one object, and select all of it's properties

&gt;Get-Vegetable corn | Select *
'OUTPUT
===============
#'Name        : corn
#'Count       : 1
#'UPC         : 4817
#'CookedState : Roasted
#'IsRoot      : False
#'IsPeeled    : False
#'Color       : yellow
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_c_Sort_by_Property</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_c_Sort_by_Property</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Example_1_c_Sort_by_Property

'To sort the objects by one property (i.e. 'Count') , then show several properties (i.e. Count,Name)
Get-Vegetable | Sort Count -Descending | Select Count,Name
------------------------------------------------------------------------- CUSTOM PROPERTY
'create a Custom Property ("ColorValue")
'This uses the color enumeration to get the 'Value' of the enumeration
'Uses a custom Hash table (Key,Value) pair
' where "$_" means the current object being processed by the expression
'		Then get that objects 'color' property, and then the 'value__' property of that 'color'
'NOTE: the sort is by the color value, not the string
&gt;Get-Vegetable | Select Name,Color,@{Name="ColorValue";Expression={$_.color.value__}} | sort Color
'OUTPUT
Name         Color ColorValue
----         ----- ----------
cucumber     green          0
peas         green          0
broccoli     green          0
zucchini     green          0
spinach      green          0
pepper       green          0
tomato         red          1
radish         red          1
pepper         red          1
cauliflower  white          2
corn        yellow          3
pepper      yellow          3
carrot      orange          4
turnip      purple          5
eggplant    purple          5
potato       brown          6

'To sort by the string:
&gt;Get-Vegetable | sort {$_.color.tostring()} 
'OUTPUT
UPC     Count Name          State    Color     
---     ----- ----          -----    -----     
4681       13 potato        Fried    brown     
4722        1 cucumber      Raw      green     
4518       13 peas          Steamed  green     
4190       14 broccoli      Steamed  green     
4061       15 zucchini      Raw      green     
4483       16 spinach       Raw      green     
4723       16 pepper        Sauteed  green     
4409        8 carrot        Raw      orange    
4762       11 turnip        Boiled   purple    
4275        4 eggplant      Fried    purple    
4247        9 tomato        Raw      red       
4488        8 radish        Raw      red       
4313        1 pepper        Sauteed  red       
4058        8 cauliflower   Steamed  white     
4945        4 corn          Roasted  yellow    
4643       19 pepper        Sauteed  yellow  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_d_Select</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_d_Select</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Example_1_d_Select_properties


'use 'Select' (i.e. the alias) or 'Select-Object' (the full command name)
'To just select the 'Name' property:0
&gt;Get-Vegetable | Select -property Name

'OUTPUT
Name       
----       
corn       
tomato     
cucumber   
carrot     
radish     
peas       
turnip     
potato     
broccoli   
zucchini   
spinach    
cauliflower
pepper     
pepper     
pepper     
eggplant  

'And you can give the 'select' command a comma-delimited list:
Get-Vegetable | Select Name,Count,State
'NOTE 'State' would not return anything b/c if you look in the list above of properties, 'State' is not listed
'Rather use 'CookedState' which is the real name of the property

'To get all the properties that start w/ 'C' you can use a wild card:
Get-Vegetable | Select Name,C*

'To get the first root vegetable object:
&gt;Get-Vegetable -RootOnly | Select -First 1
--------------------------------------------------------------------------
'If you want to get a list of the property names, just select 1 object:
&gt;Get-Vegetable  | Select -First 1 -Property *
'OUTPUT

Name        : corn
Count       : 4
UPC         : 4945
CookedState : Roasted
IsRoot      : False
IsPeeled    : False
Color       : yellow
--------------------------------------------------------------------------
'To get the list of unique names: NOTE this is still outputting OBJECTS
&gt;Get-Vegetable | Select Name -Unique

'To get it to output TEXT, you have to expand the property
'This would look the same, but it would be TEXT
&gt;Get-Vegetable | Select -Unique -ExpandProperty Name


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_f_Group_Objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_f_Group_Objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
-------------------------------------------------------------------------GROUP

'Group-Object outputs a new type of object
Get-Vegetable | Group-Object -Property color
'OUTPUT
Count Name                      Group                                                                                                                                    
----- ----                      -----                                                                                                                                    
    2 yellow                    {Vegetable, Vegetable}                                                                                                                   
    3 red                       {Vegetable, Vegetable, Vegetable}                                                                                                        
    6 green                     {Vegetable, Vegetable, Vegetable, Vegetable...}                                                                                          
    1 orange                    {Vegetable}                                                                                                                              
    2 purple                    {Vegetable, Vegetable}                                                                                                                   
    1 brown                     {Vegetable}                                                                                                                              
    1 white                     {Vegetable}     
    
    'You can even see they MemberType of the new type of object:
&gt;Get-Vegetable | Group-Object -Property color | Get-Member
'OUTPUT
   TypeName: Microsoft.PowerShell.Commands.GroupInfo

Name        MemberType Definition                                                      
----        ---------- ----------                                                      
Equals      Method     bool Equals(System.Object obj)                                  
GetHashCode Method     int GetHashCode()                                               
GetType     Method     type GetType()                                                  
ToString    Method     string ToString()                                               
Count       Property   int Count {get;}                                                
Group       Property   System.Collections.ObjectModel.Collection[psobject] Group {get;}
Name        Property   string Name {get;}                                              
Values      Property   System.Collections.ArrayList Values {get;}   

'you can then work with that new object type, and sort it
Get-Vegetable | Group color | sort count -Descending
'OUTPUT:
Count Name                      Group                                                                                                                                    
----- ----                      -----                                                                                                                                    
    6 green                     {Vegetable, Vegetable, Vegetable, Vegetable...}                                                                                          
    3 red                       {Vegetable, Vegetable, Vegetable}                                                                                                        
    2 yellow                    {Vegetable, Vegetable}                                                                                                                   
    2 purple                    {Vegetable, Vegetable}                                                                                                                   
    1 orange                    {Vegetable}                                                                                                                              
    1 brown                     {Vegetable}                                                                                                                              
    1 white                     {Vegetable} 

'Now to actually see the names of the vegetables in the first of those new objects 

&gt;Get-Vegetable | Group color | sort count -Descending | select -first 1 -ExpandProperty group
'OUTPUT:
UPC     Count Name          State    Color     
---     ----- ----          -----    -----     
4722        1 cucumber      Raw      green     
4518       13 peas          Steamed  green     
4190       14 broccoli      Steamed  green     
4061       15 zucchini      Raw      green     
4483       16 spinach       Raw      green     
4723       16 pepper        Sauteed  green    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_from_PluralSight_PuttingPowershellToWork</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_from_PluralSight_PuttingPowershellToWork</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>from PluralSight "Putting Powershell T oWork" Chapter 4

'This example is downloaded from the MS repository: 'PSGallery'
&gt;Get-PSRepository
'shows the list of available repositories

&gt;find-module psteachingtools
'OUTPUT:
Version    Name                                Repository           Description 
-------    ----                                ----------           ----------- 
1.1.0      PSTeachingTools                     PSGallery            A set of ...

'Then install it:
&gt;install-module psteachingtools

'These are just for teaching about objects, the commands are for some vegetables

&gt;Get-command -module psteachingtools| more


CommandType     Name                                               Version    Source                                                                                     
-----------     ----                                               -------    ------                                                                                     
Function        Get-Vegetable                                      1.1.0      psteachingtools                                                                            
Function        New-Vegetable                                      1.1.0      psteachingtools                                                                            
Function        Set-Vegetable                                      1.1.0      psteachingtools                                                                            
Function        Start-TypedDemo                                    1.1.0      psteachingtools     

'To get help about a command
&gt;help Get-Vegetable
--------------------------------------------------------------------------
'When you run the command you back a bunch of objects (1 on each row)
'The column headings are the properties of the object
&gt;Get-Vegetable

UPC     Count Name          State    Color     
---     ----- ----          -----    -----     
4945        4 corn          Roasted  yellow    
4247        9 tomato        Raw      red       
4722        1 cucumber      Raw      green     
4409        8 carrot        Raw      orange    
4488        8 radish        Raw      red       
4518       13 peas          Steamed  green     
4762       11 turnip        Boiled   purple    
4681       13 potato        Fried    brown     
4190       14 broccoli      Steamed  green     
4061       15 zucchini      Raw      green     
4483       16 spinach       Raw      green     
4058        8 cauliflower   Steamed  white     
4723       16 pepper        Sauteed  green     
4313        1 pepper        Sauteed  red       
4643       19 pepper        Sauteed  yellow    
4275        4 eggplant      Fried    purple 




--------------------------------------------------------------------------
'To set properties, run help on the 'set' command
&gt;help set-vegetable
--------------------------------------------------------------------------

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_h_Where-Object_to_filter</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_h_Where-Object_to_filter</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Example_1_h_Where-Object_to_filter


help Where-Object
#'simple filtering
Get-Vegetable | where-object -property color -eq yellow
#'legacy
Get-Vegetable | where {$_.color -eq 'yellow' }
#'you may also see this
Get-Vegetable | where {$psitem.color -eq 'yellow' }

'Use "$_." with Brackets for "where"
Get-Vegetable | where {$_.count -gt 10 -and $_.color -eq 'green'} | sort count -Descending
'OR with parenthesis and brackets. 
Get-Vegetable | where {($_.count -gt 10) -and ($_.color -eq 'green')} | sort count -Descending

'for a boolean:
'a) if we want IsRoot=True we can just use the variable without asking if it is =True
Get-Vegetable | where {$_.IsRoot -OR $_.color -eq 'green'} | select name,color,isroot
'b) or if want False 
Get-Vegetable | where {$_.isroot -eq $False} | Select name,isroot
'#this is better PowerShell, i.e. using -Not
Get-Vegetable | where {-Not ($_.isroot)} | Select name,isroot</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_i_Measure-Object_to_get_Count_and_Sum</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_i_Measure-Object_to_get_Count_and_Sum</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'1]: what the objects look like
&gt;Get-Vegetable -RootOnly
'OUTPUT
'==========================================
#'UPC     Count Name          State    Color     
#'---     ----- ----          -----    -----     
#'4782        5 carrot        Raw      orange    
#'4660        4 radish        Raw      red       
#'4481       16 turnip        Boiled   purple    
#'4916        8 potato        Fried    brown
     

'2] using 'Measure-Object' to get Count and Sum
&gt;Get-Vegetable -RootOnly | Measure-Object -Property count -Sum
'OUTPUT
'==========================================
#'Count    : 4
#'Average  : 
#'Sum      : 33
#'Maximum  : 
#'Minimum  : 
#'Property : Count


'3] look at the object coming out of the pipe:
&gt;Get-Vegetable -RootOnly | Measure count -sum | get-member
'OUTPUT
'==========================================
#'   TypeName: Microsoft.PowerShell.Commands.GenericMeasureInfo
#'
#'Name        MemberType Definition                                
#'----        ---------- ----------                                
#'Equals      Method     bool Equals(System.Object obj)            
#'GetHashCode Method     int GetHashCode()                         
#'GetType     Method     type GetType()                            
#'ToString    Method     string ToString()                         
#'Average     Property   System.Nullable[double] Average {get;set;}
#'Count       Property   int Count {get;set;}                      
#'Maximum     Property   System.Nullable[double] Maximum {get;set;}
#'Minimum     Property   System.Nullable[double] Minimum {get;set;}
#'Property    Property   string Property {get;set;}                
#'Sum         Property   System.Nullable[double] Sum {get;set;}
#'
   

'4] To just capture the 'sum' property and convert it to text:
Get-Vegetable -RootOnly | Measure count -sum | Select -ExpandProperty sum
'OUTPUT
'==========================================
#'33   </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_j_Foreach_Object</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_j_Foreach_Object</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>% 			'is an alias for ForEach-Object
foreach 	'is an alias for ForEach-Object

#'	When you are piping input into ForEach, 
#'	it is the alias for ForEach-Object. 
#'	But when you place ForEach at the beginning of the line, 
#'	it is a Windows PowerShell statement.


'Note there are two distinct things:
'	The 'Foreach-Object' {cmdlet} with the alias: 'ForEach'
'	and there is the 'ForEach' enumerator. 
'	THEY ARE NOT THE SAME THING

$_ 'represents the current object in the pipeline

'Use a semi-colon (;) to seperate commands on the same line

' The 'Foreach-Object' {cmdlet} has three Parameters (similar structure to 'Advanced Functions' and 'Cmdlets'}
-Begin{}	'[optional] commands (script block) that run once before anything is processed
-Process{}	'commands that run once for each incoming object (This is the default script block)
			' This is the ONLY place where you can use "$_" to represent the current object
-End{}		'[optional] commands that run once after everything is processed

===========================================================================================
#' EXAMPLE
dir c:\DATA -Directory | 
foreach -begin { $h=@{} ; $results=@() } -process { 
$stat = dir $_.FullName -file -Recurse | Measure-Object -Property length -sum
$h.Path = $_.fullname
$h.Files = $stat.count
$h.TotalSize = $stat.sum
$results+=[pscustomobject]$h
} -end { 
$results 
}

'OR  (NOTE can not break line at the following "-begin" "-process", nor "-end"

dir c:\DATA -Directory | 			#'Get Each Directory
foreach -begin { $h=@{} ; 			#'BEFORE: Initialize an empty hash table
                 $results=@() 		#'		 Initialize an empty array
               } -process {  		
               						#'Get a directory of every directory that comes through the initial command
               						#	'	and Pipe it to 'Measure-Object'
                            $stat = dir $_.FullName -file -Recurse | Measure-Object -Property length -sum
                            $h.Path = $_.fullname
                            $h.Files = $stat.count
                            $h.TotalSize = $stat.sum
                            $results+=[pscustomobject]$h	#'Create a custom object, and add the custom object to the array
                           } -end { 	#'Write the results to the Pipeline after the middle section is done
                                        $results 
                                    }
===========================================================================================   
#'get a list of numbers                                 
&gt;1..10  #' sends the numbers 1 through 10 into the pipeline

&gt;1..10 | foreach-object -process {$_ * 2}
'OUTPUT
========
#'2
#'4
#'6
#'8
#'10
#'12
#'14
#'16
#'18
#'20

'OR without the word '-process', b/c the default scriptblock is the 'process' parameter of 'foreach'
&gt;1..10 | foreach  {$_ * 2}

#' This is equivalent:
&gt;1..10 | foreach {$PSItem *2}
===========================================================================================
#' back to the Get-Vegetable teaching example

&gt;Get-Vegetable | Get-Member
#' OUTPUT
=============================== NOTE the 'Peel' Method
#'   TypeName: Vegetable
#'
#'Name        MemberType Definition                    
#'----        ---------- ----------                    
#'Equals      Method     bool Equals(System.Object obj)
#'GetHashCode Method     int GetHashCode()             
#'GetType     Method     type GetType()                
#'Peel        Method     void Peel()  				&lt;=============                 
#'Prepare     Method     void Prepare(Status State)    
#'ToString    Method     string ToString()             
#'Color       Property   VegColor Color {get;set;}     
#'CookedState Property   Status CookedState {get;set;} 
#'Count       Property   int Count {get;set;}          
#'IsPeeled    Property   bool IsPeeled {get;set;}      
#'IsRoot      Property   bool IsRoot {get;set;}        
#'Name        Property   string Name {get;set;}        
#'UPC         Property   int UPC {get;set;}  

'#Initially when we Select the Root vegetables they are not Peeled
&gt;Get-Vegetable -RootOnly | Select Name,IsPeeled
'OUTPUT
========================
#'Name   IsPeeled
#'----   --------
#'carrot    False
#'radish    False
#'turnip    False
#'potato    False

'Now apply the 'Peel' method to each object in the pipeline:
&gt;Get-Vegetable -RootOnly | foreach {$_.peel() ; get-vegetable $_.name | Select name,ispeeled}
'OUTPUT
===============
#'Name   IsPeeled
#'----   --------
#'carrot     True
#'radish     True
#'turnip     True
#'potato     True
===========================================================================================
'While you can use 'foreach, sometimes you should find the appropriate method for those objects
#'1] So while you can do this:
&gt;get-service lanmanworkstation,winmgmt,vmicvss | foreach { $_.Pause()}
#' and then verify it worked
get-service lanmanworkstation,winmgmt,vmicvss

#' it is more of a Powershell strategy to look for cmdlets
get-command -noun service

'OUTPUT
==============
#'CommandType     Name                                               Version    Source                                                
#'-----------     ----                                               -------    ------                                                
#'Cmdlet          Get-Service                                        3.1.0.0    Microsoft.PowerShell.Management                       
#'Cmdlet          New-Service                                        3.1.0.0    Microsoft.PowerShell.Management                       
#'Cmdlet          Restart-Service                                    3.1.0.0    Microsoft.PowerShell.Management                       
#'Cmdlet          Resume-Service                                     3.1.0.0    Microsoft.PowerShell.Management                       
#'Cmdlet          Set-Service                                        3.1.0.0    Microsoft.PowerShell.Management                       
#'Cmdlet          Start-Service                                      3.1.0.0    Microsoft.PowerShell.Management                       
#'Cmdlet          Stop-Service                                       3.1.0.0    Microsoft.PowerShell.Management                       
#'Cmdlet          Suspend-Service                                    3.1.0.0    Microsoft.PowerShell.Management  


#' and then use the appropriate Method
get-service lanmanworkstation,winmgmt,vmicvss | Suspend-service -PassThru

===========================================================================================
#' This would get all the files in the directory 'c:\work' that are not already .zip or .exe files
#' and then create a zip file with their name, and zip them into it.
dir c:\work -file -Recurse | 
	where {$_.length -ge 500 -AND $_.extension -notmatch ".zip|.exe"} | Foreach { 
	$file = Join-Path -path $_.Directory -ChildPath "$($_.BaseName).zip"
	Compress-Archive -path $_.fullname -DestinationPath $file -CompressionLevel Optimal -Force
	}
   
   </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_1_k_PropertyExpanding_to_text</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_1_k_PropertyExpanding_to_text</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'Objects come down the pipeline.
'Sometimes the object coming down the pipeline is a nested object
'Sometimes the object coming down the pipeline is an array, or array of nested objects

'This gets rid of the object and just gives us that property, but can only expand 1 property at a time
&gt;Get-Service winrm | Select -ExpandProperty RequiredServices
'OUTPUT
#'Status   Name               DisplayName                           
#'------   ----               -----------                           
#'Running  RPCSS              Remote Procedure Call (RPC)           
#'Running  HTTP               HTTP Service         
==============================================================
'1] when you do this to a list of objects with a single property "name" you get this:
'you get this in the text file:
'OUTPUT
=========
Name      '&lt;==== you get the name header 
----       
corn       
tomato     
cucumber   
carrot     
radish     
peas       
turnip     
potato     
broccoli   
zucchini   
spinach    
cauliflower
pepper     
eggplant   


'2] however if you expand the field you get this:
&gt;Get-Vegetable | Select -expandproperty Name -Unique
'OUTPUT
=========
corn     '&lt;==== you don't get the name header, b/c it is not an object
tomato     
cucumber   
carrot     
radish     
peas       
turnip     
potato     
broccoli   
zucchini   
spinach    
cauliflower
pepper     
eggplant

=============================================================
&gt;help Get-Vegetable -Parameter name

#'-Name &lt;String&gt;
#'    The name of a vegetable
#'    
#'    Required?                    false
#'    Position?                    0
#'    Default value                None
#'    Accept pipeline input?       True (ByPropertyName, ByValue) &lt;====
#'    Accept wildcard characters?  true
#'   

 'If you do this it won't work, b/c it is sending 'objects' with hidden characters to the file
 ' qne the parm needs a string
&gt;Get-Vegetable | Select Name -Unique | out-file c:\work\veglist.txt
&gt;get-content c:\work\veglist.txt | Where {$_ -like "c*"} | Get-Vegetable


'You can send the text into a file by expanding it
&gt;Get-Vegetable | Select -expandproperty Name -Unique | out-file c:\work\veglist.txt
&gt;get-content c:\work\veglist.txt | Where {$_ -like "c*"} | Get-Vegetable
'So now the names (that are text) are being piped back into the commandlet as a Parm

'Or pull the text directly, and then send it as a Parm to the commandlet
&gt;Get-Vegetable | Select -expandproperty Name -Unique | Where {$_ -like "c*"} |  Get-Vegetable

'OUTPUT
=======
#'UPC     Count Name          State    Color     
#'---     ----- ----          -----    -----     
#'4432        6 corn          Roasted  yellow    
#'4262        9 cucumber      Raw      green     
#'4166        8 carrot        Raw      orange    
#'4573       10 cauliflower   Steamed  white        


============================================================= .propertyname to expand a field
'This will output the expanded 'name' field as text
(get-vegetable).name

'Here you get a list of all the services that meet the criteria, as text, rather than objects
(get-service | where status -eq running).DisplayName | Sort | more

===============================================================================================
'NOT real clear on this
'NOTE: subitems to expand them, and then create variables out of them
								"$($_.name).txt"
								"$($_.count) entries"

get-eventlog application -EntryType Error,Warning | Group Source | foreach {
$file = Join-Path -path C:\work -ChildPath "$($_.name).txt"
"$($_.count) entries" | Out-File -FilePath $file
$_.group | foreach {
 $_ | Select TimeGenerated,EntryType | Out-File -FilePath $file -Append
 $_ | Select -ExpandProperty Message | Out-File -FilePath $file -Append
}
Get-Item $file
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ODBC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Modifying ODBC Settings with WMI and PowerShell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ODBC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Modifying ODBC Settings with WMI and PowerShell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://www.sqldataplatform.com/Blog/Post/9/Modifying-ODBC-Settings-with-WMI-and-PowerShell

#' This modifies an existing ODBC Setting

#'  The most important part of this script is the #Define Key to Modify section. 
#'  The $ValueName is the registry value you want to change, 
#'  in this case the "Server" value since we are moving databases to a new server. 
#'  The $Value is the new name of the server, for our example here it's SQLPROD1. 
#'  The $Key is the location of the registry key where you will change the ODBC values. 
#'  MYODBCNAME in the Key is the name of your DSN. 
#'  Create a new ODBC DSN connection and use the above script to modify it. 


#====================================================================================

#' Define Constants 

$HKEY_Local_Machine =2147483650 #This is the HKEY_Local_Machine well known value 

#' Get Class to call static methods on 

$regClass = [WMIClass]"ROOT\DEFAULT:StdRegProv" #WMIClass is a Type Accelerator 

#' Define key to modify 

$ValueName = "Server" #The registry value you want to change 

$Values = @('SQLPROD1') #SQLPROD1 is the name of the new server 

$Key = "SOFTWARE\odbc\odbc.ini\MYODBCNAME" #Location of the Key, MYODBCNAME is the DSN name. 

#' Create Value entry 

$results = $regClass.SetStringValue($HKEY_LOCAL_MACHINE, $Key, $ValueName, $Values) 

If ($results.Returnvalue -eq 0) {"Value Set"} 


#====================================================================================
#'  
#'  Now that we know how to change the ODBC on our local machine, 
#'  now we can change it on a remote PC. 
#'  This follows the same steps as our first script but now we need to add come credentials to authenticate to the target client machine. 
#'  Make sure the account you are using has elevated permissions on the remote machine. 

#Define credentials to connect to remote machine 

$Password = ConvertTo-SecureString "P@ssw0rD" -AsPlainText -Force 

$credential = New-Object System.Management.Automation.PSCredential "MyDomain\administrator", $Password 

# Define Constants 

$HKEY_Local_Machine =2147483650 #This is the HKEY_Local_Machine well known value 

# Get Class to call static methods on with credential - targets remote computername 

$regClass = get-wmiobject -list "StdRegProv" -namespace root\default -computername STL-W7User1 -credential $credential 

# Define key to modify 

$ValueName = "Server" #The registry value you want to change 

$Values = @('SQLPRD1') #Name of the new server 

$Key = "SOFTWARE\odbc\odbc.ini\MYODBCNAME" #MYODBCNAME is the DSN name. 

# Create Value entry 

$results = $regClass.SetStringValue($HKEY_LOCAL_MACHINE, $Key, $ValueName, $Values) 

If ($results.Returnvalue -eq 0) {"Value Set"} 

#'===============================================================================

#'  Here we have passed credentials to the remote machine so we can execute the script. 
#'  You will also notice the addition of –computername 
#'  under the #Define Constants section, 
#'  this is the target computer name STL-W7User1. 
#'  Setup a new ODBC on a remote PC and test again. 
#'  
#'  Now that we know how to change the ODBC connection for both local and remote PCs, 
#'  but how can we change it for more than a single remote PC, 
#'  for let's say 20 PC's? We are going to build an array, 
#'  a simple text file that has all the computer names you want to change the ODBC connection on. 
#'  After we build our array we will iterate through the array using foreach: 
#'  


#Define credentials to connect to remote machine 

$Password = ConvertTo-SecureString "P@ssw0rD" -AsPlainText -Force 

$credential = New-Object System.Management.Automation.PSCredential "MyDomain\administrator", $Password 

# Define Constants 

$HKEY_Local_Machine =2147483650 #This is the HKEY_Local_Machine well known value 

# Define array 

$strComputers = Get-Content -Path "C:\MyScripts\Computers.txt" 

# Get Class to call static methods on with credential – calls array 

$regClass = get-wmiobject -list "StdRegProv" -namespace root\default -computername $strComputers -credential $credential 

# Define key to modify 

$ValueName = "Server" #The registry value you want to change 

$Values = @('SQLPRD1') #Name of the new server 

$Key = "SOFTWARE\odbc\odbc.ini\MYODBCNAME" #MYODBCNAME is the DSN name. 

# Create Value entry 

Foreach ($objectName in $regClass) 

$results = $objectName.SetStringValue($HKEY_LOCAL_MACHINE, $Key, $ValueName, $Values) 

If ($results.Returnvalue -eq 0) {"Value Set"} 


#'  This script follows all the steps from the last script 
#'  but this time we are calling our text file to feed the computer names to build our array. 
#'  Under #Create Value Entry we use Foreach to iterate through the computer names, 
#'  this way all remote computers defined in your list will have their ODBC changed. 
#'  For the text file, I just created a simple txt file with each computer name in it. 
#'  I am calling the directory C:\MyScripts\ with the file name Computers.txt in the #Define Array section. 

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Office</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-OfficeVersion</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Office</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-OfficeVersion</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://filedb.experts-exchange.com/incoming/2015/11_w47/1030521/get-officeversion.ps1..txt
=============================================================================================
#'USAGE - Multiple Computers
$testcomputers = Get-Content -Path 'C:\DATA\DeskTops_AIO_EB_2018_04_03.txt'
$exportLocation = 'C:\DATA\OfficeVersions.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path C:\DATA\ComputersThatRespondToPing.txt
		}else{
			Add-Content -value $computer -path C:\DATA\DeadPCs.txt
		}
	}
	
#'Proceed with inventory of Live PCs
#'get-officeversion $testcomputers $exportLocation
get-officeversion -Infile C:\DATA\ComputersThatRespondToPing.txt -outfile C:\DATA\GetOffice_results.txt
=============================================================================================
#'USAGE - Single Computer
Remove-Item c:\DATA\ONE_Computer_RespondToPing.txt
#'Remove-Item c:\DATA\ONE_Computer_officeversions.csv

$testcomputers = "IT-1083"
#'$exportLocation = 'C:\DATA\OfficeVersions.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\ONE_Computer_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\ONE_Computer_DidNotPing.txt
		}
	}

 get-officeversion -infile c:\DATA\ONE_Computer_RespondToPing.txt -outfile c:\DATA\ONE_Computer_officeversions.csv


Get-Content c:\DATA\ONE_Computer_officeversions.csv

=============================================================================================
&lt;#
.Synopsis
   Get-OfficeVersion 
.DESCRIPTION
   Gets the Office version from a list of computernames and returns a CSV of the Computername and Office Version (if available)
.EXAMPLE
 get-officeversion c:\test\servers.txt c:\test\officeversions.csv
.EXAMPLE
 get-officeversion -infile c:\test\servers.txt -outfile c:\test\officeversions.csv
.NOTES
   General notes
.PARAMETER infile
A path and a filename to a text file contains a list of the computernames or ip addresses to check the office version.
.PARAMETER Outfile
A path and filename of the output .csv file

#&gt;
function Get-OfficeVersion
{
param(
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $Infile,
    
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $outfile
    )
#$outfile = 'C:\temp\office.csv'
#$infile = 'c:\temp\servers.txt'
Begin
    {
    }
 Process
    {
    $office = @()
    $computers = Get-Content $infile
    $i=0
    $count = $computers.count
    foreach($computer in $computers)
     {
     $i++
     Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
      -PercentComplete ($i/$count*100)
        $info = @{}
        $version = 0
        try{
          $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $computer) 
          $reg.OpenSubKey('software\Microsoft\Office').GetSubKeyNames() |% {
            if ($_ -match '(\d+)\.') {
              if ([int]$matches[1] -gt $version) {
                $version = $matches[1]
              }
            }    
          }
          if ($version) {
            Write-Debug("$computer : found $version")
            switch($version) {
                "7" {$officename = 'Office 97' }
                "8" {$officename = 'Office 98' }
                "9" {$officename = 'Office 2000' }
                "10" {$officename = 'Office XP' }
                "11" {$officename = 'Office 97' }
                "12" {$officename = 'Office 2003' }
                "13" {$officename = 'Office 2007' }
                "14" {$officename = 'Office 2010' }
                "15" {$officename = 'Office 2013' }
                "16" {$officename = 'Office 2016' }
                default {$officename = 'Unknown Version'}
            }
    
          }
          }
          catch{
              $officename = 'Not Installed/Not Available/Not Answering'
          }
    $info.Computer = $computer
    $info.Name= $officename
    $info.version =  $version

    $object = new-object -TypeName PSObject -Property $info
    $office += $object
    }
    $office | select computer,version,name | Export-Csv -NoTypeInformation -Path $outfile
    }
}
  write-output ("Done")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Outlook</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Remove_Outlook_mail_profile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Outlook</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Remove_Outlook_mail_profile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1] Remote to the machine (using my local PowerShell)

	'if not able to remote to the machine then, VNC into it, and enable remote powershell on the machine first
	&gt;Enable-PSRemoting -Force
	
'2] CLOSE OUTLOOK FIRST	
	
'3] Confirm that the 'Outlook' mail profile exists:

	&gt;dir HKCU:\Software\Microsoft\Office\15.0\outlook\Profiles | select -ExpandProperty PSChildName
	'It should return 'Outlook'
	
'4] To delete all the profiles including 'Outlook':

&gt;	$reg="HKCU:\Software\Microsoft\Office\15.0\Outlook\Profiles"
	$child=(Get-ChildItem -Path $reg).name
	foreach($item in $child)
	{
	    Remove-item -Path registry::$item -Recurse #-ErrorAction Inquire -WhatIf
	}
	
'5] Then start Outlook, it comes up with a 'New Profile' pop-up window.
'	type: "Outlook" in the 'Profile Name' field, then hit [Enter]
'	The 'Add Account' window for Outlook pops up =&gt; [Next]
'	another pop-up: "You must restart Outlook for these changes to take effect"
'	[Finnish]</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_OutPut</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_HashTable_and_Array_put_hashTable_into_CustomObject_and_output_a_collection_of_CustomObjects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_OutPut</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_HashTable_and_Array_put_hashTable_into_CustomObject_and_output_a_collection_of_CustomObjects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>===========================================================================================
'This creates a Hashtable, and an array in the -begin section
'in the -process section, it populates the array with a hash table for each record
'In the -end section, it writes the Array of Hashtable objects to the console


#' EXAMPLE
dir c:\DATA -Directory | 
foreach -begin { $h=@{} ; $results=@() } -process { 
$stat = dir $_.FullName -file -Recurse | Measure-Object -Property length -sum
$h.Path = $_.fullname
$h.Files = $stat.count
$h.TotalSize = $stat.sum
$results+=[pscustomobject]$h
} -end { 
$results 
}

'OR  (NOTE can not break line at the following "-begin" "-process", nor "-end"

dir c:\DATA -Directory | 			#'Get Each Directory
foreach -begin { $h=@{} ; 			#'BEFORE: Initialize an empty hash table
                 $results=@() 		#'		 Initialize an empty array
               } -process {  		
               						#'Get a directory of every directory that comes through the initial command
               						#	'	and Pipe it to 'Measure-Object'
                            $stat = dir $_.FullName -file -Recurse | Measure-Object -Property length -sum
                            $h.Path = $_.fullname
                            $h.Files = $stat.count
                            $h.TotalSize = $stat.sum
                            $results+=[pscustomobject]$h	#'Create a custom object, and add the custom object to the array
                           } -end { 	#'Write the results to the Pipeline after the middle section is done
                                        $results 
                                    }
#' OUTPUT
============================
#'Path                                           Files TotalSize
#'----                                           ----- ---------
#'C:\DATA\junkPowerShellTranscripts                  0          
#'C:\DATA\mvc-request-life-cycle                  1752 190131578
#'C:\DATA\MVC_EF_Parent_Child                      338 116821830
#'C:\DATA\New folder                                 0          
#'C:\DATA\OLD                                     2696 809039298
#'C:\DATA\PowerShellScripts                          0          
#'C:\DATA\p_0003_Inventory_FE                      238 84695272 
#'C:\DATA\p_0003_Inventory_FE - Copy               200 57573241 
#'C:\DATA\p_0003_Inventory_FE_v2                   252 57633293 
#'C:\DATA\ReversePoco_regex_generator_for_tables    44 3504399  
#'C:\DATA\RPG_Car                                  606 208402554
#'C:\DATA\SQL_with_New_changes_for_p_0003           45 85942  
  
                                    
                                    
=========================================================================================== </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_OutPut</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CSV_append</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_OutPut</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CSV_append</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

-----------------------------------------------------------------------
'Use 'append' parameter of Export-Csv
'The command uses the -Path parameter to specify the output file 
'	and the -Append parameter to add the new script data to the end of the output file, 
'	instead of replacing the existing file contents.
$ScriptFiles = Get-ChildItem D:\* -Include *.ps1 -Recurse | Where-Object {$_.creationtime -gt "01/01/2011"}
$ScriptFiles = $ScriptFiles | Select-Object -Property Name, CreationTime, LastWriteTime, IsReadOnly
$ScriptFiles | Export-Csv -Append -Path "\\Archive01\Scripts\Scripts.csv"
-----------------------------------------------------------------------
$filename = "$(Get-Date -Format "yyyy_M_d_h_m_s")-ComputerStatusSummary.csv"
$wsus.GetSummariesPerComputerTarget($updatescope,$computerscope) | SELECT @{L='ComputerTarget';E={($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).FullDomainName}}, @{L='NeededCount';E={($_.DownloadedCount + $_.NotInstalledCount)}},DownloadedCount,NotApplicableCount,NotInstalledCount,InstalledCount | Export-Csv -Append -NoType -Path "$Env:userprofile\Desktop\PS\$filename"
-----------------------------------------------------------------------





'Create a new custom object and add it to the object array that Import-Csv creates.

$fileContent = Import-csv $file -header "Date", "Description"
$newRow = New-Object PsObject -Property @{ Date = 'Text4' ; Description = 'Text5' }
$fileContent += $newRow

'This worked great for me except that it changed the ordering of my columns.
'After I appended the line using the above answer I had to use
 $Import = $Import | Select-Object...
 
 ------------------------------------------------------------------
 
'to only add a new line to the file, try the following, 
'	where $YourNewDate and $YourDescription contain the desired values.
$NewLine = "{0},{1}" -f $YourNewDate,$YourDescription
$NewLine | add-content -path $file

'Or,

"{0},{1}" -f $YourNewDate,$YourDescription | add-content -path $file

'This will just tag the new line to the end of the .csv, and will not work 
'	for creating new .csv files where you will need to add the header.

 ------------------------------------------------------------------
 
#'this bit creates the CSV if it does not already exist
$headers = "Name", "Primary Type"
$psObject = New-Object psobject
foreach($header in $headers)
{
 Add-Member -InputObject $psobject -MemberType noteproperty -Name $header -Value ""
}
$psObject | Export-Csv $csvfile -NoTypeInformation

#'this bit appends a new row to the CSV file
$bName = "My Name"
$bPrimaryType = "My Primary Type"
    $hash = @{
             "Name" =  $bName
             "Primary Type" = $bPrimaryType
              }

$newRow = New-Object PsObject -Property $hash
Export-Csv $csvfile -inputobject $newrow -append -Force

------------------------------------------------------------------------
$table=@"
First name,Surname,Phone,Age
Larry,Jones,   555-0000,  15
Bob, Barker,666-8888,   56
Jane,Doe, 888-9876,    63
"@
 
#export to a csv file
$table | Set-Content E:\a.csv
 
#append a row to an existing file
Add-Content E:\a.csv "Joe,Richard,111-2345,78"
 
The following data shows the output form the Import-Csv cmdlet.
Import-Csv E:\a.csv
 
First name                 Surname           Phone              Age                                      
----------                 -------           -----              ---                                      
Larry                      Jones             555-0000           15                                       
Bob                        Barker            666-8888           56                                       
Jane                       Doe               888-9876           63                                        
Joe                        Richard           111-2345           78 

------------------------------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_OutPut</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Out-Gridview</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_OutPut</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Out-Gridview</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Graphical display, sortable

'This opens the graphical window
Get-Service | Out-GridView

'This returns the user selected object output to the pipeline, when the user selects the row and clicks [ok]
Get-Service | where status -eq 'running' | Out-GridView -PassThru
===================================================================================================
&gt;Get-Service | where status -eq 'running' | 
	Out-GridView -Title "Select services to restart" -PassThru |
	foreach { 
	Write-Host "Restarting $($_.DisplayName)" -ForegroundColor green
	$_ | Restart-Service -PassThru -Force
	}
'This will let you multi-select (using the Control key) services in the Grid-View pop-up window, 
'	and then when your selection returns to the pipeline it will RESTART each selected service and show colored results to the screen		
===================================================================================================

#' use Grid-view to select what gets stored into a variable:
$logs = Get-Eventlog -list | Select LogDisplayName | Out-Gridview -Title "Select one or more logs" -OutputMode Multiple

'OR let the user select what goes into three variables:
&gt;$logs = Get-Eventlog -list | Select LogDisplayName | Out-Gridview -Title "Select one or more logs" -OutputMode Multiple
&gt;$count = 1,10,25,50 | Out-GridView -Title "How many entries?" -OutputMode Single
&gt;$printer = Get-Printer | Select Name | Out-GridView -Title "Select a printer" -OutputMode Single

'Then use that User created selection: for the eventlogs that were chosen, and the count of records to return, send output to chosen printer
$logs | foreach {
					$_.LogDisplayName
					Get-Eventlog -LogName $_.LogDisplayName -Newest $count -EntryType Error |
					Select TimeGenerated,Source,Message | Format-List | 
					Out-Printer $printer.Name
				}
===================================================================================================				</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_OutPut</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Write_to_a_FILE__Add_to_TOP_of_file</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_OutPut</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Write_to_a_FILE__Add_to_TOP_of_file</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://stackoverflow.com/questions/35756071/prepend-to-the-beginning-of-the-first-line-of-a-file


'Usage:

PS&gt; get-item fileName.ext | PrependTo-File "contentToAdd`r`n"

----------------------------------------------
function PrependTo-File{
  [cmdletbinding()]
  param(
    [Parameter(
      Position=1,
      ValueFromPipeline=$true,
      Mandatory=$true,
      ValueFromPipelineByPropertyName=$true
    )]
    [System.IO.FileInfo]
    $file,
    [string]
    [Parameter(
      Position=0,
      ValueFromPipeline=$false,
      Mandatory=$true
    )]
    $content
  )

  process{
    if(!$file.exists){
      write-error "$file does not exist";
      return;
    }
    $filepath = $file.fullname;
    $tmptoken = (get-location).path + "\_tmpfile" + $file.name;
    write-verbose "$tmptoken created to as buffer";
    $tfs = [System.io.file]::create($tmptoken);
    $fs = [System.IO.File]::Open($file.fullname,[System.IO.FileMode]::Open,[System.IO.FileAccess]::ReadWrite);
    try{
      $msg = $content.tochararray();
      $tfs.write($msg,0,$msg.length);
      $fs.position = 0;
      $fs.copyTo($tfs);
    }
    catch{
      write-verbose $_.Exception.Message;
    }
    finally{

      $tfs.close();
      # close calls dispose and gc.supressfinalize internally
      $fs.close();
      if($error.count -eq 0){
        write-verbose ("updating $filepath");
        [System.io.File]::Delete($filepath);
        [System.io.file]::Move($tmptoken,$filepath);
      }
      else{
        $error.clear();
        write-verbose ("an error occured, rolling back. $filepath not effected");
        [System.io.file]::Delete($tmptoken);
      }
    }
  }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Parameters</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>simple examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Parameters</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>simple examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
------------------------------------------------------------------------------------------
#'ScriptWithParameter.ps1
#'get a breakdown of error sources in the System eventlog
#'NOTE: the DEFAULT values are given
Param(
    [string]$Log = "System",
    [string]$Computername = $env:COMPUTERNAME,
    [int32]$Newest = 500,
    [string]$ReportTitle = "Event Log Report",
    [Parameter(Mandatory,HelpMessage = "Enter the path for the HTML file.")]
    [string]$Path
)

#'get event log data and group it
$data = Get-Eventlog -logname $Log -EntryType Error -Newest $newest -ComputerName $Computername |
    Group-object -Property Source -NoElement 

#'create an HTML report
$footer = "&lt;h5&gt;&lt;i&gt;report run $(Get-Date)&lt;/i&gt;&lt;/h5&gt;"
$css = "http://jdhitsolutions.com/sample.css"
$precontent = "&lt;H1&gt;$Computername&lt;/H1&gt;&lt;H2&gt;Last $newest error sources from $Log&lt;/H2&gt;"

$data |Sort-Object -Property Count, Name -Descending |
    Select-Object Count, Name | 
    ConvertTo-Html -Title $ReportTitle -PreContent $precontent  -PostContent $footer -CssUri $css |
    Out-File $Path
-------------------------------------------------------------------------------------------





===================================================================

Param
(
    [parameter()]
    $ParameterName
)
-------------------------

'It is mandatory (required).
'It takes input from the pipeline.
'It takes an array of strings as input.
Param
(
    [parameter(Mandatory=$true,
    		   ValueFromPipeline=$true)]
    [String[]]
    $ComputerName
)

---------------------'Position

Param
(
    [parameter(Position=0)]
    [String[]]
    $ComputerName
)

-------------------'Parameter Set Name
'example 1
Param
(
    [parameter(Mandatory=$true,
    ParameterSetName="Computer")]
    [String[]]
    $ComputerName,

    [parameter(Mandatory=$true,
    ParameterSetName="User")]
    [String[]]
    $UserName,

    [parameter(Mandatory=$false)]
    [Switch]
    $Summary
)

'example 2
Param
(
    [parameter(Mandatory=$true,
    ParameterSetName="Computer")]
    [String[]]
    $ComputerName,

    [parameter(Mandatory=$true,
    ParameterSetName="User")]
    [String[]]
    $UserName,

    [parameter(Mandatory=$false, ParameterSetName="Computer")]
    [parameter(Mandatory=$true, ParameterSetName="User")]
    [Switch]
    $Summary
)

-------------------'ValueFromPipeline Argument
'declares a ComputerName parameter that is mandatory 
'	and accepts an object that is passed to the function from the pipeline.
Param
(
    [parameter(Mandatory=$true,
    ValueFromPipeline=$true)]
    [String[]]
    $ComputerName
)
-------------------'ValueFromPipelineByPropertyName Argument
'the parameter accepts input from a property of a pipeline object. 
'The object property must have the same name or alias as the parameter.
Param
(
    [parameter(Mandatory=$true,
    ValueFromPipelineByPropertyName=$true)]
    [String[]]
    $ComputerName
)

----------------'HelpMessage Argument
'a brief description of the parameter or its value. 
'Windows PowerShell displays this message in the prompt 
'	that appears when a mandatory parameter value is missing from a command. 

Param
(
    [parameter(mandatory=$true,
    HelpMessage="Enter one or more computer names separated by commas.")]
    [String[]]
    $ComputerName
)
----------------'Alias Attribute
' There is no limit to the number of aliases that you can assign to a parameter.
Param
(
    [parameter(Mandatory=$true)]
    [alias("CN","MachineName")]
    [String[]]
    $ComputerName
)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Processes</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>List_Process_with_CertainProperties_Count_and_TimeStarted</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Processes</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>List_Process_with_CertainProperties_Count_and_TimeStarted</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$process = "pxplus.exe"
$arrResults = Get-WmiObject Win32_Process -Namespace "root\cimv2"  -Filter "name = '$process'"  |  Select CommandLine,CreationDate  | Where-Object {$_.CommandLine -like "*id=T*"} 
$m = $arrResults | measure


write-host 'count: '  $m.Count

write-host ' ' 
$arrResults | foreach{ 
                        write-host $_.CommandLine 
                        write-host 'Started: ' $_.CreationDate.substring(0,7) ' time:' $_.CreationDate.substring(8,2) ':'  $_.CreationDate.substring(10,2)
                        write-host ' ' 
                      }
                      
                      
========================================
LIST ALL PROCESSES:

$arrResults = Get-WmiObject Win32_Process -Namespace "root\cimv2"    |  Select CommandLine,CreationDate 
$m = $arrResults | measure


write-host 'count: '  $m.Count

write-host ' ' 
$arrResults | foreach{ 
                        write-host $_.CommandLine 
                        write-host ' ' 
                      }                      </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Alias</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Alias</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'you can create your own aliases with Set-Alias. Set-Alias

' But sometimes you might want an alias to include, 
'	for example, a cmdlet name plus a parameter that you tend to always use. 
'	For these, you can emulate an alias with a simple function.

'This lets you alias a cmdlet b/ w/o parms
Set-Alias im Import-Module

'Here is a function which wraps a cmdlet w/ a parm
function imf($name)   { Import-Module $name -force }


' show the last 50 items in your command history?
Get-History -Count 50
'Here is a function to make it easier 
function h50 { Get-History -Count 50 }
function h10 { Get-History -Count 10 }

'How would you reveal the cmdlet behind an alias, 
'the path to an executable given just the program name, 
'the parameter sets available for a given cmdlet, or the content of a user-defined function?
function which($cmd) { (Get-Command $cmd).Definition }

'reporting your domain-qualified user name:
function whoami { (get-content env:\userdomain) + "\" + (get-content env:\username }


Set-PSDebug -Strict '&lt;==============enforces, like strongly typing</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>OpenProfile_function</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>OpenProfile_function</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Function funcOpenPowerShellProfile
{
    Notepad $PROFILE
}

Set-Alias op funcOpenPowerShellProfile



\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Survivalist Version:
Function funcOpenPowerShellProfile
{
    $fileProfilePathParts = @($PROFILE.Split('\'))
    $fileProfileName = $fileProfilePathParts[-1]
    $fileProfilePathPartNum = 0
    $fileProfileHostPath = $fileProfilePathParts[$fileProfilePathPartNum] + '\'
    $fileProfileHostPathPartsCount = $fileProfilePathParts.Count - 2
        # Arrays start at 0, but the Count starts at 1; if both started at 0 or 1, 
        # then a -1 would be fine, but the realized discrepancy is 2
    Do
    {
        $fileProfilePathPartNum++
        $fileProfileHostPath = $fileProfileHostPath + `
            $fileProfilePathParts[$fileProfilePathPartNum] + '\'
    }
    While
    (
        $fileProfilePathPartNum -LT $fileProfileHostPathPartsCount
    )
    $fileProfileBackupTime = [string](date -format u) -replace ":", ""
    $fileProfileBackup = $fileProfileHostPath + `
        $fileProfileBackupTime + ' - ' + $fileProfileName + '.bak'
    cp $PROFILE $fileProfileBackup

    cd $fileProfileHostPath
    $fileProfileBackupNamePattern = $fileProfileName + '.bak'
    $fileProfileBackups = @(ls | Where {$_.Name -Match $fileProfileBackupNamePattern} | `
        Sort Name)
    $fileProfileBackupsCount = $fileProfileBackups.Count
    $fileProfileBackupThreshold = 5 # Change as Desired
    If
    (
        $fileProfileBackupsCount -GT $fileProfileBackupThreshold
    )
    {
        $fileProfileBackupsDeleteNum = $fileProfileBackupsCount - `
            $fileProfileBackupThreshold
        $fileProfileBackupsIndexNum = 0
        Do
        {

            rm $fileProfileBackups[$fileProfileBackupsIndexNum]
            $fileProfileBackupsIndexNum++;
            $fileProfileBackupsDeleteNum--
        }
        While
        (
            $fileProfileBackupsDeleteNum -NE 0
        )
    }

    PowerShell_ISE $PROFILE
        # Replace 'PowerShell_ISE' with Desired IDE (IDE's path may be needed in 
        # '$Env:PATH' for this to work; if you can start it from the "Run" window, 
        # you should be fine)
}

Set-Alias fop funcOpenPowerShellProfile</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>prompt_in_Profile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>prompt_in_Profile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'    The Windows PowerShell prompt is determined by the built-in Prompt
'    function. You can customize the prompt by creating your own Prompt
'    function and saving it in your Windows PowerShell profile.

=============================================================================

'http://kevinmarquette.blogspot.com/2015/11/here-is-my-custom-powershell-prompt.html

'I change my prompt to just show the current folder and place the full path in the tittle bar.
' I just save my last command to a text file whenever I run it.
'The last thing I so is calculate where in the history the next command will be and add that to my prompt.
'REQUIRES that you create a folder named 'log' in the directory:  C:\Users\glenn\Documents\WindowsPowerShell\

$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

=============================================================================

'To be able to get time and path with colors in my prompt :

function Get-Time { return $(get-date | foreach { $_.ToLongTimeString() } ) }
function prompt
{
    # Write the time 
    write-host "[" -noNewLine
    write-host $(Get-Time) -foreground yellow -noNewLine
    write-host "] " -noNewLine
    # Write the path
    write-host $($(Get-Location).Path.replace($home,"~").replace("\","/")) -foreground green -noNewLine
    write-host $(if ($nestedpromptlevel -ge 1) { '&gt;&gt;' }) -noNewLine
    return "&gt; "
}

===================================================================

'My prompt contains:

$width = ($Host.UI.RawUI.WindowSize.Width - 2 - $(Get-Location).ToString().Length)
$hr = New-Object System.String @('-',$width)
Write-Host -ForegroundColor Red $(Get-Location) $hr

'Which gives me a divider between commands that's easy to see when scrolling back. It also shows me the current directory without using horizontal space on the line that I'm typing on.

'For example:

C:\Users\Jay ----------------------------------------------------------------------------------------------------------
[1] PS&gt;

===================================================================

# Setup the Console look and feel
$host.UI.RawUI.ForegroundColor = "Yellow"
if ( Test-Admin ) {
    $title = "Administrator Shell - {0}" -f $host.UI.RawUI.WindowTitle
    $host.UI.RawUI.WindowTitle = $title;
}

===================================================================

function Get-Time { return $(get-date | foreach { $_.ToLongTimeString() } ) }
function prompt
{
    # Write the time 
    write-host "[" -noNewLine
    write-host $(Get-Time) -foreground yellow -noNewLine
    write-host "] " -noNewLine
    # Write the path
    write-host $($(Get-Location).Path.replace($home,"~").replace("\","/")) -foreground green -noNewLine
    write-host $(if ($nestedpromptlevel -ge 1) { '&gt;&gt;' }) -noNewLine
    return "&gt; "
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Sample_Profile_0____gig-Utility</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Sample_Profile_0____gig-Utility</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function gig-RemotelyQueryUser {
                                 &lt;#
                                   .Synopsis
                                    w/ no parm, it uses the local computer, with the parm it will query a remote computer 
                                   .Description
                                    From: https://4sysops.com/archives/remotely-query-user-profile-information-with-powershell/
                                   .Example
                                    Example-
                                    Example- accomplishes 
                                   .Parameter 
                                    ValueFromPipeline = 
                                   .Parameter 
                                    ComputerName = defaults to local
                                   .Notes
                                    Example: 
                                            &gt; gig-RemotelyQueryUser  {for local}
                                            &gt; gig-RemotelyQueryUser -ComputerName WBSQL1   {for remote}
                                    AUTHOR: glenn garson, JPHSA
                                    LASTEDIT: 12/28/2016 13:45:05
                                    KEYWORDS:
                                    HSG: 
                                   .Link
                                     Http://www.ScriptingGuys.com
                                 #'Requires -Version 2.0
                                 #&gt;
								[cmdletbinding()]
                                param (
                                [parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
                                [string[]]$ComputerName = $env:computername
                                )            
 
                                foreach ($Computer in $ComputerName) {
                                 $Profiles = Get-WmiObject -Class Win32_UserProfile -Computer $Computer -ea 0
                                 foreach ($profile in $profiles) {
                                  try {
                                      $objSID = New-Object System.Security.Principal.SecurityIdentifier($profile.sid)
                                      $objuser = $objsid.Translate([System.Security.Principal.NTAccount])
                                      $objusername = $objuser.value
                                  } catch {
                                        $objusername = $profile.sid
                                  }
                                  switch($profile.status){
                                   1 { $profileType="Temporary" }
                                   2 { $profileType="Roaming" }
                                   4 { $profileType="Mandatory" }
                                   8 { $profileType="Corrupted" }
                                   default { $profileType = "LOCAL" }
                                  }
                                  $User = $objUser.Value
                                  $ProfileLastUseTime = ([WMI]"").Converttodatetime($profile.lastusetime)
                                  $OutputObj = New-Object -TypeName PSobject
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ComputerName -Value $Computer.toUpper()
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfileName -Value $objusername
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfilePath -Value $profile.localpath
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name ProfileType -Value $ProfileType
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name IsinUse -Value $profile.loaded
                                  $OutputObj | Add-Member -MemberType NoteProperty -Name IsSystemAccount -Value $profile.special
                                  $OutputObj
  
                                 }
                                }
							}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Sample_Profile_0____PowerShellISEModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Sample_Profile_0____PowerShellISEModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

Function gig-commentIt
{
 &lt;#
   .Synopsis
    This function will add a remark #' character to beginning of line
   .Description
    This function will add a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to comment out
    a section of PowerShell code. 
   .Example
    Add-RemarkedText
    adds the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ("#'" + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-commentIt

Function gig-unCommentIt
{
 &lt;#
   .Synopsis
    This function will remove a remark #' character to beginning of line
   .Description
    This function will remove a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to clean up a 
    previously commentted out section of PowerShell code. 
   .Example
    gig-unCommentIt
    Removes the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($l -replace "#'",''),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-unCommentIt


Function gig-editProfile
{

 psedit $profile

 #'ISE $profile

} #'end function gig-editProfile

Function gig-addHelp
{
  &lt;#
   .Synopsis
    This function adds help at current insertion point 
   .Example
    add-help
    adds comment based help at current insertion point 
   .Notes
    NAME:  Add-Help
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016
    HSG: WES-09-11-10
    KEYWORDS: Scripting Techniques, Windows PowerShell ISE
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $helpText = @"
 &lt;#
   .Synopsis
    This does that 
   .Description
    This function does
   .Example
    Example-
    Example- accomplishes 
   .Parameter 
    The parameter
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS:
    HSG: 
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
"@
 $psise.CurrentFile.Editor.InsertText($helpText)
} #'end function gig-addHelp

Function gig-addHeaderToScript
{
  &lt;#
   .Synopsis
    This function adds header information to a script 
   .Example
    Add-HeaderToScript
    Adds header comments to script 
   .Example 
    AH
    Uses alias to add header comments to script
   .Notes
    NAME:  Add-HeaderToScript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS: $keyword
    HSG: $hsg
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($keyword, $comment, $hsg)
 $header = @"
#' -----------------------------------------------------------------------------
#' Script: $(split-path -Path $psISE.CurrentFile.FullPath -Leaf)
#' Author: glenn garson, JPHSA
#' Date: $(Get-Date)
#' Keywords: $keyword
#' comments: $comment
#'
#' -----------------------------------------------------------------------------
"@
 $psise.CurrentFile.Editor.InsertText($header)
} #'end function gig-addHeaderToScript

Function gig-getLogNameFromDate
{
  &lt;#
   .Synopsis
    Creates a log name from date
   .Description
    This script creates a log from a date. 
   .Example
    gig-getLogNameFromDate -path "c:\jumk" -name "log"
    Creates a file name like c:\JUNK\log20100914-122019.Txt but does not
    create the file. It returns the file name to calling code.
   .Example
    gig-getLogNameFromDate -path "c:\JUNK" -name "log" -Create
    Creates a file name like c:\JUNK\log20100914-122019.Txt and
    create the file. It returns the file name to calling code.
   .Parameter path
    path to log file
   .Parameter name
    base name of log file
   .Parameter create
    switch that determines whether log file or only name is created
   .inputs
    [string]
   .outputs
    [string]
   .Notes
    NAME:  gig-getLogNameFromDate
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 16:58:06
    KEYWORDS: parameter substitution, format specifier, string substitution
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param(
  [string]$path = "c:\JUNKC:\DATA\junkPowerShellTranscripts",
  [string]$name = "log",
  [switch]$Create
 )
 $logname = "{0}\{1}{2}.{3}" -f $path,$name, `
    (Get-Date -Format yyyyMMdd-HHmmss),"Txt"
 if($create) 
  { 
   New-Item -Path $logname -ItemType file -force | out-null
   $logname
  }
 else {$logname}
} #' end function gig-getLogNameFromDate

Function gig-start_ISE_Transcript
{
  &lt;#
   .Synopsis
    This captures output from a script to a created text file
    To use the gig-start_ISE_Transcript function, add the call to the function at the bottom of your script.
   .Example

    xxxxx...{your script}
    gig-start_ISE_Transcript -logname "c:\junk\log.txt"

    Copies output from script to file named xxxxlog.txt in c:\junk folder
   .Parameter logname
    the name and path of the log file.
   .inputs
    [string]
   .outputs
    [io.file]
   .Notes
    NAME:  gig-start_ISE_Transcript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 17:27:22
    KEYWORDS:
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
  Param(
   [string]$logname = (gig-getLogNameFromDate -path $transcriptHome -name "log" -Create)
  )
  $transcriptHeader = @"
**************************************
Windows PowerShell ISE Transcript Start
Start Time: $(get-date)
UserName: $env:username
UserDomain: $env:USERDNSDOMAIN
ComputerName: $env:COMPUTERNAME
Windows version: $((Get-WmiObject win32_operatingsystem).version)
**************************************
Transcript started. Output file is $logname
"@
 $transcriptHeader &gt;&gt; $logname
 $psISE.CurrentPowerShellTab.ConsolePane.Text &gt;&gt; $logname
 “Log saved to $logname”
} #'end function gig-start_ISE_Transcript

function gig-indentText_x_spaces
{
  &lt;#
   .Synopsis
    This function will indent text in the ISE a specific number
   .Description
    This function will indent selected text in the PowerShell ISE. These are
    real spaces, not tabs. Therefore this is appropriate for situations where
    an actual tab "`t" will not work. 
   .Example
    gig-indentText_x_spaces -space 5
    moves selected text five spaces 
   .Parameter spaces
    The number of spaces to indent the selected text. Note this number cannot
    be a negative number, and this function does not "unindent" the selected text.
   .Notes
    NAME:  gig-indentText_x_spaces
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 06/11/2012 17:16:29
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-6-17-12
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param([int]$space = 1)
 $tab = " " * $space
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($tab + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'end function gig-indentText_x_spaces

Function gig-editModule
{
  &lt;#
   .Synopsis
    This opens a module stored in the $env:PSModulePath location on a new tab in ISE 
   .Description
    This function uses Get-Module to retrieve a module from $env:PSModulePath and then
    it opens the module from that location into a new tab in ISE for editing. Wildcard
    characters that resolve to a single module are supported.
   .Example
    gig-editModule PowerShellISEModule
    gig-editModule PowerShellISEModule opens the PowerShellISEModule into a new tab in the
    ISE for editing 
  .Example
    gig-editModule PowerShellISE*
    gig-editModule PowerShellISE* opens the PowerShellISEModule into a new tab in the
    ISE for editing by using a wild card character for the module name
   .Parameter Name
    The name of the module. Wild cards that resolve to a single module are supported
   .Notes
    NAME:  gig-editModule
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 18:14:19
    KEYWORDS: Scripting Techniques, Modules
    HSG: WES-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($name)
 ISE (Get-Module -ListAvailable $name).path
} #'end function gig-editModule

Function gig-toggleOutlineView
{
  &lt;#
   .Synopsis
    This function toggles the outline view in the ISE 
   .Description
    This function toggles the outline view in the ISE. It will expand 
    or collapse all functions in the current script pane.
   .Example
    gig-toggleOutlineView
    gig-toggleOutlineView will either expand or collapse all functions 
   .Notes
    NAME:  gig-toggleOutlineView
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 19:28:37
    KEYWORDS: Scripting Techniques, Modules
    HSG: wes-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 3.0
 #&gt;
 $psise.CurrentFile.Editor.ToggleOutliningExpansion()
} #'end function gig-toggleOutlineView


#'added Functions from New-ModulesDrive.ps1
#' HSG-1-20-10
Function gig-newModuleDrives
{
&lt;#
    .SYNOPSIS
    Creates two PSDrives: myMods and sysMods
    .EXAMPLE
    gig-newModuleDrives
    Creates two PSDrives: myMods and sysMods. These correspond 
    to the users' modules folder and the system modules folder respectively. 
#&gt;
 $driveNames = "myMods","sysMods"

 For($i = 0 ; $i -le 1 ; $i++)
 {
  New-PsDrive -name $driveNames[$i] -PSProvider filesystem `
  -Root ($env:PSModulePath.split(";")[$i]) -scope Global |
  Out-Null
 } #'end For
} #'end gig-newModuleDrives

Function gig-getFileSystemDrives
{
&lt;#
    .SYNOPSIS
    Displays global PS Drives that use the Filesystem provider
    .EXAMPLE
    gig-getFileSystemDrives
    Displays global PS Drives that use the Filesystem provider
#&gt;
 Get-PSDrive -PSProvider FileSystem -scope Global
} #'end gig-getFileSystemDrives

Function gig-OpenPath
{
 &lt;#
   .Synopsis
    Opens a path in Explorer 
   .Description
    Opens a path in Explorer, default path is C:\, or the first parameter is the path
   .Example
    gig-OpenPath C:\Junk
    gig-OpenPath $moduleHome 
   .Parameter Path
    The path to open in Explorer
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/26/2016 17:31:28
    KEYWORDS:
    HSG: 
   .Link
     
 #'Requires -Version 2.0
 #&gt;
  Param(
  [string]$path = "C:\"
 )
 Invoke-Item -Path $path
 }
 
#' *** Alias ***
#'if(!(Test-Path alias:ah))
#' {
#'  New-Alias -Name ah -Value add-headertoscript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:abh))
#' {
#'  New-Alias -Name abh -Value Add-SBSBookHeaderToScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ahlp))
#' {
#'  New-Alias -Name ahlp -Value add-help -Description "MrEd alias" |
#'  Out-Null
#'  }
#'  if(!(Test-Path alias:ras))
#' {
#'  New-Alias -Name ras -Value Remove-AliasFromScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:gfsd))
#' {
#'  New-Alias -Name gfsd -Value gig-getFileSystemDrives -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:cs))
#' {
#'  New-Alias -Name cs -value Copy-ScriptToNewTab -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ar))
#' {
#'  New-Alias -Name ar -value Add-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:rr))
#' {
#'  New-Alias -Name rr -value Remove-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:em))
#' {
#'  New-Alias -Name em -value Edit-Module -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:iem))
#' {
#'  New-Alias -Name iem -value Import-EveryModule -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:sov))
#' {
#'  New-Alias -Name sov -value gig-toggleOutlineView -Description "MrEd alias" |
#'  Out-Null
#'  }



#' *** Variables ***
if(!(Test-Path variable:moduleHome))
{
 new-variable -name moduleHome -value "$env:userProfile\documents\WindowsPowerShell\Modules"
}
#'if(!(Test-Path variable:backupHome))
#'{
#' new-variable -name backupHome -value "$env:userProfile\documents\WindowsPowerShell\profileBackup"
#'}

if(!(Test-Path variable:TranscriptHome))
{
 new-variable -name TranscriptHome -value "C:\DATA\junkPowerShellTranscripts"
 #' new-variable -name TranscriptHome -value "$env:userProfile\documents\WindowsPowerShell\transcript"
}

if(!(Test-Path variable:myScripts))
{
 new-variable -name myScripts -value "C:\DATA\PowerShellScripts"
}

Set-Location $myScripts

Clear-Host

Export-ModuleMember -alias * -function * -variable *</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>SAMPLE_Profile_1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>SAMPLE_Profile_1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'http://www.zerrouki.com/powershell-profile-example/


&lt;#
.SYNOPSIS
    Microsoft.PowerShell_profile.ps1 - My PowerShell profile
.DESCRIPTION
    Microsoft.PowerShell_profile - Customizes the PowerShell console
.NOTES
    File Name   : Microsoft.PowerShell_profile.ps1
    Author      : Fabrice ZERROUKI - fabricezerrouki@hotmail.com
#&gt;
Set-Location D:\Documents\xxxxxx\PERSONNEL\powerscripts
$Shell=$Host.UI.RawUI
$size=$Shell.BufferSize
$size.width=120
$size.height=3000
$Shell.BufferSize=$size
$size=$Shell.WindowSize
$size.width=120
$size.height=30
$Shell.WindowSize=$size
 
$Shell.BackgroundColor="Black"
$Shell.ForegroundColor="White"
$Shell.CursorSize=10
 
function Get-Time {return $(Get-Date | ForEach {$_.ToLongTimeString()})}
function prompt
{
    Write-Host "[" -noNewLine
    Write-Host $(Get-Time) -ForegroundColor DarkYellow -noNewLine
    Write-Host "] " -noNewLine
    Write-Host $($(Get-Location).Path.replace($home,"~")) -ForegroundColor DarkGreen -noNewLine
    Write-Host $(if ($nestedpromptlevel -ge 1) { '&gt;&gt;' }) -noNewLine
    return "&gt; "
}
 
function ll
{
    param ($dir = ".", $all = $false)
 
    $origFg = $Host.UI.RawUI.ForegroundColor
    if ( $all ) { $toList = ls -force $dir }
    else { $toList = ls $dir }
 
    foreach ($Item in $toList)
    {
        Switch ($Item.Extension)
        {
            ".exe" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".hta" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".cmd" {$Host.UI.RawUI.ForegroundColor="DarkRed"}
            ".ps1" {$Host.UI.RawUI.ForegroundColor="DarkGreen"}
            ".html" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".htm" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".7z" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".zip" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".gz" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".rar" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            Default {$Host.UI.RawUI.ForegroundColor=$origFg}
        }
        if ($item.Mode.StartsWith("d")) {$Host.UI.RawUI.ForegroundColor="Gray"}
        $item
    }
    $Host.UI.RawUI.ForegroundColor = $origFg
}
 
function Edit-HostsFile {
    Start-Process -FilePath notepad -ArgumentList "$env:windir\system32\drivers\etc\hosts"
}
 
function rdp ($ip) {
    Start-Process -FilePath mstsc -ArgumentList "/admin /w:1024 /h:768 /v:$ip"
}
 
function tail ($file) {
Get-Content $file -Wait
}
 
function whoami {
    [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
}
 
function Reload-Profile {
    @(
        $Profile.AllUsersAllHosts,
        $Profile.AllUsersCurrentHost,
        $Profile.CurrentUserAllHosts,
        $Profile.CurrentUserCurrentHost
    ) | % {
        if(Test-Path $_) {
            Write-Verbose "Running $_"
            . $_
        }
    }    
}
 
function Check-SessionArch {
    if ([System.IntPtr]::Size -eq 8) { return "x64" }
    else { return "x86" }
}
 
function Test-Port {
[cmdletbinding()]
param(
[parameter(mandatory=$true)]
[string]$Target,
[parameter(mandatory=$true)]
[int32]$Port,
[int32]$Timeout=2000
)
$outputobj=New-Object -TypeName PSobject
$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostName -Value $Target
if(Test-Connection -ComputerName $Target -Count 2) {$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "ONLINE"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "OFFLINE"}            
$outputobj | Add-Member -MemberType NoteProperty -Name PortNumber -Value $Port
$Socket=New-Object System.Net.Sockets.TCPClient
$Connection=$Socket.BeginConnect($Target,$Port,$null,$null)
$Connection.AsyncWaitHandle.WaitOne($timeout,$false) | Out-Null
if($Socket.Connected -eq $true) {$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Success"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Failed"}            
$Socket.Close | Out-Null
$outputobj | Select TargetHostName, TargetHostStatus, PortNumber, Connectionstatus | Format-Table -AutoSize
}
 
Set-Alias powergui "C:\Program Files\PowerGUI\ScriptEditor.exe"
Set-Alias grep select-string
 
$MaximumHistoryCount=1024
$IPAddress=@(Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.DefaultIpGateway})[0].IPAddress[0]
$PSVersion=$host | Select-Object -ExpandProperty Version
$PSVersion=$PSVersion -replace '^.+@\s'
$SessionArch=Check-SessionArch
$Shell.WindowTitle="PowerFab rulez! ($SessionArch)"
 
Clear-Host
 
Write-Host "`r`nsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  ssssss`tHi Fab!" -nonewline; Write-Host "`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tComputerName`t`t" -nonewline
Write-Host $($env:COMPUTERNAME) -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tIP Address`t`t" -nonewline
Write-Host $IPAddress -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss`tUserName`t`t" -nonewline
Write-Host $env:UserDomain\$env:UserName -nonewline; Write-Host "`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Version`t" -nonewline
Write-Host $PSVersion -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Session`t" -nonewline
Write-Host $SessionArch -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss`n" -ForegroundColor Yellow
 
$LogicalDisk = @()
Get-WmiObject Win32_LogicalDisk -filter "DriveType='3'" | % {
    $LogicalDisk += @($_ | Select @{n="Name";e={$_.Caption}},
    @{n="Volume Label";e={$_.VolumeName}},
    @{n="Size (Gb)";e={"{0:N2}" -f ($_.Size/1GB)}},
    @{n="Used (Gb)";e={"{0:N2}" -f (($_.Size/1GB) - ($_.FreeSpace/1GB))}},
    @{n="Free (Gb)";e={"{0:N2}" -f ($_.FreeSpace/1GB)}},
    @{n="Free (%)";e={if($_.Size) {"{0:N2}" -f (($_.FreeSpace/1GB) / ($_.Size/1GB) * 100 )} else {"NAN"} }})
  }
$LogicalDisk | Format-Table -AutoSize | Out-String</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>SAMPLE_Profile_2___nice</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>SAMPLE_Profile_2___nice</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'http://kevinmarquette.blogspot.com/2015/11/here-is-my-custom-powershell-prompt.html

'I change my prompt to just show the current folder and place the full path in the tittle bar.
' I just save my last command to a text file whenever I run it.
'The last thing I so is calculate where in the history the next command will be and add that to my prompt.

$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Sample_Profile_3__PowerShellISEModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Sample_Profile_3__PowerShellISEModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

Function gig-commentIt
{
 &lt;#
   .Synopsis
    This function will add a remark #' character to beginning of line
   .Description
    This function will add a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to comment out
    a section of PowerShell code. 
   .Example
    Add-RemarkedText
    adds the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ("#'" + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-commentIt

Function gig-unCommentIt
{
 &lt;#
   .Synopsis
    This function will remove a remark #' character to beginning of line
   .Description
    This function will remove a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to clean up a 
    previously commentted out section of PowerShell code. 
   .Example
    gig-unCommentIt
    Removes the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($l -replace "#'",''),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-unCommentIt


Function gig-editProfile
{

 psedit $profile

 #'ISE $profile

} #'end function gig-editProfile

Function gig-addHelp
{
  &lt;#
   .Synopsis
    This function adds help at current insertion point 
   .Example
    add-help
    adds comment based help at current insertion point 
   .Notes
    NAME:  Add-Help
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016
    HSG: WES-09-11-10
    KEYWORDS: Scripting Techniques, Windows PowerShell ISE
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $helpText = @"
 &lt;#
   .Synopsis
    This does that 
   .Description
    This function does
   .Example
    Example-
    Example- accomplishes 
   .Parameter 
    The parameter
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS:
    HSG: 
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
"@
 $psise.CurrentFile.Editor.InsertText($helpText)
} #'end function gig-addHelp

Function gig-addHeaderToScript
{
  &lt;#
   .Synopsis
    This function adds header information to a script 
   .Example
    Add-HeaderToScript
    Adds header comments to script 
   .Example 
    AH
    Uses alias to add header comments to script
   .Notes
    NAME:  Add-HeaderToScript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS: $keyword
    HSG: $hsg
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($keyword, $comment, $hsg)
 $header = @"
#' -----------------------------------------------------------------------------
#' Script: $(split-path -Path $psISE.CurrentFile.FullPath -Leaf)
#' Author: glenn garson, JPHSA
#' Date: $(Get-Date)
#' Keywords: $keyword
#' comments: $comment
#'
#' -----------------------------------------------------------------------------
"@
 $psise.CurrentFile.Editor.InsertText($header)
} #'end function gig-addHeaderToScript

Function gig-getLogNameFromDate
{
  &lt;#
   .Synopsis
    Creates a log name from date
   .Description
    This script creates a log from a date. 
   .Example
    gig-getLogNameFromDate -path "c:\jumk" -name "log"
    Creates a file name like c:\JUNK\log20100914-122019.Txt but does not
    create the file. It returns the file name to calling code.
   .Example
    gig-getLogNameFromDate -path "c:\JUNK" -name "log" -Create
    Creates a file name like c:\JUNK\log20100914-122019.Txt and
    create the file. It returns the file name to calling code.
   .Parameter path
    path to log file
   .Parameter name
    base name of log file
   .Parameter create
    switch that determines whether log file or only name is created
   .inputs
    [string]
   .outputs
    [string]
   .Notes
    NAME:  gig-getLogNameFromDate
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 16:58:06
    KEYWORDS: parameter substitution, format specifier, string substitution
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param(
  [string]$path = "c:\JUNKC:\DATA\junkPowerShellTranscripts",
  [string]$name = "log",
  [switch]$Create
 )
 $logname = "{0}\{1}{2}.{3}" -f $path,$name, `
    (Get-Date -Format yyyyMMdd-HHmmss),"Txt"
 if($create) 
  { 
   New-Item -Path $logname -ItemType file -force | out-null
   $logname
  }
 else {$logname}
} #' end function gig-getLogNameFromDate

Function gig-start_ISE_Transcript
{
  &lt;#
   .Synopsis
    This captures output from a script to a created text file
    To use the gig-start_ISE_Transcript function, add the call to the function at the bottom of your script.
   .Example

    xxxxx...{your script}
    gig-start_ISE_Transcript -logname "c:\junk\log.txt"

    Copies output from script to file named xxxxlog.txt in c:\junk folder
   .Parameter logname
    the name and path of the log file.
   .inputs
    [string]
   .outputs
    [io.file]
   .Notes
    NAME:  gig-start_ISE_Transcript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 17:27:22
    KEYWORDS:
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
  Param(
   [string]$logname = (gig-getLogNameFromDate -path $transcriptHome -name "log" -Create)
  )
  $transcriptHeader = @"
**************************************
Windows PowerShell ISE Transcript Start
Start Time: $(get-date)
UserName: $env:username
UserDomain: $env:USERDNSDOMAIN
ComputerName: $env:COMPUTERNAME
Windows version: $((Get-WmiObject win32_operatingsystem).version)
**************************************
Transcript started. Output file is $logname
"@
 $transcriptHeader &gt;&gt; $logname
 $psISE.CurrentPowerShellTab.ConsolePane.Text &gt;&gt; $logname
 “Log saved to $logname”
} #'end function gig-start_ISE_Transcript

function gig-indentText_x_spaces
{
  &lt;#
   .Synopsis
    This function will indent text in the ISE a specific number
   .Description
    This function will indent selected text in the PowerShell ISE. These are
    real spaces, not tabs. Therefore this is appropriate for situations where
    an actual tab "`t" will not work. 
   .Example
    gig-indentText_x_spaces -space 5
    moves selected text five spaces 
   .Parameter spaces
    The number of spaces to indent the selected text. Note this number cannot
    be a negative number, and this function does not "unindent" the selected text.
   .Notes
    NAME:  gig-indentText_x_spaces
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 06/11/2012 17:16:29
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-6-17-12
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param([int]$space = 1)
 $tab = " " * $space
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($tab + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'end function gig-indentText_x_spaces

Function gig-editModule
{
  &lt;#
   .Synopsis
    This opens a module stored in the $env:PSModulePath location on a new tab in ISE 
   .Description
    This function uses Get-Module to retrieve a module from $env:PSModulePath and then
    it opens the module from that location into a new tab in ISE for editing. Wildcard
    characters that resolve to a single module are supported.
   .Example
    gig-editModule PowerShellISEModule
    gig-editModule PowerShellISEModule opens the PowerShellISEModule into a new tab in the
    ISE for editing 
  .Example
    gig-editModule PowerShellISE*
    gig-editModule PowerShellISE* opens the PowerShellISEModule into a new tab in the
    ISE for editing by using a wild card character for the module name
   .Parameter Name
    The name of the module. Wild cards that resolve to a single module are supported
   .Notes
    NAME:  gig-editModule
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 18:14:19
    KEYWORDS: Scripting Techniques, Modules
    HSG: WES-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($name)
 ISE (Get-Module -ListAvailable $name).path
} #'end function gig-editModule

Function gig-toggleOutlineView
{
  &lt;#
   .Synopsis
    This function toggles the outline view in the ISE 
   .Description
    This function toggles the outline view in the ISE. It will expand 
    or collapse all functions in the current script pane.
   .Example
    gig-toggleOutlineView
    gig-toggleOutlineView will either expand or collapse all functions 
   .Notes
    NAME:  gig-toggleOutlineView
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 19:28:37
    KEYWORDS: Scripting Techniques, Modules
    HSG: wes-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 3.0
 #&gt;
 $psise.CurrentFile.Editor.ToggleOutliningExpansion()
} #'end function gig-toggleOutlineView


#'added Functions from New-ModulesDrive.ps1
#' HSG-1-20-10
Function gig-newModuleDrives
{
&lt;#
    .SYNOPSIS
    Creates two PSDrives: myMods and sysMods
    .EXAMPLE
    gig-newModuleDrives
    Creates two PSDrives: myMods and sysMods. These correspond 
    to the users' modules folder and the system modules folder respectively. 
#&gt;
 $driveNames = "myMods","sysMods"

 For($i = 0 ; $i -le 1 ; $i++)
 {
  New-PsDrive -name $driveNames[$i] -PSProvider filesystem `
  -Root ($env:PSModulePath.split(";")[$i]) -scope Global |
  Out-Null
 } #'end For
} #'end gig-newModuleDrives

Function gig-getFileSystemDrives
{
&lt;#
    .SYNOPSIS
    Displays global PS Drives that use the Filesystem provider
    .EXAMPLE
    gig-getFileSystemDrives
    Displays global PS Drives that use the Filesystem provider
#&gt;
 Get-PSDrive -PSProvider FileSystem -scope Global
} #'end gig-getFileSystemDrives

Function gig-OpenPath
{
 &lt;#
   .Synopsis
    Opens a path in Explorer 
   .Description
    Opens a path in Explorer, default path is C:\, or the first parameter is the path
   .Example
    gig-OpenPath C:\Junk
    gig-OpenPath $moduleHome 
   .Parameter Path
    The path to open in Explorer
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/26/2016 17:31:28
    KEYWORDS:
    HSG: 
   .Link
     
 #'Requires -Version 2.0
 #&gt;
  Param(
  [string]$path = "C:\"
 )
 Invoke-Item -Path $path
 }


 function gig-LoadNetworkPSDrives
{
#'    net use G: "\\Jphsa.org\shared\Data" 
#'    net use H: "\\Jphsa.org\shared\Users\ggarson\" 
#'    net use I: "\\Jphsa-ebhost2\AnasaziFiles\" 
#'    net use M: "\\Jphsa.org\shared\Data\MIS\" 
#'    net use N: "\\Jphsa-ebfile01\e$\" 
#'    net use P: "\\Jphsa.org\shared\Users\ggarson\PROJECTS"


    New-PSDrive -Name "G" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Data" -scope Global
    New-PSDrive -Name "H" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Users\ggarson\" -scope Global
    New-PSDrive -Name "I" -PSProvider "FileSystem" -Root "\\Jphsa-ebhost2\AnasaziFiles\" -scope Global
    New-PSDrive -Name "M" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Data\MIS\" -scope Global
    New-PSDrive -Name "N" -PSProvider "FileSystem" -Root "\\Jphsa-ebfile01\e$\" -scope Global
    New-PSDrive -Name "P" -PSProvider "FileSystem" -Root "\\Jphsa.org\shared\Users\ggarson\PROJECTS"-scope Global


} 
 
#' *** Alias ***
#'if(!(Test-Path alias:ah))
#' {
#'  New-Alias -Name ah -Value add-headertoscript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:abh))
#' {
#'  New-Alias -Name abh -Value Add-SBSBookHeaderToScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ahlp))
#' {
#'  New-Alias -Name ahlp -Value add-help -Description "MrEd alias" |
#'  Out-Null
#'  }
#'  if(!(Test-Path alias:ras))
#' {
#'  New-Alias -Name ras -Value Remove-AliasFromScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:gfsd))
#' {
#'  New-Alias -Name gfsd -Value gig-getFileSystemDrives -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:cs))
#' {
#'  New-Alias -Name cs -value Copy-ScriptToNewTab -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ar))
#' {
#'  New-Alias -Name ar -value Add-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:rr))
#' {
#'  New-Alias -Name rr -value Remove-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:em))
#' {
#'  New-Alias -Name em -value Edit-Module -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:iem))
#' {
#'  New-Alias -Name iem -value Import-EveryModule -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:sov))
#' {
#'  New-Alias -Name sov -value gig-toggleOutlineView -Description "MrEd alias" |
#'  Out-Null
#'  }



#' *** Variables ***
if(!(Test-Path variable:moduleHome))
{
 new-variable -name moduleHome -value "$env:userProfile\documents\WindowsPowerShell\Modules"
}
#'if(!(Test-Path variable:backupHome))
#'{
#' new-variable -name backupHome -value "$env:userProfile\documents\WindowsPowerShell\profileBackup"
#'}

if(!(Test-Path variable:TranscriptHome))
{
 new-variable -name TranscriptHome -value "C:\DATA\junkPowerShellTranscripts"
 #' new-variable -name TranscriptHome -value "$env:userProfile\documents\WindowsPowerShell\transcript"
}

if(!(Test-Path variable:myScripts))
{
 new-variable -name myScripts -value "C:\DATA\PowerShellScripts"
}

Set-Location $myScripts

Clear-Host

gig-LoadNetworkPSDrives

Export-ModuleMember -alias * -function * -variable *

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>v5_Start-Transcript</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>v5_Start-Transcript</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'I have the following line in my ISE profile:
Start-Transcript -Path “C:\Logs\ISE-$(Get-Date -Format ddMMyyy).log” -Append | Out-Null

=======================
'Also I remove the logs after 7 days by running:
$logs = Get-ChildItem C:\Logs -filter “*.log”
ForEach($log in $logs) 
{
	For ($p = 1; $p -le $logs.Count; $p++) 
	{
		Write-Progress -Activity “Loading ISE” -Status “Removing old logs” -Id 2 -PercentComplete ($p/$logs.Count*100);
		$date = ((Get-Date) – $log.CreationTime).Days
		If ($date -gt 7 -and $log.PsISContainer -ne $True) {$log.Delete()}
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Regex</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Regex</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Regex</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Regex</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Regex

some examples: https://blogs.technet.microsoft.com/heyscriptingguy/2016/10/28/powershell-regex-crash-course-part-5-of-5/
=============================================================
*	Means zero or more of something
+	Means one or more of something
?	Means zero or one of something

Special character	Meaning							Example
-----------------	----------------------------	--------------------------------------------------------
. (period)			Matches any single character	‘something’ -match ‘some.hing’ 				#'returns true because the ‘t’ is a single character that matches this pattern

\n					Matches a newline character		@”
													This is some multi
													Line text
													“@ -match ‘\n’  				 			#'returns true because there is a new line between ‘multi’ and ‘line’

\t					Matches a tab character			Works just like the newline except for tabs instead of new lines
\d					Matches any digit (0-9)			‘testing123’ -match ‘\d’  					#'returns true because there are numbers present
\D					Matches a non-digit			    ‘1234’ -match ‘\D’  						#'returns false because everything in the string is a number
\w					Matches an alphanumeric character		‘hello123’ -match ‘\w’  			#'returns true because alpha numeric characters are present
\W					Matches a non-alphanumeric character	‘hello123’ -match ‘\W’ 				#'returns false because everything is an alphanumeric character
\s					Matches a whitespace character			‘ ‘ -match ‘\s’ 					#'returns true because between the quotation marks is a single space
\S					Matches a non-whitespace character		‘ ‘ -match ‘\S’  				 	#'returns false because all the characters are whitespace
\					Use \ to escape special characters		\. matches a dot and Error! Hyperlink reference not valid. matches a backslash
^					Matches the start of a string	
$					Matches the end of a string	

=============================================================[regex]
'Here, I’m looking for the digits in “abc123” using the matches() method of the [regex] accelerator. 
'The first parameter is the string to look within, and the second is the regex pattern to match.
'Here, I’m looking for the digits in “abc123” using the matches() method of the [regex] accelerator.
[regex]::matches(‘abc123’,‘\d’).value  #'returns 1, 2, 3 in an array

[regex]::matches(‘abc123’,‘\d\d\d’).value  #returns 123 in a string
============================================================={}
'We use curly braces to signify the number of times that we want a specific pattern or character to occur in our matches. 
something123’ -match ‘\d{3}’  #'returns true
'We know that the \d part of this pattern matches any digit. 
'the part that comes right before the curly braces to occur the number of times shown within the curly braces.

'We can also specify ranges.
something123’ -match ‘\d{2,4}  #returns true
'You can also go {2,} to specify “two or more times”.
=============================================================()
' round () brackets. In regex, we can use round brackets to group things. 
'whatever is in the brackets will be evaluated and returned as a match together. 
‘hello123hello123hello123’ -match ‘(hello123){3}’  #'returns true

‘hello123hello123 something else’ -match ‘(hello123){1,4}\s?something’  #'returns true
'but what I’m matching is “one to four occurrences of ‘hello123’ followed by zero or one whitespace, followed by ‘something'”

‘192.168.1.1’ -match ‘(\d{1,3}\.){3}\d{1,3}’
'Let’s break it down.
\d{1,3} 	' looking for one to three digits
\. 			' looking for a period
'Therefore, \d{1,3}\. is looking for one to three digits, followed by a period

(\d{1,3}\.){3} ' looking for three occurrences of “one to three digits followed by a period”
=============================================================[]
'In regex, we use square brackets to denote a set. 
'That might mean a range of characters or an array of characters that we’re interested in.

‘something’ -match ‘[f-q]$’ #'returns true
'In the first example, we’re looking for the pattern “a letter between f and q, 
'followed by the end of the line”. 
'Because “something” ends in g, which is between f and q, the pattern is a match. 


‘something’ -match ‘[h-q]$’  #'returns false
'we’re looking for “a letter between h and q, followed by the end of the line” 
'which doesn’t exist since g falls outside that range. 
'This is case sensitive in regex, 
'but the –match operator doesn’t take case into account.
=============================================================^
'You can negate a set, too, using the ^ symbol. That is to say, match “not this character”.
‘something’ -match ‘[^q]$’  #'returns true
‘something’ -match ‘[^g]$’  #'returns false
'The first example says, “something that is not a q followed by the end of the line” which matches our string of “something”. 
'The next example says, “something that is not a g followed by the end of the line” which returns false, because “something” ends in a g followed by the end of the line.



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>checkForRegistryValueExistence_remote</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>checkForRegistryValueExistence_remote</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://stackoverflow.com/questions/48325213/remote-registry-key-extractor-powershell-script

'This is the piece used used in the code below:
			--------------------------------------
            $REG = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', 'IT-1241')
            $REGKEY = $REG.OpenSubKey("Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending")
            $MELT = $REGKEY.GetValue('Default')

            $REGKEY
            $MELT
			---------------------------------------

1] ===========================================================================================
'Once it's been instanced the RegistryKey class does not expose that it's a remote key. 
'That means you have to record the computer name yourself.
'There's also no standard format for a remote registry value.

'If I had a PowerShell v5+, I would use something like this:

Import-Module ActiveDirectory

#' No need for the Select-Object here since we're using $SRV.Name later

$SRVS = Get-ADComputer -Filter * -SearchBase 'DC=mydomain,DC=local'

#' Create an arraylist to save our records
$Report = New-Object System.Collections.ArrayList

#' This try finally is to ensure we can always write out what we've done so far
try {
    foreach ($SRV in $SRVS) {
        # Test if the remote computer is online
        $IsOnline = Test-Connection -ComputerName $SRV.Name -Count 1 -Quiet;
        if ($IsOnline) {
            #' If system is Online
            $REG = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $SRV.name)
            $REGKEY = $REG.OpenSubKey("SOFTWARE\Microsoft\Windows\CurrentVersion\QualityCompat")
            $MELT = $REGKEY.GetValue('cadca5fe-87d3-4b96-b7fb-a231484277cc')

            #' Create a PSObject record for convenience
            $Record = [PSCustomObject]@{
                ComputerName = $SRV;
                Key          = $REGKEY.Name;
                Value        = $MELT;
            }
        }
        else {
            #' If system is Offline
            #' Create a PSObject record for convenience
            $Record = [PSCustomObject]@{
                ComputerName = $SRV;
                Key          = '';
                Value        = '';
            }
        }

        #' Add our record to the report
        $Report.Add($Record);
    }
}
finally {
    #' Always write out what we have whether or not we hit an error in the middle
    $Report | Export-Csv -Path "C:\Users\user1\Desktop\regkeys.csv" -NoTypeInformation
}



2] ===========================================================================================
Clear-Host 
Import-Module ActiveDirectory

$SRVS = (Get-ADComputer -Filter * -SearchBase (Get-ADDomainController).DefaultPartition)
$MeltHive = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\QualityCompat'
$MeltHiveKey = 'cadca5fe-87d3-4b96-b7fb-a231484277cc'

ForEach($Srv in $SRVS)
{
    Invoke-Command -ComputerName $Srv.Name -ScriptBlock {
            If (Get-ItemProperty -Path $Using:MeltHive -Name $MeltHiveKey -ErrorAction SilentlyContinue)
            {"On Host $env:COMPUTERNAME MELT registry information exists"}
            Else {Write-Warning -Message "On host $env:COMPUTERNAME MELT registry information does not exist"}
        }
}



ForEach($Srv in $SRVS)
{
    Invoke-Command -ComputerName $Srv.Name -ScriptBlock {
            If ((Get-ChildItem -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion) -match 'QualityCompat')
            {"On Host $env:COMPUTERNAME MELT registry information exists"}
            Else {Write-Warning -Message "On host $env:COMPUTERNAME MELT registry information does not exist"}
        }
}


'Results of both the above is:

'WARNING: On host DC01 MELT registry information does not exist
'WARNING: On host EX01 MELT registry information does not exist
'WARNING: On host SQL01 MELT registry information does not exist
'On Host IIS01 MELT registry information exists

'You're missing a $using: on $MeltHiveKey in your first Invoke-Command, 
'and this method is far more invasive than the WMI queries that the OP is using. 
'A lot more overhead creating a session on each server like you're doing

===========================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>DoesRemoveWindowsStoreExist_if_So_WhatIsItsValue_v4</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>DoesRemoveWindowsStoreExist_if_So_WhatIsItsValue_v4</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$file_WindowsVersionsInfo &lt;=== This file was not created. What was the problem? 0959 did not show up in the Windows List

#'DoesRemoveWindowsStoreExist_if_So_WhatIsItsValue_v4.ps1
#' 1] Ping the computer
#' 2] Write the name of those that ping into the file Ping_Returned_2018_05_01.txt
#'    Write the name of those that did NOT ping into the file Ping_DidNOT_2018_05_01.txt
#' 3] For those that pinged check the OS version
#'    Write the name of Win10 computers into the file OS_Win10_2018_05_01.txt
#'    Write the name of Other OS into the file OS_NOT_Win10_2018_05_01.txt
#' 4] For the Win10 computers: store in file: 
#'    Three columns: OS, RemoveWindowsStore_Exists, RemoveWindowsStore_Value

#'============================================

$Path_forFiles = "C:\DATA\"
$file_INPUT_computerList = $Path_forFiles + "2018_05_01_ALL_computers.txt"
$file_PingReturned = $Path_forFiles + "2018_05_01_Ping_Returned.txt"
$file_PingNOTReturned = $Path_forFiles + "2018_05_01_Ping_DidNOT.txt"
$file_WindowsVersionsInfo =  $Path_forFiles + "2018_05_01_WindowsVersion.csv"    #' NOTE: CSV
$file_OS_Win10 = $Path_forFiles + "2018_05_01_OS_Win10.txt"
$file_WindowsStoreINFO  = $Path_forFiles + "2018_05_01_WindowsStoreINFO.csv"    #' NOTE: CSV

$registryPath = "HKLM:\Software\Microsoft\WindowsStore"
$RegitryValueName = "RemoveWindowsStore"
$value = "1"

#' 1] Ping the computer
#' 2] Write the name of those that ping into the file Ping_Returned_2018_05_01.txt
#'    Write the name of those that did NOT ping into the file Ping_DidNOT_2018_05_01.txt
$Computers = get-content $file_INPUT_computerList;
foreach ($computer in $Computers) {
    write-host $computer   
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
			Add-Content -value $computer -path $file_PingReturned
		}else{
			Add-Content -value $computer -path $file_PingNOTReturned
		}
	}

#' 3] For those that pinged check the OS version
#'    Write the name of Win10 computers into the file OS_Win10_2018_05_01.txt
#'    Write the name of Other OS into the file OS_NOT_Win10_2018_05_01.txt

 
$theComputerOSinfo = @()
$computers = Get-Content $file_PingReturned 
$i=0
$count = $computers.count
foreach($computer in $computers)
    {
        $i++
        Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
        -PercentComplete ($i/$count*100)
        $info = @{}
        $version = 0
        try{
            #'================================================================================

                        write-host "responded to PING:"$computer -ForegroundColor Green 
                        #'--------------------------------------------------------------------------------
                        $OperatingSystem = Get-WmiObject -ComputerName $computer -Class Win32_OperatingSystem
                        #'--------------------------------------------------------------------------------
                        $BuildNumber = $OperatingSystem.BuildNumber 
                        write-host "Build Number:"$BuildNumber -ForegroundColor White                  
                        switch  ($BuildNumber)
                        {
                            10240 {$Build = "1507, Threshold 1, N/A,  July 29, 2015"}
                            10586 {$Build = "1511, Threshold 2, November Update,  2015/11/10"}
                            14393 {$Build = "1607, Redstone 1, 2016/08/02"}
                            15063 {$Build = "1703, Redstone 2, Creators Update, 2017/04/05"}
                            16299 {$Build = "1709, Redstone 3, Fall Creators Update, 2017/10/17"}
                            17134 {$Build = "1803, Redstone 4, Early 2018"}
                            17650 {$Build = "1809, Redstone 5, Late 2018"}
                            default {$Build = "default"}
                        }
                        write-host "Build:"$Build -ForegroundColor White 

                        #'--------------------------------------------------------------------------------
                        $OS = $OperatingSystem.Version  
                        write-host "OS:"$OS -ForegroundColor Yellow                  
                        switch  ($OS)
                        {
                            "10.0.16299" {$OSName = "Windows 10 (1709)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.15063" {$OSName = "Windows 10 (1703)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.14393" {$OSName = "Windows 10 (1607)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.10586" {$OSName = "Windows 10 (1511)"; Add-Content -value $computer -path $file_OS_Win10}
                            "10.0.10240" {$OSName = "Windows 10"; Add-Content -value $computer -path $file_OS_Win10}
                            "6.3.9600" {$OSName = "Windows 8.1 (Update 1)"}
                            "6.3.9200" {$OSName = "Windows 8.1"}
                            "6.2.9200" {$OSName = "Windows 8"}
                            "6.1.7601" {$OSName = "Windows 7 SP1"}
                            "6.1.7600" {$OSName = "Windows 7"}
                            "6.0.6002" {$OSName = "Windows Vista SP2"}
                            "6.0.6001" {$OSName = "Windows Vista SP1"}
                            "6.0.6000" {$OSName = "Windows Vista"}
                            "5.1.2600" {$OSName = "Windows XP"}
                            default {$OSName = "default"}
                        }
                        write-host "OSName:"$OSName -ForegroundColor Yellow 
            #'================================================================================
            }
 
 
            catch
            {
                        $OperatingSystem  = 'Not Installed/Not Available'
            }

            $info.Computer = $computer
            $info.OSName= $OSName
            $info.Build =  $Build
            $info.BuildNumber =  $BuildNumber
            $info.OSversion = $OS

            $object = new-object -TypeName PSObject -Property $info
            $theComputerOSinfo += $object
}
$theComputerOSinfo | select computer,OSName,Build, BuildNumber,OSversion  | Export-Csv -NoTypeInformation -Path $file_WindowsVersionsInfo

#' 4] For the Win10 computers: store in file:  $file_WindowsStoreINFO
#'    Three columns: OS, RemoveWindowsStore_Exists, RemoveWindowsStore_Value

$return_object = @()

foreach ($computer in (Get-Content $file_OS_Win10)){

  write-verbose "Getting Windows Store Info on $computer..." -Verbose
  $return_object += Invoke-Command -ComputerName "$computer" -ScriptBlock {
                                                                            #'=====================================================================================
                                                                            write-verbose "1]" -Verbose
                                                                            $info2 = @{}
                                                                            $registryPath = "HKLM:\Software\Microsoft\WindowsStore"
                                                                            $Name = "RemoveWindowsStore"
                                                                            $value = "1"
                                                                            write-verbose "2]" -Verbose
                                                                            try{
                                                                                    IF(!(Test-Path $registryPath))
	                                                                                    {
                                                                                            $registryPathExists = "1"
                                                                                            $registryPathValue = (Get-ItemProperty -Path $registryPath -Name $RegitryValueName).$RegitryValueName
	                                                                                    }
                                                                                     ELSE 
 	                                                                                    {
    	                                                                                    $registryPathExists = "0"
                                                                                            $registryPathValue = "n/a"
                                                                                        }
 			                                                                      }
			                                                                  catch{
		                                                                                $registryPathExists = "error"
                                                                                        $registryPathValue = "error"
		      	                                                                   }

                                                                            #' ------------------------------------------------------------

                                                                            write-verbose "3]" -Verbose
                                                                            Write-Host "-&gt; computer"$Using:computer
                                                                            Write-Host "-&gt; registryPathExists"$registryPathExists
                                                                            Write-Host "-&gt; registryPathValue"$registryPathValue
                                                                            New-Object -TypeName PSCustomObject -Property @{Host=$env:computername; registryPathExists=$registryPathExists; registryPathValue=$registryPathValue}
                                                                            write-verbose "4]" -Verbose

                                                                           #'========================================================================================
                                                                            Write-Host "ScriptBlock Loop Done: " -ForegroundColor Green
                                                                            #'return $info2
                                                                            } 
                                                        Write-Host "6] Loop for computer is done"$computer -ForegroundColor Green
                                                        
                                                        
                                                    }
                                                    write-verbose "7] all computers have been looped" -Verbose
                                                   
                                                   #'| SELECT computer,registryPathExists,registryPathValue
                                                    $return_object | select Host, registryPathExists, registryPathValue  | Export-Csv -NoTypeInformation -Path $file_WindowsStoreINFO
                                                    write-output ("Done with all computers")
                                                     $return_object | select Host, registryPathExists, registryPathValue  | Format-List









</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>if_you_need_users_SID</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>if_you_need_users_SID</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'If you need user's SID and browse remote HKEY_USERS folder, you can follow this script :

'&lt;# Replace following domain.name with yours and userAccountName with remote username #&gt;
$userLogin = New-Object System.Security.Principal.NTAccount(“domain.name“,”userAccountName“)
$userSID = $userLogin.Translate([System.Security.Principal.SecurityIdentifier])

'&lt;# We will open HKEY_USERS and with accurate user’s SID from remoteComputer #&gt;
$remoteRegistry = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey(‘Users’,”remoteComputer“)

'&lt;# We will then retrieve LocalName value from Control Panel / International subkeys #&gt;

$key = $userSID.value+”\Control Panel\International”
$openKey = $remoteRegistry.OpenSubKey($key)

'&lt;# We can now retrieve any values #&gt;

$localName = $openKey.GetValue(‘LocaleName’)
Source : http://techsultan.com/how-to-browse-remote-registry-in-powershell/</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Registry</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Registry_Function_Example_ex_RDP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Registry</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Registry_Function_Example_ex_RDP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>RDP_Remotely_enable_RDP

https://community.spiceworks.com/scripts/show/3924-remotely-enable-rdp

#'Will Remotely Enable Remote Desktop Protocol. That sounds funny, but it works.
#'
#'This script will access the Remote Registry of the target computer and enable it. 
#'    Then it will make a change to the Registry Key related to RDP, 
#'    thus allowing you to get into your target computer. It can also be run locally to set the Registry Key.
#'
#'The only problem is this sets the option in 
#'    System &gt; Advanced system settings &gt; Remote to 
#'    "Allow connections from computers running any version of Remote Desktop (less secure)". 
#'My suggestion is to set this to 
#'    "Allow connections only from computers running Remote Desktop with Network Level Authentication (more secure)" 
#'    once you have successfully remoted in to your target machine.


#------------------------------------------------------------------------------------
#\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/
#/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\
#------------------------------------------------------------------------------------
#|\--
#|-\-Author:  Chris Rakowitz
#|--\Purpose:  Enables the Remote Desktop Protocol on a Target Computer.
#|--/Date:  February 7, 2017
#|-/-Version:  1.00
#|/--
#------------------------------------------------------------------------------------
#\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/
#/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\
#------------------------------------------------------------------------------------

&lt;#
	.SYNOPSIS
	Enables the Remote Desktop Protocol on a target computer.
	
	.DESCRIPTION
	Remote Desktop Protocol is the Protocol used when remoting into Windows machines.
	This script will set the Registry Key that is needed to enable this functionality
	easily.
	
	This Registry Key is found at:
	HKLM:SYSTEM\CurrentControlSet\Control\Terminal Server
	Key:  fDenyTSConnections
	
	.PARAMETER $ComputerName
	Accepts a single computer name or IP Address.  Also accepts a
	comma-separated list or a path to a text file list as input.
	Leaving this parameter blank will result in the script running on
	the local machine.
	
	.EXAMPLE
	Enable-RDP.ps1
	
	Enables Windows Remote Desktop Protocol on the Local computer.
	
	.EXAMPLE
	Enable-RDP.ps1 -ComputerName TEST-1234
	
	Enables Windows Remote Desktop Protocol on the computer TEST-1234.
	
	.EXAMPLE
	Enable-RDP.ps1 -ComputerName Test-1, Test-2, Test-3
	
	Enable Windows Remote Desktop Protocol on the computers Test-1,
	Test-2 and Test-3.
	
	.EXAMPLE
	Enable-RDP.ps1 -ComputerName "C:\List\Of\My\Computers.txt"
	
	Enables Windows Remote Desktop Protocol on all the computers in the
	text file at the specified location.
	
	.NOTES
	This is required to be run as a local administrator or as a Domain
	account that has Administrator rights on the target computer or
	computers.
#&gt;

[cmdletbinding()]
param
(
	[Parameter(Mandatory=$False)] [string[]]$ComputerName = $env:computername
)
# Tell Powershell to ignore any errors that may fill up the screen.
#$ErrorActionPreference = 'silentlycontinue'

If($ComputerName -Like "*.txt")
{
	$CompList = Get-Content ([regex]::matches($ComputerName,'[^\"]+') | %{$_.value})
}
Else
{
	$CompList = $ComputerName
}

Foreach($Computer in $CompList)
{
	If(!(Test-Connection -ComputerName $Computer -TimeToLive 18 -Count 1))
	{
		Write-Host "$Computer - Offline" -Foreground red -Background black
		Write-Host ""
		continue
	}
	Else
	{
		Write-Host $Computer -Foreground green -Background black
		Write-Host ""
		
		Write-Host "Enabling Remote Desktop Protocol`n" -Foreground green -Background black
		
		# Enable the Remote Registry service on the target computer.  This allows keys to read/modified.
		Write-Host "Enabling Remote Registry Service" -Foreground yellow -Background black
		Set-Service -ComputerName $Computer -StartUpType Manual -Status Running `
			-Name RemoteRegistry -DisplayName "Remote Registry"
			
		# Access the registry and modify the Registry Key 'fDenyTSConnections' to enable RDP.
		Write-Host "`nSetting Remote Desktop Protocol Registry Key`n" -Foreground cyan -Background black
		$RegBaseKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBasekey('LocalMachine', "$Computer")
		$TSKeys = $RegBaseKey.OpenSubKey("SYSTEM\\CurrentControlSet\\Control\\Terminal Server", $True)
		$TSKeys.SetValue("fDenyTSConnections","0",[Microsoft.Win32.RegistryValueKind]::DWORD)

		# Disable the Remote Registry service.
		Write-Host "Stopping Remote Registry Service" -Foreground yellow -Background black
		(Get-Service -ComputerName $Computer -Name RemoteRegistry).stop()
		Write-Host "Disabling Remote Registry Service" -Foreground yellow -Background black
		Set-Service -ComputerName $Computer -StartUpType Disabled -Name RemoteRegistry
		Write-Host ""
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting__Invoke-Command</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Count_And_List_pxplus_Sessions_on_BCC-EXPLORER3</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting__Invoke-Command</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Count_And_List_pxplus_Sessions_on_BCC-EXPLORER3</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Count_And_List_pxplus_Sessions_on_BCC-EXPLORER3

cls
$serverName = 'BCC-EXPLORER3' 

$serverName + '  (open pxplus Sessions)'
Write-Host ''

$result = Invoke-Command  -ComputerName $serverName  -ScriptBlock { 
                                                                    
                                                                    $process = "pxplus.exe"
                                                                    $arrResults = Get-WmiObject Win32_Process -Namespace "root\cimv2"  -Filter "name = '$process'"  |  Select CommandLine,CreationDate,ProcessID  | Where-Object {$_.CommandLine -like "*id=T*"} 
                                                                    $m = $arrResults | measure


                                                                    write-host 'count: '  $m.Count

                                                                    write-host ' ' 
                                                                    $arrResults | foreach{ 
                                                                                            write-host $_.CommandLine 
                                                                                            write-host 'PID: ' $_.ProcessID
                                                                                            write-host 'Started: ' $_.CreationDate.substring(0,8) ' time:' $_.CreationDate.substring(8,2) ':'  $_.CreationDate.substring(10,2)
                                                                                            write-host ' ' 
                                                                                          }

                                                                    write-host 'count: '  $m.Count
																 }															 } </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CIM_ErrorHandling_assumes_you_start_with_WSman_Protocol</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CIM_ErrorHandling_assumes_you_start_with_WSman_Protocol</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'In this revision, we changed our New-CimSessionOption to use a variable for the protocol.
'We manually set this to “Wsman” to begin with, but in the event of a failure, we switch it to “Dcom.” 
' If it fails again, we set the protocol to “Stop,” which triggers an exit from our Do loop, 
'	and also take the opportunity to log the computer name, if we were asked to do so. 
'Writes error to Log	


function Set-TMServiceLogon {
&lt;#'
.SYNOPSIS
Sets service login name and password.
.DESCRIPTION
This command uses either CIM (default) or WMI to
set the service password, and optionally the logon
user name, for a service, which can be running on
one or more remote machines. You must run this command
as a user who has permission to peform this task,
remotely, on the computers involved.
.PARAMETER ServiceName
The name of the service. Query the Win32_Service class
to verify that you know the correct name.
.PARAMETER ComputerName
One or more computer names. Using IP addresses will
fail with CIM; they will work with WMI. CIM is always
attempted first. 
.PARAMETER NewPassword
A plain-text string of the new password.
.PARAMETER NewUser
Optional; the new logon user name, in DOMAIN\USER
format.
.PARAMETER ErrorLogFilePath
If provided, this is a path and filename of a text
file where failed computer names will be logged.
#'&gt;
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True,
                   ValueFromPipelineByPropertyName=$True)]
        [string]$ServiceName,

        [Parameter(Mandatory=$True,
                   ValueFromPipeline=$True,
                   ValueFromPipelineByPropertyName=$True)]
        [string[]]$ComputerName,

        [Parameter(ValueFromPipelineByPropertyName=$True)]
        [string]$NewPassword,

        [Parameter(ValueFromPipelineByPropertyName=$True)]
        [string]$NewUser,

        [string]$ErrorLogFilePath
    )

BEGIN{}

PROCESS{
    ForEach ($computer in $ComputerName) {

        Do {
            Write-Verbose "Connect to $computer on WS-MAN"
            $protocol = "Wsman"

            Try {
                $option = New-CimSessionOption -Protocol $protocol
                $session = New-CimSession -SessionOption $option `
                                          -ComputerName $Computer `
                                          -ErrorAction Stop

                If ($PSBoundParameters.ContainsKey('NewUser')) {
                    $args = @{'StartName'=$NewUser
                              'StartPassword'=$NewPassword}
                } Else {
                    $args = @{'StartPassword'=$NewPassword}
                    Write-Warning "Not setting a new user name"
                }

                Write-Verbose "Setting $servicename on $computer"
                $params = @{'CimSession'=$session
                            'MethodName'='Change'
                            'Query'="SELECT * FROM Win32_Service " +
                                    "WHERE Name = '$ServiceName'"
                            'Arguments'=$args}
                $ret = Invoke-CimMethod @params

                switch ($ret.ReturnValue) {
                    0  { $status = "Success" }
                    22 { $status = "Invalid Account" }
                    Default { $status = "Failed: $($ret.ReturnValue)" }
                }

                $props = @{'ComputerName'=$computer
                           'Status'=$status}
                $obj = New-Object -TypeName PSObject -Property $props
                Write-Output $obj

                Write-Verbose "Closing connection to $computer"
                $session | Remove-CimSession
		$protocol = "Stop"
            } Catch {
                #' change protocol - if we've tried both
                #' and logging was specified, log the computer
                Switch ($protocol) {
                    'Wsman' { $protocol = 'Dcom' }
                    'Dcom'  { 
                        $protocol = 'Stop'

                        if ($PSBoundParameters.ContainsKey('ErrorLogFilePath')) {
                            Write-Warning "$computer failed; logged to $ErrorLogFilePath"
                            $computer | Out-File $ErrorLogFilePath -Append
                        } #' if logging
                     }            
                } #'switch

            } #' try/catch
        } Until ($protocol -eq 'Stop')
    } #'foreach
} #'PROCESS

END{} 

} #'function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_GetResultsFromContactingAComputer_showAsStatus</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_GetResultsFromContactingAComputer_showAsStatus</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Example_GetResultsFromContactingAComputer_showAsStatus

'it outputs an object for each computer it operates against. 
'	The output should include the computer name and a status 




===========================================================
function Set-TMServiceLogon {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True,                              #' &lt;=== Mandatory
                   ValueFromPipelineByPropertyName=$True)]       #' &lt;=== can accept pipeline input ByPropertyName
        [string]$ServiceName,

        [Parameter(Mandatory=$True,                              #' &lt;=== Mandatory
                   ValueFromPipeline=$True,                      #' &lt;=== can accept pipeline input ByValue  (only one parm is allowed to do so?)
                   ValueFromPipelineByPropertyName=$True)]       #' &lt;=== can accept pipeline input ByPropertyName
        [string[]]$ComputerName,

        [Parameter(Mandatory=$True,                              #' &lt;=== Mandatory
                   ValueFromPipelineByPropertyName=$True)]       #' &lt;=== can accept pipeline input ByPropertyName
        [string]$NewPassword,

        [Parameter(ValueFromPipelineByPropertyName=$True)]       #' &lt;=== can accept pipeline input ByPropertyName
        [string]$NewUser,

        [string]$ErrorLogFilePath
    )

BEGIN{}

PROCESS{
    ForEach ($computer in $ComputerName) {

        $option = New-CimSessionOption -Protocol Wsman
        $session = New-CimSession -SessionOption $option `
                                  -ComputerName $Computer

        If ($PSBoundParameters.ContainsKey('NewUser')) {           
            $args = @{'StartName'=$NewUser
                      'StartPassword'=$NewPassword}
        } Else {
            $args = @{'StartPassword'=$NewPassword}
        }

        $params = @{'CimSession'=$session                        #' Put the Parms into a HashTable
                    'MethodName'='Change'
                    'Query'="SELECT * FROM Win32_Service WHERE Name = '$ServiceName'"
                    'Arguments'=$args}
        $ret = Invoke-CimMethod @params                          #' Splat the HashTable as input to 'Invoke-CimMethod'
       
        #' Change Method (Win32_Service) status Codes: https://msdn.microsoft.com/en-us/library/aa384901.aspx
        
        switch ($ret.ReturnValue) {                              #' Get the Return Value
            0  { $status = "Success" }      
            22 { $status = "Invalid Account" }
            Default { $status = "Failed: $($ret.ReturnValue)" }
        }

        $props = @{'ComputerName'=$computer                      #' Build the output variable, with the Return Value and the Computer Name
                   'Status'=$status}
        $obj = New-Object -TypeName PSObject -Property $props    #' Package the output variable into a new object
        Write-Output $obj                                        #' Write the object to the screen

        $session | Remove-CimSession

    } #foreach
} #PROCESS

END{} 

} #function
===========================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting_CIM</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Function_with_fallBackTo_DCOM</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting_CIM</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Function_with_fallBackTo_DCOM</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>from:https://gallery.technet.microsoft.com/scriptcenter/PowerShell-Function-to-a7fb6800

Create Sessions

=================USAGE:
&gt;New-MrCimSession -ComputerName SQL01, SQL03

'The previously created CimSessions can be used to query information from WMI 
'	on the remote computers regardless of which underlying protocol is used for communication:

&gt; Get-CimInstance -CimSession (Get-CimSession) -ClassName Win32_OperatingSystem |
Select-Object -Property PSComputerName, Caption

'The 'Get-CimSession' gets the sessions created in the first command,
'	and the result is a list of the computernames, and the OS (i.e. the Caption)
=======================================================================
#Requires -Version 3.0 
function New-MrCimSession { 
&lt;# 
.SYNOPSIS 
    Creates CimSessions to remote computer(s), automatically determining if the WSMAN 
    or Dcom protocol should be used. 
.DESCRIPTION 
    New-MrCimSession is a function that is designed to create CimSessions to one or more 
    computers, automatically determining if the default WSMAN protocol or the backwards 
    compatible Dcom protocol should be used. PowerShell version 3 is required on the 
    computer that this function is being run on, but PowerShell does not need to be 
    installed at all on the remote computer. 
.PARAMETER ComputerName 
    The name of the remote computer(s). This parameter accepts pipeline input. The local 
    computer is the default. 
.PARAMETER Credential 
    Specifies a user account that has permission to perform this action. The default is 
    the current user. 
.EXAMPLE 
     New-MrCimSession -ComputerName Server01, Server02 
.EXAMPLE 
     New-MrCimSession -ComputerName Server01, Server02 -Credential (Get-Credential) 
.EXAMPLE 
     Get-Content -Path C:\Servers.txt | New-MrCimSession 
.INPUTS 
    String 
.OUTPUTS 
    Microsoft.Management.Infrastructure.CimSession 
.NOTES 
    Author:  Mike F Robbins 
    Website: http://mikefrobbins.com 
    Twitter: @mikefrobbins 
#&gt; 
    [CmdletBinding()] 
    param( 
        [Parameter(ValueFromPipeline)] 
        [ValidateNotNullorEmpty()] 
        [string[]]$ComputerName = $env:COMPUTERNAME, 
  
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty 
    ) 
 
    BEGIN { 
        $Opt = New-CimSessionOption -Protocol Dcom 
 
        $SessionParams = @{ 
            ErrorAction = 'Stop' 
        } 
 
        If ($PSBoundParameters['Credential']) { 
            $SessionParams.Credential = $Credential 
        } 
    } 
 
    PROCESS { 
        foreach ($Computer in $ComputerName) { 
            $SessionParams.ComputerName  = $Computer 
 
            if ((Test-WSMan -ComputerName $Computer -ErrorAction SilentlyContinue).productversion -match 'Stack: ([3-9]|[1-9][0-9]+)\.[0-9]+') { 
                try { 
                    Write-Verbose -Message "Attempting to connect to $Computer using the WSMAN protocol." 
                    New-CimSession @SessionParams 
                } 
                catch { 
                    Write-Warning -Message "Unable to connect to $Computer using the WSMAN protocol. Verify your credentials and try again." 
                } 
            } 
  
            else { 
                $SessionParams.SessionOption = $Opt 
 
                try { 
                    Write-Verbose -Message "Attempting to connect to $Computer using the DCOM protocol." 
                    New-CimSession @SessionParams 
                } 
                catch { 
                    Write-Warning -Message "Unable to connect to $Computer using the WSMAN or DCOM protocol. Verify $Computer is online and try again." 
                } 
 
                $SessionParams.Remove('SessionOption') 
            }             
        } 
    } 
}

=======================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-UserSession</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-UserSession</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

#'FROM: https://gallery.technet.microsoft.com/scriptcenter/Get-UserSessions-Parse-b4c97837

#' To uset it:
#' &gt; Get-UserSession -ComputerName BCC-EXPLORER3


function Get-UserSession {
&lt;#  
.SYNOPSIS  
    Retrieves all user sessions from local or remote computers(s)

.DESCRIPTION
    Retrieves all user sessions from local or remote computer(s).
    
    Note:   Requires query.exe in order to run
    Note:   This works against Windows Vista and later systems provided the following registry value is in place
            HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\AllowRemoteRPC = 1
    Note:   If query.exe takes longer than 15 seconds to return, an error is thrown and the next computername is processed.  Suppress this with -erroraction silentlycontinue
    Note:   If $sessions is empty, we return a warning saying no users.  Suppress this with -warningaction silentlycontinue

.PARAMETER computername
    Name of computer(s) to run session query against
              
.parameter parseIdleTime
    Parse idle time into a timespan object

.parameter timeout
    Seconds to wait before ending query.exe process.  Helpful in situations where query.exe hangs due to the state of the remote system.
                    
.FUNCTIONALITY
    Computers

.EXAMPLE
    Get-usersession -computername "server1"

    Query all current user sessions on 'server1'

.EXAMPLE
    Get-UserSession -computername $servers -parseIdleTime | ?{$_.idletime -gt [timespan]"1:00"} | ft -AutoSize

    Query all servers in the array $servers, parse idle time, check for idle time greater than 1 hour.

.NOTES
    Thanks to Boe Prox for the ideas - http://learn-powershell.net/2010/11/01/quick-hit-find-currently-logged-on-users/

.LINK
    http://gallery.technet.microsoft.com/Get-UserSessions-Parse-b4c97837

#&gt; 
    [cmdletbinding()]
    Param(
        [Parameter(
            Position = 0,
            ValueFromPipeline = $True)]
        [string[]]$ComputerName = "localhost",

        [switch]$ParseIdleTime,

        [validaterange(0,120)]
        [int]$Timeout = 15
    )             
    Process
    {
        ForEach($computer in $ComputerName)
        {
        
            #start query.exe using .net and cmd /c.  We do this to avoid cases where query.exe hangs

                #build temp file to store results.  Loop until we see the file
                    Try
                    {
                        $Started = Get-Date
                        $tempFile = [System.IO.Path]::GetTempFileName()
                        
                        Do{
                            start-sleep -Milliseconds 300
                            
                            if( ((Get-Date) - $Started).totalseconds -gt 10)
                            {
                                Throw "Timed out waiting for temp file '$TempFile'"
                            }
                        }
                        Until(Test-Path -Path $tempfile)
                    }
                    Catch
                    {
                        Write-Error "Error for '$Computer': $_"
                        Continue
                    }

                #Record date.  Start process to run query in cmd.  I use starttime independently of process starttime due to a few issues we ran into
                    $Started = Get-Date
                    $p = Start-Process -FilePath C:\windows\system32\cmd.exe -ArgumentList "/c query user /server:$computer &gt; $tempfile" -WindowStyle hidden -passthru

                #we can't read in info or else it will freeze.  We cant run waitforexit until we read the standard output, or we run into issues...
                #handle timeouts on our own by watching hasexited
                    $stopprocessing = $false
                    do
                    {
                    
                        #check if process has exited
                            $hasExited = $p.HasExited
                
                        #check if there is still a record of the process
                            Try
                            {
                                $proc = Get-Process -id $p.id -ErrorAction stop
                            }
                            Catch
                            {
                                $proc = $null
                            }

                        #sleep a bit
                            start-sleep -seconds .5

                        #If we timed out and the process has not exited, kill the process
                            if( ( (Get-Date) - $Started ).totalseconds -gt $timeout -and -not $hasExited -and $proc)
                            {
                                $p.kill()
                                $stopprocessing = $true
                                Remove-Item $tempfile -force
                                Write-Error "$computer`: Query.exe took longer than $timeout seconds to execute"
                            }
                    }
                    until($hasexited -or $stopProcessing -or -not $proc)
                    
                    if($stopprocessing)
                    {
                        Continue
                    }

                    #if we are still processing, read the output!
                        try
                        {
                            $sessions = Get-Content $tempfile -ErrorAction stop
                            Remove-Item $tempfile -force
                        }
                        catch
                        {
                            Write-Error "Could not process results for '$computer' in '$tempfile': $_"
                            continue
                        }
        
            #handle no results
            if($sessions){

                1..($sessions.count - 1) | Foreach-Object {
            
                    #Start to build the custom object
                    $temp = "" | Select ComputerName, Username, SessionName, Id, State, IdleTime, LogonTime
                    $temp.ComputerName = $computer

                    #The output of query.exe is dynamic. 
                    #strings should be 82 chars by default, but could reach higher depending on idle time.
                    #we use arrays to handle the latter.

                    if($sessions[$_].length -gt 5){
                        
                        #if the length is normal, parse substrings
                        if($sessions[$_].length -le 82){
                           
                            $temp.Username = $sessions[$_].Substring(1,22).trim()
                            $temp.SessionName = $sessions[$_].Substring(23,19).trim()
                            $temp.Id = $sessions[$_].Substring(42,4).trim()
                            $temp.State = $sessions[$_].Substring(46,8).trim()
                            $temp.IdleTime = $sessions[$_].Substring(54,11).trim()
                            $logonTimeLength = $sessions[$_].length - 65
                            try{
                                $temp.LogonTime = Get-Date $sessions[$_].Substring(65,$logonTimeLength).trim() -ErrorAction stop
                            }
                            catch{
                                #Cleaning up code, investigate reason behind this.  Long way of saying $null....
                                $temp.LogonTime = $sessions[$_].Substring(65,$logonTimeLength).trim() | Out-Null
                            }

                        }
                        
                        #Otherwise, create array and parse
                        else{                                       
                            $array = $sessions[$_] -replace "\s+", " " -split " "
                            $temp.Username = $array[1]
                
                            #in some cases the array will be missing the session name.  array indices change
                            if($array.count -lt 9){
                                $temp.SessionName = ""
                                $temp.Id = $array[2]
                                $temp.State = $array[3]
                                $temp.IdleTime = $array[4]
                                try
                                {
                                    $temp.LogonTime = Get-Date $($array[5] + " " + $array[6] + " " + $array[7]) -ErrorAction stop
                                }
                                catch
                                {
                                    $temp.LogonTime = ($array[5] + " " + $array[6] + " " + $array[7]).trim()
                                }
                            }
                            else{
                                $temp.SessionName = $array[2]
                                $temp.Id = $array[3]
                                $temp.State = $array[4]
                                $temp.IdleTime = $array[5]
                                try
                                {
                                    $temp.LogonTime = Get-Date $($array[6] + " " + $array[7] + " " + $array[8]) -ErrorAction stop
                                }
                                catch
                                {
                                    $temp.LogonTime = ($array[6] + " " + $array[7] + " " + $array[8]).trim()
                                }
                            }
                        }

                        #if specified, parse idle time to timespan
                        if($parseIdleTime){
                            $string = $temp.idletime
                
                            #quick function to handle minutes or hours:minutes
                            function Convert-ShortIdle {
                                param($string)
                                if($string -match "\:"){
                                    [timespan]$string
                                }
                                else{
                                    New-TimeSpan -Minutes $string
                                }
                            }
                
                            #to the left of + is days
                            if($string -match "\+"){
                                $days = New-TimeSpan -days ($string -split "\+")[0]
                                $hourMin = Convert-ShortIdle ($string -split "\+")[1]
                                $temp.idletime = $days + $hourMin
                            }
                            #. means less than a minute
                            elseif($string -like "." -or $string -like "none"){
                                $temp.idletime = [timespan]"0:00"
                            }
                            #hours and minutes
                            else{
                                $temp.idletime = Convert-ShortIdle $string
                            }
                        }
                
                        #Output the result
                        $temp
                    }
                }
            }            
            else
            {
                Write-Warning "'$computer': No sessions found"
            }
        }
    }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LIST_of_RPC_server_is_unavalable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LIST_of_RPC_server_is_unavalable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'WhichComputers_RPCServerIsUnavailable_v0.ps1

$cred1 = Get-Credential  #' Run Once

$testcomputers = Get-Content -Path 'C:\DATA\2018_06_06_run_0_List_to_TEST.txt'


#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\2018_06_06_run_0_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\2018_06_06_run_0_didNOTping.txt
		}
	}

#'=============================================================================

$servers = Get-Content  -Path 'C:\DATA\2018_06_06_run_0_RespondToPing.txt'

ForEach ($server in $servers) {
  Try {

    write-host "TRY:"$server -ForegroundColor Green        
    gwmi win32_operatingsystem -computer $server -credential $cred1 -ErrorAction Stop    
    Add-Content -value $server -path C:\DATA\2018_06_06_run_0_WMI_is_OK.txt
    } 
  Catch {
    write-host "CATCH:"$server -ForegroundColor Red
    $ErrorMessage = $_.Exception.Message
    Add-Content -value $server -path C:\DATA\2018_06_06_run_0_RPCServerIsUnavaible.txt #'-ErrorAction Continue   
    Add-Content -value $($PSItem.ToString()) -path C:\DATA\2018_06_06_run_0_Errors.txt
    }
  Finally {
    $error.Clear() ; "errors cleared"  
    }
  }

 #' [System.Windows.MessageBox]::Show('DONE') 
 write-host "DONE!" -ForegroundColor Red</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogOff_Remote_RDP_TeamViewer_VM_sessions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogOff_Remote_RDP_TeamViewer_VM_sessions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'LogOff_Remote_RDP_TeamViewer_VM_sessions
http://stackoverflow.com/questions/18192746/powershell-log-off-remote-session

/////////////////////////////////////////////////////////////////////////////
' This makes it really easy to iterate through each entry and log out only the actual users, 
'and not the system or RDP listener itself which usually just throws an access denied error anyway.
'this script will have to be ran as an administrator user otherwise you can get accessed denied trying to log someone out. 

$serverName = "BCC-EXPLORER3DB"
$sessions = qwinsta /server $serverName| ?{ $_ -notmatch '^ SESSIONNAME' } | %{
$item = "" | Select "Active", "SessionName", "Username", "Id", "State", "Type", "Device"
$item.Active = $_.Substring(0,1) -match '&gt;'
$item.SessionName = $_.Substring(1,18).Trim()
$item.Username = $_.Substring(19,20).Trim()
$item.Id = $_.Substring(39,9).Trim()
$item.State = $_.Substring(48,8).Trim()
$item.Type = $_.Substring(56,12).Trim()
$item.Device = $_.Substring(68).Trim()
$item
} 

'ORIGINAL  - kills active and disconnected sessions
foreach ($session in $sessions){
    if ($session.Username -ne "" -or $session.Username.Length -gt 1){
        logoff /server $serverName $session.Id
    }
}

'MODIFIED to just logoff disconnected users
foreach ($session in $sessions){
    if (   ($session.Username -ne "" -or $session.Username.Length -gt 1) -and ($session.State -eq "Disc")  ){
        logoff /server $serverName $session.Id
    }
}

'NOTE: it took several seconds to actually logoff the sessions.


'HERE IS THE OUTPUT FROM THE $sessions variable when I ran it for BCC-EXPLORER3DB
'=====================
$sessions


									
Active      : False
SessionName : services
Username    : 							'Since this is = "", it is not logged off
Id          : 0
State       : Disc
Type        : 
Device      : 

Active      : False
SessionName : 
Username    : explorer1					'Since this is ne "", it is logged off, it is a TeamViewer Session
Id          : 1
State       : Disc
Type        : 
Device      : 

Active      : False
SessionName : console
Username    : glenng					'Since this is ne "", it is logged off, it is a vCenter Session
Id          : 2
State       : Active
Type        : 
Device      : 

Active      : False
SessionName : rdp-tcp
Username    : 							'Since this is = "", it is not logged off 
Id          : 65536
State       : Listen
Type        : 
Device      : 
'=====================


/////////////////////////////////////////////////////////////////////////////
'Log off all users from a machine:

try {
   query user /server:$SERVER 2&gt;&amp;1 | select -skip 1 | foreach {
     logoff ($_ -split "\s+")[-6] /server:$SERVER
   }
}
catch {}

'Details:
'===================================================
'the try/catch is used when there are no users are on the server, and the query returns an error. however, you could drop the 2&gt;&amp;1 part, and remove the try/catch if you don't mind seeing the error string
'select -skip 1 removes the header line
'the inner foreach logs off each user
'($_ -split "\s+") splits the string to an array with just text items
'[-6] index gets session ID and is the 6th string counting from the reverse of the array, you need to do this because the query output will have either 8 or 9 elements depending if the users connected or disconnected from the terminal session

'I've modified Casey's answer to only logoff disconnected sessions by doing the following:

foreach($Server in $Servers) {
    try {
        query user /server:$Server 2&gt;&amp;1 | select -skip 1 | ? {($_ -split "\s+")[-5] -eq 'Disc'} | % {logoff ($_ -split "\s+")[-6] /server:$Server /V}
    }
    catch {}
    }



/////////////////////////////////////////////////////////////////////////////
'$session responses:
						rdp-tcp#56	'RDP sessions
						console   	'{at the console, or a Vcenter sesssion 
'===========================================================================						
						
$server   = 'BCC-EXPLORER3DB'
$username = $env:USERNAME

$session = ((quser /server:$server | ? { $_ -match $username }) -split ' +')[2]

$session

logoff $session /server:$server

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>multi-hop_Remoting</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>multi-hop_Remoting</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://techgenix.com/remote-management-powershell-part2/

#'For remoting to work, 
#'    your credentials must be delegated to the target computer. 
#'    Once you are connected, by default you are not allowed to initiate another connection from that target computer into another server. 
#'    because credentials can be delegated across one connection or hop only. In other words, credentials cannot be chain-delegated a second time.
#'
#'In order to overcome this default limitation, 
#'    you must configure group policy or set up both ends of the connection as follows:
#'
#'On the computer from which you are connecting from, run the following command:
#'

Enable-WSManCredSSP –Role Client  -DelegateComputer IT-103613.jphsa.org

#'The target computer name can be a * wildcard or a limited wildcard such as *.lanztek.local.
#'
#'On the computer that you are connecting to, run the same cmdlet but assigning a different role. 
#'    (This is the computer to which you are delegating your credentials.)


 Enable-WSManCredSSP –Role Server
 --------------------------------
  $cred = Get-Credential
 Invoke-Command -ComputerName IT-103613 -ScriptBlock {Enable-WSManCredSSP –Role Server} -Credential $cred
 
 
 
 
 
 
  ------------------------------------------
 #'Example 1: Delegate client credentials
 Enable-WSManCredSSP -Role "Client" -DelegateComputer "server02.accounting.fabrikam.com"
 
 #'Example 2: Delegate client credentials to all computers in a domain
 Enable-WSManCredSSP -Role "Client" -DelegateComputer "*.accounting.fabrikam.com"
 
 #'Example 3: Delegate client credentials to multiple computers
 Enable-WSManCredSSP -Role "Client" -DelegateComputer "server02.accounting.fabrikam.com", "server03.accounting.fabrikam.com", "server04.accounting.fabrikam.com"
 
 #'Example 4: Allow a computer to act as a delegate
 Enable-WSManCredSSP -Role "Server"</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PSExec_PSRemoting__on_remote_computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PSExec_PSRemoting__on_remote_computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>==========================================================================Powershell

psexec \\[computer name] -u [admin account name] -p [admin account password] -h -d powershell.exe "enable-psremoting -force"


psexec \\lt-1069 -u Administrator -p JPHSA@Work -h -d powershell.exe "enable-psremoting -force"


==========================================================================CMD
https://ss64.com/nt/psexec.html

'Internal commands (such as COPY, CD, DIR etc) are only available within the CMD shell. 
'To run these commands from PsExec you must call CMD /C and then pass the commands as parameters 
' see the examples below. 
 -s    =     Run remote process in the SYSTEM account (use with caution).

'Connect to workstation64 and list a directory:
------------------------------------------------
PSEXEC \\workstation64 -s cmd /c dir c:\work</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PSEXEC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PSEXEC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Parameter	Description
-a	Separate processors on which the application can run with commas where 1 is the lowest numbered CPU. For example, to run the application on CPU 2 and CPU 4, enter: "-a 2,4"
-c	Copy the specified executable to the remote system for execution. If you omit this option the application must be in the system path on the remote system.
-d	Don't wait for process to terminate (non-interactive).
-e	Does not load the specified account’s profile.
-f	Copy the specified program even if the file already exists on the remote system.
-i	Run the program so that it interacts with the desktop of the specified session on the remote system. If no session is specified the process runs in the console session.
-h	If the target system is Vista or higher, has the process run with the account's elevated token, if available.
-l	Run process as limited user (strips the Administrators group and allows only privileges assigned to the Users group). On Windows Vista the process runs with Low Integrity.
-n	Specifies timeout in seconds connecting to remote computers.
-p	Specifies optional password for user name. If you omit this you will be prompted to enter a hidden password.
-r	Specifies the name of the remote service to create or interact with.
-s	Run the remote process in the System account.
-u	Specifies optional user name for login to remote computer.
-v	Copy the specified file only if it has a higher version number or is newer on than the one on the remote system.
-w	Set the working directory of the process (relative to remote computer).
-x	Display the UI on the Winlogon secure desktop (local system only).
-priority	Specifies -low, -belownormal, -abovenormal, -high or -realtime to run the process at a different priority. Use -background to run at low memory and I/O priority on Vista.
computer	Direct PsExec to run the application on the remote computer or computers specified. If you omit the computer name, PsExec runs the application on the local system, and if you specify a wildcard (\\*), PsExec runs the command on all computers in the current domain.
@file	PsExec will execute the command on each of the computers listed in the file.
cmd	Name of application to execute.
arguments	Arguments to pass (note that file paths must be absolute paths on the target system).
-accepteula	This flag suppresses the display of the li
	
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PSPASSWD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PSPASSWD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Usage for local accounts:
  pspasswd [\\[computer[,computer,[,...]]|@file] [-u Username [-p Password]]] &lt;Account&gt; [NewPassword]
Usage for domain accounts:
  pspasswd &lt;Domain\Account&gt; [NewPassword]

     computer    Computer or computers on which the local account exists. If
                 you omit the computer name, the local computer is assumed.
                 If you specify a wildcard (\\*), PsPasswd runs the
                 command on all computers in the current domain or workgroup.
     @file       PsPasswd will change the password on the computers listed
                 in the file.
     -u          Specifies optional user name for login to remote computer.
     -p          Specifies optional password for user name. If you omit this
                 you will be prompted to enter a hidden password.
     -nobanner   Do not display the startup banner and copyright message.
     Domain      Specifies name of the domain of the target account.
     Account     Specifies name of the account for password change.
     NewPassword New password. If omitted a NULL password is applied.


'For a single computer:
pspasswd \\computer_name Local_administrator_account_name “New_Password” 

'For multiple computers:
pspasswd \\computer1_name,computer2_name,computer3_name Local_administrator_account_name “New_Password” 

'For all computers in the environment:
pspasswd \\* Local_administrator_account_name “New_Password” 

'For multiple computers using a text file containing the computer names:
pspasswd \\@file.txt Local_administrator_account_name “New_Password”

'Just to clarify the Sysinternal Tools attempt to use your current user profiles credentials 
'	to authenticate against the other Machines / Domain. 
'	If you are running as an admin you are fine.

'If however you are using a limited account when you open the tool 
'	you will need to specify a username and a password using the "-u" and "-p" switches. 
'	Using these DOES transmit your username and password in plain text.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>RDP_Remotely_enable_RDP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>RDP_Remotely_enable_RDP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>RDP_Remotely_enable_RDP

https://community.spiceworks.com/scripts/show/3924-remotely-enable-rdp

#'Will Remotely Enable Remote Desktop Protocol. That sounds funny, but it works.
#'
#'This script will access the Remote Registry of the target computer and enable it. 
#'    Then it will make a change to the Registry Key related to RDP, 
#'    thus allowing you to get into your target computer. It can also be run locally to set the Registry Key.
#'
#'The only problem is this sets the option in 
#'    System &gt; Advanced system settings &gt; Remote to 
#'    "Allow connections from computers running any version of Remote Desktop (less secure)". 
#'My suggestion is to set this to 
#'    "Allow connections only from computers running Remote Desktop with Network Level Authentication (more secure)" 
#'    once you have successfully remoted in to your target machine.


#------------------------------------------------------------------------------------
#\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/
#/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\
#------------------------------------------------------------------------------------
#|\--
#|-\-Author:  Chris Rakowitz
#|--\Purpose:  Enables the Remote Desktop Protocol on a Target Computer.
#|--/Date:  February 7, 2017
#|-/-Version:  1.00
#|/--
#------------------------------------------------------------------------------------
#\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/\|-|-|/
#/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\/|-|-|\
#------------------------------------------------------------------------------------

&lt;#
	.SYNOPSIS
	Enables the Remote Desktop Protocol on a target computer.
	
	.DESCRIPTION
	Remote Desktop Protocol is the Protocol used when remoting into Windows machines.
	This script will set the Registry Key that is needed to enable this functionality
	easily.
	
	This Registry Key is found at:
	HKLM:SYSTEM\CurrentControlSet\Control\Terminal Server
	Key:  fDenyTSConnections
	
	.PARAMETER $ComputerName
	Accepts a single computer name or IP Address.  Also accepts a
	comma-separated list or a path to a text file list as input.
	Leaving this parameter blank will result in the script running on
	the local machine.
	
	.EXAMPLE
	Enable-RDP.ps1
	
	Enables Windows Remote Desktop Protocol on the Local computer.
	
	.EXAMPLE
	Enable-RDP.ps1 -ComputerName TEST-1234
	
	Enables Windows Remote Desktop Protocol on the computer TEST-1234.
	
	.EXAMPLE
	Enable-RDP.ps1 -ComputerName Test-1, Test-2, Test-3
	
	Enable Windows Remote Desktop Protocol on the computers Test-1,
	Test-2 and Test-3.
	
	.EXAMPLE
	Enable-RDP.ps1 -ComputerName "C:\List\Of\My\Computers.txt"
	
	Enables Windows Remote Desktop Protocol on all the computers in the
	text file at the specified location.
	
	.NOTES
	This is required to be run as a local administrator or as a Domain
	account that has Administrator rights on the target computer or
	computers.
#&gt;

[cmdletbinding()]
param
(
	[Parameter(Mandatory=$False)] [string[]]$ComputerName = $env:computername
)
# Tell Powershell to ignore any errors that may fill up the screen.
#$ErrorActionPreference = 'silentlycontinue'

If($ComputerName -Like "*.txt")
{
	$CompList = Get-Content ([regex]::matches($ComputerName,'[^\"]+') | %{$_.value})
}
Else
{
	$CompList = $ComputerName
}

Foreach($Computer in $CompList)
{
	If(!(Test-Connection -ComputerName $Computer -TimeToLive 18 -Count 1))
	{
		Write-Host "$Computer - Offline" -Foreground red -Background black
		Write-Host ""
		continue
	}
	Else
	{
		Write-Host $Computer -Foreground green -Background black
		Write-Host ""
		
		Write-Host "Enabling Remote Desktop Protocol`n" -Foreground green -Background black
		
		# Enable the Remote Registry service on the target computer.  This allows keys to read/modified.
		Write-Host "Enabling Remote Registry Service" -Foreground yellow -Background black
		Set-Service -ComputerName $Computer -StartUpType Manual -Status Running `
			-Name RemoteRegistry -DisplayName "Remote Registry"
			
		# Access the registry and modify the Registry Key 'fDenyTSConnections' to enable RDP.
		Write-Host "`nSetting Remote Desktop Protocol Registry Key`n" -Foreground cyan -Background black
		$RegBaseKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBasekey('LocalMachine', "$Computer")
		$TSKeys = $RegBaseKey.OpenSubKey("SYSTEM\\CurrentControlSet\\Control\\Terminal Server", $True)
		$TSKeys.SetValue("fDenyTSConnections","0",[Microsoft.Win32.RegistryValueKind]::DWORD)

		# Disable the Remote Registry service.
		Write-Host "Stopping Remote Registry Service" -Foreground yellow -Background black
		(Get-Service -ComputerName $Computer -Name RemoteRegistry).stop()
		Write-Host "Disabling Remote Registry Service" -Foreground yellow -Background black
		Set-Service -ComputerName $Computer -StartUpType Disabled -Name RemoteRegistry
		Write-Host ""
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>TEST_Remote_Registry</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>TEST_Remote_Registry</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://filedb.experts-exchange.com/incoming/2015/11_w47/1030521/get-officeversion.ps1..txt
=============================================================================================
#'USAGE
$testcomputers = "LT-1039"
#'$exportLocation = 'C:\OfficeVersions.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\ONE_Computer_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\ONE_Computer_DidNotPing.txt
		}
	}

 get-officeversion -infile C:\ONE_Computer_RespondToPing.txt -outfile C:\ONE_Computer_officeversions.csv


Get-Content C:\ONE_Computer_officeversions.csv


=============================================================================================
&lt;#
.Synopsis
   Get-OfficeVersion 
.DESCRIPTION
   Gets the Office version from a list of computernames and returns a CSV of the Computername and Office Version (if available)
.EXAMPLE
 get-officeversion c:\test\servers.txt c:\test\officeversions.csv
.EXAMPLE
 get-officeversion -infile c:\test\servers.txt -outfile c:\test\officeversions.csv
.NOTES
   General notes
.PARAMETER infile
A path and a filename to a text file contains a list of the computernames or ip addresses to check the office version.
.PARAMETER Outfile
A path and filename of the output .csv file

#&gt;
function Get-OfficeVersion
{
param(
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $Infile,
    
    [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
    [string] $outfile
    )
#$outfile = 'C:\temp\office.csv'
#$infile = 'c:\temp\servers.txt'
Begin
    {
    }
 Process
    {
    $office = @()
    $computers = Get-Content $infile
    $i=0
    $count = $computers.count
    foreach($computer in $computers)
     {
     $i++
     Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
      -PercentComplete ($i/$count*100)
        $info = @{}
        $version = 0
        try{
          $reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $computer) 
          $reg.OpenSubKey('software\Microsoft\Office').GetSubKeyNames() |% {
            if ($_ -match '(\d+)\.') {
              if ([int]$matches[1] -gt $version) {
                $version = $matches[1]
              }
            }    
          }
          if ($version) {
            Write-Debug("$computer : found $version")
            switch($version) {
                "7" {$officename = 'Office 97' }
                "8" {$officename = 'Office 98' }
                "9" {$officename = 'Office 2000' }
                "10" {$officename = 'Office XP' }
                "11" {$officename = 'Office 97' }
                "12" {$officename = 'Office 2003' }
                "13" {$officename = 'Office 2007' }
                "14" {$officename = 'Office 2010' }
                "15" {$officename = 'Office 2013' }
                "16" {$officename = 'Office 2016' }
                default {$officename = 'Unknown Version'}
            }
    
          }
          }
          catch{
              $officename = 'Not Installed/Not Available/Not Answering'
          }
    $info.Computer = $computer
    $info.Name= $officename
    $info.version =  $version

    $object = new-object -TypeName PSObject -Property $info
    $office += $object
    }
    $office | select computer,version,name | Export-Csv -NoTypeInformation -Path $outfile
    }
}
  write-output ("Done")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>TEST_WhichComputers_RPCServerIsUnavailable_v1.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>TEST_WhichComputers_RPCServerIsUnavailable_v1.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'WhichComputers_RPCServerIsUnavailable_v0.ps1

$cred1 = Get-Credential  #' Run Once

$testcomputers = Get-Content -Path 'C:\DATA\2018_06_06_run_0_List_to_TEST.txt'


#'Test connection to each computer before getting the inventory info
foreach ($computer in $testcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path C:\DATA\2018_06_06_run_0_RespondToPing.txt
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path C:\DATA\2018_06_06_run_0_didNOTping.txt
		}
	}

#'=============================================================================

$servers = Get-Content  -Path 'c:\data\2018_06_06_run_0_RespondToPing.txt'
$error.Clear() 
ForEach ($server in $servers) {
  Try {

    write-host "TRY:"$server -ForegroundColor Green        
    gwmi win32_operatingsystem -computer $server -credential $cred1 -ErrorAction Stop   
    write-host "No Error:"$server -ForegroundColor Yellow  
    Add-Content -value $server -path C:\DATA\2018_06_06_run_0_WMI_is_OK.txt
    } 
  Catch {
    write-host "CATCH:"$server -ForegroundColor Red
    Add-Content -value $server -path C:\DATA\2018_06_06_run_0_RPCServerIsUnavaible.txt #'-ErrorAction Continue  
    $errorNote = $server + ", " + $Error[0].CategoryInfo.Category + ", " + $Error[0].CategoryInfo.Reason
    write-host $errorNote -ForegroundColor Red
    Add-Content -value $errorNote -path C:\DATA\2018_06_06_run_0_Errors.txt
    }
  Finally {
    $error.Clear() 
    Write-Host "errors cleared"  
    }
  }

 #' [System.Windows.MessageBox]::Show('DONE') 
 write-host "DONE!" -ForegroundColor Red



 #'gwmi win32_operatingsystem -computer LT-1036 -credential $cred1 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>TrustedHosts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>TrustedHosts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

http://windowsitpro.com/windows/modify-trustedhosts-powershell


'to set TrustedHosts to every machine in your domain namespace use:

&gt;Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value '*.savilltech.net'

'To set to have no trusted hosts use:

Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value ''

'To avoid the prompt to make the change add -Force, for example:

Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value '' -Force


'To read the list:
 &gt;ls WSMan:\localhost\Client\TrustedHosts
 'OR
 &gt;Get-WSManInstance -ResourceURI winrm/config/client | select -ExpandProperty TrustedHosts
 =================================
 Set-Item WSMan:\localhost\Client\TrustedHosts -value 192.168.1.13
#'This sets the value to 192.168.1.13, it also overwrites any existing values
  

#' If you want to set a subnet you can use the PowerShell wildcard character
Set-Item WSMan:\localhost\Client\TrustedHosts -value 192.168.1.*  
  
#' both the examples above will overwrite the current value of the trustedhosts property
#' to add to instead of overwriting you need to use the concatenate dynamic parameter available in the WSMAN provider
#' Thanks to @alexandair for that bit of info

set-item WSMan:\localhost\Client\TrustedHosts -Value "192.168.0.*" -Concatenate
 =================================
 'multiple machines
 
 'a] 
 &gt;winrm set winrm/config/client '@{TrustedHosts="machineA,machineB"}'
 'if anyone gets an Error: Invalid use of command line ... response, try removing the single quotation marks
  
 'b] 
 &gt; Set-Item WSMan:\localhost\Client\TrustedHosts -Value 'machineA,machineB'

'to append to the list, the -Concatenate parameter can be used

Set-Item WSMan:\localhost\Client\TrustedHosts -Value 'machineC' -Concatenate

'c]
PS C:\&gt; $current=(get-item WSMan:\localhost\Client\TrustedHosts).value
PS C:\&gt; $current+=",testdsk23,alpha123"
PS C:\&gt; set-item WSMan:\localhost\Client\TrustedHosts –value $current
  =================================
 
 'The function has a single parameter – the computername that defaults to the local machine.
 function get-trustedhost {

	[CmdletBinding()]
	
	param (
	
			[string]$computername = $env:COMPUTERNAME
			
			)
	
	if (Test-Connection -ComputerName $computername -Quiet -Count 1) {
	
			Get-WSManInstance -ResourceURI winrm/config/client -ComputerName $computername | select -ExpandProperty TrustedHosts
	
	}
	
	else {
	
	Write-Warning -Message “$computername is unreachable”
	
	}

}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WORKGROUP_machines</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WORKGROUP_machines</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

https://blogs.msdn.microsoft.com/wmi/2009/07/24/powershell-remoting-between-two-workgroup-machines/

The computer you’re sitting in front of is called the client machine, 
	while the computer you’re trying to remotely access is called the server machine.
	
First, configure the SERVER machine to allow access. 
---------------------------------------------------	
&gt;Enable-PSRemoting –force

If one of the network cards on your computer has the network connection type set to “Public” 
	then the required port won’t be opened in your firewall settings.
	
If you’d rather not change your network connection type, 
	you’ll have to manually configure your firewall to allow traffic through.	
	
Make sure that the password for your Administrator account is not empty!  
	If it is, you won’t be able to log in remotely.
	
Now you’ll need to configure your CLIENT machine. 
------------------------------------------------

 enable WinRM local access so that you can modify the proper settings. 
 To do this, start the WinRM service and enable the local account token filter policy 
 
 Both of the next 2 steps are unnecessary if 
 	you’ve already run the Enable-PSRemoting cmdlet on your client machine.
 
 &gt;Start-Service WinRM
 &gt;Set-ItemProperty –Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System –Name  LocalAccountTokenFilterPolicy –Value 1 –Type DWord
 
 next (on the SERVER)
 --------
 Now that WinRM local access is enabled, 
 	you’ll need to add the name of your server machine to the TrustedHosts setting in the WinRM configuration, 
 	which enables your client machine to connect to your server machine 
 	using an authentication mechanism that does not authenticate the server (like Kerberos does):

&gt;Set-Item WSMan:\localhost\Client\TrustedHosts –Value &lt;ServerMachineName&gt; -Force

This command replaces any previous value that was stored in TrustedHosts!  
	If there is an existing list of servers and you don’t want to remove then, 
	use the –Concatenate parameter:
	
&gt;Set-Item WSMan:\localhost\Client\TrustedHosts –Value &lt;ServerMachineName&gt; -Force -Concatenate

If you want to use your server machine’s IP address instead of its name, 
	you must specify explicit credentials when you connect.
	
------------------------------------------------
'From client (HOMETOWER) to server (HOME-LAPTOP)	
&gt;Test-WSMan home-laptop	
'OUTPUT
--------
#'wsmid           : http://schemas.dmtf.org/wbem/wsman/identity/1/wsmanidentity.xsd
#'ProtocolVersion : http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd
#'ProductVendor   : Microsoft Corporation
#'ProductVersion  : OS: 0.0.0 SP: 0.0 Stack: 3.0#'
#'	

'INVOKE-COMMAND works	
&gt;Invoke-Command -ComputerName home-laptop -ScriptBlock { Get-ChildItem C:\ } -credential glenn
'OUTPUT
--------
#'
#'    Directory: C:\
#'
#'
#'Mode                LastWriteTime         Length Name                                                         PSComputerName                                             
#'----                -------------         ------ ----                                                         --------------                                             
#'d-----       12/18/2016   3:20 PM                DATA                                                         home-laptop                                                
#'d-----       12/18/2016   7:58 AM                Downloads                                                    home-laptop                                                
#'d-----        4/12/2016   1:36 AM                eSupport                                                     home-laptop                                                
#'d-----        7/16/2016   6:47 AM                PerfLogs                                                     home-laptop                                                
#'d-r---        8/29/2017   9:21 AM                Program Files                                                home-laptop                                                
#'d-r---        5/13/2017   4:48 PM                Program Files (x86)                                          home-laptop                                                
#'d-r---       12/18/2016   1:13 PM                Users                                                        home-laptop                                                
#'d-----        8/29/2017   5:50 PM                Windows                                                      home-laptop                                                
#'d-----        3/31/2017   5:49 AM                Windows.old                                                  home-laptop   
	
'BUT 'Get-CimInstance' fails from the client
&gt;Get-CimInstance –ClassName Win32_ComputerSystem –Computer HOME-LAPTOP -Verbose	
' Access is denied.	

'I can enter a session on the client (i.e. HOMETOWER) to the server:
&gt;Enter-PSSession -ComputerName home-laptop -Credential glenn
'Now we are actually on the server
'Then create an option variable
[home-laptop]: &gt; $CimOption = New-CimSessionOption -Protocol Dcom
'Then enter a CIM Session locally on the Server:
[home-laptop]: PS C:\Users\glenn\Documents&gt; $CimSession = New-CimSession  -SessionOption $CimOption
'and we can confirm we are on the Server:
&gt;Get-ChildItem C:\
'it returns the contents of the Server's C Drive
	
------------------------------------------------	
To check if the WinRM service is running:
               &gt;Get-Service WinRM

To check the version of WinRM that’s installed:
               &gt;Test-WSMan –Auth default

To check the remoting configuration for PowerShell:
               &gt;Get-PSSessionConfiguration

To verify that local WinRM access is working:
               &gt;New-PSSession

To check if the local account token filter policy is enabled (on Windows Vista and Windows Server 2008):
                &gt;Get-ItemProperty –Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System –Name LocalAccountTokenFilterPolicy*

To check if the network access policy “Sharing and security model for local accounts” is set to Classic (on Windows XP):
                Get-ItemProperty –Path HKLM:\System\CurrentControlSet\Control\Lsa –Name ForceGuest*

To check the WinRM listener settings:
               &gt;winrm enumerate winrm/config/listener

For additional help and troubleshooting steps:
                Get-Help about_remote_troubleshooting</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ScheduledTask</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>BCC_Kill_all_the_EclipseApplicationProcesses_from_Users</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ScheduledTask</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>BCC_Kill_all_the_EclipseApplicationProcesses_from_Users</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$process = "pxplus.exe"

Get-WmiObject Win32_Process -Namespace "root\cimv2"  -Filter "name = '$process'"  |  Select CommandLine,ProcessID  | Where-Object {$_.CommandLine -like "*id=T*"} | Foreach-Object {Stop-Process $_.ProcessID -Force} 

#===========================================================================
# Log to the file after the script has run
#============================================================================
$path = 'C:\DATA\PowerShellScript_LOGS\Kill_All_User_Sessions_LOG.txt'
$pathTempFile = 'C:\DATA\PowerShellScript_LOGS\Kill_All_User_Sessions_LOG_TEMP.txt'
$TheDateTime = Get-Date -format yyyy_M_d_h_m_s
$text = 'Script run at: ' +  $TheDateTime

if (Test-Path $path) {
    $text | Set-Content $pathTempFile
    Get-Content $path -ReadCount 5000 |
    Add-Content $pathTempFile 
    Remove-item $path 
    Rename-Item $pathTempFile -NewName $path
} else {
   $text | Set-Content $path
} 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ScheduledTask</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Using Task Scheduler to automate PowerShell Scripts </Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ScheduledTask</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Using Task Scheduler to automate PowerShell Scripts </Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

https://support.software.dell.com/appassure/kb/144451

'EXAMPLE: for AppAssure Core

'1] Open Task Scheduler

	'Open Task Scheduler and Create a new task. Name it and set your security options.

		'GENERAL {Tag}
		--------------
			'Name: TEST_Write_Time_to_File 
			'Location: \
			'Author: BCC\glenng
			'When running the task, use the following user Account: BCC\glenng
			'(x) Run whether user is logged on or not
			'[x] Run with highest privileges
			'Configure for: Windows Server 2012 R2
			 
			 
	'Check "Run with highest privileges" as our scripts need to run as admin.  
	'If you want this script to run without your account signed into the AppAssure Core, 
	'enable the 'Run whether user is logged on or not' radio button.
'2] Set Triggers

	'Click on the Triggers tab and set your schedule or event that will trigger the running of your PowerShell script. 

		'Triggers {Tag}
		--------------
		'[New]
		' One time: xxxxx
	
	
'3] Create your Action

	'Click on the Actions tab and click on New.
	'Action: Start a program
	'Program/script: Powershell.exe
	'You don't need to put a path as it should already be on your system.
	
		'Actions {Tag}
		--------------
		'Action: Start a program
		'Program/script: Powershell.exe
		'Add arguments: C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe -NoLogo -NonInteractive -File "C:\DATA\PowerShellScripts\WriteTimeToFile.ps1"
		
		
			
	
'4] Set Argument

	'First you need to set the ExecutionPolicy. You have two options here, you can set the ExecutionPolicy on the machine or you can do it on a per-script basis. 
	'	Read the PowerShell ExecutionPolicy link below as it talks about or you can issue the command:

	Get-Help About_execution_policies

	'To set the execution policy globally, you can issue this command from within PowerShell:

	Set-ExecutionPolicy Unrestricted

	'Or use one of the other settings available depending on your environment. 
	'In the context of this how-to, however, we want to set the execution policy on a per script basis and open up security for us to run the script. 
	'This security policy will only be in effect for the script we are running and not compromise security otherwise.
	'That means we use the following Argument:

	-ExecutionPolicy Bypass -File c:\temp\agent_repl.ps1

'5] Save and Test</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Security</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Certifcates_on_Remote_Computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Security</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Certifcates_on_Remote_Computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'Maybe:
Invoke-Command -ComputerName Whatever -ScriptBlock {
    Get-ChildItem Cert:\ -Recurse |
    Where-Object { $_.Issuer -eq 'CN=DigiCert SHA2 Assured ID Code Signing CA, OU=www.digicert.com, O=DigiCert Inc, C=US' }
}


http://ilovepowershell.com/2015/03/20/looking-at-installed-certificates-with-powershell/

'To view the certificates in the local users personal certificate store I would use the following:

#Change to the location of the personal certificates
Set-Location Cert:\CurrentUser\My
 
#Change to the location of the local machine certificates
Set-Location Cert:\LocalMachine\My
 
#Get the installed certificates in that location
Get-ChildItem | Format-Table Subject, FriendlyName, Thumbprint -AutoSize
 
#Get the installed certificates from a remote machine
$Srv = "SERVER-HOSTNAME"
$Certs = Invoke-Command -Computername $Srv -Scriptblock {Get-ChildItem "Cert:\LocalMachine\My"}


------------------------------------------------


'Installed for Current user:

$certs = Get-ChildItem cert:\CurrentUser\My  -Recurse | Where-Object {-not $_.PSIsContainer} | Select *
Write-Host ("There were {0} certificates" -f ($certs | Measure-Object).Count) 
$certs | Out-File c:\certs.txt


'Installed on Local Machine:

$certs = Get-ChildItem cert:\LocalMachine\My  -Recurse | Where-Object {-not $_.PSIsContainer} | Select *
Write-Host ("There were {0} certificates" -f ($certs | Measure-Object).Count) 
$certs | Out-File c:\certs.txt

------------------------------
'List All Certificates on a Remote Computer
Get-PKICertificates -comp dc1 -StoreLocation LocalMachine -StoreName My

------------------------------

$certs = Get-ChildItem cert:\LocalMachine -Recurse |
  ? {-not $_.PSIsContainer} |
  select @{n="Name"; e={$_.GetName()}},
          @{n="Folder"; e={$_.PSParentPath.Replace("Microsoft.PowerShell.Security\Certificate::","")}},
          @{n="Expire"; e={$_.GetExpirationDateString()}} 
Write-Host ("There were {0} certificates" -f ($certs | Measure-Object).Count) 
$certs | Out-File c:\certs.txt

--------------------------------------------
'I have the following script which brings back any certificates on the local machine 
'needed for our VPN client and shows the expiry date:

$asset = $env:COMPUTERNAME

Set-Location cert:\LocalMachine\My

Write-Host = "Asset ID:"$asset

Get-ChildItem -Recurse cert: | select subject, notafter

write-host "`n"

Read-Host "Press any key to exit..."

(Get-Host).SetShouldExit(0)

-------------------------------------------------
'to invoke local command remotely
Invoke-Command -computername $asset -scriptblock {Get-ChildItem -Recurse cert: | select subject, notafter}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Select</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Select-String</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Select</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Select-String</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/select-string?view=powershell-6

=============================================================
PS C:\&gt; $F = Select-String -Path "audit.log" -Pattern "logon failed" -Context 2, 3
PS C:\&gt; $F.count
PS C:\&gt; ($F)[0].context | Format-List

#'The first command searches the Audit.Log file for the phrase "logon failed." 
#'    It uses the Context parameter to capture 2 lines before the match and 3 lines after the match.
#'The second command uses the Count property of object arrays 
#'    to display the number of matches found, in this case, 2.
#'The third command displays the lines stored in the Context property of the first MatchInfo object. 
#'    It uses array notation to indicate the first match 
#'    (match 0 in a zero-based array), 
#'    and it uses the Format-List cmdlet to display the value of the Context property as a list.
#'The output consists of two MatchInfo objects, 
#'    one for each match detected. 
#'    The context lines are stored in the Context property of the MatchInfo object.

=============================================================

Parms:

-Context
#'Captures the specified number of lines before and after the line with the match. 
#'    This allows you to view the match in context.
#'If you enter one number as the value of this parameter, 
#'    that number determines the number of lines captured before and after the match. 
#'    If you enter two numbers as the value, 
#'    the first number determines the number of lines before the match and the second number determines the number of lines after the match.
#'

-Quiet
#'Indicates that the cmdlet returns a Boolean value (True or False), instead of a MatchInfo object. 
#'The value is True if the pattern is found; otherwise, the value is False.

-SimpleMatch
#'Indicates that the cmdlet uses a simple match rather than a regular expression match. 
#'In a simple match, Select-String searches the input for the text in the Pattern parameter. 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Setup_My_Profile_on_New_Machine</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>05_PowerShellISEModule.psm1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Setup_My_Profile_on_New_Machine</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>05_PowerShellISEModule.psm1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$PSLogPath = ("{0}{1}\Documents\WindowsPowerShell\log\{2:yyyyMMdd}-{3}.log" -f $env:HOMEDRIVE, $env:HOMEPATH,  (Get-Date), $PID)
Add-Content -Value "# $(Get-Date) $env:username $env:computername" -Path $PSLogPath
Add-Content -Value "# $(Get-Location)" -Path $PSLogPath

#'-------------------------------------------------------Drives for Powershell
New-PSDrive –Name “W” –PSProvider FileSystem –Root "\\win10vm\ALL_Share" –Persist
New-PSDrive –Name “J” –PSProvider FileSystem –Root "\\jphsa.org\shared\Users\ggarson" –Persist
#'-------------------------------------------------------

function prompt
{
    $LastCmd = Get-History -Count 1
    if($LastCmd)
    {
        $lastId = $LastCmd.Id
       
        Add-Content -Value "# $($LastCmd.StartExecutionTime)" -Path $PSLogPath
        Add-Content -Value "$($LastCmd.CommandLine)" -Path $PSLogPath
        Add-Content -Value "" -Path $PSLogPath
    }

    $nextCommand = $lastId + 1
    $currentDirectory = Split-Path (Get-Location) -Leaf
    $host.UI.RawUI.WindowTitle = Get-Location
    "$nextCommand PS:$currentDirectory&gt;"
} 

Function gig-commentIt
{
 &lt;#
   .Synopsis
    This function will add a remark #' character to beginning of line
   .Description
    This function will add a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to comment out
    a section of PowerShell code. 
   .Example
    Add-RemarkedText
    adds the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ("#'" + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-commentIt

Function gig-unCommentIt
{
 &lt;#
   .Synopsis
    This function will remove a remark #' character to beginning of line
   .Description
    This function will remove a remark character #' to selected text in the ISE.
    These are comment characters, and is great when you want to clean up a 
    previously commentted out section of PowerShell code. 
   .Example
    gig-unCommentIt
    Removes the comment / remark character to beginning of each selected line 
   .Notes
    NAME:  Add-RemarkedText
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-5-18-13
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($l -replace "#'",''),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'End function gig-unCommentIt


Function gig-editProfile
{

 psedit $profile

 #'ISE $profile

} #'end function gig-editProfile

Function gig-addHelp
{
  &lt;#
   .Synopsis
    This function adds help at current insertion point 
   .Example
    add-help
    adds comment based help at current insertion point 
   .Notes
    NAME:  Add-Help
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/24/2016
    HSG: WES-09-11-10
    KEYWORDS: Scripting Techniques, Windows PowerShell ISE
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 $helpText = @"
 &lt;#
   .Synopsis
    This does that 
   .Description
    This function does
   .Example
    Example-
    Example- accomplishes 
   .Parameter 
    The parameter
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS:
    HSG: 
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
"@
 $psise.CurrentFile.Editor.InsertText($helpText)
} #'end function gig-addHelp

Function gig-addHeaderToScript
{
  &lt;#
   .Synopsis
    This function adds header information to a script 
   .Example
    Add-HeaderToScript
    Adds header comments to script 
   .Example 
    AH
    Uses alias to add header comments to script
   .Notes
    NAME:  Add-HeaderToScript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: $(Get-Date)
    KEYWORDS: $keyword
    HSG: $hsg
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($keyword, $comment, $hsg)
 $header = @"
#' -----------------------------------------------------------------------------
#' Script: $(split-path -Path $psISE.CurrentFile.FullPath -Leaf)
#' Author: glenn garson, JPHSA
#' Date: $(Get-Date)
#' Keywords: $keyword
#' comments: $comment
#'
#' -----------------------------------------------------------------------------
"@
 $psise.CurrentFile.Editor.InsertText($header)
} #'end function gig-addHeaderToScript

Function gig-getLogNameFromDate
{
  &lt;#
   .Synopsis
    Creates a log name from date
   .Description
    This script creates a log from a date. 
   .Example
    gig-getLogNameFromDate -path "c:\jumk" -name "log"
    Creates a file name like c:\JUNK\log20100914-122019.Txt but does not
    create the file. It returns the file name to calling code.
   .Example
    gig-getLogNameFromDate -path "c:\JUNK" -name "log" -Create
    Creates a file name like c:\JUNK\log20100914-122019.Txt and
    create the file. It returns the file name to calling code.
   .Parameter path
    path to log file
   .Parameter name
    base name of log file
   .Parameter create
    switch that determines whether log file or only name is created
   .inputs
    [string]
   .outputs
    [string]
   .Notes
    NAME:  gig-getLogNameFromDate
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 16:58:06
    KEYWORDS: parameter substitution, format specifier, string substitution
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param(
  [string]$path = "c:\JUNKC:\DATA\junkPowerShellTranscripts",
  [string]$name = "log",
  [switch]$Create
 )
 $logname = "{0}\{1}{2}.{3}" -f $path,$name, `
    (Get-Date -Format yyyyMMdd-HHmmss),"Txt"
 if($create) 
  { 
   New-Item -Path $logname -ItemType file -force | out-null
   $logname
  }
 else {$logname}
} #' end function gig-getLogNameFromDate

Function gig-start_ISE_Transcript
{
  &lt;#
   .Synopsis
    This captures output from a script to a created text file
    To use the gig-start_ISE_Transcript function, add the call to the function at the bottom of your script.
   .Example

    xxxxx...{your script}
    gig-start_ISE_Transcript -logname "c:\junk\log.txt"

    Copies output from script to file named xxxxlog.txt in c:\junk folder
   .Parameter logname
    the name and path of the log file.
   .inputs
    [string]
   .outputs
    [io.file]
   .Notes
    NAME:  gig-start_ISE_Transcript
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 09/10/2010 17:27:22
    KEYWORDS:
    HSG: WES-09-25-10
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
  Param(
   [string]$logname = (gig-getLogNameFromDate -path $transcriptHome -name "log" -Create)
  )
  $transcriptHeader = @"
**************************************
Windows PowerShell ISE Transcript Start
Start Time: $(get-date)
UserName: $env:username
UserDomain: $env:USERDNSDOMAIN
ComputerName: $env:COMPUTERNAME
Windows version: $((Get-WmiObject win32_operatingsystem).version)
**************************************
Transcript started. Output file is $logname
"@
 $transcriptHeader &gt;&gt; $logname
 $psISE.CurrentPowerShellTab.ConsolePane.Text &gt;&gt; $logname
 “Log saved to $logname”
} #'end function gig-start_ISE_Transcript

function gig-indentText_x_spaces
{
  &lt;#
   .Synopsis
    This function will indent text in the ISE a specific number
   .Description
    This function will indent selected text in the PowerShell ISE. These are
    real spaces, not tabs. Therefore this is appropriate for situations where
    an actual tab "`t" will not work. 
   .Example
    gig-indentText_x_spaces -space 5
    moves selected text five spaces 
   .Parameter spaces
    The number of spaces to indent the selected text. Note this number cannot
    be a negative number, and this function does not "unindent" the selected text.
   .Notes
    NAME:  gig-indentText_x_spaces
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 06/11/2012 17:16:29
    KEYWORDS: Windows PowerShell ISE, Scripting Techniques
    HSG: wes-6-17-12
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param([int]$space = 1)
 $tab = " " * $space
 $text = $psISE.CurrentFile.editor.selectedText
 foreach ($l in $text -split [environment]::newline)
  {
   $newText += "{0}{1}" -f ($tab + $l),[environment]::newline 
  }
   $psISE.CurrentFile.Editor.InsertText($newText)
} #'end function gig-indentText_x_spaces

Function gig-editModule
{
  &lt;#
   .Synopsis
    This opens a module stored in the $env:PSModulePath location on a new tab in ISE 
   .Description
    This function uses Get-Module to retrieve a module from $env:PSModulePath and then
    it opens the module from that location into a new tab in ISE for editing. Wildcard
    characters that resolve to a single module are supported.
   .Example
    gig-editModule PowerShellISEModule
    gig-editModule PowerShellISEModule opens the PowerShellISEModule into a new tab in the
    ISE for editing 
  .Example
    gig-editModule PowerShellISE*
    gig-editModule PowerShellISE* opens the PowerShellISEModule into a new tab in the
    ISE for editing by using a wild card character for the module name
   .Parameter Name
    The name of the module. Wild cards that resolve to a single module are supported
   .Notes
    NAME:  gig-editModule
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 18:14:19
    KEYWORDS: Scripting Techniques, Modules
    HSG: WES-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 2.0
 #&gt;
 Param($name)
 ISE (Get-Module -ListAvailable $name).path
} #'end function gig-editModule

Function gig-toggleOutlineView
{
  &lt;#
   .Synopsis
    This function toggles the outline view in the ISE 
   .Description
    This function toggles the outline view in the ISE. It will expand 
    or collapse all functions in the current script pane.
   .Example
    gig-toggleOutlineView
    gig-toggleOutlineView will either expand or collapse all functions 
   .Notes
    NAME:  gig-toggleOutlineView
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 05/16/2013 19:28:37
    KEYWORDS: Scripting Techniques, Modules
    HSG: wes-5-18-2013
   .Link
     Http://www.ScriptingGuys.com
 #'Requires -Version 3.0
 #&gt;
 $psise.CurrentFile.Editor.ToggleOutliningExpansion()
} #'end function gig-toggleOutlineView


#'added Functions from New-ModulesDrive.ps1
#' HSG-1-20-10
Function gig-newModuleDrives
{
&lt;#
    .SYNOPSIS
    Creates two PSDrives: myMods and sysMods
    .EXAMPLE
    gig-newModuleDrives
    Creates two PSDrives: myMods and sysMods. These correspond 
    to the users' modules folder and the system modules folder respectively. 
#&gt;
 $driveNames = "myMods","sysMods"

 For($i = 0 ; $i -le 1 ; $i++)
 {
  New-PsDrive -name $driveNames[$i] -PSProvider filesystem `
  -Root ($env:PSModulePath.split(";")[$i]) -scope Global |
  Out-Null
 } #'end For
} #'end gig-newModuleDrives

Function gig-getFileSystemDrives
{
&lt;#
    .SYNOPSIS
    Displays global PS Drives that use the Filesystem provider
    .EXAMPLE
    gig-getFileSystemDrives
    Displays global PS Drives that use the Filesystem provider
#&gt;
 Get-PSDrive -PSProvider FileSystem -scope Global
} #'end gig-getFileSystemDrives

Function gig-OpenPath
{
 &lt;#
   .Synopsis
    Opens a path in Explorer 
   .Description
    Opens a path in Explorer, default path is C:\, or the first parameter is the path
   .Example
    gig-OpenPath C:\Junk
    gig-OpenPath $moduleHome 
   .Parameter Path
    The path to open in Explorer
   .Notes
    NAME:  Example-
    AUTHOR: glenn garson, JPHSA
    LASTEDIT: 12/26/2016 17:31:28
    KEYWORDS:
    HSG: 
   .Link
     
 #'Requires -Version 2.0
 #&gt;
  Param(
  [string]$path = "C:\"
 )
 Invoke-Item -Path $path
 }


 function gig-LoadNetworkPSDrives
{
#'    net use G: "\\Jphsa.org\shared\Data" 
#'    net use H: "\\Jphsa.org\shared\Users\ggarson\" 
#'    net use I: "\\Jphsa-ebhost2\AnasaziFiles\" 
#'    net use M: "\\Jphsa.org\shared\Data\MIS\" 
#'    net use N: "\\Jphsa-ebfile01\e$\" 
#'    net use P: "\\Jphsa.org\shared\Users\ggarson\PROJECTS"


    New-PSDrive -Name "D" -PSProvider "FileSystem" -Root "\\CBTBRFS02\Credit\Credit Risk\Month-End Reports V2\SQL Queries\" -scope Global
    New-PSDrive -Name "M" -PSProvider "FileSystem" -Root "\\CBTBRFS02\Accounting\Managerial Accounting\" -scope Global
    New-PSDrive -Name "N" -PSProvider "FileSystem" -Root "\\CBTBRFS02\Credit\Credit Risk\" -scope Global
    New-PSDrive -Name "P" -PSProvider "FileSystem" -Root "\\cbt.corp.com\cbt-dfs\MyDoc\gigarson\Documents\Data\Projects\" -scope Global
    New-PSDrive -Name "N" -PSProvider "FileSystem" -Root "\\cbt.corp.com\cbt-dfs\Accounting\Managerial Accounting\CRD Reports\" -scope Global
    New-PSDrive -Name "P" -PSProvider "FileSystem" -Root "\\cbt.corp.com\cbt-dfs\MyDoc\gigarson\Documents\"-scope Global


} 
 
#' *** Alias ***
#'if(!(Test-Path alias:ah))
#' {
#'  New-Alias -Name ah -Value add-headertoscript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:abh))
#' {
#'  New-Alias -Name abh -Value Add-SBSBookHeaderToScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ahlp))
#' {
#'  New-Alias -Name ahlp -Value add-help -Description "MrEd alias" |
#'  Out-Null
#'  }
#'  if(!(Test-Path alias:ras))
#' {
#'  New-Alias -Name ras -Value Remove-AliasFromScript -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:gfsd))
#' {
#'  New-Alias -Name gfsd -Value gig-getFileSystemDrives -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:cs))
#' {
#'  New-Alias -Name cs -value Copy-ScriptToNewTab -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:ar))
#' {
#'  New-Alias -Name ar -value Add-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:rr))
#' {
#'  New-Alias -Name rr -value Remove-RemarkedText -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:em))
#' {
#'  New-Alias -Name em -value Edit-Module -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:iem))
#' {
#'  New-Alias -Name iem -value Import-EveryModule -Description "MrEd alias" |
#'  Out-Null
#'  }
#'if(!(Test-Path alias:sov))
#' {
#'  New-Alias -Name sov -value gig-toggleOutlineView -Description "MrEd alias" |
#'  Out-Null
#'  }



#' *** Variables ***
if(!(Test-Path variable:moduleHome))
{
 new-variable -name moduleHome -value "$env:userProfile\documents\WindowsPowerShell\Modules"
}
#'if(!(Test-Path variable:backupHome))
#'{
#' new-variable -name backupHome -value "$env:userProfile\documents\WindowsPowerShell\profileBackup"
#'}

if(!(Test-Path variable:TranscriptHome))
{
 new-variable -name TranscriptHome -value "C:\DATA\junkPowerShellTranscripts"
 #' new-variable -name TranscriptHome -value "$env:userProfile\documents\WindowsPowerShell\transcript"
}

if(!(Test-Path variable:myScripts))
{
 new-variable -name myScripts -value "C:\DATA\PowerShellScripts"
}

Set-Location $myScripts

Clear-Host

gig-LoadNetworkPSDrives

Export-ModuleMember -alias * -function * -variable *

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SQL</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Submit_Queries_from_AdventureWorks database</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SQL</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Submit_Queries_from_AdventureWorks database</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>## Get ProductIDs from AdventureWorks database
$sqlconnection = New-Object System.Data.SqlClient.SqlConnection
$sqlconnection.ConnectionString = "Data Source=PLURALSIGHT\SQL2014;Initial Catalog=AdventureWorks2014;User Id=aw_webuser;Password=12345;Application Name=AdventureWorks Online Ordering;Workstation ID=AWWEB01";
$sqlconnection.Open();

$productIDs = New-Object System.Collections.Generic.List``1[System.Int32]

$sqlcmd = $sqlconnection.CreateCommand();
$sqlcmd.CommandText = "SELECT ProductID FROM Production.Product;";
$dr = $sqlcmd.ExecuteReader();

while($dr.Read())
{
      $productIDs.Add($dr[0]);
}

$sqlconnection.Close();


## Get Names from AdventureWorks database
$Names = New-Object System.Collections.Generic.List``1[System.String]

$sqlconnection = New-Object System.Data.SqlClient.SqlConnection
$sqlconnection.ConnectionString = "Data Source=PLURALSIGHT\SQL2014;Initial Catalog=AdventureWorks2014;User Id=aw_webuser;Password=12345;Application Name=AdventureWorks Online Ordering;Workstation ID=AWWEB01";
$sqlconnection.Open();

$sqlcmd = $sqlconnection.CreateCommand();
$sqlcmd.CommandText = "SELECT FirstName +'|'+LastName FROM Person.Person;";
$dr = $sqlcmd.ExecuteReader();

while($dr.Read())
{
      $Names.Add($dr.GetString(0));
}

$sqlconnection.Close();


#Set the server to script from 
$ServerName = ".";

$Queries = Get-Content -Delimiter "------" -Path "C:\Pluralsight\XE\AdventureWorks BOL Workload.sql"



WHILE(1 -eq 1)
{
      $rem = $null
      $inputint = Get-Random;
      [Void][Math]::DivRem($inputint, 2, [ref]$rem);
      
      if($rem -eq 0)
      {
      
            $ProductID = Get-Random -InputObject $productIDs;

            $query = [String]::Format("SELECT [t].[TransactionID], [t].[TransactionDate], [p].[ProductID], [p].[Name]
            FROM [Production].[TransactionHistory] [t]
          JOIN [Production].[Product] [p] ON [t].ProductID = [p].ProductID
      WHERE [p].[ProductID]= {0};", $ProductID);

            #Get a server object which corresponds to the default instance 
            
            $sqlconnection = New-Object System.Data.SqlClient.SqlConnection
            $sqlconnection.ConnectionString = "Data Source=PLURALSIGHT\SQL2014;Initial Catalog=AdventureWorks2014;User Id=aw_webuser;Password=12345;Application Name=AdventureWorks Online Ordering;Workstation ID=AWWEB01";
            $sqlconnection.Open();
            
            $sqlcmd = $sqlconnection.CreateCommand();
            $sqlcmd.CommandText = $query 
            
            $sqlcmd.ExecuteNonQuery();
            
            $sqlconnection.Close();
            
            Start-Sleep -Milliseconds 100 
      }
      else
      {
            $name = Get-Random -InputObject $Names;
            $firstname = $Name.Split('|')[0];
            $lastname = $Name.Split('|')[0];
            
            
            $query = [String]::Format("SELECT [c].[CustomerID], [c].[AccountNumber], [p].[FirstName], [p].[LastName], [a].[AddressLine1], [a].[City] 
FROM [Person].[Person] [p]
    JOIN [Sales].[Customer] [c] ON [p].[BusinessEntityID] = [c].[PersonID]
    JOIN [Person].[BusinessEntityAddress] [ba] ON [ba].BusinessEntityID = [c].PersonID
    JOIN [Person].[Address] [a] ON [a].AddressID = [ba].AddressID
    WHERE [p].[FirstName] = '{0}' AND [p].[LastName] = '{1}';", $firstname, $lastname);

            #Get a server object which corresponds to the default instance 
            
            $sqlconnection = New-Object System.Data.SqlClient.SqlConnection
            $sqlconnection.ConnectionString = "Data Source=PLURALSIGHT\SQL2014;Initial Catalog=AdventureWorks2014;User Id=aw_webuser;Password=12345;Application Name=AdventureWorks Online Ordering;Workstation ID=AWWEB01";
            $sqlconnection.Open();
            
            $sqlcmd = $sqlconnection.CreateCommand();
            $sqlcmd.CommandText = $query 
            
            $sqlcmd.ExecuteNonQuery();
            
            $sqlconnection.Close();
            
            Start-Sleep -Milliseconds 1       
      }
      
}

# Set-executionpolicy unrestricted
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SSRS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>List_or_Delete_Datasources_With_No_Dependencies</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SSRS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>List_or_Delete_Datasources_With_No_Dependencies</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>    #************************************************************************************************************************************
# FileName:     Delete-DataSources.ps1
# Date:         2015/04/23
# Author:       Hugh Scott
#
# Description:
# This script finds data sources with no dependencies in SSRS and removes them.
#
# Parameters:
#   $serverBase     - base URL for the server to check (ie, myserver.mydomain.com)
#   [$WhatIf]       - Option wwitch parameter to prevent actual deleting of objects (will list out reports that need to be deleted)
#***********************************************************************************************************************************
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$true,Position=0)]
    [string]$serverBase,
    [Parameter(Mandatory=$false,Position=1)]
    [switch]$WhatIf
)

$url = "http://$serverBase/reportserver/ReportService2010.asmx?WSDL"
$ssrs = New-WebServiceProxy -uri $url -UseDefaultCredential -Namespace "ReportingWebService"

$outFile = ".\DeleteItems_$serverBase.txt"

# Connection to Web Service, grab all data sources
$items = $ssrs.ListChildren("/", $true) | where-object {$_.typename -eq "DataSource"}
foreach($item in $items) {

    $dependencies = $ssrs.ListDependentItems($item.Path)
    $dependentReports = $dependencies.Count

    if($dependencies.Count -eq 0){
        [string]$itemName = $item.Path
        if($WhatIf){

            Write-Host "Item $itemName would be deleted."
            Add-Content $outFile "Item $itemName would be deleted."
        } else {
            try {
                $ssrs.DeleteItem($item.Path)
                Write-Host "Item $itemName deleted."
                Add-Content $outFile "Deleted item $itemName ."
            } catch [System.Exception] {
                $Msg = $_.Exception.Message
                Write-Host $itemName $Msg
                Add-Content $itemName $msg
            }
        }
    }
}
shareeditflag</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_AdAccountManagementAutomator.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_AdAccountManagementAutomator.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function New-EmployeeOnboardUser {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to perform all routine
		tasks that must be done when onboarding a new employee user account.
	.EXAMPLE
		PS&gt; New-EmployeeOnboardUser -FirstName 'adam' -MiddleInitial D -LastName Bertram -Title 'Dr. Awesome'
	
		This example creates an AD username based on company standards into a company-standard OU and adds the user
		into the company-standard main user group.
	.PARAMETER FirstName
	 	The first name of the employee
	.PARAMETER MiddleInitial
		The middle initial of the employee
	.PARAMETER LastName
		The last name of the employee
	.PARAMETER Title
		The current job title of the employee
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Firstname,
		[string]$MiddleInitial,
		[string]$LastName,
		[string]$Location = 'OU=Corporate Users',
		[string]$Title
	)
	process {
		## Not the best use of storing the password clear text
		## Google/Bing on using stored secure strings on the file system as a way to get around this
		$DefaultPassword = 'p@$$w0rd12'
		$DomainDn = (Get-AdDomain).DistinguishedName
		$DefaultGroup = 'Gigantic Corporation Inter-Intra Synergy Group'
			
		$Username = "$($FirstName.SubString(0, 1))$LastName"
		## Check if an existing user already has the first intial/last name username taken
		try {
            if (Get-ADUser $Username) {
				## If so, check to see if the first initial/middle initial/last name is taken.
				$Username = "$($FirstName.SubString(0, 1))$MiddleInitial$LastName"
				if (Get-AdUser $Username) {
					throw "No acceptable username schema could be created"
				}
			}
		} catch {
            Write-Error $_.Exception.Message
        }
		$NewUserParams = @{
            'UserPrincipalName' = $Username
            'Name' = $Username
            'GivenName' = $FirstName
            'Surname' = $LastName
            'Title' = $Title
            'SamAccountName' = $Username
            'AccountPassword' = (ConvertTo-SecureString $DefaultPassword -AsPlainText -Force)
            'Enabled' = $true
            'Initials' = $MiddleInitial
            'Path' = "$Location,$DomainDn"
            'ChangePasswordAtLogon' = $true
        }
			
		New-AdUser @NewUserParams
		Add-ADGroupMember $Username $DefaultGroup
        $Username
	}
}

function Set-MyAdUser {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to modify
		one or more Active Directory attributes on a single Active Directory user account.
	.EXAMPLE
		PS&gt; Set-MyAdUser -Username adam -Attributes @{'givenName' = 'bob'; 'DisplayName' = 'bobby bertram'; 'Title' = 'manager'}
	
		This example changes the givenName to bob, the display name to 'bobby bertram' and the title to 'manager' for the username 'adam'
	.PARAMETER Username
	 	An Active Directory username to modify
	.PARAMETER Attributes
		A hashtable with keys as Set-AdUser parameter values and values as Set-AdUser parameter argument values
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Username,
		[hashtable]$Attributes
	)
	process {
		try {
			## Attempt to find the username
			$UserAccount = Get-AdUser -Identity $Username
			if (!$UserAccount) {
				## If the username isn't found throw an error and exit
				#Write-Error "The username '$Username' does not exist"
				throw "The username '$Username' does not exist"
			}
			
			## The $Attributes parameter will contain only the parameters for the Set-AdUser cmdlet other than
			## Password.  If this is in $Attributes it needs to be treated differently.
			if ($Attributes.ContainsKey('Password')) {
				$UserAccount | Set-ADAccountPassword -Reset -NewPassword (ConvertTo-SecureString -AsPlainText $Attributes.Password -Force)
				## Remove the password key because we'll be passing this hashtable directly to Set-AdUser later
				$Attributes.Remove('Password')
			}
			
			$UserAccount | Set-AdUser @Attributes
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}

function Set-MyAdComputer {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to modify
		one or more Active Directory attributes on a single Active Directory computer account.
	.EXAMPLE
		PS&gt; Set-MyAdComputer -Computername adampc -Attributes @{'Location' = 'Phoenix'; 'Description' = 'is a little problematic'}
	
		This example changes the location to Phoenix and the description of the AD computer adampc to 'is a little problematic'
	.PARAMETER Computername
	 	An Active Directory computer account to modify
	.PARAMETER Attributes
		A hashtable with keys as Set-AdComputer parameter values and values as Set-AdComputer parameter argument values
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Computername,
		[hashtable]$Attributes
	)
	process {
		try {
			## Attempt to find the Computername
			$Computer = Get-AdComputer -Identity $Computername
			if (!$Computer) {
				## If the Computername isn't found throw an error and exit
				#Write-Error "The Computername '$Computername' does not exist"
				throw "The Computername '$Computername' does not exist"
			}
			
			## The $Attributes parameter will contain only the parameters for the Set-AdComputer cmdlet
			$Computer | Set-AdComputer @Attributes
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}

function New-EmployeeOnboardComputer {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to perform all routine
		tasks that must be done when onboarding a new AD computer account.
	.EXAMPLE
		PS&gt; New-EmployeeOnboardComputer -FirstName 'adam' -MiddleInitial D -LastName Bertram -Title 'Dr. Awesome'
	
		This example creates an AD username based on company standards into a company-standard OU and adds the user
		into the company-standard main user group.
	.PARAMETER Computername
	 	The name of the computer to create in AD
	.PARAMETER Location
		The AD distinguishedname of the OU that the computer account will be created in
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Computername,
		[string]$Location
	)
	process {
		try {
			if (Get-AdComputer $Computername) {
				#Write-Error "The computer name '$Computername' already exists"
				throw "The computer name '$Computername' already exists"
			}
			
			$DomainDn = (Get-AdDomain).DistinguishedName
			$DefaultOuPath = "$Location,$DomainDn"
			
			New-ADComputer -Name $Computername -Path $DefaultOuPath
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_CsvImportExample.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PowerShell_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_CsvImportExample.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>. C:\AdAccountManagementAutomator.ps1          #' &lt;=== dot source the file with all four functions in it.

$Employees = Import-Csv -Path C:\Users.csv     #' &lt;=== Import the CSV file
foreach ($Employee in $Employees) {            #' &lt;=== For each record in the CSV file
    ## Create the AD user accounts
    $NewUserParams = @{                         #' &lt;=== Populate a HashTable from
				        'FirstName' = $Employee.FirstName
				        'MiddleInitial' = $Employee.MiddleInitial
				        'LastName' = $Employee.LastName
				        'Title' = $Employee.Title
                      }
    if (!$Employee.Location) {                         #'&lt;== If the Location field is NOT populated, populate the field in $NewUserParams with a NULL
        						$NewUserParams.Location = $null 
    						 } 
    else { 
        	$NewUserParams.Location = $Employee.Location   #'&lt;== If the Location field is populated, that use it to populate the $NewUserParams
    	 }
    ## Grab the username created to use for Set-MyAdUser
    $Username = New-EmployeeOnboardUser @NewUserParams

    ## Create the employee's AD computer account
    New-EmployeeOnboardComputer -Computername $Employee.Computername

    ## Set the description for the employee's computer account
    Set-MyAdComputer -Computername $Employee.Computername -Attributes @{'Description' = "$($Employee.FirstName) $($Employee.LastName)'s computer" }

    ## Set the dept the employee is in
    Set-MyAdUser -Username $Username -Attributes @{'Department' = $Employee.Department}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>02_Get-InterestingEventsWithinTimeframe.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>02_Get-InterestingEventsWithinTimeframe.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' This one puts it all together, and has a validation script block BEFORE it runs

&lt;#
.SYNOPSIS
    This script finds all Windows events in all event logs and all log files on a local or remote machine
    recorded within a specific timeframe		
.EXAMPLE
	PS&gt; Get-InterestingEventsWithinTimeframe.ps1 -Computername MYCOMPUTER -StartTimestamp '04-15-15 04:00' -EndTimestamp '04-15-15 08:00' -LogFileExtension 'log'

    This example finds all events and .log files on all drives on the remote computer MYCOMPUTER from April 15th, 2015 at 4AM to April 15th, 2015 at 8AM.
.PARAMETER Computername
    The computer name you'd like to search for text and event logs on.  This defaults to localhost.
.PARAMETER StartTimestamp
    The earliest last write time of a log file and earliest time generated on an event you'd like to find
.PARAMETER EndTimestamp
    The latest last write time of a log file and latest time generated on an event you'd like to find
.PARAMETER LogFileExtension
    When searching log files, this is file extension you will be limiting your search to. This defaults to 'log'
#&gt;
[CmdletBinding()]
param ( #' This 'ValidateScript' tests the assumption that the computer is on-line, the script block returns true if the computer is on, and false if not
    [ValidateScript({Test-Connection -ComputerName $_ -Quiet -Count 1})]     #' The "$_" represents the parameter argument that will be passed to it.
    [string]$Computername = 'localhost',
    [Parameter(Mandatory)]
    [datetime]$StartTimestamp,
    [Parameter(Mandatory)]
    [datetime]$EndTimestamp,
    [string]$LogFileExtension = 'log'
)
begin {                           #' The 'begin' block is where you place code that you want to run only once, regardless if whether the script is used in a pipeline or not
                                  #' This is also a place where you can put functions that will be used in the 'process' block
    . C:\LogInvestigator.ps1
}
process {
	try {
        #' Parameter Hash table
        $Params = @{
            'Computername' = $Computername
            'StartTimestamp' = $StartTimestamp
            'EndTimestamp' = $EndTimestamp
        }
        Get-WinEventWithin @Params
	    Get-TextLogEventWithin @Params -LogFileExtension $LogFileExtension
	} catch {
		Write-Error "$($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>02_LogInvestigator.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>02_LogInvestigator.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' This holds two functions, but more could be added


function Get-WinEventWithin {
	&lt;#
	.SYNOPSIS
	    This function finds all events in all event logs on a local or remote computer between a start and end time	
	.EXAMPLE
		PS&gt; Get-WinEventWithin -StartTimestamp '04-15-15 04:00' -EndTimestamp '04-15-15 08:00'

        This example finds all events in all event logs from April 15th, 2015 at 4AM to April 15th, 2015 at 8AM.
	.PARAMETER Computername
        The computer in which you'd like to find event log entries on.  If this is not specified, it will default to localhost.
	.PARAMETER StartTimestamp
        The earlier time of the event you'd like to find an event 
	.PARAMETER EndTimestamp
        The latest time of the event you'd like to find 
	#&gt;
	[CmdletBinding()]
	param (
        [string]$Computername = 'localhost',
        [Parameter(Mandatory)]
        [datetime]$StartTimestamp,
        [Parameter(Mandatory)]
        [datetime]$EndTimestamp
	)
	process {
		try {
            $Logs = (Get-WinEvent -ListLog * -ComputerName $ComputerName | where { $_.RecordCount }).LogName
            $FilterTable = @{
	            'StartTime' = $StartTimestamp
	            'EndTime' = $EndTimestamp
	            'LogName' = $Logs
            }
		
            Get-WinEvent -ComputerName $ComputerName -FilterHashtable $FilterTable -ErrorAction 'SilentlyContinue'
		} catch {
			Write-Error "$($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
		}
	}
}

function Get-TextLogEventWithin {
	&lt;#
	.SYNOPSIS
	    This function finds all files matching a specified file extension that have a last write time
        between a specific start and end time.
	.EXAMPLE
		PS&gt; Get-TextLogEventWithin -Computername MYCOMPUTER -StartTimestamp '04-15-15 04:00' -EndTimestamp '04-15-15 08:00' -LogFileExtension 'log'

        This example finds all .log files on all drives on the remote computer MYCOMPUTER from April 15th, 2015 at 4AM to April 15th, 2015 at 8AM.
	.PARAMETER Computername
        The computer name you'd like to search for text log on.  This defaults to localhost.
	.PARAMETER StartTimestamp
        The earliest last write time of a log file you'd like to find
	.PARAMETER EndTimestamp
        The latest last write time of a log file you'd like to find
    .PARAMETER LogFileExtension
        The file extension you will be limiting your search to. This defaults to 'log'
	#&gt;
	[CmdletBinding()]
	param (
        [ValidateScript({Test-Connection -ComputerName $_ -Quiet -Count 1})]
        [string]$Computername = 'localhost',
        [Parameter(Mandatory)]
        [datetime]$StartTimestamp,
        [Parameter(Mandatory)]
        [datetime]$EndTimestamp,
        [ValidateSet('txt','log')]
        [string]$LogFileExtension = 'log'
	)
	process {
		try {
            ## Define the drives to look for log files if local or the shares to look for when remote
            if ($ComputerName -eq 'localhost') {
                $Locations = (Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType = '3'").DeviceID
            } else {
                ## Enumerate all shares
                $Shares = Get-CimInstance -ComputerName $ComputerName -Class Win32_Share | where { $_.Path -match '^\w{1}:\\$' }
                [System.Collections.ArrayList]$Locations = @()
                foreach ($Share in $Shares) {
	                $Share = "\\$ComputerName\$($Share.Name)"
	                if (!(Test-Path $Share)) {
		                Write-Warning "Unable to access the '$Share' share on '$Computername'"
	                } else {
		                $Locations.Add($Share) | Out-Null	
	                }
                }
            }

            ## Build the hashtable to perform splatting on Get-ChildItem
            $GciParams = @{
	            Path = $Locations
                Filter = "*.$LogFileExtension"
	            Recurse = $true
	            Force = $true
	            ErrorAction = 'SilentlyContinue'
	            File = $true
            }

            ## Build the Where-Object scriptblock on a separate line due to it's length
            $WhereFilter = {($_.LastWriteTime -ge $StartTimestamp) -and ($_.LastWriteTime -le $EndTimestamp) -and ($_.Length -ne 0)}

            ## Find all interesting log files
    Get-ChildItem @GciParams | Where-Object $WhereFilter
		} catch {
			Write-Error "$($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
		}
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_on_Client</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-ClientWSUSSetting.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_on_Client</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-ClientWSUSSetting.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get-ClientWSUSSetting.ps1
------------------------------


Function Get-ClientWSUSSetting {
    &lt;#  
    .SYNOPSIS  
        Retrieves the wsus client settings on a local or remove system.

    .DESCRIPTION
        Retrieves the wsus client settings on a local or remove system.
         
    .PARAMETER Computername
        Name of computer to connect to. Can be a collection of computers.

    .PARAMETER ShowEnvironment
        Display only the Environment settings.

    .PARAMETER ShowConfiguration
        Display only the Configuration settings.

    .NOTES  
        Name: Get-WSUSClient
        Author: Boe Prox
        DateCreated: 02DEC2011 
               
    .LINK  
        https://learn-powershell.net
        
    .EXAMPLE
    Get-ClientWSUSSetting -Computername TestServer
    
    RescheduleWaitTime            : NA
    AutoInstallMinorUpdates       : NA
    TargetGroupEnabled            : NA
    ScheduledInstallDay           : NA
    DetectionFrequencyEnabled     : 1
    WUServer                      : http://wsus.com
    Computername                  : TestServer
    RebootWarningTimeoutEnabled   : NA
    ElevateNonAdmins              : NA
    ScheduledInstallTime          : NA
    RebootRelaunchTimeout         : 10
    ScheduleInstallDay            : NA
    RescheduleWaitTimeEnabled     : NA
    DisableWindowsUpdateAccess    : NA
    AUOptions                     : 3
    DetectionFrequency            : 4
    RebootWarningTimeout          : NA
    ScheduleInstallTime           : NA
    WUStatusServer                : http://wsus.com
    TargetGroup                   : NA
    RebootRelaunchTimeoutEnabled  : 1
    UseWUServer                   : 1
    NoAutoRebootWithLoggedOnUsers : 1

    Description
    -----------
    Displays both Environment and Configuration settings for TestServer
    
    .EXAMPLE
    Get-ClientWSUSSetting -Computername Server1 -ShowEnvironment
    
    Computername               : Server1
    TargetGroupEnabled         : NA
    TargetGroup                : NA
    WUStatusServer             : http://wsus.com
    WUServer                   : http://wsus.com
    DisableWindowsUpdateAccess : 1
    ElevateNonAdmins           : 0
    
    Description
    -----------
    Displays the Environment settings for Server1
    
    .Example
    Get-ClientWSUSSetting -Computername Server1 -ShowConfiguration
    
    ScheduledInstallTime          : NA
    AutoInstallMinorUpdates       : 0
    ScheduledInstallDay           : NA
    Computername                  : Server1
    RebootWarningTimeoutEnabled   : NA
    RebootWarningTimeout          : NA
    NoAUAsDefaultShutdownOption   : NA
    RebootRelaunchTimeout         : NA
    DetectionFrequency            : 4
    ScheduleInstallDay            : NA
    RescheduleWaitTime            : NA
    RescheduleWaitTimeEnabled     : 0
    AUOptions                     : 3
    NoAutoRebootWithLoggedOnUsers : 1
    DetectionFrequencyEnabled     : 1
    ScheduleInstallTime           : NA
    NoAUShutdownOption            : NA
    RebootRelaunchTimeoutEnabled  : NA
    UseWUServer                   : 1
    IncludeRecommendedUpdates     : NA  
    
    Description
    -----------
    Displays the Configuration settings for Server1
    #&gt;
    [cmdletbinding()]
    Param (
        [parameter(ValueFromPipeLine = $True)]
        [string[]]$Computername = $Env:Computername,
        [parameter()]
        [switch]$ShowEnvironment,
        [parameter()]
        [switch]$ShowConfiguration        
    )
    Begin {
        $EnvKeys = "WUServer","WUStatusServer","ElevateNonAdmins","TargetGroupEnabled","TargetGroup","DisableWindowsUpdateAccess"
        $ConfigKeys = "AUOptions","AutoInstallMinorUpdates","DetectionFrequency","DetectionFrequencyEnabled","NoAutoRebootWithLoggedOnUsers",
        "NoAutoUpdate","RebootRelaunchTimeout","RebootRelaunchTimeoutEnabled","RebootWarningTimeout","RebootWarningTimeoutEnabled","RescheduleWaitTime","RescheduleWaitTimeEnabled",
        "ScheduleInstallDay","ScheduleInstallTime","UseWUServer"
    }
    Process {
        $PSBoundParameters.GetEnumerator() | ForEach {
            Write-Verbose ("{0}" -f $_)
        }
        ForEach ($Computer in $Computername) {
                If (Test-Connection -ComputerName $Computer -Count 1 -Quiet) {
                $WSUSEnvhash = @{}
                $WSUSConfigHash = @{}
                $ServerReg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey("LocalMachine",$Computer)
                #Get WSUS Client Environment Options
                $WSUSEnv = $ServerReg.OpenSubKey('Software\Policies\Microsoft\Windows\WindowsUpdate')
                $subkeys = @($WSUSEnv.GetValueNames())
                $NoData = @(Compare-Object -ReferenceObject $EnvKeys -DifferenceObject $subkeys | Select -ExpandProperty InputObject)
                ForEach ($item in $NoData) {
                    $WSUSEnvhash[$item] = 'NA'
                }
                $Data = @(Compare-Object -ReferenceObject $EnvKeys -DifferenceObject $subkeys -IncludeEqual -ExcludeDifferent | Select -ExpandProperty InputObject)
                ForEach ($key in $Data) {
                    If ($key -eq 'WUServer') {
                        $WSUSEnvhash['WUServer'] = $WSUSEnv.GetValue('WUServer')
                    }
                    If ($key -eq 'WUStatusServer') {
                        $WSUSEnvhash['WUStatusServer'] = $WSUSEnv.GetValue('WUStatusServer')
                    }
                    If ($key -eq 'ElevateNonAdmins') {
                        $WSUSEnvhash['ElevateNonAdmins'] = $WSUSEnv.GetValue('ElevateNonAdmins')
                    }
                    If ($key -eq 'TargetGroupEnabled') {
                        $WSUSEnvhash['TargetGroupEnabled'] = $WSUSEnv.GetValue('TargetGroupEnabled')
                    }
                    If ($key -eq 'TargetGroup') {
                        $WSUSEnvhash['TargetGroup'] = $WSUSEnv.GetValue('TargetGroup')
                    }  
                    If ($key -eq 'DisableWindowsUpdateAccess') {
                        $WSUSEnvhash['DisableWindowsUpdateAccess'] = $WSUSEnv.GetValue('DisableWindowsUpdateAccess')
                    }              
                }
                #Get WSUS Client Configuration Options
                $WSUSConfig = $ServerReg.OpenSubKey('Software\Policies\Microsoft\Windows\WindowsUpdate\AU')
                $subkeys = @($WSUSConfig.GetValueNames())
                $NoData = @(Compare-Object -ReferenceObject $ConfigKeys -DifferenceObject $subkeys | Select -ExpandProperty InputObject)
                ForEach ($item in $NoData) {
                    $WSUSConfighash[$item] = 'NA'
                }            
                $Data = @(Compare-Object -ReferenceObject $ConfigKeys -DifferenceObject $subkeys -IncludeEqual -ExcludeDifferent | Select -ExpandProperty InputObject)
                ForEach ($key in $Data) {
                    If ($key -eq 'AUOptions') {
                        $WSUSConfighash['AUOptions'] = $WSUSConfig.GetValue('AUOptions')
                    }
                    If ($key -eq 'AutoInstallMinorUpdates') {
                        $WSUSConfighash['AutoInstallMinorUpdates'] = $WSUSConfig.GetValue('AutoInstallMinorUpdates')
                    }
                    If ($key -eq 'DetectionFrequency') {
                        $WSUSConfighash['DetectionFrequency'] = $WSUSConfig.GetValue('DetectionFrequency')
                    }
                    If ($key -eq 'DetectionFrequencyEnabled') {
                        $WSUSConfighash['DetectionFrequencyEnabled'] = $WSUSConfig.GetValue('DetectionFrequencyEnabled')
                    }
                    If ($key -eq 'NoAutoRebootWithLoggedOnUsers') {
                        $WSUSConfighash['NoAutoRebootWithLoggedOnUsers'] = $WSUSConfig.GetValue('NoAutoRebootWithLoggedOnUsers')
                    }
                    If ($key -eq 'RebootRelaunchTimeout') {
                        $WSUSConfighash['RebootRelaunchTimeout'] = $WSUSConfig.GetValue('RebootRelaunchTimeout')
                    }
                    If ($key -eq 'RebootRelaunchTimeoutEnabled') {
                        $WSUSConfighash['RebootRelaunchTimeoutEnabled'] = $WSUSConfig.GetValue('RebootRelaunchTimeoutEnabled')
                    }
                    If ($key -eq 'RebootWarningTimeout') {
                        $WSUSConfighash['RebootWarningTimeout'] = $WSUSConfig.GetValue('RebootWarningTimeout')
                    }
                    If ($key -eq 'RebootWarningTimeoutEnabled') {
                        $WSUSConfighash['RebootWarningTimeoutEnabled'] = $WSUSConfig.GetValue('RebootWarningTimeoutEnabled')
                    }
                    If ($key -eq 'RescheduleWaitTime') {
                        $WSUSConfighash['RescheduleWaitTime'] = $WSUSConfig.GetValue('RescheduleWaitTime')
                    }                                                                                                            
                    If ($key -eq 'RescheduleWaitTimeEnabled') {
                        $WSUSConfighash['RescheduleWaitTimeEnabled'] = $WSUSConfig.GetValue('RescheduleWaitTimeEnabled')
                    }  
                    If ($key -eq 'ScheduleInstallDay') {
                        $WSUSConfighash['ScheduleInstallDay'] = $WSUSConfig.GetValue('ScheduleInstallDay')
                    }  
                    If ($key -eq 'ScheduleInstallTime') {
                        $WSUSConfighash['ScheduleInstallTime'] = $WSUSConfig.GetValue('ScheduleInstallTime')
                    }  
                    If ($key -eq 'UseWUServer') {
                        $WSUSConfighash['UseWUServer'] = $WSUSConfig.GetValue('UseWUServer')
                    }                                          
                }
                
                #Display Output
                If ((-Not ($PSBoundParameters['ShowEnvironment'] -OR $PSBoundParameters['ShowConfiguration'])) -OR `
                ($PSBoundParameters['ShowEnvironment'] -AND $PSBoundParameters['ShowConfiguration'])) {
                    Write-Verbose "Displaying everything"
                    $WSUSHash = ($WSUSEnvHash + $WSUSConfigHash)
                    $WSUSHash['Computername'] = $Computer
                    New-Object PSObject -Property $WSUSHash
                } Else {
                    If ($PSBoundParameters['ShowEnvironment']) {
                        Write-Verbose "Displaying environment settings"
                        $WSUSEnvHash['Computername'] = $Computer
                        New-Object PSObject -Property $WSUSEnvhash
                    }
                    If ($PSBoundParameters['ShowConfiguration']) {
                        Write-Verbose "Displaying Configuration settings"
                        $WSUSConfigHash['Computername'] = $Computer
                        New-Object PSObject -Property $WSUSConfigHash
                    }
                }
            } Else {
                Write-Warning ("{0}: Unable to connect!" -f $Computer)
            }
        }
    }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_on_Client</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Reset-WindowsUpdate.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_on_Client</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Reset-WindowsUpdate.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'Reset-WindowsUpdate.ps1
'https://gallery.technet.microsoft.com/scriptcenter/Reset-WindowsUpdateps1-e0c5eb78

'This script will completely reset the Windows Update client settings. 
'It has been tested on Windows 7, 8, 10, and Server 2012 R2. 
'It will configure the services and registry keys related to Windows Update for default settings. 
'It will also clean up files related to Windows Upda


&lt;#
.SYNOPSIS
Reset-WindowsUpdate.ps1 - Resets the Windows Update components

.DESCRIPTION 
This script will reset all of the Windows Updates components to DEFAULT SETTINGS.

.OUTPUTS
Results are printed to the console. Future releases will support outputting to a log file. 

.NOTES
Written by: Ryan Nemeth

Find me on:

* My Blog:	http://www.geekyryan.com
* Twitter:	https://twitter.com/geeky_ryan
* LinkedIn:	https://www.linkedin.com/in/ryan-nemeth-b0b1504b/
* Github:	https://github.com/rnemeth90
* TechNet:  https://social.technet.microsoft.com/profile/ryan%20nemeth/

Change Log
V1.00, 05/21/2015 - Initial version
V1.10, 09/22/2016 - Fixed bug with call to sc.exe
V1.20, 11/13/2017 - Fixed environment variables
#&gt;


$arch = Get-WMIObject -Class Win32_Processor -ComputerName LocalHost | Select-Object AddressWidth

Write-Host "1. Stopping Windows Update Services..."
Stop-Service -Name BITS
Stop-Service -Name wuauserv
Stop-Service -Name appidsvc
Stop-Service -Name cryptsvc

Write-Host "2. Remove QMGR Data file..."
Remove-Item "$env:allusersprofile\Application Data\Microsoft\Network\Downloader\qmgr*.dat" -ErrorAction SilentlyContinue

Write-Host "3. Renaming the Software Distribution and CatRoot Folder..."
Rename-Item $env:systemroot\SoftwareDistribution SoftwareDistribution.bak -ErrorAction SilentlyContinue
Rename-Item $env:systemroot\System32\Catroot2 catroot2.bak -ErrorAction SilentlyContinue

Write-Host "4. Removing old Windows Update log..."
Remove-Item $env:systemroot\WindowsUpdate.log -ErrorAction SilentlyContinue

Write-Host "5. Resetting the Windows Update Services to defualt settings..."
"sc.exe sdset bits D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;AU)(A;;CCLCSWRPWPDTLOCRRC;;;PU)"
"sc.exe sdset wuauserv D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;AU)(A;;CCLCSWRPWPDTLOCRRC;;;PU)"

Set-Location $env:systemroot\system32

Write-Host "6. Registering some DLLs..."
regsvr32.exe /s atl.dll
regsvr32.exe /s urlmon.dll
regsvr32.exe /s mshtml.dll
regsvr32.exe /s shdocvw.dll
regsvr32.exe /s browseui.dll
regsvr32.exe /s jscript.dll
regsvr32.exe /s vbscript.dll
regsvr32.exe /s scrrun.dll
regsvr32.exe /s msxml.dll
regsvr32.exe /s msxml3.dll
regsvr32.exe /s msxml6.dll
regsvr32.exe /s actxprxy.dll
regsvr32.exe /s softpub.dll
regsvr32.exe /s wintrust.dll
regsvr32.exe /s dssenh.dll
regsvr32.exe /s rsaenh.dll
regsvr32.exe /s gpkcsp.dll
regsvr32.exe /s sccbase.dll
regsvr32.exe /s slbcsp.dll
regsvr32.exe /s cryptdlg.dll
regsvr32.exe /s oleaut32.dll
regsvr32.exe /s ole32.dll
regsvr32.exe /s shell32.dll
regsvr32.exe /s initpki.dll
regsvr32.exe /s wuapi.dll
regsvr32.exe /s wuaueng.dll
regsvr32.exe /s wuaueng1.dll
regsvr32.exe /s wucltui.dll
regsvr32.exe /s wups.dll
regsvr32.exe /s wups2.dll
regsvr32.exe /s wuweb.dll
regsvr32.exe /s qmgr.dll
regsvr32.exe /s qmgrprxy.dll
regsvr32.exe /s wucltux.dll
regsvr32.exe /s muweb.dll
regsvr32.exe /s wuwebv.dll

Write-Host "7) Removing WSUS client settings..."
REG DELETE "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate" /v AccountDomainSid /f
REG DELETE "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate" /v PingID /f
REG DELETE "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate" /v SusClientId /f

Write-Host "8) Resetting the WinSock..."
netsh winsock reset
netsh winhttp reset proxy

Write-Host "9) Delete all BITS jobs..."
Get-BitsTransfer | Remove-BitsTransfer

Write-Host "10) Attempting to install the Windows Update Agent..."
if($arch -eq 64){
    wusa Windows8-RT-KB2937636-x64 /quiet
}
else{
    wusa Windows8-RT-KB2937636-x86 /quiet
}

Write-Host "11) Starting Windows Update Services..."
Start-Service -Name BITS
Start-Service -Name wuauserv
Start-Service -Name appidsvc
Start-Service -Name cryptsvc

Write-Host "12) Forcing discovery..."
wuauclt /resetauthorization /detectnow

Write-Host "Process complete. Please reboot your computer."</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_on_Client</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>wuauclt_detectnow_reportnow_for_LIST_of_computers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_on_Client</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>wuauclt_detectnow_reportnow_for_LIST_of_computers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'wuauclt_detectnow_reportnow_for_LIST_of_computers


========================================================

$computers = Get-ADComputer -SearchBase "Enter Computer OU" -filter *  | orEach-Object {$_.Name}

foreach ($computers in $computers){
    if (Test-Connection -Computername $computers -BufferSize 16 -Count 1 -Quiet) {
        invoke-command -ComputerName $computers {wuauclt.exe /detectnow}
        invoke-command -ComputerName $computers {wuauclt.exe /reportnow}
        write-host -foregroundcolor "Green" "WSUS is now checking in for computer: " $computers
    }
    else{
        Write-host -foregroundcolor "Red" $computers is offline
    }   
}
==========================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS_Server_2012</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>ReIndex_WSUS_Database_v0.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS_Server_2012</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>ReIndex_WSUS_Database_v0.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--ReIndex_WSUS_Database_v0.sql
--From: https://gallery.technet.microsoft.com/scriptcenter/6f8cde49-5c52-4abd-9820-f1d270ddea61

/****************************************************************************** 
If you only want to check the fragmentation level, just run the first part of the script.

Use the Re-index the WSUS 3.0 Database script from Microsoft Script Center, 
also works great with WSUS 4.0. 
Use either Sqlcmd or PowerShell (Invoke-Sqlcmd cmdlet ) to automate it.

This sample T-SQL script performs basic maintenance tasks on SUSDB 
1. Identifies indexes that are fragmented and defragments them. For certain 
   tables, a fill-factor is set in order to improve insert performance. 
   Based on MSDN sample at http://msdn2.microsoft.com/en-us/library/ms188917.aspx 
   and tailored for SUSDB requirements 
2. Updates potentially out-of-date table statistics. 
******************************************************************************/ 

USE SUSDB; 
GO 
SET NOCOUNT ON; 
 
-- Rebuild or reorganize indexes based on their fragmentation levels 
DECLARE @work_to_do TABLE ( 
    objectid int 
    , indexid int 
    , pagedensity float 
    , fragmentation float 
    , numrows int 
) 
 
DECLARE @objectid int; 
DECLARE @indexid int; 
DECLARE @schemaname nvarchar(130);  
DECLARE @objectname nvarchar(130);  
DECLARE @indexname nvarchar(130);  
DECLARE @numrows int 
DECLARE @density float; 
DECLARE @fragmentation float; 
DECLARE @command nvarchar(4000);  
DECLARE @fillfactorset bit 
DECLARE @numpages int 
 
-- Select indexes that need to be defragmented based on the following 
-- * Page density is low 
-- * External fragmentation is high in relation to index size 
PRINT 'Estimating fragmentation: Begin. ' + convert(nvarchar, getdate(), 121)  
INSERT @work_to_do 
SELECT 
    f.object_id 
    , index_id 
    , avg_page_space_used_in_percent 
    , avg_fragmentation_in_percent 
    , record_count 
FROM  
    sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, 'SAMPLED') AS f 
WHERE 
    (f.avg_page_space_used_in_percent &lt; 85.0 and f.avg_page_space_used_in_percent/100.0 * page_count &lt; page_count - 1) 
    or (f.page_count &gt; 50 and f.avg_fragmentation_in_percent &gt; 15.0) 
    or (f.page_count &gt; 10 and f.avg_fragmentation_in_percent &gt; 80.0) 
 
PRINT 'Number of indexes to rebuild: ' + cast(@@ROWCOUNT as nvarchar(20)) 
 
PRINT 'Estimating fragmentation: End. ' + convert(nvarchar, getdate(), 121) 
 

--===========================================================================================================

SELECT @numpages = sum(ps.used_page_count) 
FROM 
    @work_to_do AS fi 
    INNER JOIN sys.indexes AS i ON fi.objectid = i.object_id and fi.indexid = i.index_id 
    INNER JOIN sys.dm_db_partition_stats AS ps on i.object_id = ps.object_id and i.index_id = ps.index_id 
 
-- Declare the cursor for the list of indexes to be processed. 
DECLARE curIndexes CURSOR FOR SELECT * FROM @work_to_do 
 
-- Open the cursor. 
OPEN curIndexes 
 
-- Loop through the indexes 
WHILE (1=1) 
BEGIN 
    FETCH NEXT FROM curIndexes 
    INTO @objectid, @indexid, @density, @fragmentation, @numrows; 
    IF @@FETCH_STATUS &lt; 0 BREAK; 
 
    SELECT  
        @objectname = QUOTENAME(o.name) 
        , @schemaname = QUOTENAME(s.name) 
    FROM  
        sys.objects AS o 
        INNER JOIN sys.schemas as s ON s.schema_id = o.schema_id 
    WHERE  
        o.object_id = @objectid; 
 
    SELECT  
        @indexname = QUOTENAME(name) 
        , @fillfactorset = CASE fill_factor WHEN 0 THEN 0 ELSE 1 END 
    FROM  
        sys.indexes 
    WHERE 
        object_id = @objectid AND index_id = @indexid; 
 
    IF ((@density BETWEEN 75.0 AND 85.0) AND @fillfactorset = 1) OR (@fragmentation &lt; 30.0) 
        SET @command = N'ALTER INDEX ' + @indexname + N' ON ' + @schemaname + N'.' + @objectname + N' REORGANIZE'; 
    ELSE IF @numrows &gt;= 5000 AND @fillfactorset = 0 
        SET @command = N'ALTER INDEX ' + @indexname + N' ON ' + @schemaname + N'.' + @objectname + N' REBUILD WITH (FILLFACTOR = 90)'; 
    ELSE 
        SET @command = N'ALTER INDEX ' + @indexname + N' ON ' + @schemaname + N'.' + @objectname + N' REBUILD'; 
    PRINT convert(nvarchar, getdate(), 121) + N' Executing: ' + @command; 
    EXEC (@command); 
    PRINT convert(nvarchar, getdate(), 121) + N' Done.'; 
END 
 
-- Close and deallocate the cursor. 
CLOSE curIndexes; 
DEALLOCATE curIndexes; 
 
 
IF EXISTS (SELECT * FROM @work_to_do) 
BEGIN 
    PRINT 'Estimated number of pages in fragmented indexes: ' + cast(@numpages as nvarchar(20)) 
    SELECT @numpages = @numpages - sum(ps.used_page_count) 
    FROM 
        @work_to_do AS fi 
        INNER JOIN sys.indexes AS i ON fi.objectid = i.object_id and fi.indexid = i.index_id 
        INNER JOIN sys.dm_db_partition_stats AS ps on i.object_id = ps.object_id and i.index_id = ps.index_id 
 
    PRINT 'Estimated number of pages freed: ' + cast(@numpages as nvarchar(20)) 
END 
GO 
 
 
--Update all statistics 
PRINT 'Updating all statistics.' + convert(nvarchar, getdate(), 121)  
EXEC sp_updatestats 
PRINT 'Done updating statistics.' + convert(nvarchar, getdate(), 121)  
GO </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS_Server_2012</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>spGetObsoleteUpdatesToCleanup</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS_Server_2012</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>spGetObsoleteUpdatesToCleanup</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
run on SSMS  (SEE the SQL Scripts under WSUS)

'https://social.technet.microsoft.com/Forums/ie/en-US/7b12f8b2-d0e6-4f63-a98a-019356183c29/getting-past-wsus-cleanup-wizard-time-out-removing-unnecessary-updates?forum=winserverwsus

For anyone who is getting Timeout Expired with obsolete updates. I have a solution! Use server name : 
"\\.\pipe\MSSQL$MICROSOFT##SSEE\sql\query" to connect with SQL managment studio. 
Once connected manually run 
"
	USE SUSDB
	GO
	exec spGetObsoleteUpdatesToCleanup
". 
'This will return a list of obsolete ID's. For each one run 
"exec spDeleteUpdate @localUpdateID=000000"
'where 000000 is the ID. 
'For myself I found the first ID in the list took a full 37 minutes to delete 
'	and then after that I could run the cleanup through the GUI as per usual.


===========================================================================SQL
--spGetObsoleteUpdatesToCleanup.sql

	USE SUSDB
	GO
	exec spGetObsoleteUpdatesToCleanup
===========================================================================
'https://github.com/DeploymentResearch/DRFiles/blob/master/Scripts/Get-WSUSObsoleteUpdatesNumber.sql

USE SUSDB

DECLARE @var1 INT, @curitem INT, @totaltodelete INT

CREATE TABLE #results (Col1 INT) 
INSERT INTO #results(Col1) EXEC spGetObsoleteUpdatesToCleanup

SELECT COUNT(*) FROM #results
DROP TABLE #results
===========================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS_Server_2016</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>re-index</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS_Server_2016</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>re-index</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--ReIndex_WSUS_Database_v0.sql
--From: https://gallery.technet.microsoft.com/scriptcenter/6f8cde49-5c52-4abd-9820-f1d270ddea61

/****************************************************************************** 
If you only want to check the fragmentation level, just run the first part of the script.

Use the Re-index the WSUS 3.0 Database script from Microsoft Script Center, 
also works great with WSUS 4.0. 
Use either Sqlcmd or PowerShell (Invoke-Sqlcmd cmdlet ) to automate it.

This sample T-SQL script performs basic maintenance tasks on SUSDB 
1. Identifies indexes that are fragmented and defragments them. For certain 
   tables, a fill-factor is set in order to improve insert performance. 
   Based on MSDN sample at http://msdn2.microsoft.com/en-us/library/ms188917.aspx 
   and tailored for SUSDB requirements 
2. Updates potentially out-of-date table statistics. 
******************************************************************************/ 

USE SUSDB; 
GO 
SET NOCOUNT ON; 
 
-- Rebuild or reorganize indexes based on their fragmentation levels 
DECLARE @work_to_do TABLE ( 
    objectid int 
    , indexid int 
    , pagedensity float 
    , fragmentation float 
    , numrows int 
) 
 
DECLARE @objectid int; 
DECLARE @indexid int; 
DECLARE @schemaname nvarchar(130);  
DECLARE @objectname nvarchar(130);  
DECLARE @indexname nvarchar(130);  
DECLARE @numrows int 
DECLARE @density float; 
DECLARE @fragmentation float; 
DECLARE @command nvarchar(4000);  
DECLARE @fillfactorset bit 
DECLARE @numpages int 
 
-- Select indexes that need to be defragmented based on the following 
-- * Page density is low 
-- * External fragmentation is high in relation to index size 
PRINT 'Estimating fragmentation: Begin. ' + convert(nvarchar, getdate(), 121)  
INSERT @work_to_do 
SELECT 
    f.object_id 
    , index_id 
    , avg_page_space_used_in_percent 
    , avg_fragmentation_in_percent 
    , record_count 
FROM  
    sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, 'SAMPLED') AS f 
WHERE 
    (f.avg_page_space_used_in_percent &lt; 85.0 and f.avg_page_space_used_in_percent/100.0 * page_count &lt; page_count - 1) 
    or (f.page_count &gt; 50 and f.avg_fragmentation_in_percent &gt; 15.0) 
    or (f.page_count &gt; 10 and f.avg_fragmentation_in_percent &gt; 80.0) 
 
PRINT 'Number of indexes to rebuild: ' + cast(@@ROWCOUNT as nvarchar(20)) 
 
PRINT 'Estimating fragmentation: End. ' + convert(nvarchar, getdate(), 121) 
 

--===========================================================================================================

SELECT @numpages = sum(ps.used_page_count) 
FROM 
    @work_to_do AS fi 
    INNER JOIN sys.indexes AS i ON fi.objectid = i.object_id and fi.indexid = i.index_id 
    INNER JOIN sys.dm_db_partition_stats AS ps on i.object_id = ps.object_id and i.index_id = ps.index_id 
 
-- Declare the cursor for the list of indexes to be processed. 
DECLARE curIndexes CURSOR FOR SELECT * FROM @work_to_do 
 
-- Open the cursor. 
OPEN curIndexes 
 
-- Loop through the indexes 
WHILE (1=1) 
BEGIN 
    FETCH NEXT FROM curIndexes 
    INTO @objectid, @indexid, @density, @fragmentation, @numrows; 
    IF @@FETCH_STATUS &lt; 0 BREAK; 
 
    SELECT  
        @objectname = QUOTENAME(o.name) 
        , @schemaname = QUOTENAME(s.name) 
    FROM  
        sys.objects AS o 
        INNER JOIN sys.schemas as s ON s.schema_id = o.schema_id 
    WHERE  
        o.object_id = @objectid; 
 
    SELECT  
        @indexname = QUOTENAME(name) 
        , @fillfactorset = CASE fill_factor WHEN 0 THEN 0 ELSE 1 END 
    FROM  
        sys.indexes 
    WHERE 
        object_id = @objectid AND index_id = @indexid; 
 
    IF ((@density BETWEEN 75.0 AND 85.0) AND @fillfactorset = 1) OR (@fragmentation &lt; 30.0) 
        SET @command = N'ALTER INDEX ' + @indexname + N' ON ' + @schemaname + N'.' + @objectname + N' REORGANIZE'; 
    ELSE IF @numrows &gt;= 5000 AND @fillfactorset = 0 
        SET @command = N'ALTER INDEX ' + @indexname + N' ON ' + @schemaname + N'.' + @objectname + N' REBUILD WITH (FILLFACTOR = 90)'; 
    ELSE 
        SET @command = N'ALTER INDEX ' + @indexname + N' ON ' + @schemaname + N'.' + @objectname + N' REBUILD'; 
    PRINT convert(nvarchar, getdate(), 121) + N' Executing: ' + @command; 
    EXEC (@command); 
    PRINT convert(nvarchar, getdate(), 121) + N' Done.'; 
END 
 
-- Close and deallocate the cursor. 
CLOSE curIndexes; 
DEALLOCATE curIndexes; 
 
 
IF EXISTS (SELECT * FROM @work_to_do) 
BEGIN 
    PRINT 'Estimated number of pages in fragmented indexes: ' + cast(@numpages as nvarchar(20)) 
    SELECT @numpages = @numpages - sum(ps.used_page_count) 
    FROM 
        @work_to_do AS fi 
        INNER JOIN sys.indexes AS i ON fi.objectid = i.object_id and fi.indexid = i.index_id 
        INNER JOIN sys.dm_db_partition_stats AS ps on i.object_id = ps.object_id and i.index_id = ps.index_id 
 
    PRINT 'Estimated number of pages freed: ' + cast(@numpages as nvarchar(20)) 
END 
GO 
 
 
--Update all statistics 
PRINT 'Updating all statistics.' + convert(nvarchar, getdate(), 121)  
EXEC sp_updatestats 
PRINT 'Done updating statistics.' + convert(nvarchar, getdate(), 121)  
GO </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>ALL_computer_LIST_local</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>ALL_computer_LIST_local</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

=====================================================================
#'ListOfFailedComputers.ps1
cls
[void][reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")

# Connect to WSUS Server - getUpdateServer("server name", ssl, port)
$Global:wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::getUpdateServer()

#Create Scope objects
$computerScope = New-Object Microsoft.UpdateServices.Administration.ComputerTargetScope
$updateScope = New-Object Microsoft.UpdateServices.Administration.UpdateScope


#Get Update Summary of Computers with Failed Updates
$AllClients = ($wsus.GetSummariesPerComputerTarget($updateScope,$computerScope) | ForEach {
   New-Object PSObject -Property @{
       ComputerTarget = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).FullDomainName
       IPAddress = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).IPAddress
       Make = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).Make
       OSDescription = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).OSDescription
       ComputerRole = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).ComputerRole
       FailedCount = $_.FailedCount
   }
} )

$AllClients | Export-CSV -Path C:\Users\ggarson\Desktop\PS\ALLClientsList.csv                #'Out-GridView

=====================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>AvailableUpdatesOnServer_GUIDs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>AvailableUpdatesOnServer_GUIDs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'AvailableUpdatesOnServer_GUIDs


https://angrytechnician.wordpress.com/2011/04/28/how-to-get-a-list-of-every-wsus-update-using-powershell/
#'Recently I needed to get a list of every update on my WSUS server, 
#'    due to a bug in System Center Essentials which leaves orphaned 
#'    folders on the server even when locally-published updates have been removed using the console 
#'    (the Server Cleanup tool doesn’t get rid of these files either – see this post on TechNet.
#'
#'The folders in question were all in the WSUS\UpdateServicesPackages directory, 
#'    and are named according to the GUID of the update in WSUS. 
#'The WSUS console doesn’t provide any way to get a list of GUIDs that are valid updates, 
#'    but you can do it using the WSUS .NET API, which is accessible via PowerShell.
#'


#'Update: If you’re only interested in which folders to delete, 
#'	without any additional information, 
#'	you can run wsusutil listunreferencedpackagefolders from the 
#'	%Program Files%\Update Services\Tools directory. 
#'This command is mysteriously missing from any online documentation from MS.



#'Here’s a sample script to get the GUIDs. 
#'You’ll need to customise line 2 to reflect the FQDN of your WSUS server, 
#'    along with whether to use SSL and the port number. 
#'You’ll either need to run the script using an account with admin rights to WSUS, 
#'    either on the WSUS server itself, or on a workstation with the WSUS console installed.
#'

[void][reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")
$wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer('updates.angrytech.internal',$False,80)
#Get all updates
$updates = $wsus.GetUpdates()
#Iterate every update and output some basic info about it
ForEach ($update in $updates) {
New-Object PSObject -Property @{
Id = $update.Id.UpdateId.ToString()
Title = $update.Title
Source = $update.UpdateSource.ToString()
}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Decline_if_Superseded</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Decline_if_Superseded</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://xenappblog.com/2016/how-to-clean-up-wsus/


---------------------------------------------------
#'Change server name and port number and $True if it is on SSL
 
$Computer = $env:COMPUTERNAME
$Domain = $env:USERDNSDOMAIN
$FQDN = "$Computer" + "." + "$Domain"
[String]$updateServer1 = $FQDN
[Boolean]$useSecureConnection = $False
[Int32]$portNumber = 8530
 
#' Load .NET assembly 
[void][reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") 
$count = 0
 
#' Connect to WSUS Server 
$updateServer = [Microsoft.UpdateServices.Administration.AdminProxy]::getUpdateServer($updateServer1, $useSecureConnection, $portNumber) 
write-host "&lt;&lt;&lt;Connected sucessfully &gt;&gt;&gt;" -foregroundcolor "yellow" 
$updatescope = New-Object Microsoft.UpdateServices.Administration.UpdateScope 
$u = $updateServer.GetUpdates($updatescope ) 
foreach ($u1 in $u )
{ 
    if ($u1.IsSuperseded -eq 'True')
    { 
        write-host Decline Update : $u1.Title 
        $u1.Decline()
        $count = $count + 1 
    } 
}
 
write-host Total Declined Updates: $count 
trap
{
    write-host "Error Occurred" 
    write-host "Exception Message: " 
    write-host $_.Exception.Message 
    write-host $_.Exception.StackTrace 
    exit
 
}
 
#' EOF
---------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Declining_Superseded_Updates_v0</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Declining_Superseded_Updates_v0</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#''Declining_Superseded_Updates_v0
'from: https://blogs.technet.microsoft.com/configurationmgr/2016/01/26/the-complete-guide-to-microsoft-wsus-and-configuration-manager-sup-maintenance/

'NOTE You always want to run the script with the –SkipDecline parameter before running the decline so you get a summary of how many superseded updates you are about to decline.
'I run this once a quarter in my environment. 

'If you do not expire updates immediately in Configuration Manager, you will need to set an exclusion period that matches your Configuration Manager setting for number of days to expire superseded updates. In this case, 
'it would be 60 days since I specified to wait 2 months in my SUP properties.

'Examples on how to run the script using PowerShell running as administrator:

Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 80 -SkipDecline
Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8351
Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530
Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530 –ExclusionPeriod 60


'Running the script with a –SkipDecline and –ExclusionPeriod 60 to gather information about my WSUS and how many updates I will decline:


==========================================================================================
#' ===============================================
#' Script to decline superseeded updates in WSUS.
#' ===============================================
#' It's recommended to run the script with the -SkipDecline switch to see how many superseded updates are in WSUS and to TAKE A BACKUP OF THE SUSDB before declining the updates.
#' Parameters:

#' $UpdateServer             = Specify WSUS Server Name
#' $UseSSL                   = Specify whether WSUS Server is configured to use SSL
#' $Port                     = Specify WSUS Server Port
#' $SkipDecline              = Specify this to do a test run and get a summary of how many superseded updates we have
#' $DeclineLastLevelOnly     = Specify whether to decline all superseded updates or only last level superseded updates
#' $ExclusionPeriod          = Specify the number of days between today and the release date for which the superseded updates must not be declined. Eg, if you want to keep superseded updates published within the last 2 months, specify a value of 60 (days)


#' Supersedence chain could have multiple updates. 
#' For example, Update1 supersedes Update2. Update2 supersedes Update3. In this scenario, the Last Level in the supersedence chain is Update3. 
#' To decline only the last level updates in the supersedence chain, specify the DeclineLastLevelOnly switch

#' Usage:
#' =======

#' To do a test run against WSUS Server without SSL
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530 -SkipDecline

#' To do a test run against WSUS Server using SSL
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -SkipDecline

#' To decline all superseded updates on the WSUS Server using SSL
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531

#' To decline only Last Level superseded updates on the WSUS Server using SSL
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -DeclineLastLevelOnly

#' To decline all superseded updates on the WSUS Server using SSL but keep superseded updates published within the last 2 months (60 days)
#' Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -ExclusionPeriod 60


[CmdletBinding()]
Param(
	[Parameter(Mandatory=$True,Position=1)]
    [string] $UpdateServer,
	
	[Parameter(Mandatory=$False)]
    [switch] $UseSSL,
	
	[Parameter(Mandatory=$True, Position=2)]
    $Port,
	
    [switch] $SkipDecline,
	
    [switch] $DeclineLastLevelOnly,
	
    [Parameter(Mandatory=$False)]
    [int] $ExclusionPeriod = 0
)

Write-Host ""

if ($SkipDecline -and $DeclineLastLevelOnly) {
    Write-Host "Using SkipDecline and DeclineLastLevelOnly switches together is not allowed."
	Write-Host ""
    return
}

$outPath = Split-Path $script:MyInvocation.MyCommand.Path
$outSupersededList = Join-Path $outPath "SupersededUpdates.csv"
$outSupersededListBackup = Join-Path $outPath "SupersededUpdatesBackup.csv"
"UpdateID, RevisionNumber, Title, KBArticle, SecurityBulletin, LastLevel" | Out-File $outSupersededList

try {
    
    if ($UseSSL) {
        Write-Host "Connecting to WSUS server $UpdateServer on Port $Port using SSL... " -NoNewLine
    } Else {
        Write-Host "Connecting to WSUS server $UpdateServer on Port $Port... " -NoNewLine
    }
    
    [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") | out-null
    $wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($UpdateServer, $UseSSL, $Port);
}
catch [System.Exception] 
{
    Write-Host "Failed to connect."
    Write-Host "Error:" $_.Exception.Message
    Write-Host "Please make sure that WSUS Admin Console is installed on this machine"
	Write-Host ""
    $wsus = $null
}

if ($wsus -eq $null) { return } 

Write-Host "Connected."

$countAllUpdates = 0
$countSupersededAll = 0
$countSupersededLastLevel = 0
$countSupersededExclusionPeriod = 0
$countSupersededLastLevelExclusionPeriod = 0
$countDeclined = 0

Write-Host "Getting a list of all updates... " -NoNewLine

try {
	$allUpdates = $wsus.GetUpdates()
}

catch [System.Exception]
{
	Write-Host "Failed to get updates."
	Write-Host "Error:" $_.Exception.Message
    Write-Host "If this operation timed out, please decline the superseded updates from the WSUS Console manually."
	Write-Host ""
	return
}

Write-Host "Done"

Write-Host "Parsing the list of updates... " -NoNewLine
foreach($update in $allUpdates) {
    
    $countAllUpdates++
    
    if ($update.IsDeclined) {
        $countDeclined++
    }
    
    if (!$update.IsDeclined -and $update.IsSuperseded) {
        $countSupersededAll++
        
        if (!$update.HasSupersededUpdates) {
            $countSupersededLastLevel++
        }

        if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
		    $countSupersededExclusionPeriod++
			if (!$update.HasSupersededUpdates) {
				$countSupersededLastLevelExclusionPeriod++
			}
        }		
        
        "$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededList -Append       
        
    }
}

Write-Host "Done."
Write-Host "List of superseded updates: $outSupersededList"

Write-Host ""
Write-Host "Summary:"
Write-Host "========"

Write-Host "All Updates =" $countAllUpdates
Write-Host "Any except Declined =" ($countAllUpdates - $countDeclined)
Write-Host "All Superseded Updates =" $countSupersededAll
Write-Host "    Superseded Updates (Intermediate) =" ($countSupersededAll - $countSupersededLastLevel)
Write-Host "    Superseded Updates (Last Level) =" $countSupersededLastLevel
Write-Host "    Superseded Updates (Older than $ExclusionPeriod days) =" $countSupersededExclusionPeriod
Write-Host "    Superseded Updates (Last Level Older than $ExclusionPeriod days) =" $countSupersededLastLevelExclusionPeriod
Write-Host ""

$i = 0
if (!$SkipDecline) {
    
    Write-Host "SkipDecline flag is set to $SkipDecline. Continuing with declining updates"
    $updatesDeclined = 0
    
    if ($DeclineLastLevelOnly) {
        Write-Host "  DeclineLastLevel is set to True. Only declining last level superseded updates." 
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded -and !$update.HasSupersededUpdates) {
              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
			    $i++
				$percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededLastLevelExclusionPeriod) * 100)
				Write-Progress -Activity "Declining Updates" -Status "Declining update #'$i/$countSupersededLastLevelExclusionPeriod - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
				
                try 
                {
                    $update.Decline()                    
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Host "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                } 
              }             
            }
        }        
    }
    else {
        Write-Host "  DeclineLastLevel is set to False. Declining all superseded updates."
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded) {
              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {   
			  	
				$i++
				$percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededAll) * 100)
				Write-Progress -Activity "Declining Updates" -Status "Declining update #'$i/$countSupersededAll - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
                try 
                {
                    $update.Decline()
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Host "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                }
              }              
            }
        }   
        
    }
    
    Write-Host "  Declined $updatesDeclined updates."
    if ($updatesDeclined -ne 0) {
        Copy-Item -Path $outSupersededList -Destination $outSupersededListBackup -Force
		Write-Host "  Backed up list of superseded updates to $outSupersededListBackup"
    }
    
}
else {
    Write-Host "SkipDecline flag is set to $SkipDecline. Skipped declining updates"
}

Write-Host ""
Write-Host "Done"
Write-Host ""</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Declining_Superseeded_Updates</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Declining_Superseeded_Updates</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'SEE ORIGINAL source script below
https://4sysops.com/archives/automating-wsus-with-powershell/
-------------------------------------
#'My changes are in the lines 57–59, 99–100, and 242. 
#'I added the transcript file, so when the script ran via the Task Scheduler, 
#'    I could see the number of declined updates. And after I ran the script the first time, 
#'    I changed the update scope. 
#'So it'll check and decline only updates within the last six months.

#'===============================================
#'Script to decline superseeded updates in WSUS.
#'===============================================
#'It's recommended to run the script with the -SkipDecline switch to see how many superseded updates are in WSUS and to TAKE A BACKUP OF THE SUSDB before declining the updates.
#'Parameters:
 
#'$UpdateServer             = Specify WSUS Server Name
#'$UseSSL                   = Specify whether WSUS Server is configured to use SSL
#'$Port                     = Specify WSUS Server Port
#'$SkipDecline              = Specify this to do a test run and get a summary of how many superseded updates we have
#'$DeclineLastLevelOnly     = Specify whether to decline all superseded updates or only last level superseded updates
#'$ExclusionPeriod          = Specify the number of days between today and the release date for which the superseded updates must not be declined. Eg, if you want to keep superseded updates published within the last 2 months, specify a value of 60 (days)
 
 
#'Supersedence chain could have multiple updates. 
#'For example, Update1 supersedes Update2. Update2 supersedes Update3. In this scenario, the Last Level in the supersedence chain is Update3. 
#'To decline only the last level updates in the supersedence chain, specify the DeclineLastLevelOnly switch
 
#'Usage:
#'=======
 
#'To do a test run against WSUS Server without SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530 -SkipDecline
 
#'To do a test run against WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -SkipDecline
 
#'To decline all superseded updates on the WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531
 
#'To decline only Last Level superseded updates on the WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -DeclineLastLevelOnly
 
#'To decline all superseded updates on the WSUS Server using SSL but keep superseded updates published within the last 2 months (60 days)
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -ExclusionPeriod 60
 
 
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$True,Position=1)]
    [string] $UpdateServer,
    
    [Parameter(Mandatory=$False)]
    [switch] $UseSSL,
    
    [Parameter(Mandatory=$True, Position=2)]
    $Port,
    
    [switch] $SkipDecline,
    
    [switch] $DeclineLastLevelOnly,
    
    [Parameter(Mandatory=$False)]
    [int] $ExclusionPeriod = 0
)
 
$file = "c:\temp\WSUS_Decline_Superseded_{0:MMddyyyy_HHmm}.log" -f (Get-Date) 
 
Start-Transcript -Path $file
 
 
if ($SkipDecline -and $DeclineLastLevelOnly) {
    Write-Output "Using SkipDecline and DeclineLastLevelOnly switches together is not allowed."
    Write-Output ""
    return
}
 
$outPath = Split-Path $script:MyInvocation.MyCommand.Path
$outSupersededList = Join-Path $outPath "SupersededUpdates.csv"
$outSupersededListBackup = Join-Path $outPath "SupersededUpdatesBackup.csv"
"UpdateID, RevisionNumber, Title, KBArticle, SecurityBulletin, LastLevel" | Out-File $outSupersededList
 
try {
    
    if ($UseSSL) {
        Write-Output "Connecting to WSUS server $UpdateServer on Port $Port using SSL... " -NoNewLine
    } Else {
        Write-Output "Connecting to WSUS server $UpdateServer on Port $Port... " -NoNewLine
    }
    
    [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") | out-null
    $wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($UpdateServer, $UseSSL, $Port);
}
catch [System.Exception] 
{
    Write-Output "Failed to connect."
    Write-Output "Error:" $_.Exception.Message
    Write-Output "Please make sure that WSUS Admin Console is installed on this machine"
    Write-Output ""
    $wsus = $null
}
 
if ($wsus -eq $null) { return } 
 
Write-Output "Connected."
 
$UpdateScope = New-Object Microsoft.UpdateServices.Administration.UpdateScope
 
(get-date).AddMonths(-6)
$UpdateScope.FromArrivalDate = (get-date).AddMonths(-6)
$UpdateScope.ToArrivalDate = (get-date)
 
$countAllUpdates = 0
$countSupersededAll = 0
$countSupersededLastLevel = 0
$countSupersededExclusionPeriod = 0
$countSupersededLastLevelExclusionPeriod = 0
$countDeclined = 0
 
Write-Output "Getting a list of all updates... " -NoNewLine
 
try {
    $allUpdates = $wsus.GetUpdates($UpdateScope)
}
 
catch [System.Exception]
{
    Write-Output "Failed to get updates."
    Write-Output "Error:" $_.Exception.Message
    Write-Output "If this operation timed out, please decline the superseded updates from the WSUS Console manually."
    Write-Output ""
    return
}
 
Write-Output "Done"
 
Write-Output "Parsing the list of updates... " -NoNewLine
foreach($update in $allUpdates) {
    
    $countAllUpdates++
    
    if ($update.IsDeclined) {
        $countDeclined++
    }
    
    if (!$update.IsDeclined -and $update.IsSuperseded) {
        $countSupersededAll++
        
        if (!$update.HasSupersededUpdates) {
            $countSupersededLastLevel++
        }
 
        if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
            $countSupersededExclusionPeriod++
            if (!$update.HasSupersededUpdates) {
                $countSupersededLastLevelExclusionPeriod++
            }
        }        
        
        "$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededList -Append       
        
    }
}
 
Write-Output "Done."
Write-Output "List of superseded updates: $outSupersededList"
 
Write-Output ""
Write-Output "Summary:"
Write-Output "========"
 
Write-Output "All Updates = $countAllUpdates"
$AnyExceptDeclined = $countAllUpdates - $countDeclined
Write-Output "Any except Declined = $AnyExceptDeclined"
Write-Output "All Superseded Updates = $countSupersededAll"
$SuperseededAllOutput = $countSupersededAll - $countSupersededLastLevel
Write-Output "    Superseded Updates (Intermediate) = $SuperseededAllOutput"
Write-Output "    Superseded Updates (Last Level) = $countSupersededLastLevel"
Write-Output "    Superseded Updates (Older than $ExclusionPeriod days) = $countSupersededExclusionPeriod"
Write-Output "    Superseded Updates (Last Level Older than $ExclusionPeriod days) = $countSupersededLastLevelExclusionPeriod"
 
$i = 0
if (!$SkipDecline) {
    
    Write-Output "SkipDecline flag is set to $SkipDecline. Continuing with declining updates"
    $updatesDeclined = 0
    
    if ($DeclineLastLevelOnly) {
        Write-Output "  DeclineLastLevel is set to True. Only declining last level superseded updates." 
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded -and !$update.HasSupersededUpdates) {
              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
                $i++
                $percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededLastLevelExclusionPeriod) * 100)
                Write-Progress -Activity "Declining Updates" -Status "Declining update #$i/$countSupersededLastLevelExclusionPeriod - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
                
                try 
                {
                    $update.Decline()                    
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Output "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                } 
              }             
            }
        }        
    }
    else {
        Write-Output "  DeclineLastLevel is set to False. Declining all superseded updates."
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded) {
              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {   
                  
                $i++
                $percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededAll) * 100)
                Write-Progress -Activity "Declining Updates" -Status "Declining update #$i/$countSupersededAll - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
                try 
                {
                    $update.Decline()
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Output "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                }
              }              
            }
        }   
        
    }
    
    Write-Output "  Declined $updatesDeclined updates."
    if ($updatesDeclined -ne 0) {
        Copy-Item -Path $outSupersededList -Destination $outSupersededListBackup -Force
        Write-Output "  Backed up list of superseded updates to $outSupersededListBackup"
    }
    
}
else {
    Write-Output "SkipDecline flag is set to $SkipDecline. Skipped declining updates"
}
 
Write-Output ""
Write-Output "Done"
Write-Output ""
 
Stop-Transcript



===========================================================

==========ORIGINAL SOURCE SCRIPT========================================
https://social.technet.microsoft.com/Forums/msonline/en-US/15f0443d-2f68-4d9e-a580-0e330fbac6cc/no-updates-after-3159706?forum=winserverwsus
===============================================================
#'===============================================
#'Script to decline superseeded updates in WSUS.
#'===============================================
#'It's recommended to run the script with the -SkipDecline switch to see how many superseded updates are in WSUS and to TAKE A BACKUP OF THE SUSDB before declining the updates.
#'Parameters:

#'$UpdateServer             = Specify WSUS Server Name
#'$UseSSL                   = Specify whether WSUS Server is configured to use SSL
#'$Port                     = Specify WSUS Server Port
#'$SkipDecline              = Specify this to do a test run and get a summary of how many superseded updates we have
#'$DeclineLastLevelOnly     = Specify whether to decline all superseded updates or only last level superseded updates

#'Supersedence chain could have multiple updates. 
#'For example, Update1 supersedes Update2. Update2 supersedes Update3. In this scenario, the Last Level in the supersedence chain is Update3. 
#'To decline only the last level updates in the supersedence chain, specify the DeclineLastLevelOnly switch

#'Usage:
#'=======

#'To do a test run against WSUS Server without SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -Port 8530 -SkipDecline

#'To do a test run against WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -SkipDecline

#'To decline all superseded updates on the WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531

#'To decline only Last Level superseded updates on the WSUS Server using SSL
#'Decline-SupersededUpdates.ps1 -UpdateServer SERVERNAME -UseSSL -Port 8531 -DeclineLastLevelOnly

[CmdletBinding()]
Param(
	[Parameter(Mandatory=$True,Position=1)]
    [string] $UpdateServer,
	
	[Parameter(Mandatory=$False)]
    [switch] $UseSSL,
	
	[Parameter(Mandatory=$True, Position=2)]
    $Port,
    [switch] $SkipDecline,
    [switch] $DeclineLastLevelOnly
)

Write-Host ""

if ($SkipDecline -and $DeclineLastLevelOnly) {
    Write-Host "Using SkipDecline and DeclineLastLevelOnly switches together is not allowed."
	Write-Host ""
    return
}

$outPath = Split-Path $script:MyInvocation.MyCommand.Path
$outSupersededList = Join-Path $outPath "SupersededUpdates.csv"
$outSupersededListBackup = Join-Path $outPath "SupersededUpdatesBackup.csv"
"UpdateID, RevisionNumber, Title, KBArticle, SecurityBulletin, LastLevel" | Out-File $outSupersededList

try {
    
    if ($UseSSL) {
        Write-Host "Connecting to WSUS server $UpdateServer on Port $Port using SSL... " -NoNewLine
    } Else {
        Write-Host "Connecting to WSUS server $UpdateServer on Port $Port... " -NoNewLine
    }
    
    [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") | out-null
    #$wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($UpdateServer, $UseSSL, $Port);
	$wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer();
}
catch [System.Exception] 
{
    Write-Host "Failed to connect."
    Write-Host "Error:" $_.Exception.Message
    Write-Host "Please make sure that WSUS Admin Console is installed on this machine"
	Write-Host ""
    $wsus = $null
}

if ($wsus -eq $null) { return } 

Write-Host "Connected."

$countAllUpdates = 0
$countSupersededAll = 0
$countSupersededLastLevel = 0
$countDeclined = 0

Write-Host "Getting a list of all updates... " -NoNewLine

try {
	$allUpdates = $wsus.GetUpdates()
}

catch [System.Exception]
{
	Write-Host "Failed to get updates."
	Write-Host "Error:" $_.Exception.Message
    Write-Host "If this operation timed out, please decline the superseded updates from the WSUS Console manually."
	Write-Host ""
	return
}

Write-Host "Done"

Write-Host "Parsing the list of updates... " -NoNewLine
foreach($update in $allUpdates) {
    
    $countAllUpdates++
    
    if ($update.IsDeclined) {
        $countDeclined++
    }
    
    if (!$update.IsDeclined -and $update.IsSuperseded) {
        $countSupersededAll++
        
        if (!$update.HasSupersededUpdates) {
            $countSupersededLastLevel++
        }
        
        "$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededList -Append       
        
    }
}

Write-Host "Done."
Write-Host "List of superseded updates: $outSupersededList"

Write-Host ""
Write-Host "Summary:"
Write-Host "========"

Write-Host "All Updates =" $countAllUpdates
Write-Host "Any except Declined =" ($countAllUpdates - $countDeclined)
Write-Host "All Superseded Updates =" $countSupersededAll
Write-Host "    Superseded Updates (Intermediate) =" ($countSupersededAll - $countSupersededLastLevel)
Write-Host "    Superseded Updates (Last Level) =" $countSupersededLastLevel
Write-Host ""

if (!$SkipDecline) {
    
    Write-Host "SkipDecline flag is set to $SkipDecline. Continuing with declining updates"
    $updatesDeclined = 0
    
    if ($DeclineLastLevelOnly) {
        Write-Host "  DeclineLastLevel is set to True. Only declining last level superseded updates." 
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded -and !$update.HasSupersededUpdates) {
                
                try 
                {
                    $update.Decline()
                    #'Write-Host "Declined update $($update.Id.UpdateId.Guid)"
                    Write-Progress -Activity "Declining Updates" -Status "Declining update $($update.Id.UpdateId.Guid)" -PercentComplete (($updatesDeclined/$countSupersededLastLevel) * 100)
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Host "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                }            
            }
        }        
    }
    else {
        Write-Host "  DeclineLastLevel is set to False. Declining all superseded updates."
        
        foreach ($update in $allUpdates) {
            
            if (!$update.IsDeclined -and $update.IsSuperseded) {
                
                try 
                {
                    $update.Decline()
                    #'Write-Host "Declined update $($update.Id.UpdateId.Guid)"
                    Write-Progress -Activity "Declining Updates" -Status "Declining update $($update.Id.UpdateId.Guid)" -PercentComplete (($updatesDeclined/$countSupersededAll) * 100)
                    $updatesDeclined++
                }
                catch [System.Exception]
                {
                    Write-Host "Failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
                }            
            }
        }   
        
    }
    
    Write-Host "  Declined $updatesDeclined updates."
    if ($updatesDeclined -ne 0) {
        Copy-Item -Path $outSupersededList -Destination $outSupersededListBackup -Force
		Write-Host "  Backed up list of superseded updates to $outSupersededListBackup"
    }
    
}
else {
    Write-Host "SkipDecline flag is set to $SkipDecline. Skipped declining updates"
}

Write-Host ""
Write-Host "Done"
Write-Host ""</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FAILED_computer_LIST_local</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FAILED_computer_LIST_local</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' from: https://gist.github.com/jeffprandall/8ab33ae40d916a6dc437
#' NOTE if it is a remote server use this line:
$Global:wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::getUpdateServer(“serverName”,$true, 8531)

=============================================================================
#'ListOfFailedComputers.ps1
cls
[void][reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")

# Connect to WSUS Server - getUpdateServer("server name", ssl, port)
$Global:wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::getUpdateServer()

#Create Scope objects
$computerScope = New-Object Microsoft.UpdateServices.Administration.ComputerTargetScope
$updateScope = New-Object Microsoft.UpdateServices.Administration.UpdateScope


#Get Update Summary of Computers with Failed Updates
$clientsWithErrors = ($wsus.GetSummariesPerComputerTarget($updateScope,$computerScope) | ForEach {
   New-Object PSObject -Property @{
       ComputerTarget = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).FullDomainName
       IPAddress = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).IPAddress
       Make = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).Make
       OSDescription = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).OSDescription
       ComputerRole = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).ComputerRole
       FailedCount = $_.FailedCount
   }
} | where-object { $_.FailedCount -gt 0 })

$clientsWithErrors | Export-CSV -Path C:\Users\ggarson\Desktop\PS\FailedList.csv                #'Out-GridView


==============================================================================ORIGINAL:

cls
[void][reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")

# Connect to WSUS Server - getUpdateServer("server name", ssl, port)
$Global:wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::getUpdateServer()

#Create Scope objects
$computerScope = New-Object Microsoft.UpdateServices.Administration.ComputerTargetScope
$updateScope = New-Object Microsoft.UpdateServices.Administration.UpdateScope


#Get Update Summary of Computers with Failed Updates
$clientsWithErrors = ($wsus.GetSummariesPerComputerTarget($updateScope,$computerScope) | ForEach {
   New-Object PSObject -Property @{
       ComputerTarget = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).FullDomainName
       IPAddress = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).IPAddress
       Make = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).Make
       OSDescription = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).OSDescription
       ComputerRole = ($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).ComputerRole
       FailedCount = $_.FailedCount
   }
} | where-object { $_.FailedCount -gt 0 })

$clientsWithErrors | Export-CSV -Path C:\Users\ggarson\Desktop\PS\FailedList.csv                #'Out-GridView
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>GetSummariesPerComputerTarget_needed_Downloaded_NotApplicable_NotInstalled</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>GetSummariesPerComputerTarget_needed_Downloaded_NotApplicable_NotInstalled</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://blogs.technet.microsoft.com/heyscriptingguy/2012/01/20/get-windows-update-status-information-by-using-powershell/

#'Run it on the server (e.g. EBWSUS)
==========================================
$computerscope = New-Object Microsoft.UpdateServices.Administration.ComputerTargetScope

$updatescope = New-Object Microsoft.UpdateServices.Administration.UpdateScope

$wsus.GetSummariesPerComputerTarget($updatescope,$computerscope) |Format-Table @{L='ComputerTarget';E={($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).FullDomainName}}, @{L='NeededCount';E={($_.DownloadedCount + $_.NotInstalledCount)}},DownloadedCount,NotApplicableCount,NotInstalledCount,InstalledCoun

'OUTPUT
-----------------
ComputerTarget                                NeededCount             DownloadedCount          NotApplicableCount           NotInstalledCount InstalledCoun              
--------------                                -----------             ---------------          ------------------           ----------------- -------------              
it-1011.jphsa.org                                       4                           0                       75314                           4                            
lt-1070.jphsa.org                                      14                           0                       75482                          14                            
it-103606.jphsa.org                                     4                           0                       75503                           4                            
it-1008.jphsa.org                                       4                           0                       75270                           4                            
it-1081.jphsa.org                                       8                           1                       75010                           7                            
wug.jphsa.org                                           4                           0                       75431                           4                            
lt-103111.jphsa.org                                     5                           1                       75507                           4                            
it-1013.jphsa.org                                       4                           0                       75316                           4                            
lt-0954.jphsa.org                                       4                           0                       75298                           4                            
lt-1161.jphsa.org                                       5                           0                       75473                           5                            
it-0949.jphsa.org                                       4                           0                       75307                           4                            
it-1230.jphsa.org                                      40                           6                       75449                          34</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>GetSummariesPerUpdate_needed_download_NotApplicable_NotInstalled_Installed_Failed</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>GetSummariesPerUpdate_needed_download_NotApplicable_NotInstalled_Installed_Failed</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://blogs.technet.microsoft.com/heyscriptingguy/2012/01/20/get-windows-update-status-information-by-using-powershell/
==============================================================================================================

$updatescope.ApprovedStates = [Microsoft.UpdateServices.Administration.ApprovedStates]::NotApproved

$updatescope.IncludedInstallationStates = [Microsoft.UpdateServices.Administration.UpdateInstallationStates]::NotInstalled

$updatescope.FromArrivalDate = [datetime]"12/13/2011"   

$wsus.GetSummariesPerUpdate($updatescope,$computerscope) |  Format-Table @{L='UpdateTitle';E={($wsus.GetUpdate([guid]$_.UpdateId)).Title}}, @{L='NeededCount';E={($_.DownloadedCount + $_.NotInstalledCount)}},DownloadedCount,NotApplicableCount,NotInstalledCount,InstalledCount,FailedCount

'OUTPUT
-------------------

UpdateTitle                           NeededCount         DownloadedCount      NotApplicableCount       NotInstalledCount          InstalledCount             FailedCount
-----------                           -----------         ---------------      ------------------       -----------------          --------------             -----------
Definition Update for...                        2                       0                     117                       2                       0                       0
Update for Windows Se...                        1                       0                     145                       1                       4                       0
Windows Server Update...                        6                       0                     144                       6                       0                       0
Advanced Micro Device...                        1                       0                     149                       1                       0                       0
Definition Update for...                        1                       0                      79                       1                       0                       0
2018-06 Preview of Mo...                        5                       0                     134                       5                       0                       0
Update for Microsoft ...                        1                       0                     149                       1                       0                       0
Update for Microsoft ...                        1                       0                     149                       1                       0                       0
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-WindowsUpdate.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-WindowsUpdate.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://gallery.technet.microsoft.com/scriptcenter/Get-Installed-FailedWindows-9f28742a
============================================================================================

#'### Author Allenage.com ###

#'#### Remote Computers with server or ComputerName on Txt file ##

#'Get-WindowsUpdate_fromTextFile.ps1

$computers = get-Content c:\computers.txt
foreach ($computer in $computers){
if(!(Test-Connection -Cn $computer -BufferSize 16 -Count 1 -ea 0 -quiet))
{write-host "cannot reach $computer" -f red}

else {$Session = New-Object -ComObject "Microsoft.Update.Session"

$Searcher = $Session.CreateUpdateSearcher()

$historyCount = $Searcher.GetTotalHistoryCount()

$Searcher.QueryHistory(0, $historyCount) | Select-Object Date,

   @{name="Operation"; expression={switch($_.operation){

       1 {"Installation"}; 2 {"Uninstallation"}; 3 {"Other"}}}},

   @{name="Status"; expression={switch($_.resultcode){

       1 {"In Progress"}; 2 {"Succeeded"}; 3 {"Succeeded With Errors"};

       4 {"Failed"}; 5 {"Aborted"}

}}}, Title | Export-Csv -NoType "$Env:userprofile\Desktop\$computer-WindowsUpdates.csv"}}


#'### Enter Computer Name On Prompt to get installed Updates #####

$computers=[System.Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic') | Out-Null  
$computers= [Microsoft.VisualBasic.Interaction]::InputBox("Enter Computername")
foreach ($computer in $computers){
if(!(Test-Connection -Cn $computer -BufferSize 16 -Count 1 -ea 0 -quiet))
{write-host "cannot reach $computer" -f red}

else {$Session = New-Object -ComObject "Microsoft.Update.Session"

$Searcher = $Session.CreateUpdateSearcher()

$historyCount = $Searcher.GetTotalHistoryCount()

$Searcher.QueryHistory(0, $historyCount) | Select-Object Date,

   @{name="Operation"; expression={switch($_.operation){

       1 {"Installation"}; 2 {"Uninstallation"}; 3 {"Other"}}}},

   @{name="Status"; expression={switch($_.resultcode){

       1 {"In Progress"}; 2 {"Succeeded"}; 3 {"Succeeded With Errors"};

       4 {"Failed"}; 5 {"Aborted"}

}}}, Title | Export-Csv -NoType "$Env:userprofile\Desktop\$computer-WindowsUpdates.csv"}}



#'## get Local computers Windows Updates ######

$Session = New-Object -ComObject "Microsoft.Update.Session" 
 
$Searcher = $Session.CreateUpdateSearcher() 
 
$historyCount = $Searcher.GetTotalHistoryCount() 
 
$Searcher.QueryHistory(0, $historyCount) | Select-Object Date, 
 
   @{name="Operation"; expression={switch($_.operation){ 
 
       1 {"Installation"}; 2 {"Uninstallation"}; 3 {"Other"}}}}, 
 
   @{name="Status"; expression={switch($_.resultcode){ 
 
       1 {"In Progress"}; 2 {"Succeeded"}; 3 {"Succeeded With Errors"}; 
 
       4 {"Failed"}; 5 {"Aborted"} 
 
}}}, Title | Export-Csv -NoType "$Env:userprofile\Desktop\WindowsUpdates.csv"


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-WindowsUpdate_fromTextFile_v2.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-WindowsUpdate_fromTextFile_v2.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get-WindowsUpdate_fromTextFile_v2.ps1

$computers = get-Content c:\Data\computers.txt
foreach ($computer in $computers){

    if(!(Test-Connection -Cn $computer -BufferSize 16 -Count 1 -ea 0 -quiet))
            {write-host "cannot reach $computer" -f red}

else {$Session = New-Object -ComObject "Microsoft.Update.Session"

        $Searcher = $Session.CreateUpdateSearcher()

        $historyCount = $Searcher.GetTotalHistoryCount()

        $Searcher.QueryHistory(0, $historyCount) | Select-Object Date,

           @{
                name="Operation"; expression={switch($_.operation){

                                                                    1 {"Installation"}; 
                                                                    2 {"Uninstallation"}; 
                                                                    3 {"Other"} 
                                                                }
                                           }
            },

           @{
                name="Status"; expression={switch($_.resultcode){

                                                                    1 {"In Progress"}; 
                                                                    2 {"Succeeded"}; 
                                                                    3 {"Succeeded With Errors"};
                                                                    4 {"Failed"}; 
                                                                    5 {"Aborted"}

                                                                 }
                                           }
           }, Title | Export-Csv -NoType "c:\Data\$computer-WindowsUpdates.csv"}
    }</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>ListOfComputers_SummaryOfStatus.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>ListOfComputers_SummaryOfStatus.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'ListOfComputers_SummaryOfStatus.ps1
 

[void][reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")
$wsus = [Microsoft.UpdateServices.Administration.AdminProxy]::getUpdateServer()

$computerscope = New-Object Microsoft.UpdateServices.Administration.ComputerTargetScope

$updatescope = New-Object Microsoft.UpdateServices.Administration.UpdateScope


$filename = "$(Get-Date -Format "yyyy_M_d_h_m_s")-ComputerStatusSummary.csv"

$wsus.GetSummariesPerComputerTarget($updatescope,$computerscope) | SELECT @{L='ComputerTarget';E={($wsus.GetComputerTarget([guid]$_.ComputerTargetId)).FullDomainName}}, @{L='NeededCount';E={($_.DownloadedCount + $_.NotInstalledCount)}},DownloadedCount,NotApplicableCount,NotInstalledCount,InstalledCount | Export-Csv -Append -NoType -Path "$Env:userprofile\Desktop\PS\$filename"

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PendingUpdates_GetList</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PendingUpdates_GetList</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>This is just to see what updates I have pending on my workstation

'Finding Pending Updates Using PowerShell
'https://mcpmag.com/articles/2016/06/23/finding-pending-updates.aspx
=======================================================================
#'We can't easily see what updates are currently available on a system 
#'    'unless we go into the Windows Updates settings and view the updates 
#'    or we can query the event log to see what updates have been downloaded 
#'    and are waiting to install. 
#'I am going with a different approach by directly going into the windows update agent 
#'    via its API to search for and report on downloaded updates that are waiting to be installed.  
#'To do this, I am going to make use of Microsoft.Update.Session COM object 
#'    to get our foot in the door to begin hunting down pending updates.

$Computername = $env:COMPUTERNAME
$updatesession =  [activator]::CreateInstance([type]::GetTypeFromProgID("Microsoft.Update.Session",$Computername))

#'In this case, I am just going to look at my local system for updates. 
#'    Because I want to have something that will work remotely, 
#'    I am choosing to use the [Activator] with its CreateInstance() method 
#'    and supplying the type that I am looking to connect to remotely as well as supplying the computer name. 
#'By doing this, I will have created my UpdateSearcher object that will be used to look for updates.
#'
#'Once I have this created, 
#'    I can then begin a search using the Search() method and supplying a string which contains a specific query. 
#'More information about what kinds of queries you can perform can be found at this MSDN link. 
#'Note that the following code may take a few minutes to run.
#'
$searchresult = $updatesearcher.Search("IsInstalled=0")  #' 0 = NotInstalled | 1 = Installed 

#'In this case, 
#'    I am only looking for updates that are not currently installed. 
#'    Now I cannot query whether an update has been downloaded or not, 
#'    so I will need to deal with that later on. 
#'Once completed, we can get an idea on how many updates are available 
#'    by looking at the count of the results returned for updates.
#'
$searchresult.Updates.Count

========'all the pieces 
$Computername = $env:COMPUTERNAME
$updatesession = [activator]::CreateInstance([type]::GetTypeFromProgID("Microsoft.Update.Session",$Computername))
$UpdateSearcher = $updatesession.CreateUpdateSearcher()
$searchresult = $updatesearcher.Search("IsInstalled=0") # 0 = NotInstalled | 1 = Installed 
$searchresult.Updates.Count

-------------------------------------------------------------------------
'Since I do have updates which are available and not yet installed, 
'	it is time to take a look and see what they are.

-------------------------------------------------------------------------
$Updates = If ($searchresult.Updates.Count  -gt 0) {

  #Updates are  waiting to be installed

  $count  = $searchresult.Updates.Count

  Write-Verbose  "Found $Count update\s!"

  #Cache the  count to make the For loop run faster   

  For ($i=0; $i -lt $Count; $i++) {

  #Create  object holding update

  $Update  = $searchresult.Updates.Item($i)

  [pscustomobject]@{

  Title =  $Update.Title

  KB =  $($Update.KBArticleIDs)

  SecurityBulletin = $($Update.SecurityBulletinIDs)

  MsrcSeverity = $Update.MsrcSeverity

  IsDownloaded = $Update.IsDownloaded

  Url =  $Update.MoreInfoUrls

  Categories =  ($Update.Categories  | Select-Object  -ExpandProperty Name)

  BundledUpdates = @($Update.BundledUpdates)|ForEach{

  [pscustomobject]@{

  Title = $_.Title

  DownloadUrl = @($_.DownloadContents).DownloadUrl

  }

  }

  }      

  }

  } 
========================================================================


$Updates = If ($searchresult.Updates.Count -gt 0) {
                                                    #'Updates are waiting to be installed
                                                    $count = $searchresult.Updates.Count
                                                    Write-Verbose "Found $Count update\s!"
                                                    #'Cache the count to make the For loop run faster 
                                                    For ($i=0; $i -lt $Count; $i++) {
                                                                                    #'Create object holding update
                                                                                    $Update = $searchresult.Updates.Item($i)
                                                                                    [pscustomobject]@{
                                                                                                    Title = $Update.Title
                                                                                                    KB = $($Update.KBArticleIDs)
                                                                                                    SecurityBulletin = $($Update.SecurityBulletinIDs)
                                                                                                    MsrcSeverity = $Update.MsrcSeverity
                                                                                                    IsDownloaded = $Update.IsDownloaded
                                                                                                    Url = $Update.MoreInfoUrls
                                                                                                    Categories = ($Update.Categories | Select-Object -ExpandProperty Name)
                                                                                                    BundledUpdates = @($Update.BundledUpdates)|ForEach{
                                                                                                                                                        [pscustomobject]@{
                                                                                                                                                                            Title = $_.Title
                                                                                                                                                                            DownloadUrl = @($_.DownloadContents).DownloadUrl
                                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                    } 
                                                                                    }
                                                    }

#' Then to see the results

$IsDownloaded = $Updates|group IsDownloaded

#Index 1 is downloaded updates 

$IsDownloaded[1].Group

#'$IsDownloaded[1].Group[1]

$IsDownloaded[1].Group[1].BundledUpdates|Format-List 

$IsDownloaded[1].Group  | Export-Csv -NoTypeInformation  -Path DownloadedUpdates.csv </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Run-DeclineUpdate-CleanupV3.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Run-DeclineUpdate-CleanupV3.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Decline Updates Script by Jeff Carreon
'https://www.mnscug.org/images/carryon/Run-DeclineUpdate-Cleanup.zip

'By default the script run in “What-If” mode ($TrialRun set to $True). 
'Here is a syntax to run it in declining mode, without sending an email report:  
.\Run-DeclineUpdate-CleanupV3.ps1 -Servers CM01 –TrialRun:$false –EmailReport:$false

=================================================================================================
#'Run-DeclineUpdate-CleanupV3.ps1

&lt;#
.SYNOPSIS
	Script is for declining superseeded, Itanium Updates, XP, Preview, Beta, ARM64, IE7, IE8, IE9, IE10, Win10 Next, Server Next, and Embedded Updates in WSUS/SUP environment.
	
	Recommend running this monthly...  
	Run the scripts targetting the bottom or downstreams servers (bottom SUPs), then run it against the upstream server (Top SUP)...
	BE AWARE:  
		The XP function may grab Windows 2008 R2 articles.   
		I HIGHLY recommend do a -TrialRun first, and examine the results before executing this in prod environment.  By default, this is set to true, see param section.
	

.DESCRIPTION
	Script is designed to decline all of the updates that have been superseded for over 90 days, by default.  This can be adjusted in param section.
	
	# $Servers					= Specify the target servers as default target(s) for automation.  Or, can be specified manually at run time.
	# $UseSSL                   = Specify whether WSUS Server is configured to use SSL
	# $Port                     = Specify WSUS Server Port (Hard coded in param section, though this can be specified otherwise)
	# $TrialRun		            = Specify this to do a test run and get a summary of how many superseded updates, Itanium Updates, XP, Preview, Beta, Win10 Next, Server Next, ARM64, IE7, IE8, IE9, IE10, and Embedded Updates there are that can be declined.  It records to .csv and htm file
	# $DeclineLastLevelOnly     = Specify whether to decline all superseded updates or only last level superseded updates
									**For example, Update1 supersedes Update2. Update2 supersedes Update3. In this scenario, the Last Level in the supersedence chain is Update3. 
									**To decline only the last level updates in the supersedence chain, specify the DeclineLastLevelOnly switch
	# $ExclusionPeriod          = Specify the number of days between today and the release date for which the superseded updates must not be declined. Eg, if you want to keep superseded updates published within the last 2 months, specify a value of 60 (days)
	# $SkipItanium				= Specify this to skip declining Itanium updates.
	# $SkipXP					= Specify this to skip declining Windows XP updates.  
	# $SkipPrev					= Specify this to skip declining Windows Preview updates.  
	# $SkipBeta					= Specify this to skip declining Windows Beta updates.
	# $SkipWin10Next			= Specify this to skip declining Windows 10 Next updates.
	# $SkipServerNext			= Specify this to skip declining Windows Server Next updates.
	# $SkipArm64				= Specify this to skip declining ARM64-based updates.
	# $SkipIE7					= Specify this to skip declining Windows IE7 updates.
	# $SkipIE8					= Specify this to skip declining Windows IE8 updates. Default is $true
	# $SkipIE9					= Specify this to skip declining Windows IE9 updates. Default is $true
	# $SkipIE10					= Specify this to skip declining Windows IE10 updates. Default is $true
	# $SkipEmbedded				= Specify this to skip declining Windows Embedded updates.
	
	# $CleanUpdatelist			= Specify whether to clean the UpdateList folders/files to prevent build up. Default is $true
	# $CleanULNumber			= Specify the number of days old folders/files to keep in UpdateList folder

.NOTE
	$DeclineLastLevelOnly &amp; $trial CANNOT be used at the same time.
	Script will create custom application "CMSDKPosh" Eventlog for storing events below
		EventID 21020 = Successful Run
		EventID 21021 = Error running the main function
		EventID 21031 = Error running either the Decline superseded or itanium function
	
	Updates 4/25/2018: 
		- Added Decline updates for Win10 Next, and Server Next
        - Added email reporting and logging
		- Perfomance improvement on querying updates
	
	Updates 5/10/2018: 
		- Added Decline updates for ARM64-Based, and IE 10
        - Added Clean Update List maintnance function (optional), deletes files/folders that are # of days old.
		- Fixed error handling on querying for updates.
		- Perfomance improvement
	
	Jeff Carreon's Hack job :)
	Updated: 5/10/2018
	v.4
#&gt;

[CmdletBinding()]
Param(
	
    # Define lower tier SUP servers first, then TOP WSUS/SUP server last in this array
    $Servers = @("&lt;lowerSUPServer1&gt;","&lt;lowerSUPServer2&gt;","&lt;topSUPServer&gt;"),	

	[bool]$UseSSL = $False,
	
	[int]$PortNumber = 8530,
	
    [switch] $TrialRun = $true,
	
    [switch] $DeclineLastLevelOnly,
	
    [Parameter(Mandatory=$False)]
    [int] $ExclusionPeriod = 90,

    [switch] $SkipItanium,
	
	[switch] $SkipXP,
	
	[switch] $SkipPrev,
	
	[switch] $SkipBeta,

	[switch] $SkipWin10Next,
	
	[switch] $SkipServerNext,
	
	[switch] $SkipIE7,
	
	[switch] $SkipIE8 = $true,
	
	[switch] $SkipIE9 = $true,
	
	[switch] $SkipIE10 = $true,
	
	[switch] $SkipEmbedded,

    [switch] $SkipArm64,

	[bool]$EmailReport = $true,
	
	[string]$SMTPServer = "smtp.domain.com",
	
	[string]$From = "CMautomation@domain.com",
	
	[string[]]$To = "support@domain.com,yourmanager@domain.com",
	
	[string]$Subject = "WSUS/SUP Decline Updates Report",

    [string]$ReportTitle = "WSUS/SUP Decline Updates Maintenance Task"
	
	# UpdateList Folder maintenance
	[switch] $CleanUpdatelist = $true,
	
	# Define # of days old before it Cleans Update list files and folders
	[int]$CleanULNumber = 90

)



$EventSource = "WSUS Decline Maintenance"
$Eventlog = "CMSDKPosh"
$td = (get-date -uformat %m-%d-%y)
$path = Get-Location
$scriptName = $MyInvocation.MyCommand.Name
$ul = "UpdatesList"
$ulpath = "$path\" + "$ul\" + "$td"
$Overallhtmfile = "$ulpath\" + "_OverallCountsSummary-$td.htm"

#$script:CurrentErrorActionPreference = $ErrorActionPreference
#$ErrorActionPreference = "SilentlyContinue"
$CStyle = "&lt;Style&gt;BODY{font-size:12px;font-family:verdana,sans-serif;color:navy;font-weight:normal;}" + `
			"TABLE{border-width:1px;cellpadding=10;border-style:solid;border-color:navy;border-collapse:collapse;}" + `
			"TH{font-size:12px;border-width:1px;padding:10px;border-style:solid;border-color:navy;}" + `
			"TD{font-size:10px;border-width:1px;padding:10px;border-style:solid;border-color:navy;}&lt;/Style&gt;"



[String]$LogFile = "$path\" + $($((Split-Path $MyInvocation.MyCommand.Definition -leaf)).replace("ps1","log")) #Name and Location of LogFile


if ([System.Diagnostics.EventLog]::SourceExists('WSUS Decline Maintenance') -ne "True")
{
    New-EventLog -LogName $Eventlog -Source $EventSource
}

 Write-EventLog -LogName $Eventlog -EventID 21020 -Message "Run-DeclineCleanup Script has started." -Source $EventSource -EntryType Information

If($TrialRun){$Subject += " Trial Run"}
Function SendEmailStatus($From, $To, $Subject, $SMTPServer, $BodyAsHtml, $Body)
{	
    $SMTPMessage = New-Object System.Net.Mail.MailMessage $From, $To, $Subject, $Body
	$SMTPMessage.IsBodyHTML = $BodyAsHtml
	$SMTPClient = New-Object Net.Mail.SMTPClient($SMTPServer)
    $SMTPClient.Send($SMTPMessage)
	If($? -eq $False){Write-Warning "$($Error[0].Exception.Message) | $($Error[0].Exception.GetBaseException().Message)"}
	$SMTPMessage.Dispose()
	rv SMTPClient
	rv SMTPMessage
}

Function Write-toFile{
    &lt;#
    .SYNOPSIS
        Writing information to file
    .DESCRIPTION
        Function to write information to file
    #&gt;    
    Param ([string]$WriteLine)
    Out-File $XMLFile -encoding utf8 -input $WriteLine -append   
    Write-Host $WriteLine
}

Function Write-ToLog([string]$message, [string]$file) {
    &lt;#
    .SYNOPSIS
        Writing log to the logfile
    .DESCRIPTION
        Function to write logging to a logfile. This should be done in the End phase of the script.
    #&gt;
    If(-not($file)){$file=$LogFile}        
    $Date = $(get-date -uformat %Y-%m-%d-%H.%M.%S)
    $message = "$Date | `t$message"
    Write-Verbose $message
    Write-Host $message
    #Write Log to log file Without ASCII not able to read with tracer.
    Out-File $file -encoding ASCII -input $message -append
}

Function GetSuperSededList {

	$Script:countAllUpdates = 0
	$Script:countSupersededAll = 0
	$Script:countSupersededLastLevel = 0
	$Script:countSupersededExclusionPeriod = 0
	$Script:countSupersededLastLevelExclusionPeriod = 0
	$Script:countDeclined = 0
	
    $Prop = [ordered]@{}
    $ErrorActionPreference = "Stop"
    foreach($update in $allUpdates)
    {
    
        $Script:countAllUpdates++
    
        if ($update.IsDeclined) {
            $Script:countDeclined++
        }
    
        if (!$update.IsDeclined -and $update.IsSuperseded) {
            $Script:countSupersededAll++
        
            if (!$update.HasSupersededUpdates) {
                $Script:countSupersededLastLevel++
            }
			###################
            if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
				#"$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededExList -Append 
                "$($update.Title), $($update.KnowledgeBaseArticles), $($update.ArrivalDate), $($update.SecurityBulletins), $($update.UpdateClassificationTitle), $($update.ProductTitles), $($update.HasSupersededUpdates)" | Out-File $outSupersededExList -Append
		        $Script:countSupersededExclusionPeriod++
			    if (!$update.HasSupersededUpdates) {
				    $Script:countSupersededLastLevelExclusionPeriod++
			    }
            }		
        
            "$($update.Id.UpdateId.Guid), $($update.Id.RevisionNumber), $($update.Title), $($update.KnowledgeBaseArticles), $($update.ArrivalDate), $($update.SecurityBulletins), $($update.HasSupersededUpdates)" | Out-File $outSupersededList -Append       
        
            $Prop.Title = [string]$update.Title
            $Prop."KB Article" = [string]$update.KnowledgeBaseArticles
            $Prop."Arrival Date" = [string]$update.ArrivalDate
            $Prop.Classification = [string]$update.UpdateClassificationTitle
            $Prop."Product Title" = [string]$update.ProductTitles
            $Prop."Has Superseded Updates" = [string]$update.HasSupersededUpdates
               
            New-Object PSObject -property $Prop
        }
     }
     
}

Function Decline-Superseded{
	#Write-ToLog ""
    
    Write-ToLog ""
    Write-ToLog "$WsusServer is starting Decline-SupersededUpdates function..."

	"UpdateID, RevisionNumber, Title, KBArticle, ArrivalDate, SecurityBulletin, LastLevel" | Out-File $outSupersededList
    "Title, KBArticle, ArrivalDate, SecurityBulletin, UpdateClassificationTitle, ProductTitles, HasSupersededUpdates" | Out-File $outSupersededExList


##########################

    GetSuperSededList | ConvertTo-HTML -head $CStyle | Out-File $outSupersededHTM
    

	Write-ToLog "Done."
	if ($csv){Write-ToLog "List of superseded updates: $outSupersededList"}
	Write-ToLog "List of Superseded Updates: $outSupersededHTM"

	Write-ToLog ""
	Write-ToLog "Superseded Summary:"
	Write-ToLog "========"
	Write-ToLog "All Updates = $countAllUpdates"
	Write-ToLog "Any except Declined = ($countAllUpdates - $countDeclined)"
	Write-ToLog "All Superseded Updates = $countSupersededAll"
	Write-ToLog "    Superseded Updates (Intermediate) = ($countSupersededAll - $countSupersededLastLevel)"
	Write-ToLog "    Superseded Updates (Last Level) = $countSupersededLastLevel"
	Write-ToLog "    Superseded Updates (Older than $ExclusionPeriod days) = $countSupersededExclusionPeriod"
	Write-ToLog "    Superseded Updates (Last Level Older than $ExclusionPeriod days) = $countSupersededLastLevelExclusionPeriod"
	Write-ToLog ""

	$i = 0
	if (!$TrialRun) {
	    
	    Write-ToLog "TrialRun flag is set to $TrialRun. Continuing with declining updates"
	    $updatesDeclined = 0
	    
	    if ($DeclineLastLevelOnly) {
	        Write-ToLog "  DeclineLastLevel is set to True. Only declining last level superseded updates." 
	        
	        foreach ($update in $allUpdates) {
	            
	            if (!$update.IsDeclined -and $update.IsSuperseded -and !$update.HasSupersededUpdates) {
	              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {
				    $i++
					$percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededLastLevelExclusionPeriod) * 100)
					Write-Progress -Activity "Declining Updates" -Status "Declining update #$i/$countSupersededLastLevelExclusionPeriod - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
					
	                try 
	                {
	                    $update.Decline()                    
	                    $updatesDeclined++
	                }
	                catch [System.Exception]
	                {
	                    Write-ToLog "$WsusServer failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
	                    Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer failed to decline update $($update.Id.UpdateId.Guid). Error: $error[0]" -Source $EventSource -EntryType Error
	                } 
	              }             
	            }
	        }        
	    }
	    else {
	        Write-ToLog "  DeclineLastLevel is set to False. Declining all superseded updates."
	        
	        foreach ($update in $allUpdates) {
	            
	            if (!$update.IsDeclined -and $update.IsSuperseded) {
	              if ($update.CreationDate -lt (get-date).AddDays(-$ExclusionPeriod))  {   
				  	
					$i++
					$percentComplete = "{0:N2}" -f (($updatesDeclined/$countSupersededAll) * 100)
					Write-Progress -Activity "Declining Updates" -Status "Declining update #$i/$countSupersededAll - $($update.Id.UpdateId.Guid)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
	                try 
	                {
	                    $update.Decline()
	                    $updatesDeclined++
	                }
	                catch [System.Exception]
	                {
	                    Write-Host "$WsusServer failed to decline update $($update.Id.UpdateId.Guid). Error:" $_.Exception.Message
	                    Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer failed to decline update $($update.Id.UpdateId.Guid). Error: $error[0]" -Source $EventSource -EntryType Error
	                }
	              }              
	            }
	        }   
	        
	    }
	    
	    Write-ToLog "  Declined $updatesDeclined updates."
	    #if ($updatesDeclined -ne 0) {
	    #    Copy-Item -Path $outSupersededList -Destination $outSupersededListBackup -Force
		#	Write-ToLog "  Backed up list of superseded updates to $outSupersededListBackup"
	    #}
	    
	}
	else {
	    Write-ToLog "TrialRun flag is set to $TrialRun. Skipped declining updates"
	
    if(Test-Path $outSupersededExList){ Import-csv $outSupersededExList | ConvertTo-HTML -head $table | Out-File $outSupersededExHTM}

    }
    
}

Function Decline-Itanium{


	Write-ToLog "$WsusServer is starting Decline-WsusItaniumUpdates function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."

    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Itanium updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}


    Write-ToLog "Searching for Itanium updates..."
	#$ItaniumUpdates = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match “ia64|itanium”}
	
	$ItaniumUpdates = $GrabUpdates | where-object {$_.Title -match "ia64|itanium"}
	$script:Itancount = $ItaniumUpdates.count
	
	If($ItaniumUpdates)
	{
		Write-ToLog "Found $script:Itancount Itanium Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Itanium Updates...";$ItaniumUpdates | %{$_.Decline()}}Else{Write-ToLog "Recording Itanium Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$ItaniumUpdates | Select $Table
            $ItaniumUpdates | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IThtmfile
            If(!$TrialRun){Write-ToLog "List of Itanium updates declined: $IThtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Itanium updates that could be declined: $IThtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Itanium Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Itanium Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Itanium Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-XPUpdates{



	Write-ToLog "$WsusServer is starting Decline-XPUpdates function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."



    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Windows XP updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Windows XP updates..."
	#$XPUpdates = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Windows XP"}
	$XPUpdates = $GrabUpdates | where-object {$_.Title -match "Windows XP"}
	$Script:XPcount = $XPUpdates.count	
	
	If($XPUpdates)
	{
		Write-ToLog "Found $Script:XPcount Windows XP Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Windows XP Updates...";$XPUpdates | %{$_.Decline()}}Else{Write-ToLog "Recording Windows XP Updates..."}
            $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$XPUpdates | Select $Table
            $XPUpdates | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $XPhtmfile
            If(!$TrialRun){Write-ToLog "List of Windows XP updates declined: $XPhtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Windows XP updates that could be declined: $XPhtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Windows XP Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Windows XP Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Windows XP Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-Preview{

	Write-ToLog "$WsusServer is starting Decline-Preview function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Preview updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Preview updates..."
	#$Prev = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Preview"}
	$Prev = $GrabUpdates | where-object {$_.Title -match "Preview"}
	$Script:Prevcount = $Prev.count	
	
	If($Prev)
	{
		Write-ToLog "Found $Script:Prevcount Preview Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Preview Updates...";$Prev | %{$_.Decline()}}Else{Write-ToLog "Recording Preview Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Prev | Select $Table
            $Prev | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Prevhtmfile
            If(!$TrialRun){Write-ToLog "List of Preview updates declined: $Prevhtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Preview updates that could be declined: $Prevhtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Preview Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Preview Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Preview Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-Beta{
	

	Write-ToLog "$WsusServer is starting Decline-Beta function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Beta updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Beta updates..."
	#$Beta= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Beta"}
	$Beta = $GrabUpdates | where-object {$_.Title -match "Beta"}
	$Script:Betacount = $Beta.count	
	
	If($Beta)
	{
		Write-ToLog "Found $Script:Betacount Beta Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Beta Updates...";$Beta | %{$_.Decline()}}Else{Write-ToLog "Recording Beta Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Beta | Select $Table
            $Beta | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Betahtmfile
            If(!$TrialRun){Write-ToLog "List of Beta updates declined: $Betahtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Beta updates that could be declined: $Betahtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Beta Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Beta Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Beta Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-Win10Next{
	
	Write-ToLog "$WsusServer is starting Decline-Win10Next function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Windows 10 Next updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Windows 10 Next updates..."
	#$Win10Next = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Windows 10 Version Next"}
	$Win10Next = $GrabUpdates | where-object {$_.Title -match "Windows 10 Version Next"}
	$Script:Win10Nextcount = $Win10Next.count	
	
	If($Win10Next)
	{
		Write-ToLog "Found $Script:Win10Nextcount Windows 10 Next Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Windows 10 Next Updates...";$Win10Next | %{$_.Decline()}}Else{Write-ToLog "Recording Windows 10 Next Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Win10Next | Select $Table
            $Win10Next | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Win10Nexthtmfile
            If(!$TrialRun){Write-ToLog "List of Windows 10 Next updates declined: $Win10Nexthtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Windows 10 Next updates that could be declined: $Win10Nexthtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Windows 10 Next Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Windows 10 Next Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Windows 10 Next Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-ServerNext{
	$Script:ServerNextcount = 0
	Write-ToLog "$WsusServer is starting Decline-ServerNext function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Windows Server Next updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Windows Server Next updates..."
	#$ServerNext = $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Windows Server Next"}
	$ServerNext = $GrabUpdates | where-object {$_.Title -match "Windows Server Next"}
	$Script:ServerNextcount = $ServerNext.count	
	
	If($ServerNext)
	{
		Write-ToLog "Found $Script:ServerNextcount Windows Server Next Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Windows Server Next Updates...";$ServerNext | %{$_.Decline()}}Else{Write-ToLog "Recording Windows Server Next Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Next | Select $Table
            $ServerNext | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $ServerNexthtmfile
            If(!$TrialRun){Write-ToLog "List of Windows Server Next updates declined: $ServerNexthtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Windows Server Next updates that could be declined: $ServerNexthtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Windows Server Next Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Windows Server Next Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Windows Server Next Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-IE7{
	
	
	
	Write-ToLog "$WsusServer is starting Decline-IE7 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all IE7 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for IE7 updates..."
	#$IE7= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Internet Explorer 7"}
	$IE7 = $GrabUpdates | where-object {$_.Title -match "Internet Explorer 7"}
	$Script:IE7count = $IE7.count	
	
	If($IE7)
	{
		Write-ToLog "Found $Script:IE7count IE7 Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining IE7 Updates...";$IE7 | %{$_.Decline()}}Else{Write-ToLog "Recording IE7 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$IE7 | Select $Table
            $IE7 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IE7htmfile
            If(!$TrialRun){Write-ToLog "List of IE7 updates declined: $IE7htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of IE7 updates that could be declined: $IE7htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline IE7 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline IE7 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No IE7 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-IE8{

	Write-ToLog "$WsusServer is starting Decline-IE8 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all IE8 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for IE8 updates..."
	#$IE8= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Internet Explorer 8"}
	$IE8 = $GrabUpdates | where-object {$_.Title -match "Internet Explorer 8"}
	$Script:IE8count = $IE8.count	
	
	If($IE8)
	{
		Write-ToLog "Found $Script:IE8count IE8 Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining IE8 Updates...";$IE8 | %{$_.Decline()}}Else{Write-ToLog "Recording IE8 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$IE8 | Select $Table
            $IE8 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IE8htmfile
            If(!$TrialRun){Write-ToLog "List of IE8 updates declined: $IE8htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of IE8 updates that could be declined: $IE8htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline IE8 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline IE8 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No IE8 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-IE9{

	Write-ToLog "$WsusServer is starting Decline-IE9 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all IE9 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for IE9 updates..."
	#$IE9= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Internet Explorer 9"}
	$IE9 = $GrabUpdates | where-object {$_.Title -match "Internet Explorer 9"}
	$Script:IE9count = $IE9.count	
	
	If($IE9)
	{
		Write-ToLog "Found $Script:IE9count IE9 Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining IE9 Updates...";$IE9 | %{$_.Decline()}}Else{Write-ToLog "Recording IE9 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$IE9 | Select $Table
            $IE9 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IE9htmfile
            If(!$TrialRun){Write-ToLog "List of IE9 updates declined: $IE9htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of IE9 updates that could be declined: $IE9htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline IE9 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline IE9 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No IE9 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-Embedded{

	Write-ToLog "$WsusServer is starting Decline-Embedded function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all Embedded updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for Embedded updates..."
	#$Embedded= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined -and $_.Title -match "Embedded"}
	$Embedded = $GrabUpdates | where-object {$_.Title -match "Embedded"}
	$Script:Embeddedcount = $Embedded.count	
	
	If($Embedded)
	{
		Write-ToLog "Found $Script:Embeddedcount Embedded Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining Embedded Updates...";$Embedded | %{$_.Decline()}}Else{Write-ToLog "Recording Embedded Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$Embedded | Select $Table
            $Embedded | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Embhtmfile
            If(!$TrialRun){Write-ToLog "List of Embedded updates declined: $Embhtmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of Embedded updates that could be declined: $Embhtmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline Embedded Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline Embedded Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No Embedded Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-ARM64{

	Write-ToLog "$WsusServer is starting Decline-ARM64 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all ARM64 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for ARM64 updates..."
	$Arm64 = $GrabUpdates | where-object {$_.Title -match "ARM64"}
	$Script:Arm64count = $Arm64.count	
	
	If($Arm64)
	{
		Write-ToLog "Found $Script:Arm64count ARM64-Based Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining ARM64 Updates...";$ARM64 | %{$_.Decline()}}Else{Write-ToLog "Recording ARM64 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$ARM64 | Select $Table
            $ARM64 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Arm64htmfile
            If(!$TrialRun){Write-ToLog "List of ARM64 updates declined: $Arm64htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of ARM64 updates that could be declined: $Arm64htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline ARM64 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline ARM64 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No ARM64 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function Decline-IE10{

	Write-ToLog "$WsusServer is starting Decline-IE10 function..... Please wait...."
    #Write-ToLog "Connecting to $WSUSserver..."


    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all IE10 updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}

    Write-ToLog "Searching for IE10 updates..."
	$IE10 = $GrabUpdates | where-object {$_.Title -match "Internet Explorer 10"}
	$Script:IE10count = $IE10.count	
	
	If($IE10)
	{
		Write-ToLog "Found $Script:IE10count IE10 Updates..."
	    Try
	    {
	        If(!$TrialRun){Write-ToLog "Declining IE10 Updates...";$IE10 | %{$_.Decline()}}Else{Write-ToLog "Recording IE10 Updates..."}
		    $Table = @{Name="Title";Expression={[string]$_.Title}},`
			    @{Name="KB Article";Expression={[string]$_.KnowledgebaseArticles}},`
			    @{Name="Arrival Date";Expression={[string]$_.ArrivalDate}},`
                @{Name="Classification";Expression={[string]$_.UpdateClassificationTitle}},`
			    @{Name="Product Title";Expression={[string]$_.ProductTitles}},`
			    @{Name="Product Family";Expression={[string]$_.ProductFamilyTitles}}
		    #$IE10 | Select $Table
            $IE10 | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $IE10htmfile
            If(!$TrialRun){Write-ToLog "List of IE10 updates declined: $IE10htmfile"; Write-ToLog ""}
			Else{Write-ToLog "List of IE10 updates that could be declined: $IE10htmfile"; Write-ToLog ""}

	    }
	    Catch
	    {
	        Write-EventLog -LogName $Eventlog -EventID 21031 -Message "$WsusServer is unable to Decline IE10 Updates. Error: $error[0]" -Source $EventSource -EntryType Error
            Write-ToLog "$WsusServer is unable to Decline IE10 Updates. Error: $error[0]"
	    }
	}
	Else
	{
        Write-ToLog ""
        Write-ToLog "    No IE10 Updates found that needed declining at this time..."
        Write-ToLog ""
    }
	$ErrorActionPreference = $script:CurrentErrorActionPreference

}

Function UpdateListMaint{

	Write-ToLog "CleanUpdatelist is set to $CleanUpdatelist.  Cleaning the UpdateList folder."
	Write-ToLog "Deleting $CleanULNumber days old files and containers."
	Try{
		get-childitem -Path $ulpath -recurse | where-object {$_.lastwritetime -lt (get-date).addDays(-$CleanULNumber)} | Foreach-Object { remove-item $_.FullName -force -recurse}
		get-ChildItem $ulpath -recurse | Where-Object {$_.PSIsContainer -eq $True} | Where-Object {$_.GetFiles().Count -eq 0} | Foreach-Object { remove-item $_.FullName -recurse}
		Write-ToLog "Successfully removed files that are older than $CleanULNumber."
	}
	Catch
	{
		Write-ToLog "Failed to clean the UpdateList files/folder. Error: $Error[0]"
        Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Failed to clean the UpdateList files/folder. Error: $Error[0]" -Source $EventSource -EntryType Error
	    Write-ToLog "Please check the files manually."
		If($EmailReport)
			{	$Body = ConvertTo-Html -head $CStyle -Body "Failed to clean the UpdateList files/folder. Error: $Error[0].  Please check the files manually." | Out-String
				$Body = $Body.Replace("&lt;table&gt;`r`n&lt;/table&gt;", "")
				SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
				Write-ToLog "Sending Mail..."
			}

	}

}

############## Main Script ###############

Write-ToLog "####### Starting the $scriptName Script #######"
Write-ToLog ""
Write-ToLog "..."
if ($TrialRun -and $DeclineLastLevelOnly) {
    Write-ToLog "Using TrialRun and DeclineLastLevelOnly switches together is not allowed."
	Write-ToLog ""
    Write-ToLog "Exiting..."
    Exit
}

If (!(Test-Path -path $ulpath)){ New-Item -ItemType Directory $ulpath -force | Out-null }


$jeffobjects = Foreach ($WsusServer in $servers)
{
	
    $error.clear()
    $StartScript = Get-Date

    $outSupersededList = "$ulpath\" + "AllSupersededUpdates-$WsusServer.csv"
    $outSupersededListBackup = "$ulpath\" + "SupersededUpdatesBackup-$WsusServer.csv"
	$outSupersededExList = "$ulpath\" + "SupersededUpdates-Over-$ExclusionPeriod-$WsusServer.csv"
    $outSupersededExHTM = "$ulpath\" + "SupersededUpdates-Over-$ExclusionPeriod-$WsusServer.htm"
    $outSupersededHTM = "$ulpath\" + "AllSupersededUpdates-$WsusServer.htm"
    $IThtmfile = "$ulpath\" + "Itanium-Updates-$WsusServer.htm"
    $XPhtmfile = "$ulpath\" + "XP-Updates-$WsusServer.htm"
	$Prevhtmfile = "$ulpath\" + "Preview-$WsusServer.htm"
	$Betahtmfile = "$ulpath\" + "Beta-$WsusServer.htm"
	$Win10Nexthtmfile = "$ulpath\" + "Win10Next-$WsusServer.htm"
	$ServerNexthtmfile = "$ulpath\" + "ServerNext-$WsusServer.htm"
	$IE7htmfile = "$ulpath\" + "IE7-$WsusServer.htm"
	$IE8htmfile = "$ulpath\" + "IE8-$WsusServer.htm"
	$IE9htmfile = "$ulpath\" + "IE9-$WsusServer.htm"
	$IE10htmfile = "$ulpath\" + "IE10-$WsusServer.htm"
	$Embhtmfile = "$ulpath\" + "Embedded-$WsusServer.htm"
    $Arm64htmfile = "$ulpath\" + "Arm64-$WsusServer.htm"
    
	Function SendMail
	{
			If($EmailReport)
				{	$Body = ConvertTo-Html -head $CStyle -Body "Error on $WsusServer. Error: $Error[0]" | Out-String
					SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
					Write-ToLog "Sending Mail..."
				}
	}
	
    $Props = [ordered]@{}
	
	try {
	    
	    if ($UseSSL) {
	        Write-ToLog "Connecting to WSUS server $WsusServer on Port $PortNumber using SSL... "
	    } Else {
	        Write-ToLog "Connecting to WSUS server $WsusServer on Port $PortNumber... "
	    }
	    
	    [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") | out-null
	    $WsusServerAdminProxy = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($WsusServer,$UseSSL,$PortNumber);
		

	}
	catch [System.Exception] 
	{
	    $err1 = $_.Exception.Message
		Write-ToLog "Failed to connect $WsusServer. Error: $err1"
        Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Error running the $scriptName Script on $WsusServer.  Error: $err1" -Source $EventSource -EntryType Error
	    Write-ToLog "Please check the logs."
		If($EmailReport)
			{	$Body = ConvertTo-Html -head $CStyle -Body "Failed to connect $WsusServer. Error: $err1.  Script exited." | Out-String
				$Body = $Body.Replace("&lt;table&gt;`r`n&lt;/table&gt;", "")
				SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
				Write-ToLog "Sending Mail..."
			}
		Write-ToLog "Exiting..."
		Exit
	}
    
    if ($WsusServerAdminProxy) {Write-ToLog "Connected to $WsusServer."}
    if ($TrialRun) {Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Recording all superseded updates..."}Else{Write-ToLog "NOTE: TrialRun flag is set to $TrialRun. Continuing with declining updates..."}


    $Props."Servername" = ("$wsusserver")

    Write-ToLog "Collecting a list of updates from $WsusServer... Please wait..."

    Try{$allUpdates = $WsusServerAdminProxy.GetUpdates()}
	Catch [System.Exception]
	{
	    $err1 = $_.Exception.Message
		Write-ToLog "Failed to collect a list of updates from $WsusServer. Error: $Error[0]"
        Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Error running the $scriptName Script on $WsusServer.  Error: $Error[0]" -Source $EventSource -EntryType Error
	    Write-ToLog "Please check the logs."
		If($EmailReport)
			{	$Body = ConvertTo-Html -head $CStyle -Body "Failed to collect a list of updates from $WsusServer. Error: $Error[0].  Please check the server manually.  Script exited." | Out-String
				$Body = $Body.Replace("&lt;table&gt;`r`n&lt;/table&gt;", "")
				SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
				Write-ToLog "Sending Mail..."
			}
		Write-ToLog "Exiting..."
		Exit
	}

	Write-ToLog "Done"

	Write-ToLog "Parsing the list of updates... " -NoNewLine

	Try{Decline-Superseded{};$Props."All Superseded" = ("$script:countSupersededAll");$Props."Superseded &gt; $ExclusionPeriod" = ("$script:countSupersededExclusionPeriod")}
	Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-SupersededUpdatesWithExclusionPeriod function on $WsusServer" -Source $EventSource -EntryType Error;	SendMail{}}
		
    Write-ToLog "Decline-SupersededUpdates function.....  Done."
	Write-ToLog ""
	
	Write-ToLog "Grabbing more updates info from $WsusServer..."
	#$GrabUpdates= $WsusServerAdminProxy.GetUpdates() | ?{-not $_.IsDeclined}
    $GrabUpdates = $allUpdates | where-object {-not $_.IsDeclined}
	
	If (!$SkipItanium)
	{
		Try	{Decline-Itanium{};$Props."Itanium" = ("$Script:Itancount")}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-WsusItaniumUpdates function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
    Else
        { 
            Write-ToLog "SkipItanium is set to $SkipItanium.  Skipping Decline-WSusItaniumUpdates Function."
            $its = "Skipped"
            $Props."Itanium" = ([string]$its)
        }

	If (!$SkipXP)
	{	
		Try{Decline-XPUpdates{};$Props."Windows XP" = ($Script:XPcount)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-XPUpdates function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{
		Write-ToLog "SkipXP is set to $SkipXP.  Skipping Decline-XPUpdates Function."
		$xps = "Skipped"
		$Props."Windows XP" = ([string]$xps)
	}

	If (!$SkipPrev)
	{	
		Try{Decline-Preview{};$Props."Previews" = ("$script:Prevcount")}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-Preview function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipPrev is set to $SkipPrev.  Skipping Decline-Preview Function."
		$pvs = "Skipped"
		$Props."Previews" = ([string]$pvs)
	}
	
	If (!$SkipBeta)
	{	
		Try{Decline-Beta{};$Props."Beta" = ("$Script:Betacount")}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-Beta function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipBeta is set to $SkipBeta.  Skipping Decline-Beta Function."
		$bts = "Skipped"
		$Props."Beta" = ([string]$bts)
	}
	
	If (!$SkipWwin10Next)
	{	
		Try{Decline-Win10Next{};$Props."Windows 10 Next" = ("$Script:Win10Nextcount")}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-Win10Next function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipWin10Next is set to $SkipWin10Next.  Skipping Decline-Win10Next Function."
		$wns = "Skipped"
		$Props."Windows 10 Next" = ([string]$wns)
	}

	If (!$SkipServerNext)
	{	
		Try{Decline-ServerNext{};$Props."Server Next" = ($script:ServerNextcount)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-ServerNext function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipServerNext is set to $SkipServerNext.  Skipping Decline-ServerNext Function."
		$sns = "Skipped"
		$Props."Server 10 Next" = ([string]$sns)
	}
	
	If (!$SkipIE7)
	{	
		Try{Decline-IE7{};$Props."IE 7" = ($Script:IE7count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-IE7 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
    Else
        { 
            Write-ToLog "SkipIE7 is set to $SkipIE7.  Skipping Decline-IE7 Function."
            $i7s = "Skipped"
            $Props."IE 7" = ([string]$i7s)
         }
	
	If (!$SkipIE8)
	{	
		Try{Decline-IE8{};$Props."IE 8" = ($Script:IE8count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-IE8 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
    Else
        { 
            Write-ToLog "SkipIE8 is set to $SkipIE8.  Skipping Decline-IE8 Function."
            $i8s = "Skipped"
            $Props."IE 8" = ([string]$i8s)
         }
	
	If (!$SkipIE9)
	{	
		Try{Decline-IE9{};$Props."IE 9" = ($Script:IE9count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-IE9 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipIE9 is set to $SkipIE9.  Skipping Decline-IE9 Function."
		$i9s = "Skipped"
		$Props."IE 9" = ([string]$i9s)
		
	}

	If (!$SkipIE10)
	{	
		Try{Decline-IE10{};$Props."IE 10" = ($Script:IE10count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-IE10 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipIE10 is set to $SkipIE10.  Skipping Decline-IE10 Function."
		$i0s = "Skipped"
		$Props."IE 10" = ([string]$i0s)
		
	}

	If (!$SkipEmbedded)
	{	
		Try{Decline-Embedded{};$Props."Windows Embedded" = ($Script:Embeddedcount)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-Embedded function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipEmbedded is set to $SkipEmbedded.  Skipping Decline-Embedded Function."
		$ems = "Skipped"
		$Props."Windows Embedded" = ([string]$ems)
	}

	If (!$SkipArm64)
	{	
		Try{Decline-ARM64{};$Props."ARM64 Based" = ($Script:Arm64count)}
		Catch{Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Unable to run Decline-ARM64 function on $WsusServer" -Source $EventSource -EntryType Error; SendMail{}}
	}
	Else
	{ 
		Write-ToLog "SkipArm64 is set to $SkipArm64.  Skipping Decline-ARM64 Function."
		$arm = "Skipped"
		$Props."ARM64 Based" = ([string]$arm)
	}

    if ($error)
    {
        Write-EventLog -LogName $Eventlog -EventID 21021 -Message "Error running the $scriptName Script on $WsusServer.  Error: $error{0}" -Source $EventSource -EntryType Error
		SendMail{}
    }
    Else
    {

     Write-EventLog -LogName $Eventlog -EventID 21020 -Message "$scriptName Script has completed successfully on $WsusServer." -Source $EventSource -EntryType Information
    }

    #$row = $table.NewRow()

	Write-ToLog ""
	Write-ToLog "Done with $WsusServer... "
	Write-ToLog ""
	Write-ToLog "=========================="
	Write-ToLog "Overall Summary for $WsusServer"
	Write-ToLog "=========================="
	Write-ToLog "    Total Superseded Updates (Older than $ExclusionPeriod days) = $script:countSupersededExclusionPeriod"
	Write-ToLog "    Total Itanium Updates = $script:Itancount. $its"
	Write-ToLog "    Total Windows XP Updates = $Script:XPcount. $xts"
	Write-ToLog "    Total Preview Updates = $Script:Prevcount. $pvs"
	Write-ToLog "    Total Beta Updates = $Script:Betacount. $bts"
	Write-ToLog "    Total Windows 10 Next Updates = $Script:Win10Nextcount. $wns"
	Write-ToLog "    Total Windows Server Next Updates = $Script:ServerNextcount. $sns"
	Write-ToLog "    Total ARM64-Based Updates = $Script:Arm64count. $arm"
	Write-ToLog "    Total Windows Embedded Updates = $Script:Embeddedcount. $ems"
	Write-ToLog "    Total IE 7 Updates = $Script:IE7count. $i7s"
	Write-ToLog "    Total IE 8 Updates = $Script:IE8count. $i8s"
	Write-ToLog "    Total IE 9 Updates = $Script:IE9count. $i9s"
	Write-ToLog "    Total IE 10 Updates = $Script:IE10count. $i0s"
	
    
	Write-ToLog ""
	If (!$TrialRun){Write-ToLog "These Updates were declined, unless Skipped."}Else{Write-ToLog "Updates were ONLY recorded. See UpdatesList folder."}
	Write-ToLog "=========================="
	Write-ToLog "=========================="
	Write-ToLog ""

    $Props."TrialRun" = ($TrialRun)
   
    $StopScript = Get-Date
    $timespan = new-timespan -seconds $(($StopScript-$startScript).totalseconds) 
    $ScriptTime = '{0:00}h:{1:00}m:{2:00}s' -f $timespan.Hours,$timespan.Minutes,$timespan.Seconds
	Write-ToLog "$WsusServer Run Time: $ScriptTime"
	Write-ToLog "=========================="
	Write-ToLog ""

    $Props."Run Time" = ($ScriptTime)

    New-Object PSObject -property $Props
}

$jeffobjects | Select $Table | ConvertTo-HTML -head $CStyle | Out-File $Overallhtmfile

If($CleanUpdatelist){UpdateListMaint{}}

If($EmailReport)
	{	
        $Body = "&lt;p class=MsoTitle&gt;&lt;span style='font-size:20pt;font-family:Verdana,sans-serif'&gt;$ReportTitle&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;"
        $Body += $jeffobjects | Select $Table | ConvertTo-HTML -head $CStyle -PostContent "&lt;h6&gt;Created $(Get-Date)&lt;/h6&gt;&lt;br&gt;$from"
		SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body $Body
	}
	
Write-ToLog "====&gt;  Done  &lt;===="
Write-ToLog "All target WSUS/SUP servers have been completed."
Write-ToLog "See $Overallhtmfile."
Write-ToLog "=========================================="

=================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Start-WsusServerSync.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Start-WsusServerSync.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://gallery.technet.microsoft.com/scriptcenter/Synchronize-all-WSUS-00c899c2
#'Start-WsusServerSync.ps1

Param(
	$WsusServer = ([system.net.dns]::GetHostByName('localhost')).hostname,
	[switch]$Recursive,
	[bool]$TrialRun = $True,
	[int]$SleepTime = 60,
	[string]$SmtpServer = "smtp.company.com",
	[string]$From = "wsus@company.com",
	[string]$To = "wsus@company.com",
	[string]$Subject = "WSUS Server Synchronization.",
	[switch]$EmailLog
)
Begin
{	$script:CurrentErrorActionPreference = $ErrorActionPreference
	$script:Output = @()
	$script:ProcessedServers = @()
	$WsusAssembly = [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration")
	If($WsusAssembly -eq $Null)
	{	throw "Loading Microsoft.UpdateServices.Administration failed. Are you running this on a machine with the WSUS 3.0 SP2 Administration Console installed? http://technet.microsoft.com/en-us/library/dd939875(v=ws.10).aspx"}

	$ErrorActionPreference = "SilentlyContinue"
	If($EmailLog)
	{	If($Recursive)
		{	$Table = @{Name="Parent Wsus Server";expression={$_.ParentWsusServer}},@{Name="Wsus Server";expression={$_.WsusServer}},@{Name="Port Number";expression={$_.PortNumber}},@{Name="Using SSL";expression={$_.UsingSSL}},@{Name="Version";expression={$_.Version}},@{Name="Start";expression={$_.Start}},@{Name="Finish";expression={$_.Finish}}
		}
		Else
		{	$Table = @{Name="Wsus Server";expression={$_.WsusServer}},@{Name="Port Number";expression={$_.PortNumber}},@{Name="Using SSL";expression={$_.UsingSSL}},@{Name="Version";expression={$_.Version}},@{Name="Start";expression={$_.Start}},@{Name="Finish";expression={$_.Finish}}
		}
		If($TrialRun -eq $False)
		{	$Table += @{Name="Categories";expression={$_.Categories}},@{Name="Updates";expression={$_.Updates}},@{Name="Approvals";expression={$_.Approvals}},@{Name="LastSyncResult";expression={$_.LastSyncResult}}
		}
		$Style = "&lt;Style&gt;BODY{font-size:12px;font-family:verdana,sans-serif;color:navy;font-weight:normal;}" + `
		"TABLE{border-width:1px;cellpadding=10;border-style:solid;border-color:navy;border-collapse:collapse;}" + `
		"TH{font-size:12px;border-width:1px;padding:10px;border-style:solid;border-color:navy;}" + `
		"TD{font-size:10px;border-width:1px;padding:10px;border-style:solid;border-color:navy;}&lt;/Style&gt;"
		Function SendEmailStatus($From, $To, $Subject, $SmtpServer, $BodyAsHtml, $Body)
		{	$SmtpMessage = New-Object System.Net.Mail.MailMessage $From, $To, $Subject, $Body
			$SmtpMessage.IsBodyHTML = $BodyAsHtml
			$SmtpClient = New-Object System.Net.Mail.SmtpClient $SmtpServer
			$SmtpClient.Send($SmtpMessage)
			If($? -eq $False){Write-Warning "$($Error[0].Exception.Message) | $($Error[0].Exception.GetBaseException().Message)"}
			$SmtpMessage.Dispose()
			rv SmtpClient
			rv SmtpMessage
		}
	}

	function Get-HKLMValue
	{	Param(
  		[string]$computername=".",
  		[string]$key = "SOFTWARE\Microsoft\Update Services\Server\Setup",
  		[string]$value,
  		[switch]$REG_SZ,
  		[switch]$REG_DWORD
  	)
		$HKLM = 2147483650
		$reg = [wmiclass]"\\$computername\root\default:StdRegprov"
		If($REG_SZ)
		{	$Result = $reg.GetStringValue($HKLM,$key,$value)
			If($Result.ReturnValue -eq 0){$Result.sValue}
		}
		If($REG_DWORD)
		{	$Result = $reg.GetDwordValue($HKLM,$key,$value)
			If($Result.ReturnValue -eq 0){$Result.uValue}
		}
	}

	function Start-Pause
	{	Param(
			[int]$SleepTime = 10,
			[int]$ID = 1,
			[int]$ParentID,
			[string]$Activity = "Just taking a quick breather after all that activity..."
		)
		for($x = 1 ; $x -le $SleepTime; $x++)
		{	If(!$ParentID)
			{	Write-progress -Activity $Activity -Status "Seconds Remaining: $($SleepTime-$x)" -PercentComplete ($x/$SleepTime*100) -ID $ID}
			Else	
			{	Write-progress -Activity $Activity -Status "Seconds Remaining: $($SleepTime-$x)" -PercentComplete ($x/$SleepTime*100) -ID $ID -ParentId $ParentID}
			Sleep 1
		}
		Write-progress -Activity $Activity -Status "Done sleeping..." -Completed -ID $ID
	}

	Function Sync-WsusServer
	{	Param(
			$WsusServer,
			$ParentWsusServer
		)
		Write-Progress -Activity "Processing server: $WsusServer" -Status "Started at $((get-date).DateTime)" -ID 2 -ParentID 1
		Write-Progress -Activity "Retrieving PortNumber value from the registry via StdRegprov ..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
		$PortNumber = Get-HKLMValue -Computername $WsusServer -value PortNumber -REG_DWORD
		Write-Progress -Activity "Retrieving UsingSSL value from the registry via StdRegprov ..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
		$UsingSSL = If((Get-HKLMValue -Computername $WsusServer -value UsingSSL -REG_DWORD) -eq 1){$True}Else{$False}
		If($UsingSSL)
		{ Write-Progress -Activity "Retrieving ServerCertificateName value from the registry via StdRegprov ..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
			$ServerCertificateName = Get-HKLMValue -Computername $WsusServer -value ServerCertificateName -REG_SZ
			If($ServerCertificateName){$WsusServer = $ServerCertificateName}
		}
		If($script:ProcessedServers -Contains $WsusServer)
		{	Write-Warning "$WsusServer appears to have already been processed. You may have a circular loop in your hierarchy."}
		Else
		{	$script:ProcessedServers += $WsusServer
			$Object = New-Object psobject
			If($Recursive)
			{	If(!$ParentWsusServer){$ParentWsusServer = "--"}
				$Object | Add-Member NoteProperty ParentWsusServer $ParentWsusServer
			}
			$Object | Add-Member NoteProperty WsusServer $WsusServer -PassThru | Add-Member NoteProperty PortNumber $PortNumber -PassThru | 
				Add-Member NoteProperty UsingSSL $UsingSSL -PassThru | Add-Member NoteProperty Version "" -PassThru |
				Add-Member NoteProperty Start (get-date).DateTime -PassThru | Add-Member NoteProperty Finish ""
			If($TrialRun -eq $False)
			{	$Object | Add-Member NoteProperty Categories "--" -PassThru | 
					Add-Member NoteProperty Updates "--" -PassThru | 
					Add-Member NoteProperty Approvals "--" -PassThru | 
					Add-Member NoteProperty LastSyncResult ""
			}
			Write-Progress -Activity "Connecting to UpdateServices AdminProxy..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
			$WsusServerAdminProxy = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($WsusServer,$UsingSSL,$PortNumber)
			If ($? -eq $False)
			{	$Object.Version = $Error[0]
				Write-Warning "Failed to connect to $WsusServer $($Error[0])"
				$Object.Finish = (get-date).DateTime
				$Object
				If($EmailLog){$script:Output += $Object}
			}
			Else
			{	$Object.Version = $WsusServerAdminProxy.Version
				If($TrialRun -eq $False)
				{	Write-Progress -Activity "Connecting to the Subscription..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
					$Subscription = $WsusServerAdminProxy.GetSubscription();
					Write-Progress -Activity "Calling StartSynchronization on $WsusServer" -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
					$Subscription.StartSynchronization()
					$SynchronizationProgress = $Subscription.GetSynchronizationProgress()
					While ($SynchronizationProgress.Phase.ToString() -eq "NotProcessing")
					{	Start-Sleep -Milliseconds 100
						$SynchronizationProgress = $Subscription.GetSynchronizationProgress()
					}
					While ($SynchronizationProgress.Phase.ToString() -ne "NotProcessing")
					{	If($SynchronizationProgress.Phase.ToString() -eq "Categories")
						{$Object.Categories = $SynchronizationProgress.TotalItems}
						If($SynchronizationProgress.Phase.ToString() -eq "Updates")
						{	$Object.Updates = $SynchronizationProgress.TotalItems}
						If($SynchronizationProgress.Phase.ToString() -eq "Approvals")
						{$Object.Approvals = $SynchronizationProgress.TotalItems}
						Write-Progress -Activity "Synchronization Phase: $($SynchronizationProgress.Phase.ToString())" -Status "$($SynchronizationProgress.ProcessedItems) of $($SynchronizationProgress.TotalItems) items done..." -PercentComplete ($SynchronizationProgress.ProcessedItems*100/($SynchronizationProgress.TotalItems)) -ID 4 -ParentId 3
						$SynchronizationProgress = $Subscription.GetSynchronizationProgress()
					}
					$Object.LastSyncResult = $Subscription.GetLastSynchronizationInfo().Result
					Write-Progress -Activity "Synchronization Phase: $($SynchronizationProgress.Phase.ToString())" -Status "Complete." -ID 4 -ParentId 3 -Completed
				}
				$Object.Finish = (get-date).DateTime
				$Object
				If($EmailLog){$script:Output += $Object}
				If($Recursive -And $TrialRun -eq $False){Start-Pause -Activity "Processed $($script:ProcessedServers.Count) server(s). The script is pausing for $SleepTime seconds starting at $((get-date).DateTime)." -SleepTime $SleepTime -ID 3 -ParentID 2}
				If($Recursive)
				{	Write-Progress -Activity "Retrieving Downstream Servers on $WsusServer..." -Status "Started at $((get-date).DateTime)" -ID 3 -ParentID 2
					$WsusDownstreamServers = $WsusServerAdminProxy.GetDownstreamServers()
					If($WsusDownstreamServers){$WsusDownstreamServers | %{Sync-WsusServer -WsusServer $_.FullDomainName -ParentWsusServer $WsusServer}}
				}
			}
		}
	}
	Write-Progress -Activity "WSUS Server Synchronization." -Status "Started at $((get-date).DateTime)" -ID 1
}
Process
{	If($WsusServer)
	{	ForEach($Server in $WsusServer){Sync-WsusServer $Server}
	}
	Else
	{	Sync-WsusServer $_
	}
}
End
{	If($EmailLog){SendEmailStatus -From $From -To $To -Subject $Subject -SmtpServer $SmtpServer -BodyAsHtml $True -Body ($Output | Select $Table | ConvertTo-HTML -head $Style)}
	$ErrorActionPreference = $script:CurrentErrorActionPreference
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WindowsUpdate_Module</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WindowsUpdate_Module</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'WindowsUpdate.psm1
#'https://github.com/adbertram/Random-PowerShell-Work/blob/master/Software%20Updates/WindowsUpdate.psm1

Set-StrictMode -Version Latest

function Get-WindowsUpdate {
	&lt;#
		.SYNOPSIS
			This function retrieves a list of Microsoft updates based on a number of different criteria for a remote
			computer. It will retrieve these updates over a PowerShell remoting session. It uses the update source set
			at the time of query. If it's set to WSUS, it will only return updates that are advertised to the computer
			by WSUS.
	
		.EXAMPLE
			PS&gt; Get-WindowsUpdate -ComputerName FOO
		.PARAMETER ComputerName
			 A mandatory string parameter representing the FQDN of a computer. This is only mandatory is Session is
			 not used.
		.PARAMETER Credential
			 A optoional pscredential parameter representing an alternate credential to connect to the remote computer.
		.PARAMETER Session
			 A mandatory PSSession parameter representing a PowerShell remoting session created with New-PSSession. This
			 is only mandatory if ComputerName is not used.
		
		.PARAMETER Installed
			 A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			 updates on this criteria.
		.PARAMETER Hidden
			 A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			 updates on this criteria.
		.PARAMETER Assigned
			A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			updates on this criteria.
		.PARAMETER RebootRequired
			A optional boolean parameter set to either $true or $false depending on if you'd like to filter the resulting
			updates on this criteria.
	#&gt;
	[OutputType([System.Management.Automation.PSObject])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory, ParameterSetName = 'ByComputerName')]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName,

		[Parameter(ParameterSetName = 'ByComputerName')]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential,

		[Parameter(Mandatory, ParameterSetName = 'BySession')]
		[ValidateNotNullOrEmpty()]
		[System.Management.Automation.Runspaces.PSSession]$Session,
        
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('MicrosoftUpdate')]
		[string]$Source,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$Installed = 'False',

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$Hidden,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$Assigned,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('True', 'False')]
		[string]$RebootRequired
	)
	begin {
		$ErrorActionPreference = 'Stop'
		if (-not $Session) {
			$sessParams = @{
				ComputerName = $ComputerName
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$sessParams.Credential = $Credential
			}
			$Session = New-PSSession @sessParams
		}
	}
	process {
		try {
			$criteriaParams = @{}

			## Had to set these to string values because if they're boolean they will have a $false value even if
			## they aren't set.  I needed to check for a $null value.ided
			@('Installed', 'Hidden', 'Assigned', 'RebootRequired').where({ (Get-Variable -Name $_).Value }).foreach({
					$criteriaParams[$_] = if ((Get-Variable -Name $_).Value -eq 'True') {
						$true 
					} else {
						$false 
					}
				})
			$query = NewUpdateCriteriaQuery @criteriaParams
			Write-Verbose -Message "Using the update criteria query: [$($Query)]..."
			$searchParams = @{
				Session = $Session
				Query   = $query
			}
			if ($PSBoundParameters.ContainsKey('Source')) {
				$searchParams.Source = $Source
			}
			SearchWindowsUpdate @searchParams
		} catch {
			Write-Error $_.Exception.Message
		} finally {
			## Only clean up the session if it was generated from within this function. This is because updates
			## are stored in a variable to be used again by other functions, if necessary.
			if (($PSCmdlet.ParameterSetName -eq 'ByComputerName') -and (Test-Path Variable:\session)) {
				$session | Remove-PSSession
			}
		}
	}
}

function Install-WindowsUpdate {
	&lt;#
		.SYNOPSIS
			This function retrieves all updates that are targeted at a remote computer, download and installs any that it
			finds. Depending on how the remote computer's update source is set, it will either read WSUS or Microsoft Update
			for a compliancy report.
			Once found, it will download each update, install them and then read output to detect if a reboot is required
			or not.
	
		.EXAMPLE
			PS&gt; Install-WindowsUpdate -ComputerName FOO.domain.local
		.EXAMPLE
			PS&gt; Install-WindowsUpdate -ComputerName FOO.domain.local,FOO2.domain.local			
		
		.EXAMPLE
			PS&gt; Install-WindowsUpdate -ComputerName FOO.domain.local,FOO2.domain.local -ForceReboot
		.PARAMETER ComputerName
			 A mandatory string parameter representing one or more computer FQDNs.
		.PARAMETER Credential
			 A optional pscredential parameter representing an alternate credential to connect to the remote computer.
		
		.PARAMETER ForceReboot
			 An optional switch parameter to set if any updates on any computer targeted needs a reboot following update
			 install. By default, computers are NOT rebooted automatically. Use this switch to force a reboot.
		
		.PARAMETER AsJob
			 A optional switch parameter to set when activity needs to be sent to a background job. By default, this function 
			 waits for each computer to finish. However, if this parameter is used, it will start the process on each
			 computer and immediately return a background job object to then monitor yourself with Get-Job.
	#&gt;
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string[]]$ComputerName,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('MicrosoftUpdate')]
		[string]$Source,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[switch]$ForceReboot,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[switch]$AsJob
	)
	begin {
		$ErrorActionPreference = 'Stop'

		$scheduledTaskName = 'Windows Update Install'

	}
	process {
		try {
			$getParams = @{}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$getParams.Credential = $Credential
			}
			if ($PSBoundParameters.ContainsKey('Source')) {
				$getParams.Source = $Source
			}
			@($ComputerName).foreach({
					$getParams.ComputerName = $_
					if (-not (Get-WindowsUpdate @getParams)) {
						Write-Verbose -Message 'No updates needed to install. Skipping computer...'
					} else {
						$installProcess = {
							param($ComputerName, $TaskName, $Credential, $ForceReboot)
							$VerbosePreferences = 'Continue'
							try {
								$sessParams = @{ ComputerName = $ComputerName }
								if ($Credential) {
									$sessParams.Credential = $Credential
								}
							
								$session = New-PSSession @sessParams

								$scriptBlock = {
									$updateSession = New-Object -ComObject 'Microsoft.Update.Session'
									$objSearcher = $updateSession.CreateUpdateSearcher()
									if ($using:Source -eq 'MicrosoftUpdate') {
										$objSearcher.ServerSelection = 3
									}
									if ($updates = ($objSearcher.Search('IsInstalled=0'))) {
										$updates = $updates.Updates

										$downloader = $updateSession.CreateUpdateDownloader();
										$downloader.Updates = $updates;
										$downloadResult = $downloader.Download();
										if ($downloadResult.ResultCode -ne 2) {
											exit $downloadResult.ResultCode;
										}

										$installer = New-Object -ComObject Microsoft.Update.Installer;
										$installer.Updates = $updates;
										$installResult = $installer.Install();
										if ($installResult.RebootRequired) {
											exit 7;
										} else {
											$installResult.ResultCode
										}
									} else {
										exit 6;
									}
								}
							
								$taskParams = @{
									Session     = $session
									Name        = $TaskName
									Scriptblock = $scriptBlock
									PassThru    = $true
								}
								Write-Verbose -Message 'Creating scheduled task...'
								if (-not ($task = NewWindowsUpdateScheduledTask @taskParams)) {
									throw "Failed to create scheduled task."
								}

								Write-Verbose -Message "Starting scheduled task [$($task.TaskName)]..."

								$icmParams = @{
									Session      = $session
									ScriptBlock  = { Start-ScheduledTask -TaskName $args[0] }
									ArgumentList = $task.TaskName
									Verbose      = $true
								}
								Invoke-Command @icmParams
                                
								$waitParams = @{
									ComputerName = $_
								}
								if ($Credential) {
									$waitParams.Credential = $Credential
								}
								Wait-ScheduledTask @waitParams -Name $task.TaskName

								$installResult = GetWindowsUpdateInstallResult -Session $session

								if ($installResult -eq 'NoUpdatesNeeded') {
									Write-Verbose -Message "No updates to install"
								} elseif ($installResult -eq 'RebootRequired') {
									if ($ForceReboot) {
										Restart-Computer -ComputerName $ComputerName -Force -Wait;
									} else {
										Write-Warning "Reboot required but -ForceReboot was not used."
									}
								} else {
									throw "Updates failed. Reason: [$($installResult)]"
								}
							
							} catch {
								$PSCmdlet.ThrowTerminatingError($_)
							} finally {
								Remove-ScheduledTask @getParams -Name $TaskName
							}
						}

						$blockArgs = $_, $scheduledTaskName, $Credential, $ForceReboot.IsPresent
						if ($AsJob.IsPresent) {
							Start-Job -ScriptBlock $installProcess -Name "$_ - Windows Update Install" -ArgumentList $blockArgs
						} else {
							Invoke-Command -ScriptBlock $installProcess -ArgumentList $blockArgs
						}
					}
				})
		} catch {
			Write-Error $_.Exception.Message
		} finally {
			# Remove any sessions created. This is done when processes aren't invoked under a PS job
			$sessParams = @{
				ComputerName = $ComputerName
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$sessParams.Credential = $Credential
			}
			@(Get-PSSession @sessParams).foreach({
					Remove-PSSession -Session $_
				})
		}
	}
}

function GetWindowsUpdateInstallResult {
	[OutputType([string])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[System.Management.Automation.Runspaces.PSSession]$Session,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[string]$ScheduledTaskName = 'Windows Update Install'
	)

	$sb = { (Get-ScheduledTask -TaskName $args[0] | Get-ScheduledTaskInfo).LastTaskResult }
	$resultCode = Invoke-Command -Session $Session -ScriptBlock $sb -ArgumentList $ScheduledTaskName
	switch -exact ($resultCode) {
		0   {
			'Installed'
			break
		}
		1   {
			'InProgress'
			break
		}
		2   {
			'Installed'
			break
		}
		3   {
			'InstalledWithErrors'
			break
		}
		4   {
			'Failed'
			break
		}
		5   {
			'Aborted'
			break
		}
		6   {
			'NoUpdatesNeeded'
			break
		}
		7   {
			'RebootRequired'
			break
		}
		267009 {
			'TimedOut'
			break
		}
		default {
			"Unknown exit code [$($_)]"
		}
	}
}

function NewUpdateCriteriaQuery {
	[OutputType([string])]
	[CmdletBinding()]
	param
	(
		[Parameter()]
		[bool]$Installed,

		[Parameter()]
		[bool]$Hidden,

		[Parameter()]
		[bool]$Assigned,

		[Parameter()]
		[bool]$RebootRequired
	)

	$conversion = @{
		Installed      = 'IsInstalled'
		Hidden         = 'IsHidden'
		Assigned       = 'IsAssigned'
		RebootRequired = 'RebootRequired'
	}

	$queryElements = @()
	$PSBoundParameters.GetEnumerator().where({ $_.Key -in $conversion.Keys }).foreach({
			$queryElements += '{0}={1}' -f $conversion[$_.Key], [int]$_.Value
		})
	$queryElements -join ' and '
}

function SearchWindowsUpdate {
	[OutputType()]
	[CmdletBinding()]
	param
	(
		[Parameter()]
		[string]$Query,
        
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[string]$Source,

		[Parameter()]
		[System.Management.Automation.Runspaces.PSSession]$Session
	)

	$scriptBlock = {
		$objSession = New-Object -ComObject 'Microsoft.Update.Session'
		$objSearcher = $objSession.CreateUpdateSearcher()
		if ($using:Source -eq 'MicrosoftUpdate') {
			$objServiceManager = New-Object -ComObject "Microsoft.Update.ServiceManager"
			$objSearcher.ServerSelection = 3
			$objServiceManager.Services | Where-Object { $_.Name -eq 'Microsoft Update' } | Foreach {
				$objSearcher.ServiceID = $_.ServiceID
			}
		}
		if ($updates = ($objSearcher.Search($args[0]))) {
			$updates = $updates.Updates
			## Save the updates needed to the file system for other functions to pick them up to download/install later.
			$updates | Export-CliXml -Path "$env:TEMP\Updates.xml"
			$updates
		}
		
	}
	Invoke-Command -Session $Session -ScriptBlock $scriptBlock -ArgumentList $Query
}

function NewWindowsUpdateScheduledTask {
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[System.Management.Automation.Runspaces.PSSession]$Session,

		[Parameter(Mandatory)]
		[string]$Name,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[scriptblock]$Scriptblock,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[switch]$PassThru
	)

	if (TestWindowsUpdateScheduledTask -Session $Session -Name $Name) {
		Write-Verbose -Message "A windows update install task already exists. Removing..."
		Remove-ScheduledTask -ComputerName $Session.ComputerName -Name $Name
	}

	$createStartSb = {
		$action = New-ScheduledTaskAction -Execute 'powershell.exe' -Argument $args[1]
		$principal = New-ScheduledTaskPrincipal -UserId $args[3] -LogonType Password
		$settings = New-ScheduledTaskSettingsSet -StartWhenAvailable -Hidden
		$task = New-ScheduledTask -Action $action -Settings $settings -Principal $principal
		$regTask = Register-ScheduledTask -InputObject $task -TaskName $args[0]
		if ($args[2].IsPresent) {
			$regTask
		}
	}

	$psArgs = '-NonInteractive -NoProfile -Command "{0}"' -f $Scriptblock.ToString()

	$icmParams = @{
		Session      = $Session
		ScriptBlock  = $createStartSb
		ArgumentList = $Name, $psArgs, $PassThru
	}
	if ($PSBoundParameters.ContainsKey('Credential')) {
		$icmParams.ArgumentList += $Credential.UserName	
	} else {
		$icmParams.ArgumentList += 'SYSTEM'
	}
	
	Invoke-Command @icmParams
	
}

function TestWindowsUpdateScheduledTask {
	[OutputType([bool])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[System.Management.Automation.Runspaces.PSSession]$Session,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$Name
	)
	$testScriptBlock = {
		if (Get-ScheduledTask -TaskName $args[0] -ErrorAction Ignore) {
			$true
		} else {
			$false
		}
	}

	Invoke-Command -Session $Session -ScriptBlock $testScriptBlock -ArgumentList $Name
}

function Wait-WindowsUpdate {
	&lt;#
		.SYNOPSIS
			This function looks for any currently running background jobs that were created by Install-WindowsUpdate
			and continually waits for all of them to finish before returning control to the console.
	
		.EXAMPLE
			PS&gt; Wait-WindowsUpdate
		
		.PARAMETER Timeout
			 An optional integer parameter representing the amount of seconds to wait for the job to finish.
	
	#&gt;
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[int]$Timeout = 3600
	)
	process {
		try {
			if ($updateJobs = (Get-Job -Name '*Windows Update Install*').where({ $_.State -eq 'Running'})) {
				$timer = Start-Timer
				while ((Microsoft.PowerShell.Core\Get-Job -Id $updateJobs.Id | Where-Object { $_.State -eq 'Running' }) -and ($timer.Elapsed.TotalSeconds -lt $Timeout)) {
					Write-Verbose -Message "Waiting for all Windows Update install background jobs to complete..."
					Start-Sleep -Seconds 3
				}
				Stop-Timer -Timer $timer
			}
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}

function Remove-ScheduledTask {
	&lt;#
		.SYNOPSIS
			This function looks for a scheduled task on a remote system and, once found, removes it.
	
		.EXAMPLE
			PS&gt; Remove-ScheduledTask -ComputerName FOO -Name Task1
		
		.PARAMETER ComputerName
			 A mandatory string parameter representing a FQDN of a remote computer.
		.PARAMETER Name
			 A mandatory string parameter representing the name of the scheduled task. Scheduled tasks can be retrieved
			 by using the Get-ScheduledTask cmdlet.
		.PARAMETER Credential
			 Specifies a user account that has permission to perform this action. The default is the current user.
			 
			 Type a user name, such as 'User01' or 'Domain01\User01', or enter a variable that contains a PSCredential
			 object, such as one generated by the Get-Credential cmdlet. When you type a user name, you will be prompted for a password.
	
	#&gt;
	[OutputType([void])]
	[CmdletBinding(SupportsShouldProcess)]
	param
	(
		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential	
	)
	begin {
		$ErrorActionPreference = 'Stop'
	}
	process {
		try {
			$icmParams = @{
				ComputerName = $ComputerName
				ArgumentList = $Name
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$icmParams.Credential = $Credential
			}
			
			$sb = { 
				if ($task = Get-ScheduledTask -TaskName $args[0] -ErrorAction Ignore) {
					$task | Unregister-ScheduledTask -Confirm:$false
				}
			}

			if ($PSCmdlet.ShouldProcess("Remove scheduled task [$($Name)] from [$($ComputerName)]", '----------------------')) {
				Invoke-Command @icmParams -ScriptBlock $sb	
			}
		} catch {
			Write-Error -Message $_.Exception.Message
		}
	}
}

function Wait-ScheduledTask {
	&lt;#
		.SYNOPSIS
			This function looks for a scheduled task on a remote system and, once found, checks to see if it's running.
			If so, it will wait until the task has completed and return control.
	
		.EXAMPLE
			PS&gt; Wait-ScheduledTask -ComputerName FOO -Name Task1 -Timeout 120
		
		.PARAMETER ComputerName
			 A mandatory string parameter representing a FQDN of a remote computer.
		.PARAMETER Name
			 A mandatory string parameter representing the name of the scheduled task. Scheduled tasks can be retrieved
			 by using the Get-ScheduledTask cmdlet.
		.PARAMETER Timeout
			 A optional integer parameter representing how long to wait for the scheduled task to complete. By default,
			 it will wait 3600 seconds.
		.PARAMETER Credential
			 Specifies a user account that has permission to perform this action. The default is the current user.
			 
			 Type a user name, such as 'User01' or 'Domain01\User01', or enter a variable that contains a PSCredential
			 object, such as one generated by the Get-Credential cmdlet. When you type a user name, you will be prompted for a password.
	
	#&gt;
	[OutputType([void])]
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName,

		[Parameter(Mandatory)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[int]$Timeout = 3600, ## seconds

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[pscredential]$Credential
	)
	begin {
		$ErrorActionPreference = 'Stop'
	}
	process {
		try {
			$sessParams = @{
				ComputerName = $ComputerName
			}
			if ($PSBoundParameters.ContainsKey('Credential')) {
				$sessParams.Credential = $Credential
			}
			$session = New-PSSession @sessParams

			$scriptBlock = {
				$VerbosePreference = 'Continue'
				$timer = [Diagnostics.Stopwatch]::StartNew()
				while (((Get-ScheduledTask -TaskName $args[0]).State -ne 'Ready') -and ($timer.Elapsed.TotalSeconds -lt $args[1])) {
					Write-Verbose -Message "Waiting on scheduled task [$($args[0])]"
					Start-Sleep -Seconds 3
				}
				$timer.Stop()
				Write-Verbose -Message "We waited [$($timer.Elapsed.TotalSeconds)] seconds on the task [$($args[0])]"
			}

			Invoke-Command -Session $session -ScriptBlock $scriptBlock -ArgumentList $Name, $Timeout
		} catch {
			Write-Error -Message $_.Exception.Message
		} finally {
			if (Test-Path Variable:\session) {
				$session | Remove-PSSession
			}
		}
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_User_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>00_and_000_remote.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_User_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>00_and_000_remote.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'00_and_000_remote.ps1


$theComputerName = 'LT-103379'

$myCred = Credential -Credential jphsa01\ggarson


Test-Connection -ComputerName $theComputerName -Count 1

Invoke-Command -ComputerName $theComputerName -FilePath C:\DATA\PowerShellScripts\IE_ratherThan_Edge_MakeDefaultForNewUserProfiles_inWin10.ps1


Invoke-Command -ComputerName $theComputerName -FilePath C:\DATA\PowerShellScripts\AcrobatReader_MakeDefaultForNewUserProfiles_inWin10.ps1

#'BLING removal

#' Copy the script to the remote machine: ===============================================================

$tempSession = New-PSSession -ComputerName $theComputerName -Credential $myCred 

Copy-Item "\\win10vm\ALL_Share\win7_to_Win10\" -Destination "C:\DATA\2_Disable_Win10_StartButtonBling_LOCAL.ps1" -ToSession $tempSession

Enter-PSSession –ComputerName $theComputerName -Credential $myCred

    Set-Location C:\DATA

    dir

    .\2_Disable_Win10_StartButtonBling_LOCAL.ps1

Exit-PSSession


restart-computer $theComputerName</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Validation</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Validation</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Validation</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Validation</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Validation



AllowNull() - allows the parameter to accept a null value 
AllowEmptyString() - allows the parameter to accept an empty string (“”) 
AllowEmptyCollection() - allows an array parameter to accept an empty collection 


 
ValidateCount(min,max) - specifies a minimum and maximum number of values, in an array, that the parameter will accept 

ValidateLength(min,max) - specifies the maximum string length the parameter will accept. You can specify a minimum and maximum value, and if the parameter accepts a collection then this is applied to all members of the collection 

ValidatePattern(pattern) - specifies a regular expression that any string input must match in order to be accepted 

ValidateRange(min,max) - specifies a range of numeric values that any input must fall between, inclusive of the minimum and maximum specified 

ValidateScript({script block}) - specifies a script block; within the script, uses $_ to refer to the proposed value for the parameter, and return $true to accept it or $false to reject it 

ValidateSet(val,val,val…) - covered earlier, this specifies a set of legal values for the parameter 

ValidateNotNull() - the parameter will not accept null values 

ValidateNotNullOrEmpty() - the parameter will not accept null values or empty strings (“”) 
 

 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Validation</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Simple_Examples_Validation</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Validation</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Simple_Examples_Validation</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-5.1

------------------------------AllowNull Validation Attribute
Param
(
    [parameter(Mandatory=$true)]
    [AllowNull()]
    [String]
    $ComputerName
)

------------------------------AllowEmptyString 

Param
(
    [parameter(Mandatory=$true)]
    [AllowEmptyString()]
    [String]
    $ComputerName
)
------------------------------AllowEmptyCollection 
'allows the value of a mandatory parameter to be an empty collection (@()).
Param
(
    [parameter(Mandatory=$true)]
    [AllowEmptyCollection()]
    [String[]]
    $ComputerName
)

------------------------------ValidateCount
'the minimum and maximum number of parameter values that a parameter accepts. 
Param
(
    [parameter(Mandatory=$true)]
    [ValidateCount(1,5)]
    [String[]]
    $ComputerName
)

------------------------------ValidateLength
'specifies the minimum and maximum number of characters in a parameter or variable value. 
Param
(
    [parameter(Mandatory=$true)]
    [ValidateLength(1,10)]
    [String[]]
    $ComputerName
)
------------------------------ValidatePattern
' a regular expression that is compared to the parameter or variable value
' example, the parameter value must be a four-digit number, and each digit must be a number 0 to 9.
Param
(
    [parameter(Mandatory=$true)]
    [ValidatePattern("[0-9][0-9][0-9][0-9]")]
    [String[]]
    $ComputerName
)


------------------------------ValidateRange
' specifies a numeric range for each parameter or variable value
Param
(
    [parameter(Mandatory=$true)]
    [ValidateRange(0,10)]
    [Int]
    $Attempts
)
------------------------------ValidateScript
'specifies a script that is used to validate a parameter or variable value. 
' Windows PowerShell pipes the value to the script, and generates an error if the script
'	returns "false" or if the script throws an exception.
'the value that is being validated is mapped to the $ variable. 
Param
(
    [parameter()]
    [ValidateScript({$_ -ge (get-date)})]
    [DateTime]
    $EventDate
)


------------------------------ValidateSet
'specifies a set of valid values for a parameter or variable
Param
(
    [parameter(Mandatory=$true)]
    [ValidateSet("Low", "Average", "High")]
    [String[]]
    $Detail
)
------------------------------ValidateNotNull
'specifies that the parameter value cannot be null ($null)
Param
(
    [parameter(Mandatory=$true)]
    [ValidateNotNull()]
    # $ID
)
------------------------------ValidateNotNullOrEmpty
' specifies that the parameter value cannot be null ($null) and cannot be an empty string ("")
Param
(
    [parameter(Mandatory=$true)]
    [ValidateNotNullOrEmpty()]
    [String[]]
    $UserName
)
------------------------------


------------------------------


------------------------------


------------------------------


------------------------------
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Array_Example_get_Random_numbers_letters_Characters</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Array_Example_get_Random_numbers_letters_Characters</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'make a password
$alpha = 'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z'
$num = 0..9
$char = '!,),@,(,*,/,$,&amp;,^,%,[,],&gt;,&lt;'
$arr = @()
$arr+= $alpha.split(',') | Get-Random -count 5
#make the first and last elements upper case
$arr[0] = $arr[0].toupper()
$arr[-1] = $arr[-1].toupper()         #'  &lt;==== Last member of the array
#$num is already an array
$arr += $num | Get-Random -count 2
#get 3 random characters
$arr += $char.split(',') | Get-Random -count 3
#randomize the array and join as a string 
($arr | Get-Random -Count $arr.count) -join ""

'OUTPUT (example)
---------
h@2^T(d0Jz</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Array</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Array</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$arr[0] 					         #'  &lt;==== First member of the array		
$arr[-1] = $arr[-1].toupper()         #'  &lt;==== Last member of the array


#-----------------------------------------------------------------------------#
# Arrays {0 based}
#-----------------------------------------------------------------------------#

# Simple array
Clear-Host
$array = "Arcane", "Code"
$array                       #{returns all members in the array}
$array[0]
$array[1]

$array.GetType()

# Updating arrays
$array = "Robert", "Cain"    #{This will over-write the array}
$array

$array[0] = "Power"
$array[1] = "Shell"
$array

# Formal Array Creation Syntax
$array = @("Power", "Shell")
$array

$array = @()   # Only way to create an empty array
$array.Count   # {returns zero, b/c it is empty}

$array += "Arcane"  # { use plus/equal to add items to an array}
$array += "Code"
$array.Count


$array = 1..5  # Can load arrays using numeric range notation, This will create the members of the array, and populate them with the digits: 1,2,3,4,5
$array         # 

# Check to see if an item exists
Clear-Host
$numbers = 1, 42, 256
$numbers -contains 42    # {returns True}

$numbers -notcontains 99

$numbers -notcontains 42


##






#-----------------------------------------------------------------------------#
# This example shows how to create a MULTI-DIMENSIONAL ARRAY in PowerShell.
# For a full example and text, see Ed Wilson's article at:
# http://blogs.technet.com/b/heyscriptingguy/archive/2011/12/09/easily-create-and-manipulate-an-array-of-arrays-in-powershell.aspx
#-----------------------------------------------------------------------------#

# Load four individual arrays
$a = 1..5
$b = 6..10
$c = 11..15
$d = 16..20

# Now create an array from the four individual ones
$arrayNew = $a, $b, $c, $d

# Array will now look like
# Col      [0] [1] [2] [3] [4]
# Row [0]   1   2   3   4   5       # &lt;== $a
# Row [1]   6   7   8   9  10       # &lt;== $b
# Row [2]  11  12  13  14  15       # &lt;== $c
# Row [3]  16  17  18  19  20       # &lt;== $c

# Reference the second item in the second array (remember arrays are 0 based)
$array[1][2] # Zero based array, go to 2nd row, 3rd item

# Take the contents of the array, in Row[0], and join them into a single string and send them to the console 
$array[0] -join " "

##</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>String_Interpolation</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>String_Interpolation</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>  $retval += "`t$($_.Name)`r`n"               	#SHORTER b/c of Interpolation
  # Note this line could also be rendered as
  $retval = $retval + "`t" + $_.Name + "`r`n"  	#LONGER 


# This interprets a variables value into a string
# String Interpolation works with double quotes---------------------------------------------------
Set-Location C:\PS
Clear-Host

# Take the output of Get-ChildItem, which is an object, and gets that objects count property
# Wrapping the cmdlet in parenthesis treats the cmdlet as a collection of File Objects 
# Now the "Count" method works on the Collection, rather than individual objects
$items = (Get-ChildItem).Count

# Take the output of Get-Location and store it in a variable
$loc = Get-Location

# Use these variables in a string, NOTE the use of double qoutes
"There are $items items are in the folder $loc."

# To actually display the variable, escape it with a backtick
"There are `$items items are in the folder `$loc."

# String interpolation only works with double quotes, so the variables will not be treated as variables, 
#   but rather as part of the string
'There are $items items are in the folder $loc.'

# String Interpolation works with here strings
$hereinterpolation = @"
Items`tFolder
-----`t----------------------
$items`t`t$loc

"@

$hereinterpolation 

# Can use expressions in strings, need to be wrapped in $()
Clear-Host
"There are $((Get-ChildItem).Count) items are in the folder $(Get-Location)."

"Today is $(Get-Date). Be well."

"The 15% tip of a 33.33 dollar bill is $(33.33 * 0.15) dollars"

##
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>String_METHODS</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>String_METHODS</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$s.Length           #' &lt;==== this is a property
$s.ToUpper()        #' &lt;==== this is a Method

$s.Substring.OverloadDefinitions	#' To see the overloads for the method 'Substring'

=============================================================
$s = "powershell rocks!"
$s | Get-Member
'OUTPUT is list of methods and properties
--------
   TypeName: System.String

Name             MemberType            Definition                                                                                                                        
----             ----------            ----------                                                                                                                        
Clone            Method                System.Object Clone(), System.Object ICloneable.Clone()                                                                           
CompareTo        Method                int CompareTo(System.Object value), int CompareTo(string strB), int IComparable.CompareTo(System.Object obj), int IComparable[s...
Contains         Method                bool Contains(string value)                                                                                                       
CopyTo           Method                void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count)                                                 
EndsWith         Method                bool EndsWith(string value), bool EndsWith(string value, System.StringComparison comparisonType), bool EndsWith(string value, b...
Equals           Method                bool Equals(System.Object obj), bool Equals(string value), bool Equals(string value, System.StringComparison comparisonType), b...
GetEnumerator    Method                System.CharEnumerator GetEnumerator(), System.Collections.IEnumerator IEnumerable.GetEnumerator(), System.Collections.Generic.I...
GetHashCode      Method                int GetHashCode()                                                                                                                 
GetType          Method                type GetType()                                                                                                                    
GetTypeCode      Method                System.TypeCode GetTypeCode(), System.TypeCode IConvertible.GetTypeCode()                                                         
IndexOf          Method                int IndexOf(char value), int IndexOf(char value, int startIndex), int IndexOf(char value, int startIndex, int count), int Index...
										---------------------
										#'this is case-sensitive, results in the position of the first occurance of the letter 's'
										$s.IndexOf("s")
										---------------------
IndexOfAny       Method                int IndexOfAny(char[] anyOf), int IndexOfAny(char[] anyOf, int startIndex), int IndexOfAny(char[] anyOf, int startIndex, int co...
Insert           Method                string Insert(int startIndex, string value)                                                                                       
IsNormalized     Method                bool IsNormalized(), bool IsNormalized(System.Text.NormalizationForm normalizationForm)                                           
LastIndexOf      Method                int LastIndexOf(char value), int LastIndexOf(char value, int startIndex), int LastIndexOf(char value, int startIndex, int count...
										-----------------
										'Get the position of the last occurance of the letter 's'
										$s.LastIndexOf("s")
										-----------------
LastIndexOfAny   Method                int LastIndexOfAny(char[] anyOf), int LastIndexOfAny(char[] anyOf, int startIndex), int LastIndexOfAny(char[] anyOf, int startI...
Normalize        Method                string Normalize(), string Normalize(System.Text.NormalizationForm normalizationForm)                                             
PadLeft          Method                string PadLeft(int totalWidth), string PadLeft(int totalWidth, char paddingChar)                                                  
PadRight         Method                string PadRight(int totalWidth), string PadRight(int totalWidth, char paddingChar)                                                
Remove           Method                string Remove(int startIndex, int count), string Remove(int startIndex)                                                           
Replace          Method                string Replace(char oldChar, char newChar), string Replace(string oldValue, string newValue)                                      
										-----------------
										#'this is case-sensitive, replaces occurrances of 'e' with '3'
										$s.Replace("e","3")
										#'make multiple changes at once
										$name = $s.Replace("p","P").Replace("s","S")
										-----------------
Split            Method                string[] Split(Params char[] separator), string[] Split(char[] separator, int count), string[] Split(char[] separator, System.S...
										-----------------
										$t = 'a,b,c,d,e,f,g'    #'This is a string, not an array
										$t
										$t -is [array]
										$split = $t.Split(",")	#'This creates an Array named $split
										$split 
										$split -is [array]
										--------------------
										$name = 'glenn garson'
										$first = $name.split(' ')[0]
										$last = $name.split(' ')[1]
										-----------------
StartsWith       Method                bool StartsWith(string value), bool StartsWith(string value, System.StringComparison comparisonType), bool StartsWith(string va...
Substring        Method                string Substring(int startIndex), string Substring(int startIndex, int length)                                                    
										-----------------
										'0 is the first position, this gives the string's value starting at the 6th position
										$s.Substring(5)
										'0 is the first position, this gives the 3 characters starting at the 2nd position, ending at the 5th position
										$s.Substring(1,4)	
										------------------
ToBoolean        Method                bool IConvertible.ToBoolean(System.IFormatProvider provider)                                                                      
ToByte           Method                byte IConvertible.ToByte(System.IFormatProvider provider)                                                                         
ToChar           Method                char IConvertible.ToChar(System.IFormatProvider provider)                                                                         
ToCharArray      Method                char[] ToCharArray(), char[] ToCharArray(int startIndex, int length)                                                              
ToDateTime       Method                datetime IConvertible.ToDateTime(System.IFormatProvider provider)                                                                 
ToDecimal        Method                decimal IConvertible.ToDecimal(System.IFormatProvider provider)                                                                   
ToDouble         Method                double IConvertible.ToDouble(System.IFormatProvider provider)                                                                     
ToInt16          Method                int16 IConvertible.ToInt16(System.IFormatProvider provider)                                                                       
ToInt32          Method                int IConvertible.ToInt32(System.IFormatProvider provider)                                                                         
ToInt64          Method                long IConvertible.ToInt64(System.IFormatProvider provider)                                                                        
ToLower          Method                string ToLower(), string ToLower(cultureinfo culture)                                                                             
ToLowerInvariant Method                string ToLowerInvariant()                                                                                                         
ToSByte          Method                sbyte IConvertible.ToSByte(System.IFormatProvider provider)                                                                       
ToSingle         Method                float IConvertible.ToSingle(System.IFormatProvider provider)                                                                      
ToString         Method                string ToString(), string ToString(System.IFormatProvider provider), string IConvertible.ToString(System.IFormatProvider provider)
ToType           Method                System.Object IConvertible.ToType(type conversionType, System.IFormatProvider provider)                                           
ToUInt16         Method                uint16 IConvertible.ToUInt16(System.IFormatProvider provider)                                                                     
ToUInt32         Method                uint32 IConvertible.ToUInt32(System.IFormatProvider provider)                                                                     
ToUInt64         Method                uint64 IConvertible.ToUInt64(System.IFormatProvider provider)                                                                     
ToUpper          Method                string ToUpper(), string ToUpper(cultureinfo culture)  
										------------------
										'Gets uppercase
										------------------										                                                                           
ToUpperInvariant Method                string ToUpperInvariant()                                                                                                         
Trim             Method                string Trim(Params char[] trimChars), string Trim()                                                                               
TrimEnd          Method                string TrimEnd(Params char[] trimChars)                                                                                           
TrimStart        Method                string TrimStart(Params char[] trimChars)                                                                                         
Chars            ParameterizedProperty char Chars(int index) {get;}                                                                                                      
Length           Property              int Length {get;}  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_WiFi_Wireless</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>DELETE_all_Network_Profiles_LOCAL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_WiFi_Wireless</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>DELETE_all_Network_Profiles_LOCAL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>DELETE_all_Network_Profiles_LOCAL


==========================================================================
'https://gist.github.com/rleopold/b2af90f2261b33eb6bea8ecec76bbca0
$networks = netsh wlan show profiles | select-string 'All User Profile'

if($networks.Count -gt 0) {
  $(foreach ($item in $networks) {
    $item.Line.Split(':')[1].Trim()
  }) | Out-GridView -Title 'Select one or more neowrks to forget' -OutputMode Multiple |
  foreach {
    netsh wlan delete profile name = "$_"
  }
}
else {'No wifi networks detected'}
==========================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Windows_10</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_Windows_VersionForComputerList_v2.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Windows_10</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_Windows_VersionForComputerList_v2.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Get_Windows_VersionForComputerList_v2.ps1

#'$outfile = 'C:\data\computers_WindowsVersion.csv'
#'$infile = 'c:\data\computers.txt'



#' 1] Ping the computers and get the ones that respond:******************************************************************************************************************************    

$inTestcomputers = Get-Content -Path 'c:\data\2018_04_20_ALL_computerObjectsInActiveDirectory.txt'
$outRespondToPing = 'C:\DATA\2018_04_20__RespondToPing.txt'
$TEST = 'C:\DATA\TEST.txt'
'Run part 1 to see which machines ping
'Then using the list of the ones that PING'd get the Windows version
'NOTE: the servers were all wrong




$outDidNOTrespondToPING = 'C:\DATA\2018_04_20__DidNOTrespondToPING.txt'
$outfile = 'C:\data\2018_04_20__WindowsVersion.csv'

#'Test connection to each computer before getting the inventory info
foreach ($computer in $inTestcomputers) {
	if (Test-Connection -ComputerName $computer -Quiet -Count 2){
        	write-host "responded to PING:"$computer -ForegroundColor Green
			Add-Content -value $computer -path $outRespondToPing
		}else{
			write-host "No Response to PING:"$computer -ForegroundColor Red
			Add-Content -value $computer -path $outDidNOTrespondToPING 
		}
	}


#' 2] ******************************************************************************************************************************   
#'           $TEST = 'C:\DATA\TEST.txt'  
$outRespondToPing = 'C:\DATA\2018_04_20__RespondToPing.txt'
$outfile = 'C:\data\2018_04_20__WindowsVersion.csv'
 
           $theComputerOSinfo = @()
                    $computers = Get-Content $outRespondToPing
                    $i=0
                    $count = $computers.count
                    foreach($computer in $computers)
                     {
                            $i++
                            Write-Progress -Activity "Querying Computers" -Status "Computer: $i of $count " `
                            -PercentComplete ($i/$count*100)
                            $info = @{}
                            $version = 0
                            try{
                                #'================================================================================

                                            write-host "responded to PING:"$computer -ForegroundColor Green 
                                            #'--------------------------------------------------------------------------------
                                            $OperatingSystem = Get-WmiObject -ComputerName $computer -Class Win32_OperatingSystem
                                            #'--------------------------------------------------------------------------------
                                            $BuildNumber = $OperatingSystem.BuildNumber 
                                            write-host "Build Number:"$BuildNumber -ForegroundColor White                  
                                            switch  ($BuildNumber)
                                            {
                                                10240 {$Build = "1507, Threshold 1, N/A,  July 29, 2015"}
                                                10586 {$Build = "1511, Threshold 2, November Update,  2015/11/10"}
                                                14393 {$Build = "1607, Redstone 1, 2016/08/02"}
                                                15063 {$Build = "1703, Redstone 2, Creators Update, 2017/04/05"}
                                                16299 {$Build = "1709, Redstone 3, Fall Creators Update, 2017/10/17"}
                                                17134 {$Build = "1803, Redstone 4, Early 2018"}
                                                17650 {$Build = "1809, Redstone 5, Late 2018"}
                                                default {$Build = "default"}
                                            }
                                            write-host "Build:"$Build -ForegroundColor White 
                                            #'$Build 

                                            #'--------------------------------------------------------------------------------
                                            #'$OperatingSystem = Get-WmiObject -ComputerName IT-1241 -Class Win32_OperatingSystem
                                            $OS = $OperatingSystem.Version  
                                            write-host "OS:"$OS -ForegroundColor Yellow                  
                                            switch  ($OS)
                                            {
                                                "10.0.16299" {$OSName = "Windows 10 (1709)"}
                                                "10.0.15063" {$OSName = "Windows 10 (1703)"}
                                                "10.0.14393" {$OSName = "Windows 10 (1607)"}
                                                "10.0.10586" {$OSName = "Windows 10 (1511)"}
                                                "10.0.10240" {$OSName = "Windows 10"}
                                                "6.3.9600" {$OSName = "Windows 8.1 (Update 1) or Server"}
                                                "6.3.9200" {$OSName = "Windows 8.1 or Server "}
                                                "6.2.9200" {$OSName = "Windows 8"}
                                                "6.1.7601" {$OSName = "Windows 7 SP1"}
                                                "6.1.7600" {$OSName = "Windows 7"}
                                                "6.0.6002" {$OSName = "Windows Vista SP2"}
                                                "6.0.6001" {$OSName = "Windows Vista SP1"}
                                                "6.0.6000" {$OSName = "Windows Vista"}
                                                "5.1.2600" {$OSName = "Windows XP"}
                                                default {$OSName = "default"}
                                            }
                                            write-host "OSName:"$OSName -ForegroundColor Yellow 
                                #'================================================================================
                                }
 
 
                                catch
                                {
                                            $OperatingSystem  = 'Not Installed/Not Available'
                                }

                                $info.Computer = $computer
                                $info.OSName= $OSName
                                $info.Build =  $Build
                                $info.BuildNumber =  $BuildNumber
                                $info.OSversion = $OS

                                $object = new-object -TypeName PSObject -Property $info
                                $theComputerOSinfo += $object
                    }
                    $theComputerOSinfo | select computer,OSName,Build, BuildNumber,OSversion  | Export-Csv -NoTypeInformation -Path $outfile
#'    }


  write-output ("Done")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_WMI</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WMIExplorer.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_WMI</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WMIExplorer.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'  https://gallery.technet.microsoft.com/scriptcenter/89c759b7-20b4-49e8-98a8-3c8fbdb2dd69
#' WmiExplorer.ps1  
#'  
#' A GUI WMI explorer and WMI Method Help generator  
#'  
#' /\/\o\/\/ 2006  
#' www.ThePowerShellGuy.com  
#'  
#' load Forms NameSpace  
[void][System.Reflection.Assembly]::LoadWithPartialName("System.windows.forms")   
   
#'region BuildTheForm build in C# then translated to powershell  
#'region Make the form  
$frmMain = new-object Windows.Forms.form    
$frmMain.Size = new-object System.Drawing.Size @(800,600)    
$frmMain.text = "/\/\o\/\/'s PowerShell WMI Explorer"   
#'endregion Make the form  
#'region Define Used Controls  
$MainMenu = new-object System.Windows.Forms.MenuStrip  
$statusStrip = new-object System.Windows.Forms.StatusStrip  
$FileMenu = new-object System.Windows.Forms.ToolStripMenuItem  
$ToolMenu = new-object System.Windows.Forms.ToolStripMenuItem('&amp;tools')  
$miQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;Query (run)')  
$miSelectQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;SelectQuery')  
$miSelectQuery.add_Click({$sq | out-propertyGrid;$wmiSearcher.Query = $sq})  
[void]$ToolMenu.DropDownItems.Add($miSelectQuery)  
$miRelatedObjectQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;RelatedObjectQuery')  
$miRelatedObjectQuery.add_Click({$roq | out-propertyGrid;$wmiSearcher.Query = $roq})  
[void]$ToolMenu.DropDownItems.Add($miRelatedObjectQuery)  
$miRelationshipQuery = new-object System.Windows.Forms.ToolStripMenuItem('&amp;RelationshipQuery')  
$miRelationshipQuery.add_Click({$rq | out-propertyGrid ;$wmiSearcher.Query = $rq})  
[void]$ToolMenu.DropDownItems.Add($miRelationshipQuery)  
$oq = new-object System.Management.ObjectQuery  
$eq = new-object System.Management.EventQuery  
$sq = new-object System.Management.SelectQuery  
$roq = new-object System.Management.RelatedObjectQuery  
$rq = new-object System.Management.RelationshipQuery  
$wmiSearcher = [wmisearcher]''  
[void]$ToolMenu.DropDownItems.Add($miQuery)  
$miQuery.add_Click({  
    $wmiSearcher | out-propertyGrid  
    $moc = $wmiSearcher.get()  
    $DT =  new-object  System.Data.DataTable  
    $DT.TableName = $lblClass.text  
    $Col =  new-object System.Data.DataColumn  
    $Col.ColumnName = "WmiPath"  
    $DT.Columns.Add($Col)  
    $i = 0  
    $j = 0 ;$lblInstances.Text = $j; $lblInstances.Update()  
    $MOC |  
    ForEach-Object {  
        $j++ ;$lblInstances.Text = $j; $lblInstances.Update()  
        $MO = $_  
         
        #' Make a DataRow  
        $DR = $DT.NewRow()  
        $Col =  new-object System.Data.DataColumn  
        $DR.Item("WmiPath") = $mo.__PATH  
        $MO.psbase.properties |  
        ForEach-Object {  
         
            $prop = $_  
             
            If ($i -eq 0)  {  
     
                #' Only On First Row make The Headers  
                 
                $Col =  new-object System.Data.DataColumn  
                $Col.ColumnName = $prop.Name.ToString()  
   
                $prop.psbase.Qualifiers |  
                ForEach-Object {  
                    If ($_.Name.ToLower() -eq "key") {  
                        $Col.ColumnName = $Col.ColumnName + "*"  
                    }  
                }  
                $DT.Columns.Add($Col)   
            }  
             
            #' fill dataRow   
             
            if ($prop.value -eq $null) {  
                $DR.Item($prop.Name) = "[empty]"  
            } ElseIf ($prop.IsArray) {  
                $DR.Item($prop.Name) =[string]::Join($prop.value ,";")  
            } Else {  
                $DR.Item($prop.Name) = $prop.value  
                #'Item is Key try again with *  
                trap{$DR.Item("$($prop.Name)*") = $prop.Value.tostring();continue}  
            }  
        } #'end ForEach  
        #' Add the row to the DataTable  
         
        $DT.Rows.Add($DR)  
        $i += 1  
    }  
    $DGInstances.DataSource = $DT.psObject.baseobject    
    $status.Text = "Retrieved $j Instances"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
})#'$miQuery.add_Click  
 
$miQuit = new-object System.Windows.Forms.ToolStripMenuItem('&amp;quit')  
$miQuit.add_Click({$frmMain.close()})   
$SplitContainer1 = new-object System.Windows.Forms.SplitContainer  
$splitContainer2 = new-object System.Windows.Forms.SplitContainer  
$splitContainer3 = new-object System.Windows.Forms.SplitContainer  
$grpComputer = new-object System.Windows.Forms.GroupBox  
$grpNameSpaces = new-object System.Windows.Forms.GroupBox  
$grpClasses = new-object System.Windows.Forms.GroupBox  
$grpClass = new-object System.Windows.Forms.GroupBox  
$grpInstances = new-object System.Windows.Forms.GroupBox  
$grpStatus = new-object System.Windows.Forms.GroupBox  
$txtComputer = new-object System.Windows.Forms.TextBox  
$btnConnect = new-object System.Windows.Forms.Button  
$btnInstances = new-object System.Windows.Forms.Button  
$tvNameSpaces = new-object System.Windows.Forms.TreeView  
$lvClasses = new-object System.Windows.Forms.ListView  
$clbProperties = new-object System.Windows.Forms.CheckedListBox  
$clbProperties.CheckOnClick = $true  
$lbMethods = new-object System.Windows.Forms.ListBox  
$label1 = new-object System.Windows.Forms.Label  
$label2 = new-object System.Windows.Forms.Label  
$lblServer = new-object System.Windows.Forms.Label  
$lblPath = new-object System.Windows.Forms.Label  
$lblNameSpace = new-object System.Windows.Forms.Label  
$label6 = new-object System.Windows.Forms.Label  
$lblClass = new-object System.Windows.Forms.Label  
$label10 = new-object System.Windows.Forms.Label  
$lblClasses = new-object System.Windows.Forms.Label  
$label12 = new-object System.Windows.Forms.Label  
$lblProperties = new-object System.Windows.Forms.Label  
$label8 = new-object System.Windows.Forms.Label  
$lblMethods = new-object System.Windows.Forms.Label  
$label14 = new-object System.Windows.Forms.Label  
$lblInstances = new-object System.Windows.Forms.Label  
$label16 = new-object System.Windows.Forms.Label  
$dgInstances = new-object System.Windows.Forms.DataGridView  
$TabControl = new-object System.Windows.Forms.TabControl  
$tabPage1 = new-object System.Windows.Forms.TabPage  
$tabInstances = new-object System.Windows.Forms.TabPage  
$rtbHelp = new-object System.Windows.Forms.RichTextBox  
$tabMethods = new-object System.Windows.Forms.TabPage  
$rtbMethods = new-object System.Windows.Forms.RichTextBox  
#'endregion Define Used Controls         
#'region Suspend the Layout  
$splitContainer1.Panel1.SuspendLayout()  
$splitContainer1.Panel2.SuspendLayout()  
$splitContainer1.SuspendLayout()  
$splitContainer2.Panel1.SuspendLayout()  
$splitContainer2.Panel2.SuspendLayout()  
$splitContainer2.SuspendLayout()  
$grpComputer.SuspendLayout()  
$grpNameSpaces.SuspendLayout()  
$grpClasses.SuspendLayout()  
$splitContainer3.Panel1.SuspendLayout()  
$splitContainer3.Panel2.SuspendLayout()  
$splitContainer3.SuspendLayout()  
$grpClass.SuspendLayout()  
$grpStatus.SuspendLayout()  
$grpInstances.SuspendLayout()  
$TabControl.SuspendLayout()  
$tabPage1.SuspendLayout()  
$tabInstances.SuspendLayout()  
$FrmMain.SuspendLayout()  
#'endregion Suspend the Layout  
#'region Configure Controls  
[void]$MainMenu.Items.Add($FileMenu)  
[void]$MainMenu.Items.Add($ToolMenu)  
$MainMenu.Location = new-object System.Drawing.Point(0, 0)  
$MainMenu.Name = "MainMenu"  
$MainMenu.Size = new-object System.Drawing.Size(1151, 24)  
$MainMenu.TabIndex = 0  
$MainMenu.Text = "Main Menu"  
#'  
#' statusStrip1  
#'  
$statusStrip.Location = new-object System.Drawing.Point(0, 569)  
$statusStrip.Name = "statusStrip"  
$statusStrip.Size = new-object System.Drawing.Size(1151, 22);  
$statusStrip.TabIndex = 1  
$statusStrip.Text = "statusStrip"  
$splitContainer1.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer1.Location = new-object System.Drawing.Point(0, 24)  
$splitContainer1.Name = "splitContainer1"  
$splitContainer1.Panel1.Controls.Add($splitContainer2)  
$splitContainer1.Panel2.Controls.Add($splitContainer3)  
$splitContainer1.Size = new-object System.Drawing.Size(1151, 545)  
$splitContainer1.SplitterDistance = 372  
$splitContainer1.TabIndex = 2  
$splitContainer2.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$splitContainer2.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer2.Location = new-object System.Drawing.Point(0, 0)  
$splitContainer2.Name = "splitContainer2"  
$splitContainer2.Orientation = [System.Windows.Forms.Orientation]::Horizontal  
$splitContainer2.Panel1.BackColor = [System.Drawing.SystemColors]::Control  
$splitContainer2.Panel1.Controls.Add($grpNameSpaces)  
$splitContainer2.Panel1.Controls.Add($btnConnect)  
$splitContainer2.Panel1.Controls.Add($grpComputer)  
$splitContainer2.Panel2.Controls.Add($grpClasses)  
$splitContainer2.Size = new-object System.Drawing.Size(372, 545)  
$splitContainer2.SplitterDistance = 302  
$splitContainer2.TabIndex = 0  
#'  
#' fileMenu  
#'  
[void]$fileMenu.DropDownItems.Add($miQuit)  
$fileMenu.Name = "fileMenu"  
$fileMenu.Size = new-object System.Drawing.Size(35, 20)  
$fileMenu.Text = "&amp;File"  
$grpComputer.Anchor = "top, left, right"  
$grpComputer.Controls.Add($txtComputer)  
$grpComputer.Location = new-object System.Drawing.Point(12, 3)  
$grpComputer.Name = "grpComputer"  
$grpComputer.Size = new-object System.Drawing.Size(340, 57)  
$grpComputer.TabIndex = 0  
$grpComputer.TabStop = $false  
$grpComputer.Text = "Computer"  
$txtComputer.Anchor = "top, left, right"  
$txtComputer.Location = new-object System.Drawing.Point(7, 20)  
$txtComputer.Name = "txtComputer"  
$txtComputer.Size = new-object System.Drawing.Size(244, 20)  
$txtComputer.TabIndex = 0  
$txtComputer.Text = "."  
 
$btnConnect.Anchor = "top, right"  
$btnConnect.Location = new-object System.Drawing.Point(269, 23);  
$btnConnect.Name = "btnConnect"  
$btnConnect.Size = new-object System.Drawing.Size(75, 23)  
$btnConnect.TabIndex = 1  
$btnConnect.Text = "Connect"  
$btnConnect.UseVisualStyleBackColor = $true  
#'  
#' grpNameSpaces  
#'  
$grpNameSpaces.Anchor = "Bottom, top, left, right"  
$grpNameSpaces.Controls.Add($tvNameSpaces)  
$grpNameSpaces.Location = new-object System.Drawing.Point(12, 67)  
$grpNameSpaces.Name = "grpNameSpaces"  
$grpNameSpaces.Size = new-object System.Drawing.Size(340, 217)  
$grpNameSpaces.TabIndex = 2  
$grpNameSpaces.TabStop = $false  
$grpNameSpaces.Text = "NameSpaces"  
#'  
#' grpClasses  
#'  
$grpClasses.Anchor = "Bottom, top, left, right"  
$grpClasses.Controls.Add($lvClasses)  
$grpClasses.Location = new-object System.Drawing.Point(12, 14)  
$grpClasses.Name = "grpClasses"  
$grpClasses.Size = new-object System.Drawing.Size(340, 206)  
$grpClasses.TabIndex = 0  
$grpClasses.TabStop = $False  
$grpClasses.Text = "Classes"  
#'  
#' tvNameSpaces  
#'  
$tvNameSpaces.Anchor = "Bottom, top, left, right"  
$tvNameSpaces.Location = new-object System.Drawing.Point(7, 19)  
$tvNameSpaces.Name = "tvNameSpaces"  
$tvNameSpaces.Size = new-object System.Drawing.Size(325, 184)  
$tvNameSpaces.TabIndex = 0  
#'  
#' tvClasses  
#'  
$lvClasses.Anchor = "Bottom, top, left, right"  
$lvClasses.Location = new-object System.Drawing.Point(7, 19)  
$lvClasses.Name = "tvClasses"  
$lvClasses.Size = new-object System.Drawing.Size(325, 172)  
$lvClasses.TabIndex = 0  
$lvClasses.UseCompatibleStateImageBehavior = $False  
$lvClasses.ShowItemToolTips = $true  
$lvClasses.View = 'Details'  
$colName = $lvClasses.Columns.add('Name')  
$colname.Width = 160  
$colPath = $lvClasses.Columns.add('Description')  
$colname.Width = 260  
$colPath = $lvClasses.Columns.add('Path')  
$colname.Width = 260  
#'  
#' splitContainer3  
#'  
$splitContainer3.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$splitContainer3.Dock = [System.Windows.Forms.DockStyle]::Fill  
$splitContainer3.Location = new-object System.Drawing.Point(0, 0)  
$splitContainer3.Name = "splitContainer3"  
$splitContainer3.Orientation = [System.Windows.Forms.Orientation]::Horizontal  
#'  
#' splitContainer3.Panel1  
#'  
$splitContainer3.Panel1.Controls.Add($grpStatus)  
$splitContainer3.Panel1.Controls.Add($grpClass)  
#'  
#' splitContainer3.Panel2  
#'  
$splitContainer3.Panel2.Controls.Add($TabControl)  
$splitContainer3.Size = new-object System.Drawing.Size(775, 545)  
$splitContainer3.SplitterDistance = 303  
$splitContainer3.TabIndex = 0  
#'  
#' grpClass  
#'  
$grpClass.Anchor = "Bottom, top, left, right"  
$grpClass.Controls.Add($lblInstances)  
$grpClass.Controls.Add($label16)  
$grpClass.Controls.Add($lblMethods)  
$grpClass.Controls.Add($label14)  
$grpClass.Controls.Add($lblProperties)  
$grpClass.Controls.Add($label8)  
$grpClass.Controls.Add($lblClass)  
$grpClass.Controls.Add($label10)  
$grpClass.Controls.Add($lbMethods)  
$grpClass.Controls.Add($clbProperties)  
$grpClass.Controls.Add($btnInstances)  
$grpClass.Location = new-object System.Drawing.Point(17, 86)  
$grpClass.Name = "grpClass"  
$grpClass.Size = new-object System.Drawing.Size(744, 198)  
$grpClass.TabIndex = 0  
$grpClass.TabStop = $False  
$grpClass.Text = "Class"  
#'  
#' btnInstances  
#'  
$btnInstances.Anchor = "Bottom, Left"  
$btnInstances.Location = new-object System.Drawing.Point(6, 169);  
$btnInstances.Name = "btnInstances";  
$btnInstances.Size = new-object System.Drawing.Size(96, 23);  
$btnInstances.TabIndex = 0;  
$btnInstances.Text = "Get Instances";  
$btnInstances.UseVisualStyleBackColor = $true  
#'  
#' grpStatus  
#'  
$grpStatus.Anchor = "Top,Left,Right"  
$grpStatus.Controls.Add($lblClasses)  
$grpStatus.Controls.Add($label12)  
$grpStatus.Controls.Add($lblNameSpace)  
$grpStatus.Controls.Add($label6)  
$grpStatus.Controls.Add($lblPath)  
$grpStatus.Controls.Add($lblServer)  
$grpStatus.Controls.Add($label2)  
$grpStatus.Controls.Add($label1)  
$grpStatus.Location = new-object System.Drawing.Point(17, 3)  
$grpStatus.Name = "grpStatus"  
$grpStatus.Size = new-object System.Drawing.Size(744, 77)  
$grpStatus.TabIndex = 1  
$grpStatus.TabStop = $False  
$grpStatus.Text = "Status"  
#'  
#' label1  
#'  
$label1.AutoSize = $true  
$label1.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label1.Location = new-object System.Drawing.Point(7, 20)  
$label1.Name = "label1"  
$label1.Size = new-object System.Drawing.Size(62, 16)  
$label1.TabIndex = 0  
$label1.Text = "Server :"  
#'  
#' label2  
#'  
$label2.AutoSize = $true  
$label2.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label2.Location = new-object System.Drawing.Point(7, 41)  
$label2.Name = "label2"  
$label2.Size = new-object System.Drawing.Size(51, 16)  
$label2.TabIndex = 1  
$label2.Text = "Path  :"  
#'  
#' lblServer  
#'  
$lblServer.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblServer.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblServer.Location = new-object System.Drawing.Point(75, 20)  
$lblServer.Name = "lblServer"  
$lblServer.Size = new-object System.Drawing.Size(144, 20)  
$lblServer.TabIndex = 2  
#'  
#' lblPath  
#'  
$lblPath.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblPath.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblPath.Location = new-object System.Drawing.Point(75, 40)  
$lblPath.Name = "lblPath"  
$lblPath.Size = new-object System.Drawing.Size(567, 20)  
$lblPath.TabIndex = 3  
#'  
#' lblNameSpace  
#'  
$lblNameSpace.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblNameSpace.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblNameSpace.Location = new-object System.Drawing.Point(337, 20)  
$lblNameSpace.Name = "lblNameSpace"  
$lblNameSpace.Size = new-object System.Drawing.Size(144, 20)  
$lblNameSpace.TabIndex = 5  
#'  
#' label6  
#'  
$label6.AutoSize = $true  
$label6.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label6.Location = new-object System.Drawing.Point(229, 20)  
$label6.Name = "label6"  
$label6.Size = new-object System.Drawing.Size(102, 16)  
$label6.TabIndex = 4  
$label6.Text = "NameSpace :"  
#'  
#' lblClass  
#'  
$lblClass.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblClass.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblClass.Location = new-object System.Drawing.Point(110, 26)  
$lblClass.Name = "lblClass"  
$lblClass.Size = new-object System.Drawing.Size(159, 20)  
$lblClass.TabIndex = 11  
#'  
#' label10  
#'  
$label10.AutoSize = $true  
$label10.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label10.Location = new-object System.Drawing.Point(6, 26)  
$label10.Name = "label10"  
$label10.Size = new-object System.Drawing.Size(55, 16)  
$label10.TabIndex = 10  
$label10.Text = "Class :"  
#'  
#' lblClasses  
#'  
$lblClasses.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblClasses.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblClasses.Location = new-object System.Drawing.Point(595, 21)  
$lblClasses.Name = "lblClasses"  
$lblClasses.Size = new-object System.Drawing.Size(47, 20)  
$lblClasses.TabIndex = 9  
#'  
#' label12  
#'  
$label12.AutoSize = $true  
$label12.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label12.Location = new-object System.Drawing.Point(487, 21)  
$label12.Name = "label12"  
$label12.Size = new-object System.Drawing.Size(76, 16)  
$label12.TabIndex = 8  
$label12.Text = "Classes  :"  
#'  
#' clbProperties  
#'  
$clbProperties.Anchor = "Bottom, top,left"  
$clbProperties.FormattingEnabled = $true  
$clbProperties.Location = new-object System.Drawing.Point(510, 27)  
$clbProperties.Name = "clbProperties"  
$clbProperties.Size = new-object System.Drawing.Size(220, 160)  
$clbProperties.TabIndex = 1  
#'  
#' lbMethods  
#'  
$lbMethods.Anchor = "Bottom, top, Left"  
$lbMethods.FormattingEnabled = $true  
$lbMethods.Location = new-object System.Drawing.Point(280, 27)  
$lbMethods.Name = "lbMethods"  
$lbMethods.Size = new-object System.Drawing.Size(220, 160)  
$lbMethods.TabIndex = 2  
#'  
#' lblProperties  
#'  
$lblProperties.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblProperties.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblProperties.Location = new-object System.Drawing.Point(110, 46)  
$lblProperties.Name = "lblProperties"  
$lblProperties.Size = new-object System.Drawing.Size(119, 20)  
$lblProperties.TabIndex = 13  
#'  
#' label8  
#'  
$label8.AutoSize = $true  
$label8.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label8.Location = new-object System.Drawing.Point(6, 46)  
$label8.Name = "label8"  
$label8.Size = new-object System.Drawing.Size(88, 16)  
$label8.TabIndex = 12  
$label8.Text = "Properties :"  
#'  
#' lblMethods  
#'  
$lblMethods.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblMethods.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblMethods.Location = new-object System.Drawing.Point(110, 66)  
$lblMethods.Name = "lblMethods"  
$lblMethods.Size = new-object System.Drawing.Size(119, 20)  
$lblMethods.TabIndex = 15  
#'  
#' label14  
#'  
$label14.AutoSize = $true  
$label14.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label14.Location = new-object System.Drawing.Point(6, 66)  
$label14.Name = "label14"  
$label14.Size = new-object System.Drawing.Size(79, 16)  
$label14.TabIndex = 14  
$label14.Text = "Methods  :"  
#'  
#' lblInstances  
#'  
$lblInstances.BorderStyle = [System.Windows.Forms.BorderStyle]::Fixed3D  
$lblInstances.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$lblInstances.Location = new-object System.Drawing.Point(110, 86)  
$lblInstances.Name = "lblInstances"  
$lblInstances.Size = new-object System.Drawing.Size(119, 20)  
$lblInstances.TabIndex = 17  
#'  
#' label16  
#'  
$label16.AutoSize = $true  
$label16.Font = new-object System.Drawing.Font("Microsoft Sans Serif",9.75 ,[System.Drawing.FontStyle]::Bold)  
$label16.Location = new-object System.Drawing.Point(6, 86)  
$label16.Name = "label16"  
$label16.Size = new-object System.Drawing.Size(82, 16)  
$label16.TabIndex = 16  
$label16.Text = "Instances :"  
#'  
#' grpInstances  
#'  
$grpInstances.Anchor = "Bottom, top, left, right"  
$grpInstances.Controls.Add($dgInstances)  
$grpInstances.Location = new-object System.Drawing.Point(17, 17)  
$grpInstances.Name = "grpInstances"  
$grpInstances.Size = new-object System.Drawing.Size(744, 202)  
$grpInstances.TabIndex = 0  
$grpInstances.TabStop = $False  
$grpInstances.Text = "Instances"  
#'  
#' dgInstances  
#'  
$dgInstances.Anchor = "Bottom, top, left, right"  
$dgInstances.ColumnHeadersHeightSizeMode = [System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode]::AutoSize  
$dgInstances.Location = new-object System.Drawing.Point(10, 19)  
$dgInstances.Name = "dgInstances"  
$dgInstances.Size = new-object System.Drawing.Size(728, 167)  
$dgInstances.TabIndex = 0  
$dginstances.ReadOnly = $true  
#' TabControl  
#'  
$TabControl.Controls.Add($tabPage1)  
$TabControl.Controls.Add($tabInstances)  
$TabControl.Controls.Add($tabMethods)  
$TabControl.Dock = [System.Windows.Forms.DockStyle]::Fill  
$TabControl.Location = new-object System.Drawing.Point(0, 0)  
$TabControl.Name = "TabControl"  
$TabControl.SelectedIndex = 0  
$TabControl.Size = new-object System.Drawing.Size(771, 234)  
$TabControl.TabIndex = 0  
#'  
#' tabPage1  
#'  
$tabPage1.Controls.Add($rtbHelp)  
$tabPage1.Location = new-object System.Drawing.Point(4, 22)  
$tabPage1.Name = "tabPage1"  
$tabPage1.Padding = new-object System.Windows.Forms.Padding(3)  
$tabPage1.Size = new-object System.Drawing.Size(763, 208)  
$tabPage1.TabIndex = 0  
$tabPage1.Text = "Help"  
$tabPage1.UseVisualStyleBackColor = $true  
#'  
#' tabInstances  
#'  
$tabInstances.Controls.Add($grpInstances)  
$tabInstances.Location = new-object System.Drawing.Point(4, 22)  
$tabInstances.Name = "tabInstances"  
$tabInstances.Padding = new-object System.Windows.Forms.Padding(3)  
$tabInstances.Size = new-object System.Drawing.Size(763, 208)  
$tabInstances.TabIndex = 1  
$tabInstances.Text = "Instances"  
$tabInstances.UseVisualStyleBackColor = $true  
#'  
#' richTextBox1  
#'  
$rtbHelp.Dock = [System.Windows.Forms.DockStyle]::Fill  
$rtbHelp.Location = new-object System.Drawing.Point(3, 3)  
$rtbHelp.Name = "richTextBox1"  
$rtbHelp.Size = new-object System.Drawing.Size(757, 202)  
$rtbHelp.TabIndex = 0  
$rtbHelp.Text = ""  
#'  
#' tabMethods  
#'  
$tabMethods.Location = new-object System.Drawing.Point(4, 22)  
$tabMethods.Name = "tabMethods"  
$tabMethods.Padding = new-object System.Windows.Forms.Padding(3)  
$tabMethods.Size = new-object System.Drawing.Size(763, 208)  
$tabMethods.TabIndex = 2  
$tabMethods.Text = "Methods"  
$tabMethods.UseVisualStyleBackColor = $true  
 
        $rtbMethods.Dock = [System.Windows.Forms.DockStyle]::Fill  
        $rtbMethods.Font = new-object System.Drawing.Font("Lucida Console",8 )  
        $rtbMethods.DetectUrls = $false  
        $tabMethods.controls.add($rtbMethods)  
         
#'endregion Configure Controls  
#' Configure  Main Form  
#'region frmMain  
 
#'  
$frmMain.AutoScaleDimensions = new-object System.Drawing.SizeF(6, 13)  
$frmMain.AutoScaleMode = [System.Windows.Forms.AutoScaleMode]::Font  
$frmMain.ClientSize = new-object System.Drawing.Size(1151, 591)  
$frmMain.Controls.Add($splitContainer1)  
$frmMain.Controls.Add($statusStrip)  
$frmMain.Controls.Add($MainMenu)  
$frmMain.MainMenuStrip = $mainMenu  
$FrmMain.Name = "frmMain"  
$FrmMain.Text = "/\/\o\/\/ PowerShell WMI Browser"  
$mainMenu.ResumeLayout($false)  
$mainMenu.PerformLayout()  
$MainMenu.ResumeLayout($false)  
$MainMenu.PerformLayout()  
$splitContainer1.Panel1.ResumeLayout($false)  
$splitContainer1.Panel2.ResumeLayout($false)  
$splitContainer1.ResumeLayout($false)  
$splitContainer2.Panel1.ResumeLayout($false)  
$splitContainer2.Panel2.ResumeLayout($false)  
$splitContainer2.ResumeLayout($false)  
$grpComputer.ResumeLayout($false)  
$grpComputer.PerformLayout()  
$grpNameSpaces.ResumeLayout($false)  
$grpClasses.ResumeLayout($false)  
$splitContainer3.Panel1.ResumeLayout($false)  
$splitContainer3.Panel2.ResumeLayout($false)  
$splitContainer3.ResumeLayout($false)  
$grpClass.ResumeLayout($false)  
$grpClass.PerformLayout()  
$grpStatus.ResumeLayout($false)  
$grpStatus.PerformLayout()  
$grpInstances.ResumeLayout($false)  
$TabControl.ResumeLayout($false)  
$tabPage1.ResumeLayout($false)  
$tabInstances.ResumeLayout($false)  
$frmMain.ResumeLayout($false)  
$FrmMain.PerformLayout()  
$status = new-object System.Windows.Forms.ToolStripStatusLabel  
$status.BorderStyle = 'SunkenInner'  
$status.BorderSides = 'All'  
$status.Text = "Not Connected"  
[void]$statusStrip.Items.add($status)  
$slMessage = new-object System.Windows.Forms.ToolStripStatusLabel  
$slMessage.BorderStyle = 'SunkenInner'  
$slMessage.BorderSides = 'All'  
$slMessage.Text = ""  
[void]$statusStrip.Items.add($slMessage)  
#'endregion frmMain  
#'endregion  
#'region Helper Functions  
Function out-PropertyGrid {  
  Param ($Object,[switch]$noBase,[Switch]$array)  
  $PsObject = $null  
  if ($object) {  
      $PsObject = $object  
  }Else{  
     if ($Array.IsPresent) {  
         $PsObject = @()  
         $input |ForEach-Object {$PsObject += $_}  
     }Else{  
         $input |ForEach-Object {$PsObject = $_}  
     }  
  }  
  if ($PsObject){  
      $form = new-object Windows.Forms.Form   
      $form.Size = new-object Drawing.Size @(600,600)   
      $PG = new-object Windows.Forms.PropertyGrid   
      $PG.Dock = 'Fill'   
      $form.text = "$psObject"   
      if ($noBase.IsPresent) {"no";  
          $PG.selectedobject = $psObject   
      }Else{  
          $PG.selectedobject = $psObject.PsObject.baseobject   
      }   
      $form.Controls.Add($PG)   
      $Form.Add_Shown({$form.Activate()})    
      $form.showdialog()  
  }  
} #'Function out-PropertyGrid  
Function Update-Status {  
  $script:computer = $Script:NameSpaces.__SERVER  
  $txtComputer.Text = $script:computer  
  $lblPath.Text = $Script:NameSpaces.__PATH                                 
  $lblProperties.Text = $Script:NameSpaces.__PROPERTY_COUNT                                 
  $lblClass.Text = $Script:NameSpaces.__RELPATH                                     
  $lblServer.Text = $script:Computer  
  $lblnamespace.Text = $Script:NameSpaces.__NAMESPACE  
} #' Function Update-Status  
Function Set-StatusBar ([Drawing.Color]$Color,$Text) {  
  $status.BackColor = $color  
  $status.Text = $text  
  $statusstrip.Update()    
}  
#'endregion Helper Functions  
#'################### Main ###############################  
#'region Global Variables  
$FontBold = new-object System.Drawing.Font("Microsoft Sans Serif",8,[Drawing.FontStyle]'Bold' )  
$fontNormal = new-object System.Drawing.Font("Microsoft Sans Serif",8,[Drawing.FontStyle]'Regular')  
$fontCode = new-object System.Drawing.Font("Lucida Console",8 )  
#' Create Script Variables for WMI Connection  
$Script:ConnectionOptions = new-object System.Management.ConnectionOptions  
$script:WmiConnection = new-object system.management.ManagementScope  
$script:WmiClass = [wmiClass]''  
#' NamespaceCaching , Make HashTable to store Treeview Items  
$script:nsc = @{}  
#' Make DataSet for secondary Cache  
$Script:dsCache = new-object data.dataset  
if (-not ${Global:WmiExplorer.dtClasses}){  
    ${Global:WmiExplorer.dtClasses} = new-object data.datatable  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Path',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Namespace',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('name',[string]))  
    [VOID](${Global:WmiExplorer.dtClasses}.Columns.add('Description',[string]))  
    ${Global:WmiExplorer.dtClasses}.tablename = 'Classes'  
}  
#'endregion  
#'region Control Handlers  
#' Add Delegate Scripts to finetune the WMI Connection objects to the events of the controls  
$slMessage.DoubleClickEnabled = $true  
$slMessage.add_DoubleClick({$error[0] | out-PropertyGrid})  
$lblNameSpace.add_DoubleClick({$script:WmiConnection | out-PropertyGrid})  
$lblserver.add_DoubleClick({$Script:ConnectionOptions | out-PropertyGrid})  
$lblClass.add_DoubleClick({$script:WmiClass | out-PropertyGrid})  
 
$btnConnect.add_click({ConnectToComputer})  
$TVNameSpaces.add_DoubleClick({GetClassesFromNameSpace})  
$lvClasses.Add_DoubleClick({GetWmiClass})  
$btnInstances.add_Click({GetWmiInstances})  
$dgInstances.add_DoubleClick({OutputWmiInstance})  
$lbMethods.Add_DoubleClick({GetWmiMethod})  
$clbProperties.add_Click({  
  trap{Continue}  
  $DGInstances.Columns.Item(($this.SelectedItem)).visible = -not $clbProperties.GetItemChecked($this.SelectedIndex)  
})  
$TVNameSpaces.add_AfterSelect({  
    if ($this.SelectedNode.name -ne $Computer){  
        $lblPath.Text = "$($script:WmiConnection.path.path.replace('\root',''))\$($this.SelectedNode.Text)"   
    }  
   
    $lblProperties.Text = $Script:NameSpaces.__PROPERTY_COUNT                                 
    $lblServer.Text = $Script:NameSpaces.__SERVER  
    $lblnamespace.Text = $this.SelectedNode.Text  
    if ($this.SelectedNode.tag -eq "NotEnumerated") {  
        (new-object system.management.managementClass(  
                "$($script:WmiConnection.path.path.replace('\root',''))\$($this.SelectedNode.Text):__NAMESPACE")  
        ).PSbase.getInstances() | Sort-Object $_.name |  
        ForEach-Object {  
          $TN = new-object System.Windows.Forms.TreeNode  
          $TN.Name = $_.name  
          $TN.Text = ("{0}\{1}" -f $_.__NameSpace,$_.name)  
          $TN.tag = "NotEnumerated"  
          $this.SelectedNode.Nodes.Add($TN)  
        }  
         
        #' Set tag to show this node is already enumerated  
        $this.SelectedNode.tag = "Enumerated"  
    }  
    $mp = ("{0}\{1}" -f $script:WmiConnection.path.path.replace('\root','') , $this.SelectedNode.text)  
    $lvClasses.Items.Clear()  
    if($Script:nsc.Item("$mp")){ #' in Namespace cache  
        $lvClasses.BeginUpdate()  
        $lvClasses.Items.AddRange(($nsc.Item( "$mp")))  
        $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
        $lvClasses.EndUpdate()  
        $lblClasses.Text = $lvClasses.Items.count  
    } else {  
        if(${Global:WmiExplorer.dtClasses}.Select("Namespace='$mp'")){ #' In DataTable Cache  
            $status.BackColor = 'beige'  
            $status.Text = "$mp : Classes in Cache, DoubleClick NameSpace to retrieve Classes"  
        } else {  
            $status.BackColor = 'LightSalmon'  
            $status.Text = "$mp : Classes not recieved yet, DoubleClick NameSpace to retrieve Classes"  
        }  
    }  
}) #' $TVNameSpaces.add_AfterSelect  
#'endregion  
#'region Processing Functions  
#'region ConnectToComputer  
#' Connect to Computer  
Function ConnectToComputer {  
     
    $computer = $txtComputer.Text  
    Set-StatusBar 'beige' "Connecting to : $computer"  
     
    #' Try to Connect to Computer  
    &amp;{  
        trap {  
            Set-StatusBar 'Red' "Connecting to : $computer Failed"  
            $slMessage.Text = "$_.message"  
            Continue  
        }  
        &amp;{  
            #' Connect to WMI root  
             
            $script:WmiConnection.path = "\\$computer\root"  
            $script:WmiConnection.options = $Script:ConnectionOptions  
            $script:WmiConnection.Connect()  
             
            #' Get Avaiable NameSpaces  
     
            $opt = new-object system.management.ObjectGetOptions  
            $opt.UseAmendedQualifiers = $true  
            $Script:NameSpaces = new-object System.Management.ManagementClass(  
                $script:WmiConnection,[Management.ManagementPath]'__Namespace',$opt  
            )  
            Update-Status  
            #' Create a TreeNode for the WMI Root found  
            $computer = $txtComputer.Text  
            $TNRoot = new-object System.Windows.Forms.TreeNode("Root")  
            $TNRoot.Name = $Computer  
            $TNRoot.Text = $lblPath.Text  
            $TNRoot.tag = "Enumerated"  
             
            #' Create NameSpaces List  
             
            $Script:NameSpaces.PSbase.getInstances() | Sort-Object $_.name |  
            ForEach-Object {  
                $TN = new-object System.Windows.Forms.TreeNode  
                $TN.Name = $_.name  
                $TN.Text = ("{0}\{1}" -f $_.__NameSpace,$_.name)  
                $TN.tag = "NotEnumerated"  
                [void]$TNRoot.Nodes.Add($TN)  
            }  
            #' Add to Treeview  
            $tvNameSpaces.Nodes.clear()  
            [void]$TVNamespaces.Nodes.Add($TNRoot)  
             
            #' update StatusBar  
            Set-StatusBar 'YellowGreen' "Connected to : $computer"  
        }  
    }  
} #' ConnectToComputer  
#'endregion  
#'region GetClasseFromNameSpace  
#' Get Classes on DoubleClick on Namespace in TreeView  
Function GetClassesFromNameSpace {  
  if ($this.SelectedNode.name -ne $script:computer){  
    #' Connect to WMI Namespace  
         
    $mp = ("{0}\{1}" -f $script:WmiConnection.path.path.replace('\root','') , $this.SelectedNode.text)  
      #' Update Status  
         
      $lvClasses.BeginUpdate()  
      $lvClasses.Items.Clear()  
      $i = 0 ;$lblClasses.Text = $i; $lblclasses.Update()  
    if($Script:nsc.Item("$mp")){ #'in Namespace Cache, so just attach to ListView again  
         
        $lvClasses.Items.AddRange(($nsc.Item( "$mp")))  
        #' $lvClasses.Items.AddRange(([System.Windows.Forms.ListViewItem[]]($nsc.Item( "$mp") |  
            #' where {$_.name -like 'win32_*'})))  
        $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
        $i = $lvClasses.Items.count  
    } else { #'Not In NameSpace Cache  
      if(${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'")){ #' In DataTable cache, so get from there  
        $status.Text = "loading cache from $($this.SelectedNode.name)"  
        $statusStrip.Update()  
        ${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'") |  
        foreach {  
            $i++  
            $LI = New-Object system.Windows.Forms.ListViewItem  
            $li.Name = $_.name  
            $li.Text = $_.name  
            $li.SubItems.add($_.description)  
            $li.SubItems.add($_.path)  
            $li.ToolTipText = ($_.description)  
            $lvClasses.Items.add($li)  
            $status.Text = "$mp : $($lvClasses.Items.count) Classes"  
            $lblClasses.Text = $lvClasses.Items.count  
        }  
      } else { #' Not in any Cache , Load WMI Classes  
        Set-StatusBar 'Khaki' "Getting Classes from $($this.SelectedNode.name)"  
        $mc = new-object System.Management.ManagementClass($mp,$opt)  
        $eo = New-Object system.management.EnumerationOptions  
        $eo.EnumerateDeep = $true  
        $eo.UseAmendedQualifiers = $true  
        $Mc.psbase.GetSubclasses($eo) |  
        ForEach-Object  {  
            $i++ ; if ($i%10 -eq 0){$lblClasses.Text = $i;$lblclasses.Update() }  
            Trap{$script:Description = "[Empty]";continue}  
            $script:description = $_.psbase.Qualifiers.item("description").value  
            ${Global:WmiExplorer.dtClasses}.Rows.Add($_.__path,$mp,$_.name,$description)  
            $LI = New-Object system.Windows.Forms.ListViewItem  
            $li.Name = $_.name  
            $li.Text = $_.name  
            $li.SubItems.add($description)  
            $li.SubItems.add($_.__path)  
            $li.ToolTipText = $description  
            $lvClasses.Items.add($li)  
        }  
        $status.Text = "Ready, Retrieved $i Classes from $mp"  
      } #'if(${Global:WmiExplorer.dtClasses}.Select("Namespace = '$mp'"))  
      $lvClasses.Sorting = 'Ascending'  
      $lvClasses.Sort()  
      $script:nsc.Add($mp,(([System.Windows.Forms.ListViewItem[]]($lvClasses.Items)).clone()))  
       
    }  
    $lvClasses.EndUpdate()  
    $this.selectedNode.BackColor = 'AliceBlue'  
    $lblClasses.Text = $i;$lblclasses.Update()  
    $status.BackColor = 'YellowGreen'  
    $statusStrip.Update()  
  } #'if($Script:nsc.Item("$mp"))  
     
} #' GetClassesFromNameSpace  
#'endregion  
#'region GetWmiClass  
Function GetWmiClass {  
    #' Update Status  
     
    $status.Text = "Retrieving Class"  
    $status.BackColor = 'Khaki'  
    $statusstrip.Update()  
    $lblClass.Text =  $this.SelectedItems |ForEach-Object {$_.name}  
    $lblPath.text = $this.SelectedItems |ForEach-Object {"$($_.SubItems[2].text)"}  
     
    #' Add HelpText  
     
    $rtbHelp.Text = ""  
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext("$($lblClass.Text)`n`n")  
    $rtbHelp.selectionFont  = $fontNormal  
    $rtbHelp.appendtext(($this.SelectedItems |ForEach-Object {"$($_.SubItems[1].text)"}))  
    $rtbHelp.appendtext("`n")  
    $path = $lblPath.text  
     
    $opt = new-object system.management.ObjectGetOptions  
    $opt.UseAmendedQualifiers = $true  
     
    $script:WmiClass = new-object system.management.ManagementClass($path,$opt)  
    #' Add Property Help  
     
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext("`n$($lblClass.Text) Properties :`n`n")  
    $rtbHelp.selectionFont  = $fontNormal  
     
    $i = 0 ;$lblProperties.Text = $i; $lblProperties.Update()  
    $clbproperties.Items.Clear()  
    $clbProperties.Items.add('WmiPath',$False)  
             
    $script:WmiClass.psbase.properties |  
    ForEach-Object {  
        $i++ ;$lblProperties.Text = $i; $lblProperties.Update()  
        $clbProperties.Items.add($_.name,$true)  
        $rtbHelp.selectionFont  = $fontBold  
        $rtbHelp.appendtext("$($_.Name) :`n" )  
        &amp;{  
            Trap {$rtbHelp.appendtext("[Empty]");Continue}  
            $rtbHelp.appendtext($_.psbase.Qualifiers["description"].value)  
        }  
        $rtbHelp.appendtext("`n`n")  
    } #' ForEach-Object  
     
    #' Create Method Help  
    $rtbHelp.selectionFont  = $fontBold  
    $rtbHelp.appendtext( "$($lblClass.Text) Methods :`n`n" )  
    $i = 0 ;$lblMethods.Text = $i; $lblMethods.Update()  
    $lbmethods.Items.Clear()  
     
    $script:WmiClass.psbase.Methods |  
    ForEach-Object {  
        $i++ ;$lblMethods.Text = $i; $lblMethods.Update()  
        $lbMethods.Items.add($_.name)  
        $rtbHelp.selectionFont  = $fontBold  
        $rtbHelp.appendtext("$($_.Name) :`n")  
        &amp;{  
            Trap {$rtbHelp.Text += "[Empty]"}  
            $rtbHelp.appendtext($_.Qualifiers["description"].value)  
        }  
        $rtbHelp.appendtext("`n`n" )  
    } #'ForEach-Object  
      
    $tabControl.SelectedTab = $tabpage1  
    $status.Text = "Retrieved Class"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
} #' GetWmiClass  
#'endregion  
#'region GetWmiInstances  
Function GetWmiInstances {  
    $status.Text = "Getting Instances for $($lblClass.text)"  
    $status.BackColor = 'Red'  
    $statusstrip.Update()  
    $tabControl.SelectedTab = $tabInstances  
    $MC = new-object system.management.ManagementClass $lblPath.text  
    $MOC = $MC.PSbase.getInstances()  
     
    #'trap{"Class Not found";break}  
     
    $DT =  new-object  System.Data.DataTable  
    $DT.TableName = $lblClass.text  
    $Col =  new-object System.Data.DataColumn  
    $Col.ColumnName = "WmiPath"  
    $DT.Columns.Add($Col)  
    $i = 0  
    $j = 0 ;$lblInstances.Text = $j; $lblInstances.Update()  
    $MOC | ForEach-Object {  
        $j++ ;$lblInstances.Text = $j; $lblInstances.Update()  
        $MO = $_  
         
        #' Make a DataRow  
        $DR = $DT.NewRow()  
        $Col =  new-object System.Data.DataColumn  
         
        $DR.Item("WmiPath") = $mo.__PATH  
        $MO.psbase.properties |  
        ForEach-Object {  
            $prop = $_  
            If ($i -eq 0)  {  
     
                #' Only On First Row make The Headers  
                 
                $Col =  new-object System.Data.DataColumn  
                $Col.ColumnName = $prop.Name.ToString()  
                $prop.psbase.Qualifiers | ForEach-Object {  
                    If ($_.Name.ToLower() -eq "key") {  
                        $Col.ColumnName = $Col.ColumnName + "*"  
                    }  
                }  
                $DT.Columns.Add($Col)   
            }  
             
            #' fill dataRow   
             
            if ($prop.value -eq $null) {  
                $DR.Item($prop.Name) = "[empty]"  
            }  
            ElseIf ($prop.IsArray) {  
                                $ofs = ";"  
                $DR.Item($prop.Name) ="$($prop.value)"  
                                $ofs = $null  
            }  
            Else {  
                $DR.Item($prop.Name) = $prop.value  
                #'Item is Key try again with *  
                trap{$DR.Item("$($prop.Name)*") = $prop.Value.tostring();continue}  
            }  
        }  
        #' Add the row to the DataTable  
        $DT.Rows.Add($DR)  
        $i += 1  
    }  
    $DGInstances.DataSource = $DT.psObject.baseobject  
        $DGInstances.Columns.Item('WmiPath').visible =  $clbProperties.GetItemChecked(0)   
    $status.Text = "Retrieved $j Instances"  
    $status.BackColor = 'YellowGreen'  
    $statusstrip.Update()  
} #' GetWmiInstances  
#'endregion  
#'region OutputWmiInstance  
Function OutputWmiInstance {  
    if ( $this.SelectedRows.count -eq 1 ) {  
        if (-not $Script:InstanceTab) {$Script:InstanceTab = new-object System.Windows.Forms.TabPage  
            $Script:InstanceTab.Name = 'Instance'  
            $Script:rtbInstance = new-object System.Windows.Forms.RichTextBox  
            $Script:rtbInstance.Dock = [System.Windows.Forms.DockStyle]::Fill  
            $Script:rtbInstance.Font = $fontCode  
            $Script:rtbInstance.DetectUrls = $false  
            $Script:InstanceTab.controls.add($Script:rtbInstance)  
            $TabControl.TabPages.add($Script:InstanceTab)  
        }  
        $Script:InstanceTab.Text = "Instance = $($this.SelectedRows | ForEach-Object {$_.DataboundItem.wmiPath.split(':')[1]})" 
        $Script:rtbInstance.Text = $this.SelectedRows |ForEach-Object {$_.DataboundItem |Format-List  * | out-String -width 1000 } 
        $tabControl.SelectedTab = $Script:InstanceTab  
    }  
}  #' OutputWmiInstance  
#'endregion  
#'region GetWmiMethod  
Function GetWmiMethod {  
    $WMIMethod = $this.SelectedItem  
    $WmiClassName = $script:WmiClass.__Class  
    $tabControl.SelectedTab = $tabMethods  
    #'$rtbmethods.ForeColor = 'Green'  
    $rtbMethods.Font  = new-object System.Drawing.Font("Microsoft Sans Serif",8)  
    $rtbMethods.text = ""  
    $rtbMethods.selectionFont  = $fontBold  
     
    $rtbMethods.AppendText(("{1} Method : {0} `n" -f $this.SelectedItem , $script:WmiClass.__Class))  
    $rtbMethods.AppendText("`n")  
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("OverloadDefinitions:`n")  
    $rtbMethods.AppendText("$($script:WmiClass.$WMIMethod.OverloadDefinitions)`n`n")  
    $Qualifiers=@()  
    $script:WmiClass.psbase.Methods[($this.SelectedItem)].Qualifiers | ForEach-Object {$qualifiers += $_.name}  
    #'$rtbMethods.AppendText( "$qualifiers`n" )  
    $static = $Qualifiers -Contains "Static"   
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText( "Static : $static`n" )  
    If ($static) {   
         $rtbMethods.AppendText( "A Static Method does not an Instance to act upon`n`n" )  
         $rtbMethods.AppendText("`n")  
     
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Sample Of Connecting to a WMI Class`n`n")  
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $SB = new-Object text.stringbuilder  
         $SB = $SB.Append('$Computer = "') ; $SB = $SB.AppendLine(".`"")  
         $SB = $SB.Append('$Class = "') ; $SB = $SB.AppendLine("$WmiClassName`"")    
         $SB = $SB.Append('$Method = "') ; $SB = $SB.AppendLine("$WmiMethod`"`n")  
         $SB = $SB.AppendLine('$MC = [WmiClass]"\\$Computer\' + "$($script:WmiClass.__NAMESPACE)" + ':$Class"')    
         #'$SB = $SB.Append('$MP.Server = "') ; $SB = $SB.AppendLine("$($MP.Server)`"")    
         #'$SB = $SB.Append('$MP.NamespacePath = "') ; $SB = $SB.AppendLine("$($script:WmiClass.__NAMESPACE)`"")    
         #'$SB = $SB.AppendLine('$MP.ClassName = $Class')  
         $SB = $SB.AppendLine("`n")     
         #'$SB = $SB.AppendLine('$MC = new-object system.management.ManagementClass($MP)')    
         $rtbMethods.AppendText(($sb.tostring()))  
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Getting information about the methods`n`n")  
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText(  
             '$mc' + "`n" +  
             '$mc | Get-Member -membertype Method' + "`n" +  
             "`$mc.$WmiMethod"  
         )  
    } Else {  
         $rtbMethods.AppendText( "This is a non Static Method and needs an Instance to act upon`n`n" )  
         $rtbMethods.AppendText( "The Example given will use the Key Properties to Connect to a WMI Instance : `n`n" )  
         $rtbMethods.SelectionColor = 'Green'  
         $rtbMethods.SelectionFont = $fontCode  
         $rtbMethods.AppendText("#' Example Of Connecting to an Instance`n`n")  
     
         $rtbMethods.SelectionColor = 'Black'  
         $rtbMethods.SelectionFont = $fontCode  
         $SB = new-Object text.stringbuilder  
         $SB = $SB.AppendLine('$Computer = "."')  
         $SB = $SB.Append('$Class = "') ; $SB = $SB.AppendLine("$WmiClassName.`"")    
         $SB = $SB.Append('$Method = "') ; $SB = $SB.AppendLine("$WMIMethod`"")  
         $SB = $SB.AppendLine("`n#' $WmiClassName. Key Properties :")    
         $Filter = ""    
         $script:WmiClass.psbase.Properties | ForEach-Object {    
           $Q = @()  
           $_.psbase.Qualifiers | ForEach-Object {$Q += $_.name}   
           $key = $Q -Contains "key"   
           If ($key) {    
             $CIMType = $_.psbase.Qualifiers["Cimtype"].Value    
             $SB = $SB.AppendLine("`$$($_.Name) = [$CIMType]")    
             $Filter += "$($_.name) = `'`$$($_.name)`'"     
           }    
         }    
         $SB = $SB.Append("`n" + '$filter=');$SB = $SB.AppendLine("`"$filter`"")    
         $SB = $SB.AppendLine('$MC = get-WMIObject $class -computer $Computer -Namespace "' +  
             "$($script:WmiClass.__NAMESPACE)" + '" -filter $filter' + "`n")  
         $SB = $SB.AppendLine('#' $MC = [Wmi]"\\$Computer\Root\CimV2:$Class.$filter"')   
         $rtbMethods.AppendText(($sb.tostring()))  
    }   
    $SB = $SB.AppendLine('$InParams = $mc.psbase.GetMethodParameters($Method)')  
    $SB = $SB.AppendLine("`n")  
    #' output Method Parameter Help  
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("`n`n$WmiClassName. $WMIMethod Method :`n`n")   
    $q = $script:WmiClass.PSBase.Methods[$WMIMethod].Qualifiers | foreach {$_.name}  
    if ($q -contains "Description") {  
         $rtbMethods.AppendText(($script:WmiClass.psbase.Methods[$WMIMethod].psbase.Qualifiers["Description"].Value))  
    }   
   
    $rtbMethods.selectionFont  = $fontBold  
    $rtbMethods.AppendText("`n`n$WMIMethod Parameters :`n")   
  #' get the Parameters   
    
  $inParam = $script:WmiClass.psbase.GetMethodParameters($WmiMethod)  
  $HasParams = $False   
  if ($true) {   
    trap{$rtbMethods.AppendText('[None]') ;continue}    
    $inParam.PSBase.Properties | foreach {   
      $Q = $_.Qualifiers | foreach {$_.name}  
      #' if Optional Qualifier is not present then Parameter is Mandatory   
      $Optional = $q -contains "Optional"  
      $CIMType = $_.Qualifiers["Cimtype"].Value   
      $rtbMethods.AppendText("`nName = $($_.Name) `nType = $CIMType `nOptional = $Optional")  
      #' write Parameters to Example script   
      if ($Optional -eq $TRUE) {$SB = $SB.Append('#' ')}   
      $SB = $SB.Append('$InParams.');$SB = $SB.Append("$($_.Name) = ");$SB = $SB.AppendLine("[$CIMType]")   
      if ($q -contains "Description") {$rtbMethods.AppendText($_.Qualifiers["Description"].Value)}  
      $HasParams = $true    
    }   
  }  
  #' Create the Rest of the Script  
  $rtbMethods.selectionFont  = $fontBold  
  $rtbMethods.AppendText("`n`nTemplate Script :`n")   
  #' Call diferent Overload as Method has No Parameters   
  If ($HasParams -eq $True) {   
      $SB = $SB.AppendLine("`n`"Calling $WmiClassName. : $WMIMethod with Parameters :`"")   
      $SB = $SB.AppendLine('$inparams.PSBase.properties | select name,Value | format-Table')   
      $SB = $SB.AppendLine("`n" + '$R = $mc.PSBase.InvokeMethod($Method, $inParams, $Null)')   
  }Else{   
      $SB = $SB.AppendLine("`n`"Calling $WmiClassName. : $WMIMethod `"")   
      $SB = $SB.AppendLine("`n" + '$R = $mc.PSBase.InvokeMethod($Method,$Null)')   
  }   
  $SB = $SB.AppendLine('"Result :"')   
  $SB = $SB.AppendLine('$R | Format-list' + "`n`n")  
  #' Write Header of the Sample Script :   
   
  $rtbMethods.SelectionColor = 'Green'  
  $rtbMethods.SelectionFont = $fontCode  
  $rtbMethods.AppendText(@"  
#' $WmiClassName. $WMIMethod-Method Template Script"   
#' Created by PowerShell WmiExplorer  
#' /\/\o\/\/ 2006  
#' www.ThePowerShellGuy.com  
#'  
#' Fill InParams values before Executing   
#' InParams that are Remarked (#) are Optional  
"@  
  )  
  $rtbMethods.SelectionColor = 'Black'  
  #'$rtbMethods.SelectionFont = $fontCode  
  $rtbMethods.AppendText("`n`n" + $SB)  
  $rtbMethods.SelectionFont = new-object System.Drawing.Font("Lucida Console",6 )  
  $rtbMethods.AppendText("`n`n Generated by the PowerShell WMI Explorer  /\/\o\/\/ 2006" )  
         
} #' GetWmiMethod  
#'endregion  
#'endregion  
#' Show the Form  
$FrmMain.Add_Shown({$FrmMain.Activate()})  
   
trap {Write-Host $_ ;$status.Text = "unexpected error";$slMessage.Text = "$_.message";continue}  
&amp; {  
    [void]$FrmMain.showdialog()  
}  
#' Resolve-Error $Error[0] | out-string</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_WMI</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>writable_WMI_Properties</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_WMI</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>writable_WMI_Properties</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://blogs.technet.microsoft.com/heyscriptingguy/2014/01/29/use-powershell-to-manipulate-information-with-cim/
-----------------------------------------------
After you’ve found a property that you want to change, the process of changing it looks like this:

Retrieve the CIM instance by using Get-CimInstance, and assign to a variable.
Change the desired property value.
Call Set-CimInstance, and pass it in the variable.

 Let’s take a look at how to create a CIM session, so that we can perform work against remote computers. To create a CIM session, we simply use the New-CimSession cmdlet:
 &gt;$CimSession = New-CimSession -ComputerName sql01;
 'Get a list of printers:
 Get-CimInstance -CimSession $CimSession -Class Win32_Printer;
 
 'When you have completed a CIM session, you can clean it up by using the Remove-CimSession cmdlet:

Remove-CimSession -CimSession $CimSession;
------------------------------------------------
$ClassList = Get-CimClass;

 

foreach ($CimClass in $ClassList) {

    foreach ($CimProperty in $CimClass.CimClassProperties) {

        if ($CimProperty.Qualifiers.Name -contains 'write') {

            [PSCustomObject]@{

                ClassName = $CimClass.CimClassName;

                PropertyName = $CimProperty.Name;

                Writable = $true;

                };

        };

    };

};
------------------------------------------------
'OUTPUT:
---------
ClassName                        PropertyName                   Writable
---------                        ------------                   --------
__Trustee                        Domain                             True
__Trustee                        Name                               True
__Trustee                        SID                                True
__Trustee                        SidLength                          True
__Trustee                        SIDString                          True
Win32_Trustee                    Domain                             True
Win32_Trustee                    Name                               True
Win32_Trustee                    SID                                True
Win32_Trustee                    SidLength                          True
Win32_Trustee                    SIDString                          True
__ACE                            AccessMask                         True
__ACE                            AceFlags                           True
__ACE                            AceType                            True
__ACE                            GuidInheritedObjectType            True
__ACE                            GuidObjectType                     True
__ACE                            Trustee                            True
Win32_ACE                        AccessMask                         True
Win32_ACE                        AceFlags                           True
Win32_ACE                        AceType                            True
Win32_ACE                        GuidInheritedObjectType            True
Win32_ACE                        GuidObjectType                     True
Win32_ACE                        Trustee                            True
__SecurityDescriptor             DACL                               True
__SecurityDescriptor             Group                              True
__SecurityDescriptor             Owner                              True
__SecurityDescriptor             SACL                               True
Win32_SecurityDescriptor         DACL                               True
Win32_SecurityDescriptor         Group                              True
Win32_SecurityDescriptor         Owner                              True
Win32_SecurityDescriptor         SACL                               True
Win32_PageFileSetting            InitialSize                        True
Win32_PageFileSetting            MaximumSize                        True
Win32_PageFileSetting            Name                               True
Win32_AutochkSetting             UserInputDelay                     True
Win32_QuotaSetting               DefaultLimit                       True
Win32_QuotaSetting               DefaultWarningLimit                True
Win32_QuotaSetting               ExceededNotification               True
Win32_QuotaSetting               State                              True
Win32_QuotaSetting               VolumePath                         True
Win32_QuotaSetting               WarningExceededNotification        True
Win32_WMISetting                 ASPScriptDefaultNamespace          True
Win32_WMISetting                 ASPScriptEnabled                   True
Win32_WMISetting                 AutoStartWin9X                     True
Win32_WMISetting                 BackupInterval                     True
Win32_WMISetting                 BackupLastTime                     True
Win32_WMISetting                 EnableAnonWin9xConnections         True
Win32_WMISetting                 EnableEvents                       True
Win32_WMISetting                 EnableStartupHeapPreallocation     True
Win32_WMISetting                 HighThresholdOnClientObjects       True
Win32_WMISetting                 HighThresholdOnEvents              True
Win32_WMISetting                 LoggingDirectory                   True
Win32_WMISetting                 LoggingLevel                       True
Win32_WMISetting                 LowThresholdOnClientObjects        True
Win32_WMISetting                 LowThresholdOnEvents               True
Win32_WMISetting                 MaxLogFileSize                     True
Win32_WMISetting                 MaxWaitOnClientObjects             True
Win32_WMISetting                 MaxWaitOnEvents                    True
Win32_OSRecoveryConfiguration    AutoReboot                         True
Win32_OSRecoveryConfiguration    DebugFilePath                      True
Win32_OSRecoveryConfiguration    DebugInfoType                      True
Win32_OSRecoveryConfiguration    ExpandedDebugFilePath              True
Win32_OSRecoveryConfiguration    ExpandedMiniDumpDirectory          True
Win32_OSRecoveryConfiguration    KernelDumpOnly                     True
Win32_OSRecoveryConfiguration    MiniDumpDirectory                  True
Win32_OSRecoveryConfiguration    OverwriteExistingDebugFile         True
Win32_OSRecoveryConfiguration    SendAdminAlert                     True
Win32_OSRecoveryConfiguration    WriteDebugInfo                     True
Win32_OSRecoveryConfiguration    WriteToSystemLog                   True
Win32_DCOMApplicationSetting     AuthenticationLevel                True
Win32_DCOMApplicationSetting     RemoteServerName                   True
Win32_DCOMApplicationSetting     UseSurrogate                       True
ScriptingStandardConsumerSetting MaximumScripts                     True
ScriptingStandardConsumerSetting Timeout                            True
Win32_UserProfile                RoamingPreference                  True
Win32_VolumeUserQuota            Limit                              True
Win32_VolumeUserQuota            WarningLimit                       True
Win32_ShadowStorage              MaxSpace                           True
CIM_System                       Roles                              True
CIM_ComputerSystem               Roles                              True
CIM_UnitaryComputerSystem        Roles                              True
Win32_ComputerSystem             Roles                              True
Win32_ComputerSystem             AutomaticManagedPagefile           True
Win32_ComputerSystem             AutomaticResetBootOption           True
Win32_ComputerSystem             CurrentTimeZone                    True
Win32_ComputerSystem             EnableDaylightSavingsTime          True
Win32_ComputerSystem             SystemStartupDelay                 True
Win32_ComputerSystem             SystemStartupOptions               True
Win32_ComputerSystem             SystemStartupSetting               True
Win32_ComputerSystem             Workgroup                          True
CIM_ApplicationSystem            Roles                              True
Win32_NTDomain                   Roles                              True
Win32_NetworkAdapter             NetConnectionID                    True
CIM_Printer                      ErrorInformation                   True
Win32_Printer                    ErrorInformation                   True
Win32_Printer                    Attributes                         True
Win32_Printer                    Comment                            True
Win32_Printer                    DefaultPriority                    True
Win32_Printer                    Direct                             True
Win32_Printer                    DoCompleteFirst                    True
Win32_Printer                    DriverName                         True
Win32_Printer                    EnableBIDI                         True
Win32_Printer                    EnableDevQueryPrint                True
Win32_Printer                    Hidden                             True
Win32_Printer                    KeepPrintedJobs                    True
Win32_Printer                    Local                              True
Win32_Printer                    Location                           True
Win32_Printer                    Network                            True
Win32_Printer                    Parameters                         True
Win32_Printer                    PortName                           True
Win32_Printer                    PrintJobDataType                   True
Win32_Printer                    PrintProcessor                     True
Win32_Printer                    Priority                           True
Win32_Printer                    Published                          True
Win32_Printer                    Queued                             True
Win32_Printer                    RawOnly                            True
Win32_Printer                    SeparatorFile                      True
Win32_Printer                    Shared                             True
Win32_Printer                    ShareName                          True
Win32_Printer                    StartTime                          True
Win32_Printer                    UntilTime                          True
Win32_Printer                    WorkOffline                        True
Win32_Volume                     DriveLetter                        True
Win32_Volume                     IndexingEnabled                    True
Win32_Volume                     Label                              True
Win32_LogicalDisk                VolumeName                         True
Win32_MappedLogicalDisk          VolumeName                         True
Win32_DfsNode                    Description                        True
Win32_DfsNode                    Timeout                            True
Win32_UserAccount                Disabled                           True
Win32_UserAccount                FullName                           True
Win32_UserAccount                Lockout                            True
Win32_UserAccount                PasswordChangeable                 True
Win32_UserAccount                PasswordExpires                    True
Win32_UserAccount                PasswordRequired                   True
Win32_BaseService                State                              True
Win32_SystemDriver               State                              True
Win32_Service                    State                              True
Win32_TerminalService            State                              True
Win32_PrinterDriver              FilePath                           True
Win32_PrinterDriver              InfName                            True
Win32_PrinterDriver              SupportedPlatform                  True
Win32_PrinterDriver              Version                            True
Win32_Environment                Name                               True
Win32_Environment                VariableValue                      True
Win32_IP4RouteTable              Destination                        True
Win32_IP4RouteTable              InterfaceIndex                     True
Win32_IP4RouteTable              Mask                               True
Win32_IP4RouteTable              Metric1                            True
Win32_IP4RouteTable              Metric2                            True
Win32_IP4RouteTable              Metric3                            True
Win32_IP4RouteTable              Metric4                            True
Win32_IP4RouteTable              Metric5                            True
Win32_IP4RouteTable              NextHop                            True
Win32_IP4RouteTable              Type                               True
Win32_OperatingSystem            Description                        True
Win32_OperatingSystem            ForegroundApplicationBoost         True
Win32_NTEventlogFile             MaxFileSize                        True
Win32_NTEventlogFile             OverwriteOutDated                  True
Win32_IP4PersistedRouteTable     Destination                        True
Win32_IP4PersistedRouteTable     Mask                               True
Win32_IP4PersistedRouteTable     Metric1                            True
Win32_IP4PersistedRouteTable     NextHop                            True
Win32_Registry                   ProposedSize                       True
Win32_ProcessStartup             CreateFlags                        True
Win32_ProcessStartup             EnvironmentVariables               True
Win32_ProcessStartup             ErrorMode                          True
Win32_ProcessStartup             FillAttribute                      True
Win32_ProcessStartup             PriorityClass                      True
Win32_ProcessStartup             ShowWindow                         True
Win32_ProcessStartup             Title                              True
Win32_ProcessStartup             WinstationDesktop                  True
Win32_ProcessStartup             X                                  True
Win32_ProcessStartup             XCountChars                        True
Win32_ProcessStartup             XSize                              True
Win32_ProcessStartup             Y                                  True
Win32_ProcessStartup             YCountChars                        True
Win32_ProcessStartup             YSize                              True
Win32_DiskQuota                  Limit                              True
Win32_DiskQuota                  WarningLimit                       True</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_ADO</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>DestroyAnADOConnection</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_ADO</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>DestroyAnADOConnection</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'refernece: Microsoft ActiveX Data Objects 2.8 Library



Sub DestroyAdoConnection(Connection As ADODB.Connection)
    
    ' Check the Errors collection
    If Connection.errors.Count &gt; 0 Then
        ' Do some error handling
    End If
    
    ' Close the Connection
    Connection.Close
    
    ' Destroy the Connection
    Set Connection = Nothing
    
End sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_ADO</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ReturnRecordSet_FromCurrentProject_ImplicitConnection</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_ADO</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ReturnRecordSet_FromCurrentProject_ImplicitConnection</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'refernece: Microsoft ActiveX Data Objects 2.8 Library

'Implicit connection to CurrentProject
'Returns ADODB.Recordset from local 

Function fn_CreateImplicitAdoConnection() As ADODB.Recordset

    ' Define Variables
    Dim strSQL  As String
    Dim rs      As New ADODB.Recordset
    
    ' Set the SQL for the Recordset
    strSQL = "SELECT [CONTACTS].* FROM [CONTACTS]"
    
    ' Open the Recordset using to Contacts connection
    rs.Open strSQL, CurrentProject.AccessConnection
    
    ' Return the Recordset
    Set CreateImplicitAdoConnection = rs

End Function



=========================================================================


Private Sub cmdGetRecord_Click()
'refernece: Microsoft ActiveX Data Objects 2.8 Library

    ' Define Variables
    Dim strSQL  As String
    Dim rs      As New ADODB.Recordset
    
    ' Set the SQL for the Recordset
    strSQL = "SELECT t_Rates.* FROM t_Rates WHERE (((t_Rates.Rate_ID)=1))"

    
    rs.Open strSQL, CurrentProject.AccessConnection
    
    Dim iFieldCount As Integer
    iFieldCount = rs.Fields.Count
    
    Dim arrFields() As Variant
    ReDim arrFields(1 To iFieldCount)
    
    Dim iFieldCounter As Integer
    For iFieldCounter = 1 To iFieldCount
        arrFields(iFieldCounter) = rs(iFieldCounter - 1)
        Debug.Print "iFieldCounter: " &amp; iFieldCounter &amp; ", rs(i-1).Name: " &amp; rs.Fields(iFieldCounter - 1).Name &amp; ", arrFields(i): " &amp; arrFields(iFieldCounter)
    Next iFieldCounter




End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_CONTROLS_Programmatically_Manipulate</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>COMBOBOX_is_it_populated</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_CONTROLS_Programmatically_Manipulate</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>COMBOBOX_is_it_populated</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
http://www.vbaexpress.com/forum/archive/index.php/t-32569.html

'This checks to see if anything is selected

If ComboBox1.Value = "" Then
'More code
end if

If ComboBox1.ListIndex = -1
'More code
end if


'This is example of seeing if the combobox is populated

Private Sub UserForm_Initialize()

	If ComboBox1.ListCount = 0 Then
		MsgBox "List Empty"
	End If
	
	With ComboBox1
		.AddItem "One"
		.AddItem "Two"
		.AddItem "Three"
	End With
	
	If ComboBox1.ListCount &gt; 0 Then
		MsgBox "Combobox1 has " &amp; ComboBox1.ListCount &amp; " entries"
	End If

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_CONTROLS_Programmatically_Manipulate</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ReferToControlByName_where_Name_is_a_String_EXAMPLE_Looping</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_CONTROLS_Programmatically_Manipulate</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ReferToControlByName_where_Name_is_a_String_EXAMPLE_Looping</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>For a_counter = 1 To 20
    Me.Controls("Label" &amp; a_counter).Visible = True
Next a_counter</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Events_on_ComboBox_and_other_Controls</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_VBA_ACCESS_Events_on_ComboBox_and_other_Controls</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Events_on_ComboBox_and_other_Controls</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_VBA_ACCESS_Events_on_ComboBox_and_other_Controls</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_VBA_ACCESS_Events_on_ComboBox_and_other_Controls

ControlSource 
	'	column in your table where you want the selection to be stored.
RowSource 
	'	query that selects the departmentID's and their names from the lookup table.
BoundColumn 
	'	usually 1 which is the first column in the RowSource query.
ColumnCount =
	'	the number of columns in the RowSource query (usually 2)
ColumnWidths 
	'	0",3" --- which hides the first column because the width is 0 and shows the second column.
 
' it is common to add the lookup table to your form's RecordSource query 
' 	so you can select whatever columns you want to display. 
' In this case, you should set the locked Property of these controls to yes to prevent accidental updating of the lookup table.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_File_Directory</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Drag_n_Drop_Filename_and_Directory</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_File_Directory</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Drag_n_Drop_Filename_and_Directory</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Drag_n_Drop_Filename_and_Directory
'From: http://www.mrexcel.com/forum/microsoft-access/408038-drag-drop-file-visual-basic-applications.html


'
'if the purpose is just to get a full path of a file that's dragged onto the form, your salvation is near .
' In Access you can create a table with a field set to Hyperlink. When you place this field on a form,
' you will be able to drag any file from the Windows Explorer into this field.
'
' But of course there is always a but. Normally you'd expect to simply retrieve the hyperlink address from the hyperlink field.
' Somehow you 'll end up with a relative path, or even worse an absolute path starting with the default path set under you're database options.
'
' Now I will explain how to deal with this. For this example create a simple table with just two fields,
' FileHyperlink (type = hyperlink) and FilePath(type = text). Then create a form and place the two fields on the form.
'
' Copy this code to the form code

'Now start the form and drag a file to the FileHyperlink control. Voila, you'll have the full path in the FilePath field.
' From here you can build you're app. 

'well there is one little bug in the code.
' If you're file is in the same folder as your databasefile it only returns the filename. Probably this is the case.

Option Compare Database

Private Sub FileHyperLink_AfterUpdate()
	Dim hlink As Hyperlink
	Me.FileHyperLink.Value = RelativeToAbsoluteHyperlink(Me.FileHyperLink.Value)
	Set hlink = Me.FileHyperLink.Hyperlink
	Me.FilePath.Value = hlink.Address
	Me.FileHyperLink.Value = vbNullString
	DoCmd.RunCommand acCmdSaveRecord
End Sub

Function ExtractDirName(strPathName As String, Optional strDelimiter As String = "\") As String
  Dim intIndex As Integer
  For intIndex = VBA.Len(strPathName) To 1 Step -1
    If Mid(strPathName, intIndex, 1) = strDelimiter Then Exit For
  Next
  If intIndex &lt;= 1 Then
    ExtractDirName = ""
  Else
    ExtractDirName = VBA.Left(strPathName, intIndex - 1)
  End If
End Function

Function ExtractFileName(strPathName As String, Optional strDelimiter As String = "\") As String
  Dim intIndex As Integer
  For intIndex = VBA.Len(strPathName) To 1 Step -1
    If Mid(strPathName, intIndex, 1) = strDelimiter Then Exit For
  Next
  ExtractFileName = VBA.Right(strPathName, VBA.Len(strPathName) - intIndex)
End Function

Function RelativeToAbsoluteHyperlink(strHyperlink As String) As String
  Dim strTemp() As String
  Dim intIndex As Integer
  Dim strResult As String
  If Nz(strHyperlink, "") &lt;&gt; "" Then
    strTemp() = Split(strHyperlink, "#", , vbTextCompare)
    For intIndex = LBound(strTemp) To UBound(strTemp)
      If Len(strTemp(intIndex)) &gt; 0 Then
        If Left(strTemp(intIndex), 2) = ".." Then
          strTemp(intIndex) = Replace(strTemp(intIndex), "/", "\")
        End If
        strTemp(intIndex) = RelativeToAbsolutePath(strTemp(intIndex))
      '  Debug.Print strTemp(intIndex)
      End If
      If intIndex = LBound(strTemp) Then
        strResult = strTemp(intIndex)
      Else
        strResult = strResult &amp; "#" &amp; strTemp(intIndex)
      End If
    Next
  End If
  RelativeToAbsoluteHyperlink = strResult
End Function

Function RelativeToAbsolutePath(strRelativePath As String, _
  Optional strStartPath As String = "", _
  Optional strDelimiter As String = "\") As String
  
  Dim intCount As Integer
  Dim intIndex As Integer
  Dim intIndex2 As Integer
  
  Dim strFileName As String
  Dim strPathName As String
  Dim strResult As String
  Dim strSplit() As String
  Dim strSplit2() As String
  Dim strTemp As String
  
  If strStartPath = "" Then
    strStartPath = Application.CurrentProject.Path
  End If
  If (Left(strRelativePath, 2) = "\\") Or _
    (Mid(strRelativePath, 2, 1) = ":") Or _
    (Left(strRelativePath, 5) = "http:") Or _
    (Left(strRelativePath, 6) = "https:") Or _
    (Left(strRelativePath, 4) = "ftp:") Or _
    (Left(strRelativePath, 7) = "mailto:") Or _
    (Left(strRelativePath, 7) = "callto:") Then
    'Path is already absolute
    RelativeToAbsolutePath = strRelativePath
    Exit Function
  End If
  
  strPathName = ExtractDirName(strRelativePath, strDelimiter)
  strFileName = ExtractFileName(strRelativePath, strDelimiter)
  If Left(strPathName, 2) = ".." Then
    'Go up
    intCount = 0
    strSplit() = Split(strPathName, strDelimiter, -1, vbTextCompare)
    strSplit2() = Split(strStartPath, strDelimiter, -1, vbTextCompare)
    For intIndex = 0 To UBound(strSplit())
      If strSplit(intIndex) = ".." Then
        intCount = intCount + 1
        strResult = ""
        For intIndex2 = 0 To UBound(strSplit2()) - intCount
          If strResult &lt;&gt; "" Then
            strResult = strResult &amp; strDelimiter
          End If
          strResult = strResult &amp; strSplit2(intIndex2)
        Next
      Else
        If strResult &lt;&gt; "" Then
          strResult = strResult &amp; strDelimiter
        End If
        strResult = strResult &amp; strSplit(intIndex)
      End If
    Next
    strResult = strResult &amp; strDelimiter &amp; strFileName
  Else
    strResult = strRelativePath
  End If
  
  RelativeToAbsolutePath = strResult
End Function
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>01_Parent_Opens_SubForm_ValidatesJobNumber_ThenEitherCreates_Opens_or_Adds_newRecord</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>01_Parent_Opens_SubForm_ValidatesJobNumber_ThenEitherCreates_Opens_or_Adds_newRecord</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'	01_Parent_Opens_SubForm_ValidatesJobNumber_ThenEitherCreates_Opens_or_Adds_newRecord



Public Sub cmd_Add_or_Edit_SubContract_Window_Click()   'NOTE: Changed Name of SUB!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    On Error GoTo ErrorHandler
    
    '=========================
    '===================================
    DoCmd.RunCommand acCmdSaveRecord
    '===================================
    ' note that this subroutine has been designated a PUBLIC subroutine
    ' so that the popup form can call this sub.
    If Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Open SubContract Form" Then
    

        Dim sX As String
        Dim sX2 As String
        Dim sX3 As String
        sX = Me.Vendor_ID
        sX2 = [Vendor_Name].Value
        sX3 = [Vendor].Value
        Debug.Print "sX : " &amp; sX
        Debug.Print "sX2 : " &amp; sX2
        Debug.Print "sX3 : " &amp; sX3
        
        Dim sWHERE As String
        sWHERE = "[Vendor_ID]= " &amp; Vendor_ID.Value
        Debug.Print "sWhere: " &amp; sWHERE
        
        Dim JobNumber As String
        
        JobNumber = InputBox("Enter Job Number that you want to create or find (e.g. 01234-000), or enter nothing to see all the Jobs for this Vendor:", "Job Number")
                         
            Select Case fn_TheSubContractNumberIs_0_ok_1_NotRightLength_2_Missing(JobNumber)
                Case 0 'Job Number is OK
        
                     'Check for number of Records with the job name supplied by the user (via msgbox), if none then open as add only, if there are some, ask if they want to add one, or edit existing ones.
                    '-----------------------------

                    Dim varWhereVendorJob As Variant
                    varWhereVendorJob = Null
                    'THIS version of WHERE is for the count
                    varWhereVendorJob = varWhereVendorJob &amp; "(([q_T101_innerJoin_T104.Vendor_ID]=" &amp; Trim(sX) &amp; ") AND ([q_T101_innerJoin_T104.Job_Number] Like '*" &amp; Trim(JobNumber) &amp; "*'))"
                    'THIS version of WHERE is for actually opening the form to the right record
                    varWhereVendorJob_v2 = "(([Vendor_ID]=" &amp; Trim(sX) &amp; ") AND ([Job_Number] Like '*" &amp; Trim(JobNumber) &amp; "*'))"
                     Debug.Print "varWhereVendorJob: " &amp; varWhereVendorJob

                    Dim iCount_VendorJob
                    iCount_VendorJob = DCount("[q_T101_innerJoin_T104.Vendor_ID]", "q_T101_innerJoin_T104", varWhereVendorJob)
                    '-----------------------------
                    If iCount_VendorJob &gt; 0 Then
                    
                        DoCmd.OpenForm "sf_SubContract", acNormal, , varWhereVendorJob_v2      'sWHERE
                        Form_sf_SubContract.Caption = "Subcontract for: (" &amp; Trim(sX3) &amp; ") " &amp; sX2
                        Form_sf_SubContract.Vendor_ID_parent = Me.Vendor_ID
                        Form_sf_SubContract.Vendor.Value = sX3
                        Form_sf_SubContract.AllowAdditions = False
                        Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Close SubContract Form"
                    Else
                        DoCmd.OpenForm "sf_SubContract", , , , acAdd, , Me.Vendor_ID &amp; "|" &amp; [Vendor].Value &amp; "|" &amp; Trim(JobNumber)
                        Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Close SubContract Form"
                    End If
                    
                    '-----------------------------
        
        
                Case 1
                    MsgBox ("It looks like Job Number is the wrong length (e.g. 01234-000). You need to fix this before you can proceed")
        
                Case 2
        
'                       MsgBox ("Job_Number is REQUIRED. If you want try again")
                        If MsgBox("Do you just want to see all the jobs for this Vendor.?", vbYesNo, "Delete Confirmation") = vbYes Then
                            'Check for number of Records for the given Vendor (via msgbox), if none then do nothing, if there are some then show them all but don't allow user to add more Job Records
                            '-----------------------------
        
                            Dim varWhereVendor As Variant
                            varWhereVendor = Null
                            varWhereVendor = varWhereVendor &amp; "([q_T101_innerJoin_T104.Vendor_ID]=" &amp; Trim(sX) &amp; ")"
        
                             Debug.Print "varWhereVendor: " &amp; varWhereVendor
        
                            Dim iCount_Vendor
                            iCount_Vendor = DCount("[q_T101_innerJoin_T104.Vendor_ID]", "q_T101_innerJoin_T104", varWhereVendor)
                            '-----------------------------
                            If iCount_Vendor &gt; 0 Then
                            
                                DoCmd.OpenForm "sf_SubContract", acNormal, , sWHERE
                                Form_sf_SubContract.Caption = "(" &amp; Trim(sX3) &amp; ") " &amp; sX2
                                Form_sf_SubContract.Vendor_ID_parent = Me.Vendor_ID
                                Form_sf_SubContract.Vendor.Value = sX3
                                Form_sf_SubContract.AllowAdditions = False
                                Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Close SubContract Form"
                            Else
                                MsgBox ("That vendor Does not have any jobs in this database. You can create a new job by trying again, and providing the Job Number for the new record")
                            End If
                            
                            '-----------------------------


                        Else
                            
'                            MsgBox ("If you want try again at your convenience.")
                            
                        End If

        
                Case Else
                    MsgBox ("Woops, there was a problem. The wrong value came back from fn_TheSubContractNumberIs_0_ok_1_NotRightLength_2_Missing")
    
            End Select

    Else
        DoCmd.Close acForm, "sf_SubContract"
        Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Open SubContract Form"
    End If
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number
'            Case 3621
'                'Cannot insert the value NULL into column 'SubContract_Number'... The statement has been terminated
'                'do nothing just let it close
'            Case 3146  'cannot insert the value NULL into column 'SubContract_Number', table 'COI.dbo.T104_SubContract'; column does not allow nulls
'
'                Call Form_f_Vendor.cmd_Add_or_Edit_SubContract_Window_Click
                
            Case Else
                MsgBox "Error (f_Vendor): " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub
    

Public Function fn_TheSubContractNumberIs_0_ok_1_NotRightLength_2_Missing(sX) As Integer

    Dim iX As Integer
    
    Dim vX As Variant
    
    vX = Len(Trim(sX))
       
    If IsNull(vX) Then
    
        iX = 2
    Else
    
        Select Case vX
            Case 0
                iX = 2
            Case 9
                iX = 0
            Case Else
                iX = 1
        End Select
        
    End If
    fn_TheSubContractNumberIs_0_ok_1_NotRightLength_2_Missing = iX
    
End Function

    
    
    
    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Button_To_Filter_Records_On_a_Form</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Button_To_Filter_Records_On_a_Form</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords>filter records</Keywords>
        <Imports />
        <Code>
=============This one counts the results from the various parts of the Where, and bases the filter on those counts

Private Sub cmdFilterRecords_Click()
On Error GoTo Err_cmdFilterRecords_Click
     Dim strX As String
     strX = BuildFilter

    'For filtering the form itself use:
     Me.Form.RecordSource = strX

     Me.Requery
     
Exit_cmdFilterRecords_Click:
    Exit Sub

Err_cmdFilterRecords_Click:
    MsgBox Err.Description
    Resume Exit_cmdFilterRecords_Click

End Sub


Private Function BuildFilter() As Variant
    
    On Error GoTo ErrorHandler
    
    '=========================
    Dim varWhere As Variant

    varWhere = Null  ' Main filter

    If Me.txt_FilterBy &gt; "" Then
        varWhere = varWhere &amp; "[dbo_T201_Trucker.A1_Trucking_Company_Name] LIKE" &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Number] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Company_Address_1] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Company_Address_2] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Contact_Notes] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T201_Trucker.A1_Trucking_Company_Address_3] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' "
        
    End If
    
    Dim countArray(5) As Variant
	'dbo_T201_Trucker is the linked SQL table
     countArray(0) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Name]", "q_T201_Trucker", varWhere)
     countArray(1) = DCount("[dbo_T201_Trucker.A1_Trucking_Number]", "q_T201_Trucker", varWhere)
     countArray(2) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_1]", "q_T201_Trucker", varWhere)
     countArray(3) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_2]", "q_T201_Trucker", varWhere)
     countArray(4) = DCount("[dbo_T201_Trucker.A1_Trucking_Contact_Notes]", "q_T201_Trucker", varWhere)
     countArray(5) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_3]", "q_T201_Trucker", varWhere)
     
     Dim iCount_max As Variant

     iCount_max = MaxInList(countArray(0), countArray(1), countArray(2), countArray(3), countArray(4), countArray(5))
     
    If IsNull(varWhere) Or iCount_max = 0 Then
        varWhere = "SELECT dbo_T201_Trucker.* FROM dbo_T201_Trucker"
        
        If iCount_max = 0 Then
            MsgBox "No records were found that met your criteria"
        End If
    Else
        varWhere = "SELECT dbo_T201_Trucker.* FROM dbo_T201_Trucker WHERE" &amp; varWhere

    End If

    BuildFilter = varWhere
        '=========================
    Exit Function
            
ErrorHandler:
        Select Case Err.Number

            Case 3075  '
                MsgBox "There was a problem. You may have had an illegal character in your search string (e.g. an apostrophe). Remove the part with any non-alphatical characters and try again"
                BuildFilter = "SELECT dbo_T201_Trucker.* FROM dbo_T201_Trucker"

                Exit Function
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Function


Function MaxInList(ParamArray ArrayList() As Variant)
    'Function will return the maximum value from a list of values
       
    Dim n As Integer
    Dim iValue As Variant
     
    'Set the variable iValue - initialize to the first item or value in list.
    iValue = ArrayList(0)
    
    'Checks each item or value in the list to find the largest.
    For n = 0 To UBound(ArrayList)
    'Determines the largest value.
    If ArrayList(n) &gt; iValue Then
        iValue = ArrayList(n)
    End If
    
    Next n
    
    MaxInList = iValue
   
End Function

====================for the query, I just had it pull all the fields from the table, but really just need the ones being counted =======================================
'ACCESS QUERY:  q_T201_Trucker
SELECT 
	dbo_T201_Trucker.Trucker_ID, 
	dbo_T201_Trucker.TruckerInsuranceRates_ID, 
	dbo_T201_Trucker.A1_Trucking_Company_Name, 
	dbo_T201_Trucker.A1_BOOL_ActiveOwnerOperator, 
	dbo_T201_Trucker.A1_Trucking_Number, 
	dbo_T201_Trucker.A1_Status_Note, 
	dbo_T201_Trucker.A1_Last_Used, 
	dbo_T201_Trucker.A1_Trucking_Company_Email, 
	dbo_T201_Trucker.A1_Trucking_Company_Phone_Number, 
	dbo_T201_Trucker.A1_Trucking_Company_Address_1, 
	dbo_T201_Trucker.A1_Trucking_Company_Address_2, 
	dbo_T201_Trucker.A1_Trucking_Company_Address_3, 
	dbo_T201_Trucker.A1_Trucking_ZipCode, 
	dbo_T201_Trucker.A1_Trucking_Contact_Notes, 
	dbo_T201_Trucker.A1_Is_a_Broker_bool, 
	dbo_T201_Trucker.A2_BOOL_First_Notice_Sent, 
	dbo_T201_Trucker.A2_BOOL_Second_Notice_Sent, 
	dbo_T201_Trucker.A2_Date_First_Notice_Sent, 
	dbo_T201_Trucker.A2_Date_Second_Notice_Sent, 
	dbo_T201_Trucker.A2_Cut_Off_Date, 
	dbo_T201_Trucker.A3_UserName_CreatedBy, 
	dbo_T201_Trucker.A3_ComputerName_CreatedBy, 
	dbo_T201_Trucker.A3_DateTime_CreatedBy, 
	dbo_T201_Trucker.A1_HasExplorerTruckingNumber
FROM dbo_T201_Trucker;

=======This works but does not count================================================================================================================
'Button_To_Filter_Records_On_a_Form


'1] The button:

Private Sub cmdFilterRecords_Click()


On Error GoTo Err_cmdFilterRecords_Click


     Dim strX As String
     strX = BuildFilter

	'For filtering the form itself use:
     Me.Form.RecordSource = strX
     
     'For a subform use: ================================
     Me!vw_T1_T2_sf.Form.RecordSource = strX
	 '================================ Where 'vw_T1_T2_sf' is the subform

     Me.Requery

Exit_cmdFilterRecords_Click:
    Exit Sub

Err_cmdFilterRecords_Click:
    MsgBox Err.Description
    Resume Exit_cmdFilterRecords_Click

End Sub



Private Function BuildFilter() As Variant
    Dim varWhere As Variant

    varWhere = Null  ' Main filter
    
    If Me.txt_FilterBy &gt; "" Then
        varWhere = varWhere &amp; " T1_Project_Header.Project_DescriptiveName LIKE" &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "

        varWhere = varWhere &amp; " T1_Project_Header.Key_Words LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "

        varWhere = varWhere &amp; " T1_Project_Header.Person_Requesting_Project LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
    
        varWhere = varWhere &amp; " T1_Project_Header.Project_Number LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
    
        varWhere = varWhere &amp; " T1_Project_Header.Key_People LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " AND "  'The "AND" gets removed in the following steps
        
    End If
    
    
    
    'txtApplicationNumber
    ' Check if there is a filter to return...
    If IsNull(varWhere) Then
        varWhere = "SELECT T1_Project_Header.* FROM T1_Project_Header"
    Else
        varWhere = "SELECT T1_Project_Header.* FROM T1_Project_Header WHERE" &amp; varWhere
        
        ' strip off last "AND" in the filter
        If Right(varWhere, 5) = " AND " Then
            varWhere = Left(varWhere, Len(varWhere) - 5)
        End If
    End If
    
    BuildFilter = varWhere
    
End Function


============IF you want to deal with a zero record count returned then use DCount:

Private Function BuildFilter() As Variant
    
    On Error GoTo ErrorHandler
    
    '=========================
    Dim varWhere As Variant

    varWhere = Null  ' Main filter

    If Me.txt_FilterBy &gt; "" Then
        varWhere = varWhere &amp; "[dbo_T01_TruckerPacket.01_Trucking_Company_Name] LIKE" &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
        
        varWhere = varWhere &amp; " [dbo_T01_TruckerPacket.01_Trucking_Number] LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T01_TruckerPacket.01_Trucking_Company_Address_1] LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
         varWhere = varWhere &amp; " [dbo_T01_TruckerPacket.01_Trucking_Company_Address_2] LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' " &amp; " OR "
        varWhere = varWhere &amp; " [dbo_T01_TruckerPacket.01_Trucking_Company_Address_3] LIKE " &amp; " '*" &amp; Me.txt_FilterBy &amp; "*' "
        
    End If

     Dim iCount
     iCount = DCount("[dbo_T01_TruckerPacket.01_Trucking_Company_Name]", "q_TruckerPacket_00", varWhere)   &lt;&lt;&lt;&lt;&lt;&lt;&lt;=========== DCount!!!!

    If IsNull(varWhere) Or iCount = 0 Then
        varWhere = "SELECT dbo_T01_TruckerPacket.* FROM dbo_T01_TruckerPacket"
        
        If iCount = 0 Then
            MsgBox "No records were found that met your criteria"
        End If
    Else
        varWhere = "SELECT dbo_T01_TruckerPacket.* FROM dbo_T01_TruckerPacket WHERE" &amp; varWhere

    End If

    BuildFilter = varWhere
        '=========================
    Exit Function
            
ErrorHandler:
        Select Case Err.Number

            Case 0  '
                        
                           
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>openArgs_MultipleParms</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>openArgs_MultipleParms</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


http://www.access-programmers.co.uk/forums/showthread.php?t=210530
'calling code
'concatenates the values of the cbo's delimited by the "|"
DoCmd.OpenReport "rptResults", acViewPreview, , , acDialog, Me.cbo1ID &amp; "|" &amp; Me.cbo2ID &amp; "|" &amp; Me.cbo3ID

'form open
Private Sub Report_Open(Cancel As Integer)
  varSplitString = Split(Me.OpenArgs, "|")
  Me.[EngagementID].Value = varSplitString(0)
  Me.[LocationID].Value = varSplitString(1)
  Me.[ProviderID].Value = varSplitString(2)
End Sub


=================================================================================


&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Child form catches and uses the OpenArgs:  Set focus, then puts the parm into the .Text of the Textbox

Private Sub Form_Open(Cancel As Integer)
    On Error GoTo ErrorHandler
    
    '=========================
    If Me.OpenArgs &lt;&gt; vbNull Then
        
        varSplitString = Split(Me.OpenArgs, "|")
        Debug.Print "Form_Open - sf_SubContract - varSplitString(0): " &amp; Trim(varSplitString(0))	'&lt;===========================
        Me.txt_Vendor_ID.SetFocus
        Me.txt_Vendor_ID.Text = varSplitString(0)
        Debug.Print "Form_Open - sf_SubContract - varSplitString(1): " &amp; Trim(varSplitString(1))	'&lt;===========================
         Me.Vendor.SetFocus
        Me.Vendor.Value = varSplitString(1)
        Debug.Print "Form_Open - sf_SubContract - varSplitString(2): " &amp; Trim(varSplitString(2))	'&lt;===========================
        Me.txt_Job_Number.SetFocus
        Me.txt_Job_Number.Value = varSplitString(2)
    
    End If
    
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number

'            Case 3075  '
'                MsgBox "There was a problem. You may have had an illegal character in your search string (e.g. an apostrophe). Remove the part with any non-alphatical characters and try again"
'                BuildFilter = "SELECT dbo_T101_Vendor.* FROM dbo_T101_Vendor"
'
'                Exit Sub
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Sub



&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Parent form: uses openArgs on new record

Public Sub cmd_Add_or_Edit_SubContract_Window_Click()   'NOTE: Changed Name of SUB!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    On Error GoTo ErrorHandler
    
    '=========================
    '===================================
    DoCmd.RunCommand acCmdSaveRecord
    '===================================
    ' note that this subroutine has been designated a PUBLIC subroutine
    ' so that the popup form can call this sub.
    If Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Open SubContract Form" Then
    

        Dim sX As String
        Dim sX2 As String
        Dim sX3 As String
        sX = Me.Vendor_ID
        sX2 = [Vendor_Name].Value
        sX3 = [Vendor].Value
        Debug.Print "sX : " &amp; sX
        Debug.Print "sX2 : " &amp; sX2
        Debug.Print "sX3 : " &amp; sX3
        
        Dim sWHERE As String
        sWHERE = "[Vendor_ID]= " &amp; Vendor_ID.Value
        Debug.Print "sWhere: " &amp; sWHERE
        
        Dim JobNumber As String
        
        JobNumber = InputBox("Enter Job Number that you want to create or find (e.g. 01234-000):", "Job Number")
                         
            Select Case fn_TheSubContractNumberIs_0_ok_1_NotRightLength_2_Missing(JobNumber)
                Case 0 'Job Number is OK
        
                     'Check for number of Records with the job name supplied by the user (via msgbox), if none then open as add only, if there are some, ask if they want to add one, or edit existing ones.
                    '-----------------------------
                    
                    Dim varWhereVendorJob As Variant
                    varWhereVendorJob = Null
'                                        varWhereVendorJob = varWhereVendorJob &amp; "(([q_T101_innerJoin_T104.Vendor_ID]=58) AND ([q_T101_innerJoin_T104.Job_Number] Like '*03883-000*'))"
                    varWhereVendorJob = varWhereVendorJob &amp; "(([q_T101_innerJoin_T104.Vendor_ID]=" &amp; Trim(sX) &amp; ") AND ([q_T101_innerJoin_T104.Job_Number] Like '*" &amp; Trim(JobNumber) &amp; "*'))"
                    
                     Debug.Print "varWhereVendorJob: " &amp; varWhereVendorJob
                    
                    Dim iCount_VendorJob
                    iCount_VendorJob = DCount("[q_T101_innerJoin_T104.Vendor_ID]", "q_T101_innerJoin_T104", varWhereVendorJob)
                    '-----------------------------
                    If iCount_VendorJob &gt; 0 Then
                    
                        DoCmd.OpenForm "sf_SubContract", acNormal, , sWHERE
                        Form_sf_SubContract.Caption = "(" &amp; Trim(sX3) &amp; ") " &amp; sX2
                        Form_sf_SubContract.Vendor_ID_parent = Me.Vendor_ID
                        Form_sf_SubContract.Vendor.Value = sX3
                        Form_sf_SubContract.AllowAdditions = False
                        Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Close SubContract Form"
                    Else
                        DoCmd.OpenForm "sf_SubContract", , , , acAdd, , Me.Vendor_ID &amp; "|" &amp; [Vendor].Value &amp; "|" &amp; Trim(JobNumber)   '&lt;===============  OpenArgs
                        Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Close SubContract Form"
                    End If
                    
                    '-----------------------------
        
        
                Case 1
                    MsgBox ("It looks like Job Number is the wrong length (e.g. 01234-000). You need to fix this before you can proceed")
        
                Case 2
        
                     MsgBox ("Job_Number is REQUIRED. If you want try again")

        
                Case Else
                    MsgBox ("Woops, there was a problem. The wrong value came back from fn_TheSubContractNumberIs_0_ok_1_NotRightLength_2_Missing")
    
            End Select

    Else
        DoCmd.Close acForm, "sf_SubContract"
        Me.cmd_Add_or_Edit_SubContract_Window.Caption = "Open SubContract Form"
    End If
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number
                
            Case Else
                MsgBox "Error (f_Vendor): " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>RecordCounter_ForLabel</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>RecordCounter_ForLabel</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1] Usage
'2] Sub



'=== USAGE =================

Private Sub cmb_TypeOfDTP_AfterUpdate()
    UpdateRecordSetCount
End Sub

Private Sub Form_AfterInsert()
    UpdateRecordSetCount
End Sub

Private Sub Form_Current()

    UpdateRecordSetCount

End Sub



'=== Sub (on a subform)=======================

Sub UpdateRecordSetCount()

    On Error GoTo ErrorHandler
    '=========================

    Dim iCount As Integer
    Dim iThisRecord As Integer
    Dim sInfoFromSubFormAbove As String

    iCount = Me.Recordset.RecordCount
    iThisRecord = Me.RecordsetClone.AbsolutePosition + 1
    iThisRecord = Me.CurrentRecord

    sInfoFromSubFormAbove = Format([Forms]![sf_MedicalReview]![Date_Of_Medical_Review].Value, "mm/dd/yyyy")
    
    Select Case iCount
    
        Case 0
            lbl_RecordCount.Caption = "There are no DTP Records for: " &amp; sInfoFromSubFormAbove
        Case 1

            lbl_RecordCount.Caption = "There is the first DTP Record for: " &amp; sInfoFromSubFormAbove
        Case Is &gt; 1

            lbl_RecordCount.Caption = CStr(iThisRecord) &amp; " of " &amp; CStr(iCount) &amp; " Records for: " &amp; sInfoFromSubFormAbove
    End Select
    '=========================

    Exit Sub


ErrorHandler:
        Select Case Err.Number
'            Case 2105
'                MsgBox "This error happens when there is no related record for the subform yet. So the code creates one"
'                bSubRecordExists = False
'                Resume Next

            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Link</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Link_Tables_and_Editable_Views_With_SCHEMA</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Link</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Link_Tables_and_Editable_Views_With_SCHEMA</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Tables with PK are editable, but Views are only editable if they have a unique index in the table defs of the Access DB
'It is easiest to use the PK as the index

'e.g.

CurrentDb.Execute "CREATE UNIQUE Index _uniqueindex ON App_001_vw_8004_500_ChronicConditionsList_List_3(L1_PK)"

'This has a (1) Button, (2) Global Mod, (3) Mod_Link

'==================================
' 1] Button on Form
'==================================


Private Sub cmd_LinkViews_Click()
    Main_LinkTables
End Sub


Private Sub cmd_UNLINK_Click()
    Main_UnLinkTables
End Sub

'==================================
' 2] Global Mod
'==================================

Option Compare Database
Option Explicit


Public g_arrTableListCount As Integer

Public g_arrTableList_Local() As String
Public g_arrTableList_External() As String
Public g_arrTableList_bIsAView() As Boolean
Public g_arrTableList_sNameOfUniqueIndex() As String


'==================================
' 3] Mod_Link
'==================================

Option Compare Database
Option Explicit


Sub Main_LoadGlobals()
    
    Dim iNoOfElements As Integer
    
    iNoOfElements = 2

    '============================================================
    'LOCAL Names

    ReDim g_arrTableList_Local(iNoOfElements) As String

    g_arrTableList_Local(0) = "App_001_vw_8004_500_ChronicConditionsList_List_3"
    g_arrTableList_Local(1) = "dbo_L1_ChronicConditionCodes_t"
    
    g_arrTableListCount = UBound(g_arrTableList_Local)
    
    '============================================================
    
    'SQL Server Names
    
     ReDim g_arrTableList_External(iNoOfElements) As String

    g_arrTableList_External(0) = "App_001.vw_8004_500_ChronicConditionsList_List_3"
    g_arrTableList_External(1) = "dbo.L1_ChronicConditionCodes_t"
    

        
    '============================================================
    
    'True or False: it is a view
    
     ReDim g_arrTableList_bIsAView(iNoOfElements) As Boolean

    g_arrTableList_bIsAView(0) = True
    g_arrTableList_bIsAView(1) = False
    
    '============================================================
    
    'If it is a view, and you want it to be editable you have to provide the name of the Unique Index field ( the PK is perfect for this)\
    ' otherwise can just provide a blank ("")
    
     ReDim g_arrTableList_sNameOfUniqueIndex(iNoOfElements) As String

    g_arrTableList_sNameOfUniqueIndex(0) = "L1_PK"
    g_arrTableList_sNameOfUniqueIndex(1) = ""
    
    '============================================================

End Sub


'==================================
' 2] Main LINK Routine
'==================================


Sub Main_LinkTables()
    Main_LoadGlobals
    AttachAllTheDSNLessTables
End Sub





Sub AttachAllTheDSNLessTables()

    Dim iTCount As Integer

    For iTCount = 0 To g_arrTableListCount - 1
        Attach_DSNLess_Table g_arrTableList_Local(iTCount), g_arrTableList_External(iTCount), g_arrTableList_bIsAView(iTCount), g_arrTableList_sNameOfUniqueIndex(iTCount)
    Next iTCount
    
'    Refresh
    
End Sub






Sub Attach_DSNLess_Table(stLocalTableName As String, stRemoteTableName, bIsAViewAndYouWantItUpdateAble As Boolean, sNameOfUniqueIndex As String)

    On Error GoTo AttachDSNLessTable_Err
    
    Dim td As TableDef
    Dim stConnect As String
    
    For Each td In CurrentDb.TableDefs
        If td.Name = stLocalTableName Then
            CurrentDb.TableDefs.Delete stLocalTableName
        End If
    Next
      

    stConnect = "ODBC;DRIVER=SQL Server Native Client 10.0;SERVER=SQL-SERVER\PRODUCTION;DATABASE=DB1_Main;Trusted_Connection=Yes"


    Debug.Print stConnect
    

    Set td = CurrentDb.CreateTableDef(stLocalTableName, dbAttachSavePWD, stRemoteTableName, stConnect)
    CurrentDb.TableDefs.Append td
    
    
    If bIsAViewAndYouWantItUpdateAble Then
    
        CurrentDb.Execute "CREATE UNIQUE Index _uniqueindex ON " &amp; stLocalTableName &amp; "(" &amp; sNameOfUniqueIndex &amp; ")"
        
    End If
    

    
    CurrentDb.TableDefs.Refresh
    
    
    
    
    DoCmd.SelectObject acTable, stLocalTableName, True
    DoCmd.RepaintObject
    
    Debug.Print "Table: " &amp; stLocalTableName &amp; " Was Successfully Linked"


    Exit Sub

AttachDSNLessTable_Err:
    

    Debug.Print "Table: " &amp; stLocalTableName &amp; "Was NOT Linked"

ErrorHandler:
    Select Case Err.Number
        Case 3011
            'When the table is not there this error occurred
           Debug.Print "RESUME NEXT in Attach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
           Resume Next
        Case 2544
            'When the table is not there this error occurred
           Debug.Print "RESUME NEXT in Attach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
           Resume Next

        Case Else
            MsgBox "Attach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
    End Select
End Sub


'==================================
' 3] Main UN-LINK Routine
'==================================

Sub Main_UnLinkTables()
    Main_LoadGlobals
    DetachAllTheDSNLessTables
End Sub




Sub DetachAllTheDSNLessTables()

    Dim iTCount As Integer

    For iTCount = 0 To g_arrTableListCount - 1
        Detach_DSNLess_Table g_arrTableList_Local(iTCount)
    Next iTCount
    
'    Refresh
    
End Sub



Sub Detach_DSNLess_Table(stLocalTableName As String)

    On Error GoTo DetachDSNLessTable_Err
    
    Dim td As TableDef
    
    For Each td In CurrentDb.TableDefs
        If td.Name = stLocalTableName Then
            CurrentDb.TableDefs.Delete stLocalTableName
        End If
    Next
      
    DoCmd.SelectObject acTable, stLocalTableName, True
    DoCmd.RepaintObject
      

    
    Debug.Print "Table: " &amp; stLocalTableName &amp; " Was Successfully UN-Linked"


    Exit Sub

DetachDSNLessTable_Err:
    

    Debug.Print "Table: " &amp; stLocalTableName &amp; "Was NOT Linked"

ErrorHandler:
    Select Case Err.Number

         Case 2544
            Resume Next
        Case Else
            MsgBox "Detach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
    End Select
End Sub



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Link</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Link_Tables_No_SCHEMA</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Link</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Link_Tables_No_SCHEMA</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' Link Tables (No SCHEMA)

'==================================
' 0] Globals
'==================================

Public g_arrTableList() As String
Public g_arrTableListCount As Integer


'==================================
' 1] Button on Form
'==================================

Private Sub cmd_Link_All_TheSQLServerTables_Click()
    Main_LinkTables
End Sub


Private Sub cmd_UnLink_All_the_SQL_Tables_Click()
    Main_UnLinkTables
End Sub

'==================================
' 2] Main LINK Routine
'==================================


Sub Main_LinkTables()
    Main_LoadGlobals
    AttachAllTheDSNLessTables
End Sub

Sub Main_LoadGlobals()
    ReDim g_arrTableList(2) As String

    g_arrTableList(0) = "zzz_prj_1001_TEMP_1_t"
    g_arrTableList(1) = "zzz_prj_1001_TEMP_2_t"

'    g_arrTableList(2) = "T8_All_Hospitals_Daily_ARCHIVE_t"
    
    g_arrTableListCount = UBound(g_arrTableList)
End Sub


Sub AttachAllTheDSNLessTables()

    Dim iTCount As Integer

    For iTCount = 0 To g_arrTableListCount - 1
        Attach_DSNLess_Table g_arrTableList(iTCount), g_arrTableList(iTCount)
    Next iTCount
    
'    Refresh
    
End Sub


Sub Attach_DSNLess_Table(stLocalTableName As String, stRemoteTableName)

    On Error GoTo AttachDSNLessTable_Err
    
    Dim td As TableDef
    Dim stConnect As String
    
    For Each td In CurrentDb.TableDefs
        If td.Name = stLocalTableName Then
            CurrentDb.TableDefs.Delete stLocalTableName
        End If
    Next
      

    stConnect = "ODBC;DRIVER=SQL Server Native Client 10.0;SERVER=SQL-SERVER\PRODUCTION;DATABASE=CCNCclaims;Trusted_Connection=Yes"

    Debug.Print stConnect
    

    Set td = CurrentDb.CreateTableDef(stLocalTableName, dbAttachSavePWD, stRemoteTableName, stConnect)
    CurrentDb.TableDefs.Append td
    
    CurrentDb.TableDefs.Refresh
    
    DoCmd.SelectObject acTable, stLocalTableName, True
    DoCmd.RepaintObject
    
    Debug.Print "Table: " &amp; stLocalTableName &amp; " Was Successfully Linked"


    Exit Sub

AttachDSNLessTable_Err:
    

    Debug.Print "Table: " &amp; stLocalTableName &amp; "Was NOT Linked"

ErrorHandler:
    Select Case Err.Number
        Case 3011
            'When the table is not there this error occurred
           Debug.Print "RESUME NEXT in Attach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
           Resume Next
        Case 2544
            'When the table is not there this error occurred
           Debug.Print "RESUME NEXT in Attach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
           Resume Next

        Case Else
            MsgBox "Attach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
    End Select
End Sub

'==================================
' 3] Main UN-LINK Routine
'==================================



Sub Main_UnLinkTables()
    Main_LoadGlobals
    DetachAllTheDSNLessTables
End Sub


Sub Main_LoadGlobals()
    ReDim g_arrTableList(2) As String

    g_arrTableList(0) = "zzz_prj_1001_TEMP_1_t"
    g_arrTableList(1) = "zzz_prj_1001_TEMP_2_t"

'    g_arrTableList(2) = "T8_All_Hospitals_Daily_ARCHIVE_t"
    
    g_arrTableListCount = UBound(g_arrTableList)
End Sub



Sub DetachAllTheDSNLessTables()

    Dim iTCount As Integer

    For iTCount = 0 To g_arrTableListCount - 1
        Detach_DSNLess_Table g_arrTableList(iTCount)
    Next iTCount
    
'    Refresh
    
End Sub




Sub Detach_DSNLess_Table(stLocalTableName As String)

    On Error GoTo DetachDSNLessTable_Err
    
    Dim td As TableDef
    
    For Each td In CurrentDb.TableDefs
        If td.Name = stLocalTableName Then
            CurrentDb.TableDefs.Delete stLocalTableName
        End If
    Next
      
    DoCmd.SelectObject acTable, stLocalTableName, True
    DoCmd.RepaintObject
      

    
    Debug.Print "Table: " &amp; stLocalTableName &amp; " Was Successfully UN-Linked"


    Exit Sub

DetachDSNLessTable_Err:
    

    Debug.Print "Table: " &amp; stLocalTableName &amp; "Was NOT Linked"

ErrorHandler:
    Select Case Err.Number

         Case 2544
            Resume Next
        Case Else
            MsgBox "Detach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
    End Select
End Sub



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Link</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Link_Tables_With_SCHEMA</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Link</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Link_Tables_With_SCHEMA</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' Link Tables (With SCHEMA)

'==================================
' 0] Globals
'==================================

Public g_arrTableList_Local() As String
Public g_arrTableList_External() As String
Public g_arrTableListCount_Local As Integer
Public g_arrTableListCount_External As Integer

'==================================
' 1] Button on Form
'==================================

Private Sub cmd_Link_All_TheSQLServerTables_Click()
    Main_LinkTables
End Sub

Private Sub cmd_UnLink_All_the_SQL_Tables_Click()
    Main_UnLinkTables
End Sub

'==================================
' 2] Main LINK Routine
'==================================


Sub Main_LinkTables()
    Main_LoadGlobals
    AttachAllTheDSNLessTables
End Sub



Sub Main_LoadGlobals()

     'Example w/ TWO tables
     
    'LOCAL Names 

    ReDim g_arrTableList_Local(2) As String

    g_arrTableList_Local(0) = "App_001_zzz_prj_1001_TEMP_1_t"
    g_arrTableList_Local(1) = "App_001_zzz_prj_1001_TEMP_2_t"
    
    g_arrTableListCount_Local = UBound(g_arrTableList_Local)
    
    '============================================================
    
    'SQL Server Names 
    
     ReDim g_arrTableList_External(2) As String

    g_arrTableList_External(0) = "App_001.zzz_prj_1001_TEMP_1_t"
    g_arrTableList_External(1) = "App_001.zzz_prj_1001_TEMP_2_t"
    
    g_arrTableListCount_External = UBound(g_arrTableList_External)
        
    
End Sub


Sub AttachAllTheDSNLessTables()

    Dim iTCount As Integer

    For iTCount = 0 To g_arrTableListCount_Local - 1
        Attach_DSNLess_Table g_arrTableList_Local(iTCount), g_arrTableList_External(iTCount)
    Next iTCount
    
'    Refresh
    
End Sub






Sub Attach_DSNLess_Table(stLocalTableName As String, stRemoteTableName)

    On Error GoTo AttachDSNLessTable_Err
    
    Dim td As TableDef
    Dim stConnect As String
    
    For Each td In CurrentDb.TableDefs
        If td.Name = stLocalTableName Then
            CurrentDb.TableDefs.Delete stLocalTableName
        End If
    Next
      

    stConnect = "ODBC;DRIVER=SQL Server Native Client 10.0;SERVER=SQL-SERVER\PRODUCTION;DATABASE=DB1_Main;Trusted_Connection=Yes"


    Debug.Print stConnect
    

    Set td = CurrentDb.CreateTableDef(stLocalTableName, dbAttachSavePWD, stRemoteTableName, stConnect)
    CurrentDb.TableDefs.Append td
    
    CurrentDb.TableDefs.Refresh
    
    DoCmd.SelectObject acTable, stLocalTableName, True
    DoCmd.RepaintObject
    
    Debug.Print "Table: " &amp; stLocalTableName &amp; " Was Successfully Linked"


    Exit Sub

AttachDSNLessTable_Err:
    

    Debug.Print "Table: " &amp; stLocalTableName &amp; "Was NOT Linked"

ErrorHandler:
    Select Case Err.Number
        Case 3011
            'When the table is not there this error occurred
           Debug.Print "RESUME NEXT in Attach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
           Resume Next
        Case 2544
            'When the table is not there this error occurred
           Debug.Print "RESUME NEXT in Attach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
           Resume Next

        Case Else
            MsgBox "Attach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
    End Select
End Sub



'==================================
' 3] Main UN-LINK Routine
'==================================

Sub Main_UnLinkTables()
    Main_LoadGlobals
    DetachAllTheDSNLessTables
End Sub




Sub Main_LoadGlobals()

     'Example w/ TWO tables
     
    'LOCAL Names 

    ReDim g_arrTableList_Local(2) As String

    g_arrTableList_Local(0) = "App_001_zzz_prj_1001_TEMP_1_t"
    g_arrTableList_Local(1) = "App_001_zzz_prj_1001_TEMP_2_t"
    
    g_arrTableListCount_Local = UBound(g_arrTableList_Local)
    
    '============================================================
    
    'SQL Server Names 
    
     ReDim g_arrTableList_External(2) As String

    g_arrTableList_External(0) = "App_001.zzz_prj_1001_TEMP_1_t"
    g_arrTableList_External(1) = "App_001.zzz_prj_1001_TEMP_2_t"
    
    g_arrTableListCount_External = UBound(g_arrTableList_External)
        
    
End Sub



Sub DetachAllTheDSNLessTables()

    Dim iTCount As Integer

    For iTCount = 0 To g_arrTableListCount_Local - 1
        Detach_DSNLess_Table g_arrTableList_Local(iTCount)
    Next iTCount
    
'    Refresh
    
End Sub



Sub Detach_DSNLess_Table(stLocalTableName As String)

    On Error GoTo DetachDSNLessTable_Err
    
    Dim td As TableDef
    
    For Each td In CurrentDb.TableDefs
        If td.Name = stLocalTableName Then
            CurrentDb.TableDefs.Delete stLocalTableName
        End If
    Next
      
    DoCmd.SelectObject acTable, stLocalTableName, True
    DoCmd.RepaintObject
      

    
    Debug.Print "Table: " &amp; stLocalTableName &amp; " Was Successfully UN-Linked"


    Exit Sub

DetachDSNLessTable_Err:
    

    Debug.Print "Table: " &amp; stLocalTableName &amp; "Was NOT Linked"

ErrorHandler:
    Select Case Err.Number

         Case 2544
            Resume Next
        Case Else
            MsgBox "Detach_DSNLess_Table - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
    End Select
End Sub
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_StoredProc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>001_SP_Parm_In_Out_and_ReturnValue</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_StoredProc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>001_SP_Parm_In_Out_and_ReturnValue</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>001_SP_Parm_In_Out_and_ReturnValue


-- gg009_DMC_Pension_UpdateClaim_WithDate.sql


-- This SP will:

--		
--		1] Update the [DMC_Claim_t]:
--			Update the PensionDate back to Null, so that another user can begin work on the record
--			Add in the user and time that it was updated to the ClaimNote
--		2] Update the [DMC_Claim_MileStone_t]
--			Set CMS_1a = 4 {Completed}
--		

/*
	************************************************************************************
	NOTE: 
	Uses: 
	************************************************************************************
*/

SET NOCOUNT ON
Use Firstparty
go

	-- This setting may help performance and error reporting back to VBA.

alter PROCEDURE gg009_DMC_Pension_UpdateClaim_WithDate(
	@sClaim_PK as NVARCHAR(25),
	@sPensionDate as VARCHAR(10) ,							
	@ClaimNote AS NVARCHAR(1000), 
	@MessageFromSQL AS NVARCHAR(1000) OUTPUT
	)
	AS
	
	-- START DEBUGGING SECTION -------------------	
	
			PRINT 'gg009-Input  @sClaim_PK: ' +  @sClaim_PK
			PRINT 'gg009-Input  @sPensionDate: ' +  @sPensionDate
			PRINT 'gg009-Input  @ClaimNote: ' + 	 @ClaimNote	
			PRINT 'gg009-Input  @MessageFromSQL: ' + 	 @MessageFromSQL	

-- END DEBUGGING SECTION -------------------	
	

-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
   DECLARE @CONTINUE BIT	
   DECLARE @Claim_MileStone_PK INT
   DECLARE @Claim_PK INT
   DECLARE @dPensionDate DATE
  
	SELECT @CONTINUE = 1	
	SELECT @Claim_MileStone_PK = 0
	SELECT @MessageFromSQL = @MessageFromSQL + '[MessageFromSQL start in gg009]: '	
	SELECT @Claim_PK =CAST(@sClaim_PK as INT)
	SELECT @dPensionDate = CAST(@sPensionDate as DATE)   -- CONVERT(CHAR(10), @sPensionDate, 112) 
	PRINT 'Input @dPensionDate: ' +  CAST(@dPensionDate AS NVARCHAR(25))
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 1] Update the [DMC_Claim_t], Update the ClaimNote w/ the HEC Confirm Number, and Contact Info that was given to HEC
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	BEGIN TRANSACTION DMC_UpdateClaimAndMilestone_tr

-- START TEST 
  		PRINT 'gg009- TEST-1' +  @MessageFromSQL 
-- END TEST

	UPDATE DMC_Claim_t
	SET ClaimNote = @ClaimNote, Pension_Date = @dPensionDate, Hold_Started_DateTime = null	
	WHERE Claim_PK = @Claim_PK

-- START TEST 
  		PRINT 'gg009- TEST-2' +  @MessageFromSQL 
-- END TEST

	-- Check for errors
	-- ||||||||||||||||||
	IF @@ERROR &lt;&gt; 0
		BEGIN
		--
		-- Rollback the transaction and return to the caller
		--
		SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: Unable to update the ClaimNote for Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))		
		ROLLBACK TRANSACTION DMC_UpdateClaimAndMilestone_tr
		RETURN 1	-- Error in First Step
		END


-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 2] Update the [DMC_Claim_MileStone_t], Set CMS_1a = 4 {Complete}
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	UPDATE DMC_Claim_MileStone_t
	SET CMS_1a = 4
	WHERE Claim_FK = @Claim_PK

-- START TEST 
  		PRINT 'gg009- TEST-3' +  @MessageFromSQL 
-- END TEST


	-- Check for errors
	-- ||||||||||||||||||
	IF @@ERROR &lt;&gt; 0
		BEGIN
		--
		-- Rollback the transaction and return to the caller
		--
		SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: Unable to update the ClaimNote_MileStone for Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))		
		ROLLBACK TRANSACTION DMC_UpdateClaimAndMilestone_tr
		RETURN 2	-- Error in Second Step
		END


		SELECT @MessageFromSQL = @MessageFromSQL + '-- The MileStone (CMS_1a = 4) has been updated for Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))	


	COMMIT TRANSACTION DMC_UpdateClaimAndMilestone_tr

-- START TEST 
  		PRINT 'gg009- TEST-4' +  @MessageFromSQL 
-- END TEST
	


	--**************************************************************************
		PRINT '-----------------------------------------------------------------'
  		PRINT 'At the end of gg009' +  @MessageFromSQL 
	--**************************************************************************	

	RETURN 0
	
	go








</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_StoredProc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>002_SP_Parm_In_and_RecordSet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_StoredProc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>002_SP_Parm_In_and_RecordSet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>002_SP_Parm_In_and_RecordSet



-- gg010_DMC_GetClaims_Given_SSN.sql


-- Returns a List of Claims from DMC_Claim_t Where:
--		a) Full SSN = input parm
-- 

/*
	************************************************************************************
	NOTE:

	************************************************************************************
	Use: 
*/

SET NOCOUNT ON
Use Firstparty
go

	-- This setting may help performance and error reporting back to VBA.

Create PROCEDURE gg010_DMC_GetClaims_Given_SSN(
	@SSN_Full AS NVARCHAR(9)
	)
	AS
	
	-- START DEBUGGING SECTION -------------------	
	
			PRINT 'Input @SSN_Full: ' + 	 @SSN_Full
	
-- END DEBUGGING SECTION -------------------	
	
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
   DECLARE @COUNT INT
   
   
   SELECT @COUNT=0
	
--  **************************************************************************
--  1] Get the Count of records with this same SSN, and the records themselves.
--  **************************************************************************					
	SELECT @COUNT = (
					Select COUNT(*)
					FROM DMC_Claim_t
					WHERE [SSN_Full]=@SSN_Full
					)


	Select 
	[Veteran_Name],
	--[SSN_Original],
	--[Claim_No],
	--[Claim_Loc],
	[Eligibility],
	[SC_Eff_Date],
	[FacilityName],
	--[FacilityNumber],
	--[DateReportWasRun],
	--[SSMA_TimeStamp],
	[DateTimeUploaded],
	--[Pension_01],
	--[SC_01],
	[SSN_Full],
	--[Hold_UserName],
	--[Hold_Started_DateTime],
	[Claim_DONE_01],
	[Pension_Date],
	[ClaimNumberForThisSSN],
	[DateTimeUploaded],
	[ClaimNote]
      
	FROM DMC_Claim_t
	WHERE [SSN_Full]=@SSN_Full
		
	RETURN @COUNT  

		
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_StoredProc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>002_VBA_Parm_In_and_ReturnRecordSet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_StoredProc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>002_VBA_Parm_In_and_ReturnRecordSet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>002_VBA_Parm_In_and_ReturnRecordSet






Public Function fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet(sFullSSN As String) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sFullSSN: " &amp; sFullSSN
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'=============================================================================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg010_DMC_GetClaims_Given_SSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)

    End With
'=============================================================================
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
    
'    If iReturnValue = 0 Then
'        Err.Raise vbObjectError + 111
'    End If
        
    
    Set fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
'        Case vbObjectError + 111
''            Err.Raise vbObjectError + 111
'            MsgBox ("There were No Records in the database already with that SSN!")
        Case Else
            Debug.Print "fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_StoredProc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LongListOfExamples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_StoredProc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LongListOfExamples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Compare Database





Public Function fn_RunSP_UpdatePensionDate(iClaim_PK As Integer, _
                                            sPensionDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg009_DMC_Pension_UpdateClaim_WithDate"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sPensionDate", adVarChar, adParamInput, 10, sPensionDate)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_UpdatePensionDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function






Public Function fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet(sTransactionNumber As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sTransactionNumber: " &amp; sTransactionNumber
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg008_DMC_Pension_GetClaim_GivenHECTransactionNumber"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sTransactionNumber", adVarChar, adParamInput, 18, sTransactionNumber)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'
    
    Set fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    If iReturnValue &gt; 1 Then
            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg008_DMC_Pension_GetClaim_GivenHECTransactionNumber =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
    End If
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            MsgBox ("More than one Claim was returned that matched that Confirmation Number" &amp; vbCrLf &amp; "You need to use the COMPLETE and EXACT confirmation number")
'            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
            Debug.Print "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)

        Case Else
            Debug.Print "fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function


Public Function fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg006_DMC_Pension_GetClaimForHECDate_PlaceHold"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'    If iReturnValue = 50 Then
'        Err.Raise vbObjectError + 111
'    End If
'
    
    Set fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=50, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; No records left for that facility"
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function


'
Public Function fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    

    
'ALTER PROCEDURE gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN(
'    @SSN_Full AS NVARCHAR(9),
'    @sClaim_TEMP_PK as NVARCHAR(25),
'    @Hold_UserName AS nvarchar(255),
'    @MessageFromSQL AS NVARCHAR(1000) OUTPUT
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Private Sub ClearCommandParameters(ByRef oCMD As ADODB.Command)
    Dim lngX As Long
    For lngX = (oCMD.Parameters.Count - 1) To 0 Step -1
        oCMD.Parameters.Delete lngX
    Next

End Sub
'
'
'Public Function fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet(sFullSSN As String) As recordset




Public Function fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet(sFullSSN As String) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sFullSSN: " &amp; sFullSSN
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'=============================================================================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg010_DMC_GetClaims_Given_SSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)

    End With
'=============================================================================
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
    
'    If iReturnValue = 0 Then
'        Err.Raise vbObjectError + 111
'    End If
        
    
    Set fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
'        Case vbObjectError + 111
''            Err.Raise vbObjectError + 111
'            MsgBox ("There were No Records in the database already with that SSN!")
        Case Else
            Debug.Print "fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function




Public Function fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable(sSSN As String) As Integer
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sSSN: " &amp; sSSN
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

'    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg005_DMC_CountOccuranceOfSSN_In_DMC_Claim_t"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN)
'===================================================================================
        .Execute

'===================================================================================

    End With
    
    
    iReturnValue = objCmd.Parameters("RETURN_VALUE")
    
    fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable = iReturnValue
        
    
    
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objConn = Nothing
    Set objCmd = Nothing
'    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function

'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet
'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet



Public Function fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg001_DMC_Pension_GetClaimForSSN_PlaceHOLDonTEMPclaim" 'gg001_DMC_Pension_GetClaimForSSN_PlaceHOLDonTEMPclaim
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================


'===================================================================================


'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
    

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 50 Then
        Err.Raise vbObjectError + 111
    End If
        
    
    Set fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function


Public Sub RunSP_PP_ReportProblems(iPP_WorkList_PK As Integer, _
                                            sFullSSN As String, _
                                            sWorkList_Note As String, _
                                            sArchived_UserName As String, _
                                            sArchived_DateTime As String _
                                            )
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gig_PP_ReportProblem"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        'Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("@PP_WorkList_PK", adInteger, adParamInput, 0, iPP_WorkList_PK)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)
        .Parameters.Append .CreateParameter("@WorkList_Note", adVarChar, adParamInput, 1000, sWorkList_Note)
        .Parameters.Append .CreateParameter("@Archived_UserName", adVarChar, adParamInput, 255, sArchived_UserName)
        .Parameters.Append .CreateParameter("@Archived_DateTime", adVarChar, adParamInput, 255, sArchived_DateTime)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working

         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
    
    End With
    
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Sub
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "RunSP_PP_ReportProblems ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "RunSP_PP_ReportProblems ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Sub


Public Sub RunSP_MarkPrePayDone_ArchiveIt(iPP_WorkList_PK As Integer, _
                                            sFullSSN As String, _
                                            sWorkList_HoldReason As String, _
                                            sWorkList_Note As String, _
                                            sArchived_UserName As String, _
                                            sArchived_DateTime As String, _
                                            sHold_ProblemReported_Notes As String, _
                                            sHoldProblemResolved_DateTime As String, _
                                            sHoldProblemResolved_Notes As String, _
                                            sAction_Taken As String _
                                            ) 'As ADODB.recordset

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

'    Dim objRs As New ADODB.recordset
    Dim sConnect As String
'    Dim iIN As Integer
'    Dim iOUT As Integer
'    Dim sX As String
'    Dim iX As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gig_MarkPrePayDone_ArchiveIt"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        'Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("@PP_WorkList_PK", adInteger, adParamInput, 0, iPP_WorkList_PK)
'        .Parameters.Append .CreateParameter("@Date_Last_Updated", adVarChar, adParamInput, 255, sDate_Last_Updated)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)
        .Parameters.Append .CreateParameter("@WorkList_HoldReason", adVarChar, adParamInput, 255, sWorkList_HoldReason)
        .Parameters.Append .CreateParameter("@WorkList_Note", adVarChar, adParamInput, 1000, sWorkList_Note)
        .Parameters.Append .CreateParameter("@Archived_UserName", adVarChar, adParamInput, 255, sArchived_UserName)
        .Parameters.Append .CreateParameter("@Archived_DateTime", adVarChar, adParamInput, 255, sArchived_DateTime)
        .Parameters.Append .CreateParameter("@Hold_ProblemReported_Notes", adVarChar, adParamInput, 1000, sHold_ProblemReported_Notes)
        .Parameters.Append .CreateParameter("@HoldProblemResolved_DateTime", adVarChar, adParamInput, 255, sHoldProblemResolved_DateTime)
        .Parameters.Append .CreateParameter("@HoldProblemResolved_Notes", adVarChar, adParamInput, 1000, sHoldProblemResolved_Notes)
        .Parameters.Append .CreateParameter("@Action_Taken", adVarChar, adParamInput, 255, sAction_Taken)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
   

    End With
    
    
'        objRs.CursorLocation = adUseClient
'        objRs.CursorType = adOpenDynamic
'        objRs.LockType = adLockOptimistic
'        objRs.Open objCmd
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
    

'    Set RunSP_gig_GetPrePayInfo_PlaceTempHoldOnPrePay_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Sub
    
ErrHandler:
    'clean up
'    If objRs.State = adStateOpen Then
'        objRs.Close
'    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
'    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Sub



Public Function RunSP_gig_GetPrePayInfo_PlaceTempHoldOnPrePay_ReturnRecordSet(iFacility_FK As Long, sHold_UserName As String, iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "iFacility_FK: " &amp; iFacility_FK
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
'    Dim iIN As Integer
'    Dim iOUT As Integer
'    Dim sX As String
'    Dim iX As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gig_GetPrePayInfo_PlaceTempHoldOnPrePay"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_FK", adInteger, adParamInput, 0, iFacility_FK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================


'===================================================================================


'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
    

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 50 Then
        Err.Raise vbObjectError + 111
    End If
        
    
    Set RunSP_gig_GetPrePayInfo_PlaceTempHoldOnPrePay_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function



Public Function fRun_SQLString_NoParms_ReturnDisconnectedRecordSet(sSQL As String) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
'    Dim objCmd As New ADODB.Command
    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    Dim iX As Integer
    

            
    ' Connect to the data source.
'=========================
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    objCmd.ActiveConnection = objConn
        
'=======================================

' Setting the cursor location to client side is important
' to get a disconnected recordset.
objRs.CursorLocation = adUseClient
objRs.Open sSQL, objConn, ADODB.adOpenForwardOnly, ADODB.adLockBatchOptimistic

' Disconnect the recordset.
Set objRs.ActiveConnection = Nothing



'======================================
    ' Execute once and display...
'    Set objRs = objCmd.Execute
        

    For iX = 0 To objRs.Fields.Count - 1
        Debug.Print "Field " &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
    Next iX
        
    Set fRun_SQLString_NoParms_ReturnDisconnectedRecordSet = objRs
    
    'clean up
'    objRs.Close
'    objConn.Close
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
'    MsgBox "Done!"
    
    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing


    
    If Err &lt;&gt; 0 Then
        MsgBox "ERROR: fRun_SQLString_NoParms_ReturnDisconnectedRecordSet: " &amp; Err.Number &amp; ", " &amp; Err.Description
    End If

End Function

Public Sub RunStoredProcedure_NoParms_NoReturnInfo(sNameOfStoredProc As String)

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim objParm1 As New ADODB.Parameter
    Dim objRs As New ADODB.recordset
    Dim stConnect As String
    
    ' Set CommandText equal to the stored procedure name.
    objCmd.CommandText = sNameOfStoredProc
    objCmd.CommandType = adCmdStoredProc
            
    ' Connect to the data source.
'    Set objConn = GetNewConnection

'========================= OPTION to use a connection string
    stConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open stConnect
'==========================
    objCmd.ActiveConnection = objConn
    
    ' Execute once
    objCmd.Execute
                
    'clean up

    objConn.Close

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
'    MsgBox "Done!"
    Exit Sub

ErrHandler:
    'clean up

    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        MsgBox Err.Source &amp; "--&gt;" &amp; Err.Description, , "Error"
    Else
        MsgBox "Done!, but it went to the ErrHandler!"
    End If


End Sub





Public Function fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    
    
'ALTER PROCEDURE gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord(
'    @SSN_Full AS NVARCHAR(9),
'    @sClaim_TEMP_PK as NVARCHAR(25),
'    @Hold_UserName AS nvarchar(255),
'    @MessageFromSQL AS NVARCHAR(1000) OUTPUT
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function










Public Function fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t(sClaim_TEMP_PK As String) As Integer
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg004_DMC_Delete_Claim_From_Claim_TEMP_t"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        
         .Execute
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Public Function fn_RunStoredProcedure_NoParms_ReturnRecordSet(sNameOfStoredProc As String) As recordset
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    ' Set CommandText equal to the stored procedure name.
    objCmd.CommandText = "CustOrdersOrders"
    objCmd.CommandType = adCmdStoredProc
            
    ' Connect to the data source.
'=========================
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    objCmd.ActiveConnection = objConn
        
    ' Automatically fill in parameter info from stored procedure.
    objCmd.Parameters.Refresh
    
    ' Set the param value.

    
    ' Execute once and display...
    Set objRs = objCmd.Execute
        

    Do While Not objRs.EOF
        Debug.Print vbTab &amp; objRs(0) &amp; vbTab &amp; objRs(1) &amp; vbTab &amp; _
                    objRs(2) &amp; vbTab &amp; objRs(3)
        objRs.MoveNext
    Loop
        
    RunStoredProcedure_NoParms_ReturnRecordSet = objRs
    
    'clean up
    objRs.Close
    objConn.Close
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    MsgBox "Done!"
    
    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        MsgBox Err.Source &amp; "--&gt;" &amp; Err.Description, , "Error"
    End If

End Function
'
'
'
'
'
'Public Sub BAD_RunSP_MarkClaim_SentRequestToHEC(iClaim_PK As Integer, _
'                                            sClaimNote As String _
'                                            )
'
'    On Error GoTo ErrHandler:
'
'    Dim objConn As New ADODB.Connection
'    Dim objCmd As New ADODB.Command
'
'    Dim sConnect As String
'
'    ' Connect to the data source.
''========================= OPTION to use a connection string
'    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
'    objConn.Open sConnect
'
'    With objCmd
'        ' Set CommandText equal to the stored procedure name.
'        .CommandText = "gg007_DMC_Pension_Date_UpdateClaim_RequestSentToHEC"
'        .CommandType = adCmdStoredProc
'
'        .ActiveConnection = objConn
''=============================================================================
'
'        .Parameters.Append .CreateParameter("@Claim_PK", adInteger, adParamInput, 0, iClaim_PK)
'        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
'        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'        '--------
'         .Execute
'         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
'
'
'    End With
'
'
'        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
'
'
'    objConn.Close
'    Set objConn = Nothing
'    Set objCmd = Nothing
'
''    MsgBox "Done!"
'
'    Exit Sub
'
'ErrHandler:
'
'    If objConn.State = adStateOpen Then
'        objConn.Close
'    End If
'
'    Set objConn = Nothing
'    Set objCmd = Nothing
'    Set objParm1 = Nothing
'
'    If Err &lt;&gt; 0 Then
'        Debug.Print "RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
'
'        MsgBox "RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
'    End If
'
'End Sub



Public Function OLD_fn_RunSP_MarkClaim_SentRequestToHEC(iClaim_PK As Integer, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg007_DMC_Pension_Date_UpdateClaim_RequestSentToHEC"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_MarkClaim_SentRequestToHEC = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function





Public Function fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate(iClaim_PK As Integer, _
                                            sPensionDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg007A_DMC_Pension_PensionDate_Either_gg007_OR_gg009"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK_IN", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sPensionDate_IN", adVarChar, adParamInput, 10, sPensionDate)
        .Parameters.Append .CreateParameter("@ClaimNote_IN", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        
    objConn.Close
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function


'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet
'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet



Public Function fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg011_DMC_SC_GetClaimForSSN_PlaceHOLDonTEMPclaim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================


'===================================================================================


'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
    

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 50 Then
        Err.Raise vbObjectError + 111
    End If
        
    
    Set fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function








Public Function fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function




'
Public Function fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function




Public Function fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg016_DMC_SC_GetClaimForHECDate_PlaceHold"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'    If iReturnValue = 50 Then
'        Err.Raise vbObjectError + 111
'    End If
'
    
    Set fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=50, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; No records left for that facility"
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function




Public Function fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate(iClaim_PK As Integer, _
                                            sSCDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg017A_DMC_SC_SCDate_Either_gg017_OR_gg019"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK_IN", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sSCDate_IN", adVarChar, adParamInput, 10, sSCDate)
        .Parameters.Append .CreateParameter("@ClaimNote_IN", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        
    objConn.Close
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function






Public Function fn_RunSP_UpdateSCDate(iClaim_PK As Integer, _
                                            sSCDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg019_DMC_SC_UpdateClaim_WithDate"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sSCDate", adVarChar, adParamInput, 10, sSCDate)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_UpdateSCDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_UpdateSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_UpdateSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function







Public Function fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet(sTransactionNumber As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sTransactionNumber: " &amp; sTransactionNumber
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg018_DMC_SC_GetClaim_GivenHECTransactionNumber"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sTransactionNumber", adVarChar, adParamInput, 18, sTransactionNumber)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'
    
    Set fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    If iReturnValue &gt; 1 Then
            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg008_DMC_Pension_GetClaim_GivenHECTransactionNumber =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
    End If
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            MsgBox ("More than one Claim was returned that matched that Confirmation Number" &amp; vbCrLf &amp; "You need to use the COMPLETE and EXACT confirmation number")
'            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
            Debug.Print "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)

        Case Else
            Debug.Print "fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function





Public Function fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                bSortBy_SC_First As Boolean, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    Dim iSortBy_SC_First As Integer
    
'========================================
' Translate input values

    If bSortBy_SC_First = True Then
        iSortBy_SC_First = 1
    Else
        iSortBy_SC_First = 0
    End If
    
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg020_DMC_GetNewOrIncompleteClaim_ToValidate"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)
        .Parameters.Append .CreateParameter("@SortBy_SC_First", adInteger, adParamInput, 0, iSortBy_SC_First)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")    '( 1 means there were no problems, 0 means there were problems)
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 0 Then
        Err.Raise vbObjectError + 111
    End If
'
    
    Set fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=0 in: fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet, from: gg020_DMC_GetNewOrIncompleteClaim_ToValidate =&gt; There was a problem"
        Case Else
            Debug.Print "fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function



Public Function fn_Tickle_ClaimPK_Hold(sClaim_PK As String, _
                                        sUserName As String, _
                                        sNumberOfDays As String) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg000A_TickleOutHOLD_Claim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sUserName", adVarChar, adParamInput, 255, sUserName)
        .Parameters.Append .CreateParameter("@sNumberOfDays", adVarChar, adParamInput, 2, sNumberOfDays)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_Tickle_ClaimPK_Hold = iReturnValue   '0 if there was a problem, 1 if it was ok

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_Tickle_ClaimPK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_Tickle_ClaimPK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function





Public Function fn_Tickle_Claim_TEMP_PK_Hold(sClaim_TEMP_PK As String, _
                                        sUserName As String, _
                                        sNumberOfDays As String) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg000B_TickleOutHOLD_ClaimTEMP"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@sUserName", adVarChar, adParamInput, 255, sUserName)
        .Parameters.Append .CreateParameter("@sNumberOfDays", adVarChar, adParamInput, 2, sNumberOfDays)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_Tickle_Claim_TEMP_PK_Hold = iReturnValue   '0 if there was a problem, 1 if it was ok

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_Tickle_Claim_TEMP_PK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_Tickle_Claim_TEMP_PK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function








Public Function fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet(sClaim_PK As String, _
                                                                   sClaim_TEMP_PK As String) _
                                                                   As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sClaim_PK: " &amp; sClaim_PK
    Debug.Print "sClaim_TEMP_PK: " &amp; sClaim_TEMP_PK
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer

    

    
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg000C_DMC_CountBillsToValidateForTheClaim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sClaim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")    '( 1 means there were no problems, 0 means there were problems)
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue &gt; 0 Then
    ' @@ERROR should be 0 if everything is ok.
        Err.Raise vbObjectError + 111
    End If
'
    
    Set fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet = objRs
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=0 in: fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet, from: gg020_DMC_GetNewOrIncompleteClaim_ToValidate =&gt; There was a problem"
        Case Else
            Debug.Print "fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function









Public Function fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Long
    
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim lReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        lReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord = lReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Public Function fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Long
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim lReturnValue As Long
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        lReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN = lReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Public Function fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim(sClaim_PK As String, _
                                                                            sHold_UserName As String, _
                                                                            iTimeLimitForHoldInMinutes As Integer) _
                                                                            As ADODB.recordset
    On Error GoTo ErrHandler:
    
     Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "sClaim_PK: " &amp; sClaim_PK
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer

     ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 25, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
        
'===================================================================================

    End With
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")    '( This is the DMC_Bills_PK)
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue (DMC_Bills_PK):" &amp; iReturnValue
    
'    If iReturnValue &gt; 0 Then
'    ' @@ERROR should be 0 if everything is ok.
'        Err.Raise vbObjectError + 111
'    End If
'
    
    Set fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim = objRs
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
'        Case vbObjectError + 111
''            Err.Raise vbObjectError + 111
'            Debug.Print "Return Code=0 in: fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim, from: gg020_DMC_GetNewOrIncompleteClaim_ToValidate =&gt; There was a problem"
        Case Else
            Debug.Print "fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function







Public Function fn_gg022_Bill_and_Milestone_UpdateServiceDates( _
                                            sBill_PK As String, _
                                            sFirstDateServiced As String, _
                                            sLastDateServiced As String, _
                                            sBillNote As String, _
                                            sHold_UserName As String _
                                            ) As Integer
                                            
' create PROCEDURE gg022_Bill_and_Milestone_UpdateServiceDates(
'    @sBills_PK as NVARCHAR(25),
'    @sFirstDateServiced as VARCHAR(10) ,
'    @sLastDateServiced as VARCHAR(10) ,
'    @BillNote AS NVARCHAR(1000),
'    @Hold_UserName AS NVARCHAR(25),
'    @MessageFromSQL AS NVARCHAR(1000) OUTPUT
'    )
                                            
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg022_Bill_and_Milestone_UpdateServiceDates"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sBill_PK", adVarChar, adParamInput, 25, sBill_PK)
        .Parameters.Append .CreateParameter("@sFirstDateServiced", adVarChar, adParamInput, 10, sFirstDateServiced)
        .Parameters.Append .CreateParameter("@sLastDateServiced", adVarChar, adParamInput, 10, sLastDateServiced)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sBillNote)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_gg022_Bill_and_Milestone_UpdateServiceDates = iReturnValue '0=No errors, otherwise the number indicates which step had the error

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_gg022_Bill_and_Milestone_UpdateServiceDates ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_gg022_Bill_and_Milestone_UpdateServiceDates ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function

'\\\\\\\


Public Function fn_gg023_DMC_Claim_Validate_Phase_1_Done(lClaim_PK As Long) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(lClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg023_DMC_Claim_Validate_Phase_1_Done"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
'-----
         .Execute
        
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_gg023_DMC_Claim_Validate_Phase_1_Done = iReturnValue       'RETURN(@@ERROR),  @@ERROR should be 0 if everything is ok.

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CREATE_TABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CREATE_TABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


Sub Create_CombinedHospital_t()
    On Error GoTo ErrorHandler
    
    '=========================
    Dim sSQL As String
    
    sSQL = "CREATE TABLE CombinedHospital_t ([FACILITY CODE] TEXT(255),"
    sSQL = sSQL &amp; "[ACCOUNT NUMBER] TEXT(255),"
    sSQL = sSQL &amp; "[MEDICAID ID] TEXT(255),"
    sSQL = sSQL &amp; "[SOCIAL SECURITY NUMBER] TEXT(255),"
    sSQL = sSQL &amp; "[PATIENT TYPE] TEXT(255),"
    sSQL = sSQL &amp; "[ADMISSION DATE] DATETIME,"
    sSQL = sSQL &amp; "[DISCHARGE DATE] TEXT(255),"
    sSQL = sSQL &amp; "[LAST NAME] TEXT(255),"
    sSQL = sSQL &amp; "[FIRST NAME] TEXT(255),"
    sSQL = sSQL &amp; "[MIDDLE INITIAL] TEXT(255),"
    sSQL = sSQL &amp; "[ADDRESS LINE 1] TEXT(255),"
    sSQL = sSQL &amp; "[ADDRESS LINE 2] TEXT(255),"
    sSQL = sSQL &amp; "[CITY] TEXT(255),"
    sSQL = sSQL &amp; "[COUNTY] TEXT(255),"
    sSQL = sSQL &amp; "[STATE] TEXT(255),"
    sSQL = sSQL &amp; "[ZIP CODE] TEXT(255),"
    sSQL = sSQL &amp; "[HOME PHONE] TEXT(255),"
    sSQL = sSQL &amp; "[ALTERNATE PHONE] TEXT(255),"
    sSQL = sSQL &amp; "[BIRTH DATE] DATETIME,"
    sSQL = sSQL &amp; "[AGE ON ADMIT] TEXT(255),"
    sSQL = sSQL &amp; "[PCP NAME] TEXT(255),"
    sSQL = sSQL &amp; "[PRIMARY INSURANCE] TEXT(255),"
    sSQL = sSQL &amp; "[SECONDARY INSURANCE] TEXT(255),"
    sSQL = sSQL &amp; "[TERTIARY INSURANCE] TEXT(255),"
    sSQL = sSQL &amp; "[PRINCIPLE ICD9 CODE] TEXT(255),"
    sSQL = sSQL &amp; "[PRINCIPLE ICD9 DESCRIPTION] TEXT(255),"
    sSQL = sSQL &amp; "[2ND ICD9 CODE] TEXT(255),"
    sSQL = sSQL &amp; "[2ND ICD9 DESCRIPTION] TEXT(255),"
    sSQL = sSQL &amp; "[3RD ICD9 CODE] TEXT(255),"
    sSQL = sSQL &amp; "[3RD ICD9 DESCRIPTION] TEXT(255),"
    sSQL = sSQL &amp; "[4TH ICD9 CODE] TEXT(255),"
    sSQL = sSQL &amp; "[4TH ICD9 DESCRIPTION] TEXT(255),"
    sSQL = sSQL &amp; "[5TH ICD9 CODE] TEXT(255),"
    sSQL = sSQL &amp; "[5TH ICD9 DESCRIPTION] TEXT(255),"
    sSQL = sSQL &amp; "[6TH ICD9 CODE] TEXT(255),"
    sSQL = sSQL &amp; "[6TH ICD9 DESCRIPTION] TEXT(255),"
    sSQL = sSQL &amp; "[7TH ICD9 CODE] TEXT(255),"
    sSQL = sSQL &amp; "[7TH ICD9 DESCRIPTION] TEXT(255),"
    sSQL = sSQL &amp; "[PRINCIPLE PROCEDURE CODE] TEXT(255),"
    sSQL = sSQL &amp; "[PRINCIPLE PROCEDURE DESCRIPTION] TEXT(255),"
    sSQL = sSQL &amp; "[SECONDARY PROCEDURE CODE] TEXT(255),"
    sSQL = sSQL &amp; "[SECONDARY PROCEDURE DESCRIPTION] TEXT(255)"
    sSQL = sSQL &amp; ")"
    
    
    DoCmd.RunSQL "Drop TABLE CombinedHospital_t"
    
    DoCmd.RunSQL sSQL
    
    Application.RefreshDatabaseWindow
     '=========================
  
      Exit Sub
      
      
ErrorHandler:
        Select Case Err.Number
             Case 3376
               ' This happens when you try to delete the table and it already is not there.
                Resume Next
    '         Case vbObjectError + 111
    '            'MsgBox "Error: vbObjectError + 111"
    '            Exit Sub
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
            
        
    
    End Sub

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Min_Max</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Min_Max</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


    Dim countArray(5) As Variant

     countArray(0) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Name]", "q_T201_Trucker", varWhere)
     countArray(1) = DCount("[dbo_T201_Trucker.A1_Trucking_Number]", "q_T201_Trucker", varWhere)
     countArray(2) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_1]", "q_T201_Trucker", varWhere)
     countArray(3) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_2]", "q_T201_Trucker", varWhere)
     countArray(4) = DCount("[dbo_T201_Trucker.A1_Trucking_Contact_Notes]", "q_T201_Trucker", varWhere)
     countArray(5) = DCount("[dbo_T201_Trucker.A1_Trucking_Company_Address_3]", "q_T201_Trucker", varWhere)
     
     Dim iCount_max As Variant
'     iCount_max = MaxInList(countArray)		'&lt;======================================================================This does not work: Type Mismatch
     iCount_max = MaxInList(countArray(0), countArray(1), countArray(2), countArray(3), countArray(4), countArray(5))
     
     

	Function MaxInList(ParamArray ArrayList() As Variant)
	    'Function will return the maximum value from a list of values
	       
	    Dim n As Integer
	    Dim iValue As Variant
	     
	    'Set the variable iValue - initialize to the first item or value in list.
	    iValue = ArrayList(0)
	    
	    'Checks each item or value in the list to find the largest.
	    For n = 0 To UBound(ArrayList)
	    'Determines the largest value.
	    If ArrayList(n) &gt; iValue Then
	        iValue = ArrayList(n)
	    End If
	    
	    Next n
	    
	    MaxInList = iValue
	   
	End Function     
     
     

======================================================================

Option Compare Database
Option Base 0
Option Explicit

Function f_var_Min(ParamArray NumericItems()) As Variant
	If UBound(NumericItems) = -1 Then Exit Function ' No parameters
	Dim vVal As Variant, vNumeric As Variant
	vVal = NumericItems(0)
	For Each vNumeric In NumericItems
	    vVal = IIf(vNumeric &lt; vVal, vNumeric, vVal) ' Keep smaller of 2 values
	Next
	f_var_Min = vVal ' Return final value
End Function

Function f_var_Max(ParamArray NumericItems()) As Variant
	If UBound(NumericItems) = -1 Then Exit Function ' No parameters
	Dim vVal As Variant, vNumeric As Variant
	vVal = NumericItems(0)
	For Each vNumeric In NumericItems
	    vVal = IIf(vNumeric &lt; vVal, vVal, vNumeric) ' Keep larger of 2 values
	Next
	f_var_Max = vVal ' Return final value
End Function

========================================================================================


  Public Function iMax(ParamArray p()) As Variant
  ' Idea from Trevor Best in Usenet MessageID rib5dv45ko62adf2v0d1cot4kiu5t8mbdp@4ax.com
    Dim i As Long
    Dim v As Variant

    v = p(LBound(p))
    For i = LBound(p) + 1 To UBound(p)
      If v &lt; p(i) Then
         v = p(i)
      End If
    Next
    iMax = v
  End Function

  Public Function iMin(ParamArray p()) As Variant
  ' Idea from Trevor Best in Usenet MessageID rib5dv45ko62adf2v0d1cot4kiu5t8mbdp@4ax.com
    Dim i As Long
    Dim v As Variant

    v = p(LBound(p))
    For i = LBound(p) + 1 To UBound(p)
      If v &gt; p(i) Then
         v = p(i)
      End If
    Next
    iMin = v
  End Function
  
  
  'Note "an array of numbers" is critical. iMax(Null,1) returns Null. And iMax(1,2,"foo") returns foo.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Numeric_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Numeric_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Numeric/Math Functions

Abs
Atn
Avg
Cos
Count
Exp
Fix - returns the integer portion of a number
Format (with Numbers)
Int
Max
Min
Randomize
Rnd (random number)
Round
Sgn
Sqr
Sum
Val</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Password Protect a Form or a Report - Table Based Password</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Password Protect a Form or a Report - Table Based Password</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Table Based Password

'Run Query
CREATE TABLE tbl_DB_Object_Password (  
     ObjectPasswordId              COUNTER PRIMARY KEY,
     Objecttype      TEXT(10) NOT NULL,
     ObjectName      TEXT(255) NOT NULL,
     ObjectPassword      TEXT(255) NOT NULL,
     CONSTRAINT UniqueObjectEntry UNIQUE (ObjectType, ObjectName)
);
     
     
     'Now you need to make an entry for each object you wish to protect

'ObjectType = Form or Report
'ObjectName = Name of the Form or Report
'ObjectPassword = Password you’d like to use to protect the Form or Report

'Then once that is done, we’d use code along the lines of

Private Sub Form_Open(Cancel As Integer)
    On Error GoTo Error_Handler
    Dim sFormPassword
 
    sFormPassword = Nz(DLookup("ObjectPassword", "tbl_DB_Object_Passwords", _
                               "[ObjectType]='Form' AND [ObjectName]='" &amp; Me.Name &amp; "'"), "")
    If sFormPassword &lt;&gt; "" Then
        '    If InputBox("Please enter the Password.") &lt;&gt; "MyPassword" Then 'if using Option Compare Binary
        If StrComp(InputBox("Please enter the Password. (the password is: ABc"), sFormPassword, 0) &lt;&gt; 0 Then
            Cancel = True
            MsgBox "Wrong password.", vbInformation Or vbOKOnly, "Operation cancelled"
        End If
    Else
        'You choose what to do here!
        '***************************
        '1. no password was set so this form isn't secured, do nothing
        '2. no password, so the admin forgot to set things up, so lock it down by Cancel=True
    End If
 
Error_Handler_Exit:
    On Error Resume Next
    Exit Sub
 
Error_Handler:
    MsgBox "The following error has occurred" &amp; vbCrLf &amp; vbCrLf &amp; _
           "Error Number: " &amp; Err.Number &amp; vbCrLf &amp; _
           "Error Source: Form_Open" &amp; vbCrLf &amp; _
           "Error Description: " &amp; Err.Description &amp; _
           Switch(Erl = 0, "", Erl &lt;&gt; 0, vbCrLf &amp; "Line No: " &amp; Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Password Protect a Form or a Report</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Password Protect a Form or a Report</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.devhut.net/2018/09/16/access-password-protect-a-form-or-a-report/

'Authorized User(s) Table run in Access:

CREATE TABLE tbl_Users (  
     UserId              COUNTER PRIMARY KEY,
     UserName      TEXT(255) NOT NULL,
     Objecttype      TEXT(10) NOT NULL,
     ObjectName      TEXT(255) NOT NULL,
     CONSTRAINT UniqueUserObject UNIQUE (UserName, ObjectType, ObjectName)
);


'Now you need to make an entry for each object you wish to protect

'UserName = The windows username of the authorized user
'ObjectType = Form or Report
'ObjectName = Name of the Form or Report

'and then we code the Form’s/Report’s On Open event like

'and then we code the Form’s/Report’s On Open event like

Private Sub Form_Open(Cancel As Integer)
    On Error GoTo Error_Handler
 
    If Nz(DLookup("UserName", "tbl_Users", _
                  "[ObjectType]='Form' AND [ObjectName]='" &amp; Me.Name &amp; "' AND [UserName]='" &amp; fOSUserName() &amp; "'"), "") = "" Then
        Cancel = True
        MsgBox "You are not authorized to open this form", vbInformation Or vbOKOnly, "Operation cancelled"
    End If
 
Error_Handler_Exit:
    On Error Resume Next
    Exit Sub
 
Error_Handler:
    MsgBox "The following error has occurred" &amp; vbCrLf &amp; vbCrLf &amp; _
           "Error Number: " &amp; Err.Number &amp; vbCrLf &amp; _
           "Error Source: Form_Open" &amp; vbCrLf &amp; _
           "Error Description: " &amp; Err.Description &amp; _
           Switch(Erl = 0, "", Erl &lt;&gt; 0, vbCrLf &amp; "Line No: " &amp; Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Sub



'====================================

Option Compare Database
Private Declare Function apiGetUserName Lib "advapi32.dll" Alias _
"GetUserNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Private Declare Function apiGetComputerName Lib "kernel32" Alias _
"GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long

Function fOSUserName() As String
'Returns the network login name
    Dim lnglen As Long, lngX As Long
    Dim strUserName As String
    strUserName = String$(254, 0)
    lnglen = 255
    lngX = apiGetUserName(strUserName, lnglen)
    If lngX &lt;&gt; 0 Then
        fOSUserName = Left$(strUserName, lnglen - 1)
    Else
        fOSUserName = ""
    End If

End Function
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Populate_LocalTable_FromExcel</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Populate_LocalTable_FromExcel</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'  EXAMPLE: USING SQL FUNCTIONS IN THE INSERT INTO STATEMENT
'    cn.Execute "INSERT INTO [T3_ECP_Enrollment_t] (EDIT, LASTNAME, FIRSTNAME, MI, DOB, LASTVISIT, CHARTS) IN '" &amp; sPathFileName_CurrentDB &amp; "' SELECT [Edit], [PatientLast], [PatientFirst], MID([PatientMiddle],1,1), [DOB], [LastVisit(Days)], [# Charts] FROM [TalkingEMR_Patientlist$]"



Sub Populate_CombinedHospital_FromExcel(sPathFileName As String)

    'Reference: Microsoft ActiveX Date Objects 2.8 Library

    On Error GoTo ErrorHandler
    '==============================
    Dim cn As ADODB.Connection
    Dim dbs As Database
    Dim SQLstring As String
    Dim sPath As String
    Dim sFileName As String
    Dim sPathFileName_CurrentDB As String
    
    Set dbs = CurrentDb
    Set cn = New ADODB.Connection

    
    '0] Get the Location of the access DB
    sPath = Application.CurrentProject.Path
    sFileName = Application.CurrentProject.Name
    sPathFileName_CurrentDB = sPath &amp; "\" &amp; sFileName
    
    '2] Open the Connection
     cn.Open "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" &amp; sPathFileName &amp; ";Extended Properties='Excel 12.0;HDR=Yes;IMEX=1'"
    
'===============
   SQLstring = "INSERT INTO [CombinedHospital_t] "
   'List from Access Table:
   SQLstring = SQLstring &amp; "([FACILITY CODE] ,  [ACCOUNT NUMBER] ,  [MEDICAID ID] ,  [SOCIAL SECURITY NUMBER] ,[PATIENT TYPE] ,  [ADMISSION DATE] ,  [DISCHARGE DATE] ,  [LAST NAME] ,  [FIRST NAME] ,[MIDDLE INITIAL] ,  [ADDRESS LINE 1] ,  "
   SQLstring = SQLstring &amp; "[ADDRESS LINE 2] ,  [CITY] ,  [COUNTY] ,[STATE] ,  [ZIP CODE] ,  [HOME PHONE] , [ALTERNATE PHONE] , [BIRTH DATE] ,  [AGE ON ADMIT] ,[PCP NAME] ,[PRIMARY INSURANCE] ,[SECONDARY INSURANCE] ,[TERTIARY INSURANCE] ,[PRINCIPLE ICD9 CODE] , "
   SQLstring = SQLstring &amp; "[PRINCIPLE ICD9 DESCRIPTION] ,[2ND ICD9 CODE] ,[2ND ICD9 DESCRIPTION] ,[3RD ICD9 CODE] ,[3RD ICD9 DESCRIPTION] ,[4TH ICD9 CODE] ,[4TH ICD9 DESCRIPTION] ,[5TH ICD9 CODE] ,[5TH ICD9 DESCRIPTION] ,[6TH ICD9 CODE] ,[6TH ICD9 DESCRIPTION] , "
   SQLstring = SQLstring &amp; "[7TH ICD9 CODE] ,[7TH ICD9 DESCRIPTION] ,[PRINCIPLE PROCEDURE CODE] ,[PRINCIPLE PROCEDURE DESCRIPTION] ,[SECONDARY PROCEDURE CODE] ,[SECONDARY PROCEDURE DESCRIPTION])"
   
   SQLstring = SQLstring &amp; "IN '" &amp; sPathFileName_CurrentDB
   SQLstring = SQLstring &amp; "' SELECT "
   'List from Excel Spreadsheet:
   SQLstring = SQLstring &amp; "[FACILITY CODE] ,  [ACCOUNT NUMBER] ,  [MEDICAID ID] ,  [SOCIAL SECURITY NUMBER] ,[PATIENT TYPE] ,  [ADMISSION DATE] ,  [DISCHARGE DATE] ,  [LAST NAME] ,  [FIRST NAME] ,[MIDDLE INITIAL] ,  [ADDRESS LINE 1] ,  "
   SQLstring = SQLstring &amp; "[ADDRESS LINE 2] ,  [CITY] ,  [COUNTY] ,[STATE] ,  [ZIP CODE] ,  [HOME PHONE] , [ALTERNATE PHONE] , [BIRTH DATE] ,  [AGE ON ADMIT] ,[PCP NAME] ,[PRIMARY INSURANCE] ,[SECONDARY INSURANCE] ,[TERTIARY INSURANCE] ,[PRINCIPLE ICD9 CODE] , "
   SQLstring = SQLstring &amp; "[PRINCIPLE ICD9 DESCRIPTION] ,[2ND ICD9 CODE] ,[2ND ICD9 DESCRIPTION] ,[3RD ICD9 CODE] ,[3RD ICD9 DESCRIPTION] ,[4TH ICD9 CODE] ,[4TH ICD9 DESCRIPTION] ,[5TH ICD9 CODE] ,[5TH ICD9 DESCRIPTION] ,[6TH ICD9 CODE] ,[6TH ICD9 DESCRIPTION] , "
   SQLstring = SQLstring &amp; "[7TH ICD9 CODE] ,[7TH ICD9 DESCRIPTION] ,[PRINCIPLE PROCEDURE CODE] ,[PRINCIPLE PROCEDURE DESCRIPTION] ,[SECONDARY PROCEDURE CODE] ,[SECONDARY PROCEDURE DESCRIPTION]"
   
   SQLstring = SQLstring &amp; "FROM [Sheet1$]"
'===============
    
    cn.Execute SQLstring
   
   
   
CleanUp:
    dbs.Close
    Set dbs = Nothing
    cn.Close
    Set cn = Nothing

   
'    MsgBox ("Done!")
    
    Exit Sub
    
'==============================
ErrorHandler:
    Select Case Err.Number
'         Case vbObjectError + 111
'            'MsgBox "Error: vbObjectError + 111"
'            Exit Sub
        Case Else
            MsgBox "Populate_CombinedHospital_FromExcel - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
            
    End Select
    GoTo CleanUp
    
End Sub
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>RecordCount</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>RecordCount</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Private Function BuildFilter() As Variant
    
    On Error GoTo ErrorHandler
    
    '=========================
    Dim varWhere As Variant

    varWhere = Null  ' Main filter

    If Me.txt_FilterBy &gt; "" Then
        varWhere = varWhere &amp; "[dbo_T101_Vendor.Vendor] LIKE" &amp; " '*" &amp; Trim(UCase(Me.txt_FilterBy)) &amp; "*' " &amp; " OR "
        
        varWhere = varWhere &amp; " [dbo_T101_Vendor.Vendor_Name] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' "           '&amp; " OR "
'        varWhere = varWhere &amp; " [dbo_T101_Vendor.Vendor_Contact_Notes] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
'        varWhere = varWhere &amp; " [dbo_T101_Vendor.Vendor_Notes] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
'        varWhere = varWhere &amp; " [dbo_T101_Vendor.Vendor_ZipCode] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
'        varWhere = varWhere &amp; " [dbo_T101_Vendor.Vendor_Address_1] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
'        varWhere = varWhere &amp; " [dbo_T101_Vendor.Vendor_Address_2] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' " &amp; " OR "
'        varWhere = varWhere &amp; " [dbo_T101_Vendor.Vendor_Address_3] LIKE " &amp; " '*" &amp; UCase(Me.txt_FilterBy) &amp; "*' "
        
    End If

     Dim iCount_Vendor															'&lt;============= Record Count
     iCount_Vendor = DCount("[dbo_T101_Vendor.Vendor]", "q_T101_Vendor", varWhere)
     Dim iCount_Vendor_Name
     iCount_Vendor_Name = DCount("[dbo_T101_Vendor.Vendor_Name]", "q_T101_Vendor", varWhere)


    If IsNull(varWhere) Or ((iCount_Vendor + iCount_Vendor_Name) = 0) Then
        varWhere = "SELECT dbo_T101_Vendor.* FROM dbo_T101_Vendor"
        
        If iCount_Vendor = 0 Then
            MsgBox "No records were found that met your criteria"
        End If
    Else
        varWhere = "SELECT dbo_T101_Vendor.* FROM dbo_T101_Vendor WHERE" &amp; varWhere

    End If

    BuildFilter = varWhere
        '=========================
    Exit Function
            
ErrorHandler:
        Select Case Err.Number

            Case 3075  '
                MsgBox "There was a problem. You may have had an illegal character in your search string (e.g. an apostrophe). Remove the part with any non-alphatical characters and try again"
                BuildFilter = "SELECT dbo_T101_Vendor.* FROM dbo_T101_Vendor"

                Exit Function
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Function


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Transferring Records to Excel with Automation</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Transferring Records to Excel with Automation</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'http://access.mvps.org/access/modules/mdl0035.htm

'Excel's CopyFromRecordset method is probably the fastest way to copy over the records 
'via Automation. It also provides a great deal of flexibility on where and how 
'the records are to be copied. 
'You can use a named range in an existing worksheet or specify starting columns for the records.

'Here are a couple of different ways to transfer a recordset over to Excel. In order to use these samples, set a reference to "Microsoft Excel 8.0 Object Library" under Tools Menu/References first.

'************* Code Start *****************
'This code was originally written by Dev Ashish
'It is not to be altered or distributed,
'except as part of an application.
'You are free to use it in any application,
'provided the copyright notice is left unchanged.
'
'Code Courtesy of
'Dev Ashish
'
Sub sCopyFromRS()
'Send records to the first
'sheet in a new workbook
'
Dim rs As Recordset
Dim intMaxCol As Integer
Dim intMaxRow As Integer
Dim objXL As Excel.Application
Dim objWkb As Workbook
Dim objSht As Worksheet
  Set rs = CurrentDb.OpenRecordset("Customers", _
                    dbOpenSnapshot)
  intMaxCol = rs.Fields.Count
  If rs.RecordCount &gt; 0 Then
    rs.MoveLast:    rs.MoveFirst
    intMaxRow = rs.RecordCount
    Set objXL = New Excel.Application
    With objXL
      .Visible = True
      Set objWkb = .Workbooks.Add
      Set objSht = objWkb.Worksheets(1)
      With objSht
        .Range(.Cells(1, 1), .Cells(intMaxRow, _
            intMaxCol)).CopyFromRecordset rs
      End With
    End With
  End If
End Sub

Sub sCopyRSExample()
'Copy records to first 20000 rows
'in an existing Excel Workbook and worksheet
'
Dim objXL As Excel.Application
Dim objWkb As Excel.Workbook
Dim objSht As Excel.Worksheet
Dim db As Database
Dim rs As Recordset
Dim intLastCol As Integer
Const conMAX_ROWS = 20000
Const conSHT_NAME = "SomeSheet"
Const conWKB_NAME = "J:\temp\book1.xls"
  Set db = CurrentDb
  Set objXL = New Excel.Application
  Set rs = db.OpenRecordset("Customers", dbOpenSnapshot)
  With objXL
    .Visible = True
    Set objWkb = .Workbooks.Open(conWKB_NAME)
    On Error Resume Next
    Set objSht = objWkb.Worksheets(conSHT_NAME)
    If Not Err.Number = 0 Then
      Set objSht = objWkb.Worksheets.Add
      objSht.Name = conSHT_NAME
    End If
    Err.Clear
    On Error GoTo 0
    intLastCol = objSht.UsedRange.Columns.Count
    With objSht
      .Range(.Cells(1, 1), .Cells(conMAX_ROWS, _
          intLastCol)).ClearContents
      .Range(.Cells(1, 1), _
        .Cells(1, rs.Fields.Count)).Font.Bold = True
      .Range("A2").CopyFromRecordset rs
    End With
  End With
  Set objSht = Nothing
  Set objWkb = Nothing
  Set objXL = Nothing
  Set rs = Nothing
  Set db = Nothing
End Sub

Sub sCopyRSToNamedRange()
'Copy records to a named range
'on an existing worksheet on a
'workbook
'
Dim objXL As Excel.Application
Dim objWkb As Excel.Workbook
Dim objSht As Excel.Worksheet
Dim db As Database
Dim rs As Recordset
Const conMAX_ROWS = 20000
Const conSHT_NAME = "SomeSheet"
Const conWKB_NAME = "c:\temp\book1.xls"
Const conRANGE = "RangeForRS"

  Set db = CurrentDb
  Set objXL = New Excel.Application
  Set rs = db.OpenRecordset("Customers", dbOpenSnapshot)
  With objXL
    .Visible = True
    Set objWkb = .Workbooks.Open(conWKB_NAME)
    On Error Resume Next
    Set objSht = objWkb.Worksheets(conSHT_NAME)
    If Not Err.Number = 0 Then
      Set objSht = objWkb.Worksheets.Add
      objSht.Name = conSHT_NAME
    End If
    Err.Clear
    On Error GoTo 0
    objSht.Range(conRANGE).CopyFromRecordset rs
  End With
  Set objSht = Nothing
  Set objWkb = Nothing
  Set objXL = Nothing
  Set rs = Nothing
  Set db = Nothing
End Sub
'************* Code End *****************</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Array</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Fill_Array_From_EveryOtherRowOf_a_Range</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Array</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Fill_Array_From_EveryOtherRowOf_a_Range</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub EveryOtherRow()
    ' Page 455
    Dim myArray(1 To 8, 1 To 2)
    Dim i As Integer, j As Integer, myCount As Integer
    
    'Fill the array with every other row
    For i = 1 To 8
        For j = 1 To 2
            myArray(i, j) = Worksheets("EveryOther").Cells(i * 2, j + 1).Value
        Next j
    Next i

    'Empty the array
    For myCount = LBound(myArray) To UBound(myArray)
        Worksheets("EveryOther").Cells(myCount * 2, 4) = _
            WorksheetFunction.Sum(myArray(myCount, 1), myArray(myCount, 2))
    Next myCount
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Array</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LookForAllTheExcelFilesInADirectory</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Array</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LookForAllTheExcelFilesInADirectory</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Look For all the Excel Files in a Directory

Sub XLFiles()
    ' Page 459 - at bottom
    Dim FName As String
    Dim arNames() As String
    Dim myCount As Integer
    
    FName = Dir(ThisWorkbook.Path &amp; "\*.xls*")
    Do Until FName = ""
        myCount = myCount + 1
        ReDim Preserve arNames(1 To myCount)
        arNames(myCount) = FName
        FName = Dir
    Loop
    On Error Resume Next
    Worksheets("EveryOther").Range("J38").Resize(, myCount).Value = arNames
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Array</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>PassAnArray_To_A_Function</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Array</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>PassAnArray_To_A_Function</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub PassAnArray()
' Page 460
    Dim myArray() As Variant
    Dim myRegion As String
    
    myArray = Range("mySalesData")								'&lt;== This is named range: 3 columns, first is a string, then 2 columns of integers
    myRegion = InputBox("Enter Region - Central,East,West")
    MsgBox myRegion &amp; " Sales are: " &amp; Format(RegionSales(myArray, _			'&lt;== Here is the function receiving the array
        myRegion), "$#,#00.00 ")
End Sub

Function RegionSales(ByRef BigArray As Variant, sRegion As String) As Long
    Dim myCount As Integer
    
    RegionSales = 0
    For myCount = LBound(BigArray) To UBound(BigArray)
        If BigArray(myCount, 1) = sRegion Then
            RegionSales = BigArray(myCount, 4) * BigArray(myCount, 3) + RegionSales
        End If
    Next myCount
End Function
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Array</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Populate_Range_From_Array</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Array</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Populate_Range_From_Array</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub ColumnHeaders()
    ' Page 455
    Dim myArray As Variant
    Dim myCount As Integer
    ' Fill the array
    myArray = Array("Name", "Address", "Phone", "Email")
    ' Empty the array
    With Worksheets("Fill An Array")
        For myCount = 1 To UBound(myArray)
            .Cells(1, myCount).Value = myArray(myCount)
        Next myCount
    End With
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Array</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Read_2Columns_16Rows_GetAverage_PlaceIn_3rd_Columns</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Array</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Read_2Columns_16Rows_GetAverage_PlaceIn_3rd_Columns</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Base 1




Sub QuickFillAverage()
    ' Page 457
    Dim myArray As Variant
    Dim myCount As Integer
    
    myArray = Worksheets("EveryOther").Range("B2:C17")		'Fills a Matrix (1 to 16, 1 to 2)
    For myCount = LBound(myArray) To UBound(myArray)		'=LBound and UBound are on the first dimension
        Worksheets("EveryOther").Cells(myCount + 1, 5).Value = _
            WorksheetFunction.Average(myArray(myCount, 1), myArray(myCount, 2))	'For Column 1 and 2
    Next myCount
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Array</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>reDim</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Array</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>reDim</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Sub MySheets()
    ' requires Option Base 1
    Dim myArray() As String
    Dim myCount As Integer, NumShts As Integer
    
    NumShts = ActiveWorkbook.Worksheets.Count
    ' Size the array
    ReDim myArray(1 To NumShts)
    For myCount = 1 To NumShts
        myArray(myCount) = ActiveWorkbook.Sheets(myCount).Name
    Next myCount
    Worksheets("EveryOther").Range("J33").Resize(, NumShts).Value = myArray
    
End Sub


'Look For all the Excel Files in a Directory

Sub XLFiles()
    ' Page 459 - at bottom
    Dim FName As String
    Dim arNames() As String
    Dim myCount As Integer
    
    FName = Dir(ThisWorkbook.Path &amp; "\*.xls*")
    Do Until FName = ""
        myCount = myCount + 1
        ReDim Preserve arNames(1 To myCount)
        arNames(myCount) = FName
        FName = Dir
    Loop
    On Error Resume Next
    Worksheets("EveryOther").Range("J38").Resize(, myCount).Value = arNames
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_BetweenWorkBooks</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>UserForm_ToBrowseToExcelWorkBook_ListSheets_ThenCopyBackToThisWB</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_BetweenWorkBooks</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>UserForm_ToBrowseToExcelWorkBook_ListSheets_ThenCopyBackToThisWB</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>1] UserForm:

Button: cmd_SelectAWorkbook
ComboBox: cmb_WorkSheetList
Button: cmd_CopySheetToThisWorkBook
Button: cmd_Close


//////////////////////////


Option Explicit
Private m_sWorkBookName As String
Private m_wbSource As Workbook

Private Sub cmd_Close_Click()
    Me.Hide
End Sub


Private Sub cmd_CopySheetToThisWorkBook_Click()

    Dim sSheetName As String
    sSheetName = Me.cmb_WorkSheetList.Text
    
    If Len(Trim(sSheetName)) &lt; 1 Then
        MsgBox ("First Pick a WorkSheet from the drop-down BEFORE attempting to copy it")
    Else
    
        m_wbSource.Sheets(sSheetName).Copy Before:=ThisWorkbook.Sheets(1)
    
        ThisWorkbook.Sheets(1).Name = "ORIG"

        m_wbSource.Close SaveChanges:=False
        
    End If
    
    
End Sub

Private Sub cmd_SelectAWorkbook_Click()

    Dim sWorkBookName As String

    Dim i_m_wbSource_SheetCounter
        
    m_sWorkBookName = Application.GetOpenFilename(Filefilter:="Excel (NEW) (*.xlsx),*.xlsx,Excel (OLD) (*.xls),*.xls")

    If m_sWorkBookName = "False" Then
        MsgBox "Nothing Chosen"
    Else
    
        Set m_wbSource = Workbooks.Open(m_sWorkBookName)
'        ActiveWindow.Visible = False

        
        Me.cmb_WorkSheetList.Clear
        
        For i_m_wbSource_SheetCounter = 0 To m_wbSource.Sheets.Count - 1
            Me.cmb_WorkSheetList.AddItem m_wbSource.Sheets(i_m_wbSource_SheetCounter + 1).Name
        Next i_m_wbSource_SheetCounter

    End If
    
End Sub


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>AssignTwoSeries_To_BarGraph_UsingRowColumnNumbers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>AssignTwoSeries_To_BarGraph_UsingRowColumnNumbers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Dim sc As SeriesCollection
Dim i as Long, j as Long

j = 1

For i = 1 To ActiveChart.SeriesCollection.Count
    ActiveChart.SeriesCollection(i).Values = "=Sheet1!R8C" &amp; j &amp; ":R12C" &amp; j
    j = j + 2 '&lt;~~ Adding 2 for Col C
Next</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>BarGraph</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>BarGraph</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>///////////////////////////////////////////////////////////////////////////////////////////
'Invoke the sub:

Private m_sNameOfOutPutWorkSheet_1 As String


	m_sNameOfOutPutWorkSheet_1 = "Dashboard_1"
	
    Dim rngOfChart As Range
    Set rngOfChart = Range(Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(9, 1), Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(17, 12))


    Dim rngYValues As Range
    Set rngYValues = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 3), Worksheets("DataToGraph_Quarterly").Cells(6, 3))

    Dim rngXNames As Range
    Set rngXNames = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 1), Worksheets("DataToGraph_Quarterly").Cells(6, 1))

    CreateABarGraphChart Worksheets(m_sNameOfOutPutWorkSheet_1), rngOfChart, "M2", "Metric # 2", rngYValues, rngXNames
    
///////////////////////////////////////////////////////////////////////////////////////////    


//////////////////////////////////////////

Sub CreateABarGraphChart(wsX As Worksheet, rngOfChart As Range, sChartName As String, sChartTitle As String, rngYValues As Range, rngXNames As Range)
    'rngOfChart is the Range of cells where you want the graph to be located
    
    On Error GoTo ErrorHandler
    
    '=========================
    
    wsX.Shapes.AddChart(xlBar, _
                        Left:=rngOfChart.Left, _
                        Top:=rngOfChart.Top, _
                        Width:=rngOfChart.Width, _
                        Height:=rngOfChart.Height).Select

    ActiveChart.Parent.Name = sChartName
    
    
    ActiveChart.SeriesCollection.NewSeries
    ActiveChart.SeriesCollection(1).Values = rngYValues
    '===============================================================================
    'Apparently it is grabbing some empty cells and turning them into series.
    '   e.g. for: "=DataToGraph_Quarterly!$C$2:$C$5", it creates 4 series, where the first and last are the good ones
    '        so I delete second, then do it again, leaving the original 1st and original 4th series
    Dim iNumberOfSeries As Integer
    iNumberOfSeries = ActiveChart.SeriesCollection.Count
    ActiveChart.SeriesCollection(2).Delete
    ActiveChart.SeriesCollection(2).Delete
    '===============================================================================
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Legend.Delete
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Axes(xlCategory).Select
    ActiveChart.ChartArea.Select
    ActiveChart.SeriesCollection(1).XValues = rngXNames '&lt;== These are the axis labels
    
      With ActiveChart
        .Axes(xlCategory).Select           '&lt;= Bottom Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
    
        
        
    
        .Axes(xlValue).Select           '&lt;= Left Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
    
    End With
    
    With wsX.ChartObjects(sChartName).Chart
        .HasTitle = True
        .ChartTitle.Text = sChartTitle
        .ChartTitle.Font.Size = 7
    End With
    
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number

            Case 0  'raised by subroutine
               
            Case Else
                MsgBox "CreateALineGraphChart - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LineGraph_GoodSub</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LineGraph_GoodSub</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
///////////////////////////////////////////////////////////////////////////////////////////
'Invoke the sub:

Private m_sNameOfOutPutWorkSheet_1 As String


	m_sNameOfOutPutWorkSheet_1 = "Dashboard_1"
	
    Dim rngOfChart As Range
    Set rngOfChart = Range(Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(9, 1), Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(17, 12))


    Dim rngYValues As Range
    Set rngYValues = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 3), Worksheets("DataToGraph_Quarterly").Cells(6, 3))

    Dim rngXNames As Range
    Set rngXNames = Range(Worksheets("DataToGraph_Quarterly").Cells(2, 1), Worksheets("DataToGraph_Quarterly").Cells(6, 1))

    CreateALineGraphChart Worksheets(m_sNameOfOutPutWorkSheet_1), rngOfChart, "M2", "Metric # 2", rngYValues, rngXNames
    
///////////////////////////////////////////////////////////////////////////////////////////    

Sub CreateALineGraphChart(wsX As Worksheet, rngOfChart As Range, sChartName As String, sChartTitle As String, rngYValues As Range, rngXNames As Range)    
      'rngOfChart is the Range of cells where you want the graph to be located
    
    On Error GoTo ErrorHandler
    
    '=========================
'    Dim chrtobjX As ChartObject
    
    wsX.Shapes.AddChart(xlLine, _
                        Left:=rngOfChart.Left, _
                        Top:=rngOfChart.Top, _
                        Width:=rngOfChart.Width, _
                        Height:=rngOfChart.Height).Select
                        
    ActiveChart.Parent.Name = sChartName
    
    
    ActiveChart.SeriesCollection.NewSeries
    ActiveChart.SeriesCollection(1).Values = rngYValues
    '===============================================================================
    'Apparently it is grabbing some empty cells and turning them into series.
    '   e.g. for: "=DataToGraph_Quarterly!$C$2:$C$5", it creates 4 series, where the first and last are the good ones
    '        so I delete second, then do it again, leaving the original 1st and original 4th series
    Dim iNumberOfSeries As Integer
    iNumberOfSeries = ActiveChart.SeriesCollection.Count
    ActiveChart.SeriesCollection(2).Delete
    ActiveChart.SeriesCollection(2).Delete
    '===============================================================================

    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Legend.Delete
'    ActiveChart.Legend.Select
'    Selection.Delete
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Axes(xlCategory).Select
    ActiveChart.ChartArea.Select
    ActiveChart.SeriesCollection(1).XValues = rngXNames
        
      With ActiveChart
        .Axes(xlCategory).Select           '&lt;= Bottom Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
   
        .Axes(xlValue).Select           '&lt;= Left Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
    
'        With .Parent                                '&lt;== To position the Chart
'            .Left = ActiveSheet.Cells(9, 1).Left
'            .Top = ActiveSheet.Cells(9, 1).Top
'        End With
    
    End With

    With wsX.ChartObjects(sChartName).Chart
        .HasTitle = True
        .ChartTitle.Text = sChartTitle
        .ChartTitle.Font.Size = 7
    End With
    
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number

            Case 0  'raised by subroutine
               
            Case Else
                MsgBox "CreateALineGraphChart - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub  
    
    
    
    
    
    
    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LineGraph_withGoal</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LineGraph_withGoal</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
////////////////Usage


'===================================================================================================================================
'   R2C3] M6
'    Dim rngOfChart As Range
    Set rngOfChart = Range(Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(20, 25), Worksheets(m_sNameOfOutPutWorkSheet_1).Cells(28, 34))

'    Dim rngYValues As Range
    Set rngYValues = Range(Worksheets("DataToGraph_Quarterly").Cells(m_iRowStartData, 7), Worksheets("DataToGraph_Quarterly").Cells(m_iRowEndData, 7))

    Dim rngYGoal As Range
    Set rngYGoal = Range(Worksheets("DataToGraph_Quarterly").Cells(m_iRowStartData, 16), Worksheets("DataToGraph_Quarterly").Cells(m_iRowEndData, 16))


'    Dim rngXNames As Range
    Set rngXNames = Range(Worksheets("DataToGraph_Quarterly").Cells(m_iRowStartData, 1), Worksheets("DataToGraph_Quarterly").Cells(m_iRowEndData, 1))

'    CreateALineGraphChart Worksheets(m_sNameOfOutPutWorkSheet_1), rngOfChart, "M6", m_sM6_Name, rngYValues, rngXNames
    CreateALineGraphChart_WithGoal Worksheets(m_sNameOfOutPutWorkSheet_1), rngOfChart, "M6", m_sM6_Name, rngYValues, rngXNames, rngYGoal
''===================================================================================================================================



////////////////////////////////////////////////////////////////////

Sub CreateALineGraphChart_WithGoal(wsX As Worksheet, rngOfChart As Range, sChartName As String, sChartTitle As String, rngYValues As Range, rngXNames As Range, rngYGoal As Range)
    'rngOfChart is the Range of cells where you want the graph to be located
    
    On Error GoTo ErrorHandler
    
    '=========================
   
    wsX.Shapes.AddChart(xlLine, _
                        Left:=rngOfChart.Left, _
                        Top:=rngOfChart.Top, _
                        Width:=rngOfChart.Width, _
                        Height:=rngOfChart.Height).Select
                        


     '\\\\\\
    ActiveChart.Parent.Name = sChartName
    
    
    ActiveChart.SeriesCollection.NewSeries
    ActiveChart.SeriesCollection(1).Values = rngYValues
    ActiveChart.SeriesCollection.NewSeries
    ActiveChart.SeriesCollection(2).Values = rngYGoal
    ActiveChart.SeriesCollection(2).Format.Line.ForeColor.RGB = vbRed
    '===============================================================================
    'Apparently it is grabbing some empty cells and turning them into series.
    '   e.g. for a values and Goal series it creates 5 series, where the first and second are the good ones
    '        so I delete the fifth, fourth and third series (this gets rid of empty space on the right side of the chart)
    Dim iNumberOfSeries As Integer
    iNumberOfSeries = ActiveChart.SeriesCollection.Count
    ActiveChart.SeriesCollection(5).Delete
    ActiveChart.SeriesCollection(4).Delete
    ActiveChart.SeriesCollection(3).Delete
    '===============================================================================
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Legend.Delete
    ActiveSheet.ChartObjects(sChartName).Activate
    ActiveChart.Axes(xlCategory).Select
    ActiveChart.ChartArea.Select
    ActiveChart.SeriesCollection(1).XValues = rngXNames
    
    With ActiveChart
        .Axes(xlCategory).Select           '&lt;= Bottom Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With

        .Axes(xlValue).Select           '&lt;= Left Axis of line graph
        With Selection.TickLabels.Font
            .Size = 7
            .Name = "Times New Roman"
        End With
    
        
    
    End With
    
    With wsX.ChartObjects(sChartName).Chart
        .HasTitle = True
        .ChartTitle.Text = sChartTitle
        .ChartTitle.Font.Size = 7
    End With
    
    '=========================
    Exit Sub
            
ErrorHandler:
        Select Case Err.Number

            Case 0  'raised by subroutine
               
            Case Else
                MsgBox "CreateALineGraphChart - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Specify_XValues_as_Array_or_String</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Specify_XValues_as_Array_or_String</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub try()
Dim label_values() As String
Dim individual_label_value As Variant
Dim counter As Long
Dim ChartObj As ChartObject
Dim ChartSeries As Series
  

'Get the number of lables that you will need to have for the chart Ex. say 7
ReDim label_values(4) As String
 counter = 1

For counter = 0 To 4
     label_values(counter) = "MySeries " &amp; counter + 1
Next counter


Set ChartObj = ActiveSheet.ChartObjects.Add(Left:=100, Width:=550, Top:=75, Height:=325)
Set ChartSeries = ChartObj.Chart.SeriesCollection.NewSeries

With ChartSeries
     .Name = "Chart Series 1"
     .Values = Array(1, 2, 3, 4, 5)
     .XValues = label_values
End With
End Sub


'There is a restriction on the maximum number of characters that can be added as .XValues in above code. 

'If you wanted to specify those values as static values using an Array, you’d end up having to restrict the number of lables you can accomodate in the chart. If you exceed this value, the application will throw the following error:

Run-time error '1004'
Unable to set the XValues Property of the Series Class </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CHART</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>VBA_EXCEL_CHART_Readme</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CHART</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>VBA_EXCEL_CHART_Readme</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>VBA_EXCEL_CHART_Readme


////////////////////////////////////////////////////////////
'Referencing a chart using index:

dim sChartName As String 
sChartName = "whatever"

wsX.Shapes.AddChart(xlLine, _
                    Left:=rngOfChart.Left, _
                    Top:=rngOfChart.Top, _
                    Width:=rngOfChart.Width, _
                    Height:=rngOfChart.Height).Select

ActiveChart.Parent.Name = sChartName


dim sChartTitle As String
wsX.ChartObjects(sChartName).Chart.ChartTitle.HasTitle = True
wsX.ChartObjects(sChartName).Chart.ChartTitle.Text = sChartTitle

///////////////////////////////////////////////////////////


'Referencing a chart using name:

wsX.ChartObjects(1).Chart.HasTitle = True
wsX.ChartObjects(1).Chart.ChartTitle.Text = sChartTitle

/////////////// Series and SeriesColletion //////////////////////////////////////////////
'when you use and index with a SeriesCollection object it becomes a Series object
' So:
ActiveChart.SeriesCollection(2) 'is in fact a 'Series' object

/////////////SeriesCollection Object Members///////////////////////////////////////////////
Methods

  Name Description 
 Add -	Adds one or more new series to the SeriesCollection collection. 
 Extend -	Adds new data points to an existing series collection. 
 Item -	Returns a single object from a collection. 
 NewSeries -	Creates a new series. Returns a Series object that represents the new series. 
 Paste -	Pastes data from the Clipboard into the specified series collection. 

Properties

  Name Description 
 Application-	 When used without an object qualifier, this Property returns an Application object that represents the Microsoft Excel application. When used with an object qualifier, this property returns an Application object that represents the creator of the specified object (you can use this property with an OLE Automation object to return the application of that object). Read-only. 
 Count -	Returns a Long value that represents the number of objects in the collection. 
 Creator -	Returns a 32-bit integer that indicates the application in which this object was created. Read-only Long. 
 Parent -	Returns the parent object for the specified object. Read-only. 

/////////////Series Object Members///////////////////////////////////////////////

Methods

  Name Description 
 ApplyDataLabels -	Applies data labels to a series. 
 ClearFormats -	 Clears the formatting of the object. 
 Copy -	 If the series has a picture fill, then this method copies the picture to the Clipboard. 
 DataLabels -	 Returns an object that represents either a single data label (a DataLabel object) or a collection of all the data labels for the series (a DataLabels collection). 
 Delete -	 Deletes the object. 
 ErrorBar -	 Applies error bars to the series. Variant. 
 Paste -	 Pastes a picture from the Clipboard as the marker on the selected series. 
 Points -	 Returns an object that represents a single point (a Point object) or a collection of all the points (a Points collection) in the series. Read-only 
 Select -	 Selects the object. 
 Trendlines -	 Returns an object that represents a single trendline (a Trendline object) or a collection of all the trendlines (a Trendlines collection) for the series. 

Properties

  Name Description 
 Application -	 When used without an object qualifier, this property returns an Application object that represents the Microsoft Excel application. When used with an object qualifier, this property returns an Application object that represents the creator of the specified object (you can use this property with an OLE Automation object to return the application of that object). Read-only. 
 ApplyPictToEnd -	 True if a picture is applied to the end of the point or all points in the series. Read/write Boolean. 
 ApplyPictToFront -	 True if a picture is applied to the front of the point or all points in the series. Read/write Boolean. 
 ApplyPictToSides -	 True if a picture is applied to the sides of the point or all points in the series. Read/write Boolean. 
 AxisGroup -	 Returns or sets the group for the specified series. Read/write 
 BarShape -	 Returns or sets the shape used with the 3-D bar or column chart. Read/write XlBarShape. 
 BubbleSizes -	 Returns or sets a string that refers to the worksheet cells containing the x-value, y-value and size data for the bubble chart. When you return the cell reference, it will return a string describing the cells in A1-style notation. To set the size data for the bubble chart, you must use R1C1-style notation. Applies only to bubble charts. Read/write Variant. 
 ChartType -	 Returns or sets the chart type. Read/write XlChartType. 
 Creator -	 Returns a 32-bit integer that indicates the application in which this object was created. Read-only Long. 
 ErrorBars -	 Returns an ErrorBars object that represents the error bars for the series. Read-only. 
 Explosion -	 Returns or sets the explosion value for a pie-chart or doughnut-chart slice. Returns 0 (zero) if there's no explosion (the tip of the slice is in the center of the pie). Read/write Long. 
 Format -	 Returns the ChartFormat object. Read-only. 
 Formula -	 Returns or sets a String value that represents the object's formula in A1-style notation and in the language of the macro. 
 FormulaLocal -	 Returns or sets the formula for the object, using A1-style references in the language of the user. Read/write String. 
 FormulaR1C1 -	 Returns or sets the formula for the object, using R1C1-style notation in the language of the macro. Read/write String. 
 FormulaR1C1Local -	 Returns or sets the formula for the object, using R1C1-style notation in the language of the user. Read/write String. 
 Has3DEffect -	 True if the series has a three-dimensional appearance. Read/write Boolean. 
 HasDataLabels -	 True if the series has data labels. Read/write Boolean. 
 HasErrorBars -	 True if the series has error bars. This property isn’t available for 3-D charts. Read/write Boolean. 
 HasLeaderLines -	 True if the series has leader lines. Read/write Boolean. 
 InvertColor -	 Returns or sets the fill color for negative data points in a series. Read/write 
 InvertColorIndex -	 Returns or sets the fill color for negative data points in a series. Read/write 
 InvertIfNegative -	 True if Microsoft Excel inverts the pattern in the item when it corresponds to a negative number. Read/write Boolean. 
 LeaderLines -	 Returns a LeaderLines object that represents the leader lines for the series. Read-only. 
 MarkerBackgroundColor -	 Sets the marker background color as an RGB value or returns the corresponding color index value. Applies only to line, scatter, and radar charts. Read/write Long. 
 MarkerBackgroundColorIndex -	 Returns or sets the marker background color as an index into the current color palette, or as one of the following XlColorIndex constants: xlColorIndexAutomatic or xlColorIndexNone. Applies only to line, scatter, and radar charts. Read/write Long. 
 MarkerForegroundColor -	 Sets the marker foreground color as an RGB value or returns the corresponding color index value. Applies only to line, scatter, and radar charts. Read/write Long. 
 MarkerForegroundColorIndex -	 Returns or sets the marker foreground color as an index into the current color palette, or as one of the following XlColorIndex constants: xlColorIndexAutomatic or xlColorIndexNone. Applies only to line, scatter, and radar charts. Read/write Long. 
 MarkerSize -	 Returns or sets the data-marker size, in points (point: Unit of measure referring to the height of a printed character. A point equals 1/72 of an inch, or approximately 1/28 of a centimeter.). Can be a value from 2 through 72. Read/write Long. 
 MarkerStyle -	 Returns or sets the marker style for a point or series in a line chart, scatter chart, or radar chart. Read/write XlMarkerStyle. 
 Name -	 Returns or sets a String value representing the name of the object. 
 Parent -	 Returns the parent object for the specified object. Read-only. 
 PictureType -	 Returns or sets a XlChartPictureType value that represents the way pictures are displayed on a column or bar picture chart. 
 PictureUnit2 -	 Returns or sets the unit for each picture on the chart if the PictureType property is set to xlStackScale (if not, this property is ignored). Read/write Double. 
 PlotColorIndex -	 Returns an index value that is used internally to associate series formatting with chart elements. Read-only 
 PlotOrder -	 Returns or sets the plot order for the selected series within the chart group. Read/write Long. 
 Shadow -	 Returns or sets a Boolean value that determines if the object has a shadow. 
 Smooth -	 True if curve smoothing is turned on for the line chart or scatter chart. Applies only to line and scatter charts. Read/write. 
 Type -	 Returns or sets a Long value that represents the series type. 
 Values -	 Returns or sets a Variant value that represents a collection of all the values in the series. 
 XValues -	 Returns or sets an array of x values for a chart series. The XValues property can be set to a range on a worksheet or to an array of values, but it cannot be a combination of both. Read/write Variant. 



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Classes_Records_Collections</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Create_and_Use_Object</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Classes_Records_Collections</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Create_and_Use_Object</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1]  clsEmployee
'2]  clsEmployees
'3]   Module3



///////////// DATA in cells ////////////
Tracy	1651	25	45
Bill	1509	25	50
////////////////////////////////////////


'1]  clsEmployee
//////////////clsEmployee//////////////////////////
' Page 499
Public EmpName As String
Public EmpID As String
Public EmpRate As Double
Private NormalHrs As Double
Private OverHrs As Double

Property Let EmpWeeklyHrs(Hrs As Double)
    NormalHrs = WorksheetFunction.Min(40, Hrs)
    OverHrs = WorksheetFunction.Max(0, Hrs - 40)
End Property

' Page 500
Property Get EmpWeeklyHrs() As Double
    EmpWeeklyHrs = NormalHrs + OverHrs
End Property

Property Get EmpNormalHrs() As Double
    EmpNormalHrs = NormalHrs
End Property

Property Get EmpOverTimeHrs() As Double
    EmpOverTimeHrs = OverHrs
End Property

Public Function EmpWeeklyPay() As Double
    EmpWeeklyPay = (EmpNormalHrs * EmpRate) + (EmpOverTimeHrs * EmpRate * 1.5)
End Function

/////////////////////////////////////////////////


'2]  clsEmployees
//////////////clsEmployee//////////////////////////
Private AllEmployees As New Collection							'&lt;== has built-in methods: Add, Remove, Count and Item

'...
Public Sub Add(recEmployee As clsEmployee)
    AllEmployees.Add recEmployee, recEmployee.EmpID				'&lt;== Note use of optional parm for built-in Collection Method
End Sub

' Page 503
Public Property Get Count() As Long
    Count = AllEmployees.Count
End Property

'...
Public Property Get Items() As Collection
    Set Items = AllEmployees
End Property

'...
Public Property Get Item(myItem As Variant) As clsEmployee
    Set Item = AllEmployees(myItem)
End Property

'...
Public Sub Remove(myItem As Variant)
    AllEmployees.Remove myItem
End Sub

//////////////////////////////////////////////////////


'2]  Module3
//////////////Module3//////////////////////////
' Page 504
Sub EmpAddCollection()
    Dim colEmployees As New clsEmployees			'&lt;== declare it as a class that has a Collection of Employee Record Objects
    Dim recEmployee As New clsEmployee				'&lt;== Employee Record object
    Dim LastRow As Integer, myCount As Integer
    Dim EmpArray As Variant							'&lt;== Array of Employee

    LastRow = ActiveSheet.Cells(ActiveSheet.Rows.Count, 1).End(xlUp).Row
    EmpArray = ActiveSheet.Range(Cells(1, 1), Cells(LastRow, 4))

    For myCount = 1 To UBound(EmpArray)
    Set recEmployee = New clsEmployee
    
        With recEmployee
            .EmpName = EmpArray(myCount, 1)
            .EmpID = EmpArray(myCount, 2)
            .EmpRate = EmpArray(myCount, 3)
            .EmpWeeklyHrs = EmpArray(myCount, 4)
        End With
        colEmployees.Add recEmployee											'&lt;== Use 'Add' method 
    Next myCount

    MsgBox "Number of Employees:" &amp; colEmployees.Count &amp; Chr(10) &amp; _
        "Employee(1) Name:" &amp; colEmployees.Item(1).EmpName							'&lt;== Here it uses an integer

    MsgBox "Tracy's Weekly Pay: $" &amp; colEmployees.Item("1651").EmpWeeklyPay			'&lt;== NOTE: uses 'Item' for the ID string
    
    For Each recEmployee In colEmployees.Items
        recEmployee.EmpRate = recEmployee.EmpRate * 1.5
    Next recEmployee
    MsgBox "Tracy's Weekly Pay (after Bonus): $" &amp; colEmployees.Item("1651"). _		'&lt;== Call a particular record by it's ID
        EmpWeeklyPay
End Sub


/////////////////////////////////////////////////</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Classes_Records_Collections</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Fill_ListBox_With_UniqueItems_FromA_Collection</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Classes_Records_Collections</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Fill_ListBox_With_UniqueItems_FromA_Collection</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'From: http://j-walk.com/ss/Excel/tips/tip47.htm
'When you display a list of items in a ListBox,
'you generally don't want to show duplicate items.
'This tip describes a clever way of filling a UserForm with unique items from a list.
'This technique is adapted from a tip by J.G. Hussey, published in Visual Basic Programmer's Journal.
'How it works
'
'This tip uses a Collection object,
'and relies on the fact that VBA generates an error if you attempt to add an item
'to a collection when the item already exists in the collection.
'The trick is to build the collection by adding all items to it,
'and ignore the errors that may occur. The result is a collection of unduplicated items.
'Example
'
'The items (105 of them) are stored in Column A of a worksheet.
'Many of these items are duplicated.
'The RemoveDuplicates subroutine,
'listed below, builds a collection that consists of the unique items in the list.
'It then transfers the items to a ListBox on a UserForm.



Option Explicit
'   This example is based on a tip by J.G. Hussey,
'   published in "Visual Basic Programmer's Journal"

Sub RemoveDuplicates()
    Dim AllCells As Range, Cell As Range
    Dim NoDupes As New Collection
    Dim i As Integer, j As Integer
    Dim Swap1, Swap2, Item
    
'   The items are in A1:A105
    Set AllCells = Range("A1:A105")
    
'   The next statement ignores the error caused
'   by attempting to add a duplicate key to the collection.
'   The duplicate is not added - which is just what we want!
    On Error Resume Next
    For Each Cell In AllCells
        NoDupes.Add Cell.Value, CStr(Cell.Value)
'       Note: the 2nd argument (key) for the Add method must be a string
    Next Cell

'   Resume normal error handling
    On Error GoTo 0

'   Sort the collection (optional)
    For i = 1 To NoDupes.Count - 1
        For j = i + 1 To NoDupes.Count
            If NoDupes(i) &gt; NoDupes(j) Then
                Swap1 = NoDupes(i)
                Swap2 = NoDupes(j)
                NoDupes.Add Swap1, before:=j
                NoDupes.Add Swap2, before:=i
                NoDupes.Remove i + 1
                NoDupes.Remove j + 1
            End If
        Next j
    Next i
    
'   Add the sorted, non-duplicated items to a ListBox
    For Each Item In NoDupes
        UserForm1.ListBox1.AddItem Item
    Next Item

'   Show the UserForm
    UserForm1.Show
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Classes_Records_Collections</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Use_UDT_To_ProcessColumnsOfData</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Classes_Records_Collections</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Use_UDT_To_ProcessColumnsOfData</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1] Button to call the UDTMain sub
'2] Module with the sub that does the work



///////// DATA Sample //////////////////
Store #	Style Number	Retail Price	Unit Sold	Unit On Hand
Store 340001	00012	8	0	1
Store 340001	00013	38	0	1
Store 340001	00016	38	0	1
Store 340001	0001M	1	0	1
Store 340001	00023	36	7	11
Store 340001	00025	36	0	1
Store 340001	00026	36	0	0
Store 340001	00027	36	6	11
Store 340001	00052	12.25	0	1
Store 340001	00053	27	9	5
Store 340001	00070	31	2	2
Store 340001	0008M	50	0	1
Store 340001	06089	18.25	0	1
Store 340002	00012	8	0	1
Store 340002	00013	38	0	1
Store 340002	00016	38	0	0
Store 340002	0001M	1	0	0
Store 340002	00023	36	2	3
Store 340002	00025	36	0	1
Store 340002	00026	36	0	1
Store 340002	00027	36	6	11
Store 340002	00052	12.25	0	0
Store 340002	00053	27	5	5
Store 340002	00070	31	4	5
Store 340002	0008M	50	0	1
Store 340002	00090	43	3	4
Store 340002	00113	40	0	0

////////////////////////////////////////////
'NOTE: the Main routine stores the data in an Outer Array {Stores}, and an inner Array {Styles}
Stores[ 
		(34001, Styles(
						00012,
						00013,
						00016,
						...
					   )
	    ), 
		(34002, Styles(
						00012,
						00013,
						00016,
						...
					   )
	    ),  
		....
	   ]


'1] Button to call the UDTMain sub
/////////////////////////////////////
Private Sub CommandButton1_Click()
    UDTMain
End Sub
/////////////////////////////////////




'2] Module with the sub that does the work
//////////////////////////////////////////////////////////////////////////


' Page 507
Public type Style
    StyleName As String
    Price As Single
    UnitsSold As Long
    UnitsOnHand As Long
End Type

'...
Public type Store
    Name As String
    Styles() As Style
End Type

' Page 507
Sub UDTMain()
    Dim FinalRow As Long
    Dim ThisRow As Long
    Dim ThisStore As Long
    Dim CurrRow As Long
    Dim TotalDollarsSold As Long
    Dim TotalUnitsSold As Long
    Dim TotalDollarsOnHand As Long
    Dim TotalUnitsOnHand As Long
    Dim ThisStyle As Long
    Dim StoreName As String
    
    ReDim Stores(0 To 0) As Store ' The UDT is declared

    FinalRow = Cells(Rows.Count, 1).End(xlUp).Row
    ' The following For loop fills both arrays. The outer array is filled with the
    ' store name and an array consisting of product details.
    ' To accomplish this, the store name is tracked and when it changes,
    ' the outer array is expanded.
    ' The inner array for each outer array expands with each new product
    For ThisRow = 2 To FinalRow
        StoreName = Range("A" &amp; ThisRow).Value
        ' Checks whether this is the first entry in the outer array
        If LBound(Stores) = 0 Then
            ThisStore = 1                                                       '&lt;==  Assign This store if first 
            ReDim Stores(1 To 1) As Store										'&lt;== Expands outer array
            Stores(1).Name = StoreName
            ReDim Stores(1).Styles(0 To 0) As Style								'&lt;== Creates inner Array for first element of outer array
        Else
            For ThisStore = LBound(Stores) To UBound(Stores)					'&lt;== This For loop either keeps ThisStore equal to what it was,  
                If Stores(ThisStore).Name = StoreName Then Exit For				'		of if the name has changed, bumps it up by 1 as it leaves the loop
            Next ThisStore
            If ThisStore &gt; UBound(Stores) Then											'&lt;== Now either ThisStore is unchanged b/c the name has not changed, or
                ReDim Preserve Stores(LBound(Stores) To UBound(Stores) + 1) As Store	'	 it is greater than the previous UBound, in that case
                Stores(ThisStore).Name = StoreName										' 	 the array is bumped up in size, and a new name is stored in: .Name
                ReDim Stores(ThisStore).Styles(0 To 0) As Style                         '    and then it Creates inner Array for new element of outer array
            End If
        End If
        With Stores(ThisStore)
            If LBound(.Styles) = 0 Then												    '&lt;== if Brand new, it makes it Base 1, but does NOT resize it
                ReDim .Styles(1 To 1) As Style
            Else
                ReDim Preserve .Styles(LBound(.Styles) To _								 '&lt;== if NOT Brand new, it does resize it							'
                    UBound(.Styles) + 1) As Style
            End If
            With .Styles(UBound(.Styles))												'&lt;== now it Populates it from the columns: B:E
                .StyleName = Range("B" &amp; ThisRow).Value
                .Price = Range("C" &amp; ThisRow).Value
                .UnitsSold = Range("D" &amp; ThisRow).Value
                .UnitsOnHand = Range("E" &amp; ThisRow).Value
            End With
        End With
    Next ThisRow

    ' Create a report on a new sheet
    Sheets.Add
    Range("A1:E1").Value = Array("Store Name", "Units Sold", _
        "Dollars Sold", "Units On Hand", "Dollars On Hand")
    CurrRow = 2
    For ThisStore = LBound(Stores) To UBound(Stores)
        With Stores(ThisStore)
            TotalDollarsSold = 0
            TotalUnitsSold = 0
            TotalDollarsOnHand = 0
            TotalUnitsOnHand = 0
            ' Go through the array of product styles within the array
            ' of stores to summarize information
            For ThisStyle = LBound(.Styles) To UBound(.Styles)
                With .Styles(ThisStyle)
                    TotalDollarsSold = TotalDollarsSold + .UnitsSold * .Price
                    TotalUnitsSold = TotalUnitsSold + .UnitsSold
                    TotalDollarsOnHand = TotalDollarsOnHand + .UnitsOnHand * .Price
                    TotalUnitsOnHand = TotalUnitsOnHand + .UnitsOnHand
                End With
            Next ThisStyle
            'AFTER all the styles for the Store, print the sums
            Range("A" &amp; CurrRow &amp; ":E" &amp; CurrRow).Value = _
                Array(.Name, TotalUnitsSold, TotalDollarsSold, _
                TotalUnitsOnHand, TotalDollarsOnHand)
        End With
        'INCREMENT the counter
        CurrRow = CurrRow + 1
    Next ThisStore
End Sub



//////////////////////////////////////////////////////////////////////////</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Collections_and_Dictionary</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Using_ClassObject_with_Dictionary_vs_Collection</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Collections_and_Dictionary</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Using_ClassObject_with_Dictionary_vs_Collection</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit


'Using a dictionary:
Dim Dict As Dictionary 'set reference to Microsoft Scripting Runtime
'Dim Dict As Object 'to use late-binding (no reference)
Sub nals14exampleDictionary()
    Dim aBook As CBooks

    Set Dict = New Dictionary ' CreateObject("scripting.dictionary")
    
    Set aBook = New CBooks
    aBook.Name = "nals14 example"
    aBook.Author = "mvidas"
    aBook.Publisher = "vbaexpress.com"
    Dict.Add aBook.Name, aBook '(Key, Item)
    
    Set aBook = New CBooks
    aBook.Name = "nals14 example number 2"
    aBook.Author = "mvidas"
    aBook.Publisher = "vbaexpress.com"
    Dict.Add aBook.Name, aBook

'until you destroy the Dict variable or RemoveAll, it can now be used anywhere
End Sub

'VARIOUS ARTICLES SAY THIS DOESN'T WORK????
'Using a collection:Option Explicit
Dim Coll As Collection

Sub nals14exampleDictionary()
    Dim aBook As CBooks
    
    Set Coll = New Collection
    
    Set aBook = New CBooks
    aBook.Name = "nals14 example"
    aBook.Author = "mvidas"
    aBook.Publisher = "vbaexpress.com"
    Coll.Add aBook '(Item, [Key], [Before], [After])
    
    Set aBook = New CBooks
    aBook.Name = "nals14 example number 2"
    aBook.Author = "mvidas"
    aBook.Publisher = "vbaexpress.com"
    Coll.Add aBook

'Coll now contains all books entered
End Sub


'For the Key argument of the dict.add, make that the field you want to sort by. You can later put the Dict.Keys into an array and sort that, then use something like:
For i = 0 To Dict.Count - 1
    'Dict(SortedKeyArray(i)) now refers to the variable of your class
Next 'i</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Comments</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ListComments_PutThemOnA_NewWorkBook</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Comments</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ListComments_PutThemOnA_NewWorkBook</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Sub ListComments()
    ' Page 337-339
    Dim wb As Workbook
    Dim ws As Worksheet
    
    Dim cmt As Comment
    
    Dim cmtCount As Long
    
    cmtCount = 2
    
    On Error Resume Next
        Set ws = ActiveSheet
            If ws Is Nothing Then Exit Sub
    On Error GoTo 0
    
    Application.ScreenUpdating = False
    
    Set wb = Workbooks.Add(xlWorksheet)
    
    With wb.Sheets(1)
        .Range("$A$1") = "Author"
        .Range("$B$1") = "Book"
        .Range("$C$1") = "Sheet"
        .Range("$D$1") = "Range"
        .Range("$E$1") = "Comment"
    End With
    
    For Each cmt In ws.Comments
        With wb.Sheets(1)
            .Cells(cmtCount, 1) = cmt.author
            .Cells(cmtCount, 2) = cmt.Parent.Parent.Parent.Name
            .Cells(cmtCount, 3) = cmt.Parent.Parent.Name
            .Cells(cmtCount, 4) = cmt.Parent.Address
            .Cells(cmtCount, 5) = CleanComment(cmt.author, cmt.Text)
        End With
    
        cmtCount = cmtCount + 1
    Next
    
    wb.Sheets(1).UsedRange.WrapText = False
    
    Application.ScreenUpdating = True

    Set ws = Nothing
    Set wb = Nothing
End Sub


Private Function CleanComment(author As String, cmt As String) As String
    Dim tmp As String
    
    tmp = Application.WorksheetFunction.Substitute(cmt, author &amp; ":", "")
    tmp = Application.WorksheetFunction.Substitute(tmp, Chr(10), "")
    
    CleanComment = tmp
End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Conditional_Formatting</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ApplyConditionalFormat_To_Range_with_2_ConditionalFormats</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Conditional_Formatting</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ApplyConditionalFormat_To_Range_with_2_ConditionalFormats</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://stackoverflow.com/questions/13661965/conditional-formatting-using-excel-vba-code

they noted some problems
'I have Range object called DistinationRange which contains reference to range B3:H63

'I want to apply following two conditional formatting using Excel VBA code dynamically. (Because the range would not be same all the time)

'If Cell column D is blank, no formatting should be applied (Need to use Stop If True there)
'If Value in Cell of column E is lesser than value in cell of column F, that whole row should have green background.

Sub setCondFormat()
    Range("B3").Select
    With Range("B3:H63")
        .FormatConditions.Add Type:=xlExpression, Formula1:= _
          "=IF($D3="""",FALSE,IF($F3&gt;=$E3,TRUE,FALSE))"
        With .FormatConditions(.FormatConditions.Count)
            .SetFirstPriority
            With .Interior
                .PatternColorIndex = xlAutomatic
                .Color = 5287936
                .TintAndShade = 0
            End With
        End With
    End With
End Sub

'Replacing "A1:D5" with "DestinationRange" would sort out the dynamic nature of the initial range

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Conditional_Formatting</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>DeleteConditionalFormatting_Then_Add_ConditionalFormatting</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Conditional_Formatting</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>DeleteConditionalFormatting_Then_Add_ConditionalFormatting</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://www.mrexcel.com/forum/excel-questions/522196-conditional-formatting-excel-visual-basic-applications.html

Sub PLConditionalFormatting()
    Cells.FormatConditions.Delete
 
    With Columns("F:L")
        .FormatConditions.Add Type:=xlExpression, Formula1:= _
            "=B1=0"
        With .FormatConditions(.FormatConditions.Count)
            .SetFirstPriority
            With .Font
                .ThemeColor = xlThemeColorDark1
                .TintAndShade = 0
            End With
            .StopIfTrue = False
        End With
    End With
 
    With Columns("L:L")
        .FormatConditions.Add Type:=xlExpression, Formula1:= _
            "=A1=0"
        With .FormatConditions(.FormatConditions.Count)
            .SetFirstPriority
            With .Interior
                .PatternColorIndex = xlAutomatic
                .Color = 65535
                .TintAndShade = 0
            End With
            .StopIfTrue = False
        End With
    End With
 

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_CustomObject_With_Dictionary_asAProperty</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>StoreDictionaryInCustomObject_ReadWorksheetData_HoldInMatrix</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_CustomObject_With_Dictionary_asAProperty</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>StoreDictionaryInCustomObject_ReadWorksheetData_HoldInMatrix</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1] Mod_Two					'Second Button: Process the Data (i.e. runs sub: "Two_Main")  &lt;== This holds the controlling sub: Two_Main
'2] Mod_General				'General Subs
'3] Mod_Functions	 		'Used by Main
'4] Mod_One(NOT INCLUDED)	'First Button: Get Original Data (Choose File, then choose Sheet 
'5] c_R1_Record				'Class that defines the Highest Level Record
'6] c_R2_Record				'Class that defines the next-Highest Level Record
'This example only focuses on the first two levels
////////////////////////////////////////////////
'The sub 'Build_Output_Array' is the one that:
'a) Creates the local level dictionaries to populate into the Custom Objects (i.e. oR1_record and oR2_record)    
	Dim oR1_record As New c_R1_record
    Dim oR2_record As New c_R2_Record
'b) Then those are stored in form module level object:  m_dict_OUTPUTs   
	Private m_dict_OUTPUTs As Scripting.Dictionary		

///////////DATA on sheet: R2_to_R1_Mapping//////////////////////////////

	R1(i) ==&gt;					1		2
R2(i)							Revenue	Expenses
1	Per Member Per Month (PMPM)	1	
2	Grant and Other Revenue		1	
3	Salary and Benefits					1
4	Operations							1
5	Support to Others					1
6	Reserve Spending					1

//////////////////////////////////////////




//////////////1] Mod_Two/////////////////
Option Explicit
Option Base 0

Private m_l_R2_to_R1_Max_Column As Long 'Column where the last cell is located (right side) of:  R2_to_R1
Private m_l_R2_to_R1_Max_Row As Long    'Row where the last cell is located (bottom) of:  R2_to_R1
Private m_l_R3_to_R2_Max_Column As Long 'Column where the last cell is located (right side) of:  R3_to_R2
Private m_l_R3_to_R2_Max_Row As Long    'Row where the last cell is located (bottom) of: R3_to_R2
Private m_l_IN_to_R3_Max_Column As Long 'Column where the last cell is located (right side) of:  IN_to_R3
Private m_l_IN_to_R3_Max_Row As Long    'Row where the last cell is located (bottom) of: IN_to_R3

Private m_arrMAP_R2_to_R1() As Variant       'Matrix Mapping the data from:  R2_to_R1
Private m_arMAP_R3_to_R2() As Variant       'Matrix Mapping the data from:  R3_to_R2
Private m_arrMAP_IN_to_R3() As Variant       'Matrix Mapping the data from:  IN_to_R3

'Requires REFERENCE: Microsoft Scripting Runtime

Private m_dict_OUTPUTs As Scripting.Dictionary     'This is the Output Data, with the 'R1_PK' as the key
'Dictionary Key:    IN_PK   As Integer             'This is the key that ties the levels together, from the Mapping table

'==============================================================================



Sub Two_Main()
    On Error GoTo ErrorHandler
    
    '=========================
    GetTheMatrixSizes
    PopulateTheMappingMatrix "R2_to_R1_Mapping", m_l_R2_to_R1_Max_Row, m_l_R2_to_R1_Max_Column, m_arrMAP_R2_to_R1
    mod_General.PutArrayOnWorkSheet m_arrMAP_R2_to_R1, "Junk", 1, 1
    PopulateTheMappingMatrix "R3_to_R2_Mapping", m_l_R3_to_R2_Max_Row, m_l_R3_to_R2_Max_Column, m_arMAP_R3_to_R2
    PopulateTheMappingMatrix "IN_to_R3_Mapping", m_l_IN_to_R3_Max_Row, m_l_IN_to_R3_Max_Column, m_arrMAP_IN_to_R3
'    mod_General.PutArrayOnWorkSheet m_arrMAP_IN_to_R3, "Junk", 1, 1
    
    
    '1] Build the Output Array
    Set m_dict_OUTPUTs = New Dictionary
    Build_Output_Array
    
    
    '===================START TEST Print of data ==============================
   Dim keyX As Variant
   Dim keyY As Variant
   
   For Each keyX In m_dict_OUTPUTs
        Debug.Print ("=================")
        Debug.Print (CStr(m_dict_OUTPUTs(keyX).R1_i) &amp; " : " &amp; m_dict_OUTPUTs(keyX).R1_Caption)
        

        For Each keyY In m_dict_OUTPUTs(keyX).dict_R2s
            Debug.Print ("=================")
            Debug.Print ("      " &amp; CStr(m_dict_OUTPUTs(keyX).dict_R2s(keyY).R2_i) &amp; " : " &amp; m_dict_OUTPUTs(keyX).dict_R2s(keyY).R2_Caption)
        Next keyY
            
    Next keyX
    
    '===================START TEST Print of data ==============================
    
    
    
    MsgBox ("Done!")
    '=========================
      Exit Sub
            
ErrorHandler:
        Select Case Err.Number
            Case 0  'raised by subroutine
                MsgBox ("A Subroutine raised an error that must be fixed BEFORE proceeding")
            Case Else
                MsgBox "Two_Main - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub



Sub PopulateTheMappingMatrix(sSheetName As String, lNoOfRows As Long, lNoOfColumns As Long, ByRef arrMatrixToPopulate() As Variant)
    On Error GoTo ErrorHandler
    
    '=========================
    Dim rngX As Range

    Set rngX = Range(Worksheets(sSheetName).Range("A1"), Worksheets(sSheetName).Cells(lNoOfRows, lNoOfColumns))
    arrMatrixToPopulate() = rngX


    '=========================
      Exit Sub
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "PopulateTheMappingMatrix - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub

Sub GetTheMatrixSizes()
    On Error GoTo ErrorHandler
    
    '=========================
    '1] R2_to_R1
    m_l_R2_to_R1_Max_Column = fn_lLastColumn("R2_to_R1_Mapping")
    m_l_R2_to_R1_Max_Row = fn_lLastRow("R2_to_R1_Mapping")

     '2] R3_to_R2
    m_l_R3_to_R2_Max_Column = fn_lLastColumn("R3_to_R2_Mapping")
    m_l_R3_to_R2_Max_Row = fn_lLastRow("R3_to_R2_Mapping")
   
     '3] IN_to_R3
    m_l_IN_to_R3_Max_Column = fn_lLastColumn("IN_to_R3_Mapping")
    m_l_IN_to_R3_Max_Row = fn_lLastRow("IN_to_R3_Mapping")
   
    '=========================
      Exit Sub
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "GetTheMatrixSizes - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub


Sub Build_Output_Array()
    On Error GoTo ErrorHandler
    
    '=========================

    Dim iRowCounter As Integer
    Dim iColumnCounter As Integer
    Dim iCellInRangeCounter As Integer
    Dim rngHeaderOfData As Range    'This is the value in Row: 1
    Dim rngColumnOfData As Range    'this is the set of data values located underneath the header, starting a row: 3
    Dim iDataStartsAtColumn_for_R2_to_R1  As Integer   'The Column R1(i) index begin at this column
    Dim iNumberOfRowsOfData_for_R2_to_R1  As Integer
    Dim c As Range
    Dim oR1_record As New c_R1_record
    Dim oR2_record As New c_R2_Record

'   Get the data from: R2_to_R1
    iDataStartsAtColumn_for_R2_to_R1 = 3
    iNumberOfRowsOfData_for_R2_to_R1 = CInt(m_l_R2_to_R1_Max_Row)
    
    
    For iColumnCounter = iDataStartsAtColumn_for_R2_to_R1 To m_l_R2_to_R1_Max_Column
    '===============================================================================
        Set oR1_record = New c_R1_record
        
'        Set rngHeaderOfData = Worksheets("R2_to_R1_Mapping").Range("A1").Offset(0, iDataStartsAtColumn_for_R2_to_R1 - 1)
        Set rngHeaderOfData = Worksheets("R2_to_R1_Mapping").Range("A1").Offset(0, iColumnCounter - 1)

        Set rngColumnOfData = rngHeaderOfData.Offset(2, 0).Resize(iNumberOfRowsOfData_for_R2_to_R1, 1).SpecialCells(xlCellTypeConstants)
        
'        oR1_record.R1_PK = rngHeaderOfData.Value
'        oR1_record.R1_Caption = rngHeaderOfData.Offset(1, 0).Value
'        oR1_record.R1_i = iColumnCounter - iDataStartsAtColumn_for_R2_to_R1 + 1
'
'        Set oR1_record.dict_R2s = New Dictionary

        With oR1_record
            .R1_PK = rngHeaderOfData.Value
            .R1_Caption = rngHeaderOfData.Offset(1, 0).Value
            .R1_i = iColumnCounter - iDataStartsAtColumn_for_R2_to_R1 + 1
            Set .dict_R2s = New Dictionary
        End With

        iCellInRangeCounter = 0
        Set c = Nothing
        
        For Each c In rngColumnOfData.Cells
        
            iCellInRangeCounter = iCellInRangeCounter + 1

            Set oR2_record = New c_R2_Record
            Dim iR2_PK As Integer
            iR2_PK = Worksheets("R2_to_R1_Mapping").Range("A" &amp; CStr(c.Row)).Value
            
            oR2_record.R2_i = iCellInRangeCounter
            oR2_record.R2_PK = iR2_PK
            oR2_record.R2_Caption = Worksheets("R2_to_R1_Mapping").Range("B" &amp; CStr(c.Row)).Value
            oR2_record.R2_Multiplier = c.Value          'This comes from the cell located directly below the 'rngHeaderOfData' cell
            '======================================================================
            
            
            
            'Code for inner Loops if neccessary
            
            
            

             '======================================================================
            'oR1_record.dict_R2s.Add iCellInRangeCounter, oR2_record
            oR1_record.dict_R2s.Add iR2_PK, oR2_record
        Next c
        
        m_dict_OUTPUTs.Add rngHeaderOfData.Value, oR1_record    'Key: is the R1_PK
    '===============================================================================
    Next iColumnCounter
    
    
    '=========================
      Exit Sub
            
            
            
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "Build_Output_Array - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
                Err.Raise 0
                
        End Select
    End Sub



/////////////2] Mod_General/////////////////

Sub PutArrayOnWorkSheet(arrData() As Variant, SheetName As String, intStartRow As Integer, intStartCol As Integer)
    On Error GoTo ErrorHandler
    
    '=========================
    Dim oWorksheet As Worksheet
    Dim rngCopyTo As Range
    Set oWorksheet = ActiveWorkbook.Worksheets(SheetName)

    ' size of array
    Dim intEndRow As Integer
    Dim intEndCol As Integer
    intEndRow = UBound(arrData, 1)
    intEndCol = UBound(arrData, 2)

    Set rngCopyTo = oWorksheet.Range(oWorksheet.Cells(intStartRow, intStartCol), oWorksheet.Cells(intEndRow, intEndCol))
    rngCopyTo.Value = arrData

    '=========================
      Exit Sub
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "GetTheMatrixSizes - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
    End Sub

////////// 3] Mod_Functions ///////////////

Function fn_WorkSheetExists(wsName As String) As Boolean
    On Error Resume Next
    fn_WorkSheetExists = Worksheets(wsName).Name = wsName
End Function


Function fn_lLastRow(sWorkSheetName As String) As Long
    Dim lX As Long
    

    Dim wsX As Worksheet
    
    Set wsX = Sheets(sWorkSheetName)
    lX = wsX.Cells(Rows.Count, 1).End(xlUp).Row
    
    fn_lLastRow = lX
    
'    MsgBox (CStr(lX))
    
End Function

Function fn_lLastColumn(sWorkSheetName As String) As Long
    On Error GoTo ErrorHandler
    
    '=========================
    Dim lX As Long

'    Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Select


    lX = Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Column
    
    fn_lLastColumn = lX
    
         '=========================
      Exit Function
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
     
End Function



Function fn_MappingsAreValid() As String
    'Validity is defined as:
    '      a) There is 1 or less entries per row of data
    
    Dim sX As String
    Dim sX_accumulated As String
    
    sX = ""
    sX_accumulated = ""
    
    '1] R2_to_R1
    sX = sX &amp; fn_CheckForOneAndOnlyOneValuePerRow("R2_to_R1_Mapping", m_l_R2_to_R1_Max_Row, m_l_R2_to_R1_Max_Column)

    If Len(Trim(sX)) &gt; 0 Then
        sX = "These rows in R2_to_R1_Mapping had more than one value: " &amp; sX
        sX_accumulated = sX
        sX = ""
    Else
    
    End If
    
    '2] R3_to_R2
    
    sX = sX &amp; fn_CheckForOneAndOnlyOneValuePerRow("R3_to_R2_Mapping", m_l_R3_to_R2_Max_Row, m_l_R3_to_R2_Max_Column)

    If Len(Trim(sX)) &gt; 0 Then
        sX = "These rows in R3_to_R2_Mapping had more than one value: " &amp; sX
        sX_accumulated = sX_accumulated &amp; " | " &amp; sX
        sX = ""
    Else
    
    End If
    
    
        '3] IN_to_R3
    
    sX = sX &amp; fn_CheckForOneAndOnlyOneValuePerRow("IN_to_R3_Mapping", m_l_IN_to_R3_Max_Row, m_l_IN_to_R3_Max_Column)

    If Len(Trim(sX)) &gt; 0 Then
        sX = "These rows in IN_to_R3_Mapping had more than one value: " &amp; sX
        sX_accumulated = sX_accumulated &amp; " | " &amp; sX
        sX = ""
    Else
    
    End If

    fn_MappingsAreValid = sX_accumulated
    
End Function


Function fn_CheckForOneAndOnlyOneValuePerRow(sNameOfWorkSheet As String, lRows As Long, lColumns As Long) As String
    On Error GoTo ErrorHandler
    
    '=========================
    
    Dim sX As String
    Dim lRowCounter As Long
    Dim lnonEmptyColumnCount As Long
    
    sX = ""
           
    For lRowCounter = 3 To lRows
        Dim rng As Range
        Dim ws As Worksheet
        Set ws = Sheets(sNameOfWorkSheet)
        Set rng = ws.Cells(lRowCounter, 3).Resize(, lColumns - 2)
        lnonEmptyColumnCount = WorksheetFunction.CountA(rng)
 
        If lnonEmptyColumnCount &gt; 1 Then
            sX = sX &amp; "[" &amp; Trim(Worksheets(sNameOfWorkSheet).Range("A1").Cells(lRowCounter, 2).Value) &amp; "] , "
        Else
'            sX = sX
        End If
        
    Next lRowCounter

    fn_CheckForOneAndOnlyOneValuePerRow = sX
    '=========================
      Exit Function
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "GetTheMatrixSizes - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Function

    
///////////// 5] c_R1_Record /////////////

Option Explicit

'CLASS: c_R1_Record
'Dictionary Key:    R1_PK   As Integer             'This is the key that ties the levels together, from the Mapping table

Public R1_i As Long                     'This is a simple counter starting at 1
Public R1_PK As Long                    'This is the key that ties the levels together, from the Mapping table
Public Total_1 As Double                'This is the total of the (Total_2  times R2_Multiplier) from the R2_Records
Public R1_Caption As String             'This is the caption from the Mapping table
Public dict_R2s As Scripting.Dictionary 'This is the dictionary of R2_Record objects


///////////// 6] c_R2_Record /////////////

Option Explicit

'CLASS: c_R2_Record
'Dictionary Key:    R2_PK   As Integer             'This is the key that ties the levels together, from the Mapping table


Public R2_i As Long                     'This is a simple counter starting at 1
Public R2_PK As Long                    'This is the key that ties the levels together, from the Mapping table
Public Total_2 As Double                'This is the total of the (Total_3  times R3_Multiplier) from the R3_Records
Public R2_Caption As String             'This is the caption from the Mapping table
Public R2_Multiplier As Double          'Used in R1 Record to calculate the Total_1
Public dict_R3s As Scripting.Dictionary 'This is the dictionary of R3_Record objects

//////////////////////////////////////////
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Files_Directory_Folders</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ListFilesInDirectory_use_Function_ToGetFolder</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Files_Directory_Folders</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ListFilesInDirectory_use_Function_ToGetFolder</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Sub ExcelFileSearch()
    Dim srchExt As Variant, srchDir As Variant, i As Long, j As Long
    Dim strName As String, varArr(1 To 1048576, 1 To 3) As Variant
    Dim strFileFullName As String
    Dim ws As Worksheet
    Dim fso As Object
    
    Let srchExt = Application.InputBox("Please Enter File Extension", "Info Request")
    If srchExt = False And Not TypeName(srchExt) = "String" Then
        Exit Sub
    End If
    
    Let srchDir = BrowseForFolderShell
    If srchDir = False And Not TypeName(srchDir) = "String" Then
        Exit Sub
    End If
    
    Application.ScreenUpdating = False
    
    Set ws = ThisWorkbook.Worksheets.Add(Sheets(1))
    On Error Resume Next
    Application.DisplayAlerts = False
    ThisWorkbook.Worksheets("FileSearch Results").Delete
    Application.DisplayAlerts = True
    On Error GoTo 0
    ws.Name = "FileSearch Results"
    
    Let strName = Dir$(srchDir &amp; "\*" &amp; srchExt)
    Do While strName &lt;&gt; vbNullString
        Let i = i + 1
        Let strFileFullName = srchDir &amp; strName
        Let varArr(i, 1) = strFileFullName
        Let varArr(i, 2) = FileLen(strFileFullName) \ 1024
        Let varArr(i, 3) = FileDateTime(strFileFullName)
        Let strName = Dir$()
    Loop
    
    Set fso = CreateObject("Scripting.FileSystemObject")
    Call recurseSubFolders(fso.GetFolder(srchDir), varArr(), i, CStr(srchExt))
    Set fso = Nothing
    
    ThisWorkbook.Windows(1).DisplayHeadings = False
    With ws
        If i &gt; 0 Then
            .Range("A2").Resize(i, UBound(varArr, 2)).Value = varArr
            For j = 1 To i
                .Hyperlinks.Add Anchor:=.Cells(j + 1, 1), Address:=varArr(j, 1)
            Next
        End If
        .Range(.Cells(1, 4), .Cells(1, .Columns.Count)).EntireColumn.Hidden = True
        .Range(.Cells(.Rows.Count, 1).End(xlUp)(2), _
            .Cells(.Rows.Count, 1)).EntireRow.Hidden = True
        With .Range("A1:C1")
            .Value = Array("Full Name", "Kilobytes", "Last Modified")
            .Font.Underline = xlUnderlineStyleSingle
            .EntireColumn.AutoFit
            .HorizontalAlignment = xlCenter
        End With
    End With
    Application.ScreenUpdating = True
End Sub


Private Sub recurseSubFolders(ByRef Folder As Object, _
    ByRef varArr() As Variant, _
    ByRef i As Long, _
    ByRef srchExt As String)
    
    Dim SubFolder As Object
    Dim strName As String, strFileFullName As String
    For Each SubFolder In Folder.SubFolders
        Let strName = Dir$(SubFolder.Path &amp; "\*" &amp; srchExt)
        Do While strName &lt;&gt; vbNullString
            Let i = i + 1
            Let strFileFullName = SubFolder.Path &amp; "\" &amp; strName
            Let varArr(i, 1) = strFileFullName
            Let varArr(i, 2) = FileLen(strFileFullName) \ 1024
            Let varArr(i, 3) = FileDateTime(strFileFullName)
            Let strName = Dir$()
        Loop
        If i &gt; 1048576 Then Exit Sub
        Call recurseSubFolders(SubFolder, varArr(), i, srchExt)
    Next
End Sub


Private Function BrowseForFolderShell() As Variant
    Dim objShell As Object, objFolder As Object
    Set objShell = CreateObject("Shell.Application")
    Set objFolder = objShell.BrowseForFolder(0, "Please select a folder", 0, "C:\")
    If Not objFolder Is Nothing Then
        On Error Resume Next
        If IsError(objFolder.Items.Item.Path) Then
            BrowseForFolderShell = CStr(objFolder)
        Else
            On Error GoTo 0
            If Len(objFolder.Items.Item.Path) &gt; 3 Then
                BrowseForFolderShell = objFolder.Items.Item.Path &amp; _
                Application.PathSeparator
            Else
                BrowseForFolderShell = objFolder.Items.Item.Path
            End If
        End If
    Else
        BrowseForFolderShell = False
    End If
    Set objFolder = Nothing: Set objShell = Nothing
End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Formatting</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ChangeCase_Lower_Upper_Sentance_Titles_CapsSmall</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Formatting</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ChangeCase_Lower_Upper_Sentance_Titles_CapsSmall</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'This particular sub let's you select a range of cells
' and then is formats the selected range





//////////////////////////////


Sub TextCaseChange()
    ' Page 359
    Dim RgText As Range
    Dim oCell As Range
    Dim Ans As String
    Dim strTest As String
    Dim sCap As Integer, _
        lCap As Integer, _
        i As Integer
    
    '// You need to select a Range to Alter 1st!
    
Again:
    Ans = Application.InputBox("[L]owercase" &amp; vbCr &amp; "[U]ppercase" &amp; vbCr &amp; _
            "[S]entence" &amp; vbCr &amp; "[T]itles" &amp; vbCr &amp; "[C]apsSmall", _
            "Type in a Letter", Type:=2)
    
    If Ans = "False" Then Exit Sub
    If InStr(1, "LUSTC", UCase(Ans), vbTextCompare) = 0 Or Len(Ans) &gt; 1 Then GoTo Again
    
    On Error GoTo NoText
    If Selection.Count = 1 Then
        Set RgText = Selection
    Else
        Set RgText = Selection.SpecialCells(xlCellTypeConstants, 2)
    End If
    On Error GoTo 0
    
    For Each oCell In RgText
        Select Case UCase(Ans)
            Case "L": oCell = LCase(oCell.Text)
            Case "U": oCell = UCase(oCell.Text)
            Case "S": oCell = UCase(Left(oCell.Text, 1)) &amp; _
                LCase(Right(oCell.Text, Len(oCell.Text) - 1))
            Case "T": oCell = Application.WorksheetFunction.Proper(oCell.Text)
            Case "C"
                    lCap = oCell.Characters(1, 1).Font.Size
                    sCap = Int(lCap * 0.85)
                    'Small caps for everything.
                    oCell.Font.Size = sCap
                    oCell.Value = UCase(oCell.Text)
                    strTest = oCell.Value
                    'Large caps for 1st letter of words.
                    strTest = Application.Proper(strTest)
                    For i = 1 To Len(strTest)
                        If Mid(strTest, i, 1) = UCase(Mid(strTest, i, 1)) Then
                            oCell.Characters(i, 1).Font.Size = lCap
                        End If
                    Next i
        End Select
    Next
    
    Exit Sub
NoText:
    MsgBox "No Text in your selection @ " &amp; Selection.Address

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Formatting</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Custom_Transpose</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Formatting</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Custom_Transpose</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' 1] Place Code in standard Module

'OBJECTIVE:
'you need the data formatted so each date and batch is in a single row, with the Value and Finish postion
'   going across

/////////////DATA //////////////////////

'Initial:

ItemName	ItemDate	Batch#	FinishPosition	Value	V1	V2	V3	V4	V5	V6	V7	V8	V9	V10	V11	V12	V13	V14	V1FP	V2FP	V3FP	V4FP	V5FP	V6FP	V7FP	V8FP	V9FP	V10FP	V11FP	V12FP	V13FP	V14FP
Thermal	10/23/2009	1	8	2.15
Thermal	10/23/2009	1	3	3.2
Thermal	10/23/2009	1	2	4.9
Thermal	10/23/2009	1	1	6.1
Thermal	10/23/2009	1	7	6.2
Thermal	10/23/2009	1	4	12.9
Thermal	10/23/2009	1	9	23
Thermal	10/23/2009	1	5	36
Thermal	10/23/2009	1	6	36.25
Thermal	10/23/2009	2	2	1.05
Thermal	10/23/2009	2	1	2.5
Thermal	10/23/2009	2	8	7.3
Thermal	10/23/2009	2	3	10.9
Thermal	10/23/2009	2	4	12.1
Thermal	10/23/2009	2	9	21.7
Thermal	10/23/2009	2	6	33.25
Thermal	10/23/2009	2	7	43
Thermal	10/23/2009	2	5	43.25
Thermal	10/23/2009	3	2	1.65
Thermal	10/23/2009	3	3	3.1
Thermal	10/23/2009	3	4	3.1
Thermal	10/23/2009	3	5	3.75
Thermal	10/23/2009	3	6	7.1
Thermal	10/23/2009	3	7	7.1
Thermal	10/23/2009	3	1	7.7
Thermal	10/23/2009	3	9	18.7
Thermal	10/23/2009	3	8	34
Thermal	10/23/2009	3	10	55.5

////////////////////////////////
' Final data

ItemName	ItemDate	Batch#	V1	V2	V3	V4	V5	V6	V7	V8	V9	V10	V11	V12	V13	V14	V1FP	V2FP	V3FP	V4FP	V5FP	V6FP	V7FP	V8FP	V9FP	V10FP	V11FP	V12FP	V13FP	V14FP
Thermal	10/23/2009	1	2.15	3.2	4.9	6.1	6.2	12.9	23	36	36.25						8	3	2	1	7	4	9	5	6					
Thermal	10/23/2009	2	1.05	2.5	7.3	10.9	12.1	21.7	33.25	43	43.25						2	1	8	3	4	9	6	7	5					
Thermal	10/23/2009	3	1.65	3.1	3.1	3.75	7.1	7.1	7.7	18.7	34	55.5					2	3	4	5	6	7	1	9	8	10				

/////////////CODE/////////////////

'//////////////////////////////////
'//Written by Masaru Kaji @ MrExcel.com
'//////////////////////////////////
Option Explicit

Declare Function ShellAbout Lib "shell32.dll" Alias "ShellAboutA" (ByVal hwnd As Long, ByVal szApp As String, ByVal szOtherStuff As String, ByVal hIcon As Long) As Long
Declare Function GetActiveWindow Lib "user32" () As Long

Public Const Nm = "TransposeData"

Sub TransposeData()
Dim shOrg As Worksheet, shRes As Worksheet
Dim rngStart As Range, rngPaste As Range
Dim lngData As Long

Application.ScreenUpdating = False
On Error Resume Next
Application.DisplayAlerts = False
Sheets("TransposeResult").Delete
Application.DisplayAlerts = True
On Error GoTo 0

On Error GoTo terminate

Set shOrg = Sheets("TransposeData")
Set shRes = Sheets.Add(After:=shOrg)
shRes.Name = "TransposeResult"
With shOrg
    '--Sort
    .Cells.CurrentRegion.Sort Key1:=.[B2], Order1:=1, Key2:=.[C2], Order2:=1, _
        Key3:=.[E2], Order3:=1, Header:=xlYes
    '--Copy title
    .Rows(1).Copy shRes.Rows(1)
    '--Set start range
    Set rngStart = .[C2]
    Do Until IsEmpty(rngStart)
        Set rngPaste = shRes.Cells(shRes.Rows.Count, 1).End(xlUp).Offset(1)
        lngData = GetNextRange(rngStart)
        rngStart.Offset(, -2).Resize(, 5).Copy rngPaste

        'Copy to V1 toV14
        rngStart.Offset(, 2).Resize(lngData).Copy
        rngPaste.Offset(, 5).PasteSpecial Paste:=xlAll, Operation:=xlNone, _
         SkipBlanks:=False, Transpose:=True
        'Copy to V1FP to V14FP
        rngStart.Offset(, 1).Resize(lngData).Copy
        rngPaste.Offset(, 19).PasteSpecial Paste:=xlAll, Operation:=xlNone, _
         SkipBlanks:=False, Transpose:=True
        Set rngStart = rngStart.Offset(lngData)
    Loop
End With

Application.GoTo shRes.[A1]
With shRes
    .Cells.Columns.AutoFit
    .Columns("D:E").Delete shift:=xlToLeft
End With

Application.ScreenUpdating = True
Application.CutCopyMode = False

If MsgBox("Do you want to delete the original worksheet?", 36) = 6 Then
    Application.DisplayAlerts = False
    Sheets("TransposeData").Delete
    Application.DisplayAlerts = True
End If

Set rngPaste = Nothing
Set rngStart = Nothing
Set shRes = Nothing

Exit Sub

terminate:
   
End Sub

Function GetNextRange(ByVal rngSt As Range) As Long
    Dim i As Long
    i = 0
    
    Do Until rngSt.Value &lt;&gt; rngSt.Offset(i).Value
        i = i + 1
    Loop
    
    GetNextRange = i
End Function

Sub AboutTranspose()
    Dim hwnd As Integer
    On Error Resume Next
    hwnd = GetActiveWindow()
    ShellAbout hwnd, Nm, vbCrLf + Chr(169) + "" &amp; " MrExcel.com Consulting" + vbCrLf, 0
    On Error GoTo 0
End Sub
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_Formatting</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Highlight_Row_when_Selecting_Cell_For_a_particular_sheet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_Formatting</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Highlight_Row_when_Selecting_Cell_For_a_particular_sheet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    If Target.Cells.Count &gt; 1 Then Exit Sub
    Application.ScreenUpdating = False
    ' Clear the color of all the cells
    Cells.Interior.ColorIndex = 0
    With Target
        ' Highlight the entire row and column that contain the active cell
        .EntireRow.Interior.ColorIndex = 15
    End With
    Application.ScreenUpdating = True
End Sub
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_GeneralWorkSheet</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Autofilter_DeleteRows_WithNothingIn_ColumnA</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_GeneralWorkSheet</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Autofilter_DeleteRows_WithNothingIn_ColumnA</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

Sub Delete_with_Autofilter()
    Dim DeleteValue As String
    Dim rng As Range
    Dim calcmode As Long

    With Application
        calcmode = .Calculation
        .Calculation = xlCalculationManual
'        .ScreenUpdating = False
    End With

    'Fill in the value that you want to delete
    'Tip: use DeleteValue = "&lt;&gt;ron" to delete rows without ron
'    DeleteValue = "ron"
'        We can have the filter show only blanks for the specified Field by using: Criteria1:="="
'        To show all non-blanks we would use: Criteria1:="&lt;&gt;"

    DeleteValue = "="
    
    
    'Sheet with the data, you can also use Sheets("MySheet")
'    With ActiveSheet
    With Sheets("InstitutionList_WorkingVersion")

        'Firstly, remove the AutoFilter
        .AutoFilterMode = False

        'Apply the filter
        .Range("A1:A" &amp; .Rows.Count).AutoFilter Field:=1, Criteria1:=DeleteValue

        With .AutoFilter.Range
            On Error Resume Next
            Set rng = .Offset(1, 0).Resize(.Rows.Count - 1, 1) _
                      .SpecialCells(xlCellTypeVisible)
            On Error GoTo 0
            If Not rng Is Nothing Then rng.EntireRow.Delete
        End With

        'Remove the AutoFilter
        .AutoFilterMode = False
    End With

    With Application
'        .ScreenUpdating = True
        .Calculation = calcmode
    End With

    MsgBox ("Done")

End Sub

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_GeneralWorkSheet</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>FinalRow</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_GeneralWorkSheet</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>FinalRow</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' Gets the final row of a worksheet.

'1] Go to the very last row of the worksheet, in the first column
'2] Then go back up to the first occupied cell

'For an empty sheet the FinalRow is = 1


Sub TEST()
    Dim FinalRow As Integer
    Sheet1.Select
    FinalRow = Cells(Rows.Count, 1).End(xlUp).Row
    MsgBox ("FinalRow: " &amp; CStr(FinalRow))
    
End Sub

///////////////////////////////////////////////////////

Function fn_lLastRow(sWorkSheetName As String) As Long
    Dim lX As Long
    

    Dim wsX As Worksheet
    
    Set wsX = Sheets(sWorkSheetName)
    lX = wsX.Cells(Rows.Count, 1).End(xlUp).Row
    
    fn_lLastRow = lX
    
'    MsgBox (CStr(lX))
    
End Function

Function fn_lLastColumn(sWorkSheetName As String) As Long

    Dim lX As Long

    Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Select


    lX = Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Column
    
    fn_lLastColumn = lX
    
'    MsgBox (CStr(lX))
     
End Function


//////////////////////////////////
' FROM: http://stackoverflow.com/questions/4872512/last-not-empty-cell-in-row-excel-vba
'    do not use Select
'    cater for the last cell in row 1 being used
'    cater for the entire row being empty
'    cater for the entire row being full

'The Find method in the second code is a far more direct method of establishing the first non-blank cell
'----------------------------------------------------
'This Line:

Set rng1 = ws.Rows(1).Find("*", ws.[a1], xlValues, , xlByColumns, xlPrevious)

'says, start in cell A1 of Sheet "DTCa" then look backwards
'(ie from the last cell in row 1) in row1 by column looking for anything (the *).
'This method either find the last non blank or returns Nothing , ie an empty row
'------------------------------------------------------


Sub Method1()
    Dim ws As Worksheet
    Dim rng1 As Range
    Set ws = Sheets("DTCs")
    If ws.Cells(1, Columns.Count) = vbNullString Then
        Set rng1 = ws.Cells(1, Columns.Count).End(xlToLeft)
        If rng1.Column &lt;&gt; 1 Then
            'return last used cell
            MsgBox "rng1 contains " &amp; rng1.Address(0, 0)
        Else
            If Application.WorksheetFunction.CountA(ws.Rows(1)) = Columns.Count Then
                'row is completely full
                MsgBox ws.Name &amp; " row1 is completely full", vbCritical
                'row is completely empty
            ElseIf ws.[a1] = vbNullString Then MsgBox ws.Name &amp; " row1 is completely empty", vbCritical
            Else
                'true last used cell is A1
                MsgBox "rng1 contains " &amp; rng1.Address(0, 0)
            End If
        End If
    Else
        'last cell is non-blank
        MsgBox ws.Cells(1, Columns.Count) &amp; " contains a value@,vbcritical"
    End If
End Sub

Sub Method2()
    Dim ws As Worksheet
    Dim rng1 As Range
    Set ws = Sheets("DTCs")
    Set rng1 = ws.Rows(1).Find("*", ws.[a1], xlValues, , xlByColumns, xlPrevious)
    If Not rng1 Is Nothing Then
        MsgBox "rng1 contains " &amp; rng1.Address(0, 0)
    Else
        MsgBox ws.Name &amp; " row1 is completely empty", vbCritical
    End If
End Sub


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_GeneralWorkSheet</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>fn_lLastColumn</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_GeneralWorkSheet</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>fn_lLastColumn</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Function fn_lLastColumn(sWorkSheetName As String) As Long
    On Error GoTo ErrorHandler
    
    '=========================
    Dim lX As Long

'    Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Select


    lX = Worksheets(sWorkSheetName).Cells(1, Columns.Count).End(xlToLeft).Column
    
    fn_lLastColumn = lX
    
         '=========================
      Exit Function
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
     
End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_GeneralWorkSheet</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>fn_lLastRow</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_GeneralWorkSheet</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>fn_lLastRow</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Function fn_lLastRow(sWorkSheetName As String) As Long
    Dim lX As Long
    

    Dim wsX As Worksheet
    
    Set wsX = Sheets(sWorkSheetName)
    lX = wsX.Cells(Rows.Count, 1).End(xlUp).Row
    
    fn_lLastRow = lX
    
'    MsgBox (CStr(lX))
    
End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_GeneralWorkSheet</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>MoveWorkSheet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_GeneralWorkSheet</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>MoveWorkSheet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Sub Move_Sheet_To_LastPosition()
    ActiveSheet.Move _
       After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count)
       'Moves active sheet to end of active workbook.
End Sub


Sub Move_Sheet_To_BeginningOfAnother_Workbook()

    ActiveSheet.Move Before:=Workbooks("Test.xls").Sheets(1)
    'Moves active sheet to beginning of named workbook.
    'Replace Test.xls with the full name of the target workbook you want.
End Sub


'Move Active Sheet to a New Position in Workbook
Sub Mover1()
    ActiveSheet.Move _
       After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count)
       'Moves active sheet to end of active workbook.
End Sub


'Move Multiple Sheets in ActiveWorkbook to Another Workbook

Sub Mover3()
   Dim BkName As String
   Dim NumSht As Integer
   Dim BegSht As Integer

   'Starts with second sheet - replace with index number of starting sheet.
   BegSht = 2
   'Moves two sheets - replace with number of sheets to move.
   NumSht = 2
   BkName = ActiveWorkbook.Name
    
    For x = 1 To NumSht
      'Moves second sheet in source to front of designated workbook.
      Workbooks(BkName).Sheets(BegSht).Move _
         Before:=Workbooks("Test.xls").Sheets(1)
         'In each loop, the next sheet in line becomes indexed as number 2.
      'Replace Test.xls with the full name of the target workbook you want.
    Next
End Sub
				</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_GeneralWorkSheet</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>OpenDialogThatListsNonEmptySheets_PopulatesDialogWithCheckboxes_PrintSelectedSheets</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_GeneralWorkSheet</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>OpenDialogThatListsNonEmptySheets_PopulatesDialogWithCheckboxes_PrintSelectedSheets</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

Sub SelectSheets()
    Dim i As Integer
    Dim TopPos As Integer
    Dim SheetCount As Integer
    Dim PrintDlg As DialogSheet
    Dim CurrentSheet As Worksheet
    Dim cb As CheckBox
    Application.ScreenUpdating = False

'   Check for protected workbook
    If ActiveWorkbook.ProtectStructure Then
        MsgBox "Workbook is protected.", vbCritical
        Exit Sub
    End If

'   Add a temporary dialog sheet
    Set CurrentSheet = ActiveSheet
    Set PrintDlg = ActiveWorkbook.DialogSheets.Add

    SheetCount = 0

'   Add the checkboxes

    TopPos = 40
    For i = 1 To ActiveWorkbook.Worksheets.Count
        Set CurrentSheet = ActiveWorkbook.Worksheets(i)
'       Skip empty sheets and hidden sheets
        If Application.CountA(CurrentSheet.Cells) &lt;&gt; 0 And _
            CurrentSheet.Visible Then
            SheetCount = SheetCount + 1
            PrintDlg.CheckBoxes.Add 78, TopPos, 150, 16.5
                PrintDlg.CheckBoxes(SheetCount).Text = _
                    CurrentSheet.Name
            TopPos = TopPos + 13
        End If
    Next i

'   Move the OK and Cancel buttons
    PrintDlg.Buttons.Left = 240

'   Set dialog height, width, and caption
    With PrintDlg.DialogFrame
        .Height = Application.Max _
            (68, PrintDlg.DialogFrame.Top + TopPos - 34)
        .Width = 230
        .Caption = "Select sheets to print"

    End With

'   Change tab order of OK and Cancel buttons
'   so the 1st option button will have the focus
    PrintDlg.Buttons("Button 2").BringToFront
    PrintDlg.Buttons("Button 3").BringToFront

'   Display the dialog box
    CurrentSheet.Activate
    Application.ScreenUpdating = True
    If SheetCount &lt;&gt; 0 Then
        If PrintDlg.Show Then
            For Each cb In PrintDlg.CheckBoxes
                If cb.Value = xlOn Then
                    Worksheets(cb.Caption).Activate
                    ActiveSheet.PrintOut
'                   ActiveSheet.PrintPreview 'for debugging

                End If
            Next cb
        End If
    Else
        MsgBox "All worksheets are empty."
    End If

'   Delete temporary dialog sheet (without a warning)
    Application.DisplayAlerts = False
    PrintDlg.Delete

'   Reactivate original sheet
    CurrentSheet.Activate
End Sub

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_GeneralWorkSheet</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>SortTabsAlphabetically</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_GeneralWorkSheet</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>SortTabsAlphabetically</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'From Bruce Riesen, he got it of the web:


Sub Sort_Active_Book()
	Dim i As Integer
	Dim j As Integer
	Dim iAnswer As VbMsgBoxResult
	iAnswer = MsgBox("Sort Sheets in Ascending Order?" &amp; Chr(10) &amp; "Clicking No will sort in Descending Order", vbYesNoCancel + vbQuestion + vbDefaultButton1, "Sort Worksheets")
	For i = 1 To Sheets.Count
		For j = 1 To Sheets.Count - 1
		
			If iAnswer = vbYes Then
				If UCase$(Sheets(j).Name) &gt; UCase$(Sheets(j + 1).Name) Then
					Sheets(j).Move After:=Sheets(j + 1)
				End If
				
			ElseIf iAnswer = vbNo Then
			
				If UCase$(Sheets(j).Name) &lt; UCase$(Sheets(j + 1).Name) Then
					Sheets(j).Move After:=Sheets(j + 1)
				End If
				
			End If
		Next j
	Next i
End Sub
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_MISC</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>#N/A</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_MISC</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>#N/A</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>If IsError(ActiveWorkbook.Sheets("Publish").Range("G4").offset(offsetCount, 0).Value) Then
  If (ActiveWorkbook.Sheets("Publish").Range("G4").offset(offsetCount, 0).Value &lt;&gt; CVErr(xlErrNA)) Then
    'do something
  End If
End If


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_MISC</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>AlternatingRowFill</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_MISC</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>AlternatingRowFill</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub AlternatingColors_LightKakiGreen()
'
' TEST_AlternatingColors_LightKakiGreen Macro
'

'
    Selection.FormatConditions.Add Type:=xlExpression, Formula1:= _
        "=MOD(ROW(),2)=0"
    Selection.FormatConditions(Selection.FormatConditions.Count).SetFirstPriority
    With Selection.FormatConditions(1).Interior
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorAccent3
        .TintAndShade = 0.599963377788629
    End With
    Selection.FormatConditions(1).StopIfTrue = True
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_MISC</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Count_NonBlank_Cells</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_MISC</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Count_NonBlank_Cells</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


MsgBox WorksheetFunction.CountA(Range("A1:D45")) 
//////////////////////////////////////
Worksheets("Sheet1").Range("A:A").Cells.SpecialCells(xlCelltypeConstants).Count
///////////////////////////////////////


Sub Count_NonBlank_Cells_InSelectedColumn()
    Dim col As Integer
    Dim rng As Range
    Dim n As Long
    Dim b As Long
    
    col = Selection.Column
    
    If Application.WorksheetFunction.CountA(Columns(col)) = 0 Then
        MsgBox "You have selected a blank column"
        n = 0
    Else
        Set rng = Intersect(Columns(col), ActiveSheet.UsedRange)
        On Error Resume Next
        b = rng.Cells.SpecialCells(xlCellTypeBlanks).Count
        n = rng.Cells.Count - b
        On Error GoTo 0
        MsgBox "The number of non-blank cells in column " &amp; col &amp; " is " &amp; n
    End If
End Sub


/////////////////////////////////////////////</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_MISC</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>fn_CheckForOneAndOnlyOneValuePerRow</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_MISC</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>fn_CheckForOneAndOnlyOneValuePerRow</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Function fn_CheckForOneAndOnlyOneValuePerRow(sNameOfWorkSheet As String, lRows As Long, lColumns As Long) As String
    On Error GoTo ErrorHandler
    
    '=========================
    
    Dim sX As String
    Dim lRowCounter As Long
    Dim lnonEmptyColumnCount As Long
    
    sX = ""
           
    For lRowCounter = 3 To lRows
        Dim rng As Range
        Dim ws As Worksheet
        Set ws = Sheets(sNameOfWorkSheet)
        Set rng = ws.Cells(lRowCounter, 3).Resize(, lColumns - 2)
        lnonEmptyColumnCount = WorksheetFunction.CountA(rng)
 
        If lnonEmptyColumnCount &gt; 1 Then
            sX = sX &amp; "[" &amp; Trim(Worksheets(sNameOfWorkSheet).Range("A1").Cells(lRowCounter, 2).Value) &amp; "] , "
        Else
'            sX = sX
        End If
        
    Next lRowCounter

    fn_CheckForOneAndOnlyOneValuePerRow = sX
    '=========================
      Exit Function
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "GetTheMatrixSizes - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_MISC</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Select_Just_Filled_Cells_andCheckThem</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_MISC</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Select_Just_Filled_Cells_andCheckThem</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Check all cells versus just cells that are filled



'must select cell A1 for it to work
Sub CheckAllCells()
' Slow version of the macro shown on page 360
Dim TheRange As Range
Dim oCell As Range

    StartTime = Now
    Ctr = 0
    Set TheRange = Range("A1:Z20000")
    For Each oCell In TheRange
        If oCell.Text = "Your Text" Then
            '//
            Ctr = Ctr + 1
        End If
    Next oCell
    EndTime = Now
    
    Msg = "Checked " &amp; TheRange.Cells.Count &amp; " cells. Found " &amp; Ctr &amp; " matches. Duration = " &amp; Format(EndTime - StartTime, "h:mm:ss")
    MsgBox Msg
    
End Sub

Sub CheckSpecialCellsOnly()
    ' Based on Page 360

Dim TheRange As Range
Dim oCell As Range

    StartTime = Now
    Ctr = 0
    
    Set TheRange = Range("A1:Z20000").SpecialCells(xlCellTypeConstants, xlTextValues)
    
    For Each oCell In TheRange
        If oCell.Text = "Your Text" Then
            '//
            Ctr = Ctr + 1
        End If
    Next oCell
    EndTime = Now
    
    Msg = "Checked " &amp; TheRange.Cells.Count &amp; " cells. Found " &amp; Ctr &amp; " matches. Duration = " &amp; Format(EndTime - StartTime, "h:mm:ss")
    MsgBox Msg

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_RANGE_Manipulation_Maneuvering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CheckForMoreThanOneValuePerRow</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_RANGE_Manipulation_Maneuvering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CheckForMoreThanOneValuePerRow</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Function fn_CheckForOneAndOnlyOneValuePerRow(sNameOfWorkSheet As String, lRows As Long, lColumns As Long) As String
    On Error GoTo ErrorHandler
    
    '=========================
    
    Dim sX As String
    Dim lRowCounter As Long
    Dim lnonEmptyColumnCount As Long
    
    sX = ""
           
    For lRowCounter = 3 To lRows
        Dim rng As Range
        Dim ws As Worksheet
        Set ws = Sheets(sNameOfWorkSheet)
        Set rng = ws.Cells(lRowCounter, 3).Resize(, lColumns - 2)
        lnonEmptyColumnCount = WorksheetFunction.CountA(rng)
 
        If lnonEmptyColumnCount &gt; 1 Then
            sX = sX &amp; "[" &amp; Trim(Worksheets(sNameOfWorkSheet).Range("A1").Cells(lRowCounter, 2).Value) &amp; "] , "
        Else
'            sX = sX
        End If
        
    Next lRowCounter

    fn_CheckForOneAndOnlyOneValuePerRow = sX
    '=========================
      Exit Function
            
ErrorHandler:
        Select Case Err.Number
            Case Else
                MsgBox "GetTheMatrixSizes - Error: " &amp; Err.Number &amp; " " &amp; Err.Description
        End Select
End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_RANGE_Manipulation_Maneuvering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Offset</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_RANGE_Manipulation_Maneuvering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Offset</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Set rngHeaderOfData = Worksheets("R2_to_R1_Mapping").Range("A1").Offset(0, iColumnCounter - 1)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_RANGE_Manipulation_Maneuvering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Range_References</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_RANGE_Manipulation_Maneuvering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Range_References</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Set rngX = Range(Worksheets(sSheetName).Cells(2, 1), Worksheets(sSheetName).Cells(2, 34))

/////////////////////
    'refer to A1
    Range ("A1")
    Worksheets(1).Range ("A1")
    
    'These are equivalent:
    Range ("D5")
    [D5]
    Range("B3").Range ("C3")
    Range("A1").Offset(4,3)
    Range("MyRange")    'assuming that D5 has a name of 'MrRaange'
    [MyRange]
    
    'Multicell Range
    Range ("A1:D5")
    [A1:D5]
    Range("A1:D5", "G6:I17") = ""
    [A1:D5, G6:I17]

	'Matrix Range as offset
	////////////////////
    Dim rngX As Range
    Set rngX = Range(Worksheets(sSheetName).Range("A1"), Worksheets(sSheetName).Cells(lNoOfRows - 1, lNoOfColumns - 1))
    arrMatrixToPopulate = rngX	
	////////////////////	


'This one pickes the first five columns
//////////////

Sub FirstFiveColumnsOfEachRow()

    Dim FinalRow As Integer
    Dim i As Integer
    Dim sX As String
    
    Sheet1.Select
'    FinalRow = Cells(Rows.Count, 1).End(xlUp).Row
    FinalRow = 10
'    sX = ThisWorkbook.FullName        '&lt;== This did not work
'    sX = ThisWorkbook.FullNameURLEncoded        '&lt;== This did not work

    

    For i = 1 To FinalRow
        Cells(i, "A").Resize(, 5).Value = i                 '&lt;== This is one way
        Range("A" &amp; i &amp; ":E" &amp; i).Font.Bold = True          '&lt;== This is another way
'        Workbooks("C:\junk.xlsm").Worksheets("Sheet2").Range("A" &amp; i &amp; ":E" &amp; i).Value = "It Worked: "         '&lt;== This did not work
        Workbooks("junk.xlsm").Worksheets("Sheet2").Range("A" &amp; i &amp; ":E" &amp; i).Value = "It Worked: " &amp; CStr(i)
'        Workbooks("C:\Junk\junk.xlsx").Worksheets("Sheet1").Range("A" &amp; i &amp; ":E" &amp; i).Value = "It Worked: " &amp; CStr(i)        '&lt;== This did not work
'        Workbooks(sX).Worksheets("Sheet3").Range("A" &amp; i &amp; ":E" &amp; i).Value = "It Worked: " &amp; CStr(i)        '&lt;== This did not work

'        ChDir ("C:\Junk")
         Workbooks("C:\Junk\\junk.xlsx").Worksheets("Sheet2").Range("A" &amp; i &amp; ":E" &amp; i).Value = "It Worked: " &amp; CStr(i) '&lt;== This did not work
    Next i


End Sub

//////////////</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Count_occurance_of_specified_character</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Count_occurance_of_specified_character</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'''
''' Returns the count of the specified character in the specified string.
'''
Public Function CountChrInString(Expression As String, Character As String) As Long
'
' ? CountChrInString("a/b/c", "/")
'  2
' ? CountChrInString("a/b/c", "\")
'  0
' ? CountChrInString("//////", "/")
'  6
' ? CountChrInString(" a / b / c ", "/")
'  2
' ? CountChrInString("a/b/c", " / ")
'  0
'
    Dim iResult As Long
    Dim sParts() As String

    sParts = Split(Expression, Character)

    iResult = UBound(sParts, 1)

    If (iResult = -1) Then
    iResult = 0
    End If

    CountChrInString = iResult

End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_USERFORM</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Programatic_CreateUserForm_ComboBox_Cancel_and_OK_Button</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_USERFORM</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Programatic_CreateUserForm_ComboBox_Cancel_and_OK_Button</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit
Sub MakeUserForm()
    'References:
'    Microsoft Visual Basic for Applications Extensibility 5.3
'    Microsoft Forms 2.0 Object Library
     
    Dim MyUserForm As VBComponent
    Dim NewOptionButton As MSForms.OptionButton
    Dim NewCommandButton1 As MSForms.CommandButton
    Dim NewCommandButton2 As MSForms.CommandButton
    Dim MyComboBox As MSForms.ComboBox
    Dim N, X As Integer, MaxWidth As Long
     
     '//First, check the form doesn't already exist
    For N = 1 To ActiveWorkbook.VBProject.VBComponents.Count
        If ActiveWorkbook.VBProject.VBComponents(N).Name = "NewForm" Then
            ShowForm
            Exit Sub
        Else
        End If
    Next N
     
     '//Make a userform
    Set MyUserForm = ActiveWorkbook.VBProject _
    .VBComponents.Add(vbext_ct_MSForm)
    With MyUserForm
        .Properties("Height") = 100
        .Properties("Width") = 200
        On Error Resume Next
        .Name = "NewForm"
        .Properties("Caption") = "Here is your user form"
    End With
     
     '//Add a Cancel button to the form
    Set NewCommandButton1 = MyUserForm.designer.Controls.Add("forms.CommandButton.1")
    With NewCommandButton1
        .Caption = "Cancel"
        .Height = 18
        .Width = 44
        .Left = MaxWidth + 147
        .Top = 6
    End With
     
     '//Add an OK button to the form
    Set NewCommandButton2 = MyUserForm.designer.Controls.Add("forms.CommandButton.1")
    With NewCommandButton2
        .Caption = "OK"
        .Height = 18
        .Width = 44
        .Left = MaxWidth + 147
        .Top = 28
    End With
     
     '//Add code on the form for the CommandButtons
    With MyUserForm.codemodule
        X = .CountOfLines
        .insertlines X + 1, "Sub CommandButton1_Click()"
        .insertlines X + 2, "    Unload Me"
        .insertlines X + 3, "End Sub"
        .insertlines X + 4, ""
        .insertlines X + 5, "Sub CommandButton2_Click()"
        .insertlines X + 6, "    Unload Me"
        .insertlines X + 7, "End Sub"
    End With
     
     '//Add a combo box on the form
    Set MyComboBox = MyUserForm.designer.Controls.Add("Forms.ComboBox.1")
    With MyComboBox
        .Name = "Combo1"
        .Left = 10
        .Top = 10
        .Height = 16
        .Width = 100
    End With
     
    ShowForm
End Sub
 
Sub ShowForm()
    NewForm.Show
End Sub

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_USERFORM</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>PROGRAMMATIC_Comboboxs_GoodWayToAddCodeToUserForm</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_USERFORM</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>PROGRAMMATIC_Comboboxs_GoodWayToAddCodeToUserForm</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'1] code behind the worksheet
'2] Code on the module
/////////////////////////
'NOTE: use of .InsertLines for putting the code on code of the form




'1] code behind the worksheet
/////////////////////////////

Private mintLeft As Integer
Private mintTop As Integer
Private Sub CommandButton1_Click()

Dim frm As UserForm2

Set frm = New UserForm2
frm.Show vbModeless
mintLeft = mintLeft + 100
mintTop = mintTop + 100

frm.Left = mintLeft
frm.Top = mintTop
End Sub



'2] Code on the module
/////////////////////
Option Explicit

'Passed back to the function from the UserForm
Public GETOPTION_RET_VAL As Variant


Sub Demo1()
    Dim Ops(1 To 12) As String
    Dim i As Integer
    Dim UserChoice As Variant
'   Create an array of month names
    For i = 1 To 12
        Ops(i) = Format(DateSerial(1, i, 1), "mmmm")
    Next i
    UserChoice = GetCombo(Ops, 1, "Select a month")
    If UserChoice = False Then
        Range("A6") = ""
    Else
        Range("A6") = Ops(UserChoice)
    End If
End Sub

Function GetCombo(OpArray, Default, Title)
    Dim TempForm  'As VBComponent
    Dim NewOptionButton As MSForms.OptionButton
    Dim NewCommandButton1 As MSForms.CommandButton
    Dim NewCommandButton2 As MSForms.CommandButton
    Dim NewComboBox As MSForms.ComboBox
    Dim TextLocation As Integer
    Dim X As Integer, i As Integer, TopPos As Integer
    Dim MaxWidth As Long
    Dim WasVisible As Boolean
    
'   Hide VBE window to prevent screen flashing
    'Application.VBE.MainWindow.Visible = False

'   Create the UserForm
    Set TempForm = ThisWorkbook.VBProject.VBComponents.Add(3)
    TempForm.Properties("Width") = 800
    
'   Add the OptionButtons
    TopPos = 4
    MaxWidth = 0 'Stores width of widest OptionButton
    For i = LBound(OpArray) To UBound(OpArray)
        Set NewComboBox = TempForm.Designer.Controls.Add("forms.combobox.1")
        With NewComboBox
            .Width = 50
            .Name = OpArray(i)
            .Value = OpArray(i)
            .Height = 15
            .Left = 8
            .Top = TopPos
            .Tag = i
            .AutoSize = False
            If .Width &gt; MaxWidth Then MaxWidth = .Width
        End With
        TopPos = TopPos + 15
    Next i
    
'   Add the Cancel button
    Set NewCommandButton1 = TempForm.Designer.Controls.Add("forms.CommandButton.1")
    With NewCommandButton1
        .Caption = "Cancel"
        .Height = 18
        .Width = 44
        .Left = MaxWidth + 12
        .Top = 6
    End With

'   Add the OK button
    Set NewCommandButton2 = TempForm.Designer.Controls.Add("forms.CommandButton.1")
    With NewCommandButton2
        .Caption = "OK"
        .Height = 18
        .Width = 44
        .Left = MaxWidth + 12
        .Top = 28
    End With

'   Add event-hander subs for the CommandButtons
    With TempForm.CodeModule
        X = .CountOfLines
        .InsertLines X + 1, "Sub CommandButton1_Click()"
        .InsertLines X + 2, "  GETOPTION_RET_VAL=False"
        .InsertLines X + 3, "  Unload Me"
        .InsertLines X + 4, "End Sub"
        
        .InsertLines X + 5, "Sub CommandButton2_Click()"
        .InsertLines X + 6, "  Dim ctl"
        .InsertLines X + 7, "  GETOPTION_RET_VAL = False"
        .InsertLines X + 8, "  For Each ctl In Me.Controls"
        .InsertLines X + 9, "    If ctl.Tag &lt;&gt; """" Then If ctl Then GETOPTION_RET_VAL = ctl.Tag"
        .InsertLines X + 10, "  Next ctl"
        .InsertLines X + 11, "  Unload Me"
        .InsertLines X + 12, "End Sub"
    End With
    
'   Adjust the form
    With TempForm
        .Properties("Caption") = Title
        .Properties("Width") = NewCommandButton1.Left + NewCommandButton1.Width + 10
        If .Properties("Width") &lt; 160 Then
            .Properties("Width") = 160
            NewCommandButton1.Left = 106
            NewCommandButton2.Left = 106
        End If
        .Properties("Height") = TopPos + 24
    End With

'   Show the form
    VBA.UserForms.Add(TempForm.Name).Show

'   Delete the form
    ThisWorkbook.VBProject.VBComponents.Remove VBComponent:=TempForm
    
'   Pass the selected option back to the calling procedure
    GetCombo = GETOPTION_RET_VAL
End Function

 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_VLookup</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>VLookup_InCode_or_InFormula</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_VLookup</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>VLookup_InCode_or_InFormula</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


///////////'Problem
'I have a two dimensional array that I need to search, and copy a value to the sheet I am using.

Example Array
code1 name1
code2 name1
code3 name4

Sheet
ColumnA ColumnB
code2
code4
code1
code3

'I need to fill in columnB with the corresponding name, leaving it blank if the code does not exisit in the array.


/////////'Solution
'If your array is B2:C4 and your list starts in A8

Dim lastrow As Long, r As Long 
 
lastrow = Sheet1.Cells(Rows.Count, 1).End(xlUp).Row 
 
On Error Resume Next ' in case vlookup error
For r = 8 To lastrow 
    Cells(r, 2) = WorksheetFunction.VLookup(Cells(r, 1), Range("B2:C4"), 2, False) 
    
   ' A reference to Sheet2 would look like:

'	=VLOOKUP(1,Sheet2!A1:B4,2. False)
    
    
Next r 

'If you wanted to have the formulae in the sheet you could substitute this line and use conditional formatting to hide any errors.

Cells(r, 2).Formula = "=VLookup(A" &amp; r &amp; ",B2:C4, 2, False)" 

'A reference to Sheet2 would look like:

Cells(r, 2).Formula = "=VLookup(Sheet2!A" &amp; r &amp; ",B2:C4, 2, False)" 
/////////////////////////////////////////////////////////</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_WORKBOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CreateNewWB</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_WORKBOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CreateNewWB</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Sub ListComments()
    ' Page 337-339
    Dim wb As Workbook
    Dim ws As Worksheet              '&lt;== DIM
    
    Dim cmt As Comment
    
    Dim cmtCount As Long
    
    cmtCount = 2
    
    On Error Resume Next
        Set ws = ActiveSheet
            If ws Is Nothing Then Exit Sub
    On Error GoTo 0
    
    Application.ScreenUpdating = False
    
    Set wb = Workbooks.Add(xlWorksheet)              '&lt;== Add
    
    With wb.Sheets(1)              '&lt;== Write to new WB
        .Range("$A$1") = "Author"
        .Range("$B$1") = "Book"
        .Range("$C$1") = "Sheet"
        .Range("$D$1") = "Range"
        .Range("$E$1") = "Comment"
    End With
    
    For Each cmt In ws.Comments
        With wb.Sheets(1)
            .Cells(cmtCount, 1) = cmt.author
            .Cells(cmtCount, 2) = cmt.Parent.Parent.Parent.Name
            .Cells(cmtCount, 3) = cmt.Parent.Parent.Name
            .Cells(cmtCount, 4) = cmt.Parent.Address
            .Cells(cmtCount, 5) = CleanComment(cmt.author, cmt.Text)
        End With
    
        cmtCount = cmtCount + 1
    Next
    
    wb.Sheets(1).UsedRange.WrapText = False
    
    Application.ScreenUpdating = True

    Set ws = Nothing
    Set wb = Nothing               '&lt;== Even though it is set to nothing the WB now exists on the screen
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_WORKBOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ReferenceWorkBooks</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_WORKBOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ReferenceWorkBooks</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
/////////////////////////////////////////////////////////////
Function GetActiveWB() As String

  GetActiveWB = ActiveWorkbook.Path &amp; "\" &amp; ActiveWorkbook.Name

End Function
/////////////////////////////////////////////////////////////

Function GetThisWB() As String

  GetThisWB = ThisWorkbook.Path &amp; "\" &amp; ThisWorkbook.Name

End Function

/////////////////////////////////////////////////////////////
'Reference workbooks in the Workbooks collection
'The Workbooks collection contains all the open Workbook objects.

Private Sub UserForm_Activate()

  'Populate list box with names of open workbooks.

  Dim wb As Workbook

  For Each wb In Workbooks

    ListBox1.AddItem wb.Name

  Next wb

End Sub
/////////////////////////////////////////////////////////////
'opening all of the workbooks in a specified folder is a bit harder, 
'as you can see in the following subprocedure:

Sub OpenAllWB()

  'Open all workbooks in specified folder.

  Dim i As Integer

  With Application.FileSearch

    .LookIn = "C:\Examples"

    .FileType = msoFileTypeExcelWorkbooks

      'There are wb's

      If .Execute &gt; 0 Then

        For i = 1 To .FoundFiles.Count

          Workbooks.Open (.FoundFiles(i))

        Next i

      'There are no wb's

      Else

        MsgBox "There are no workbooks to open", vbOKOnly

      End If

  End With

End Sub

/////////////////////////////////////////////////////
'Closing all the open workbooks is a bit easier than opening them
Sub CloseAllWB()

  'Close all open workbooks.

    Workbooks.Close

End Sub

/////////////////////////////////////////////////////////////
'Open a specific WorkBook, but apparently only in the same folder:

Function ActivateWB(wbname As String)

  'Open wbname.

  Workbooks(wbname).Activate

End Function

To execute it, you simply pass the name of the workbook you want to activate as follows:

ActivateWB("HumanResources.xls")

/////////////////////////////////////////////////////////////

'The following function also uses the Workbooks property to determine whether a specific workbook is currently open:

Function IsWBOpen(wbname As String) As Boolean

  'Open workbook.

  Dim wb As Workbook

  On Error Resume Next

  Set wb = Workbooks(wbname)

  IsWBOpen = Not wb Is Nothing

End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_EXCEL_WORKBOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>WeirdWayToOpen_Workbook</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_EXCEL_WORKBOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>WeirdWayToOpen_Workbook</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Sub DoesWorkBookExist() 
     
    Dim i As Integer 
     
    With Application.FileSearch 
        .LookIn = "C:\MyDocuments" 
        '* represents wildcard characters 
        .Filename = "Book*.xls" 
        If .Execute &gt; 0 Then 'Workbook exists 
        MsgBox "There is a Workbook." 
    Else 'There Is Not a Workbook 
        MsgBox "The Workbook does not exist" 
    End If 
End With 
End Sub 


'With a wild card *

Sub DoesWorkBookExist() 
    Dim i As Integer 
    With Application.FileSearch 
        .LookIn = "C:\MyDocuments" 
        '* represents wildcard characters 
        .Filename = "Book*.xls" 
        If .Execute &gt; 0 Then 'Workbook exists 
        For i = 1 To .FoundFiles.Count 
            Workbooks.Open (.FoundFiles(i)) 
        Next i 
    End If 
End With 
End Sub </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_LOOPs</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>For_To_Next</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_LOOPs</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>For_To_Next</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>For counter = start To end [Step step]
[statements]
[Exit For]
[statements]

Next [counter]
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name> info on currently selected email using the Outlook Object Model</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name> info on currently selected email using the Outlook Object Model</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

' VBA Script that gets info on the currently selected email using the Outlook Object Model
' (see other scripts a http://www.GregThatcher.com for other ways to get email properties)
' Use Tools-&gt;Macro-&gt;Security to allow Macros to run, then restart Outlook
' Run Outlook, Press Alt+F11 to open VBA
' Programming by Greg Thatcher, http://www.GregThatcher.com

Public Sub GetCurrentEmailInfo()
    Dim Session As Outlook.NameSpace
    Dim currentExplorer As Explorer
    Dim Selection As Selection
    Dim currentItem As Object
    Dim currentMail As MailItem
    Dim report As String
    Dim currentAction As Action
    Dim currentConflict As Conflict
    Dim currentLink As Link
    Dim currentRecipient As Recipient
    
    Set currentExplorer = Application.ActiveExplorer
    Set Selection = currentExplorer.Selection
    
    'for all items do...
    For Each currentItem In Selection
        If currentItem.Class = olMail Then
            Set currentMail = currentItem
            report = report &amp; AddToReportIfNotBlank("EntryID: ", currentMail.entryID) &amp; vbCrLf
            report = report &amp; "Actions: " &amp; vbCrLf
            For Each currentAction In currentMail.Actions
                report = report &amp; vbTab &amp; currentAction.Name &amp; vbCrLf
            Next
            report = report &amp; vbCrLf
            
            report = report &amp; AddToReportIfNotBlank("AlternateRecipientAllowed: ", currentMail.AlternateRecipientAllowed)
            report = report &amp; AddToReportIfNotBlank("Application: ", currentMail.Application.Name)
            report = report &amp; AddToReportIfNotBlank("AutoForwarded: ", currentMail.AutoForwarded)
            report = report &amp; AddToReportIfNotBlank("AutoResolvedWinner: ", currentMail.AutoResolvedWinner)
            report = report &amp; AddToReportIfNotBlank("BCC: ", currentMail.BCC)
            report = report &amp; AddToReportIfNotBlank("BillingInformation: ", currentMail.BillingInformation)
            report = report &amp; AddToReportIfNotBlank("BodyFormat: ", currentMail.BodyFormat)
            
            report = report &amp; AddToReportIfNotBlank("Categories: ", currentMail.Categories)
            report = report &amp; AddToReportIfNotBlank("CC: ", currentMail.CC)
            report = report &amp; AddToReportIfNotBlank("Class: ", currentMail.Application.Class)
            report = report &amp; AddToReportIfNotBlank("Companies: ", currentMail.Companies)
            
            If currentMail.Conflicts.Count &gt; 0 Then
                report = report &amp; "Conflicts: " &amp; vbCrLf
                For Each currentConflict In currentMail.Conflicts
                    report = report &amp; vbTab &amp; currentConflict.Name &amp; vbCrLf
                Next
                report = report &amp; vbCrLf
            End If
            
            
            report = report &amp; AddToReportIfNotBlank("ConversationIndex: ", currentMail.ConversationIndex)
            report = report &amp; AddToReportIfNotBlank("ConversationTopic: ", currentMail.ConversationTopic)
            report = report &amp; AddToReportIfNotBlank("CreationTime: ", currentMail.CreationTime)
            report = report &amp; AddToReportIfNotBlank("DeferredDeliveryTime: ", currentMail.DeferredDeliveryTime)
            
            report = report &amp; AddToReportIfNotBlank("DeleteAfterSubmit: ", currentMail.DeleteAfterSubmit)
            report = report &amp; AddToReportIfNotBlank("DownloadState: ", currentMail.DownloadState)
            report = report &amp; AddToReportIfNotBlank("Entry ID: ", currentMail.entryID)

            report = report &amp; AddToReportIfNotBlank("ExpiryTime: ", currentMail.ExpiryTime)
            report = report &amp; AddToReportIfNotBlank("FlagRequest: ", currentMail.FlagRequest)
            report = report &amp; AddToReportIfNotBlank("FormDescription: ", currentMail.FormDescription)
            report = report &amp; AddToReportIfNotBlank("Importance: ", currentMail.Importance)
            report = report &amp; AddToReportIfNotBlank("InternetCodepage: ", currentMail.InternetCodepage)
            report = report &amp; AddToReportIfNotBlank("IsConflict: ", currentMail.IsConflict)
            ' Not available for Outlook 2003
            'report = report &amp; AddToReportIfNotBlank("IsMarkedAsTask: ", currentMail.IsMarkedAsTask)
            'report = report &amp; AddToReportIfNotBlank("LastModificationTime: ", currentMail.ItemProperties)

            report = report &amp; AddToReportIfNotBlank("LastModificationTime: ", currentMail.LastModificationTime)
            
            'If currentMail.Links.Count &gt; 0 Then
            '    report = report &amp; "Links: " &amp; vbCrLf
            '    For Each currentLink In currentMail.Links
            '        report = report &amp; vbTab &amp; currentLink.Name &amp; vbCrLf
            '    Next
            '    report = report &amp; vbCrLf
            'End If

            report = report &amp; AddToReportIfNotBlank("MarkForDownload: ", currentMail.MarkForDownload)
            report = report &amp; AddToReportIfNotBlank("MessageClass: ", currentMail.MessageClass)
            report = report &amp; AddToReportIfNotBlank("Mileage: ", currentMail.Mileage)
            report = report &amp; AddToReportIfNotBlank("NoAging: ", currentMail.NoAging)
            report = report &amp; AddToReportIfNotBlank("OriginatorDeliveryReportRequested: ", currentMail.OriginatorDeliveryReportRequested)
            report = report &amp; AddToReportIfNotBlank("OutlookInternalVersion: ", currentMail.OutlookInternalVersion)
            report = report &amp; AddToReportIfNotBlank("OutlookVersion: ", currentMail.OutlookVersion)
            report = report &amp; AddToReportIfNotBlank("Permission: ", currentMail.Permission)
            report = report &amp; AddToReportIfNotBlank("PermissionService: ", currentMail.PermissionService)
            'report = report &amp; AddToReportIfNotBlank("Permission: ", currentMail.PropertyAccessor)
            report = report &amp; AddToReportIfNotBlank("ReadReceiptRequested: ", currentMail.ReadReceiptRequested)
            'report = report &amp; AddToReportIfNotBlank("ReceivedByEntryID: ", currentMail.ReceivedByEntryID)
            report = report &amp; AddToReportIfNotBlank("ReceivedByName: ", currentMail.ReceivedByName)
            'report = report &amp; AddToReportIfNotBlank("ReceivedOnBehalfOfEntryID: ", currentMail.ReceivedOnBehalfOfEntryID)
            report = report &amp; AddToReportIfNotBlank("ReceivedOnBehalfOfName: ", currentMail.ReceivedOnBehalfOfName)
            report = report &amp; AddToReportIfNotBlank("ReceivedTime: ", currentMail.ReceivedTime)
            report = report &amp; AddToReportIfNotBlank("RecipientReassignmentProhibited: ", currentMail.RecipientReassignmentProhibited)
            
            report = report &amp; "Recipients: " &amp; vbCrLf
            For Each currentRecipient In currentMail.Recipients
                report = report &amp; vbTab &amp; "Name: " &amp; currentRecipient.Name &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "Address: " &amp; currentRecipient.Address &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "AddressEntry: " &amp; currentRecipient.AddressEntry &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "AutoResponse: " &amp; currentRecipient.AutoResponse &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "Class: " &amp; currentRecipient.Class &amp; vbCrLf
                'report = report &amp; vbTab &amp; vbTab &amp; "DisplayType: " &amp; currentRecipient.DisplayType &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "EntryID: " &amp; currentRecipient.entryID &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "Index: " &amp; currentRecipient.Index &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "MeetingResponseStatus: " &amp; currentRecipient.MeetingResponseStatus &amp; vbCrLf
                'report = report &amp; vbTab &amp; vbTab &amp; "Parent: " &amp; currentRecipient.Parent &amp; vbCrLf
                'report = report &amp; vbTab &amp; vbTab &amp; "PropertyAccessor: " &amp; currentRecipient.PropertyAccessor &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "Resolved: " &amp; currentRecipient.Resolved &amp; vbCrLf
                'report = report &amp; vbTab &amp; vbTab &amp; "Session: " &amp; currentRecipient.Session &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "TrackingStatus: " &amp; currentRecipient.TrackingStatus &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "TrackingStatusTime: " &amp; currentRecipient.TrackingStatusTime &amp; vbCrLf
                report = report &amp; vbTab &amp; vbTab &amp; "Type: " &amp; currentRecipient.Type &amp; vbCrLf
            Next
            report = report &amp; vbCrLf

            report = report &amp; AddToReportIfNotBlank("ReminderOverrideDefault: ", currentMail.ReminderOverrideDefault)
            report = report &amp; AddToReportIfNotBlank("ReminderPlaySound: ", currentMail.ReminderPlaySound)
            report = report &amp; AddToReportIfNotBlank("ReminderSet: ", currentMail.ReminderSet)
            report = report &amp; AddToReportIfNotBlank("ReminderSoundFile: ", currentMail.ReminderSoundFile)
            report = report &amp; AddToReportIfNotBlank("ReminderTime: ", currentMail.ReminderTime)
            report = report &amp; AddToReportIfNotBlank("ReminderTime: ", currentMail.RemoteStatus)

            report = report &amp; AddToReportIfNotBlank("ReplyRecipientNames: ", currentMail.ReplyRecipientNames)
            
            If currentMail.ReplyRecipients.Count &gt; 0 Then
                report = report &amp; "ReplyRecipients: " &amp; vbCrLf
                For Each currentRecipient In currentMail.ReplyRecipients
                    report = report &amp; vbTab &amp; "Name: " &amp; currentRecipient.Name &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "Address: " &amp; currentRecipient.Address &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "AddressEntry: " &amp; currentRecipient.AddressEntry &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "AutoResponse: " &amp; currentRecipient.AutoResponse &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "Class: " &amp; currentRecipient.Class &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "DisplayType: " &amp; currentRecipient.DisplayType &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "EntryID: " &amp; currentRecipient.entryID &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "Index: " &amp; currentRecipient.Index &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "MeetingResponseStatus: " &amp; currentRecipient.MeetingResponseStatus &amp; vbCrLf
                    'report = report &amp; vbTab &amp; vbTab &amp; "Parent: " &amp; currentRecipient.Parent &amp; vbCrLf
                    'report = report &amp; vbTab &amp; vbTab &amp; "PropertyAccessor: " &amp; currentRecipient.PropertyAccessor &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "Resolved: " &amp; currentRecipient.Resolved &amp; vbCrLf
                    'report = report &amp; vbTab &amp; vbTab &amp; "Session: " &amp; currentRecipient.Session &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "TrackingStatus: " &amp; currentRecipient.TrackingStatus &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "TrackingStatusTime: " &amp; currentRecipient.TrackingStatusTime &amp; vbCrLf
                    report = report &amp; vbTab &amp; vbTab &amp; "Type: " &amp; currentRecipient.Type &amp; vbCrLf
                Next
                report = report &amp; vbCrLf
            End If
            
            
            report = report &amp; AddToReportIfNotBlank("Saved: ", currentMail.Saved)
            report = report &amp; AddToReportIfNotBlank("Subject: ", currentMail.Subject)
            report = report &amp; AddToReportIfNotBlank("Submitted: ", currentMail.Submitted)
            ' Not Available for Outlook 2003
            'report = report &amp; AddToReportIfNotBlank("TaskCompletedDate: ", currentMail.TaskCompletedDate)
            ' Not Available for Outlook 2003
            'report = report &amp; AddToReportIfNotBlank("TaskDueDate: ", currentMail.TaskDueDate)
            ' Not Available for Outlook 2003
            'report = report &amp; AddToReportIfNotBlank("TaskStartDate: ", currentMail.TaskStartDate)
            ' Not Available for Outlook 2003
            'report = report &amp; AddToReportIfNotBlank("TaskSubject: ", currentMail.TaskSubject)
            report = report &amp; AddToReportIfNotBlank("To: ", currentMail.To)
            ' Not Available for Outlook 2003
            ' report = report &amp; AddToReportIfNotBlank("ToDoTaskOrdinal: ", currentMail.ToDoTaskOrdinal)
            report = report &amp; AddToReportIfNotBlank("UnRead: ", currentMail.UnRead)
            'report = report &amp; AddToReportIfNotBlank("UserProperties: ", currentMail.UserProperties)
            report = report &amp; AddToReportIfNotBlank("VotingOptions: ", currentMail.VotingOptions)
            report = report &amp; AddToReportIfNotBlank("VotingResponse: ", currentMail.VotingResponse)
            
            report = report &amp; vbCrLf
            report = report &amp; vbCrLf
            report = report &amp; "Body: " &amp; vbCrLf
            report = report &amp; currentMail.Body &amp; vbCrLf
            report = report &amp; vbCrLf
            report = report &amp; vbCrLf
            report = report &amp; "HTML Body: " &amp; vbCrLf
            report = report &amp; currentMail.HTMLBody &amp; vbCrLf
            report = report &amp; vbCrLf
            report = report &amp; vbCrLf
            report = report &amp; vbCrLf
            report = report &amp; vbCrLf
        End If
    Next
    
    Call CreateReportAsEmail("Current Email Report", report)
    
End Sub

Private Function AddToReportIfNotBlank(FieldName As String, FieldValue As String)
    AddToReportIfNotBlank = ""
    If (FieldValue &lt;&gt; "") Then
        AddToReportIfNotBlank = FieldName &amp; " : " &amp; FieldValue &amp; vbCrLf
    End If
    
End Function

' VBA SubRoutine which displays a report inside an email
' Programming by Greg Thatcher, http://www.GregThatcher.com
Public Sub CreateReportAsEmail(Title As String, report As String)
    On Error GoTo On_Error

    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As AddressEntry
    Dim Inbox

    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")

    mail.Subject = Title
    mail.Body = report

    mail.Save
    mail.Display
    

Exiting:
        Set Session = Nothing
        Exit Sub

On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name> info on currently selected email using various Property Syntaxes (DASL)</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name> info on currently selected email using various Property Syntaxes (DASL)</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

' VBA Script that gets info on the currently selected email using propertyAccessor and various syntaxes
' (see other scripts at http://www.GregThatcher.com for other ways to get email properties)
' Property Tag Syntax looks like this http://schemas.microsoft.com/mapi/proptag/0x0005000b
' Property Tag Syntax is used for Outlook 'Properties' (defined by Outlook Object Model)
'
' Property ID Syntax looks like this http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8586001f
' Property ID Syntax is used for MAPI Named Properties (optional Outlook properties that can't be deleted) and UserProperties (properties you can add which are visible to the user)
'
' Named Property Syntax looks like this http://schemas.microsoft.com/mapi/string folloowed by a property name
' Named Property Syntax is used to create and view 'Named Properties" (properties you can create, but which are not visible to the user)
'
' Office document syntax looks like this: urn:schemas-microsoft-com:office:outlook#source-table-label
'
' Use Tools-&gt;Macro-&gt;Security to allow Macros to run, then restart Outlook
' Run Outlook, Press Alt+F11 to open VBA
' Programming by Greg Thatcher, http://www.GregThatcher.com
' THIS SCRIPT WILL ONLY RUN ON OUTLOOK 2007 OR LATER (it won't work on Outlook 2003 -- there is no propertyAccessor)
'
' To find the DASL definition of Outlook Properties, use the method described in Professional Outlook 2007 Programming (Programmer to Programmer) by Ken Slovak
' From the 'Views' menu, create a new view (but don't save it)
' Click on the 'Advanced' tab, and choose 'Filter'
' Choose a Field from the 'Field' dropdown, also choose a condition and value
' Click on the 'Sql tab'
' Check the 'Edit these Criteria' checkbox
'

Public Sub GetCurrentMailInfoUsingpropertyAccessor()
    Dim Session As Outlook.NameSpace
    Dim currentExplorer As Explorer
    Dim Selection As Selection
    Dim currentItem As Object
    Dim currentMail As MailItem
    Dim report As String
    Dim propertyAccessor As Outlook.PropertyAccessor
    Dim stringArray() As String
    Dim index
    Dim currentString
    Dim tempVal
    
    Set currentExplorer = Application.ActiveExplorer
    Set Selection = currentExplorer.Selection
    
    'for all items do...
    For Each currentItem In Selection
        If currentItem.Class = olMail Then
            Set currentMail = currentItem
            
            Set propertyAccessor = currentMail.PropertyAccessor
    
            
        
            report = report &amp; AddToReportIfNotBlank("Auto Forwarded", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x0005000b")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Bcc", propertyAccessor.GetProperty("urn:schemas:calendar:resources")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Billing Information", propertyAccessor.GetProperty("urn:schemas:contacts:billinginformation")) &amp; vbCrLf
            stringArray() = propertyAccessor.GetProperty("urn:schemas-microsoft-com:office:office#Keywords")
            For index = LBound(stringArray) To UBound(stringArray)
                report = report &amp; "Categories (" &amp; index &amp; ") " &amp; stringArray(index) &amp; vbCrLf
            Next index
            report = report &amp; AddToReportIfNotBlank("Cc", propertyAccessor.GetProperty("urn:schemas:httpmail:displaycc")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Changed By", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x3ffa001f")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Contacts", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8586001f")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Conversation", propertyAccessor.GetProperty("urn:schemas:httpmail:thread-topic")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Created", propertyAccessor.GetProperty("urn:schemas:calendar:created")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Defer Until", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/deferred-delivery-iso")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Do Not AutoArchive", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/850e000b")) &amp; vbCrLf

            report = report &amp; AddToReportIfNotBlank("Due Date", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062003-0000-0000-C000-000000000046}/81050040")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("E-mail Account", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8580001f")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Expires", propertyAccessor.GetProperty("urn:schemas:mailheader:expiry-date")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Flag Complated Date", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x10910040")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Flag Status", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x10900003")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Follow Up Flag", propertyAccessor.GetProperty("urn:schemas:httpmail:messageflag")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("From", propertyAccessor.GetProperty("urn:schemas:httpmail:fromname")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Have Replies Sent To", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x0050001f")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("IMAP Status", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/85700003")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Importance", propertyAccessor.GetProperty("urn:schemas:httpmail:importance")) &amp; vbCrLf
            'report = report &amp; AddToReportIfNotBlank("In Folder", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x0e05001f")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("InfoPath Form Type", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/85b1001f")) &amp; vbCrLf
            'report = report &amp; AddToReportIfNotBlank("Message", propertyAccessor.GetProperty("urn:schemas:httpmail:textdescription")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Message Class", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x001a001e")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Mileage", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/mileage")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Modified", propertyAccessor.GetProperty("DAV:getlastmodified")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Originator Delivery Requested", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/deliveryreportrequested")) &amp; vbCrLf
            'report = report &amp; AddToReportIfNotBlank("Outlook Data File", propertyAccessor.GetProperty("urn:schemas-microsoft-com:office:outlook#source-table-label")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Outlook Internal Version", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/85520003")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Outlook Version", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8554001f")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Receipt Requested", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/readreceiptrequested")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Received", propertyAccessor.GetProperty("urn:schemas:httpmail:datereceived")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Received Representing Name", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x0044001f")) &amp; vbCrLf
            'report = report &amp; AddToReportIfNotBlank("Recipient Name", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/received_by_name")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Relevance", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x10840003")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Reminder", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8503000b")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Remote Status", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/85110003")) &amp; vbCrLf
            'report = report &amp; AddToReportIfNotBlank("Retrieval Time", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062014-0000-0000-C000-000000000046}/8f040003")) &amp; vbCrLf
            'report = report &amp; AddToReportIfNotBlank("RSS Feed", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062041-0000-0000-C000-000000000046}/8904001f")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Sensitivity", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/sensitivity-long")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Sent", propertyAccessor.GetProperty("urn:schemas:httpmail:date")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Signed By", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00020328-0000-0000-C000-000000000046}/9104001f")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Start Date", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062003-0000-0000-C000-000000000046}/81040040")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Subject", propertyAccessor.GetProperty("urn:schemas:httpmail:subject")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Task Subject", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/85a4001f")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("To", propertyAccessor.GetProperty("urn:schemas:httpmail:displayto")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Tracking Status", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{0006200B-0000-0000-C000-000000000046}/88090003")) &amp; vbCrLf
            report = report &amp; AddToReportIfNotBlank("Voting Response", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8524001f")) &amp; vbCrLf
           
        End If
    Next
    
    Call CreateReportAsEmail("Email properties from PropertyAccessor using various Property Syntaxes", report)
End Sub


Private Function AddToReportIfNotBlank(FieldName As String, FieldValue)
    AddToReportIfNotBlank = ""
    If (IsNull(FieldValue) Or FieldValue &lt;&gt; "") Then
        AddToReportIfNotBlank = FieldName &amp; " : " &amp; FieldValue &amp; vbCrLf
    End If
    
End Function

' VBA SubRoutine which displays a report inside an email
' Programming by Greg Thatcher, http://www.GregThatcher.com
Public Sub CreateReportAsEmail(Title As String, report As String)
    On Error GoTo On_Error

    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As AddressEntry
    Dim Inbox

    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")

    mail.Subject = Title
    mail.Body = report

    mail.Save
    mail.Display
    

Exiting:
        Set Session = Nothing
        Exit Sub

On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name> list of Outlook Calendar Appointments using the Outlook Object Model</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name> list of Outlook Calendar Appointments using the Outlook Object Model</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

' VBA Script that gets list of Outlook Calendar Appointments and their Properties using the Outlook Object Model
' Use Tools-&gt;Macro-&gt;Security to allow Macros to run, then restart Outlook
' Run Outlook, Press Alt+F11 to open VBA
' Programming by Greg Thatcher, http://www.GregThatcher.com
' See http://www.GregThatcher.com for other ways to get the properties of Appointments
Public Sub GetListOfAppointmentsUsingOutlookObjectModel()
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim Report As String
    Dim AppointmentsFolder As Outlook.Folder
    Dim currentItem As Object
    Dim currentAppointment As AppointmentItem
    Set Session = Application.Session
    
    Set AppointmentsFolder = Session.GetDefaultFolder(olFolderCalendar)
    
    For Each currentItem In AppointmentsFolder.Items
        If (currentItem.Class = olAppointment) Then
            Set currentAppointment = currentItem
            
            'Call AddToReportIfNotBlank(Report, "Actions", currentAppointment.Actions)
            Call AddToReportIfNotBlank(Report, "AllDayEvent", currentAppointment.AllDayEvent)
            ' Call AddToReportIfNotBlank(Report, "Attachments", currentAppointment.Attachments)
            Call AddToReportIfNotBlank(Report, "AutoResolvedWinner", currentAppointment.AutoResolvedWinner)
            Call AddToReportIfNotBlank(Report, "BillingInformation", currentAppointment.BillingInformation)
            Call AddToReportIfNotBlank(Report, "Body", currentAppointment.Body)
            Call AddToReportIfNotBlank(Report, "BusyStatus", currentAppointment.BusyStatus)
            Call AddToReportIfNotBlank(Report, "Categories", currentAppointment.Categories)
            Call AddToReportIfNotBlank(Report, "Class", currentAppointment.Class)
            Call AddToReportIfNotBlank(Report, "Companies", currentAppointment.Companies)
            ' Call AddToReportIfNotBlank(Report, "Conflicts", currentAppointment.Conflicts)
            ' Call AddToReportIfNotBlank(Report, "ConversationID", currentAppointment.ConversationID)
            Call AddToReportIfNotBlank(Report, "ConversationIndex", currentAppointment.ConversationIndex)
            Call AddToReportIfNotBlank(Report, "ConversationTopic", currentAppointment.ConversationTopic)
            Call AddToReportIfNotBlank(Report, "CreationTime", currentAppointment.CreationTime)
            Call AddToReportIfNotBlank(Report, "DownloadState", currentAppointment.DownloadState)
            Call AddToReportIfNotBlank(Report, "Duration", currentAppointment.Duration)
            Call AddToReportIfNotBlank(Report, "End", currentAppointment.End)
            Call AddToReportIfNotBlank(Report, "EndInEndTimeZone", currentAppointment.EndInEndTimeZone)
            Call AddToReportIfNotBlank(Report, "EndTimeZone", currentAppointment.EndTimeZone)
            Call AddToReportIfNotBlank(Report, "EndUTC", currentAppointment.EndUTC)
            
            Call AddToReportIfNotBlank(Report, "EntryID", currentAppointment.EntryID)
            Call AddToReportIfNotBlank(Report, "ForceUpdateToAllAttendees", currentAppointment.ForceUpdateToAllAttendees)
            Call AddToReportIfNotBlank(Report, "FormDescription", currentAppointment.FormDescription)
            Call AddToReportIfNotBlank(Report, "GlobalAppointmentID", currentAppointment.GlobalAppointmentID)
            Call AddToReportIfNotBlank(Report, "Importance", currentAppointment.Importance)
            Call AddToReportIfNotBlank(Report, "InternetCodepage", currentAppointment.InternetCodepage)
            Call AddToReportIfNotBlank(Report, "IsConflict", currentAppointment.IsConflict)
            Call AddToReportIfNotBlank(Report, "IsRecurring", currentAppointment.IsRecurring)
            ' Call AddToReportIfNotBlank(Report, "ItemProperties", currentAppointment.ItemProperties)
            Call AddToReportIfNotBlank(Report, "LastModificationTime", currentAppointment.LastModificationTime)
            
            ' Call AddToReportIfNotBlank(Report, "Links", currentAppointment.Links)
            Call AddToReportIfNotBlank(Report, "Location", currentAppointment.Location)
            Call AddToReportIfNotBlank(Report, "MarkForDownload", currentAppointment.MarkForDownload)
            Call AddToReportIfNotBlank(Report, "MeetingStatus", currentAppointment.MeetingStatus)
            Call AddToReportIfNotBlank(Report, "MeetingWorkspaceURL", currentAppointment.MeetingWorkspaceURL)
            Call AddToReportIfNotBlank(Report, "MessageClass", currentAppointment.MessageClass)
            Call AddToReportIfNotBlank(Report, "Mileage", currentAppointment.Mileage)
            Call AddToReportIfNotBlank(Report, "NoAging", currentAppointment.NoAging)
            Call AddToReportIfNotBlank(Report, "OptionalAttendees", currentAppointment.OptionalAttendees)
            Call AddToReportIfNotBlank(Report, "Organizer", currentAppointment.Organizer)
            
            Call AddToReportIfNotBlank(Report, "OutlookInternalVersion", currentAppointment.OutlookInternalVersion)
            Call AddToReportIfNotBlank(Report, "OutlookVersion", currentAppointment.OutlookVersion)
            ' Call AddToReportIfNotBlank(Report, "Recipients", currentAppointment.Recipients)
            Call AddToReportIfNotBlank(Report, "RecurrenceState", currentAppointment.RecurrenceState)
            Call AddToReportIfNotBlank(Report, "ReminderMinutesBeforeStart", currentAppointment.ReminderMinutesBeforeStart)
            Call AddToReportIfNotBlank(Report, "ReminderOverrideDefault", currentAppointment.ReminderOverrideDefault)
            Call AddToReportIfNotBlank(Report, "ReminderPlaySound", currentAppointment.ReminderPlaySound)
            Call AddToReportIfNotBlank(Report, "ReminderSet", currentAppointment.ReminderSet)
            Call AddToReportIfNotBlank(Report, "ReminderSoundFile", currentAppointment.ReminderSoundFile)
            Call AddToReportIfNotBlank(Report, "ReplyTime", currentAppointment.ReplyTime)
            
            
            Call AddToReportIfNotBlank(Report, "RequiredAttendees", currentAppointment.RequiredAttendees)
            Call AddToReportIfNotBlank(Report, "Resources", currentAppointment.Resources)
            Call AddToReportIfNotBlank(Report, "ResponseRequested", currentAppointment.ResponseRequested)
            Call AddToReportIfNotBlank(Report, "ResponseStatus", currentAppointment.ResponseStatus)
            ' Call AddToReportIfNotBlank(Report, "RTFBody", currentAppointment.RTFBody)
            Call AddToReportIfNotBlank(Report, "Saved", currentAppointment.Saved)
            ' Call AddToReportIfNotBlank(Report, "SendUsingAccount", currentAppointment.SendUsingAccount)
            Call AddToReportIfNotBlank(Report, "Sensitivity", currentAppointment.Sensitivity)
            Call AddToReportIfNotBlank(Report, "Size", currentAppointment.Size)
            Call AddToReportIfNotBlank(Report, "Start", currentAppointment.Start)
            
            Call AddToReportIfNotBlank(Report, "StartTimeZone", currentAppointment.StartTimeZone)
            Call AddToReportIfNotBlank(Report, "StartUTC", currentAppointment.StartUTC)
            Call AddToReportIfNotBlank(Report, "Subject", currentAppointment.Subject)
            Call AddToReportIfNotBlank(Report, "UnRead", currentAppointment.UnRead)
            ' Call AddToReportIfNotBlank(Report, "UserProperties", currentAppointment.UserProperties)
            
            Report = Report &amp; "--------------------------------------------------------------------------------------------------------"
            Report = Report &amp; vbCrLf &amp; vbCrLf
        End If
        
    Next
    
    
    Call CreateReportAsEmail("List of Appointments", Report)
    
Exiting:
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting
    
End Sub

Private Function AddToReportIfNotBlank(Report As String, FieldName As String, FieldValue)
    AddToReportIfNotBlank = ""
    If (IsNull(FieldValue) Or FieldValue &lt;&gt; "") Then
        AddToReportIfNotBlank = FieldName &amp; " : " &amp; FieldValue &amp; vbCrLf
        Report = Report &amp; AddToReportIfNotBlank
    End If
    
End Function

' VBA SubRoutine which displays a report inside an email
' Programming by Greg Thatcher, http://www.GregThatcher.com
Public Sub CreateReportAsEmail(Title As String, Report As String)
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As addressEntry
    Dim Inbox As Outlook.Folder
    
    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")
    
    Set MyAddress = Session.CurrentUser.addressEntry
    mail.Recipients.Add (MyAddress.Address)
    mail.Recipients.ResolveAll
    
    mail.Subject = Title
    mail.Body = Report
    
    mail.Save
    mail.Display
    
    
Exiting:
        Set Session = Nothing
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>list of Outlook Calendar Appointments and uses the Property Accessor</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>list of Outlook Calendar Appointments and uses the Property Accessor</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

' VBA Script that gets list of Outlook Calendar Appointments and their Properties and uses the Property Accessor
' Use Tools-&gt;Macro-&gt;Security to allow Macros to run, then restart Outlook
' Run Outlook, Press Alt+F11 to open VBA
' Programming by Greg Thatcher, http://www.GregThatcher.com
' See http://www.GregThatcher.com for other ways to get the properties of Appointments
Public Sub GetListOfAppointmentsUsingPropertyAccessor()
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim Report As String
    Dim AppointmentsFolder As Outlook.Folder
    Dim currentItem As Object
    Dim currentAppointment As AppointmentItem
    Set Session = Application.Session
    
    Set AppointmentsFolder = Session.GetDefaultFolder(olFolderCalendar)
    
    For Each currentItem In AppointmentsFolder.Items
        If (currentItem.Class = olAppointment) Then
            Set currentAppointment = currentItem
            
            'Call AddToReportIfNotBlank(Report, "Actions", currentAppointment.Actions)
            Call AddToReportIfNotBlank(Report, "AllDayEvent", currentAppointment.AllDayEvent)
            ' Call AddToReportIfNotBlank(Report, "Attachments", currentAppointment.Attachments)
            Call AddToReportIfNotBlank(Report, "AutoResolvedWinner", currentAppointment.AutoResolvedWinner)
            Call AddToReportIfNotBlank(Report, "BillingInformation", currentAppointment.BillingInformation)
            Call AddToReportIfNotBlank(Report, "Body", currentAppointment.Body)
            Call AddToReportIfNotBlank(Report, "BusyStatus", currentAppointment.BusyStatus)
            Call AddToReportIfNotBlank(Report, "Categories", currentAppointment.Categories)
            Call AddToReportIfNotBlank(Report, "Class", currentAppointment.Class)
            Call AddToReportIfNotBlank(Report, "Companies", currentAppointment.Companies)
            ' Call AddToReportIfNotBlank(Report, "Conflicts", currentAppointment.Conflicts)
            ' Call AddToReportIfNotBlank(Report, "ConversationID", currentAppointment.ConversationID)
            Call AddToReportIfNotBlank(Report, "ConversationIndex", currentAppointment.ConversationIndex)
            Call AddToReportIfNotBlank(Report, "ConversationTopic", currentAppointment.ConversationTopic)
            Call AddToReportIfNotBlank(Report, "CreationTime", currentAppointment.CreationTime)
            Call AddToReportIfNotBlank(Report, "DownloadState", currentAppointment.DownloadState)
            Call AddToReportIfNotBlank(Report, "Duration", currentAppointment.Duration)
            Call AddToReportIfNotBlank(Report, "End", currentAppointment.End)
            Call AddToReportIfNotBlank(Report, "EndInEndTimeZone", currentAppointment.EndInEndTimeZone)
            Call AddToReportIfNotBlank(Report, "EndTimeZone", currentAppointment.EndTimeZone)
            Call AddToReportIfNotBlank(Report, "EndUTC", currentAppointment.EndUTC)
            
            Call AddToReportIfNotBlank(Report, "EntryID", currentAppointment.EntryID)
            Call AddToReportIfNotBlank(Report, "ForceUpdateToAllAttendees", currentAppointment.ForceUpdateToAllAttendees)
            Call AddToReportIfNotBlank(Report, "FormDescription", currentAppointment.FormDescription)
            Call AddToReportIfNotBlank(Report, "GlobalAppointmentID", currentAppointment.GlobalAppointmentID)
            Call AddToReportIfNotBlank(Report, "Importance", currentAppointment.Importance)
            Call AddToReportIfNotBlank(Report, "InternetCodepage", currentAppointment.InternetCodepage)
            Call AddToReportIfNotBlank(Report, "IsConflict", currentAppointment.IsConflict)
            Call AddToReportIfNotBlank(Report, "IsRecurring", currentAppointment.IsRecurring)
            ' Call AddToReportIfNotBlank(Report, "ItemProperties", currentAppointment.ItemProperties)
            Call AddToReportIfNotBlank(Report, "LastModificationTime", currentAppointment.LastModificationTime)
            
            ' Call AddToReportIfNotBlank(Report, "Links", currentAppointment.Links)
            Call AddToReportIfNotBlank(Report, "Location", currentAppointment.Location)
            Call AddToReportIfNotBlank(Report, "MarkForDownload", currentAppointment.MarkForDownload)
            Call AddToReportIfNotBlank(Report, "MeetingStatus", currentAppointment.MeetingStatus)
            Call AddToReportIfNotBlank(Report, "MeetingWorkspaceURL", currentAppointment.MeetingWorkspaceURL)
            Call AddToReportIfNotBlank(Report, "MessageClass", currentAppointment.MessageClass)
            Call AddToReportIfNotBlank(Report, "Mileage", currentAppointment.Mileage)
            Call AddToReportIfNotBlank(Report, "NoAging", currentAppointment.NoAging)
            Call AddToReportIfNotBlank(Report, "OptionalAttendees", currentAppointment.OptionalAttendees)
            Call AddToReportIfNotBlank(Report, "Organizer", currentAppointment.Organizer)
            
            Call AddToReportIfNotBlank(Report, "OutlookInternalVersion", currentAppointment.OutlookInternalVersion)
            Call AddToReportIfNotBlank(Report, "OutlookVersion", currentAppointment.OutlookVersion)
            ' Call AddToReportIfNotBlank(Report, "Recipients", currentAppointment.Recipients)
            Call AddToReportIfNotBlank(Report, "RecurrenceState", currentAppointment.RecurrenceState)
            Call AddToReportIfNotBlank(Report, "ReminderMinutesBeforeStart", currentAppointment.ReminderMinutesBeforeStart)
            Call AddToReportIfNotBlank(Report, "ReminderOverrideDefault", currentAppointment.ReminderOverrideDefault)
            Call AddToReportIfNotBlank(Report, "ReminderPlaySound", currentAppointment.ReminderPlaySound)
            Call AddToReportIfNotBlank(Report, "ReminderSet", currentAppointment.ReminderSet)
            Call AddToReportIfNotBlank(Report, "ReminderSoundFile", currentAppointment.ReminderSoundFile)
            Call AddToReportIfNotBlank(Report, "ReplyTime", currentAppointment.ReplyTime)
            
            
            Call AddToReportIfNotBlank(Report, "RequiredAttendees", currentAppointment.RequiredAttendees)
            Call AddToReportIfNotBlank(Report, "Resources", currentAppointment.Resources)
            Call AddToReportIfNotBlank(Report, "ResponseRequested", currentAppointment.ResponseRequested)
            Call AddToReportIfNotBlank(Report, "ResponseStatus", currentAppointment.ResponseStatus)
            ' Call AddToReportIfNotBlank(Report, "RTFBody", currentAppointment.RTFBody)
            Call AddToReportIfNotBlank(Report, "Saved", currentAppointment.Saved)
            ' Call AddToReportIfNotBlank(Report, "SendUsingAccount", currentAppointment.SendUsingAccount)
            Call AddToReportIfNotBlank(Report, "Sensitivity", currentAppointment.Sensitivity)
            Call AddToReportIfNotBlank(Report, "Size", currentAppointment.Size)
            Call AddToReportIfNotBlank(Report, "Start", currentAppointment.Start)
            
            Call AddToReportIfNotBlank(Report, "StartTimeZone", currentAppointment.StartTimeZone)
            Call AddToReportIfNotBlank(Report, "StartUTC", currentAppointment.StartUTC)
            Call AddToReportIfNotBlank(Report, "Subject", currentAppointment.Subject)
            Call AddToReportIfNotBlank(Report, "UnRead", currentAppointment.UnRead)
            ' Call AddToReportIfNotBlank(Report, "UserProperties", currentAppointment.UserProperties)
            
            Report = Report &amp; "--------------------------------------------------------------------------------------------------------"
            Report = Report &amp; vbCrLf &amp; vbCrLf
        End If
        
    Next
    
    
    Call CreateReportAsEmail("List of Appointments", Report)
    
Exiting:
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting
    
End Sub

Private Function AddToReportIfNotBlank(Report As String, FieldName As String, FieldValue)
    AddToReportIfNotBlank = ""
    If (IsNull(FieldValue) Or FieldValue &lt;&gt; "") Then
        AddToReportIfNotBlank = FieldName &amp; " : " &amp; FieldValue &amp; vbCrLf
        Report = Report &amp; AddToReportIfNotBlank
    End If
    
End Function

' VBA SubRoutine which displays a report inside an email
' Programming by Greg Thatcher, http://www.GregThatcher.com
Public Sub CreateReportAsEmail(Title As String, Report As String)
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As addressEntry
    Dim Inbox As Outlook.Folder
    
    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")
    
    Set MyAddress = Session.CurrentUser.addressEntry
    mail.Recipients.Add (MyAddress.Address)
    mail.Recipients.ResolveAll
    
    mail.Subject = Title
    mail.Body = Report
    
    mail.Save
    mail.Display
    
    
Exiting:
        Set Session = Nothing
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>list of Outlook Calendar Appointments using the Outlook Object Model</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>list of Outlook Calendar Appointments using the Outlook Object Model</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

' VBA Script that gets list of Outlook Calendar Appointments and their Properties using the Outlook Object Model
' Use Tools-&gt;Macro-&gt;Security to allow Macros to run, then restart Outlook
' Run Outlook, Press Alt+F11 to open VBA
' Programming by Greg Thatcher, http://www.GregThatcher.com
' See http://www.GregThatcher.com for other ways to get the properties of Appointments
Public Sub GetListOfAppointmentsUsingOutlookObjectModel()
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim Report As String
    Dim AppointmentsFolder As Outlook.Folder
    Dim currentItem As Object
    Dim currentAppointment As AppointmentItem
    Set Session = Application.Session
    
    Set AppointmentsFolder = Session.GetDefaultFolder(olFolderCalendar)
    
    For Each currentItem In AppointmentsFolder.Items
        If (currentItem.Class = olAppointment) Then
            Set currentAppointment = currentItem
            
            'Call AddToReportIfNotBlank(Report, "Actions", currentAppointment.Actions)
            Call AddToReportIfNotBlank(Report, "AllDayEvent", currentAppointment.AllDayEvent)
            ' Call AddToReportIfNotBlank(Report, "Attachments", currentAppointment.Attachments)
            Call AddToReportIfNotBlank(Report, "AutoResolvedWinner", currentAppointment.AutoResolvedWinner)
            Call AddToReportIfNotBlank(Report, "BillingInformation", currentAppointment.BillingInformation)
            Call AddToReportIfNotBlank(Report, "Body", currentAppointment.Body)
            Call AddToReportIfNotBlank(Report, "BusyStatus", currentAppointment.BusyStatus)
            Call AddToReportIfNotBlank(Report, "Categories", currentAppointment.Categories)
            Call AddToReportIfNotBlank(Report, "Class", currentAppointment.Class)
            Call AddToReportIfNotBlank(Report, "Companies", currentAppointment.Companies)
            ' Call AddToReportIfNotBlank(Report, "Conflicts", currentAppointment.Conflicts)
            ' Call AddToReportIfNotBlank(Report, "ConversationID", currentAppointment.ConversationID)
            Call AddToReportIfNotBlank(Report, "ConversationIndex", currentAppointment.ConversationIndex)
            Call AddToReportIfNotBlank(Report, "ConversationTopic", currentAppointment.ConversationTopic)
            Call AddToReportIfNotBlank(Report, "CreationTime", currentAppointment.CreationTime)
            Call AddToReportIfNotBlank(Report, "DownloadState", currentAppointment.DownloadState)
            Call AddToReportIfNotBlank(Report, "Duration", currentAppointment.Duration)
            Call AddToReportIfNotBlank(Report, "End", currentAppointment.End)
            Call AddToReportIfNotBlank(Report, "EndInEndTimeZone", currentAppointment.EndInEndTimeZone)
            Call AddToReportIfNotBlank(Report, "EndTimeZone", currentAppointment.EndTimeZone)
            Call AddToReportIfNotBlank(Report, "EndUTC", currentAppointment.EndUTC)
            
            Call AddToReportIfNotBlank(Report, "EntryID", currentAppointment.EntryID)
            Call AddToReportIfNotBlank(Report, "ForceUpdateToAllAttendees", currentAppointment.ForceUpdateToAllAttendees)
            Call AddToReportIfNotBlank(Report, "FormDescription", currentAppointment.FormDescription)
            Call AddToReportIfNotBlank(Report, "GlobalAppointmentID", currentAppointment.GlobalAppointmentID)
            Call AddToReportIfNotBlank(Report, "Importance", currentAppointment.Importance)
            Call AddToReportIfNotBlank(Report, "InternetCodepage", currentAppointment.InternetCodepage)
            Call AddToReportIfNotBlank(Report, "IsConflict", currentAppointment.IsConflict)
            Call AddToReportIfNotBlank(Report, "IsRecurring", currentAppointment.IsRecurring)
            ' Call AddToReportIfNotBlank(Report, "ItemProperties", currentAppointment.ItemProperties)
            Call AddToReportIfNotBlank(Report, "LastModificationTime", currentAppointment.LastModificationTime)
            
            ' Call AddToReportIfNotBlank(Report, "Links", currentAppointment.Links)
            Call AddToReportIfNotBlank(Report, "Location", currentAppointment.Location)
            Call AddToReportIfNotBlank(Report, "MarkForDownload", currentAppointment.MarkForDownload)
            Call AddToReportIfNotBlank(Report, "MeetingStatus", currentAppointment.MeetingStatus)
            Call AddToReportIfNotBlank(Report, "MeetingWorkspaceURL", currentAppointment.MeetingWorkspaceURL)
            Call AddToReportIfNotBlank(Report, "MessageClass", currentAppointment.MessageClass)
            Call AddToReportIfNotBlank(Report, "Mileage", currentAppointment.Mileage)
            Call AddToReportIfNotBlank(Report, "NoAging", currentAppointment.NoAging)
            Call AddToReportIfNotBlank(Report, "OptionalAttendees", currentAppointment.OptionalAttendees)
            Call AddToReportIfNotBlank(Report, "Organizer", currentAppointment.Organizer)
            
            Call AddToReportIfNotBlank(Report, "OutlookInternalVersion", currentAppointment.OutlookInternalVersion)
            Call AddToReportIfNotBlank(Report, "OutlookVersion", currentAppointment.OutlookVersion)
            ' Call AddToReportIfNotBlank(Report, "Recipients", currentAppointment.Recipients)
            Call AddToReportIfNotBlank(Report, "RecurrenceState", currentAppointment.RecurrenceState)
            Call AddToReportIfNotBlank(Report, "ReminderMinutesBeforeStart", currentAppointment.ReminderMinutesBeforeStart)
            Call AddToReportIfNotBlank(Report, "ReminderOverrideDefault", currentAppointment.ReminderOverrideDefault)
            Call AddToReportIfNotBlank(Report, "ReminderPlaySound", currentAppointment.ReminderPlaySound)
            Call AddToReportIfNotBlank(Report, "ReminderSet", currentAppointment.ReminderSet)
            Call AddToReportIfNotBlank(Report, "ReminderSoundFile", currentAppointment.ReminderSoundFile)
            Call AddToReportIfNotBlank(Report, "ReplyTime", currentAppointment.ReplyTime)
            
            
            Call AddToReportIfNotBlank(Report, "RequiredAttendees", currentAppointment.RequiredAttendees)
            Call AddToReportIfNotBlank(Report, "Resources", currentAppointment.Resources)
            Call AddToReportIfNotBlank(Report, "ResponseRequested", currentAppointment.ResponseRequested)
            Call AddToReportIfNotBlank(Report, "ResponseStatus", currentAppointment.ResponseStatus)
            ' Call AddToReportIfNotBlank(Report, "RTFBody", currentAppointment.RTFBody)
            Call AddToReportIfNotBlank(Report, "Saved", currentAppointment.Saved)
            ' Call AddToReportIfNotBlank(Report, "SendUsingAccount", currentAppointment.SendUsingAccount)
            Call AddToReportIfNotBlank(Report, "Sensitivity", currentAppointment.Sensitivity)
            Call AddToReportIfNotBlank(Report, "Size", currentAppointment.Size)
            Call AddToReportIfNotBlank(Report, "Start", currentAppointment.Start)
            
            Call AddToReportIfNotBlank(Report, "StartTimeZone", currentAppointment.StartTimeZone)
            Call AddToReportIfNotBlank(Report, "StartUTC", currentAppointment.StartUTC)
            Call AddToReportIfNotBlank(Report, "Subject", currentAppointment.Subject)
            Call AddToReportIfNotBlank(Report, "UnRead", currentAppointment.UnRead)
            ' Call AddToReportIfNotBlank(Report, "UserProperties", currentAppointment.UserProperties)
            
            Report = Report &amp; "--------------------------------------------------------------------------------------------------------"
            Report = Report &amp; vbCrLf &amp; vbCrLf
        End If
        
    Next
    
    
    Call CreateReportAsEmail("List of Appointments", Report)
    
Exiting:
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting
    
End Sub

Private Function AddToReportIfNotBlank(Report As String, FieldName As String, FieldValue)
    AddToReportIfNotBlank = ""
    If (IsNull(FieldValue) Or FieldValue &lt;&gt; "") Then
        AddToReportIfNotBlank = FieldName &amp; " : " &amp; FieldValue &amp; vbCrLf
        Report = Report &amp; AddToReportIfNotBlank
    End If
    
End Function

' VBA SubRoutine which displays a report inside an email
' Programming by Greg Thatcher, http://www.GregThatcher.com
Public Sub CreateReportAsEmail(Title As String, Report As String)
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As addressEntry
    Dim Inbox As Outlook.Folder
    
    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")
    
    Set MyAddress = Session.CurrentUser.addressEntry
    mail.Recipients.Add (MyAddress.Address)
    mail.Recipients.ResolveAll
    
    mail.Subject = Title
    mail.Body = Report
    
    mail.Save
    mail.Display
    
    
Exiting:
        Set Session = Nothing
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>list of Outlook Contacts using the Outlook Object Model</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>list of Outlook Contacts using the Outlook Object Model</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

' VBA Script that gets list of Outlook Contacts
' Use Tools-&gt;Macro-&gt;Security to allow Macros to run, then restart Outlook
' Run Outlook, Press Alt+F11 to open VBA
' Programming by Greg Thatcher, http://www.GregThatcher.com
' (see other scripts at http://www.GregThatcher.com for other ways to get contact properties)
Public Sub GetListOfContacts()
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim Report As String
    Dim ContactFolder As Outlook.Folder
    Dim currentItem As Object
    Dim currentContact As ContactItem
    Set Session = Application.Session
    
    Set ContactFolder = Session.GetDefaultFolder(olFolderContacts)
    
    For Each currentItem In ContactFolder.Items
        If (currentItem.Class = olContact) Then
            Set currentContact = currentItem
            
            
            Report = Report &amp; AddToReportIfNotBlank("Full Name", currentContact.FullName)
            Report = Report &amp; AddToReportIfNotBlank("Account", currentContact.Account)
            'Report = Report &amp; AddToReportIfNotBlank("Anniversary", currentContact.Anniversary)
            Report = Report &amp; AddToReportIfNotBlank("AssistantName", currentContact.AssistantName)
            Report = Report &amp; AddToReportIfNotBlank("AssistantTelephoneNumber", currentContact.AssistantTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("BillingInformation", currentContact.BillingInformation)
            'Report = Report &amp; AddToReportIfNotBlank("Birthday", currentContact.Birthday)
            Report = Report &amp; AddToReportIfNotBlank("Body", currentContact.Body)
            Report = Report &amp; AddToReportIfNotBlank("Business2TelephoneNumber", currentContact.Business2TelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("BusinessAddress", currentContact.BusinessAddress)
            Report = Report &amp; AddToReportIfNotBlank("BusinessAddressCity", currentContact.BusinessAddressCity)
            Report = Report &amp; AddToReportIfNotBlank("BusinessAddressCountry", currentContact.BusinessAddressCountry)
            Report = Report &amp; AddToReportIfNotBlank("BusinessAddressPostalCode", currentContact.BusinessAddressPostalCode)
            Report = Report &amp; AddToReportIfNotBlank("BusinessAddressPostOfficeBox", currentContact.BusinessAddressPostOfficeBox)
            Report = Report &amp; AddToReportIfNotBlank("BusinessAddressState", currentContact.BusinessAddressState)
            Report = Report &amp; AddToReportIfNotBlank("BusinessAddressStreet", currentContact.BusinessAddressStreet)
            'Report = Report &amp; AddToReportIfNotBlank("BusinessCardLayoutXml", currentContact.BusinessCardLayoutXml)
            Report = Report &amp; AddToReportIfNotBlank("BusinessCardType", currentContact.BusinessCardType)
            Report = Report &amp; AddToReportIfNotBlank("BusinessFaxNumber", currentContact.BusinessFaxNumber)
            Report = Report &amp; AddToReportIfNotBlank("BusinessHomePage", currentContact.BusinessHomePage)
            Report = Report &amp; AddToReportIfNotBlank("BusinessTelephoneNumber", currentContact.BusinessTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("CallbackTelephoneNumber", currentContact.CallbackTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("CarTelephoneNumber", currentContact.CarTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("Categories", currentContact.Categories)
            Report = Report &amp; AddToReportIfNotBlank("Children", currentContact.Children)
            Report = Report &amp; AddToReportIfNotBlank("Companies", currentContact.Companies)
            Report = Report &amp; AddToReportIfNotBlank("CompanyAndFullName", currentContact.CompanyAndFullName)
            Report = Report &amp; AddToReportIfNotBlank("CompanyLastFirstNoSpace", currentContact.CompanyLastFirstNoSpace)
            Report = Report &amp; AddToReportIfNotBlank("CompanyLastFirstSpaceOnly", currentContact.CompanyLastFirstSpaceOnly)
            Report = Report &amp; AddToReportIfNotBlank("CompanyMainTelephoneNumber", currentContact.CompanyMainTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("CompanyName", currentContact.CompanyName)
            Report = Report &amp; AddToReportIfNotBlank("ComputerNetworkName", currentContact.ComputerNetworkName)
            Report = Report &amp; AddToReportIfNotBlank("ConversationIndex ", currentContact.ConversationIndex)
            Report = Report &amp; AddToReportIfNotBlank("ConversationTopic", currentContact.ConversationTopic)
            Report = Report &amp; AddToReportIfNotBlank("CreationTime", currentContact.CreationTime)
            Report = Report &amp; AddToReportIfNotBlank("CustomerID", currentContact.CustomerID)
            Report = Report &amp; AddToReportIfNotBlank("Department", currentContact.Department)
            Report = Report &amp; AddToReportIfNotBlank("DownloadState", currentContact.DownloadState)
            Report = Report &amp; AddToReportIfNotBlank("Email1Address", currentContact.Email1Address)
            Report = Report &amp; AddToReportIfNotBlank("Email1AddressType", currentContact.Email1AddressType)
            Report = Report &amp; AddToReportIfNotBlank("Email1DisplayName", currentContact.Email1DisplayName)
            'Report = Report &amp; AddToReportIfNotBlank("Email1EntryID", currentContact.Email1EntryID)
            Report = Report &amp; AddToReportIfNotBlank("Email2Address", currentContact.Email2Address)
            Report = Report &amp; AddToReportIfNotBlank("Email2AddressType", currentContact.Email2AddressType)
            Report = Report &amp; AddToReportIfNotBlank("Email2DisplayName", currentContact.Email2DisplayName)
            Report = Report &amp; AddToReportIfNotBlank("Email2EntryID", currentContact.Email2EntryID)
            Report = Report &amp; AddToReportIfNotBlank("Email3Address", currentContact.Email3Address)
            Report = Report &amp; AddToReportIfNotBlank("Email3AddressType", currentContact.Email3AddressType)
            Report = Report &amp; AddToReportIfNotBlank("Email3DisplayName ", currentContact.Email3DisplayName)
            Report = Report &amp; AddToReportIfNotBlank("Email3EntryID ", currentContact.Email3EntryID)
            Report = Report &amp; AddToReportIfNotBlank("EntryID", currentContact.Account)
            Report = Report &amp; AddToReportIfNotBlank("FileAs", currentContact.FileAs)
            Report = Report &amp; AddToReportIfNotBlank("FirstName", currentContact.FirstName)
            Report = Report &amp; AddToReportIfNotBlank("FTPSite", currentContact.FTPSite)
            Report = Report &amp; AddToReportIfNotBlank("FullName", currentContact.FullName)
            Report = Report &amp; AddToReportIfNotBlank("FullNameAndCompany", currentContact.FullNameAndCompany)
            Report = Report &amp; AddToReportIfNotBlank("Gender", currentContact.Gender)
            Report = Report &amp; AddToReportIfNotBlank("GovernmentIDNumber", currentContact.GovernmentIDNumber)
            Report = Report &amp; AddToReportIfNotBlank("HasPicture", currentContact.HasPicture)
            Report = Report &amp; AddToReportIfNotBlank("Hobby", currentContact.Hobby)
            Report = Report &amp; AddToReportIfNotBlank("Home2TelephoneNumber", currentContact.Home2TelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("HomeAddress ", currentContact.HomeAddress)
            Report = Report &amp; AddToReportIfNotBlank("HomeAddressCity", currentContact.HomeAddressCity)
            Report = Report &amp; AddToReportIfNotBlank("HomeAddressCountry", currentContact.HomeAddressCountry)
            Report = Report &amp; AddToReportIfNotBlank("HomeAddressPostalCode ", currentContact.HomeAddressPostalCode)
            Report = Report &amp; AddToReportIfNotBlank("HomeAddressPostOfficeBox", currentContact.HomeAddressPostOfficeBox)
            Report = Report &amp; AddToReportIfNotBlank("HomeAddressState", currentContact.HomeAddressState)
           
            Report = Report &amp; AddToReportIfNotBlank("HomeAddressStreet", currentContact.HomeAddressStreet)
            Report = Report &amp; AddToReportIfNotBlank("HomeFaxNumber", currentContact.HomeFaxNumber)
            Report = Report &amp; AddToReportIfNotBlank("HomeTelephoneNumber", currentContact.HomeTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("IMAddress", currentContact.IMAddress)
            Report = Report &amp; AddToReportIfNotBlank("Importance", currentContact.Importance)
            Report = Report &amp; AddToReportIfNotBlank("Initials", currentContact.Initials)
            Report = Report &amp; AddToReportIfNotBlank("InternetFreeBusyAddress", currentContact.InternetFreeBusyAddress)
            Report = Report &amp; AddToReportIfNotBlank("IsConflict", currentContact.IsConflict)
            Report = Report &amp; AddToReportIfNotBlank("ISDNNumber", currentContact.ISDNNumber)
            Report = Report &amp; AddToReportIfNotBlank("IsMarkedAsTask", currentContact.IsMarkedAsTask)
            Report = Report &amp; AddToReportIfNotBlank("JobTitle", currentContact.JobTitle)
            Report = Report &amp; AddToReportIfNotBlank("Journal", currentContact.Journal)
            Report = Report &amp; AddToReportIfNotBlank("Language", currentContact.Language)
            Report = Report &amp; AddToReportIfNotBlank("LastFirstAndSuffix", currentContact.LastFirstAndSuffix)
            Report = Report &amp; AddToReportIfNotBlank("LastFirstNoSpace", currentContact.LastFirstNoSpace)
            Report = Report &amp; AddToReportIfNotBlank("LastFirstNoSpaceAndSuffix", currentContact.LastFirstNoSpaceAndSuffix)
            Report = Report &amp; AddToReportIfNotBlank("LastFirstNoSpaceCompany", currentContact.LastFirstNoSpaceCompany)
            Report = Report &amp; AddToReportIfNotBlank("LastFirstSpaceOnly", currentContact.LastFirstSpaceOnly)
            Report = Report &amp; AddToReportIfNotBlank("LastFirstSpaceOnlyCompany", currentContact.LastFirstSpaceOnlyCompany)
            Report = Report &amp; AddToReportIfNotBlank("LastModificationTime", currentContact.LastModificationTime)
            Report = Report &amp; AddToReportIfNotBlank("LastName", currentContact.LastName)
            Report = Report &amp; AddToReportIfNotBlank("LastNameAndFirstName", currentContact.LastNameAndFirstName)
            'Report = Report &amp; AddToReportIfNotBlank("Links", currentContact.Links)
            Report = Report &amp; AddToReportIfNotBlank("MailingAddress", currentContact.MailingAddress)
            Report = Report &amp; AddToReportIfNotBlank("MailingAddressCity", currentContact.MailingAddressCity)
            Report = Report &amp; AddToReportIfNotBlank("MailingAddressCountry", currentContact.MailingAddressCountry)
            Report = Report &amp; AddToReportIfNotBlank("MailingAddressPostalCode", currentContact.MailingAddressPostalCode)

            Report = Report &amp; AddToReportIfNotBlank("MailingAddressPostOfficeBox", currentContact.MailingAddressPostOfficeBox)
            Report = Report &amp; AddToReportIfNotBlank("MailingAddressState", currentContact.MailingAddressState)
            Report = Report &amp; AddToReportIfNotBlank("MailingAddressStreet", currentContact.MailingAddressStreet)
            Report = Report &amp; AddToReportIfNotBlank("ManagerName", currentContact.ManagerName)
            Report = Report &amp; AddToReportIfNotBlank("MarkForDownload", currentContact.MarkForDownload)
            Report = Report &amp; AddToReportIfNotBlank("MessageClass", currentContact.MessageClass)
            Report = Report &amp; AddToReportIfNotBlank("MiddleName", currentContact.MiddleName)
            Report = Report &amp; AddToReportIfNotBlank("Mileage", currentContact.Mileage)
            Report = Report &amp; AddToReportIfNotBlank("MobileTelephoneNumber", currentContact.MobileTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("NetMeetingAlias", currentContact.NetMeetingAlias)
            Report = Report &amp; AddToReportIfNotBlank("NetMeetingServer", currentContact.NetMeetingServer)
            Report = Report &amp; AddToReportIfNotBlank("NickName", currentContact.NickName)
            Report = Report &amp; AddToReportIfNotBlank("NoAging", currentContact.NoAging)
            Report = Report &amp; AddToReportIfNotBlank("OfficeLocation", currentContact.OfficeLocation)
            Report = Report &amp; AddToReportIfNotBlank("OrganizationalIDNumber", currentContact.OrganizationalIDNumber)
            Report = Report &amp; AddToReportIfNotBlank("OtherAddress", currentContact.OtherAddress)
            Report = Report &amp; AddToReportIfNotBlank("OtherAddressCity", currentContact.OtherAddressCity)
            Report = Report &amp; AddToReportIfNotBlank("OtherAddressCountry", currentContact.OtherAddressCountry)
            Report = Report &amp; AddToReportIfNotBlank("OtherAddressPostalCode", currentContact.OtherAddressPostalCode)
            Report = Report &amp; AddToReportIfNotBlank("OtherAddressPostOfficeBox", currentContact.OtherAddressPostOfficeBox)
            Report = Report &amp; AddToReportIfNotBlank("OtherAddressState", currentContact.OtherAddressState)
            Report = Report &amp; AddToReportIfNotBlank("OtherAddressStreet", currentContact.OtherAddressStreet)
            Report = Report &amp; AddToReportIfNotBlank("OtherFaxNumber", currentContact.OtherFaxNumber)
            Report = Report &amp; AddToReportIfNotBlank("OtherTelephoneNumber", currentContact.OtherTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("OutlookInternalVersion", currentContact.OutlookInternalVersion)
            Report = Report &amp; AddToReportIfNotBlank("OutlookVersion", currentContact.OutlookVersion)
            Report = Report &amp; AddToReportIfNotBlank("PagerNumber", currentContact.PagerNumber)
            Report = Report &amp; AddToReportIfNotBlank("PersonalHomePage", currentContact.PersonalHomePage)
            Report = Report &amp; AddToReportIfNotBlank("PrimaryTelephoneNumber", currentContact.PrimaryTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("Profession", currentContact.Profession)
            Report = Report &amp; AddToReportIfNotBlank("RadioTelephoneNumber", currentContact.RadioTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("ReferredBy", currentContact.ReferredBy)
            Report = Report &amp; AddToReportIfNotBlank("ReminderOverrideDefault", currentContact.ReminderOverrideDefault)
            Report = Report &amp; AddToReportIfNotBlank("ReminderPlaySound", currentContact.ReminderPlaySound)
            Report = Report &amp; AddToReportIfNotBlank("ReminderSet", currentContact.ReminderSet)
            Report = Report &amp; AddToReportIfNotBlank("ReminderSoundFile", currentContact.ReminderSoundFile)
            Report = Report &amp; AddToReportIfNotBlank("ReminderTime", currentContact.ReminderTime)
            Report = Report &amp; AddToReportIfNotBlank("Saved", currentContact.Saved)
            Report = Report &amp; AddToReportIfNotBlank("SelectedMailingAddress", currentContact.SelectedMailingAddress)
            Report = Report &amp; AddToReportIfNotBlank("Sensitivity", currentContact.Sensitivity)
            Report = Report &amp; AddToReportIfNotBlank("Size", currentContact.Size)
            Report = Report &amp; AddToReportIfNotBlank("Spouse", currentContact.Spouse)
            Report = Report &amp; AddToReportIfNotBlank("Subject", currentContact.Subject)
            Report = Report &amp; AddToReportIfNotBlank("Suffix", currentContact.Suffix)
            Report = Report &amp; AddToReportIfNotBlank("TaskCompletedDate", currentContact.TaskCompletedDate)
            Report = Report &amp; AddToReportIfNotBlank("TaskDueDate", currentContact.TaskDueDate)
            Report = Report &amp; AddToReportIfNotBlank("TaskStartDate", currentContact.TaskStartDate)
            Report = Report &amp; AddToReportIfNotBlank("TaskSubject", currentContact.TaskSubject)
            Report = Report &amp; AddToReportIfNotBlank("TelexNumber", currentContact.TelexNumber)
            Report = Report &amp; AddToReportIfNotBlank("Title", currentContact.Title)
            Report = Report &amp; AddToReportIfNotBlank("ToDoTaskOrdinal", currentContact.ToDoTaskOrdinal)
            Report = Report &amp; AddToReportIfNotBlank("TTYTDDTelephoneNumber", currentContact.TTYTDDTelephoneNumber)
            Report = Report &amp; AddToReportIfNotBlank("UnRead", currentContact.UnRead)
            Report = Report &amp; AddToReportIfNotBlank("User1", currentContact.User1)
            Report = Report &amp; AddToReportIfNotBlank("User2", currentContact.User2)
            Report = Report &amp; AddToReportIfNotBlank("User3", currentContact.User3)
            Report = Report &amp; AddToReportIfNotBlank("User4", currentContact.User4)
            Report = Report &amp; AddToReportIfNotBlank("WebPage", currentContact.WebPage)
            Report = Report &amp; AddToReportIfNotBlank("YomiCompanyName", currentContact.YomiCompanyName)
            Report = Report &amp; AddToReportIfNotBlank("YomiFirstName", currentContact.YomiFirstName)
            Report = Report &amp; AddToReportIfNotBlank("YomiLastName", currentContact.YomiLastName)
            Report = Report &amp; vbCrLf &amp; vbCrLf
        End If
        
    Next
    
    
    Call CreateReportAsEmail("List of Contacts", Report)
    
Exiting:
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting
    
End Sub

Private Function AddToReportIfNotBlank(FieldName As String, FieldValue As String)
    AddToReportIfNotBlank = ""
    If (FieldValue &lt;&gt; "") Then
        AddToReportIfNotBlank = FieldName &amp; " : " &amp; FieldValue &amp; vbCrLf
    End If
    
End Function

' VBA SubRoutine which displays a report inside an email
' Programming by Greg Thatcher, http://www.GregThatcher.com
Public Sub CreateReportAsEmail(Title As String, Report As String)
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As AddressEntry
    Dim Inbox As Outlook.Folder
    
    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")
    
    Set MyAddress = Session.CurrentUser.AddressEntry
    mail.Recipients.Add (MyAddress.Address)
    mail.Recipients.ResolveAll
    
    mail.Subject = Title
    mail.Body = Report
    
    mail.Save
    mail.Display
    
    
Exiting:
        Set Session = Nothing
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>list of Outlook Contacts using the Property Accessor</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>list of Outlook Contacts using the Property Accessor</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

' VBA Script that gets info on Outlook Contacts using propertyAccessor and various syntaxes
' (see other scripts at http://www.GregThatcher.com for other ways to get contact properties)
' Property Tag Syntax looks like this http://schemas.microsoft.com/mapi/proptag/0x0005000b
' Property Tag Syntax is used for Outlook 'Properties' (defined by Outlook Object Model)
'
' Property ID Syntax looks like this http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8586001f
' Property ID Syntax is used for MAPI Named Properties (optional Outlook properties that can't be deleted) and UserProperties (properties you can add which are visible to the user)
'
' Named Property Syntax looks like this http://schemas.microsoft.com/mapi/string folloowed by a property name
' Named Property Syntax is used to create and view 'Named Properties" (properties you can create, but which are not visible to the user)
'
' Office document syntax looks like this: urn:schemas-microsoft-com:office:outlook#source-table-label
'
' Use Tools-&gt;Macro-&gt;Security to allow Macros to run, then restart Outlook
' Run Outlook, Press Alt+F11 to open VBA
' Programming by Greg Thatcher, http://www.GregThatcher.com
' THIS SCRIPT WILL ONLY RUN ON OUTLOOK 2007 OR LATER (it won't work on Outlook 2003 -- there is no propertyAccessor)
'
' To find the DASL definition of Outlook Properties, use the method described in Professional Outlook 2007 Programming (Programmer to Programmer)
' From the 'Views' menu, create a new view (but don't save it)
' Click on the 'Advanced' tab, and choose 'Filter'
' Choose a Field from the 'Field' dropdown, also choose a condition and value
' Click on the 'Sql tab'
' Check the 'Edit these Criteria' checkbox
'

Public Sub GetContactInfoUsingpropertyAccessor()
    Dim Session As Outlook.NameSpace
    Dim Report As String
    Dim ContactFolder As Outlook.Folder
    Dim currentItem As Object
    Dim currentContact As ContactItem
    Dim propertyAccessor As Outlook.propertyAccessor
    Dim stringArray() As String
    Dim index
    Dim currentString
    
    Set Session = Application.Session
    
    Set ContactFolder = Session.GetDefaultFolder(olFolderContacts)
    
    For Each currentItem In ContactFolder.Items
        If (currentItem.Class = olContact) Then
            Set currentContact = currentItem
            Set propertyAccessor = currentContact.propertyAccessor

            'report = report &amp; AddToReportIfNotBlank("Auto Forwarded", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x0005000b")) &amp; vbCrLf
    

           'Report = Report &amp; AddToReportIfNotBlank("Account", propertyAccessor.GetProperty("urn:schemas:contacts:account")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Address Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8074001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Address Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/80680003")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Anniversary", propertyAccessor.GetProperty("urn:schemas:contacts:weddinganniversary")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Assistant's Name", propertyAccessor.GetProperty("urn:schemas:contacts:secretarycn")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Assitant's Phone", propertyAccessor.GetProperty("urn:schemas:contacts:secretaryphone")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Billing information", propertyAccessor.GetProperty("urn:schemas:contacts:billinginformation")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Birthday", propertyAccessor.GetProperty("urn:schemas:contacts:bday")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Business address", propertyAccessor.GetProperty("urn:schemas:contacts:workaddress")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Business Address City", propertyAccessor.GetProperty("urn:schemas:contacts:l")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Business Address Country/Region", propertyAccessor.GetProperty("urn:schemas:contacts:co")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Business Address Post Office Box", propertyAccessor.GetProperty("urn:schemas:contacts:postofficebox")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Business address postal code", propertyAccessor.GetProperty("urn:schemas:contacts:postalcode")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Business address state", propertyAccessor.GetProperty("urn:schemas:contacts:st")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Business address street", propertyAccessor.GetProperty("urn:schemas:contacts:street")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Business fax number", propertyAccessor.GetProperty("urn:schemas:contacts:facsimiletelephonenumber")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Business home page", propertyAccessor.GetProperty("urn:schemas:contacts:businesshomepage")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Business telephone number", propertyAccessor.GetProperty("urn:schemas:contacts:officetelephonenumber")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Business telephone number", propertyAccessor.GetProperty("urn:schemas:contacts:office2telephonenumber")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Callback phone number", propertyAccessor.GetProperty("urn:schemas:contacts:callbackphone")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Car phone number", propertyAccessor.GetProperty("urn:schemas:contacts:othermobile")) &amp; vbCrLf
            stringArray() = propertyAccessor.GetProperty("urn:schemas-microsoft-com:office:office#Keywords")
            For index = LBound(stringArray) To UBound(stringArray)
                Report = Report &amp; "Categories (" &amp; index &amp; ") " &amp; stringArray(index) &amp; vbCrLf
            Next index

           'Report = Report &amp; AddToReportIfNotBlank("Children", propertyAccessor.GetProperty("urn:schemas:contacts:childrensnames")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("City", propertyAccessor.GetProperty("urn:schemas:contacts:mailingcity")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Company name", propertyAccessor.GetProperty("urn:schemas:contacts:o")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Company main telephone number", propertyAccessor.GetProperty("urn:schemas:contacts:organizationmainphone")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Computer network name", propertyAccessor.GetProperty("urn:schemas:contacts:computernetworkname")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Contacts", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8586001f")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Country/Region", propertyAccessor.GetProperty("urn:schemas:contacts:mailingcountry")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Created", propertyAccessor.GetProperty("urn:schemas:calendar:created")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Customer ID", propertyAccessor.GetProperty("urn:schemas:contacts:customerid")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Department", propertyAccessor.GetProperty("urn:schemas:contacts:department")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail 1 address", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8084001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail 2 address", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8094001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail 3 address", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/80a4001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail 1 display name", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8080001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8009001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/80690003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail 2 display name", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8090001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail 3 display name", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/80a0001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail 1 type", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8082001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail 2 type", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8092001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("E-mail 3 type", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/80a2001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("File As", propertyAccessor.GetProperty("urn:schemas:contacts:fileas")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("First name", propertyAccessor.GetProperty("urn:schemas:contacts:givenName")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Flag Completed Date", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x10910040")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Flag Status", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x10900003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Follow Up Flag", propertyAccessor.GetProperty("urn:schemas:httpmail:messageflag")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("FTP site", propertyAccessor.GetProperty("urn:schemas:contacts:ftpsite")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Full name", propertyAccessor.GetProperty("urn:schemas:contacts:cn")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Gender", propertyAccessor.GetProperty("urn:schemas:contacts:gender")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Government ID number", propertyAccessor.GetProperty("urn:schemas:contacts:governmentid")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Hobbies", propertyAccessor.GetProperty("urn:schemas:contacts:hobbies")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Home address", propertyAccessor.GetProperty("urn:schemas:contacts:homepostaladdress")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Home address city", propertyAccessor.GetProperty("urn:schemas:contacts:homeCity")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Home address country/region", propertyAccessor.GetProperty("urn:schemas:contacts:homeCountry")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Home address post office box", propertyAccessor.GetProperty("urn:schemas:contacts:homepostofficebox")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Home address postal code", propertyAccessor.GetProperty("urn:schemas:contacts:homePostalCode")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Home address state", propertyAccessor.GetProperty("urn:schemas:contacts:homeState")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Home address street", propertyAccessor.GetProperty("urn:schemas:contacts:homeStreet")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Home fax", propertyAccessor.GetProperty("urn:schemas:contacts:homefax")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Home phone", propertyAccessor.GetProperty("urn:schemas:contacts:homePhone")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Home phone 2", propertyAccessor.GetProperty("urn:schemas:contacts:homephone2")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("IM address", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8062001f")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("In Folder", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x0e05001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Initials", propertyAccessor.GetProperty("urn:schemas:contacts:initials")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Internet free/busy address", propertyAccessor.GetProperty("urn:schemas:calendar:fburl")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("ISDN number", propertyAccessor.GetProperty("urn:schemas:contacts:internationalisdnnumber")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Job title", propertyAccessor.GetProperty("urn:schemas:contacts:title")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Journal", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8025000b")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Language", propertyAccessor.GetProperty("urn:schemas:contacts:language")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Last name", propertyAccessor.GetProperty("urn:schemas:contacts:sn")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Location", propertyAccessor.GetProperty("urn:schemas:contacts:location")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Mailing Address", propertyAccessor.GetProperty("urn:schemas:contacts:mailingpostaladdress")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Mailing Address Indicator", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8002000b")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Manager's name", propertyAccessor.GetProperty("urn:schemas:contacts:manager")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Message Class", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x001a001e")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Middle name", propertyAccessor.GetProperty("urn:schemas:contacts:middlename")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Mileage", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/mileage")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Mobile phone", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x3a1c001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Modified", propertyAccessor.GetProperty("DAV:getlastmodified")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Nickname", propertyAccessor.GetProperty("urn:schemas:contacts:nickname")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Notes", propertyAccessor.GetProperty("urn:schemas-microsoft-com:office:office#Notes")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Office location", propertyAccessor.GetProperty("urn:schemas:contacts:roomnumber")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Organizational ID number", propertyAccessor.GetProperty("urn:schemas:contacts:employeenumber")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Other address", propertyAccessor.GetProperty("urn:schemas:contacts:otherpostaladdress")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Other address city", propertyAccessor.GetProperty("urn:schemas:contacts:othercity")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Other address country/region", propertyAccessor.GetProperty("urn:schemas:contacts:othercountry")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Other address post office box", propertyAccessor.GetProperty("urn:schemas:contacts:otherpostofficebox")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Other address postal code", propertyAccessor.GetProperty("urn:schemas:contacts:otherpostalcode")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Other address state", propertyAccessor.GetProperty("urn:schemas:contacts:otherstate")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Other address street", propertyAccessor.GetProperty("urn:schemas:contacts:otherstreet")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Other fax number", propertyAccessor.GetProperty("urn:schemas:contacts:otherfax")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Other phone number", propertyAccessor.GetProperty("urn:schemas:contacts:otherTelephone")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Outlook Data File", propertyAccessor.GetProperty("urn:schemas-microsoft-com:office:outlook#source-table-label")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Outlook Internal Version", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/85520003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Outlook Version", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8554001f")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Pager", propertyAccessor.GetProperty("urn:schemas:contacts:pager")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Personal home page", propertyAccessor.GetProperty("urn:schemas:contacts:personalHomePage")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 1 Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8076001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 1 Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/806a0003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 2 Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8077001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 2 Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/806b0003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 3 Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8078001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 3 Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/806c0003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 4 Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/8079001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 4 Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/806d0003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 5 Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/807a001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 5 Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/806e0003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 6 Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/807b001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 6 Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/806f0003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 7 Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/807c001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 7 Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/80700003")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 8 Selected", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/807d001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Phone 8 Selector", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/80710003")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("PO Box", propertyAccessor.GetProperty("urn:schemas:contacts:mailingpostofficebox")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Primary phone number", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x3a1a001f")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Private", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8506000b")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Profession", propertyAccessor.GetProperty("urn:schemas:contacts:profession")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Radio phone number", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/proptag/0x3a1d001f")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Referred by", propertyAccessor.GetProperty("urn:schemas:contacts:referredby")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Reminder", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/8503000b")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Reminder Time", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062008-0000-0000-C000-000000000046}/85020040")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Reminder Topic", propertyAccessor.GetProperty("urn:schemas:httpmail:messageflag")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Sensitivity", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/sensitivity-long")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Spouse/Partner", propertyAccessor.GetProperty("urn:schemas:contacts:spousecn")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("State", propertyAccessor.GetProperty("urn:schemas:contacts:mailingstate")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Street Address", propertyAccessor.GetProperty("urn:schemas:contacts:mailingstreet")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Subject", propertyAccessor.GetProperty("urn:schemas:httpmail:subject")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Suffix", propertyAccessor.GetProperty("urn:schemas:contacts:namesuffix")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Telex", propertyAccessor.GetProperty("urn:schemas:contacts:telexnumber")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Title", propertyAccessor.GetProperty("urn:schemas:contacts:personaltitle")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("TTY/TDD Phone", propertyAccessor.GetProperty("urn:schemas:contacts:ttytddphone")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("User Field 1", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/extensionattribute1")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("User Field 2", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/extensionattribute2")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("User Field 3", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/extensionattribute3")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("User Field 4", propertyAccessor.GetProperty("http://schemas.microsoft.com/exchange/extensionattribute4")) &amp; vbCrLf
           Report = Report &amp; AddToReportIfNotBlank("Web page", propertyAccessor.GetProperty("http://schemas.microsoft.com/mapi/id/{00062004-0000-0000-C000-000000000046}/802b001f")) &amp; vbCrLf
           'Report = Report &amp; AddToReportIfNotBlank("Zip/Postal Code", propertyAccessor.GetProperty("urn:schemas:contacts:mailingpostalcode")) &amp; vbCrLf

            Report = Report &amp; "----------------------------------------------------------------------------------" &amp; vbCrLf &amp; vbCrLf
           
        End If
    Next
    
    Call CreateReportAsEmail("List of Contacts and properties using various Property Syntaxes", Report)
End Sub


Private Function AddToReportIfNotBlank(FieldName As String, FieldValue)
    AddToReportIfNotBlank = ""
    If (IsNull(FieldValue) Or FieldValue &lt;&gt; "") Then
        AddToReportIfNotBlank = FieldName &amp; " : " &amp; FieldValue &amp; vbCrLf
    End If
    
End Function

' VBA SubRoutine which displays a report inside an email
' Programming by Greg Thatcher, http://www.GregThatcher.com
Public Sub CreateReportAsEmail(Title As String, Report As String)
    On Error GoTo On_Error

    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As addressEntry
    Dim Inbox

    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")

    mail.Subject = Title
    mail.Body = Report

    mail.Save
    mail.Display
    

Exiting:
        Set Session = Nothing
        Exit Sub

On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_OUTLOOK</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>list of Outlook Tasks using the Outlook Object Model</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_OUTLOOK</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>list of Outlook Tasks using the Outlook Object Model</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Explicit

' VBA Script that gets list of Outlook Tasks
' Use Tools-&gt;Macro-&gt;Security to allow Macros to run, then restart Outlook
' Run Outlook, Press Alt+F11 to open VBA
' Programming by Greg Thatcher, http://www.GregThatcher.com
Public Sub GetListOfTasks()
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim Report As String
    Dim TaskFolder As Outlook.Folder
    Dim currentItem As Object
    Dim currentTask As TaskItem
    Set Session = Application.Session
    
    Set TaskFolder = Session.GetDefaultFolder(olFolderTasks)
    
    For Each currentItem In TaskFolder.Items
        If (currentItem.Class = olTask) Then
            Set currentTask = currentItem
            
            
            Report = Report &amp; AddToReportIfNotBlank("ConversationTopic", currentTask.ConversationTopic)
            Report = Report &amp; AddToReportIfNotBlank("ActualWork", currentTask.ActualWork)
            Report = Report &amp; AddToReportIfNotBlank("AutoResolvedWinner", currentTask.AutoResolvedWinner)
            Report = Report &amp; AddToReportIfNotBlank("BillingInformation", currentTask.BillingInformation)
            Report = Report &amp; AddToReportIfNotBlank("Body", currentTask.Body)
            Report = Report &amp; AddToReportIfNotBlank("CardData", currentTask.CardData)
            Report = Report &amp; AddToReportIfNotBlank("Categories", currentTask.Categories)
            Report = Report &amp; AddToReportIfNotBlank("Companies", currentTask.Companies)
            Report = Report &amp; AddToReportIfNotBlank("Complete", currentTask.Complete)
            Report = Report &amp; AddToReportIfNotBlank("ContactNames", currentTask.ContactNames)
            Report = Report &amp; AddToReportIfNotBlank("ConversationIndex", currentTask.ConversationIndex)
            Report = Report &amp; AddToReportIfNotBlank("CreationTime", currentTask.CreationTime)
            Report = Report &amp; AddToReportIfNotBlank("DateCompleted", currentTask.DateCompleted)
            Report = Report &amp; AddToReportIfNotBlank("DelegationState", currentTask.DelegationState)
            Report = Report &amp; AddToReportIfNotBlank("Delegator", currentTask.Delegator)
            Report = Report &amp; AddToReportIfNotBlank("DownloadState", currentTask.DownloadState)
            Report = Report &amp; AddToReportIfNotBlank("DueDate", currentTask.DueDate)
            Report = Report &amp; AddToReportIfNotBlank("EntryID", currentTask.EntryID)
            Report = Report &amp; AddToReportIfNotBlank("Importance", currentTask.Importance)
            Report = Report &amp; AddToReportIfNotBlank("InternetCodepage", currentTask.InternetCodepage)
            Report = Report &amp; AddToReportIfNotBlank("IsConflict", currentTask.IsConflict)
            Report = Report &amp; AddToReportIfNotBlank("IsRecurring", currentTask.IsRecurring)
            Report = Report &amp; AddToReportIfNotBlank("LastModificationTime", currentTask.LastModificationTime)
            Report = Report &amp; AddToReportIfNotBlank("MarkForDownload", currentTask.MarkForDownload)
            Report = Report &amp; AddToReportIfNotBlank("MessageClass", currentTask.MessageClass)
            Report = Report &amp; AddToReportIfNotBlank("Mileage", currentTask.Mileage)
            Report = Report &amp; AddToReportIfNotBlank("NoAging", currentTask.NoAging)
            Report = Report &amp; AddToReportIfNotBlank("Ordinal", currentTask.Ordinal)
            Report = Report &amp; AddToReportIfNotBlank("OutlookInternalVersion", currentTask.OutlookInternalVersion)
            Report = Report &amp; AddToReportIfNotBlank("OutlookVersion", currentTask.OutlookVersion)
            Report = Report &amp; AddToReportIfNotBlank("Owner", currentTask.Owner)
            Report = Report &amp; AddToReportIfNotBlank("Ownership", currentTask.Ownership)
            Report = Report &amp; AddToReportIfNotBlank("PercentComplete", currentTask.PercentComplete)
            Report = Report &amp; AddToReportIfNotBlank("ReminderOverrideDefault", currentTask.ReminderOverrideDefault)
            Report = Report &amp; AddToReportIfNotBlank("ReminderPlaySound", currentTask.ReminderPlaySound)
            Report = Report &amp; AddToReportIfNotBlank("ReminderSet", currentTask.ReminderSet)
            Report = Report &amp; AddToReportIfNotBlank("ReminderSoundFile", currentTask.ReminderSoundFile)
            Report = Report &amp; AddToReportIfNotBlank("ReminderTime", currentTask.ReminderTime)
            Report = Report &amp; AddToReportIfNotBlank("ResponseState", currentTask.ResponseState)
            Report = Report &amp; AddToReportIfNotBlank("Role", currentTask.Role)
            Report = Report &amp; AddToReportIfNotBlank("Saved", currentTask.Saved)
            Report = Report &amp; AddToReportIfNotBlank("SchedulePlusPriority", currentTask.SchedulePlusPriority)
            Report = Report &amp; AddToReportIfNotBlank("SendUsingAccount", currentTask.SendUsingAccount)
            Report = Report &amp; AddToReportIfNotBlank("Sensitivity", currentTask.Sensitivity)
            Report = Report &amp; AddToReportIfNotBlank("Size", currentTask.Size)
            Report = Report &amp; AddToReportIfNotBlank("StartDate", currentTask.StartDate)
            Report = Report &amp; AddToReportIfNotBlank("Status", currentTask.Status)
            Report = Report &amp; AddToReportIfNotBlank("StatusOnCompletionRecipients", currentTask.StatusOnCompletionRecipients)
            Report = Report &amp; AddToReportIfNotBlank("StatusUpdateRecipients", currentTask.StatusUpdateRecipients)
            Report = Report &amp; AddToReportIfNotBlank("Subject", currentTask.Subject)
            Report = Report &amp; AddToReportIfNotBlank("TeamTask", currentTask.TeamTask)
            Report = Report &amp; AddToReportIfNotBlank("ToDoTaskOrdinal", currentTask.ToDoTaskOrdinal)
            Report = Report &amp; AddToReportIfNotBlank("TotalWork", currentTask.TotalWork)
            Report = Report &amp; AddToReportIfNotBlank("UnRead", currentTask.UnRead)
            
            Report = Report &amp; vbCrLf &amp; vbCrLf
        End If
        
    Next
    
    
    Call CreateReportAsEmail("List of Tasks", Report)
    
Exiting:
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting
    
End Sub

Private Function AddToReportIfNotBlank(FieldName As String, FieldValue As String)
    AddToReportIfNotBlank = ""
    If (FieldValue &lt;&gt; "") Then
        AddToReportIfNotBlank = FieldName &amp; " : " &amp; FieldValue &amp; vbCrLf
    End If
    
End Function

' VBA SubRoutine which displays a report inside an email
' Programming by Greg Thatcher, http://www.GregThatcher.com
Public Sub CreateReportAsEmail(Title As String, Report As String)
    On Error GoTo On_Error
    
    Dim Session As Outlook.NameSpace
    Dim mail As MailItem
    Dim MyAddress As AddressEntry
    Dim Inbox As Outlook.Folder
    
    Set Session = Application.Session
    Set Inbox = Session.GetDefaultFolder(olFolderInbox)
    Set mail = Inbox.Items.Add("IPM.Mail")
    
    Set MyAddress = Session.CurrentUser.AddressEntry
    mail.Recipients.Add (MyAddress.Address)
    mail.Recipients.ResolveAll
    
    mail.Subject = Title
    mail.Body = Report
    
    mail.Save
    mail.Display
    
    
Exiting:
        Set Session = Nothing
        Exit Sub
On_Error:
    MsgBox "error=" &amp; Err.Number &amp; " " &amp; Err.Description
    Resume Exiting

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>fn_AtLeastOneOfACommaSeperatedStringIsInTheTargetString</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>fn_AtLeastOneOfACommaSeperatedStringIsInTheTargetString</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code> Function fn_bIsStringInTargetString(sStringToLookFor As String, sTargetStringToSearch As String) As Boolean


           Dim String1 As String
           Dim String2 As String
           Dim bX As Boolean


           String1 = sTargetStringToSearch
           String2 = "*" &amp; sStringToLookFor &amp; "*"

           bX = String1 Like String2
           fn_bIsStringInTargetString = bX


End Function


Function fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString(sTargetStringToSearch As String, sCommaSeperatedStringOfStringsToSearchFor As String) As String

         Dim arrX() As String
         Dim iX As Integer
         Dim iCounter As Integer
         arrX = Split(sCommaSeperatedStringOfStringsToSearchFor, ",")

         iCounter = 0
         For iX = 0 To UBound(arrX)

             If fn_bIsStringInTargetString(arrX(iX), sTargetStringToSearch) Then
                 iCounter = iCounter + 1
             End If

         Next '

'         If iCounter &gt; 0 Then
'             fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString = True
'         Else
'             fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString = False
'         End If

        fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString = CStr(iCounter * 100)




End Function


Private Sub Test()

     Dim bX As Boolean
     Dim sX As String
     Dim sListToLookFor As String

     sX = "Public Function fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString(sTargetStringToSearch As String, sCommaSeperatedStringOfStringsToSearchFor) As Boolean"
     sListToLookFor = "One,target,String"

     bX = fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString(sX, sListToLookFor)

     If bX Then
         MsgBox ("YES! The string is there")
     Else
         MsgBox ("NO! The string is NOT there")

     End If

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>fn_StripAStringOfCharactersFromAString</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>fn_StripAStringOfCharactersFromAString</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Function fn_StripACharacterFromAString(ByVal sTargetStringToStrip As String, ByVal SingleCharacterToStripOut As String) As String

    Dim intPos As Integer

     Do
         intPos = InStr(1, sTargetStringToStrip, SingleCharacterToStripOut, vbTextCompare)

         If intPos &gt; 0 Then
             sTargetStringToStrip = Left$(sTargetStringToStrip, intPos - 1) &amp; Right$(sTargetStringToStrip, Len(sTargetStringToStrip) - intPos)
         End If

     Loop While intPos &gt; 0

    fn_StripACharacterFromAString = Trim(sTargetStringToStrip)


End Function




Function fn_StripAStringOfCharactersFromAString(ByVal sTargetStringToStrip, sStringOfCharactersToStripOutOfTargetString As String) As String

     Dim iLenOfStringOfCharactersLeftToLookFor As Integer
     Dim iCounter As Integer
     Dim sCharacter As String
     Dim sX As String

     iLenOfStringOfCharactersLeftToLookFor = Len(sStringOfCharactersToStripOutOfTargetString)
     sX = sTargetStringToStrip


     For iCounter = 1 To iLenOfStringOfCharactersLeftToLookFor
             sCharacter = Mid(sStringOfCharactersToStripOutOfTargetString, iCounter, 1)
             sX = fn_StripACharacterFromAString(sX, sCharacter)
     Next 'iCounter

     fn_StripAStringOfCharactersFromAString = sX


End Function


Sub Test()
     Dim sTargetString As String
     Dim sCharacterToStripOut As String
     Dim sX As String

     sTargetString = "x123.v"
     sCharacterToStripOut = ".x"

     sX = fn_StripAStringOfCharactersFromAString(sTargetString, sCharacterToStripOut)
     MsgBox sX


End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>fn_vCleanUpSSN</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>fn_vCleanUpSSN</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Function fn_vCleanUpSSN(vSSN_ToCleanUp As Variant) As Variant

    Dim vX As Variant

    If IsNull(vSSN_ToCleanUp) Then
        vX = Null
    Else

        vX = fn_vStripOutAllCharactersExceptNumbers(vSSN_ToCleanUp)
        
        If Len(vX) &lt;&gt; 9 Then
            Debug.Print "SSN Length is wrong: " &amp; CStr(vX)
            vX = Null
        Else
        
            Select Case CStr(vX)
                Case "000000000"
                    vX = Null
                Case "111111111"
                    vX = Null
                Case "222222222"
                    vX = Null
                Case "333333333"
                    vX = Null
                Case "444444444"
                    vX = Null
                Case "555555555"
                    vX = Null
                Case "666666666"
                    vX = Null
                Case "777777777"
                    vX = Null
                Case "888888888"
                    vX = Null
                Case "999999999"
                    vX = Null
                Case Else
                    'no problem, so leave vx alone
            End Select
        
        
        End If
        
        
    End If

    fn_vCleanUpSSN = vX


End Function

Function fn_vCleanUpSSN(vSSN_ToCleanUp As Variant) As Variant

    Dim vX As Variant

    If IsNull(vSSN_ToCleanUp) Then
        vX = Null
    Else

        vX = fn_sStripOutAllCharactersExceptNumbers(CStr(vSSN_ToCleanUp))

        If Len(vX) &lt;&gt; 9 Then
            Debug.Print "SSN Length is wrong: " &amp; CStr(vX)
            vX = Null
        End If
    End If

    fn_vCleanUpSSN = vX


End Function


Function fn_sStripOutAllCharactersExceptNumbers(sStringToStrip As String)
    ' removing characters from a string

    Dim strOutput As String
    Dim lngStrLength As Long
    Dim lngCount As Long
    Dim strChar As String
    Dim lngChar As Long

    lngStrLength = Len(sStringToStrip)
    strOutput = ""

    For lngCount = 1 To lngStrLength
        strChar = Mid(sStringToStrip, lngCount, 1)
        lngChar = Asc(strChar)

            ' space is 32
            ' 0 to 9 is character codes 48 to 57
            ' A to Z is character codes 65 to 90
            ' a to z is character codes 97 to 122
        If (lngChar &gt;= 48 And lngChar &lt;= 57) Then
            strOutput = strOutput &amp; strChar
        End If
    Next

    Debug.Print "fn_sStripOutAllCharactersExceptNumbers - Input: " &amp; sStringToStrip
    Debug.Print "fn_sStripOutAllCharactersExceptNumbers - Output: " &amp; strOutput

    fn_sStripOutAllCharactersExceptNumbers = strOutput

End Function


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>mod_CleanUpFunctions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>mod_CleanUpFunctions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Compare Database
Option Explicit

Const k_EliminateCommasWhenChoppingStringsDown As Boolean = True    'This tells the function "fn_ChopTheStringDownIfItIsTooBig" to replace Commas with another character
Const k_CharacterToUseInsteadOfCommas As String = " "


Function fn_vStripOutAllCharactersForAddresses(vStringToStrip As Variant)
    ' removing characters from a string, except what I expect to see in an address

    Dim vOutput As String
    Dim lngStrLength As Long
    Dim lngCount As Long
    Dim strChar As String
    Dim lngChar As Long
    Dim sStringToStrip As String

    If IsNull(vStringToStrip) Then

        fn_vStripOutAllCharactersForAddresses = Null

    Else

        sStringToStrip = CStr(vStringToStrip)

        lngStrLength = Len(sStringToStrip)
        vOutput = ""

        For lngCount = 1 To lngStrLength
            strChar = Mid(sStringToStrip, lngCount, 1)
            lngChar = Asc(strChar)

                ' space is 32
                ' Apostrophe is 39, and 96, 145, 146
                ' &amp; is 38
                ' comma "," is 44
                ' period "." is 46
                ' Hyphen '-' is 45, 150, 151, 173, 175
                ' Slash '/' &amp; '\' is 47 and 92
                ' Comma is 130
                ' 0 to 9 is character codes 48 to 57
                ' A to Z is character codes 65 to 90
                ' a to z is character codes 97 to 122


            If (lngChar = 32) _
                Or (lngChar = 39) _
                Or (lngChar = 44) _
                Or (lngChar = 46) _
                Or (lngChar = 96) _
                Or (lngChar = 145) _
                Or (lngChar = 146) _
                Or (lngChar = 38) _
                Or (lngChar = 45) _
                Or (lngChar = 150) _
                Or (lngChar = 151) _
                Or (lngChar = 173) _
                Or (lngChar = 175) _
                Or (lngChar = 47) _
                Or (lngChar = 92) _
                Or (lngChar = 130) _
                Or (lngChar &gt;= 48 And lngChar &lt;= 57) _
                Or (lngChar &gt;= 65 And lngChar &lt;= 90) _
                Or (lngChar &gt;= 97 And lngChar &lt;= 122) Then

                vOutput = vOutput &amp; strChar
            End If
        Next

        Debug.Print "fn_vStripOutAllCharactersForAddresses - Input: " &amp; sStringToStrip
        Debug.Print "fn_vStripOutAllCharactersForAddresses - Output: " &amp; vOutput

        fn_vStripOutAllCharactersForAddresses = vOutput

    End If

End Function


Function fn_sStripOutAllCharactersExceptLettersAndNumbers(sStringToStrip As String)
    ' removing characters from a string
    
    Dim strOutput As String
    Dim lngStrLength As Long
    Dim lngCount As Long
    Dim strChar As String
    Dim lngChar As Long
    
    lngStrLength = Len(sStringToStrip)
    strOutput = ""
    
    For lngCount = 1 To lngStrLength
        strChar = Mid(sStringToStrip, lngCount, 1)
        lngChar = Asc(strChar)
        
            ' space is 32
            ' 0 to 9 is character codes 48 to 57
            ' A to Z is character codes 65 to 90
            ' a to z is character codes 97 to 122
        If (lngChar &gt;= 48 And lngChar &lt;= 57) _
            Or (lngChar &gt;= 65 And lngChar &lt;= 90) _
            Or (lngChar &gt;= 97 And lngChar &lt;= 122) Then
            
            strOutput = strOutput &amp; strChar
        End If
    Next
    
    'Debug.Print "fn_sStripOutAllCharactersExceptLettersAndNumbers - Input: " &amp; sStringToStrip
    'Debug.Print "fn_sStripOutAllCharactersExceptLettersAndNumbers - Output: " &amp; strOutput
    
    fn_sStripOutAllCharactersExceptLettersAndNumbers = strOutput
    
End Function


Function fn_vStripOutAllCharactersExceptNumbers(vStringToStrip As Variant)
    ' removing characters from a string

    Dim vOutput As Variant
    Dim lngStrLength As Long
    Dim lngCount As Long
    Dim strChar As String
    Dim lngChar As Long
    Dim sStringToStrip As String

    If IsNull(vStringToStrip) Then

        fn_vStripOutAllCharactersExceptNumbers = Null

    Else

        sStringToStrip = CStr(vStringToStrip)
        lngStrLength = Len(sStringToStrip)
        vOutput = ""

        For lngCount = 1 To lngStrLength
            strChar = Mid(sStringToStrip, lngCount, 1)
            lngChar = Asc(strChar)

                ' space is 32
                ' 0 to 9 is character codes 48 to 57
                ' A to Z is character codes 65 to 90
                ' a to z is character codes 97 to 122
            If (lngChar &gt;= 48 And lngChar &lt;= 57) Then
                vOutput = vOutput &amp; strChar
            End If
        Next

    '    Debug.Print "fn_vStripOutAllCharactersExceptNumbers - Input: " &amp; vStringToStrip
    '    Debug.Print "fn_vStripOutAllCharactersExceptNumbers - Output: " &amp; vOutput

        fn_vStripOutAllCharactersExceptNumbers = vOutput

    End If

End Function



Function fn_vCleanUpSSN(vSSN_ToCleanUp As Variant) As Variant

    Dim vX As Variant

    If IsNull(vSSN_ToCleanUp) Then
        vX = Null
    Else

        vX = fn_vStripOutAllCharactersExceptNumbers(vSSN_ToCleanUp)
        
        If Len(vX) &lt;&gt; 9 Then
            Debug.Print "SSN Length is wrong: " &amp; CStr(vX)
            vX = Null
        Else
        
            Select Case CStr(vX)
                Case "000000000"
                    vX = Null
                Case "111111111"
                    vX = Null
                Case "222222222"
                    vX = Null
                Case "333333333"
                    vX = Null
                Case "444444444"
                    vX = Null
                Case "555555555"
                    vX = Null
                Case "666666666"
                    vX = Null
                Case "777777777"
                    vX = Null
                Case "888888888"
                    vX = Null
                Case "999999999"
                    vX = Null
                Case Else
                    'no problem, so leave vx alone
            End Select
        
        
        End If
        
        
    End If

    fn_vCleanUpSSN = vX


End Function


Function fn_sCleanUpPT(sPT_ToCleanUp As String) As String

    Dim sX As String

    Select Case Trim(sPT_ToCleanUp)
        Case "1"
           sX = "IP"
        Case "3"
           sX = "ER"
        Case "4"
           'These are Gero/Psych patients from St. Lukes
           sX = "BH"
        Case Else
          sX = Mid(sPT_ToCleanUp, 1, 2)
    End Select

    fn_sCleanUpPT = sX

End Function

Function fn_vDateToDate(vDate As Variant) As Date

    Dim dX As Date

    If IsDate(vDate) Then

       dX = CDate(vDate)

    Else

       dX = CDate("1/1/1900")

    End If

    fn_vDateToDate = dX


End Function

Function fn_vCleanUpAddress(vAddress_ToCleanUp As Variant) As Variant

    Dim vX As Variant

    If IsNull(vAddress_ToCleanUp) Then
        vX = Null
    Else

        vX = fn_vStripOutAllCharactersForAddresses(vAddress_ToCleanUp)

    End If

    fn_vCleanUpAddress = vX


End Function

Function fn_CountyLookupForACity(vCityName As Variant) As String
    On Error GoTo Err_Handler
    
    Dim strWhere As String
    Dim strReturn As Variant
    Dim sX As String
    
    If IsNull(vCityName) Then
    
        fn_CountyLookupForACity = "**Missing City****"
    
    Else

        sX = UCase(vCityName)
        
        
        strWhere = "UCASE([City])=""" &amp; sX &amp; """"
        
        strReturn = Nz(DLookup("County", "CityCounty_L", strWhere), "")
        
        If Len(strReturn) &gt; 0 Then
            fn_CountyLookupForACity = strReturn
        Else
            fn_CountyLookupForACity = "**NEED_To_Fix****"
        End If
    End If
    
Exit_Handler:
    Exit Function
    
Err_Handler:
    MsgBox Err.Description, vbExclamation, "Error No: " &amp; Err.Number
    Resume Exit_Handler
End Function


Function fn_vCleanUpCounty(vCounty_ToCleanUp As Variant, vCityToUseInLookup As Variant) As Variant

    Dim vCounty As Variant

    If IsNull(vCounty_ToCleanUp) Or (vCounty_ToCleanUp = "na") Or (Trim(vCounty_ToCleanUp) = "") Then

        vCounty = fn_CountyLookupForACity(vCityToUseInLookup)

    Else

        vCounty = vCounty_ToCleanUp

    End If


    If k_EliminateCommasWhenChoppingStringsDown Then
        vCounty = CVar(Replace(CStr(vCounty), ",", k_CharacterToUseInsteadOfCommas))
    End If


    fn_vCleanUpCounty = vCounty


End Function




Function fn_vStripOutAllCharactersExceptLetters(vStringToStrip As Variant) As Variant
    ' removing characters from a string
    
    Dim vOutput As Variant
    Dim lngStrLength As Long
    Dim lngCount As Long
    Dim strChar As String
    Dim lngChar As Long
    
    
    If IsNull(vStringToStrip) Then
    
        fn_vStripOutAllCharactersExceptLetters = Null
        
    Else
        lngStrLength = Len(CStr(vStringToStrip))
        vOutput = ""
        
        For lngCount = 1 To lngStrLength
            strChar = Mid(vStringToStrip, lngCount, 1)
            lngChar = Asc(strChar)
            
                ' space is 32
                ' 0 to 9 is character codes 48 to 57
                ' A to Z is character codes 65 to 90
                ' a to z is character codes 97 to 122
            If (lngChar &gt;= 65 And lngChar &lt;= 90) _
                Or (lngChar &gt;= 97 And lngChar &lt;= 122) Then
                
                vOutput = vOutput &amp; strChar
            End If
        Next
        
        'Debug.Print "fn_sStripOutAllCharactersExceptLetters - Input: " &amp; vStringToStrip
        'Debug.Print "fn_sStripOutAllCharactersExceptLetters - Output: " &amp; vOutput
        
        fn_vStripOutAllCharactersExceptLetters = vOutput
        
    End If
    
End Function


Function fn_vCleanUpZip(vZip_ToCleanUp As Variant) As Variant

    Dim vX As Variant

    If IsNull(vZip_ToCleanUp) Or (vZip_ToCleanUp = "na") Or (Trim(vZip_ToCleanUp) = "") Then
    
        vX = Null
        
    Else

        vX = fn_vStripOutAllCharactersExceptNumbers(vZip_ToCleanUp)
        
        Select Case Len(vX)
        

                
            Case Is &lt; 5
            
                vX = Null
                
            Case Is = 6
            
                vX = Null
            Case Is = 7
            
                vX = Null
            Case Is = 8
            
                vX = Null
                
            Case Is &gt; 9
                
                vX = Null
                
            Case Else
            
                'Do nothing, b/c it is len=5 or =9 and that is fine
        End Select
        

    End If

    fn_vCleanUpZip = vX


End Function




Function fn_vCleanUpPhone(vPhone_ToCleanUp As Variant) As Variant

    Dim vX As Variant

    If IsNull(vPhone_ToCleanUp) Or (vPhone_ToCleanUp = "na") Or (Trim(vPhone_ToCleanUp) = "") Or (Trim(vPhone_ToCleanUp) = "000-000-0000") Then
    
        vX = Null
        
    Else

        vX = fn_vStripOutAllCharactersExceptNumbers(vPhone_ToCleanUp)
        
        Select Case Len(vX)
        
            Case Is &gt; 10
                
                vX = Null
                
            Case Is &lt; 5
            
                vX = Null
                
            Case Else
                'Do nothing, b/c it is len=10 and that is fine
        End Select
        

    End If

    fn_vCleanUpPhone = vX


End Function


Function fn_vCleanUpAge(vAge_ToCleanUp As Variant) As Variant

    Dim vX As Variant

    If IsNull(vAge_ToCleanUp) Or (vAge_ToCleanUp = "na") Or (Trim(vAge_ToCleanUp) = "") Then
    
        vX = Null
        
    Else
    
        If (Trim(vAge_ToCleanUp) = "NB") Then vAge_ToCleanUp = 0
        
        vX = fn_vStripOutAllCharactersExceptNumbers(vAge_ToCleanUp)
        
        Select Case Len(vX)
        
            Case Is &gt; 3
                
                vX = Null
                
                
            Case Else
            
                
            
                'Do nothing, b/c it is len&lt;=3 and that is fine
        End Select
        

    End If

    fn_vCleanUpAge = vX


End Function


Function fn_ChopTheStringDownIfItIsTooBig(vStringToChop As Variant, iMaxSizeOfStringAllowed As Integer) As Variant

    Dim vX As Variant

    If IsNull(vStringToChop) Or (vStringToChop = "na") Or (Trim(vStringToChop) = "") Then
    
        vX = Null
        
    Else
    
        If k_EliminateCommasWhenChoppingStringsDown Then
            vStringToChop = CVar(Replace(CStr(vStringToChop), ",", k_CharacterToUseInsteadOfCommas))
        End If
        
        Select Case Len(vX)
        
            Case Is &gt; iMaxSizeOfStringAllowed
                
                vX = Mid(CStr(vStringToChop), 1, iMaxSizeOfStringAllowed)
                
                
            Case Else
                vX = vStringToChop
        End Select
        

    End If

    fn_ChopTheStringDownIfItIsTooBig = vX




End Function



Function fn_vStripOutAllCharactersForICD9(vStringToStrip As Variant)
    ' removing characters from a string, except what I expect to see in an address
    
    Dim vOutput As String
    Dim lngStrLength As Long
    Dim lngCount As Long
    Dim strChar As String
    Dim lngChar As Long
    Dim sStringToStrip As String

    
    If IsNull(vStringToStrip) Then
    
        fn_vStripOutAllCharactersForICD9 = Null
    
    Else
        
        sStringToStrip = CStr(vStringToStrip)
        
        lngStrLength = Len(sStringToStrip)
        vOutput = ""
        
        For lngCount = 1 To lngStrLength
            strChar = Mid(sStringToStrip, lngCount, 1)
            lngChar = Asc(strChar)
            
                ' space is 32
                ' Apostrophe is 39, and 96, 145, 146
                ' &amp; is 38
                ' comma "," is 44
                ' period "." is 46                          'This was removed on 12/9/2011
                ' Hyphen '-' is 45, 150, 151, 173, 175
                ' Slash '/' &amp; '\' is 47 and 92
                ' Comma is 130
                ' 0 to 9 is character codes 48 to 57
                ' A to Z is character codes 65 to 90
                ' a to z is character codes 97 to 122
    
                
            If (lngChar = 32) _
                Or (lngChar &gt;= 48 And lngChar &lt;= 57) _
                Or (lngChar &gt;= 65 And lngChar &lt;= 90) _
                Or (lngChar &gt;= 97 And lngChar &lt;= 122) Then
                
                vOutput = vOutput &amp; strChar
            End If
        Next
        
        Debug.Print "fn_vStripOutAllCharactersForICD9 - Input: " &amp; sStringToStrip
        Debug.Print "fn_vStripOutAllCharactersForICD9 - Output: " &amp; vOutput
        
        fn_vStripOutAllCharactersForICD9 = vOutput
        
    End If
    
End Function



Function fn_vStripOutAllCharactersForICD9Description(vStringToStrip As Variant)
    ' removing characters from a string, except what I expect to see in an address

    Dim vOutput As String
    Dim lngStrLength As Long
    Dim lngCount As Long
    Dim strChar As String
    Dim lngChar As Long
'    Dim vX As Variant
    Dim sStringToStrip As String
    
    If IsNull(vStringToStrip) Then

        fn_vStripOutAllCharactersForICD9Description = Null

    Else


        sStringToStrip = CStr(vStringToStrip)

        If k_EliminateCommasWhenChoppingStringsDown Then
            sStringToStrip = Replace(sStringToStrip, ",", k_CharacterToUseInsteadOfCommas)          'commas cause problems w. CSV files, if they are used later.
        End If



        lngStrLength = Len(sStringToStrip)
        vOutput = ""

        For lngCount = 1 To lngStrLength
            strChar = Mid(sStringToStrip, lngCount, 1)
            lngChar = Asc(strChar)

                ' space is 32
                ' Apostrophe is 39, and 96, 145, 146
                ' &amp; is 38
                ' comma "," is 44
                ' period "." is 46
                ' Hyphen '-' is 45, 150, 151, 173, 175
                ' Slash '/' &amp; '\' is 47 and 92
                ' Comma is 130
                ' 0 to 9 is character codes 48 to 57
                ' A to Z is character codes 65 to 90
                ' a to z is character codes 97 to 122


            If (lngChar = 32) _
                Or (lngChar = 45) _
                Or (lngChar = 46) _
                Or (lngChar &gt;= 48 And lngChar &lt;= 57) _
                Or (lngChar &gt;= 65 And lngChar &lt;= 90) _
                Or (lngChar &gt;= 97 And lngChar &lt;= 122) Then

                vOutput = vOutput &amp; strChar
            End If
        Next

        Debug.Print "fn_vStripOutAllCharactersForICD9Description - Input: " &amp; sStringToStrip
        Debug.Print "fn_vStripOutAllCharactersForICD9Description - Output: " &amp; vOutput

        fn_vStripOutAllCharactersForICD9Description = fn_ChopTheStringDownIfItIsTooBig(vOutput, 60)

    End If

End Function


Function fn_dDate_From_vYYYYMMDD(vYYYYMMDD As Variant) As Date


    Dim sYYYYMMDD As String
    Dim sMM_dx As String
    Dim sYYYY_dx As String
    Dim sDD_dx As String
    Dim dX As Date



    If IsNull(vYYYYMMDD) Then

        fn_dDate_From_vYYYYMMDD = CDate("1/1/1900")

    Else

        sYYYYMMDD = CStr(vYYYYMMDD)

        If Len(sYYYYMMDD) = 8 Then

            sMM_dx = Mid(sYYYYMMDD, 5, 2)
            sDD_dx = Mid(sYYYYMMDD, 7, 2)
            sYYYY_dx = Mid(sYYYYMMDD, 1, 4)


            dX = CDate(sMM_dx &amp; "/" &amp; sDD_dx &amp; "/" &amp; sYYYY_dx)    ' Return a date.


            fn_dDate_From_vYYYYMMDD = dX
        Else


            fn_dDate_From_vYYYYMMDD = CDate("1/1/1900")

        End If

    End If

End Function


Function fn_Translate_StLukesPrimaryInsuranceCodes(vStLukeInsuranceCode As Variant) As Variant
    
    Dim sStLukeInsuranceCode As String
    
    If IsNull(vStLukeInsuranceCode) Then

        fn_Translate_StLukesPrimaryInsuranceCodes = Null

    Else
    
        sStLukeInsuranceCode = CStr(vStLukeInsuranceCode)
    
        Select Case UCase(Mid(Trim(sStLukeInsuranceCode), 1, 1))
        
            Case "X"
                
                'X or XO = Medicaid
                'XFE = ER HMO Medicaid
                'XFG = Geriatric/Pshyc, and Mental Health, Medicaid
                'XFI = First Choide Inpatient Medicaid
                'XFO = Outpatient Medicaid
            
                fn_Translate_StLukesPrimaryInsuranceCodes = "MEDICAID"
                
            Case "P"
                fn_Translate_StLukesPrimaryInsuranceCodes = "PRIVATE INSURANCE"
            Case Else
                fn_Translate_StLukesPrimaryInsuranceCodes = Null
        End Select
    
    End If
    
End Function


Function fn_GetNameFromFirstAndMiddleInititial(vName As Variant, sWhichName As String) As Variant

    ' First this assumes that the names are in the following format: "First MI"
    ' Note the second parameter is  either "f", or "m" for first name, or middle initial

    Dim sName As String

    Dim iLoc_Comma As Integer
    Dim iLoc_SpaceBetweenFirstNameAndMI As Integer
    Dim sX As String
    Dim vFirstName As Variant
    Dim vMI As Variant
     
     
     
    If IsNull(vName) Then
    
        vFirstName = Null
        vMI = Null

    
    Else
    
        sName = CStr(vName)
        
        iLoc_SpaceBetweenFirstNameAndMI = InStr(1, sName, " ")
        
        
        If iLoc_SpaceBetweenFirstNameAndMI &gt; 0 Then
        
            vFirstName = CVar(Trim(Mid(sName, 1, iLoc_SpaceBetweenFirstNameAndMI)))
            vMI = CVar(Trim(Mid(sName, (iLoc_SpaceBetweenFirstNameAndMI + 1), 1)))
            
        
        Else
        
            vMI = Null
            vFirstName = CVar(sName)
            
            
        End If
        
           
    End If
    
    
    Select Case Mid(sWhichName, 1, 1)
        Case "F"
            fn_GetNameFromFirstAndMiddleInititial = vFirstName
        Case "M"
            fn_GetNameFromFirstAndMiddleInititial = vMI

        Case Else
            fn_GetNameFromFirstAndMiddleInititial = vName
    End Select
    
    

End Function
 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Pad_string_with_Zeros</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Pad_string_with_Zeros</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Padding a number with leading zeros can be done using the Format() function: 

Format(YourNumericField, "0000")

'8 will be returned as 0008, 12 as 0012 and so forth. 

'Note that Format() actually returns a string/text value. Access is often forgiving when dealing with this kind of thing. If, for example 


'Can use this in an Excel cell b/c it is public
'=PERSONAL.XLSB!fn_PadStringToWith_x_Zeros(C2,3) 
Public Function fn_PadStringToWith_x_Zeros(sStringToPad As String, iNumberOfPlaces As Integer)

    Dim sX As String
    Dim iCounter As Integer
    
    sX = "0"
    
    For iCounter = 1 To (iNumberOfPlaces - 1)
        sX = sX &amp; "0"
    Next iCounter
    
    fn_PadStringToWith_x_Zeros = Format(sStringToPad, sX)


End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>sStripOutAllCharactersExceptLettersAndNumbers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>sStripOutAllCharactersExceptLettersAndNumbers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


'================================================================




Function fn_sStripOutAllCharactersExceptLettersAndNumbers(sStringToStrip As String)
    ' removing characters from a string
    
    Dim strOutput As String
    Dim lngStrLength As Long
    Dim lngCount As Long
    Dim strChar As String
    Dim lngChar As Long
    
    lngStrLength = Len(sStringToStrip)
    strOutput = ""
    
    For lngCount = 1 To lngStrLength
        strChar = Mid(sStringToStrip, lngCount, 1)
        lngChar = Asc(strChar)
        
            ' space is 32
            ' 0 to 9 is character codes 48 to 57
            ' A to Z is character codes 65 to 90
            ' a to z is character codes 97 to 122
        If (lngChar &gt;= 48 And lngChar &lt;= 57) _
            Or (lngChar &gt;= 65 And lngChar &lt;= 90) _
            Or (lngChar &gt;= 97 And lngChar &lt;= 122) Then
            
            strOutput = strOutput &amp; strChar
        End If
    Next
    
    'Debug.Print "fn_sStripOutAllCharactersExceptLettersAndNumbers - Input: " &amp; sStringToStrip
    'Debug.Print "fn_sStripOutAllCharactersExceptLettersAndNumbers - Output: " &amp; strOutput
    
    fn_sStripOutAllCharactersExceptLettersAndNumbers = strOutput
    
End Function

'================================================================







Numbers from 0 – 31 are the same as standard, nonprintableASCII codes

Chr(10) returns a linefeed character

The normal range for charcode is 0 – 255

Dim MyChar
MyChar = Chr(65) ' Returns A.
MyChar = Chr(97) ' Returns a.
MyChar = Chr(62) ' Returns &gt;.
MyChar = Chr(37) ' Returns %.


10: Line feed character

32:
33: !
34: "
35: #
36: $
37: %
38: &amp;
39: '
40: (
41: )
42: *
43: +
44: ,
45: -
46: .
47: /
48: 0
49: 1
50: 2
51: 3
52: 4
53: 5
54: 6
55: 7
56: 8
57: 9
58: :
59: ;
60: &lt;
61: =
62: &gt;
63: ?
64: @
65: A
66: B
67: C
68: D
69: E
70: F
71: G
72: H
73: I
74: J
75: K
76: L
77: M
78: N
79: O
80: P
81: Q
82: R
83: S
84: T
85: U
86: V
87: W
88: X
89: Y
90: Z
91: [
92: \
93: ]
94: ^
95: _
96: `
97: a
98: b
99: c
100: d
101: e
102: f
103: g
104: h
105: i
106: j
107: k
108: l
109: m
110: n
111: o
112: p
113: q
114: r
115: s
116: t
117: u
118: v
119: w
120: x
121: y
122: z
123: {
124: |
125: }
126: ~
127: 
128: €
129: 
130: ‚
131: ƒ
132: "
133: …
134: †
135: ‡
136: ˆ
137: ‰
138: Š
139: ‹
140: Œ
141: 
142: Ž
143: 
144: 
145: '
146: '
147: "
148: "
149: o
150: -
151: -
152: ˜
153: ™
154: š
155: ›
156: œ
157: 
158: ž
159: Ÿ
160:
161: ¡
162: ¢
163: £
164: ¤
165: ¥
166: ¦
167: §
168: ¨
169: ©
170: ª
171: "
172:
173: ­
174: ®
175: ¯
176: °
177: ±
178: ²
179: ³
180: ´
181: µ
182:
183: •
184: ¸
185: ¹
186: º
187: "
188: ¼
189: ½
190: ¾
191: ¿
192: À
193: Á
194: Â
195: Ã
196: Ä
197: Å
198: Æ
199: Ç
200: È
201: É
202: Ê
203: Ë
204: Ì
205: Í
206: Î
207: Ï
208: Ð
209: Ñ
210: Ò
211: Ó
212: Ô
213: Õ
214: Ö
215: ×
216: Ø
217: Ù
218: Ú
219: Û
220: Ü
221: Ý
222: Þ
223: ß
224: à
225: á
226: â
227: ã
228: ä
229: å
230: æ
231: ç
232: è
233: é
234: ê
235: ë
236: ì
237: í
238: î
239: ï
240: ð
241: ñ
242: ò
243: ó
244: ô
245: õ
246: ö
247: ÷
248: ø
249: ù
250: ú
251: û
252: ü
253: ý
254: þ
255: ÿ
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Adding A Procedure To A Module</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Adding A Procedure To A Module</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Creating a procedure via VBA code is really quite simple. 
'Build up a text string of the code, using vbCrLf to create new lines, and then insert that text with the InsertLines method, 
'passing to it the line number and the text string. 
'The following code will add a simple "Hello World" procedure named SayHello to the end of the module named Module1.

    Sub AddProcedureToModule()
        Dim VBProj As VBIDE.VBProject
        Dim VBComp As VBIDE.VBComponent
        Dim CodeMod As VBIDE.CodeModule
        Dim LineNum As Long
        Const DQUOTE = """" ' one " character

        Set VBProj = ActiveWorkbook.VBProject
        Set VBComp = VBProj.VBComponents("Module1")
        Set CodeMod = VBComp.CodeModule
        
        With CodeMod
            LineNum = .CountOfLines + 1
            .InsertLines LineNum, "Public Sub SayHello()"
            LineNum = LineNum + 1
            .InsertLines LineNum, "    MsgBox " &amp; DQUOTE &amp; "Hello World" &amp; DQUOTE
            LineNum = LineNum + 1
            .InsertLines LineNum, "End Sub"
        End With
    End Sub

'You can also build up a String variable with the content of the procedure and insert that string with one call to InsertLines. For example,

Dim CodePan As VBIDE.CodeModule
Dim S As String
Set CodePan = ThisWorkbook.VBProject.VBComponents("Module2").CodeModule
S = _
"Sub ABC()" &amp; vbNewLine &amp; _
"    MsgBox ""Hello World"",vbOkOnly" &amp; vbNewLine &amp; _
"End Sub" &amp; vbNewLine
With CodePan
    .InsertLines .CountOfLines + 1, S
End With
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Copy A Module From One Project To Another</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Copy A Module From One Project To Another</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'There is no direct way to copy a module from one project to another. 
'To accomplish this task, you must export the module from the Source VBProject 
'and then import that file into the Destination VBProject. The code below will do this. The function declaration is:

Function CopyModule(ModuleName As String, _
    FromVBProject As VBIDE.VBProject, _
    ToVBProject As VBIDE.VBProject, _
    OverwriteExisting As Boolean) As Boolean
    
ModuleName 'is the name of the module you want to copy from one project to another.
----------
FromVBProject 'is the VBProject that contains the module to be copied. This is the source VBProject.
-------------
ToVBProject 'is the VBProject in to which the module is to be copied. This is the destination VBProject.
-----------
OverwriteExisting 'indicates what to do if ModuleName already exists in the ToVBProject. If this is True the existing VBComponent will be removed from the ToVBProject. If this is False and the VBComponent already exists, the function does nothing and returns False.
-----------------
'The function returns True if successful or False is an error occurs. 
'The function will return False if any of the following are true:
		FromVBProject is nothing.
		ToVBProject is nothing.
		ModuleName is blank.
		FromVBProject is locked.
		ToVBProject is locked.
		ModuleName does not exist in FromVBProject.
		ModuleName exists in ToVBProject and OverwriteExisting is False.

'The complete code is shown below:


Function CopyModule(ModuleName As String, _
    FromVBProject As VBIDE.VBProject, _
    ToVBProject As VBIDE.VBProject, _
    OverwriteExisting As Boolean) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' CopyModule
    ' This function copies a module from one VBProject to
    ' another. It returns True if successful or  False
    ' if an error occurs.
    '
    ' Parameters:
    ' --------------------------------
    ' FromVBProject         The VBProject that contains the module
    '                       to be copied.
    '
    ' ToVBProject           The VBProject into which the module is
    '                       to be copied.
    '
    ' ModuleName            The name of the module to copy.
    '
    ' OverwriteExisting     If True, the VBComponent named ModuleName
    '                       in ToVBProject will be removed before
    '                       importing the module. If False and
    '                       a VBComponent named ModuleName exists
    '                       in ToVBProject, the code will return
    '                       False.
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    Dim VBComp As VBIDE.VBComponent
    Dim FName As String
    Dim CompName As String
    Dim S As String
    Dim SlashPos As Long
    Dim ExtPos As Long
    Dim TempVBComp As VBIDE.VBComponent
    
    '''''''''''''''''''''''''''''''''''''''''''''
    ' Do some housekeeping validation.
    '''''''''''''''''''''''''''''''''''''''''''''
    If FromVBProject Is Nothing Then
        CopyModule = False
        Exit Function
    End If
    
    If Trim(ModuleName) = vbNullString Then
        CopyModule = False
        Exit Function
    End If
    
    If ToVBProject Is Nothing Then
        CopyModule = False
        Exit Function
    End If
    
    If FromVBProject.Protection = vbext_pp_locked Then
        CopyModule = False
        Exit Function
    End If
    
    If ToVBProject.Protection = vbext_pp_locked Then
        CopyModule = False
        Exit Function
    End If
    
    On Error Resume Next
    Set VBComp = FromVBProject.VBComponents(ModuleName)
    If Err.Number &lt;&gt; 0 Then
        CopyModule = False
        Exit Function
    End If
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' FName is the name of the temporary file to be
    ' used in the Export/Import code.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    FName = Environ("Temp") &amp; "\" &amp; ModuleName &amp; ".bas"
    If OverwriteExisting = True Then
        ''''''''''''''''''''''''''''''''''''''
        ' If OverwriteExisting is True, Kill
        ' the existing temp file and remove
        ' the existing VBComponent from the
        ' ToVBProject.
        ''''''''''''''''''''''''''''''''''''''
        If Dir(FName, vbNormal + vbHidden + vbSystem) &lt;&gt; vbNullString Then
            Err.Clear
            Kill FName
            If Err.Number &lt;&gt; 0 Then
                CopyModule = False
                Exit Function
            End If
        End If
        With ToVBProject.VBComponents
            .Remove .Item(ModuleName)
        End With
    Else
        '''''''''''''''''''''''''''''''''''''''''
        ' OverwriteExisting is False. If there is
        ' already a VBComponent named ModuleName,
        ' exit with a return code of False.
        ''''''''''''''''''''''''''''''''''''''''''
        Err.Clear
        Set VBComp = ToVBProject.VBComponents(ModuleName)
        If Err.Number &lt;&gt; 0 Then
            If Err.Number = 9 Then
                ' module doesn't exist. ignore error.
            Else
                ' other error. get out with return value of False
                CopyModule = False
                Exit Function
            End If
        End If
    End If
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Do the Export and Import operation using FName
    ' and then Kill FName.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    FromVBProject.VBComponents(ModuleName).Export Filename:=FName
    
    '''''''''''''''''''''''''''''''''''''
    ' Extract the module name from the
    ' export file name.
    '''''''''''''''''''''''''''''''''''''
    SlashPos = InStrRev(FName, "\")
    ExtPos = InStrRev(FName, ".")
    CompName = Mid(FName, SlashPos + 1, ExtPos - SlashPos - 1)
    
    ''''''''''''''''''''''''''''''''''''''''''''''
    ' Document modules (SheetX and ThisWorkbook)
    ' cannot be removed. So, if we are working with
    ' a document object, delete all code in that
    ' component and add the lines of FName
    ' back in to the module.
    ''''''''''''''''''''''''''''''''''''''''''''''
    Set VBComp = Nothing
    Set VBComp = ToVBProject.VBComponents(CompName)
    
    If VBComp Is Nothing Then
        ToVBProject.VBComponents.Import Filename:=FName
    Else
        If VBComp.Type = vbext_ct_Document Then
            ' VBComp is destination module
            Set TempVBComp = ToVBProject.VBComponents.Import(FName)
            ' TempVBComp is source module
            With VBComp.CodeModule
                .DeleteLines 1, .CountOfLines
                S = TempVBComp.CodeModule.Lines(1, TempVBComp.CodeModule.CountOfLines)
                .InsertLines 1, S
            End With
            On Error GoTo 0
            ToVBProject.VBComponents.Remove TempVBComp
        End If
    End If
    Kill FName
    CopyModule = True
End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Creating A Procedure</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Creating A Procedure</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'You can use code to create code in a module. 
'The code below creates a simple "Hello World" Sub procedure. 
'You can either create a new VBComponent to hold the procedure or you can use an existing module. 
'Comment out the appropriate lines of code.

Sub CreateProcedure()
    Dim VBComp As VBIDE.VBComponent
    Dim CodeMod As VBIDE.CodeModule
    Dim S As String
    Dim LineNum As Long
    
    ' Use the next two lines to create a new module for the code
    'Set VBComp = ThisWorkbook.VBProject.VBComponents.Add(vbext_ct_StdModule)
    'VBComp.Name = "NewModule"
    ' OR use the following line to use an existing module for the code
    'Set VBComp = ThisWorkbook.VBProject.VBComponents("Module2")    
    
    Set CodeMod = VBComp.CodeModule
    LineNum = CodeMod.CountOfLines + 1
    S = "Sub HelloWorld()" &amp; vbCrLf &amp; _
        "    MsgBox ""Hello, World""" &amp; vbCrLf &amp; _
        "End Sub"
    CodeMod.InsertLines LineNum, S
End Sub

'This code creates the procedure:

    Sub HelloWorld()
        MsgBox "Hello, World"
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Deleting A Procedure From A Module</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Deleting A Procedure From A Module</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'This code will delete the procedure DeleteThisProc from the Module1. 
'You must specify the procedure type in order to differentiate between Property Get, Property Let, 
'and Property Set procedure, all of which have the same name. 

    Sub DeleteProcedureFromModule()
        Dim VBProj As VBIDE.VBProject
        Dim VBComp As VBIDE.VBComponent
        Dim CodeMod As VBIDE.CodeModule
        Dim StartLine As Long
        Dim NumLines As Long
        Dim ProcName As String
        
        Set VBProj = ActiveWorkbook.VBProject
        Set VBComp = VBProj.VBComponents("Module1")
        Set CodeMod = VBComp.CodeModule
    
        ProcName = "DeleteThisProc"
        With CodeMod
            StartLine = .ProcStartLine(ProcName, vbext_pk_Proc)
            NumLines = .ProcCountLines(ProcName, vbext_pk_Proc)
            .DeleteLines StartLine:=StartLine, Count:=NumLines
        End With
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Deleting All VBA Code In A Project</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Deleting All VBA Code In A Project</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'This code will delete ALL VBA code in a VBProject.

    Sub DeleteAllVBACode()
        Dim VBProj As VBIDE.VBProject
        Dim VBComp As VBIDE.VBComponent
        Dim CodeMod As VBIDE.CodeModule
        
        Set VBProj = ActiveWorkbook.VBProject
        
        For Each VBComp In VBProj.VBComponents
            If VBComp.Type = vbext_ct_Document Then
                Set CodeMod = VBComp.CodeModule
                With CodeMod
                    .DeleteLines 1, .CountOfLines
                End With
            Else
                VBProj.VBComponents.Remove VBComp
            End If
        Next VBComp
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>General Infomation About A Procedure</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>General Infomation About A Procedure</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'The code below returns the following information about a procedure in a module, 
'loaded into the ProcInfo type. 
'The function ProcedureInfo takes as input then name of the procedure, 
'a VBIDE.vbext_ProcKind procedure type, and a reference to the CodeModule object containing the procedure. 

    Public enum ProcScope
        ScopePrivate = 1
        ScopePublic = 2
        ScopeFriend = 3
        ScopeDefault = 4
    End Enum
    
    Public enum LineSplits
        LineSplitRemove = 0
        LineSplitKeep = 1
        LineSplitConvert = 2
    End Enum
    
    Public type ProcInfo
        ProcName As String
        ProcKind As VBIDE.vbext_ProcKind
        ProcStartLine As Long
        ProcBodyLine As Long
        ProcCountLines As Long
        ProcScope As ProcScope
        ProcDeclaration As String
    End Type

    Function ProcedureInfo(ProcName As String, ProcKind As VBIDE.vbext_ProcKind, _
        CodeMod As VBIDE.CodeModule) As ProcInfo
    
        Dim PInfo As ProcInfo
        Dim BodyLine As Long
        Dim Declaration As String
        Dim FirstLine As String
        
        
        BodyLine = CodeMod.ProcStartLine(ProcName, ProcKind)
        If BodyLine &gt; 0 Then
            With CodeMod
                PInfo.ProcName = ProcName
                PInfo.ProcKind = ProcKind
                PInfo.ProcBodyLine = .ProcBodyLine(ProcName, ProcKind)
                PInfo.ProcCountLines = .ProcCountLines(ProcName, ProcKind)
                PInfo.ProcStartLine = .ProcStartLine(ProcName, ProcKind)
                
                FirstLine = .Lines(PInfo.ProcBodyLine, 1)
                If StrComp(Left(FirstLine, Len("Public")), "Public", vbBinaryCompare) = 0 Then
                    PInfo.ProcScope = ScopePublic
                ElseIf StrComp(Left(FirstLine, Len("Private")), "Private", vbBinaryCompare) = 0 Then
                    PInfo.ProcScope = ScopePrivate
                ElseIf StrComp(Left(FirstLine, Len("Friend")), "Friend", vbBinaryCompare) = 0 Then
                    PInfo.ProcScope = ScopeFriend
                Else
                    PInfo.ProcScope = ScopeDefault
                End If
                PInfo.ProcDeclaration = GetProcedureDeclaration(CodeMod, ProcName, ProcKind, LineSplitKeep)
            End With
        End If
        
        ProcedureInfo = PInfo
    
    End Function
    
    
    Public Function GetProcedureDeclaration(CodeMod As VBIDE.CodeModule, _
        ProcName As String, ProcKind As VBIDE.vbext_ProcKind, _
        Optional LineSplitBehavior As LineSplits = LineSplitRemove)
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' GetProcedureDeclaration
    ' This return the procedure declaration of ProcName in CodeMod. The LineSplitBehavior
    ' determines what to do with procedure declaration that span more than one line using
    ' the "_" line continuation character. If LineSplitBehavior is LineSplitRemove, the
    ' entire procedure declaration is converted to a single line of text. If
    ' LineSplitBehavior is LineSplitKeep the "_" characters are retained and the
    ' declaration is split with vbNewLine into multiple lines. If LineSplitBehavior is
    ' LineSplitConvert, the "_" characters are removed and replaced with vbNewLine.
    ' The function returns vbNullString if the procedure could not be found.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        Dim LineNum As Long
        Dim S As String
        Dim Declaration As String
        
        On Error Resume Next
        LineNum = CodeMod.ProcBodyLine(ProcName, ProcKind)
        If Err.Number &lt;&gt; 0 Then
            Exit Function
        End If
        S = CodeMod.Lines(LineNum, 1)
        Do While Right(S, 1) = "_"
            Select Case True
                Case LineSplitBehavior = LineSplitConvert
                    S = Left(S, Len(S) - 1) &amp; vbNewLine
                Case LineSplitBehavior = LineSplitKeep
                    S = S &amp; vbNewLine
                Case LineSplitBehavior = LineSplitRemove
                    S = Left(S, Len(S) - 1) &amp; " "
            End Select
            Declaration = Declaration &amp; S
            LineNum = LineNum + 1
            S = CodeMod.Lines(LineNum, 1)
        Loop
        Declaration = SingleSpace(Declaration &amp; S)
        GetProcedureDeclaration = Declaration
        
    
    End Function
    
    Private Function SingleSpace(ByVal Text As String) As String
        Dim Pos As String
        Pos = InStr(1, Text, Space(2), vbBinaryCompare)
        Do Until Pos = 0
            Text = Replace(Text, Space(2), Space(1))
            Pos = InStr(1, Text, Space(2), vbBinaryCompare)
        Loop
        SingleSpace = Text
    End Function

'You can call the ProcedureInfo function using code like the following:

    Sub ShowProcedureInfo()
        Dim VBProj As VBIDE.VBProject
        Dim VBComp As VBIDE.VBComponent
        Dim CodeMod As VBIDE.CodeModule
        Dim CompName As String
        Dim ProcName As String
        Dim ProcKind As VBIDE.vbext_ProcKind
        Dim PInfo As ProcInfo
        
        CompName = "modVBECode"
        ProcName = "ProcedureInfo"
        ProcKind = vbext_pk_Proc
        
        Set VBProj = ActiveWorkbook.VBProject
        Set VBComp = VBProj.VBComponents(CompName)
        Set CodeMod = VBComp.CodeModule
        
        PInfo = ProcedureInfo(ProcName, ProcKind, CodeMod)
        
        Debug.Print "ProcName: " &amp; PInfo.ProcName
        Debug.Print "ProcKind: " &amp; CStr(PInfo.ProcKind)
        Debug.Print "ProcStartLine: " &amp; CStr(PInfo.ProcStartLine)
        Debug.Print "ProcBodyLine: " &amp; CStr(PInfo.ProcBodyLine)
        Debug.Print "ProcCountLines: " &amp; CStr(PInfo.ProcCountLines)
        Debug.Print "ProcScope: " &amp; CStr(PInfo.ProcScope)
        Debug.Print "ProcDeclaration: " &amp; PInfo.ProcDeclaration
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>HighlightRow_of_Selected_Cell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>HighlightRow_of_Selected_Cell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Add Reference (for VBIDE): "Microsoft Visual Basic for Applications Extensibility 5.3"
' File -&gt; Options -&gt; Trust Center -&gt; Trust Center Setttings -&gt; Macro Settings -&gt; Trust Access to the VBA Project object model.


    Sub CreateEventProcedure()
        Dim VBProj As VBIDE.VBProject
        Dim VBComp As VBIDE.VBComponent
        Dim CodeMod As VBIDE.CodeModule
        Dim LineNum As Long
        Const DQUOTE = """" ' one " character

        Set VBProj = ActiveWorkbook.VBProject
        Set VBComp = VBProj.VBComponents(ActiveSheet.Name)
        Set CodeMod = VBComp.CodeModule
        
        With CodeMod
            LineNum = .CreateEventProc("SelectionChange", "WorkSheet")
            LineNum = LineNum + 1
            .InsertLines LineNum, "    If Target.Cells.Count &gt; 1 Then Exit Sub"
            LineNum = LineNum + 1
            .InsertLines LineNum, "    Application.ScreenUpdating = False"
             LineNum = LineNum + 1
            .InsertLines LineNum, "    ' Clear the color of all the cells"
             LineNum = LineNum + 1
            .InsertLines LineNum, "    Cells.Interior.ColorIndex = 0"
              LineNum = LineNum + 1
            .InsertLines LineNum, "    With Target"
              LineNum = LineNum + 1
            .InsertLines LineNum, "        ' Highlight the entire row and column that contain the active cell"
              LineNum = LineNum + 1
            .InsertLines LineNum, "        .EntireRow.Interior.ColorIndex = 15"
              LineNum = LineNum + 1
            .InsertLines LineNum, "    End With"
              LineNum = LineNum + 1
            .InsertLines LineNum, "    Application.ScreenUpdating = True"
          End With
            
            
        MsgBox ("Done!")
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Listing All Procedures In A Module</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Listing All Procedures In A Module</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'This code will list all the procedures in Module1, beginning the listing in cell A1.

    Sub ListProcedures()
        Dim VBProj As VBIDE.VBProject
        Dim VBComp As VBIDE.VBComponent
        Dim CodeMod As VBIDE.CodeModule
        Dim LineNum As Long
        Dim NumLines As Long
        Dim WS As Worksheet
        Dim Rng As Range
        Dim ProcName As String
        Dim ProcKind As VBIDE.vbext_ProcKind
        
        Set VBProj = ActiveWorkbook.VBProject
        Set VBComp = VBProj.VBComponents("Module1")
        Set CodeMod = VBComp.CodeModule
        
        Set WS = ActiveWorkbook.Worksheets("Sheet1")
        Set Rng = WS.Range("A1")
        With CodeMod
            LineNum = .CountOfDeclarationLines + 1
            Do Until LineNum &gt;= .CountOfLines
                ProcName = .ProcOfLine(LineNum, ProcKind)
                Rng.Value = ProcName
                Rng(1, 2).Value = ProcKindString(ProcKind)
                LineNum = .ProcStartLine(ProcName, ProcKind) + _
                        .ProcCountLines(ProcName, ProcKind) + 1
                Set Rng = Rng(2, 1)
            Loop
        End With

    End Sub
    
    
    Function ProcKindString(ProcKind As VBIDE.vbext_ProcKind) As String
        Select Case ProcKind
            Case vbext_pk_Get
                ProcKindString = "Property Get"
            Case vbext_pk_Let
                ProcKindString = "Property Let"
            Case vbext_pk_Set
                ProcKindString = "Property Set"
            Case vbext_pk_Proc
                ProcKindString = "Sub Or Function"
            Case Else
                ProcKindString = "Unknown Type: " &amp; CStr(ProcKind)
        End Select
    End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Searching For Text In A Module</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Searching For Text In A Module</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'The CodeModule object has a Find method that you can use to search for text within the code module. 
'The Find method accepts ByRef Long parameters. 
'Upon input, these parameters specify the range of lines and column to search. 
'On output, these values will point to the found text. 
'To find the second and subsequent occurence of the text, you need to set the parameters to refer to the text following the found line and column. 
'The Find method returns True or False indicating whether the text was found. 
'The code below will search all of the code in Module1 and print a Debug message for each found occurrence. 
'Note the values set with the SL, SC, EL, and EC variables. The code loops until the Found variable is False.

    Sub SearchCodeModule()
        Dim VBProj As VBIDE.VBProject
        Dim VBComp As VBIDE.VBComponent
        Dim CodeMod As VBIDE.CodeModule
        Dim FindWhat As String
        Dim SL As Long ' start line
        Dim EL As Long ' end line
        Dim SC As Long ' start column
        Dim EC As Long ' end column
        Dim Found As Boolean
        
        Set VBProj = ActiveWorkbook.VBProject
        Set VBComp = VBProj.VBComponents("Module1")
        Set CodeMod = VBComp.CodeModule
        
        FindWhat = "findthis"
        
        With CodeMod
            SL = 1
            EL = .CountOfLines
            SC = 1
            EC = 255
            Found = .Find(target:=FindWhat, StartLine:=SL, StartColumn:=SC, _
                EndLine:=EL, EndColumn:=EC, _
                wholeword:=True, MatchCase:=False, patternsearch:=False)
            Do Until Found = False
                Debug.Print "Found at: Line: " &amp; CStr(SL) &amp; " Column: " &amp; CStr(SC)
                EL = .CountOfLines
                SC = EC + 1
                EC = 255
                Found = .Find(target:=FindWhat, StartLine:=SL, StartColumn:=SC, _
                    EndLine:=EL, EndColumn:=EC, _
                    wholeword:=True, MatchCase:=False, patternsearch:=False)
            Loop
        End With
    End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Total Code Lines In A Component Code Module</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Total Code Lines In A Component Code Module</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'This function will return the total code lines in a VBComponent. 
'It ignores blank lines and comment lines. It will return -1 if the project is locked.

    Public Function TotalCodeLinesInVBComponent(VBComp As VBIDE.VBComponent) As Long
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This returns the total number of code lines (excluding blank lines and
    ' comment lines) in the VBComponent referenced by VBComp. Returns -1
    ' if the VBProject is locked.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        Dim N As Long
        Dim S As String
        Dim LineCount As Long
        
        If VBComp.Collection.Parent.Protection = vbext_pp_locked Then
            TotalCodeLinesInVBComponent = -1
            Exit Function
        End If
        
        With VBComp.CodeModule
            For N = 1 To .CountOfLines
                S = .Lines(N, 1)
                If Trim(S) = vbNullString Then
                    ' blank line, skip it
                ElseIf Left(Trim(S), 1) = "'" Then
                    ' comment line, skip it
                Else
                    LineCount = LineCount + 1
                End If
            Next N
        End With
        TotalCodeLinesInVBComponent = LineCount
    End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Total Code Lines In A Component</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Total Code Lines In A Component</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'This function will return the total number of code lines in a VBComponent. 
'It ignores blank lines and comment lines. It will return -1 if the project is locked.

    Public Function TotalCodeLinesInVBComponent(VBComp As VBIDE.VBComponent) As Long
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This returns the total number of code lines (excluding blank lines and
    ' comment lines) in the VBComponent referenced by VBComp. Returns -1
    ' if the VBProject is locked.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        Dim N As Long
        Dim S As String
        Dim LineCount As Long
        
        If VBComp.Collection.Parent.Protection = vbext_pp_locked Then
            TotalCodeLinesInVBComponent = -1
            Exit Function
        End If
        
        With VBComp.CodeModule
            For N = 1 To .CountOfLines
                S = .Lines(N, 1)
                If Trim(S) = vbNullString Then
                    ' blank line, skip it
                ElseIf Left(Trim(S), 1) = "'" Then
                    ' comment line, skip it
                Else
                    LineCount = LineCount + 1
                End If
            Next N
        End With
        TotalCodeLinesInVBComponent = LineCount
    End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Total Code Lines In A Project</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Total Code Lines In A Project</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'This function will return the total number of code lines in all the components of a VBProject. 
'It ignores blank lines and comment lines. It will return -1 if the project is locked.

    Public Function TotalCodeLinesInProject(VBProj As VBIDE.VBProject) As Long
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This returns the total number of code lines (excluding blank lines and
    ' comment lines) in all VBComponents of VBProj. Returns -1 if VBProj
    ' is locked.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        
        Dim VBComp As VBIDE.VBComponent
        Dim LineCount As Long
        If VBProj.Protection = vbext_pp_locked Then
            TotalCodeLinesInProject = -1
            Exit Function
        End If
        For Each VBComp In VBProj.VBComponents
            LineCount = LineCount + TotalCodeLinesInVBComponent(VBComp)
        Next VBComp
        
        TotalCodeLinesInProject = LineCount
    End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBE_VBA_Extensibility</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Total Lines In A Project</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBE_VBA_Extensibility</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Total Lines In A Project</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'This code will return the count of lines in all components of the project referenced by VBProj. 
'If VBProj is omitted, the VBProject of the ActiveWorkbook is used. 
'The function will return -1 if the project is locked.

    Public Function TotalLinesInProject(Optional VBProj As VBIDE.VBProject = Nothing) As Long
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This returns the total number of lines in all components of the VBProject
    ' referenced by VBProj. If VBProj is missing, the VBProject of the ActiveWorkbook
    ' is used. Returns -1 if the VBProject is locked.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
        Dim VBP As VBIDE.VBProject
        Dim VBComp As VBIDE.VBComponent
        Dim LineCount As Long
        
        If VBProj Is Nothing Then
            Set VBP = ActiveWorkbook.VBProject
        Else
            Set VBP = VBProj
        End If
        
        If VBP.Protection = vbext_pp_locked Then
            TotalLinesInProject = -1
            Exit Function
        End If
        
        For Each VBComp In VBP.VBComponents
            LineCount = LineCount + VBComp.CodeModule.CountOfLines
        Next VBComp
        
        TotalLinesInProject = LineCount
    End Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>DISTINCTCOUNT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>DISTINCTCOUNT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'SYNTAX
DISTINCTCOUNT(
				&lt;column&gt;
			 ) 
			 
'Return
The number of distinct values in column.

NOTE
'DISTINCTCOUNT function includes the BLANK value. To skip the BLANK value, use the 
	DISTINCTCOUNTNOBLANK 
'function.			 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>TEXT_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>TEXT_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/text-functions-dax

ampersand (&amp;) to concatenate strings



BLANK
CODE
CONCATENATE


	-------------------------------- also Ampersand
	&amp; (ampersand)						Connects, or concatenates, two values to produce one continuous text value						
									[Region] &amp; ", " &amp; [City]
CONCATENATEX - 'returns the concatenation of those values in a single string result, seperated by a specified delimiter
	'e.g.Notice: DISTINCT gets rid of the duplicates
	Colors = CONCATENATEX(DISTINCT(Products[Color]),Products[Color], ", ")
	'It is possible to pass Unicode characters to the CONCATENATEX function, using the UNICHAR(number) function.	
	'new line is given by UNICHAR(10).
	
	Cities = IF(
				    //' if there is one city for the current 
				    //' filter context ...
				    DISTINCTCOUNT(City[CityName]) = 1,
				    //' ... shows the city's name
				    VALUES(City[CityName]),
				    //' Otherwise, list all city names    
				    CONCATENATEX(							--&lt;===
				        VALUES(City[CityName]),
				        City[CityName],
				        ",",
				        City[CityName],
				        ASC
				    )
				)	
	
		
	
Custom date and time formats for the FORMAT function
Custom Numeric Formats for the FORMAT function
EXACT
FIND
	'Returns the starting position of one text string within another text string. FIND is case-sensitive.
	FIND(
			&lt;find_text&gt;
			, &lt;within_text&gt;
			[, [&lt;start_num&gt;]
			[, &lt;NotFoundValue&gt;]]
			) 
	'e.g.: Caps sensitive, find 'Mouse" in column  'Product'[ProductName], 1= yes report back the position if found, if not found then put a zero(0)
	Mouse = FIND("Mouse",'Product'[ProductName],1,0)

FIXED
FORMAT
	can use to format many things, but regardless it convert them to a string, e.g. dates become strings
	e.g.
	Month Year = 
			//'  returns 2 digit month hypen 4 digit year
			//' MM-YYYY
			FORMAT(
			    'Date'[Date],
			    "MM-YYYY")
			//' MM =&gt; 01, MMM =&gt; Jan, MMMM =&gt; January	
				
	
LEFT
LEN
LOWER
MID
	'Returns a string of characters from the middle of a text string, given a starting position and length.
	MID(&lt;text&gt;, &lt;start_num&gt;, &lt;num_chars&gt;) 
	'Example
	Removes all spaces from text except for single spaces between words.
		
Pre-defined date and time formats for the FORMAT function
Pre-Defined Numeric Formats for the FORMAT function
REPLACE
REPT
RIGHT
SEARCH
SUBSTITUTE
	'replace multiple values in a column
		Segments = SUBSTITUTE(
		                     SUBSTITUTE(Segments[DealerSegmentation], "Signed Not Submitting Apps", "SNSA"),
		                     "Submitting Apps No Contracts", "SNS"
)

TRIM
	'Removes all spaces from text except for single spaces between words.
UNICHAR
UPPER
VALUE
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>extract_text_BETWEEN_Delimiters</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>extract_text_BETWEEN_Delimiters</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
My Example =============================================================================================== 
----------------sample of paths-------------------------------------
/Reports51/COLLECTIONS™ WORKBENCH™ Reporting/Volume Reports/Door Knock Cancel by Collector
/Collections/Collection
----------------------------------------------------------------------
'The root folder
================
Folder_01 = 
    var thePath = 'vw_ExecutionLog3_Modified_1'[ItemPath]
    var Slash_1 = FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],1,0)
    var Slash_2= FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],Slash_1+1,0)
    var Slash_3= FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],Slash_2+1,0)
    var LengthOfString = LEN(vw_ExecutionLog3_Modified_1[ItemPath])		
    var startNumber = IF(
                        Slash_1 = 0
                        , 0
                        ,Slash_1 + 1
                    )
     var numberCharacters = IF(
                        Slash_1 * Slash_2 = 0
                        , 0
                        ,Slash_2 - Slash_1 - 1
                    )      
     var result = MID(thePath, startNumber,numberCharacters)                            
return
result

'The second folder
=====================
Folder_02 = 
    var thePath = 'vw_ExecutionLog3_Modified_1'[ItemPath]
    var Slash_1 = FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],1,0)
    var Slash_2= FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],Slash_1+1,0)
    var Slash_3= FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],Slash_2+1,0)
    var Slash_4= FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],Slash_3+1,0)
    var LengthOfString = LEN(vw_ExecutionLog3_Modified_1[ItemPath])	
    var startNumber = IF(
                        Slash_2 = 0
                        , 1
                        ,Slash_2 + 1
                    )
     var numberCharacters = IF(
                         Slash_2 = 0 
                        , 0
                        ,IF( Slash_3 = 0, (  LengthOfString - Slash_2 ),  (  Slash_3 - Slash_2 - 1  ) )
                    )      
     var result = MID(thePath, startNumber,numberCharacters)                            
return
result

'Third Folder
======================
Folder_03 = 
    var thePath = 'vw_ExecutionLog3_Modified_1'[ItemPath]
    var Slash_1 = FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],1,0)
    var Slash_2= FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],Slash_1+1,0)
    var Slash_3= FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],Slash_2+1,0)
    var Slash_4= FIND("/",'vw_ExecutionLog3_Modified_1'[ItemPath],Slash_3+1,0)
    var LengthOfString = LEN(vw_ExecutionLog3_Modified_1[ItemPath])	
    var startNumber = IF(
                        Slash_2 = 0 || Slash_3 = 0
                        , 1
                        ,Slash_3 + 1
                    )
     var numberCharacters = IF(
                         Slash_2 = 0 || Slash_3 = 0
                        , 0
                        ,IF( Slash_4 = 0, (  LengthOfString - Slash_3 ),  (  Slash_4 - Slash_3 - 1  ) )
                    )      
     var result = MID(thePath, startNumber,numberCharacters)                            
return
result
=================================================================================================================
https://community.powerbi.com/t5/DAX-Commands-and-Tips/DAX-extract-text-between-delimiter/m-p/1191367

Q: 'How can I get the DDD using DAX? A text after equal and before semicolon
	AAA=BBB,CCC=DDD;EEE=FFF
	
------------------------------------------------------------------------------------------------------
	First Derived Column =
VAR FirstEqual =
    FIND (
        "=",
        'Table'[Sorting Text],
        1
    )
VAR SecondEqual =
    FIND (
        "=",
        'Table'[Sorting Text],
        FirstEqual + 1
    )
VAR Thirdampersand =
    FIND (
        ";",
        'Table'[Sorting Text],
        SecondEqual + 1
    )
RETURN
    MID (
        'Table'[Sorting Text],
        SecondEqual + 1,
        Thirdampersand - SecondEqual - 1
    )
    
------------------------------------------------------------------------------------------------------
    
 GetText =
		VAR OriginalText = 'Table'[Column1]
		VAR CountOfEqualSign =
		    LEN ( 'Table'[Column1] ) - LEN ( SUBSTITUTE ( 'Table'[Column1], "=", "" ) )
		VAR AddCaret =
		    SUBSTITUTE ( OriginalText, "=", "^", CountOfEqualSign - 1 )
		VAR FirstCharAfterCaret =
		    SEARCH ( "^", AddCaret ) + 1
		VAR SemiColonPostion =
		    SEARCH ( ";", OriginalText )
		VAR Result =
		    MID ( AddCaret, FirstCharAfterCaret, SemiColonPostion - FirstCharAfterCaret )
		RETURN
		    Result   
=================================================================================================================		    

Q: 'I have a column in my data model table which has values like this: 
'Example:AA:XX-yy:1234 --&gt; I would like to create 2 additional columns which contains only 
	XX-yy '(text between 2nd/3rd colon delimiter) and 
	1234 '(text after the last colon delimiter)
----------------------------------------------------------------------------------------------
First Derived Column = 
			var FirstColon = FIND(":",'Table1'[Origin Column],1)
			var SecondColon = FIND(":",'Table1'[Origin Column],FirstColon + 1)
			var ThirdColon = FIND(":",'Table1'[Origin Column],SecondColon + 1)
			return
			MID('Table1'[Origin Column], SecondColon + 1, ThirdColon - SecondColon - 1)	
			
Second Derived Column = 
			var FirstColon = FIND(":",'Table1'[Origin Column],1)
			var SecondColon = FIND(":",'Table1'[Origin Column],FirstColon + 1)
			var ThirdColon = FIND(":",'Table1'[Origin Column],SecondColon + 1)
			var LengthOfString = LEN('Table1'[Origin Column])
			return
			MID('Table1'[Origin Column],ThirdColon + 1, LengthOfString -  ThirdColon + 1)			
----------------------------------------------------------------------------------------------
First Derived Column = 	Text.Split([Value], ":"){2}		
'It splits the text on each colon and returns a list of the separated values. 
'To fetch the 3rd value from the list you use {2} because the count starts at zero here.			
			
Second Derived Column = Text.AfterDelimiter([Value], ":", {0, RelativePosition.FromEnd})		</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>