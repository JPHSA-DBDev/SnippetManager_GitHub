<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>NETSH</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>NETSH_display_WiFi_Saved_Password</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>NETSH</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>NETSH_display_WiFi_Saved_Password</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'http://blog.jocha.se/tech/display-all-saved-wifi-passwords

Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope LocalMachine


(netsh wlan show profiles) | 
    Select-String "\:(.+)$" | 
    %{$name=$_.Matches.Groups[1].Value.Trim(); $_} | 
    %{(netsh wlan show profile name="$name" key=clear)}  | 
    Select-String "Key Content\W+\:(.+)$" | 
    %{$pass=$_.Matches.Groups[1].Value.Trim(); $_} | 
    %{[PSCustomObject]@{ PROFILE_NAME=$name;PASSWORD=$pass }} | 
    Format-Table -AutoSize 
    
    
'To see the profile (and password)
&gt;netsh wlan show profile name="JPHSA" key=clear
    
    
'To delete a profile    
&gt; netsh wlan delete profile name='JPHSA'    

'Show the list of wireless profiles: 
netsh wlan show profiles

'Retrieve the stored key (WPA, WEP, etc) of a profile: 
netsh wlan show profiles name=[profile name] key=clear

'Delete a wireless profile: 
netsh wlan delete profile name=[profile name]

'Set a network’s priority: 
netsh wlan set profileorder name=[profile name]interface=[interface_name] priority=1

'Stop automatically connecting to a network: 
netsh wlan set profileparameter name=[profile name] connectionmode=manual</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_browser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>URL of each Favorite in alphabetical order =&gt; CSV file on Desktop</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_browser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>URL of each Favorite in alphabetical order =&gt; CSV file on Desktop</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'# URL of each Favorite in alphabetical order =&gt; CSV file on Desktop

# Gathers a list of the current users IE Favorites
Get-ChildItem $env:userprofile\favorites -Recurse -Include *.url |
 where {select-string -InputObject $_ -Quiet "^URL=http"} | 
 select @{Name="Name"; Expression={[IO.Path]::GetFileNameWithoutExtension($_.FullName)}},
 @{Name="URL"; Expression={get-content $_ | ? {$_ -match "^URL=http"} | % {$_.Substring(4)}}} |
#Sorts and exports them to a CSV on user's Desktop
 sort Name |Export-Csv -Path $env:userprofile\Desktop\favorites.csv -NoTypeInformation
#Opens the CSV file for reading
Invoke-Item $env:userprofile\Desktop\favorites.csv


'# OUTPUT
'=================================================================================
'Name							URL
'Access Achieve					https://magellan.learn.com/laprovider
'Anasazi - Logon					https://ansoaz.cernerworks.com/JEF/auth/login.aspx
'Bing							http://go.microsoft.com/fwlink/p/?LinkId=255142
'Clicial Advisor					https://ca.magellanhealth.com/vpn/index.html
'Contacts - New					http://wbsql1/Reports_PROD/report/Reports_For_All_Users/001_Telephone_Contacts
'Dev Essentials  - Visual Studio	https://www.visualstudio.com/dev-essentials/
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Search_for_string_in_File</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Search_for_string_in_File</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

' suppose we’re interested in tracking down all the files in a specific folder (C:\Scripts)
'	that include the phrase Hey, Scripting Guy! How do we do that? Like this:
Select-String C:\Scripts\*.txt -pattern "Hey, Scripting Guy!"
'Notice that we don’t even need to use Get-Content to open the text file; instead we simply call the Select-String cmdlet

'OUTPUT:
C:\Scripts\Everyone.txt:3:Hey, Scripting Guy! How can I search a text file using VBScript?
C:\Scripts\Test.txt:1:Hey, Scripting Guy! How can I search a text file using Windows PowerShell?

'What’s especially cool here is that each line of information is, beneath the covers, an object. 
'Notice what happens if we retrieve this content and then pipe it to the Format-List cmdlet. First we issue this command:

Select-String C:\Scripts\*.txt -pattern "Hey, Scripting Guy!" | Format-List

'OUTPUT:
===========
'IgnoreCase : True
'LineNumber : 3
'Line       : Hey, Scripting Guy! How can I search a text file using VBScript?
'Filename   : Everyone.txt
'Path       : C:\Scripts\Everyone.txt
'Pattern    : Hey, Scripting Guy!

'IgnoreCase : True
'LineNumber : 1
'Line       : Hey, Scripting Guy! How can I search a text file using Windows PowerShell?
'Filename   : Test.txt
'Path       : C:\Scripts\Test.txt
'Pattern    : Hey, Scripting Guy!

'Want to see just the file name for each file containing the target string? Try this command:
Select-String C:\Scripts\*.txt -pattern "Hey, Scripting Guy!" | Select-Object Filename

OUTPUT:
'Filename
'--------
'Everyone.txt
'Test.txt</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Help</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>showwindow_option_for_help</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Help</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>showwindow_option_for_help</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' This brings up the help in a seperate window
&gt;help get-method -ShowWindow


'Display detailed help
&gt; Get-Help ls -Detailed

' Display full information for a cmdlet
&gt; Get-Help Format-Table -Full


'Display examples for a cmdlet
&gt; Get-Help Start-Service -Examples

'Display parameter help
&gt; Get-Help Format-List -Parameter GroupBy

'Search for a word in cmdlet help
Get-Help Add-Member -Full | Out-String -Stream | Select-String -Pattern Clixml</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>alias</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>alias</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
&gt;Get-Alias




#region Aliasing
	
	# Notice how older DOS/Linux commands work in PowerShell
	dir
	ls
	
	# But how? With command aliasing
	# The aliases dir and ls both point to the cmdlet Get-Childitem
	Get-Alias dir
	Get-Alias ls
	
	# We can see all of the aliases for a cmdlet
	Get-Alias -Definition Get-ChildItem
	
	# There are lots of aliases
	Get-Alias
	
	# Note: Aliases are fine for command line use or quick prototypes
	# For clarity however it is a best practice to use the full cmdlet
	# name in all scripts you write.

#endregion Aliasing




\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# Setting up provider aliases
New-PSDrive -Name BPSD `
            -P
            -Root 'C:\PS\Beginning PowerShell Scripting for Developers'

Set-Location BPSD:
Get-ChildItem | Format-Table

Set-Location BPSD:\demo			#Set a new location
Get-ChildItem | Format-Table	#This now gives me a 'dir' of that folder


# When done, either use the remove cmdlet below, otherwise
# when this session ends so does the lifespan of the PSDrive
# Make sure to set your location outside the PSDrive first
Set-Location 'C:\PS\Beginning PowerShell Scripting for Developers'
Remove-PSDrive BPSD		#will cause an error if you are in the folder when you run the command

=========================================================================
&gt;Get-Alias

#'CommandType     Name                                               Version    Source                                                                            
#'-----------     ----                                               -------    ------                                                                            
#'Alias           % -&gt; ForEach-Object                                                                                                                             
#'Alias           ? -&gt; Where-Object                                                                                                                               
#'Alias           ac -&gt; Add-Content                                                                                                                               
#'Alias           asnp -&gt; Add-PSSnapin                                                                                                                            
#'Alias           cat -&gt; Get-Content                                                                                                                              
#'Alias           cd -&gt; Set-Location                                                                                                                              
#'Alias           CFS -&gt; ConvertFrom-String                          3.1.0.0    Microsoft.PowerShell.Utility                                                      
#'Alias           chdir -&gt; Set-Location                                                                                                                           
#'Alias           clc -&gt; Clear-Content                                                                                                                            
#'Alias           clear -&gt; Clear-Host                                                                                                                             
#'Alias           clhy -&gt; Clear-History                                                                                                                           
#'Alias           cli -&gt; Clear-Item                                                                                                                               
#'Alias           clp -&gt; Clear-ItemProperty                                                                                                                       
#'Alias           cls -&gt; Clear-Host                                                                                                                               
#'Alias           clv -&gt; Clear-Variable                                                                                                                           
#'Alias           cnsn -&gt; Connect-PSSession                                                                                                                       
#'Alias           compare -&gt; Compare-Object                                                                                                                       
#'Alias           copy -&gt; Copy-Item                                                                                                                               
#'Alias           cp -&gt; Copy-Item                                                                                                                                 
#'Alias           cpi -&gt; Copy-Item                                                                                                                                
#'Alias           cpp -&gt; Copy-ItemProperty                                                                                                                        
#'Alias           curl -&gt; Invoke-WebRequest                                                                                                                       
#'Alias           cvpa -&gt; Convert-Path                                                                                                                            
#'Alias           dbp -&gt; Disable-PSBreakpoint                                                                                                                     
#'Alias           del -&gt; Remove-Item                                                                                                                              
#'Alias           diff -&gt; Compare-Object                                                                                                                          
#'Alias           dir -&gt; Get-ChildItem                                                                                                                            
#'Alias           dnsn -&gt; Disconnect-PSSession                                                                                                                    
#'Alias           ebp -&gt; Enable-PSBreakpoint                                                                                                                      
#'Alias           echo -&gt; Write-Output                                                                                                                            
#'Alias           epal -&gt; Export-Alias                                                                                                                            
#'Alias           epcsv -&gt; Export-Csv                                                                                                                             
#'Alias           epsn -&gt; Export-PSSession                                                                                                                        
#'Alias           erase -&gt; Remove-Item                                                                                                                            
#'Alias           etsn -&gt; Enter-PSSession                                                                                                                         
#'Alias           exsn -&gt; Exit-PSSession                                                                                                                          
#'Alias           fc -&gt; Format-Custom                                                                                                                             
#'Alias           fhx -&gt; Format-Hex                                  3.1.0.0    Microsoft.PowerShell.Utility                                                      
#'Alias           fl -&gt; Format-List                                                                                                                               
#'Alias           foreach -&gt; ForEach-Object                                                                                                                       
#'Alias           ft -&gt; Format-Table                                                                                                                              
#'Alias           fw -&gt; Format-Wide                                                                                                                               
#'Alias           gal -&gt; Get-Alias                                                                                                                                
#'Alias           gbp -&gt; Get-PSBreakpoint                                                                                                                         
#'Alias           gc -&gt; Get-Content                                                                                                                               
#'Alias           gcb -&gt; Get-Clipboard                               3.1.0.0    Microsoft.PowerShell.Management                                                   
#'Alias           gci -&gt; Get-ChildItem                                                                                                                            
#'Alias           gcm -&gt; Get-Command                                                                                                                              
#'Alias           gcs -&gt; Get-PSCallStack                                                                                                                          
#'Alias           gdr -&gt; Get-PSDrive                                                                                                                              
#'Alias           ghy -&gt; Get-History                                                                                                                              
#'Alias           gi -&gt; Get-Item                                                                                                                                  
#'Alias           gjb -&gt; Get-Job                                                                                                                                  
#'Alias           gl -&gt; Get-Location                                                                                                                              
#'Alias           gm -&gt; Get-Member                                                                                                                                
#'Alias           gmo -&gt; Get-Module                                                                                                                               
#'Alias           gp -&gt; Get-ItemProperty                                                                                                                          
#'Alias           gps -&gt; Get-Process                                                                                                                              
#'Alias           gpv -&gt; Get-ItemPropertyValue                                                                                                                    
#'Alias           group -&gt; Group-Object                                                                                                                           
#'Alias           gsn -&gt; Get-PSSession                                                                                                                            
#'Alias           gsnp -&gt; Get-PSSnapin                                                                                                                            
#'Alias           gsv -&gt; Get-Service                                                                                                                              
#'Alias           gu -&gt; Get-Unique                                                                                                                                
#'Alias           gv -&gt; Get-Variable                                                                                                                              
#'Alias           gwmi -&gt; Get-WmiObject                                                                                                                           
#'Alias           h -&gt; Get-History                                                                                                                                
#'Alias           history -&gt; Get-History                                                                                                                          
#'Alias           icm -&gt; Invoke-Command                                                                                                                           
#'Alias           iex -&gt; Invoke-Expression                                                                                                                        
#'Alias           ihy -&gt; Invoke-History                                                                                                                           
#'Alias           ii -&gt; Invoke-Item                                                                                                                               
#'Alias           ipal -&gt; Import-Alias                                                                                                                            
#'Alias           ipcsv -&gt; Import-Csv                                                                                                                             
#'Alias           ipmo -&gt; Import-Module                                                                                                                           
#'Alias           ipsn -&gt; Import-PSSession                                                                                                                        
#'Alias           irm -&gt; Invoke-RestMethod                                                                                                                        
#'Alias           ise -&gt; powershell_ise.exe                                                                                                                       
#'Alias           iwmi -&gt; Invoke-WmiMethod                                                                                                                        
#'Alias           iwr -&gt; Invoke-WebRequest                                                                                                                        
#'Alias           kill -&gt; Stop-Process                                                                                                                            
#'Alias           lp -&gt; Out-Printer                                                                                                                               
#'Alias           ls -&gt; Get-ChildItem                                                                                                                             
#'Alias           man -&gt; help                                                                                                                                     
#'Alias           md -&gt; mkdir                                                                                                                                     
#'Alias           measure -&gt; Measure-Object                                                                                                                       
#'Alias           mi -&gt; Move-Item                                                                                                                                 
#'Alias           mount -&gt; New-PSDrive                                                                                                                            
#'Alias           move -&gt; Move-Item                                                                                                                               
#'Alias           mp -&gt; Move-ItemProperty                                                                                                                         
#'Alias           mv -&gt; Move-Item                                                                                                                                 
#'Alias           nal -&gt; New-Alias                                                                                                                                
#'Alias           ndr -&gt; New-PSDrive                                                                                                                              
#'Alias           ni -&gt; New-Item                                                                                                                                  
#'Alias           nmo -&gt; New-Module                                                                                                                               
#'Alias           npssc -&gt; New-PSSessionConfigurationFile                                                                                                         
#'Alias           nsn -&gt; New-PSSession                                                                                                                            
#'Alias           nv -&gt; New-Variable                                                                                                                              
#'Alias           ogv -&gt; Out-GridView                                                                                                                             
#'Alias           oh -&gt; Out-Host                                                                                                                                  
#'Alias           popd -&gt; Pop-Location                                                                                                                            
#'Alias           ps -&gt; Get-Process                                                                                                                               
#'Alias           pushd -&gt; Push-Location                                                                                                                          
#'Alias           pwd -&gt; Get-Location                                                                                                                             
#'Alias           r -&gt; Invoke-History                                                                                                                             
#'Alias           rbp -&gt; Remove-PSBreakpoint                                                                                                                      
#'Alias           rcjb -&gt; Receive-Job                                                                                                                             
#'Alias           rcsn -&gt; Receive-PSSession                                                                                                                       
#'Alias           rd -&gt; Remove-Item                                                                                                                               
#'Alias           rdr -&gt; Remove-PSDrive                                                                                                                           
#'Alias           ren -&gt; Rename-Item                                                                                                                              
#'Alias           ri -&gt; Remove-Item                                                                                                                               
#'Alias           rjb -&gt; Remove-Job                                                                                                                               
#'Alias           rm -&gt; Remove-Item                                                                                                                               
#'Alias           rmdir -&gt; Remove-Item                                                                                                                            
#'Alias           rmo -&gt; Remove-Module                                                                                                                            
#'Alias           rni -&gt; Rename-Item                                                                                                                              
#'Alias           rnp -&gt; Rename-ItemProperty                                                                                                                      
#'Alias           rp -&gt; Remove-ItemProperty                                                                                                                       
#'Alias           rsn -&gt; Remove-PSSession                                                                                                                         
#'Alias           rsnp -&gt; Remove-PSSnapin                                                                                                                         
#'Alias           rujb -&gt; Resume-Job                                                                                                                              
#'Alias           rv -&gt; Remove-Variable                                                                                                                           
#'Alias           rvpa -&gt; Resolve-Path                                                                                                                            
#'Alias           rwmi -&gt; Remove-WmiObject                                                                                                                        
#'Alias           sajb -&gt; Start-Job                                                                                                                               
#'Alias           sal -&gt; Set-Alias                                                                                                                                
#'Alias           saps -&gt; Start-Process                                                                                                                           
#'Alias           sasv -&gt; Start-Service                                                                                                                           
#'Alias           sbp -&gt; Set-PSBreakpoint                                                                                                                         
#'Alias           sc -&gt; Set-Content                                                                                                                               
#'Alias           scb -&gt; Set-Clipboard                               3.1.0.0    Microsoft.PowerShell.Management                                                   
#'Alias           select -&gt; Select-Object                                                                                                                         
#'Alias           set -&gt; Set-Variable                                                                                                                             
#'Alias           shcm -&gt; Show-Command                                                                                                                            
#'Alias           si -&gt; Set-Item                                                                                                                                  
#'Alias           sl -&gt; Set-Location                                                                                                                              
#'Alias           sleep -&gt; Start-Sleep                                                                                                                            
#'Alias           sls -&gt; Select-String                                                                                                                            
#'Alias           sort -&gt; Sort-Object                                                                                                                             
#'Alias           sp -&gt; Set-ItemProperty                                                                                                                          
#'Alias           spjb -&gt; Stop-Job                                                                                                                                
#'Alias           spps -&gt; Stop-Process                                                                                                                            
#'Alias           spsv -&gt; Stop-Service                                                                                                                            
#'Alias           start -&gt; Start-Process                                                                                                                          
#'Alias           sujb -&gt; Suspend-Job                                                                                                                             
#'Alias           sv -&gt; Set-Variable                                                                                                                              
#'Alias           swmi -&gt; Set-WmiInstance                                                                                                                         
#'Alias           tee -&gt; Tee-Object                                                                                                                               
#'Alias           trcm -&gt; Trace-Command                                                                                                                           
#'Alias           type -&gt; Get-Content                                                                                                                             
#'Alias           wget -&gt; Invoke-WebRequest                                                                                                                       
#'Alias           where -&gt; Where-Object                                                                                                                           
#'Alias           wjb -&gt; Wait-Job                                                                                                                                 
#'Alias           write -&gt; Write-Output   
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FIREWALL_STATE_local_or_remote_machine_using_NETSH</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FIREWALL_STATE_local_or_remote_machine_using_NETSH</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://power-shell.com/2015/powershell-scripts/get-curent-firewall-status-utilizing-netsh/

#' USAGE:
&gt;Get-FirewallState -HOSTNAME SERVER01

#' The function:

Function Get-FirewallState
{
	[CmdletBinding()]
	
	Param ([Parameter(Mandatory = $true)][string]$HOSTNAME)
$ErrorActionPreference = "Stop"
Try {
$FirewallBlock = {
				$content = netsh advfirewall show allprofiles
				If ($domprofile = $content | Select-String 'Domain Profile' -Context 2 | Out-String)
				{ $domainpro = ($domprofile.Substring($domprofile.Length - 9)).Trim()}
				Else { $domainpro = $null }
				If ($priprofile = $content | Select-String 'Private Profile' -Context 2 | Out-String)
				{ $privatepro = ($priprofile.Substring($priprofile.Length - 9)).Trim()}
				Else { $privatepro = $null }
				If ($pubprofile = $content | Select-String 'Public Profile' -Context 2 | Out-String)
				{ $publicpro = ($pubprofile.Substring($pubprofile.Length - 9)).Trim()}
				Else { $publicpro = $null }
				
				$FirewallObject = New-Object PSObject
				Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallDomain" -value $domainpro
				Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPrivate" -value $privatepro
				Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPublic" -value $publicpro
				$FirewallObject
			}
 
Invoke-Command -computerName $HOSTNAME -command $FirewallBlock | Select-Object FirewallDomain, FirewallPrivate, FirewallPublic
 
}
Catch
		{
       Write-Host  ($_.Exception.Message -split ' For')[0] -ForegroundColor Red
        }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FIREWALL_STATE_pipeline_input</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FIREWALL_STATE_pipeline_input</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gist.github.com/micmaher/f101132fd86554062aaaa50b234b3cdc
==============
'USAGE

'1] The Input file
LT-103336
LT-103110

'2] Call the function, and assign the items in the list to the 'Name' variable
'	Basically, the select operation is turning the object into a property value. 

&gt;$Computers = get-content computers_2.txt -OutVariable Name;
&gt;$Computers  | Select @{ Name = "Name"; Expression = {$_}} | Get-FirewallState ;


'OR
'3]

$Computers = get-content computers_2.txt -OutVariable Name;
$Computers  | Get-FirewallState -Hostname {$_} ;


=============

#Requires -Version 4.0
&lt;#
    .SYNOPSIS
        Gets the Firewall State for for a local, remote or a piped list of machines
    .DESCRIPTION
        Will require PowerShell 4.0 or later
        Gets Public, Private and Domain Profiles
    .EXAMPLE
        Gets the firewall state for all domain controllers
            Get-ADDomainController -filter * | Get-FirewallState
    .PARAMETER Hostname
        The host to query
	.NOTES
        Author: Based on http://power-shell.com/2015/powershell-scripts/get-curent-firewall-status-utilizing-netsh/
        I added pipeline support and the inclusion of the hostname in the results
    #&gt;
Function Get-FirewallState
{
	[CmdletBinding()]

	Param ([Parameter(Mandatory = $true, ValueFromPipelineByPropertyName)]
    [Alias("Name")]
    [string]$Hostname)

Begin{
    $ErrorActionPreference = "Stop"
}

Process{
    Try {
    $FirewallBlock = {
				    $content = netsh advfirewall show allprofiles
				    If ($domprofile = $content | Select-String 'Domain Profile' -Context 2 | Out-String)
				    { $domainpro = ($domprofile.Substring($domprofile.Length - 9)).Trim()}
				    Else { $domainpro = $null }
				    If ($priprofile = $content | Select-String 'Private Profile' -Context 2 | Out-String)
				    { $privatepro = ($priprofile.Substring($priprofile.Length - 9)).Trim()}
				    Else { $privatepro = $null }
				    If ($pubprofile = $content | Select-String 'Public Profile' -Context 2 | Out-String)
				    { $publicpro = ($pubprofile.Substring($pubprofile.Length - 9)).Trim()}
				    Else { $publicpro = $null }

				    $FirewallObject = New-Object PSObject
				    Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallDomain" -value $domainpro
				    Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPrivate" -value $privatepro
				    Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPublic" -value $publicpro
				    $FirewallObject
			    }

    Invoke-Command -computerName $HOSTNAME -command $FirewallBlock | Select-Object  @{N="Hostname";E={$hostname}},FirewallDomain, FirewallPrivate, FirewallPublic

    }
    Catch
		    {
           Write-Host  ($_.Exception.Message -split ' For')[0] -ForegroundColor Red
            }
}
End{}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-SubNetItems.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-SubNetItems.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Get-SubNetItems.ps1
'https://gallery.technet.microsoft.com/scriptcenter/SubNet-Scan-dad0311f

I ended up putting this in the MyFunctions Module


'This file Get-SubNetItems.ps1 contains only definition of Get-SubNetItems function. To use this tool try this:
'1) Load file with cmdlet definition. Don't forget first . It is important to load the cmdlets in the current namespace.
'PS&gt;. P:\Get-SubNetIte​ms.ps1

'2) And next try use function.

'Basic
PS&gt;Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.10
'Formated
Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.10 | Format-Table -Property Host, IP, OS_Name, OS_Ver, WMI  -AutoSize
'To File
Get-SubNetItems -StartScanIP 10.0.0.1 -EndScanIP 10.0.0.254 | Format-Table -Property Host, IP, OS_Name, OS_Ver, WMI  -AutoSize | Out-File C:\ListOfComputers.txt
===================================================================================
Function Get-SubNetItems
{
&lt;# 
	.SYNOPSIS 
		Scan subnet machines
		
	.DESCRIPTION 
		Use Get-SubNetItems to receive list of machines in specific IP range.

	.PARAMETER StartScanIP 
		Specify start of IP range.

	.PARAMETER EndScanIP
		Specify end of IP range.

	.PARAMETER Ports
		Specify ports numbers to scan if open or not.
		
	.PARAMETER MaxJobs
		Specify number of threads to scan.
		
	.PARAMETER ShowAll
		Show even adress is inactive.
	
	.PARAMETER ShowInstantly 
		Show active status of scaned IP address instanly. 
	
	.PARAMETER SleepTime  
		Wait time to check if threads are completed.
 
	.PARAMETER TimeOut 
		Time out when script will be break.

	.EXAMPLE 
		PS C:\&gt;$Result = Get-SubNetItems -StartScanIP 10.10.10.1 -EndScanIP 10.10.10.10 -ShowInstantly -ShowAll
		10.10.10.7 is active.
		10.10.10.10 is active.
		10.10.10.9 is active.
		10.10.10.1 is inactive.
		10.10.10.6 is active.
		10.10.10.4 is active.
		10.10.10.3 is inactive.
		10.10.10.2 is active.
		10.10.10.5 is active.
		10.10.10.8 is inactive.

		PS C:\&gt; $Result | Format-Table IP, Active, WMI, WinRM, Host, OS_Name -AutoSize

		IP           Active   WMI WinRM Host              OS_Name
		--           ------   --- ----- ----              -------
		10.10.10.1    False False False
		10.10.10.2     True  True  True pc02.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.3    False False False
		10.10.10.4     True  True  True pc05.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.5     True  True  True pc06.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.6     True  True  True pc07.mydomain.com Microsoft(R) Windows(R) Server 2003, Standard Edition
		10.10.10.7     True False False
		10.10.10.8    False False False
		10.10.10.9     True  True False pc09.mydomain.com Microsoft Windows Server 2008 R2 Enterprise
		10.10.10.10    True  True False pc10.mydomain.com Microsoft Windows XP Professional

	.EXAMPLE 
		PS C:\&gt; Get-SubNetItems -StartScanIP 10.10.10.2 -Verbose
		VERBOSE: Creating own list class.
		VERBOSE: Start scaning...
		VERBOSE: Starting job (1/20) for 10.10.10.2.
		VERBOSE: Trying get part of data.
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (0)
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (5)
		VERBOSE: Trying get last part of data.
		VERBOSE: All jobs is not completed (1/20), please wait... (10)
		VERBOSE: Trying get last part of data.
		VERBOSE: Geting job 10.10.10.2 result.
		VERBOSE: Removing job 10.10.10.2.
		VERBOSE: Scan finished.


		RunspaceId : d2882105-df8c-4c0a-b92c-0d078bcde752
		Active     : True
		Host       : pc02.mydomain.com
		IP         : 10.10.10.2
		OS_Name    : Microsoft Windows Server 2008 R2 Enterprise
		OS_Ver     : 6.1.7601 Service Pack 1
		WMI        : True
		WinRM      : True
		
	.EXAMPLE 	
		PS C:\&gt; $Result = Get-SubNetItems -StartScanIP 10.10.10.1 -EndScanIP 10.10.10.25 -Ports 80,3389,5900	

		PS C:\&gt; $Result | Select-Object IP, Host, MAC, @{l="Ports";e={[string]::join(", ",($_.Ports | Select-Object @{Label="Ports";Expression={"$($_.Port)-$($_.Status)"}} | Select-Object -ExpandProperty Ports))}} | Format-Table * -AutoSize
		
		IP          Host              MAC               Ports
		--          ----              ---               -----
		10.10.10.1                                      80-False, 3389-False, 5900-False
		10.10.10.2  pc02.mydomain.com 00-15-AD-0C-82-20 80-True, 3389-False, 5900-False
		10.10.10.5  pc05.mydomain.com 00-15-5D-1C-80-25 80-True, 3389-False, 5900-False
		10.10.10.7  pc07.mydomain.com 00-15-4D-0C-81-04 80-True, 3389-True, 5900-False
		10.10.10.9  pc09.mydomain.com 00-15-4A-0C-80-31 80-True, 3389-True, 5900-False
		10.10.10.10 pc10.mydomain.com 00-15-5D-02-1F-1C 80-False, 3389-True, 5900-False

	.NOTES 
		Author: Michal Gajda
		
		ChangeLog:
		v1.3
		-Scan items in subnet for MAC
		-Basic port scan on items in subnet
		-Fixed some small spelling bug
		
		v1.2
		-IP Range Ganerator upgrade
		
		v1.1
		-ProgressBar upgrade
		
		v1.0:
		-Scan subnet for items
		-Scan items in subnet for WMI Access
		-Scan items in subnet for WinRM Access
#&gt;

	[CmdletBinding(
		SupportsShouldProcess=$True,
		ConfirmImpact="Low" 
	)]	
	param(
		[parameter(Mandatory=$true)]
		[System.Net.IPAddress]$StartScanIP,
		[System.Net.IPAddress]$EndScanIP,
		[Int]$MaxJobs = 20,
		[Int[]]$Ports,
		[Switch]$ShowAll,
		[Switch]$ShowInstantly,
		[Int]$SleepTime = 5,
		[Int]$TimeOut = 90
	)

	Begin{}

	Process
	{
		if ($pscmdlet.ShouldProcess("$StartScanIP $EndScanIP" ,"Scan IP range for active machines"))
		{
			if(Get-Job -name *.*.*.*)
			{
				Write-Verbose "Removing old jobs."
				Get-Job -name *.*.*.* | Remove-Job -Force
			}
			
			$ScanIPRange = @()
			if($EndScanIP -ne $null)
			{
				Write-Verbose "Generating IP range list."
				# Many thanks to Dr. Tobias Weltner, MVP PowerShell and Grant Ward for IP range generator
				$StartIP = $StartScanIP -split '\.'
	  			[Array]::Reverse($StartIP)  
	  			$StartIP = ([System.Net.IPAddress]($StartIP -join '.')).Address 
				
				$EndIP = $EndScanIP -split '\.'
	  			[Array]::Reverse($EndIP)  
	  			$EndIP = ([System.Net.IPAddress]($EndIP -join '.')).Address 
				
				For ($x=$StartIP; $x -le $EndIP; $x++) {    
					$IP = [System.Net.IPAddress]$x -split '\.'
					[Array]::Reverse($IP)   
					$ScanIPRange += $IP -join '.' 
				}
			
			}
			else
			{
				$ScanIPRange = $StartScanIP
			}

			Write-Verbose "Creating own list class."
			$Class = @"
			public class SubNetItem {
				public bool Active;
				public string Host;
				public System.Net.IPAddress IP;
				public string MAC;
				public System.Object Ports;
				public string OS_Name;
				public string OS_Ver;
				public bool WMI;
				public bool WinRM;
			}
"@		

			Write-Verbose "Start scaning..."	
			$ScanResult = @()
			$ScanCount = 0
			Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete (0)
			Foreach($IP in $ScanIPRange)
			{
	 			Write-Verbose "Starting job ($((Get-Job -name *.*.*.* | Measure-Object).Count+1)/$MaxJobs) for $IP."
				Start-Job -Name $IP -ArgumentList $IP,$Ports,$Class -ScriptBlock{ 
				
					param
					(
					[System.Net.IPAddress]$IP = $IP,
					[Int[]]$Ports = $Ports,
					$Class = $Class 
					)
					
					Add-Type -TypeDefinition $Class
					
					if(Test-Connection -ComputerName $IP -Quiet)
					{
						#Get Hostname
						Try
						{
							$HostName = [System.Net.Dns]::GetHostbyAddress($IP).HostName
						}
						Catch
						{
							$HostName = $null
						}
						
						#Get WMI Access, OS Name and version via WMI
						Try
						{
							#I don't use Get-WMIObject because it havent TimeOut options. 
							$WMIObj = [WMISearcher]''  
							$WMIObj.options.timeout = '0:0:10' 
							$WMIObj.scope.path = "\\$IP\root\cimv2"  
							$WMIObj.query = "SELECT * FROM Win32_OperatingSystem"  
							$Result = $WMIObj.get()  

							if($Result -ne $null)
							{
								$OS_Name = $Result | Select-Object -ExpandProperty Caption
								$OS_Ver = $Result | Select-Object -ExpandProperty Version
								$OS_CSDVer = $Result | Select-Object -ExpandProperty CSDVersion
								$OS_Ver += " $OS_CSDVer"
								$WMIAccess = $true					
							}
							else
							{
								$WMIAccess = $false	
							}
						}	
						catch
						{
							$WMIAccess = $false					
						}
						
						#Get WinRM Access, OS Name and version via WinRM
						if($HostName)
						{
							$Result = Invoke-Command -ComputerName $HostName -ScriptBlock {systeminfo} -ErrorAction SilentlyContinue 
						}
						else
						{
							$Result = Invoke-Command -ComputerName $IP -ScriptBlock {systeminfo} -ErrorAction SilentlyContinue 
						}
						
						if($Result -ne $null)
						{
							if($OS_Name -eq $null)
							{
								$OS_Name = ($Result[2..3] -split ":\s+")[1]
								$OS_Ver = ($Result[2..3] -split ":\s+")[3]
							}	
							$WinRMAccess = $true
						}
						else
						{
							$WinRMAccess = $false
						}
						
						#Get MAC Address
						Try
						{
							$result= nbtstat -A $IP | select-string "MAC"
							$MAC = [string]([Regex]::Matches($result, "([0-9A-F][0-9A-F]-){5}([0-9A-F][0-9A-F])"))
						}
						Catch
						{
							$MAC = $null
						}
						
						#Get ports status
						$PortsStatus = @()
						ForEach($Port in $Ports)
						{
							Try
							{							
								$TCPClient = new-object Net.Sockets.TcpClient
								$TCPClient.Connect($IP, $Port)
								$TCPClient.Close()
								
								$PortStatus = New-Object PSObject -Property @{            
		        					Port		= $Port
									Status      = $true
								}
								$PortsStatus += $PortStatus
							}	
							Catch
							{
								$PortStatus = New-Object PSObject -Property @{            
		        					Port		= $Port
									Status      = $false
								}	
								$PortsStatus += $PortStatus
							}
						}

						
						$HostObj = New-Object SubNetItem -Property @{            
		        					Active		= $true
									Host        = $HostName
									IP          = $IP 
									MAC         = $MAC
									Ports       = $PortsStatus
		        					OS_Name     = $OS_Name
									OS_Ver      = $OS_Ver               
		        					WMI         = $WMIAccess      
		        					WinRM       = $WinRMAccess      
		        		}
						$HostObj
					}
					else
					{
						$HostObj = New-Object SubNetItem -Property @{            
		        					Active		= $false
									Host        = $null
									IP          = $IP  
									MAC         = $null
									Ports       = $null
		        					OS_Name     = $null
									OS_Ver      = $null               
		        					WMI         = $null      
		        					WinRM       = $null      
		        		}
						$HostObj
					}
				} | Out-Null
				$ScanCount++
				Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
				
				do
				{
					Write-Verbose "Trying get part of data."
					Get-Job -State Completed | Foreach {
						Write-Verbose "Geting job $($_.Name) result."
						$JobResult = Receive-Job -Id ($_.Id)

						if($ShowAll)
						{
							if($ShowInstantly)
							{
								if($JobResult.Active -eq $true)
								{
									Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
								}
								else
								{
									Write-Host "$($JobResult.IP) is inactive." -ForegroundColor Red
								}
							}
							
							$ScanResult += $JobResult	
						}
						else
						{
							if($JobResult.Active -eq $true)
							{
								if($ShowInstantly)
								{
									Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
								}
								$ScanResult += $JobResult
							}
						}
						Write-Verbose "Removing job $($_.Name)."
						Remove-Job -Id ($_.Id)
						Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
					}
					
					if((Get-Job -name *.*.*.*).Count -eq $MaxJobs)
					{
						Write-Verbose "Jobs are not completed ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs), please wait..."
						Sleep $SleepTime
					}
				}
				while((Get-Job -name *.*.*.*).Count -eq $MaxJobs)
			}
			
			$timeOutCounter = 0
			do
			{
				Write-Verbose "Trying get last part of data."
				Get-Job -State Completed | Foreach {
					Write-Verbose "Geting job $($_.Name) result."
					$JobResult = Receive-Job -Id ($_.Id)

					if($ShowAll)
					{
						if($ShowInstantly)
						{
							if($JobResult.Active -eq $true)
							{
								Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
							}
							else
							{
								Write-Host "$($JobResult.IP) is inactive." -ForegroundColor Red
							}
						}
						
						$ScanResult += $JobResult	
					}
					else
					{
						if($JobResult.Active -eq $true)
						{
							if($ShowInstantly)
							{
								Write-Host "$($JobResult.IP) is active." -ForegroundColor Green
							}
							$ScanResult += $JobResult
						}
					}
					Write-Verbose "Removing job $($_.Name)."
					Remove-Job -Id ($_.Id)
					Write-Progress -Activity "Scan IP Range $StartScanIP $EndScanIP" -Status "Scaning:" -Percentcomplete ([int](($ScanCount+$ScanResult.Count)/(($ScanIPRange | Measure-Object).Count) * 50))
				}
				
				if(Get-Job -name *.*.*.*)
				{
					Write-Verbose "All jobs are not completed ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs), please wait... ($timeOutCounter)"
					Sleep $SleepTime
					$timeOutCounter += $SleepTime				

					if($timeOutCounter -ge $TimeOut)
					{
						Write-Verbose "Time out... $TimeOut. Can't finish some jobs  ($((Get-Job -name *.*.*.* | Measure-Object).Count)/$MaxJobs) try remove it manualy."
						Break
					}
				}
			}
			while(Get-Job -name *.*.*.*)
			
			Write-Verbose "Scan finished."
			Return $ScanResult | Sort-Object {"{0:d3}.{1:d3}.{2:d3}.{3:d3}" -f @([int[]]([string]$_.IP).split('.'))}
		}
	}
	
	End{}
}
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>SAMPLE_Profile_1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>SAMPLE_Profile_1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'http://www.zerrouki.com/powershell-profile-example/


&lt;#
.SYNOPSIS
    Microsoft.PowerShell_profile.ps1 - My PowerShell profile
.DESCRIPTION
    Microsoft.PowerShell_profile - Customizes the PowerShell console
.NOTES
    File Name   : Microsoft.PowerShell_profile.ps1
    Author      : Fabrice ZERROUKI - fabricezerrouki@hotmail.com
#&gt;
Set-Location D:\Documents\xxxxxx\PERSONNEL\powerscripts
$Shell=$Host.UI.RawUI
$size=$Shell.BufferSize
$size.width=120
$size.height=3000
$Shell.BufferSize=$size
$size=$Shell.WindowSize
$size.width=120
$size.height=30
$Shell.WindowSize=$size
 
$Shell.BackgroundColor="Black"
$Shell.ForegroundColor="White"
$Shell.CursorSize=10
 
function Get-Time {return $(Get-Date | ForEach {$_.ToLongTimeString()})}
function prompt
{
    Write-Host "[" -noNewLine
    Write-Host $(Get-Time) -ForegroundColor DarkYellow -noNewLine
    Write-Host "] " -noNewLine
    Write-Host $($(Get-Location).Path.replace($home,"~")) -ForegroundColor DarkGreen -noNewLine
    Write-Host $(if ($nestedpromptlevel -ge 1) { '&gt;&gt;' }) -noNewLine
    return "&gt; "
}
 
function ll
{
    param ($dir = ".", $all = $false)
 
    $origFg = $Host.UI.RawUI.ForegroundColor
    if ( $all ) { $toList = ls -force $dir }
    else { $toList = ls $dir }
 
    foreach ($Item in $toList)
    {
        Switch ($Item.Extension)
        {
            ".exe" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".hta" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".cmd" {$Host.UI.RawUI.ForegroundColor="DarkRed"}
            ".ps1" {$Host.UI.RawUI.ForegroundColor="DarkGreen"}
            ".html" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".htm" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".7z" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".zip" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".gz" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".rar" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            Default {$Host.UI.RawUI.ForegroundColor=$origFg}
        }
        if ($item.Mode.StartsWith("d")) {$Host.UI.RawUI.ForegroundColor="Gray"}
        $item
    }
    $Host.UI.RawUI.ForegroundColor = $origFg
}
 
function Edit-HostsFile {
    Start-Process -FilePath notepad -ArgumentList "$env:windir\system32\drivers\etc\hosts"
}
 
function rdp ($ip) {
    Start-Process -FilePath mstsc -ArgumentList "/admin /w:1024 /h:768 /v:$ip"
}
 
function tail ($file) {
Get-Content $file -Wait
}
 
function whoami {
    [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
}
 
function Reload-Profile {
    @(
        $Profile.AllUsersAllHosts,
        $Profile.AllUsersCurrentHost,
        $Profile.CurrentUserAllHosts,
        $Profile.CurrentUserCurrentHost
    ) | % {
        if(Test-Path $_) {
            Write-Verbose "Running $_"
            . $_
        }
    }    
}
 
function Check-SessionArch {
    if ([System.IntPtr]::Size -eq 8) { return "x64" }
    else { return "x86" }
}
 
function Test-Port {
[cmdletbinding()]
param(
[parameter(mandatory=$true)]
[string]$Target,
[parameter(mandatory=$true)]
[int32]$Port,
[int32]$Timeout=2000
)
$outputobj=New-Object -TypeName PSobject
$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostName -Value $Target
if(Test-Connection -ComputerName $Target -Count 2) {$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "ONLINE"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "OFFLINE"}            
$outputobj | Add-Member -MemberType NoteProperty -Name PortNumber -Value $Port
$Socket=New-Object System.Net.Sockets.TCPClient
$Connection=$Socket.BeginConnect($Target,$Port,$null,$null)
$Connection.AsyncWaitHandle.WaitOne($timeout,$false) | Out-Null
if($Socket.Connected -eq $true) {$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Success"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Failed"}            
$Socket.Close | Out-Null
$outputobj | Select TargetHostName, TargetHostStatus, PortNumber, Connectionstatus | Format-Table -AutoSize
}
 
Set-Alias powergui "C:\Program Files\PowerGUI\ScriptEditor.exe"
Set-Alias grep select-string
 
$MaximumHistoryCount=1024
$IPAddress=@(Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.DefaultIpGateway})[0].IPAddress[0]
$PSVersion=$host | Select-Object -ExpandProperty Version
$PSVersion=$PSVersion -replace '^.+@\s'
$SessionArch=Check-SessionArch
$Shell.WindowTitle="PowerFab rulez! ($SessionArch)"
 
Clear-Host
 
Write-Host "`r`nsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  ssssss`tHi Fab!" -nonewline; Write-Host "`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tComputerName`t`t" -nonewline
Write-Host $($env:COMPUTERNAME) -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tIP Address`t`t" -nonewline
Write-Host $IPAddress -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss`tUserName`t`t" -nonewline
Write-Host $env:UserDomain\$env:UserName -nonewline; Write-Host "`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Version`t" -nonewline
Write-Host $PSVersion -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Session`t" -nonewline
Write-Host $SessionArch -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss`n" -ForegroundColor Yellow
 
$LogicalDisk = @()
Get-WmiObject Win32_LogicalDisk -filter "DriveType='3'" | % {
    $LogicalDisk += @($_ | Select @{n="Name";e={$_.Caption}},
    @{n="Volume Label";e={$_.VolumeName}},
    @{n="Size (Gb)";e={"{0:N2}" -f ($_.Size/1GB)}},
    @{n="Used (Gb)";e={"{0:N2}" -f (($_.Size/1GB) - ($_.FreeSpace/1GB))}},
    @{n="Free (Gb)";e={"{0:N2}" -f ($_.FreeSpace/1GB)}},
    @{n="Free (%)";e={if($_.Size) {"{0:N2}" -f (($_.FreeSpace/1GB) / ($_.Size/1GB) * 100 )} else {"NAN"} }})
  }
$LogicalDisk | Format-Table -AutoSize | Out-String</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Select</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Select</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Select</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Select</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Select

#' Context parm:
&gt;get-content $pshome\DotNetTypes.format.ps1xml | Select-String system.serviceprocess.servicecontroller -Context 0,30 | more
#' Context means show 0 lines before you find the word "system.serviceprocess.servicecontroller"
#' 	and show 30 lines after you find the word</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting__Invoke-Command</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Invoke-Command_inside_a_function__THEN_use_it</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting__Invoke-Command</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Invoke-Command_inside_a_function__THEN_use_it</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>This example has a bunch of commands to be run on a remote machine, inside a function whose PARM is the computername
The results are returned to the screen of the local Machine 

============================================================
http://power-shell.com/2015/powershell-scripts/get-curent-firewall-status-utilizing-netsh/

#' USAGE:
&gt;Get-FirewallState -HOSTNAME SERVER01

#' The function:

Function Get-FirewallState
{
	[CmdletBinding()]
	
	Param ([Parameter(Mandatory = $true)][string]$HOSTNAME)
$ErrorActionPreference = "Stop"
Try {
$FirewallBlock = {
				$content = netsh advfirewall show allprofiles
				If ($domprofile = $content | Select-String 'Domain Profile' -Context 2 | Out-String)
				{ $domainpro = ($domprofile.Substring($domprofile.Length - 9)).Trim()}
				Else { $domainpro = $null }
				If ($priprofile = $content | Select-String 'Private Profile' -Context 2 | Out-String)
				{ $privatepro = ($priprofile.Substring($priprofile.Length - 9)).Trim()}
				Else { $privatepro = $null }
				If ($pubprofile = $content | Select-String 'Public Profile' -Context 2 | Out-String)
				{ $publicpro = ($pubprofile.Substring($pubprofile.Length - 9)).Trim()}
				Else { $publicpro = $null }
				
				$FirewallObject = New-Object PSObject
				Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallDomain" -value $domainpro
				Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPrivate" -value $privatepro
				Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPublic" -value $publicpro
				$FirewallObject
			}
 
Invoke-Command -computerName $HOSTNAME -command $FirewallBlock | Select-Object FirewallDomain, FirewallPrivate, FirewallPublic
 
}
Catch
		{
       Write-Host  ($_.Exception.Message -split ' For')[0] -ForegroundColor Red
        }
}
============================================================ another example
#'Invoke Remove-UserProfile on a Remote Computer 
$scriptBlock = { 
    function Remove-UserProfile 
    { 
        ... 
    } 
 
    Remove-UserProfile 
} 
 
Invoke-Command -ComputerName "GWS-F20" -ScriptBlock $scriptBlock 
============================================================ Multiple computers 
#'Invoke Remove-UserProfile on Many Remote Computers, Passing in Arguments 
#'This Example Utilizes Windows Workflow Foundation Technology, Available in PowerShell V3 and Above 
$scriptBlock = { 
    function Remove-UserProfile 
    { 
        ... 
    } 
 
    Remove-UserProfile -Exclude $args 
} 
 
$compArray = @() 
Get-Content -Path "\\path\to\computers.txt" | ForEach-Object { $compArray += $_ } 
 
$excludedList = @("labadmin", "desktopuser") 
 
Invoke-Command -ComputerName $compArray -ScriptBlock $scriptBlock -ArgumentList $excludedList -ThrottleLimit 50

==================================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>