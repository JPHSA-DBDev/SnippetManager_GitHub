<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>eMail</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_for_BCC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>eMail</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_for_BCC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#email_LIST_of_REMOTE_logins_for_all_SERVERS_on_our_Network.psf


# Import the Active Directory module for the Get-ADComputer CmdLet 
Import-Module ActiveDirectory 
 
# Get today's date for the report 
$today = Get-Date 
 
# Setup email parameters 
$subject = "ACTIVE SERVER SESSIONS REPORT - " + $today 
$priority = "Normal" 
$smtpServer = "Barriere-com.mail.protection.outlook.com" 
$emailFrom = "DoNotReply@barriere.com" 
$emailTo = "glenng@barriere.com" 
 
# Create a fresh variable to collect the results. You can use this to output as desired 
$SessionList = "ACTIVE SERVER SESSIONS REPORT - " + $today + "`n`n" 
 
# Query Active Directory for computers running a Server operating system 
$Servers = Get-ADComputer -Filter {OperatingSystem -like "*server*"} 
 
# Loop through the list to query each server for login sessions 
ForEach ($Server in $Servers) { 
    $ServerName = $Server.Name 
 
    # When running interactively, uncomment the Write-Host line below to show which server is being queried 
    # Write-Host "Querying $ServerName" 
 
    # Run the qwinsta.exe and parse the output 
    $queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "\s+",","))} | ConvertFrom-Csv)  
     
    # Pull the session information from each instance 
    ForEach ($queryResult in $queryResults) { 
        $RDPUser = $queryResult.USERNAME 
        $sessionType = $queryResult.SESSIONNAME 
         
        # We only want to display where a "person" is logged in. Otherwise unused sessions show up as USERNAME as a number 
        If (($RDPUser -match "[a-z]") -and ($RDPUser -ne $NULL)) {  
            # When running interactively, uncomment the Write-Host line below to show the output to screen 
            # Write-Host $ServerName logged in by $RDPUser on $sessionType 
            $SessionList = $SessionList + "`n`n" + $ServerName + " logged in by " + $RDPUser + " on " + $sessionType 
        } 
    } 
} 
 
# Send the report email 
# Send-MailMessage -To $emailTo -Subject $subject -Body $SessionList -SmtpServer $smtpServer -From $emailFrom -Priority $priority 
 
# When running interactively, uncomment the Write-Host line below to see the full list on screen 
$SessionList </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>eMail</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Send-MailMessage</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>eMail</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Send-MailMessage</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Send-MailMessage -To $emailTo -Subject $subject -Body $SessionList -SmtpServer $smtpServer -From $emailFrom -Priority $priority

-------------------------------------------
Send email to one recipient
============================
Send-MailMessage -To "Manager 1 &lt;Manager1@xyz.com&gt;" -From "Reports Admin &lt;Reportadmin@xyx.com&gt;" -SMTPServer smtp1.xyz.com -Subject "Daily report" -Body "This is a daily report of server uptime"

Send email to multiple recipients in To and CC
==============================================
Send-MailMessage -To "Manager 1 &lt;Manager1@xyz.com&gt;", "Manager2 &lt;Manager2@xyz.com&gt;" -CC "Manager 3 &lt;Manager3@xyz.com&gt;", "Manager4 &lt;Manager4@xyz.com&gt;" -From "Reports Admin &lt;Reportadmin@xyx.com&gt;" -SMTPServer smtp1.xyz.com -Subject "Daily report sent to multiple managers" -Body "This is a daily report of servers uptime"


Send email to one recipient with an attachment
==============================================
Send-MailMessage -To "Manager 1 &lt;Manager1@xyz.com&gt;" -From "Reports Admin &lt;Reportadmin@xyx.com&gt;" -SMTPServer smtp1.xyz.com -Subject "Daily report" -Body "Attached file has uptime details of all servers" -Attachments "c:\temp\uptime-report.txt"

Send email to one recipient with multiple attachments
======================================================
Send-MailMessage -To "Manager 1 &lt;Manager1@xyz.com&gt;" -From "Reports Admin &lt;Reportadmin@xyx.com&gt;" -SMTPServer smtp1.xyz.com -Subject "Daily report" -Body "Attached file has uptime details of all servers" -Attachments "c:\temp\server1-uptime-report.txt", "c:\temp\server2-uptime-report.txt"


Send email via an SMTP relay server that requires authentication
==================================================================
Send-MailMessage -To "Manager 1 &lt;Manager1@xyz.com&gt;" -From "Reports Admin &lt;Reportadmin@xyx.com&gt;" -SMTPServer smtp1.xyz.com -Credentials (Get-Credential) -Subject "Daily report" -Body "This is a daily report of servers uptime"

Send status of all services in a server as an email
=====================================================
Send-MailMessage -To "Manager 1 &lt;Manager1@xyz.com&gt;" -From "Reports Admin &lt;Reportadmin@xyx.com&gt;" -SMTPServer smtp1.xyz.com -Subject "Services status of Server1" -Body (Get-Service -ComputerName Server1 | Out-String)

Send high-priority email
=========================
Send-MailMessage -To "Manager 1 &lt;Manager1@xyz.com&gt;" -From "Reports Admin &lt;Reportadmin@xyx.com&gt;" -SMTPServer smtp1.xyz.com -Subject "Daily report" -Body "This is a daily report of servers uptime" -Priority High




---------------------------------------------
-FROM: 
	Every email needs a “from” address. 
	Without this, email cannot be sent. 
	Though it is a required parameter, the email ID doesn’t necessarily have to be a valid one. 
	You can use nothing@nothing.com and the cmdlet will still work.

-TO: 
	This is also a mandatory parameter. 
	You can supply a single or multiple email addresses, 
	and you can also specify the name associated with the email address 
	(for example, -To “Sitaram Pamarthi &lt;sitaram @4sysops.com&gt;”).

-SMTPServer: 
	You need to provide the name of the SMTP server through which you want to send the email. 
	If you are in doubt, ask your email administrator for the server to use. 
	If this parameter is not specified, 
	PowerShell tries to pick the value from the $PSEmailServer preference variable, 
	if this variable is set.


-CC and -BCC: 
	You know what they are. 
	If you would like to CC or BCC somebody in the email, 
	pass their email addresses to these parameters.

-Attachments: 
	This parameter takes the full path of the file(s) that you want to attach to the email.

-Subject: This is a simple string that represents the subject of your email.

-Body: This string specifies the body of your email message.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Map_Drives</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>from_BCC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Map_Drives</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>from_BCC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'********************************************************************************
'This login scripts will do the following items for non-People Trak Users
'	Map all user drives based on group user belongs to
'	write a record to a database to track PC make and Models
'	Write a record to a database to track user logon times
'	Set the local time on the user PC to match the server
'********************************************************************************

strComputer="."
on error resume next


'****************
'   Variables
'****************

Dim WSHNetwork
Dim wshShell
Dim wshSysEnv
Dim nReturnCode
Dim FSO
Dim strUsername
Dim strUseName
Dim strUserDomain
Dim objGroupDict

'*********************************************************
'	DRIVE MAPPING SECTION OF SCRIPT
'*********************************************************

Set WSHNetwork = WScript.CreateObject("WScript.Network")
Set FSO = CreateObject("Scripting.FileSystemObject")

'**** Wait Until User is Logged In ****

strUserName = ""
While strUserName = ""
WScript.Sleep 1000 ' 1 second
strUserName = WSHNetwork.UserName
Wend
strUserDomain = WSHNetwork.UserDomain

'**** Insert the user's account "Member Of" tab info ****


Set ObjGroupDict = CreateMemberOfObject(strUserDomain, strUserName)

'****Remove drive letters first****

	WshNetwork.RemoveNetworkDrive "G:", True, false
	WshNetwork.RemoveNetworkDrive "H:", True, false
	WshNetwork.RemoveNetworkDrive "J:", True, false
	WshNetwork.RemoveNetworkDrive "K:", True, false
	WshNetwork.RemoveNetworkDrive "Q:", True, false
	WshNetwork.RemoveNetworkDrive "S:", True, false
	WshNetwork.RemoveNetworkDrive "T:", True, false
	WshNetwork.RemoveNetworkDrive "U:", True, false
	WshNetwork.RemoveNetworkDrive "V:", True, false
	WshNetwork.RemoveNetworkDrive "W:", True, false
	WshNetwork.RemoveNetworkDrive "X:", True, false
	WshNetwork.RemoveNetworkDrive "Y:", True, false
	WshNetwork.RemoveNetworkDrive "Z:", True, false

'****Map Drive based on Group Membership****

'*********** Boutte **********

If MemberOf(ObjGroupDict, "BoutteLA") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "BoutteLA") Then
WSHNetwork.MapNetworkDrive "t:", "\\bcc-bouttedcfs\Boutteshare"
End If

If MemberOf(ObjGroupDict, "BoutteLA") Then
WSHNetwork.MapNetworkDrive "u:", "\\bcc-bouttedcfs\Users\" &amp; WSHNetwork.UserName
End If

'*********** Concrete Paving **********

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** Executive **********

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "j:", "\\bcc-explorer2\XPLRF"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "k:", "\\bcc-explorer2\XPLR"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** HR **********

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "H:", "\\bcc-explorer2\xplrf\barriere\images"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "J:", "\\bcc-explorer2\xplr"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "K:", "\\bcc-explorer2\XPLRF"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If


'*********** Gravel Pit **********

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If


'*********** Interns**********

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "y:", "\\bcc-bouttedcfs\BoutteShare"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "z:", "\\bcc-nshore\1A_Northshore"
End If

'*********** New Orleans **********

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** North Shore **********

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "s:", "\\bcc-nshore\1A_Northshore"
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "u:", "\\bcc-nshore\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "z:", "\\ts-frank2\share\archive"
End If

'*********** South Shore **********

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** All Common **********

WSHNetwork.MapNetworkDrive "g:", "\\BCC-CONTROL\PeopleTrak"
WSHNetwork.MapNetworkDrive "q:", "\\bcc-hcss\HCSS"
WSHNetwork.MapNetworkDrive "w:", "\\BCC-FS1\Public"
WSHNetwork.MapNetworkDrive "x:", "\\bcc-explorer2\CLI"
'==========================================================CUSTOM MAPPINGS
WSHNetwork.MapNetworkDrive "y:", "\\bcc-explorer\d$"
WSHNetwork.MapNetworkDrive "z:", "\\bcc-explorer3\d$"

'==========================================================

'**** Group Membership Function Subroutines ****

Function MemberOf(ObjDict, strKey)

MemberOf = CBool(ObjGroupDict.Exists(strKey))

End Function


Function CreateMemberOfObject(strDomain, strUserName)

Dim objUser, objGroup

Set CreateMemberOfObject = CreateObject("Scripting.Dictionary")
CreateMemberOfObject.CompareMode = vbTextCompare
Set objUser = GetObject("WinNT://" _
&amp; strDomain &amp; "/" _
&amp; strUserName &amp; ",user")
For Each objGroup In objUser.Groups
CreateMemberOfObject.Add objGroup.Name, "-"
Next
Set objUser = Nothing

End Function

'*****************************************************
'	END OF DRIVE MAPPING SECTION
'*****************************************************


'*****************************************************
'	SECTION TO SET LOCAL COMPUTER TIME
'*****************************************************
strComputer="."
Set WshNetwork = WScript.CreateObject("WScript.Network")
Set wshShell = WScript.CreateObject("Wscript.Shell")
Set wshSysEnv = wshShell.Environment("SYSTEM")
If (wshSysEnv("OS") = "Windows_NT") Then
    nReturnCode = wshShell.Run("net time /domain:" &amp; wshNetwork.UserDomain &amp; " /set /yes", 0, TRUE)
    Else
	WScript.Echo "This Logon Script Supports only Windows 2000 or Windows XP" &amp; vbNewLine &amp; "Exiting..."
    Set wshNetwork = Nothing
    Set wshShell = Nothing
    WScript.Quit(1)
End If

'*****************************************************
result=Msgbox("Good To Go!",vbYesNo+vbInformation, "")
'*****************************************************


Set wshNetwork = Nothing
Set wshShell = Nothing
WScript.Quit(nReturnCode)

'*****************************************************
'	END OF SETTING LOCAL TIME
'*****************************************************













</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Modify_Computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Modify_Computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' Uses $Attributes Hashtable for the various properties that you want to 

#' Uses $Attributes Hashtable for the various properties that you want to 

param ([string]$Computername, [hashtable]$Attributes)

## Attempt to find the Computername
try {
        $Computer = Get-AdComputer -Identity $Computername
        if (!$Computer) {
	                        ## If the Computername isn't found throw an error and exit
	                        Write-Error "The Computername '$Computername' does not exist"
	                        return
                        }
    } 
catch {

}

## The $Attributes parameter will contain only the parameters for the Set-AdComputer cmdlet
$Computer | Set-AdComputer @Attributes


#' USAGE:
#'============================================================================================

&gt; .\Set-MyAdComputer.ps1 -Computername BCC1044 -Attributes @{'DisplayName' = 'my displayName';'Description' = 'my description'}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Modify_User</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Modify_User</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' Uses $Attributes Hashtable for the various properties that you want to 

param ([string]$Username, [hashtable]$Attributes)

    try {
            ## Attempt to find the username
            $UserAccount = Get-AdUser -Identity $Username
            if (!$UserAccount) {
	                                ## If the username isn't found throw an error and exit
	                                Write-Error "The username '$Username' does not exist"
	                                return
                                }
        } 
  catch {

        }

## The $Attributes parameter will contain only the parameters for the Set-AdUser cmdlet other than
## Password.  If the password is in $Attributes it needs to be treated differently, i.e. need to use:Set-ADAccountPassword, then delete it from $Attributes .
if ($Attributes.ContainsKey('Password')) {
	                                            $UserAccount | Set-ADAccountPassword -Reset -NewPassword (ConvertTo-SecureString -AsPlainText $Attributes.Password -Force)
	                                            ## Remove the password key because we'll be passing this hashtable directly to Set-AdUser later
	                                            $Attributes.Remove('Password')
                                          }

$UserAccount | Set-AdUser @Attributes


#' USAGE ======================================================================================================
#' the parameter names (i.e. Hash Table Keys) must be spelled just like the Parameters of the method be called
#' e.g. 'givenName' and 'surname' keys in the Hashtable are the same as the PARMs of Set-AdUser  

&gt; .\Set-MyAdUser.ps1 -Username rsmith -Attributes @{givenName = "Trudy"; surname = 'smithley'}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_and_DotNet</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_Object_from_external_DotNet_file____PowerShell.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_and_DotNet</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_Object_from_external_DotNet_file____PowerShell.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'01_Object_from_external_DotNet_file____PowerShell.ps1



#'-----------------------------------------------------------------------------#'
#' Demo 9 - Create object from .Net Code in an external file
#'-----------------------------------------------------------------------------#'

#' Set the folder where the CS file is
$assyPath = "C:\JUNK\"

#' Path and File Name
$file = "$($assyPath)ExternalCSharpClass.cs"

#' Load the contents of the file into Memory (each line into seperate element of an Array)
#' So an Array of strings, 'Out-String' combines all the elements into a string variable
$code = Get-Content $file | Out-String



#' Add a new type definition based on the code
Add-Type -TypeDefinition $code `
         -Language CSharpVersion3     #' &lt;==== C# version 3 PowerShell

#' Call the static method of the object
$mySchema = "dbo"
$myTable = "ArcaneCode"

 #' put the name of the class in square braces [xxx] followed by 2 colons, then the name of the method, and the Parms
$result = [BPSDObjectExternal]::composeFullName($mySchema, $myTable)
$result</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_and_DotNet</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_and_use_a_STATIC_C#_Method_and_Class</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_and_DotNet</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_and_use_a_STATIC_C#_Method_and_Class</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'-----------------------------------------------------------------------------#'
#' Demo 7 - Create a class from .Net Code and call a static method
#'-----------------------------------------------------------------------------#'

#' Load the class definition into a variable
$code = @"
using System;

public class BPSDObjectStatic
{
  public static string composeFullName(string pSchema, string pTable)
  {
    string retVal = "";  

    retVal = pSchema + "." + pTable;

    return retVal;

  } // public static string composeFullName
} // class BPSDObjectStatic

"@

#' Add a new type definition based on the code 'Add-Type' tells powershell that $code is a definition from which you can create objects
Add-Type -TypeDefinition $code `
         -Language CSharpVersion3     #'&lt;===  This means we are using C# compatible with v3 PowerShell

#' Call the static method of the class
$mySchema = "dbo"
$myTable = "ArcaneCode"
$result = [BPSDObjectStatic]::composeFullName($mySchema, $myTable)        #'&lt;==== put the name of the class in square braces [xxx] followed by 2 colons, then the name of the method, and the Parms
$result</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_and_DotNet</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Instantiate_object_and_method_from_Code_embedded_in_PowerShell_script</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_and_DotNet</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Instantiate_object_and_method_from_Code_embedded_in_PowerShell_script</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#'
#' Demo 7 - Create a class from .Net Code and call a static method
#'-----------------------------------------------------------------------------#'

#' Load the class definition into a variable
$code = @"
using System;

public class BPSDObjectStatic
{
  public static string composeFullName(string pSchema, string pTable)
  {
    string retVal = "";  

    retVal = pSchema + "." + pTable;

    return retVal;

  } // public static string composeFullName
} // class BPSDObjectStatic

"@

#' Add a new type definition based on the code 'Add-Type' tells powershell that $code is a definition from which you can create objects
Add-Type -TypeDefinition $code `
         -Language CSharpVersion3     #'&lt;===  This means we are using C# compatible with v3 PowerShell

#' Call the static method of the class
$mySchema = "dbo"
$myTable = "ArcaneCode"
$result = [BPSDObjectStatic]::composeFullName($mySchema, $myTable)        #'&lt;==== put the name of the class in square braces [xxx] followed by 2 colons, then the name of the method, and the Parms
$result</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Applications_Add_Remove</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Applications_Add_Remove</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Applications_Add_Remove</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Applications_Add_Remove</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Applications_Add_Remove

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
WINDOWS 10

Messaging and Skype:
==================
Get-AppxPackage *messaging* | Remove-AppxPackage
Get-AppxPackage *skypeapp* | Remove-AppxPackage


Windows Defender: not done yet
=========================================================================================================
Set-MpPreference -DisableRealtimeMonitoring $true

{To renable}
Set-MpPreference -DisableRealtimeMonitoring $false

# Install Windows Defender GUI (no restart required)
=====================================================
Install-WindowsFeature Windows-Defender-GUI

# Uninstall Windows Defender and its GUI (restart required)
=======================================================
Remove-WindowsFeature Windows-Defender, Windows-Defender-GUI

# Disable Windows Defender&lt;============Powershell to create Registry key that turns it off
# Write-Host "Disabling Windows Defender..."
Set-ItemProperty -Path "HKLM:\Software\Policies\Microsoft\Windows Defender" -Name "DisableAntiSpyware" -Type DWord -Value 1
 
# Enable Windows Defender
# Remove-ItemProperty -Path "HKLM:\Software\Policies\Microsoft\Windows Defender" -Name "DisableAntiSpyware"
 
========================================================================================================= 











+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_browser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_Default_Browser_from_Remote_PC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_browser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_Default_Browser_from_Remote_PC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://theezitguy.wordpress.com/2014/02/09/powershell-get-default-browser-from-remote-pc/

'DefaultBrowser.ps1

Param([parameter(Mandatory=$true)][alias("Computer")]$ComputerName)
 
$Registry = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $ComputerName)
$RegistryKey = $Registry.OpenSubKey("SOFTWARE\\Classes\\http\\shell\\open\\command")
#Get (Default) Value
$Value = $RegistryKey.GetValue("")
 
$Value

'OUTPUT
'The above Script will return a String like:
'C:\Program Files\Internet Explorer\iexplore.exe" %1

'Here the above Script packaged as a function ready to use:
'Get-DefaultBrowserFunction.ps1

function Get-DefaultBrowser
{
Param([parameter(Mandatory=$true)][alias("Computer")]$ComputerName)
 
$Registry = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $ComputerName)
$RegistryKey = $Registry.OpenSubKey("SOFTWARE\\Classes\\http\\shell\\open\\command")
#Get (Default) Value
$Value = $RegistryKey.GetValue("")
 
return $Value
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_browser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>URL of each Favorite in alphabetical order =&gt; CSV file on Desktop</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_browser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>URL of each Favorite in alphabetical order =&gt; CSV file on Desktop</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'# URL of each Favorite in alphabetical order =&gt; CSV file on Desktop

# Gathers a list of the current users IE Favorites
Get-ChildItem $env:userprofile\favorites -Recurse -Include *.url |
 where {select-string -InputObject $_ -Quiet "^URL=http"} | 
 select @{Name="Name"; Expression={[IO.Path]::GetFileNameWithoutExtension($_.FullName)}},
 @{Name="URL"; Expression={get-content $_ | ? {$_ -match "^URL=http"} | % {$_.Substring(4)}}} |
#Sorts and exports them to a CSV on user's Desktop
 sort Name |Export-Csv -Path $env:userprofile\Desktop\favorites.csv -NoTypeInformation
#Opens the CSV file for reading
Invoke-Item $env:userprofile\Desktop\favorites.csv


'# OUTPUT
'=================================================================================
'Name							URL
'Access Achieve					https://magellan.learn.com/laprovider
'Anasazi - Logon					https://ansoaz.cernerworks.com/JEF/auth/login.aspx
'Bing							http://go.microsoft.com/fwlink/p/?LinkId=255142
'Clicial Advisor					https://ca.magellanhealth.com/vpn/index.html
'Contacts - New					http://wbsql1/Reports_PROD/report/Reports_For_All_Users/001_Telephone_Contacts
'Dev Essentials  - Visual Studio	https://www.visualstudio.com/dev-essentials/
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Classes_and_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Crreate_Object_adding_one_Member_at_time</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Classes_and_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Crreate_Object_adding_one_Member_at_time</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#'
#' Demo 2 -- Create a new object by adding properties one at a time (to SINGLE or MULTIPLE objects)
#' In the previous demo a property hash table was used to generate the object
#' Behind the scenes it does the equivalent of what this function does
#'-----------------------------------------------------------------------------#'
function Create-Object ($Schema, $Table, $Comment)
{
  #' Start by creating an EMPTY generic object of type PSObject
  $object = New-Object –TypeName psobject     

  #' SIMPLE syntac
  #' {as an Argument to a method (i.e. Add-Member) , this works for creation of ONE object}
  #' after creating it, then add the FIRST Member
  #' Add-Member by passing in input object 
  Add-Member -InputObject $object `
             –MemberType NoteProperty `			#'&lt;=== This is generic property
             –Name Schema `						#'&lt;=== this is the name of the property
             –Value $Schema						#'&lt;=== This is the value of the property


  #' ALTERNATE syntax, pipe the object as an input to Add-Member 
  #' {Pipe the object as input into the Method, could work for a COLLECTION of objects}
  #' Thus you could add a property to ALL the members of a collection  
  #' NOTE that with this syntax, 'object' could itself be a collection of objects
  #
  $object | Add-Member –MemberType NoteProperty `
                       –Name Table `
                       –Value $Table

  #' SECOND Member
  $object | Add-Member -MemberType NoteProperty `
                       -Name Comment `
                       -Value $Comment

  return $object
}

#'USAGE:

#'Create a new object
$myObject = Create-Object -Schema "MySchema" -Table "MyTable" -Comment "MyComment"
$myObject							 #' &lt;=== This will echo back the three properties, and their values

#' Display in text. Note because it is an object need to wrap in $() to access a property
"My Schema = $($myObject.Schema)"

$myObject.Schema = "New Schema"      #'&lt;=== update the property w/ a new value
$myObject.Comment = "New Comment"    #'&lt;=== update the property w/ a new value
$myObject							 #' &lt;=== This will echo back the three properties, and their values</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Classes_and_Objects</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Default_Properties</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Classes_and_Objects</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Default_Properties</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>I am not sure exactly what the "Default" properties does, except make it harder to see all the properties
See the last two lines, for what you now have to do to see ALL properties


#'-----------------------------------------------------------------------------#'
#' Demo 6 -- Set default properties
#' Thus display just the most important properties, when you type just the object.
#'-----------------------------------------------------------------------------#'
Clear-Host

#' When just running the object, it displays all properties
$myObject

#' If you have a lot, this can get overwhelming. Instead you can define a
#' default set to display.

#' Define the property names in an ARRAY.
$defaultProperties = 'Schema', 'Table', 'Comment', 'Author'

#' Create a PROPERTY SET object, 
#'   using 'New-Object'and 'PSPropertySet', 
#'   and pass in the array 
$defaultPropertiesSet `
  = New-Object System.Management.Automation.PSPropertySet(`
      ‘DefaultDisplayPropertySet’ `                            #' &lt;===  This is the type we want to create, so it is the 1st Parm.
      ,[string[]]$defaultProperties `                          #' &lt;===  Here you give it the object holding the array
      )

#' Create a PS Member Info object from the previous property set object
$members `
  = [System.Management.Automation.PSMemberInfo[]]@($defaultPropertiesSet)    #' &lt;===  Here you give it the set that was just created

#' Now add to the object
$myObject | Add-Member MemberSet PSStandardMembers $members            #' Now add a MemberSet of the type: PSStandardMembers

#' Now the object will just display the default list in standard output
$myObject

#' Little easier to read in a list
$myObject | Format-List

#' To display ALL PROPERTIES, pipe through format-list with wild card for property
$myObject | Format-List -Property *
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_DEBUG_ERROR_TroubleShooting</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_DEBUG_ERROR_TroubleShooting</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_DEBUG_ERROR_TroubleShooting



&gt;$ErrorActionPreference    ' Returns the Error Action setting
						   'When it hits a error or non-error condition it will keep running, but send it to the console
						   ' The error message will show up in the red text	
						   
						   'Example, use this after some command option to suppress the error: -ErrorAction SilentlyContinue						   
						   &gt;Do-Something -ErrorAction SilentlyContinue
						   
						   'OR you can just set it in general, or globally, and then add the option after a command to run that command different from the global
						   
						   &gt;$ErrorActionPreference = 'SilentlyContinue'
						   
&gt;$VerbosePreference		'Returns the Verbose setting value
						' -Verbose since $VerbosePreference defaults to SilentlyContinue
						
						'For an advanced function you can turn on the Verbose setting:
						&gt;Do-Something -Verbose
						
						'To set the Global setting:
						&gt;$VerbosePreference = 'Continue'
						
DEBUG						
						&gt;Do-Something -Debug   {It throws you into the double greater than sign 'debug' mode
						&gt;&gt;
						To get out of it, just type 'exit' at the command line
						
				
#region During production we'll silence everything and instead, assign to a variable

		'Set the globals:
		$ErrorActionPreference = 'SilentlyContinue'
		$WarningPreference = 'SilentlyContinue'
		$VerbosePreference = 'SilentlyContinue'
		$DebugPreference = 'SilentlyContinue'
		
		## A VM already exists so instead of confusing the user let's just log to fictional file instead
		## This puts the warning into the Warning variable: VMAlreadyExists, but put it into a file rather than to the console
		New-VirtualMachine -VMName 'AlreadyExists' -WarningVariable VMAlreadyExists
		if ($VMAlreadyExists) {
		    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "WARNING: $VMAlreadyExists"
		}
		
		## Here we create an 'error' variable, and save it to a log file
		New-VirtualMachine -VMName 'SQLInjectAttackName' -ErrorVariable err
		if ($err) {
		    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "ERR: $($err.Exception.Message)"
		}
		
		## Check out the log
		Get-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log'

#endregion		</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>error_from_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>error_from_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># No error handling produces ugly errors

function divver($enum,$denom)
{   
  Write-Host "Divver begin."
  $result = $enum / $denom
  Write-Host "Result: $result"
  Write-Host "Divver done."    
}

Clear-Host
divver 33 3   # No Error
divver 33 0   # Generate Error

# Handle errors using try/catch/finally
function divver($enum,$denom)
{   
  Write-Host "Divver begin."

  try
  {
    $result = $enum / $denom
    Write-Host "Result: $result"
  }
  catch
  {
    Write-Host "Oh NO! An error has occurred!!"
    Write-Host $_.ErrorID
    Write-Host $_.Exception.Message
    break  # With break, or omitting it, error bubbles up to parent
  }
  finally
  {
    Write-Host "Divver done."    
  }
}

Clear-Host
divver 33 3   # No Error
divver 33 0   # Generate Error

#endregion Error Handling

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>try_catch</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>try_catch</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>try	{
		if($SomeErrorOccurred) {
									throw 'some error occurred'
							   }
	} 
catch {
		Write-Error "$($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
	  }</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Event_Logs</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get_Events_in_Time_Window</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Event_Logs</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get_Events_in_Time_Window</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'=========START Get-WinEventWithin.ps1 =============================================================
param([string]$ComputerName = 'localhost',[datetime]$StartTimestamp,[datetime]$EndTimestamp)


#'Get-WinEvent lets you query ALL event log sources, and is faster than Get-EventLog
#'  "where { $_.RecordCount }" gets rid of all the event logs with no events
$Logs = (Get-WinEvent -ListLog * -ComputerName $ComputerName | where { $_.RecordCount }).LogName

$FilterTable = @{
	                'StartTime' = $StartTimestamp
	                'EndTime' = $EndTimestamp
	                'LogName' = $Logs
                }
		
Get-WinEvent -ComputerName $ComputerName -FilterHashtable $FilterTable -ErrorAction 'SilentlyContinue'

#'=========END Get-WinEventWithin.ps1 =============================================================

#'USAGE

 .\Get-WinEventWithin.ps1 -StartTimestamp '11-18-16 04:00' -EndTimestamp '11-18-16 05:10' 

 #'To get count of the events
 (.\Get-WinEventWithin.ps1 -StartTimestamp '11-18-16 04:00' -EndTimestamp '11-18-16 05:10').Count</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>File_Existance</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>File_Existance</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'You might consider piping instead:

if ($path | Test-Path) { ... }
if (-not ($path | Test-Path)) { ... }
if (!($path | Test-Path)) { ... }

'Alternatively, for the negative approach, if appropriate for your code, you can make it a positive check then use else for the negative:

if (Test-Path $path) {
    throw "File already exists."
} else {
   # The thing you really wanted to do.
}

////////////////////////

if (Test-Path $path) { ... }
'and
if (-not (Test-Path $path)) { ... }
if (!(Test-Path $path)) { ... }

////////////////////////

if(![System.IO.File]::Exists($path)){
    # file with path $path doesn't exist
}


////////////////////////
'from: http://stackoverflow.com/questions/31888580/a-better-way-to-check-if-a-path-exists-or-not-in-powershell/31888581#31888581

If, on the other hand, you want a general purpose negated alias for Test-Path, here is how you should do it:

'# Gather command meta data from the original Cmdlet (in this case, Test-Path)
$TestPathCmd = Get-Command Test-Path
$TestPathCmdMetaData = New-Object System.Management.Automation.CommandMetadata $TestPathCmd

'# Use the static ProxyCommand.GetParamBlock method to copy 
'# Test-Path's param block and CmdletBinding attribute
$Binding = [System.Management.Automation.ProxyCommand]::GetCmdletBindingAttribute($TestPathCmdMetaData)
$Params  = [System.Management.Automation.ProxyCommand]::GetParamBlock($TestPathCmdMetaData)

'# Create wrapper for the command that proxies the parameters to Test-Path 
'# using @PSBoundParameters, and negates any output with -not
$WrappedCommand = { 
    try { -not (Test-Path @PSBoundParameters) } catch { throw $_ }
}

'# define your new function using the details above
$Function:notexists = '{0}param({1}) {2}' -f $Binding,$Params,$WrappedCommand

'notexists will now behave exactly like Test-Path, but always return the opposite result:

PS C:\&gt; Test-Path -Path "C:\Windows"
True
PS C:\&gt; notexists -Path "C:\Windows"
False
PS C:\&gt; notexists "C:\Windows" # positional parameter binding exactly like Test-Path
False
'As you've already shown yourself, the opposite is quite easy, just alias exists to Test-Path:

PS C:\&gt; New-Alias exists Test-Path
PS C:\&gt; exists -Path "C:\Windows"
True</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Get-MyFile.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Get-MyFile.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#' USAGE:
&gt; .\Get-MyFile.ps1 -Criteria 'Extension' - Attributes @{'Extension' = 'log'}

#' USAGE:
&gt; .\Get-MyFile.ps1 -Criteria Age -Attributes @{'DaysOld' = 5}



#'=================================================================================================================================
param ([string[]]$Computername = 'localhost', [string]$Criteria, [hashtable]$Attributes)   #' &lt;==== an array of computer names

foreach ($Computer in $Computername) {
	## Enumerate all of the default admin shares
    $CimInstParams = @{'ClassName' = 'Win32_Share'}
    if ($Computer -ne 'localhost') {
	    $CimInstParams.Computername = $Computer    
    }
    $DriveShares = (Get-CimInstance @CimInstParams | where { $_.Name -match '^[A-Z]\$$' }).Name    #' &lt;===List of Drive Shares
	foreach ($Drive in $DriveShares) {
		switch ($Criteria) {
			'Extension' {
                Get-ChildItem -Path "\\$Computer\$Drive" -Filter "*.$($Attributes.Extension)" -Recurse
			}
			'Age' {
				$Today = Get-Date
                $DaysOld = $Attributes.DaysOld
                Get-ChildItem -Path "\\$Computer\$Drive" -Recurse | Where-Object { $_.LastWriteTime -le $Today.AddDays(-$DaysOld)}
			}
			'Name' {
                $Name = $Attributes.Name
				Get-ChildItem -Path "\\$Computer\$Drive" -Filter "*$Name*" -Recurse
			}
            default {
                Write-Error "Unrecognized criteria '$Criteria'"
            }
		}
	}
}
#'=================================================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Read_from_File</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Read_from_File</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

Get-Content C:\Scripts\Test.txt			'In turn, Windows PowerShell displays the contents of the file in the console window:


'assign the returned information to a variable
$a = Get-Content C:\Scripts\Test.txt
'When Get-Content reads a text file and stashes the contents in a variable, the data is stored as an array, 
'	with each line in the file 
'	(determined by the presence of a carriage return-linefeed character) 
'	representing a single item in the array

'For example, do you want to look at only the first three lines in the text file?
'the first item in an array is always item 0.
(Get-Content C:\Scripts\Test.txt)[0 .. 2]

'another way to display just the first x number of lines in a text file is to use the –totalcount parameter
'Get-Content will retrieve only the first three lines in the file Test.txt:
Get-Content C:\Scripts\Test.txt -totalcount 3

'what about the last three lines in the text file? 
(Get-Content C:\Scripts\Test.txt)[-1 .. -3]
'The -1 represents the last item in the array. 
'The index number -2 represents the second-to-the-last item in the array, and so on.

'If you want to grab specific lines from the middle of the text file then use a command like this:
(Get-Content C:\Scripts\Test.txt)[3 .. 5]


'How can we open that file, sort the contents, and then display the sorted contents?
(Get-Content C:\Scripts\Test.txt) | Sort-Object

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Windows_10_Mount_Dismount_ISO_VHD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Windows_10_Mount_Dismount_ISO_VHD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&gt; Mount-DiskImage -ImagePath "E:\ISO-Files\My US Visit Fall 2010 Pictures.iso"

&gt; Dismount-DiskImage -ImagePath "E:\ISO-Files\My US Visit Fall 2010 Pictures.iso"</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Write_to_File</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Write_to_File</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'The Out-File cmdlet enables you to send pipelined output directly to a text file rather than displaying that output on screen. 
Get-Process | Out-File c:\scripts\test.txt

'The problem with Out-File is that it works like the console. When text is output, it will be truncated if it is wider than the default.
' I also assume the default is the standard console width (80 characters I believe.)

'Sometimes things won't fit on a line b/c it acts like it is writing to the display screen, with limited width, by default
'so use width parm:

Get-Process | Out-File c:\scripts\test.txt -width 120

======================================================
'Generate file with line of 10000 Xs.

PS C:\scripts&gt; 'X'*10000|out-file xxex.txt

'Now read file and get length of written line:

PS C:\scripts&gt; cat xxex.txt|%{$_.Length}
10000

'See - no limit when output comes from a variable.  -Width only manages conversion buffers for output from 'Format" commands. 
'Console output uses a default formatter that truncates long strings.  Variable output does not need this.

===========================================================
'write time to file:
Get-Date | Out-File C:\junk.txt</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Format_Commands_to_change_output_vie</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Format_Commands_to_change_output_vie</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Format_Commands_to_change_output_vie</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Format_Commands_to_change_output_vie</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Format_Commands_to_change_output_view

'The Format cmdlets are 
'	Format-Wide
'	Format-List
'	Format-Table
'	and Format-Custom

'Each cmdlet also uses the same parameter name, Property, to specify which properties you want to display. 
'	Because Format-Wide only shows a single property, its Property parameter only takes a single value, 
'	but the property parameters of Format-List and Format-Table will accept a list of property names.

'Example:
&gt; Get-Process -Name chrome

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName                                                                                                     
-------  ------    -----      ----- -----   ------     -- -----------                                                                                                     
    220      24    64112      52000   263    38.66   5404 chrome                                                                                                          
    165      20    34864      33988   207     0.45   6456 chrome                                                                                                          
    160      20    28312      30240   209     0.87   6668 chrome                                                                                                          
   1281      69    93976     115380   378    57.63   7036 chrome                                                                                                          
    205      23    42608      55556   243    16.11  24500 chrome                                                                                                          
    195      23    42492      49880   256     1.36  26212 chrome  
    
'The Format-Wide cmdlet, by default, displays only the default property of an object.    
&gt; Get-Process -Name chrome | Format-Wide

chrome                                                                                chrome                                                                              
chrome                                                                                chrome                                                                              
chrome                                                                                chrome       

'You can also specify a non-default property:
&gt; Get-Process -Name chrome | Format-Wide  -Property Id
5404                                                                                  6456                                                                                
6668                                                                                  7036                                                                                
24500                                                                                 26212

'With the Format-Wide cmdlet, you can only display a single property at a time. This makes it 
'useful for displaying simple lists that show only one element per line. To get a simple listing, set the value of the Column parameter to 1 

&gt; Get-Process -Name chrome | Format-Wide   -Column 1
chrome                                                                                                                                                                    
chrome                                                                                                                                                                    
chrome                                                                                                                                                                    
chrome                                                                                                                                                                    
chrome                                                                                                                                                                    
chrome  

'The Format-List cmdlet displays an object in the form of a listing, with each property labeled and displayed on a separate line:
&gt; Get-Process -Name chrome | Format-list
Id      : 5404
Handles : 220
CPU     : 39.1874512
Name    : chrome

Id      : 6456
Handles : 160
CPU     : 0.4524029
Name    : chrome

Id      : 6668
Handles : 160
CPU     : 0.8736056
Name    : chrome

Id      : 7036
Handles : 1274
CPU     : 59.1867794
Name    : chrome

Id      : 24500
Handles : 210
CPU     : 17.9713152
Name    : chrome

Id      : 26212
Handles : 195
CPU     : 1.3572087
Name    : chrome


'You can specify as many properties as you want:
&gt; Get-Process -Name chrome | Format-list -Property processname, id


ProcessName : chrome
Id          : 5404

ProcessName : chrome
Id          : 6456

ProcessName : chrome
Id          : 6668

ProcessName : chrome
Id          : 7036

ProcessName : chrome
Id          : 24500

ProcessName : chrome
Id          : 26212

'Getting Detailed Information by Using Format-List with Wildcards, This gives a huge list of properties
&gt; Get-Process -Name chrome | Format-list -Property *

'If you use the Format-Table cmdlet with no property names specified to format the output of the Get-Process command, 
'you get exactly the same output as you do without performing any formatting. 
'The reason is that processes are usually displayed in a tabular format, as are most Windows PowerShell objects.

&gt; Get-Process -Name chrome | Format-table

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName                                                                                                                          
-------  ------    -----      ----- -----   ------     -- -----------                                                                                                                          
    219      24    70044      60708   268    83.46   5404 chrome                                                                                                                               
    160      20    34756      34012   206     0.47   6456 chrome                                                                                                                               
    160      20    29432      31500   210     1.20   6668 chrome                                                                                                                               
   1313      69   105772     128120   394    84.60   7036 chrome                                                                                                                               
    204      23    42096      54180   242    20.51  24500 chrome                                                                                                                               
    195      23    42204      49748   256     1.40  26212 chrome  

'If you specify the AutoSize parameter when you run the Format-Table command,
' Windows PowerShell will calculate column widths based on the actual data you are going to display.
'The Format-Table cmdlet might still truncate data, but it will only do so at the end of the screen

&gt; Get-Process -Name chrome | Format-table  -Property Path,Name,Id,Company -AutoSize

Path                                                        Name      Id Company    
----                                                        ----      -- -------    
C:\Program Files (x86)\Google\Chrome\Application\chrome.exe chrome  5404 Google Inc.
C:\Program Files (x86)\Google\Chrome\Application\chrome.exe chrome  6456 Google Inc.
C:\Program Files (x86)\Google\Chrome\Application\chrome.exe chrome  6668 Google Inc.
C:\Program Files (x86)\Google\Chrome\Application\chrome.exe chrome  7036 Google Inc.
C:\Program Files (x86)\Google\Chrome\Application\chrome.exe chrome 24500 Google Inc.
C:\Program Files (x86)\Google\Chrome\Application\chrome.exe chrome 26212 Google Inc.

'you can force lengthy Format-Table data to wrap within its display column by using the Wrap parameter
'An advantage of using the Wrap parameter by itself is that it does not slow down processing very much. 
'	If you perform a recursive file listing of a large directory system, 
'	it might take a very long time and use a lot of memory before displaying the first output items if you use AutoSize.

&gt; Get-Process -Name chrome | Format-table -wrap -Property Path,Name,Id,Company

'Another useful parameter for tabular output control is GroupBy. 
'	Longer tabular listings in particular may be hard to compare. The GroupBy parameter groups output based on a property value. 
'	For example, we can group processes by company for easier inspection, omitting the company value from the property listing:

&gt; Get-Process -Name chrome | Format-table -wrap -Property Path,Name,Id  -GroupBy Company




</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions_Numeric</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>aggregate</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions_Numeric</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>aggregate</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#
# useful agregate
#
function count
{
    BEGIN { $x = 0 }
    PROCESS { $x += 1 }
    END { $x }
}

function product
{
    BEGIN { $x = 1 }
    PROCESS { $x *= $_ }
    END { $x }
}

function sum
{
    BEGIN { $x = 0 }
    PROCESS { $x += $_ }
    END { $x }
}

function average
{
    BEGIN { $max = 0; $curr = 0 }
    PROCESS { $max += $_; $curr += 1 }
    END { $max / $curr }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Functions

Advanced Functions have the following advantages over standard functions:
1] Stream control:
	Control verbose, warning,debug and error output 
2] Validation, mandatory, parameter sets, 	
	Advanced Parameters
3] 	
	Pipeline InputAcceptance
4] 	
	A Safety Net:
		-WhatIf and -Confirm
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Advanced_Function__TEMPLATE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Advanced_Function__TEMPLATE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function New-AdvancedFunction {
								&lt;#
								.SYNOPSIS
									
								.EXAMPLE
									PS&gt; New-AdvancedFunction -Param1 MYPARAM
							
							        This example does something to this and that.
								.PARAMETER Param1
							        This param does this thing.
								.PARAMETER 
								.PARAMETER 
								.PARAMETER 
								#&gt;
								[CmdletBinding()]
								param (
							        [string]$Param1
								)
								process {
											try	{
										
												} 
											catch {
													Write-Error "$($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
												  }
										}
							}

#' With begin/end: ========================================================================================

function New-AdvancedFunction {
								&lt;#
								.SYNOPSIS
									
								.EXAMPLE
									PS&gt; New-AdvancedFunction -Param1 MYPARAM
							
							        This example does something to this and that.
								.PARAMETER Param1
							        This param does this thing.
								.PARAMETER 
								.PARAMETER 
								.PARAMETER 
								#&gt;
								[CmdletBinding()]
								param (
							        [string]$Param1
								)
								begin {
									      #' This is where you can put functions used in the 'process' section, or "." source statements
									  }
								process {
											try	{
										
												} 
											catch {
													Write-Error "$($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
												  }
										}
								end {
								
									}
							}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Advanced_Functions_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Advanced_Functions_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># Advanced functions also allow parameters with extra helping hints
function Get-AValue ()
{
  [CmdletBinding()]                       # &lt;===== Needed to indicate this is an advanced function
  param (                                 # &lt;=====  Begin the parameter block

         [Parameter( Mandatory = $true,
                     HelpMessage = 'Please enter value one.'
                     )]
         [int] $one,                      # &lt;===== Strong typing is optional

         
         [Parameter( Mandatory = $false,
                     HelpMessage = 'Please enter value two.'
                     )]
         [int] $two = 42                  # &lt;===== Since this is optional, you can provide a default value

        )  # End the parameter block

  begin { }

  process { 
            return $one * $two
          }

  end { }

}

# Example 1 pass in values
Get-AValue -one 33 -two 42

# Example 2 pass in value for one, take default for two
Get-AValue -one 33 

# Example 3 no params, will prompt for one and take default for two
Get-AValue 

# Example 4, use a string for one (generates error)
Get-AValue -one "x"

#endregion Functions

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Advanced_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Advanced_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Advanced Functions

'Advanced functions allow you to write functions that can act like cmdlets.

'Those features would be typically available with compiled cmdlet using a Microsoft .NET Framework language 
'	(for example with C#). However, Advanced Functions make it simple and are written in Windows PowerShell 
'	in the same way that other functions or script blocks are written.

'Rule #1 says that the function shouldn’t care about its input. 
'	Instead, your function should simply implement
'	 a ComputerName parameter and accept one or more computer names. 

'all you need is the attribute CmdletBinding.
'Note: You can also use the [Parameter()] attribute to make it advanced, but for this example I'll stick with CmdletBinding.

Function Get-ComputerInformation
{
    [CmdletBinding()]				' &lt;===== 1]
    PARAM ($ComputerName)			' &lt;===== 2]
    # Computer System
    $ComputerSystem = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $ComputerName
    # Operating System
    $OperatingSystem = Get-WmiObject -Class win32_OperatingSystem -ComputerName $ComputerName
    # BIOS
    $Bios = Get-WmiObject -class win32_BIOS -ComputerName $ComputerName
    
    # Prepare Output
    $Properties = @{
        ComputerName = $ComputerName
        Manufacturer = $ComputerSystem.Manufacturer
        Model = $ComputerSystem.Model
        OperatingSystem = $OperatingSystem.Caption
        OperatingSystemVersion = $OperatingSystem.Version
        SerialNumber = $Bios.SerialNumber
    }
    
    # Output Information
    New-Object -TypeName PSobject -Property $Properties
    
}

'Accept Pipeline Input and Verbose message
'adding the static parameter “ValueFromPipeline” inside the Parameter attribute: [Parameter(ValueFromPipeline)]
'Verbose messages are available using the Write-Verbose cmdlet. 

Function Get-ComputerInformation
{
    [CmdletBinding()]
    PARAM (
        [Parameter(ValueFromPipeline)]
        $ComputerName = $env:COMPUTERNAME
    )
    PROCESS
    {
        Write-Verbose -Message "$ComputerName"
        
        # Computer System
        $ComputerSystem = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $ComputerName
        # Operating System
        $OperatingSystem = Get-WmiObject -class win32_OperatingSystem -ComputerName $ComputerName
        # BIOS
        $Bios = Get-WmiObject -class win32_BIOS -ComputerName $ComputerName
        
        # Prepare Output
        Write-Verbose -Message "$ComputerName - Preparing output"
        $Properties = @{
            ComputerName = $ComputerName
            Manufacturer = $ComputerSystem.Manufacturer
            Model = $ComputerSystem.Model
            OperatingSystem = $OperatingSystem.Caption
            OperatingSystemVersion = $OperatingSystem.Version
            SerialNumber = $Bios.SerialNumber
        } #Properties
        
        # Output Information
        Write-Verbose -Message "$ComputerName - Output Information"
        New-Object -TypeName PSobject -Property $Properties
    } #PROCESS
} #Function</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Functions</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PIPELINE_functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Functions</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PIPELINE_functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
# It is possible to PIPELINE enable your functions
# These are referred to as ADVANCED functions
function Get-PSFiles ()
{
  # The begin block executes once at the start of the function for the RETURN VALUE (retval)
  begin  { $retval = "Here are some PowerShell files: `r`n" }    # `r`n = carriage return line feed

  # The process block is executed once for each object being
  # passed in from the pipe
  process { 
            if ($_.Name -like "*.ps1")
            { 
              $retval += "`t$($_.Name)`r`n"             #concatenate to the retval, TAB, and CRLF
              # Note this line could also be rendered as
              #$retval = $retval + "`t" + $_.Name + "`r`n" 
              # `t     Tab Character
              # `r     Carriage Return
              # `n     Line Feed
              # $( )   Tells PS to evaute the expression in () first then return it
              # $_     The current object being passed in the pipeline
              # .Name  The name property of the current object 
            }
          }
  
  # The end block executes once, after the rest of the function
  end { return $retval }          
}





Clear-Host
Set-Location "C:\PS\Beginning PowerShell Scripting for Developers\demo"
Get-ChildItem | Get-PSFiles




$output = Get-ChildItem | Get-PSFiles


$output.GetType()          #This would show as a single string, so can not be used as objects being passed into an array
                           # and you can not pipeline the individual objects

Clear-Host
$i = 0
foreach($f in $output)
{
  $i++
  "$i : $f"     #This would produce a line w/ a number for each item, but if you run this you get only one number
                # even though the line feeds would make it show up on different lines.
}

#==========================================================================================================
# To pipeline the output, push the output in the process area
function Get-PSFiles ()
{
  begin  { }    # &lt;=== empty

      process { 
                if ($_.Name -like "*.ps1")
                { 
                  $retval = "`tPowerShell file is $($_.Name)"
                  $retval  # This is the equivalent of: return $retval
                           # so some people use "return" but you can just call it, like this to return it
                           # In this case there is no CRLF, the $retval is just sent right back out
                }
              }
  
  end { }       # &lt;===  empty       
}

$output = Get-ChildItem | Get-PSFiles
$output.GetType()          # IN THIS CASE it will show that it is an ARRAY of objects, and no longer a single string

#NOW when you iterate you will get the counter with a new value on each line

Clear-Host
$i = 0
foreach($f in $output)
{
  $i++
  "$i : $f"
}


#HERE is a second piping function using "process"

function Write-SomeText ()
{
  # begin  { }            # &lt;== NOTE: These are commented out

  process { 
            $retval = "Here is the output: $($_)"          
            $retval
          }
  
  # end { }            # &lt;== NOTE: These are commented out          
}


Clear-Host
Set-Location "C:\PS\Beginning PowerShell Scripting for Developers\demo"
# NOW COMBINE BOTH OF THE PIPing functions
Get-ChildItem | Get-PSFiles | Write-SomeText



# Similar to original function but truly pipelined
"Here are some PowerShell files: `r`n"
Get-ChildItem | Get-PSFiles 


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_HASH_table</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FILTER_HashTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_HASH_table</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FILTER_HashTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$FilterTable = @{
	                'StartTime' = $StartTimestamp
	                'EndTime' = $EndTimestamp
	                'LogName' = $Logs
                }
#'USAGE:		
Get-WinEvent -ComputerName localhost -FilterHashtable $FilterTable -ErrorAction 'SilentlyContinue'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_HASH_table</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>HASH_Table_as_PARM_for_a_Method</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_HASH_table</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>HASH_Table_as_PARM_for_a_Method</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'Hash Table with all the parms I will need for the New-AdUser method
$NewUserParams = @{
    'UserPrincipalName' = $Username
    'Name' = $Username
    'GivenName' = $FirstName
    'Surname' = $LastName
    'Title' = $Title
    'SamAccountName' = $Username
    'AccountPassword' = (ConvertTo-SecureString $DefaultPassword -AsPlainText -Force)
    'Enabled' = $true
    'Initials' = $MiddleInitial
    'Path' = "$Location,$DomainDn"       #'&lt;=== Creates a fully distinguished name
    'ChangePasswordAtLogon' = $true
}


#' USAGE ======================================================================================================
New-AdUser @NewUserParams                #'&lt;==== Pass a whole hash table of parms to the method


#' USAGE ======================================================================================================
#' the parameter names (i.e. Hash Table Keys) must be spelled just like the Parameters of the method be called
#' e.g. 'givenName' and 'surname' keys in the Hashtable are the same as the PARMs of Set-AdUser  

&gt; .\Set-MyAdUser.ps1 -Username rsmith -Attributes @{givenName = "Trudy"; surname = 'smithley'}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_HASH_table</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Query_EventLog_BetweenDateTimes_using_a_FilterHashTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_HASH_table</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Query_EventLog_BetweenDateTimes_using_a_FilterHashTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#'=====START: Get-WinEventWithin.ps1 ========================================================================

param([string]$ComputerName = 'localhost',[datetime]$StartTimestamp,[datetime]$EndTimestamp)


#'Get-WinEvent lets you query ALL event log sources, and is faster than Get-EventLog
#'  "where { $_.RecordCount }" gets rid of all the event logs with no events
$Logs = (Get-WinEvent -ListLog * -ComputerName $ComputerName | where { $_.RecordCount }).LogName

$FilterTable = @{
	                'StartTime' = $StartTimestamp
	                'EndTime' = $EndTimestamp
	                'LogName' = $Logs
                }
		
Get-WinEvent -ComputerName $ComputerName -FilterHashtable $FilterTable -ErrorAction 'SilentlyContinue'
#'=====END: Get-WinEventWithin.ps1 ========================================================================

#'USAGE:===========================
&gt; .\Get-WinEventWithin.ps1 -StartTimestamp '11-18-16 04:00' -EndTimestamp '11-18-16 05:10' 

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_IP_Port_Telnet_WindowsSockets</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_IP_Port_Telnet_WindowsSockets</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_IP_Port_Telnet_WindowsSockets</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_IP_Port_Telnet_WindowsSockets</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_IP_Port_Telnet_WindowsSockets


'TELNET
'---------------
' By default, Telnet is not installed on Windows or Windows Server. 
'	In order to use Telnet, the Telnet client has to be installed. 
'	In Windows, this can be done through Control Panel &gt; Programs and Features &gt; Turn Windows features on or off, and check the Telnet Client. 
'	For Windows Server, go to Server Manager &gt; Features &gt; Add Features &gt; Telnet Client.

'Can add the Telnet Client feature through PowerShell,
Import-Module ServerManager
Add-WindowsFeature -Name Telnet-Client 


'Instead of installing the Telnet client, 
'	alternatively we could use Windows Sockets through the System.Net.Sockets provided in .NET framework.

'To test the TCP port,
$tcp = New-Object System.Net.Sockets.TcpClient
$tcp.connect('&lt;remote server&gt;', &lt;port&gt;)

'Or even one line of code if you wish,
(New-Object System.Net.Sockets.TcpClient).Connect('&lt;remote server&gt;', &lt;port&gt;)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_LogParser(IIS)=&gt;SQL__CREATE_TABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_LogParser(IIS)=&gt;SQL__CREATE_TABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--p_0014_CREATE_TABLE_T001_W3SVC1_JPHSA411_v4.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 03/22/2017
	By: glenn garson
	************************************************************************************
*/

USE [d4_IIS_Logs]
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF OBJECT_ID('dbo.T001_W3SVC1_JPHSA411') IS NOT NULL
    DROP TABLE dbo.T001_W3SVC1_JPHSA411

CREATE TABLE [dbo].[T001_W3SVC1_JPHSA411](
	[T001_PK] [int] IDENTITY(1,1) NOT NULL,

	[LogFilename] [varchar](255) NULL,
	[LogRow] [int] NULL,
	[EntryTime] [datetime] NULL,
	[SiteName] [varchar](255) NULL,
	[Client_IP] [varchar](255) NULL,
	[csUsername] [varchar](255) NULL,
	[ServerIpAddress] [varchar](255) NULL,
	[sPort] [int] NULL,
	[csMethod] [varchar](255) NULL,
	[csUriStem] [varchar](255) NULL,
	[csUriQuery] [varchar](255) NULL,
	[scStatus] [int] NULL,
	[scSubstatus] [int] NULL,
	[scWin32Status] [int] NULL,
	[BytesFromServerToClient] [int] NULL,
	[BytesFromClientToServer] [int] NULL,
	[timeTaken] [int] NULL,
	[csUserAgent] [varchar](255) NULL,
	[csReferer] [varchar](255) NULL

	--[DateTime_Archived] [datetime] NOT NULL CONSTRAINT T001_ARCHIVE_TheDateTime_Default_GETDATE DEFAULT GETDATE(),
	--[ARCHIVE_T001_RowVersion] [timestamp] NULL
	CONSTRAINT [T001_W3SVC1_JPHSA411$T001_PK] PRIMARY KEY NONCLUSTERED 
		(
			[T001_PK] ASC
		)
		WITH 
				(
					PAD_INDEX  = OFF, 
					STATISTICS_NORECOMPUTE  = OFF, 
					IGNORE_DUP_KEY = OFF, 
					ALLOW_ROW_LOCKS  = ON, 
					ALLOW_PAGE_LOCKS  = ON
				) ON [PRIMARY]

)

GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_LogParser(IIS)=&gt;SQL__PowerShell_1st_and_2nd_Line</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_LogParser(IIS)=&gt;SQL__PowerShell_1st_and_2nd_Line</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'  IIS_Log_W3SVC1_to_SQL_v1.ps1

cls

#' First to create the SQL table
logparser.exe  –i:IISW3C   -iCheckpoint:cp__W3SVC1.lpc   -ignoreIdCols:on  -o:sql -server:WBSQL1\PROD  -database:d4_IIS_Logs -driver:"sql server"   “SELECT 
                LogFilename
                ,LogRow 
                ,TO_TIMESTAMP(date, time) AS EntryTime
                ,s-sitename AS SiteName
                ,c-Ip as Client_IP
                ,cs-Username
                ,s-Ip as ServerIpAddress
                ,s-Port
                ,cs-Method
                ,cs-Uri-Stem
                ,cs-Uri-Query
                ,sc-Status
                ,sc-Substatus
                ,sc-Win32-Status
                ,sc-Bytes as BytesFromServerToClient
                ,cs-Bytes as BytesFromClientToServer
                ,time-Taken
                ,cs(User-Agent)
                ,cs(Referer) INTO T001_W3SVC1_JPHSA411 FROM C:\inetpub\logs\LogFiles\W3SVC1\*”  
#' This should just add to the table, but was unable to test
logparser.exe  –i:IISW3C   -iCheckpoint:cp__W3SVC1.lpc   -ignoreIdCols:on  -o:sql -server:WBSQL1\PROD  -database:d4_IIS_Logs -driver:"sql server"   “SELECT 
                LogFilename
                ,LogRow 
                ,TO_TIMESTAMP(date, time) AS EntryTime
                ,s-sitename AS SiteName
                ,c-Ip as Client_IP
                ,cs-Username
                ,s-Ip as ServerIpAddress
                ,s-Port
                ,cs-Method
                ,cs-Uri-Stem
                ,cs-Uri-Query
                ,sc-Status
                ,sc-Substatus
                ,sc-Win32-Status
                ,sc-Bytes as BytesFromServerToClient
                ,cs-Bytes as BytesFromClientToServer
                ,time-Taken
                ,cs(User-Agent)
                ,cs(Referer) INTO T001_W3SVC1_JPHSA411 FROM C:\inetpub\logs\LogFiles\W3SVC1\*” 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_LogParser(IIS)=&gt;SQL__ScheduleTask</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_LogParser(IIS)=&gt;SQL__ScheduleTask</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

https://support.software.dell.com/appassure/kb/144451



'1] Open Task Scheduler

	'Open Task Scheduler, create folder named "JPHSA" 
	' Right click the folder, and Create a new task "IIS_to_SQL_W3SVC1". Name it and set your security options.

		'GENERAL {Tag}
		--------------
			'Name: IIS_to_SQL_W3SVC1 
			'Location: \JPHSA
			'Author: JPHSA01\ggarson
			'Description: run LogParser, sets the Checkpoint, and moves new data to table on SQL Server. Runs under JPHSA01\IIS_SQL_DomainAdmin
			'When running the task, use the following user account
			'	JPHSA01\IIS_SQL_DomainAdmin
			'(x) Run whether user is logged on or not
			'[x] Run with highest privileges
			'Configure for: Windows Server 2012
			 
			 
	'Check "Run with highest privileges" as our scripts need to run as admin.  
	', 
	'enable the 'Run whether user is logged on or not' radio button.
'2] Triggers {tag}

	'Click on the Triggers tab and set your schedule or event that will trigger the running of your PowerShell script. 

		'Triggers {Tag}
		--------------
		'[New]
		' On a Schedule: Daily, at 5:30:00 am, Start on 3/24/2017
	
	
'3] Action {Tag}

	'Click on the Actions tab and click on New.
	'Action: Start a program
	'Program/script: Powershell.exe
	'You don't need to put a path as it should already be on your system.
	
		'Actions {Tag}
		--------------
		'Action: Start a program
		'Program/script: Powershell.exe
		'Add arguments: C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe -NoLogo -NonInteractive -File "C:\DATA\PowerShellScripts\IIS_Log_W3SVC1_to_SQL_task_v0.ps1"
		
	'When I clicked [ok] it challenged me for the credentials of: JPHSA01\IIS_SQL_DomainAdmin
	p.iis_sql_23.56		
	'Message:
		This task requires that the user account specified has Log on as batch job rights.
		For more information about setting this policy, see the Task Security Context topic
		in Help	
	'To give the user rights:
			
'			Go to the Start menu
'			Run
'			Type secpol.msc
'			and press Enter
'			The Local Security Policy manager opens
'			Go to Security Settings - Local Policies - User Rights Assignment node
'			Double click Log on as a batch job on the right side
'			Click Add User or Group...
'			Select 'JPHSA01\IIS_SQL_DomainAdmin' and click OK
				
'4] Set Argument

	'First you need to set the ExecutionPolicy. You have two options here, you can set the ExecutionPolicy on the machine or you can do it on a per-script basis. 
	'	Read the PowerShell ExecutionPolicy link below as it talks about or you can issue the command:

	Get-Help About_execution_policies

	'To set the execution policy globally, you can issue this command from within PowerShell:

	Set-ExecutionPolicy Unrestricted

	'Or use one of the other settings available depending on your environment. 
	'In the context of this how-to, however, we want to set the execution policy on a per script basis and open up security for us to run the script. 
	'This security policy will only be in effect for the script we are running and not compromise security otherwise.
	'That means we use the following Argument:

	-ExecutionPolicy Bypass -File c:\temp\agent_repl.ps1

'5] Save and Test</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>gig_WorkingExamples_on_JPHSA-EBWEB2</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>gig_WorkingExamples_on_JPHSA-EBWEB2</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
#' This works b/c logparser.exe is in the environmental path.
&gt; logparser.exe “SELECT Top 10 cs-uri-stem, Count(*) FROM C:\inetpub\logs\LogFiles\W3SVC1\u_ex170308.log Group By cs-uri-stem Order by cs-uri-stem desc” –i:w3c

#'This does all the log files in the folder:
logparser.exe “SELECT Top 10 cs-uri-stem, Count(*) FROM C:\inetpub\logs\LogFiles\W3SVC1\* Group By cs-uri-stem Order by cs-uri-stem desc” –i:w3c

&gt; logparser.exe “SELECT *  FROM C:\inetpub\logs\LogFiles\W3SVC1\u_ex170308.log” –i:w3c

#'These are the output fields from previous statement:
#'LogFilename
#'RowNumber
#'date
#'time
#'s-ip
#'cs-method
#'cs-uri-stem
#'cs-uri-query                          
#'s-port
#'cs-username
#'c-ip
#'cs(User-Agent)  

#'Get help on the web log format:
&gt;logparser -h -i:IISW3C

#'SELECT and create Table:
logparser.exe –i:w3c  -o:sql -server:WBSQL1\DEV  -database:JUNK -driver:"sql server" -clearTable:on -createTable:on  “SELECT * INTO LogsTable FROM C:\inetpub\logs\LogFiles\W3SVC1\u_ex170308.log”

#'SELECT  create Table with Identity field, and checkpoint named: MyCheckpoint (NOTE the inoput format is not the same)
#' but this clears the table
logparser.exe  –i:IISW3C   -iCheckpoint:Checkpoint_W3SVC1.lpc   -ignoreIdCols:on  -o:sql -server:WBSQL1\PROD  -database:d4_IIS_Logs -driver:"sql server" -clearTable:on -createTable:on “SELECT * INTO jnk3_T001_W3SVC1_JPHSA411 FROM C:\inetpub\logs\LogFiles\W3SVC1\*” 

======================
#' First to create the SQL table
logparser.exe  –i:IISW3C   -iCheckpoint:Checkpoint_W3SVC1_b.lpc   -ignoreIdCols:on  -o:sql -server:WBSQL1\PROD  -database:d4_IIS_Logs -driver:"sql server"  -createTable:on “SELECT * INTO jnk3_T001_W3SVC1_JPHSA411 FROM C:\inetpub\logs\LogFiles\W3SVC1\*” 
#' This should just add to the table, but was unable to test
logparser.exe  –i:IISW3C   -iCheckpoint:Checkpoint_W3SVC1_b.lpc   -ignoreIdCols:on  -o:sql -server:WBSQL1\PROD  -database:d4_IIS_Logs -driver:"sql server"   “SELECT * INTO jnk3_T001_W3SVC1_JPHSA411 FROM C:\inetpub\logs\LogFiles\W3SVC1\*” 
==========================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>help</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>help</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Microsoft (R) Log Parser Version 2.2.10
Copyright (C) 2004 Microsoft Corporation. All rights reserved.

Usage:   LogParser [-i:&lt;input_format&gt;] [-o:&lt;output_format&gt;] &lt;SQL query&gt; |
                   file:&lt;query_filename&gt;[?param1=value1+...]
                   [&lt;input_format_options&gt;] [&lt;output_format_options&gt;]
                   [-q[:ON|OFF]] [-e:&lt;max_errors&gt;] [-iw[:ON|OFF]]
                   [-stats[:ON|OFF]] [-saveDefaults] [-queryInfo]

         LogParser -c -i:&lt;input_format&gt; -o:&lt;output_format&gt; &lt;from_entity&gt;
                   &lt;into_entity&gt; [&lt;where_clause&gt;] [&lt;input_format_options&gt;]
                   [&lt;output_format_options&gt;] [-multiSite[:ON|OFF]]
                   [-q[:ON|OFF]] [-e:&lt;max_errors&gt;] [-iw[:ON|OFF]]
                   [-stats[:ON|OFF]] [-queryInfo]

 -i:&lt;input_format&gt;   :  one of IISW3C, NCSA, IIS, IISODBC, BIN, IISMSID,
                        HTTPERR, URLSCAN, CSV, TSV, W3C, XML, EVT, ETW,
                        NETMON, REG, ADS, TEXTLINE, TEXTWORD, FS, COM (if
                        omitted, will guess from the FROM clause)
 -o:&lt;output_format&gt;  :  one of CSV, TSV, XML, DATAGRID, CHART, SYSLOG,
                        NEUROVIEW, NAT, W3C, IIS, SQL, TPL, NULL (if omitted,
                        will guess from the INTO clause)
 -q[:ON|OFF]         :  quiet mode; default is OFF
 -e:&lt;max_errors&gt;     :  max # of parse errors before aborting; default is -1
                        (ignore all)
 -iw[:ON|OFF]        :  ignore warnings; default is OFF
 -stats[:ON|OFF]     :  display statistics after executing query; default is
                        ON
 -c                  :  use built-in conversion query
 -multiSite[:ON|OFF] :  send BIN conversion output to multiple files
                        depending on the SiteID value; default is OFF
 -saveDefaults       :  save specified options as default values
 -restoreDefaults    :  restore factory defaults
 -queryInfo          :  display query processing information (does not
                        execute the query)


Examples:
 LogParser "SELECT date, REVERSEDNS(c-ip) AS Client, COUNT(*) FROM file.log
            WHERE sc-status&lt;&gt;200 GROUP BY date, Client" -e:10
 LogParser file:myQuery.sql?myInput=C:\temp\ex*.log+myOutput=results.csv
 LogParser -c -i:BIN -o:W3C file1.log file2.log "ComputerName IS NOT NULL"

Help:
 -h GRAMMAR                  : SQL Language Grammar
 -h FUNCTIONS [ &lt;function&gt; ] : Functions Syntax
 -h EXAMPLES                 : Example queries and commands
 -h -i:&lt;input_format&gt;        : Help on &lt;input_format&gt;
 -h -o:&lt;output_format&gt;       : Help on &lt;output_format&gt;
 -h -c                       : Conversion help</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>IIS_CustomField_input</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>IIS_CustomField_input</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
=========
'use the TRIM function around your string. 
	'This way, you can type any string you want as a custom extra field in a Log Parser Query.
'Reference : http://logparserplus.com/Functions#function_TRIM
'For example, I do it in this query (used to retrieve the Average and Max time) :
logparser -i:IISW3C -rtp:-1 -o:NAT -headers:OFF -iw:ON "SELECT TRIM('my-website-custom-extra-column-name.com') AS siteName, TRIM('foo-bar-custom-extra-column-name') AS fooBar, AVG(time-taken) As AverageTimeTaken, MAX(time-taken) As MaxTimeTaken, COUNT(*) As Hits, TO_LOWERCASE(cs-uri-stem) As Uri FROM C:\inetpub\yourwebsite.com\ex*.log TO c:\myOutputParsedLog.txt WHERE (Extract_Extension(To_Lowercase(cs-uri-stem)) IN ('aspx')) GROUP BY TO_LOWERCASE(cs-uri-stem) ORDER BY AverageTimeTaken DESC"
=========
use option -iHeaderFile to define your own fields. logparser -h will prove additional inforamtion</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogParser =&gt; SQL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogParser =&gt; SQL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'This command asks Log Parser to filter out entries for pages 
#'	ending up in ".gif", ".jpg", and ".png", 
#'	regardless of the capitalization of the URL. 
#'	It also leaves out requests that generated the HTTP error code "404", 
#'	that is, "page not found".

#'Everything else is handed to the SQL output format, 
#'	which will save the records to the table specified in the INTO clause. 
#'	Also, this output format accepts a "database" parameter 
#'	that we can use to specify the name of the target database, 
#'	together with many other parameters that let us specify other properties of the connection 
#'	to the SQL database.

#'To do this, you could put the command above in a batch file, use the SCHTASKS.EXE utility to schedule the batch 
#'	file to run, say, every hour, and ' poof! ' you'd have an automated mechanism that periodically 
#'	uploads entries from your log files to your SQL database.
#'Note that every time you execute the command above, 
#'	Log Parser goes through all the log entries over and over, 
#'	uploading all of them multiple times to the database. 
#'	What we really need is a mechanism to say "only parse the log entries not parsed yet."
#'Here's where a new Log Parser 2.2 feature comes handy: the "incremental parsing" feature, 
#'	also know as "checkpointing."

Checkpoints
===========
#'Most Log Parser input formats support a parameter, called "iCheckpoint", 
#'	that tells the input format to save to a private data file (a "checkpoint" file) 
#'	the current state of all the files being parsed. 
#'	When you execute a query using a checkpoint file generated during a previous run, 
#'	the input format will only parse those portions of the input files that were not parsed before, that is, new entries only.


logparser "SELECT * INTO LogsTable FROM ex*.log WHERE TO_LOWERCASE (EXTRACT_EXTENSION(cs-uri-stem)) NOT IN ('gif';'jpg';'png') AND sc-status &lt;&gt; 404" -i:IISW3C -o:SQL -database:LogsDatabase

#'So, all you need to do is specify the name of a checkpoint file with the "iCheckpoint" parameter, as follows:

&gt;logparser "SELECT * INTO LogsTable FROM ex*.log WHERE TO_LOWERCASE (EXTRACT_EXTENSION(cs-uri-stem)) NOT IN ('gif';'jpg';'png') AND sc-status &lt;&gt; 404" -i:IISW3C -o:SQL -database:LogsDatabase -iCheckpoint:MyCheckpoint.lpc

#'The very first time you execute this command, 
#'	the "MyCheckpoint.lpc" file does not exist, 
#'	and the IISW3C input format parses all the entries in all the log files, 
#'	filtering and uploading the resulting data to the database. 
#'After parsing all the logs, the IISW3C input format saves the current size of each log file to the "MyCheckpoint.lpc" file.
#'When you execute the same command at a later time, 
#'	the IISW3C input format will load the checkpoint file 
#'	and will parse the logs starting at the position where they were left in the previous run, 
#'	thus processing, filtering, and uploading new log entries only. 
#'When completed, it will update the checkpoint file with the new size of the log files, 
#'	and the cycle repeats itself continually.


#'	-o:sql
#'	-database:AdventureWorks2012
#'	-server:localhost\sqlsrv2012
#'	-driver:"sql server"
#'	SELECT...into ScmEvents  {the SQL table}
&gt; logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" "select extract_token(EventTypeName, 0, ' ') as TypeEvent,  to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where SourceName = 'Service  Control Manager' and SID is not null"

'Delete
===========
#'there might also be times when you want to delete the data in the target table before inserting the new information. 
#'	To do so, you can use the -clearTable parameter with the sql output format, as shown in the following example:
#' IT IS MUCH MORE EFFICIENT TO USE SQL and run a truncate statement
&gt; logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on "select extract_token(EventTypeName, 0, ' ') as  TypeEvent, to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where SourceName =  'Service Control Manager' and SID is not null"

Insert data into table with IDENTITY Fields in table
====================================================
#'when you insert Log Parser data into a SQL Server table, 
#'    the number and position of fields must match the target table, 
#'    as was the case in the preceding two examples. 
#'However, there is one exception to the rule. 
#'    If the target table includes a column configured with the IDENTITY property, 
#'    you can specify that no data be inserted into that column. 
#'    Let’s re-create our target table to demonstrate how this works. 
#'The following T-SQL again creates the ScmEvents table, but this time includes the EventID column, 
#'    which is configured with the IDENTITY property:

USE AdventureWorks2012;
GO
IF OBJECT_ID('ScmEvents','U')IS NOT NULL
DROP TABLEScmEvents;
GO
CREATETABLE dbo.ScmEvents
(
  EventIDint primarykey identity,
  TypeEventvarchar(25) NOT NULL,
  DateGenerateddatetime NOT NULL,
  SecurityIDvarchar(50) NULL
);
GO

#'When using Log Parser to insert data into a table with an IDENTITY column, 
#'    we can use the -ignoreIdCols parameter with the sql output format to prevent the utility from trying to insert data into that column. 
#'    The following example includes the -ignoreIdCols parameter with it set to on:

logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on -ignoreIdCols:on "select extract_token(EventTypeName,  0, ' ') as TypeEvent, to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where  SourceName = 'Service Control Manager' and SID is not null"

CreateTable
============
#'When you run the command, Log Parser will create the table in the target database if the table does not already exist. 
#'However, if you were to run this command without including the -createTable parameter and the table did not exist, 
#'Log Parser would return an error.

&gt;logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on -createTable:on "select extract_token(EventTypeName, 0,  ' ') as TypeEvent, to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where  SourceName = 'Service Control Manager' and SID is not null"


Query in External File
========================
#'When your SQL query becomes too unwieldy, 
#'    you can put the SQL in a separate file and call that file from your Log Parser command. 
#'For example, suppose we save the query in the previous example to the file C:\DataFiles\EvtQuery.sql

#'Once we’ve created the file for our query, we can modify our command as follows:

logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on -createTable:on file:c:\datafiles\evtquery.sql
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogParser_Expressions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogParser_Expressions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ALL
&lt;field_expr&gt; &lt;rel_op&gt; ALL ( &lt;value_rows&gt; ) | ( &lt;field_expr_list&gt; ) &lt;rel_op&gt; ALL ( &lt;value_rows&gt; )
The ALL operator compares a given field-expression with a list of values, returning TRUE if all values in the list satisfy the comparison operation, or FALSE if not all values satisfy the comparison.
ANY
&lt;field_expr&gt; &lt;rel_op&gt; ANY ( &lt;value_rows&gt; ) | ( &lt;field_expr_list&gt; ) &lt;rel_op&gt; ANY ( &lt;value_rows&gt; )
The ANY operator compares a given field-expression with a list of values, returning TRUE if any value in the list satisfies the comparison operation, or FALSE if no values satisfy the comparison.
BETWEEN
&lt;field_expr&gt; [ NOT ] BETWEEN &lt;field_expr&gt; AND &lt;field_expr&gt;
The BETWEEN operator determines if a given field-expression belongs to a specified interval.
sc-status BETWEEN 400 AND 499
Returns requests with a status code from 400 to 499, inclusive.
IN
&lt;field_expr&gt; [ NOT ] IN ( &lt;value_rows&gt; ) | ( &lt;field_expr_list&gt; ) [ NOT ] IN ( &lt;value_rows&gt; )
The IN and NOT IN operators determine whether or not a given field-expression or list of field-expressions matches any element in a list of values.
EXTRACT_EXTENSION(cs-uri-stem) NOT IN ('jpg';'png';'gif';'ico')
When used in a WHERE clause, excludes requests for common image formats.
See Removing potential bots from query results for an example using a nested query.
LIKE
&lt;field_expr&gt; [ NOT ] LIKE &lt;like_mask&gt;
Determines whether or not a given character string matches a specified pattern. A pattern can include regular characters and wildcard characters. During pattern matching, regular characters must yield a case-insensitive match with the characters specified in the character string. Wildcard characters, however, can be matched with arbitrary fragments of the character string. Using wildcard characters makes the LIKE operator more flexible than using the = and != string comparison operators. _ (underscore) matches any single character, while % (percent) matches any string of zero or more characters.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogParser_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogParser_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://logparserplus.com/Functions#function_TRIM

Function listing


ADD
ADD( addend1 &lt;any type&gt;, addend2 &lt;any type&gt; )
Calculates the sum of two values. Returns a value of the same type as its arguments.
Type: arithmetical

See also: SUB DIV MUL
AVG
AVG( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the average among all the values, or only the DISTINCT values, of the specified field-expression.
Type: aggregate

BIT_AND
BIT_AND( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Calculates the bitwise AND of two values.
Type: arithmetical

See also: BIT_NOT BIT_OR BIT_SHL BIT_SHR BIT_XOR
BIT_NOT
BIT_NOT( arg &lt;INTEGER&gt; )
Calculates the bitwise NOT of a value.
Type: arithmetical

See also: BIT_AND BIT_OR BIT_SHL BIT_SHR BIT_XOR
BIT_OR
BIT_OR( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Calculates the bitwise OR of two values.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_SHL BIT_SHR BIT_XOR
BIT_SHL
BIT_SHL( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Shifts a value left by a specified number of bits.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_OR BIT_SHR BIT_XOR
BIT_SHR
BIT_SHR( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Shifts a value right by a specified number of bits.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_OR BIT_SHL BIT_XOR
BIT_XOR
BIT_XOR( arg1 &lt;INTEGER&gt;, arg2 &lt;INTEGER&gt; )
Calculates the bitwise XOR of two values.
Type: arithmetical

See also: BIT_AND BIT_NOT BIT_OR BIT_SHL BIT_SHR
CASE
CASE &lt;field_expression&gt; WHEN &lt;field_expression&gt; THEN &lt;field_expression&gt; [ ... ] [ ELSE &lt;field_expression&gt; ] END
Compares the argument of the CASE statement with the arguments of the WHEN statements, returning the argument of a THEN statement when a match is found. If no match is found, returns the argument of the ELSE statement, or NULL if no ELSE statement is provided.
Type: miscellaneous

COALESCE
COALESCE( arg1 &lt;any type&gt;, arg2 &lt;any type&gt; [, ....] )
Returns the first non-NULL value among its arguments.
Type: miscellaneous

COMPUTER_NAME
COMPUTER_NAME()
Returns the NetBIOS name of the local computer.
Type: system information

COUNT
COUNT( [ DISTINCT | ALL ] * ) | ( [ DISTINCT | ALL ] &lt;field_expr_list&gt; )
Returns the number of items in a group.
Type: aggregate
COUNT(DISTINCT cs-uri-stem) AS [Distinct Requests]
Returns a count of how many distinct files were requested.
DIV
DIV( dividend &lt;INTEGER | REAL&gt;, divisor &lt;INTEGER | REAL&gt; )
Calculates the quotient of two values.
Type: arithmetical
DIV(sc-bytes, 1024) AS [KB Sent]
Converts bytes sent from the server to the client to Kilobytes (KB).
DIV(DIV(sc-bytes, 1024), 1024) AS [MB Sent]
Converts bytes sent from the server to the client to Megabytes (MB).
See also: MUL ADD SUB
EXP
EXP( argument &lt;INTEGER | REAL&gt; )
Calculates e (the Natural logarithm base) raised to the power of the specified argument.
Type: arithmetical

See also: EXP10
EXP10
EXP10( argument &lt;INTEGER | REAL&gt; )
Calculates 10 raised to the power of the specified argument.
Type: arithmetical

See also: EXP
EXTRACT_EXTENSION
EXTRACT_EXTENSION( filepath &lt;STRING&gt; )
Returns the file extension portion of a file path.
Type: string manipulation
EXTRACT_EXTENSION(cs-uri-stem) AS [File Extension]
Extracts the file extension for requests. Returns nothing for those without an extension.
EXTRACT_EXTENSION(cs-uri-stem) NOT IN ('jpg';'png';'gif';'ico')
When used in a WHERE clause, excludes requests for common image formats.
See also: EXTRACT_FILENAME EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_FILENAME
EXTRACT_FILENAME( filepath &lt;STRING&gt; )
Returns the filename portion of a file path.
Type: string manipulation
EXTRACT_FILENAME(cs-uri-stem) AS [File Requested]
Extracts the file name for requests.
See also: EXTRACT_EXTENSION EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_PATH
EXTRACT_PATH( filepath &lt;STRING&gt; )
Returns the directory path portion of a file path.
Type: string manipulation
EXTRACT_PATH(cs-uri-stem) AS [Path Requested]
Extracts the path of a request. The trailing slash (/) is removed.
See also: EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_PREFIX
EXTRACT_PREFIX( argument &lt;STRING&gt;, index &lt;INTEGER&gt;, separator &lt;STRING&gt; )
Returns a substring beginning at the first character and up to, but not including, the specified instance of the separator.
Type: string manipulation

See also: EXTRACT_SUFFIX EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_SUFFIX
EXTRACT_SUFFIX( argument &lt;STRING&gt;, index &lt;INTEGER&gt;, separator &lt;STRING&gt; )
Returns a substring beginning after the specified instance of the separator and up to the end of the string.
Type: string manipulation

See also: EXTRACT_PREFIX EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_TOKEN EXTRACT_VALUE
EXTRACT_TOKEN
EXTRACT_TOKEN( argument &lt;STRING&gt;, index &lt;INTEGER&gt; [ , separator &lt;STRING&gt; ] )
Splits the string into substrings at each point where the separator occurs, and returns the substring with the specified index.
Type: string manipulation
EXTRACT_TOKEN(cs(Referer), 2, '/') AS [Referring Domain]
Returns full domain of the site referring traffic to this resource.
See also: EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_VALUE
EXTRACT_VALUE
EXTRACT_VALUE( argument &lt;STRING&gt;, key &lt;STRING&gt; [ , separator &lt;STRING&gt; ] )
Parses "key=value" pairs in the string, returning the value corresponding to the specified key.
Type: string manipulation

See also: EXTRACT_EXTENSION EXTRACT_FILENAME EXTRACT_PATH EXTRACT_PREFIX EXTRACT_SUFFIX EXTRACT_TOKEN
FLOOR
FLOOR( argument &lt;REAL&gt; )
Returns the integral part of the specified argument.
Type: arithmetical

See also: ROUND QNTFLOOR_TO_DIGIT QNTROUND_TO_DIGIT
GROUPING
GROUPING( &lt;field_expr&gt; )
Returns a value of 1 when the row is added by the ROLLUP operator of the GROUP BY clause, or 0 when the row is not the result of ROLLUP. GROUPING is used to distinguish the NULL values returned by ROLLUP from standard NULL values. The NULL returned as the result of a ROLLUP operation is a special use of NULL. It acts as a value placeholder in the result set and means "all".
Type: aggregate

HASHMD5_FILE
HASHMD5_FILE( filePath &lt;STRING&gt; )
Calculates the MD5 hash of the content of a file and returns its hexadecimal representation.
Type: miscellaneous

HASHSEQ
HASHSEQ( value &lt;STRING&gt; )
Returns a unique, sequential integer for each distinct value of the argument.
Type: miscellaneous

HEX_TO_ASC
HEX_TO_ASC( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of a series of bytes into a string where the bytes belonging to the 0x20-0x7F range have been converted to ASCII characters.
Type: string manipulation

See also: HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_INT HEX_TO_PRINT
HEX_TO_HEX16
HEX_TO_HEX16( hexString &lt;STRING&gt; [ , bigEndian &lt;INTEGER&gt; ] )
Converts the hexadecimal representation of a series of bytes into another hexadecimal representation in which bytes are grouped into 16-bit WORDs.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_INT HEX_TO_PRINT
HEX_TO_HEX32
HEX_TO_HEX32( hexString &lt;STRING&gt; [ , bigEndian &lt;INTEGER&gt; ] )
Converts the hexadecimal representation of a series of bytes into another hexadecimal representation in which bytes are grouped into 32-bit DWORDs.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX8 HEX_TO_INT HEX_TO_PRINT
HEX_TO_HEX8
HEX_TO_HEX8( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of a series of bytes into another hexadecimal representation in which bytes are grouped into 8-bit octets.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_INT HEX_TO_PRINT
HEX_TO_INT
HEX_TO_INT( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of an integer into the integer itself.
Type: conversion

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_PRINT
HEX_TO_PRINT
HEX_TO_PRINT( hexString &lt;STRING&gt; )
Converts the hexadecimal representation of a series of bytes into a string where the bytes corresponding to printable ASCII characters have been converted to the characters themselves.
Type: string manipulation

See also: HEX_TO_ASC HEX_TO_HEX16 HEX_TO_HEX32 HEX_TO_HEX8 HEX_TO_INT
IN_ROW_NUMBER
IN_ROW_NUMBER()
Returns the current input record number.
Type: miscellaneous

See also: OUT_ROW_NUMBER
INDEX_OF
INDEX_OF( string &lt;STRING&gt;, searchStr &lt;STRING&gt; )
Returns the character position where the first occurrence of a search substring occurs in a string.
Type: string manipulation

See also: LAST_INDEX_OF
INT_TO_IPV4
INT_TO_IPV4( ipV4Address &lt;INTEGER&gt; )
Converts a 32-bit integer into the string representation of an IPV4 address.
Type: conversion

See also: IPV4_TO_INT
IPV4_TO_INT
IPV4_TO_INT( ipV4Address &lt;STRING&gt; )
Converts the string representation of an IPV4 address into a 32-bit integer.
Type: conversion

See also: INT_TO_IPV4
LAST_INDEX_OF
LAST_INDEX_OF( string &lt;STRING&gt;, searchStr &lt;STRING&gt; )
Returns the character position where the last occurrence of a search substring occurs in a string.
Type: string manipulation

See also: INDEX_OF
LOG
LOG( argument &lt;INTEGER | REAL&gt; )
Calculates the Natural logarithm of the specified argument.
Type: arithmetical

See also: LOG10
LOG10
LOG10( argument &lt;INTEGER | REAL&gt; )
Calculates the base-10 logarithm of the specified argument.
Type: arithmetical

See also: LOG
LTRIM
LTRIM( string &lt;STRING&gt; )
Removes whitespace characters from the beginning of a string.
Type: string manipulation

See also: RTRIM TRIM
MAX
MAX( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the maximum value among all the values of the specified field-expression.
Type: aggregate
MAX(sc-bytes) AS [Maximum Bytes Sent]
Returns the maximum number of bytes sent from the server to the client, across all requests.
See also: MIN
MIN
MIN( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the minimum value among all the values of the specified field-expression.
Type: aggregate
MIN(sc-bytes) AS [Minimum Bytes Sent]
Returns the minimum number of bytes sent from the server to the client, across all requests.
See also: MAX
MOD
MOD( dividend &lt;INTEGER | REAL&gt;, divisor &lt;INTEGER | REAL&gt; )
Calculates the remainder of the division of two numbers.
Type: arithmetical

MUL
MUL( multiplicand &lt;INTEGER | REAL&gt;, multiplier &lt;INTEGER | REAL&gt; )
Calculates the product of two values.
Type: arithmetical
MUL(PROPCOUNT(*), 100)
When used with another field and a simple GROUP BY, returns the percentage of requests by that field. See example query HTTP status codes and percentage of total.
See also: DIV ADD SUB
OUT_ROW_NUMBER
OUT_ROW_NUMBER()
Returns the current output record number.
Type: miscellaneous

See also: IN_ROW_NUMBER
PROPCOUNT
PROPCOUNT( * ) [ ON ( &lt;on_field_expr_list&gt; ) ] | ( &lt;field_expr_list&gt; ) [ ON ( &lt;on_field_expr_list&gt; ) ]
Returns the ratio of the COUNT aggregate function calculated on a group to the COUNT aggregate function calculated on a hierarchically higher group.
Type: aggregate

PROPSUM
PROPSUM( &lt;field_expr&gt; ) [ ON ( &lt;on_field_expr_list&gt; ) ]
Returns the ratio of the SUM aggregate function calculated on a group to the SUM aggregate function calculated on a hierarchically higher group.
Type: aggregate

QNTFLOOR_TO_DIGIT
QNTFLOOR_TO_DIGIT( value &lt;INTEGER&gt;, digits &lt;INTEGER&gt; )
Truncates a number to a specified number of significant digits, masking the remaining digits to zero.
Type: arithmetical

See also: QNTROUND_TO_DIGIT FLOOR ROUND
QNTROUND_TO_DIGIT
QNTROUND_TO_DIGIT( value &lt;INTEGER&gt;, digits &lt;INTEGER&gt; )
Rounds a number to a specified number of significant digits, masking the remaining digits to zero.
Type: arithmetical

See also: QNTFLOOR_TO_DIGIT FLOOR ROUND
QUANTIZE
QUANTIZE( argument &lt;INTEGER | REAL | TIMESTAMP&gt;, quantization &lt;INTEGER | REAL&gt; )
Truncates a value to the nearest multiple of another value.
Type: arithmetical
QUANTIZE(TO_TIMESTAMP(date, time), 3600)
Returns date/times to the hour. (In other words, drops the minutes.)
REPLACE_CHR
REPLACE_CHR( string &lt;STRING&gt;, searchCharacters &lt;STRING&gt;, replaceString &lt;STRING&gt; )
Replaces each occurrence of a character in a given set of characters with a string.
Type: string manipulation

REPLACE_IF_NOT_NULL
REPLACE_IF_NOT_NULL( argument &lt;any type&gt;, replaceValue &lt;any type&gt; )
Returns the second argument when the first argument is not NULL, and NULL otherwise.
Type: miscellaneous

REPLACE_STR
REPLACE_STR( string &lt;STRING&gt;, searchString &lt;STRING&gt;, replaceString &lt;STRING&gt; )
Replaces each occurrence of a substring with a string.
Type: string manipulation

RESOLVE_SID
RESOLVE_SID( sid &lt;STRING&gt; [ , computerName &lt;STRING&gt; ] )
Resolves a SID and returns its full account name.
Type: system information

REVERSEDNS
REVERSEDNS( ipAddress &lt;STRING&gt; )
Resolves an IP address and returns the corresponding host name.
Type: system information
REVERSEDNS(c-ip)
Returns the host name for the client's IP address.
ROT13
ROT13( string &lt;STRING&gt; )
Encodes or decodes a string using the ROT13 algorithm.
Type: string manipulation

ROUND
ROUND( argument &lt;REAL&gt; )
Returns the integer closest to the specified argument.
Type: arithmetical

See also: FLOOR QNTFLOOR_TO_DIGIT QNTROUND_TO_DIGIT
RTRIM
RTRIM( string &lt;STRING&gt; )
Removes whitespace characters from the end of a string.
Type: string manipulation

See also: LTRIM TRIM
SEQUENCE
SEQUENCE( [ startValue &lt;INTEGER&gt; ] )
Returns a unique sequential integer associated with the current input record number.
Type: miscellaneous

SQR
SQR( argument &lt;INTEGER | REAL&gt; )
Calculates the square of the specified argument.
Type: arithmetical

SQRROOT
SQRROOT( argument &lt;INTEGER | REAL&gt; )
Calculates the square root of the specified argument.
Type: arithmetical

STRCAT
STRCAT( string1 &lt;STRING&gt;, string2 &lt;STRING&gt; )
Appends one string to another.
Type: string manipulation

STRCNT
STRCNT( string &lt;STRING&gt;, token &lt;STRING&gt; )
Returns the number of occurrences of a substring in a string.
Type: string manipulation
STRCNT(cs-uri-stem, '/') AS [Request Depth]
Returns the depth of a requested file.
STRLEN
STRLEN( string &lt;STRING&gt; )
Returns the length of a string.
Type: string manipulation

STRREPEAT
STRREPEAT( string &lt;STRING&gt;, count &lt;INTEGER&gt; )
Creates a string by repeating a substring a given number of times.
Type: string manipulation

STRREV
STRREV( string &lt;STRING&gt; )
Reverses the characters in a string.
Type: string manipulation

SUB
SUB( minuend &lt;any type&gt;, subtrahend &lt;any type&gt; )
Calculates the difference of two values.
Type: arithmetical
TO_DATE(SUB(TO_LOCALTIME(SYSTEM_TIMESTAMP()), TIMESTAMP('0000-01-08', 'yyyy-MM-dd')))
Gets the date seven days ago, based on the current local date/time.
See also: ADD DIV MUL
SUBSTR
SUBSTR( string &lt;STRING&gt;, start &lt;INTEGER&gt; [ , length &lt;INTEGER&gt; ])
Returns a substring beginning at a specified location and having a specified length. The &lt;start&gt; of &lt;string&gt; begins at 0.
Type: string manipulation

SUM
SUM( [ DISTINCT | ALL ] &lt;field_expr&gt; )
Returns the sum of all the values, or only the DISTINCT values, of the specified field-expression.
Type: aggregate
SUM(sc-bytes) AS [Total Bytes Sent]
Returns the total number of bytes sent from the server to the client.
SYSTEM_DATE
SYSTEM_DATE()
Returns the current system date in Universal Time Coordinates (UTC) time.
Type: system information

See also: SYSTEM_TIME SYSTEM_TIMESTAMP
SYSTEM_TIME
SYSTEM_TIME()
Returns the current system time of the day in Universal Time Coordinates (UTC) time.
Type: system information

See also: SYSTEM_DATE SYSTEM_TIMESTAMP
SYSTEM_TIMESTAMP
SYSTEM_TIMESTAMP()
Returns the current system date and time in Universal Time Coordinates (UTC) time.
Type: system information
TO_LOCALTIME(SYSTEM_TIMESTAMP) AS [CurrentLocalTime]
Get the current date and time, converted to local time.
SUB(TO_LOCALTIME(SYSTEM_TIMESTAMP()), TIMESTAMP('0000-01-01 00:03', 'yyyy-MM-dd HH:mm'))
Get the local time 3 minutes ago.
See also: SYSTEM_DATE SYSTEM_TIME
SYSTEM_UTCOFFSET
SYSTEM_UTCOFFSET()
Returns the current system timezone and daylight saving offset relative to Universal Time Coordinates (UTC) time.
Type: system information

TO_DATE
TO_DATE( timestamp &lt;TIMESTAMP&gt; )
Converts a full timestamp into a date-only timestamp.
Type: conversion

See also: TO_TIME
TO_HEX
TO_HEX( argument &lt;INTEGER | STRING&gt; )
Returns the hexadecimal representation of an integer or of the characters in a string.
Type: conversion

TO_INT
TO_INT( argument &lt;any type&gt; )
Converts a value of the REAL, STRING, or TIMESTAMP data type into a value of the INTEGER data type.
Type: conversion

TO_LOCALTIME
TO_LOCALTIME( timestamp &lt;TIMESTAMP&gt; )
Converts a timestamp from Universal Time Coordinates (UTC) time into local time.
Type: conversion
TO_LOCALTIME(TO_TIMESTAMP(date, time)) AS [LocalTime]
Create a timestamp from the date and time of a request and convert it to local time.
See also: TO_UTCTIME
TO_LOWERCASE
TO_LOWERCASE( string &lt;STRING&gt; )
Returns a string where all alphabetic characters have been converted to lowercase.
Type: string manipulation

See also: TO_UPPERCASE
TO_REAL
TO_REAL( argument &lt;any type&gt; )
Converts a value of the INTEGER, STRING, or TIMESTAMP data type into a value of the REAL data type.
Type: conversion

TO_STRING
TO_STRING( argument &lt;INTEGER | REAL&gt; ) | ( timestamp &lt;TIMESTAMP&gt;, format &lt;STRING&gt; )
Converts a value of the REAL or INTEGER data type into a value of the STRING data type.
Type: conversion
TO_STRING(TO_LOCALTIME(TO_TIMESTAMP(date, time)), 'yyyy-MM-dd') AS [Day]
Converts the date and time of a request to local time, and then outputs the day as a string (2010-03-22).
TO_TIME
TO_TIME( timestamp &lt;TIMESTAMP&gt; )
Converts a full timestamp into a time-only timestamp.
Type: conversion
TO_TIME(TO_LOCALTIME(QUANTIZE(TO_TIMESTAMP(date, time), 3600))) AS [Hour]
Create a timestamp from the date and time of a request, drops the minutes from the time, converts it to local time, and pulls just the time.
See also: TO_LOCALTIME TO_DATE
TO_TIMESTAMP
TO_TIMESTAMP( dateTime1 &lt;TIMESTAMP&gt;, dateTime2 &lt;TIMESTAMP&gt; ) | ( string &lt;STRING&gt;, format &lt;STRING&gt; ) ( seconds &lt;INTEGER | REAL&gt; )
Parses a string representing a timestamp and returns a value of the TIMESTAMP data type. See also Microsoft Log Parser timestamp formats by James Skemp. There seems to be no difference between using TO_TIMESTAMP() and just TIMESTAMP().
Type: conversion
TO_TIMESTAMP(date, time)
Converts the date and time of a request into a timestamp, for use with other functions.
TO_TIMESTAMP('2009-02-06', 'yyyy-MM-dd')
Creates a timestamp of the date February 6, 2009.
TO_TIMESTAMP('2010-02-15 10:15', 'yyyy-MM-dd HH:mm')
Creates a timestamp of February 25, 2010, at 10:15 in the morning.
TO_TIMESTAMP('24 Jun 2011 13:22:21', 'dd MMM yyyy HH:mm:ss')
Creates a timestamp of a date/time in 'short' format.
TO_UPPERCASE
TO_UPPERCASE( string &lt;STRING&gt; )
Returns a string where all alphabetic characters have been converted to uppercase.
Type: string manipulation

See also: TO_LOWERCASE
TO_UTCTIME
TO_UTCTIME( timestamp &lt;TIMESTAMP&gt; )
Converts a timestamp from local time into Universal Time Coordinates (UTC) time.
Type: conversion

See also: TO_LOCALTIME
TRIM
TRIM( string &lt;STRING&gt; )
Removes whitespace characters from the beginning and end of a string.
Type: string manipulation

See also: LTRIM RTRIM
URLESCAPE
URLESCAPE( url &lt;STRING&gt; [ , codepage &lt;INTEGER&gt; ] )
Converts a string to the URL-encoded form suitable for transmission as an HTTP query string.
Type: string manipulation

See also: URLUNESCAPE
URLUNESCAPE
URLUNESCAPE( url &lt;STRING&gt; [ , codepage &lt;INTEGER&gt; ] )
Converts a URL-encoded string into its plain, unencoded form.
Type: string manipulation

See also: URLESCAPE
WIN32_ERROR_DESCRIPTION
WIN32_ERROR_DESCRIPTION( win32ErrorCode &lt;INTEGER&gt; )
Returns the text message associated with a numeric Windows error code.
Type: miscellaneous</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Query IIS Logs using Logparser via Powershell - example </Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Query IIS Logs using Logparser via Powershell - example </Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

#'Query IIS Logs using Logparser via Powershell
#' https://gallery.technet.microsoft.com/office/Query-IIS-Logs-using-fa66667f



&lt;#
=====================================
Script Created by - Binu Balan      
Script Created on - 11/8/2015
Version - V 1.1
Requirement *
PowerShell = 2.0 or above
This script is used to perform query
Huge IIS Log Files
	 .__.
     (oo)____
     (__)    )\
        ll--ll '
=====================================
#&gt;
cls
Write-Host " "
Write-Host " "
Write-host " AAAAAAAA     PPPPPPPPP    PPPPPPPPP    UUU    UUU" -ForegroundColor Green
Write-host "AAAAAAAAAA    PPP   PPPP   PPP   PPPP   UUU    UUU" -ForegroundColor Green
Write-host "AAA    AAA    PPP    PPP   PPP    PPP   UUU    UUU" -ForegroundColor Green
Write-host "AAAAAAAAAA    PPPPPPPP     PPPPPPPP     UUU    UUU" -ForegroundColor Green
Write-host "AAA    AAA    PPP          PPP          UUU    UUU" -ForegroundColor Green
Write-host "AAA    AAA    PPP          PPP           UUUUUUUU" -ForegroundColor Green
Write-Host " "
Write-Host " " 
Write-host "	           .__." -ForegroundColor Green
Write-host "                   (oo)____" -ForegroundColor Green
Write-host "                   (__)    )\" -ForegroundColor Green
Write-host "                      ll--ll '" -ForegroundColor Green
Write-Host "               SCRIPT BY BINU BALAN               " -ForegroundColor DarkYellow -BackgroundColor DarkBlue 
Write-Host " "
Write-Host " "


$i = 1

# Getting Input from User
# =======================
Write-Host " "
Write-Host " "
Write-Host "Pre-Requisite Check for the Logparser.exe on local path" -NoNewline

Start-Sleep -Seconds 2
If(Test-Path -Path Logparser.exe){
Write-Host "                 [   OK   ]" -ForegroundColor Green
} Else {
Write-Host "                 [ Failed ]" -ForegroundColor Red
Write-Host " "
Write-Host " "
Write-Warning "Either Logparser is not installed or you are running this script on a different folder where Logparser.exe file is unavailable."
Write-Host " "
Write-Host "To download logparser follow this link : " -NoNewline -BackgroundColor Yellow -ForegroundColor Black
Write-Host "http://www.microsoft.com/en-in/download/details.aspx?id=24659" -ForegroundColor Blue -BackgroundColor Yellow
Write-Host " "
exit
}



Write-Host " "
Write-Host " "
$ReportPath = Read-Host "Enter Report Folder Path [Ex: c:\reports] "
$ReportName = Read-Host "Enter the report file name [Ex: LogReport.csv] "
Write-Host " "
Write-Host " "

Write-Host "Select the query type that you want to perform against the log?" -ForegroundColor Yellow
Write-Host "&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt; " -ForegroundColor Blue
Write-Host "1. Date             Example -2014-12-02" -ForegroundColor Green
Write-Host "2. Time             Example -00:00:12" -ForegroundColor Green
Write-Host "3. s-ip             Example -192.168.1.20" -ForegroundColor Green
Write-Host "4. cs-method        Example - GET/POST" -ForegroundColor Green
Write-Host "5. cs-uri-query     Example - /EWS/Exchange.asmx" -ForegroundColor Green
Write-Host "6. s-port           Example -443" -ForegroundColor Green
Write-Host "7. cs-username      Example -appudomain\binu.balan" -ForegroundColor Green
Write-Host "8. c-ip             Example -106.33.98.222" -ForegroundColor Green
Write-Host "9. cs(user-Agent)   Example -Microsoft+office" -ForegroundColor Green
Write-Host "10. sc-status       Example -401" -ForegroundColor Green
Write-Host "11. sc-substatus    Example -1" -ForegroundColor Green
Write-Host "12. sc-win32-status " -ForegroundColor Green
Write-Host "13. time-taken" -ForegroundColor Green
Write-Host " "
Write-Host " "

$GetInput = Read-host "Enter the query number "

switch ($GetInput) 
    { 
        1 {$WhereVal = "Date"} 
        2 {$WhereVal = "Time"} 
        3 {$WhereVal = "s-ip"} 
        4 {$WhereVal = "cs-method"} 
        5 {$WhereVal = "cs-uri-query"} 
        6 {$WhereVal = "s-port"} 
        7 {$WhereVal = "cs-username"} 
        8 {$WhereVal = "c-ip"} 
        9 {$WhereVal = "cs(user-Agent)"} 
        10 {$WhereVal = "sc-status"} 
        11 {$WhereVal = "sc-substatus"} 
        12 {$WhereVal = "sc-win32-status"} 
        13 {$WhereVal = "time-taken"} 

        default {"You have input invalid data !!"}
    }

if ($WhereVal -eq $null) {

Write-Host "You have entered invalid data. Exiting the Script"

exit

}

Write-host "Enter Log folder path. For multiple folders use Comma separated value [Example [C:\Log1,C:\Log2"
$ORRFolderpath = Read-Host "Enter here "

$WhereQuery = Read-Host ("Enter the Query for $WhereVal ")
$EachFolder = $ORRFolderpath.Split(",")
$EachIP = $WhereQuery.Split(",")


#$RName = Read-Host ("Enter Report Name with CSV Extension - (Result.csv)")
#$RPath = Read-Host ("Enter the path where you want to store the report - (C:\Report)")



ForEach ($S_Folder in $EachFolder) {

    ForEach ($IP in $EachIP) {

    $LogPath = $S_Folder
    $FileNames = Get-childItem -Path $LogPath


            ForEach ($File in $FileNames) {

            Write-Host "Script Line $i - .\LogParser.exe SELECT * INTO $ReportPath\$ReportName FROM $LogPath\$File WHERE $WhereVal LIKE '%$IP%' -filemode:0" -ForegroundColor Yellow


            $i = $i + 1

            .\LogParser.exe "SELECT * INTO $ReportPath\$ReportName FROM $LogPath\$File WHERE $WhereVal LIKE '%$IP%'" -filemode:0

            Write-Host "[ Completed ]" -ForegroundColor Green

            Write-Host "    "
            Write-Host "    "

            }


    }

}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Use Logparser and Powershell to produce a single CSV output from IIS logs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Use Logparser and Powershell to produce a single CSV output from IIS logs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://gallery.technet.microsoft.com/office/Use-Logparser-and-59eaa5e5
#' Use Logparser and Powershell to produce a single CSV output from IIS logs

============================
I wanted to combine powershell and logparser to get me a single csv file of user activity on my ASPX website.

The following script acheives that by doing the following

It connects to a root IIS log repository. 
	Although the script looks at a single location, 
	it would be fairly simple to collect the logs from several servers first 
	(renaming them, possibly with the server name appended to give them a unique name) 
My IIS logs are generated fresh each day (the default) 
	so I used the create date to determine what day each log relates to.
I considered a week to be a reasonable block of time to track activity.  
	Therefore, I loop over the list of files and copy them into a week by week folder (named YYYY-WW)
Logparser then comes into action, 
	producing a single csv file for each set of logs for the week (i.e. for each folder)
You can modify the SELECT statement as needed, 
	but I was only interested in who hit which page, 
	where it was in the site and what their average and maximum rendering time was
Logparser will output some paths that I dont want in the report.  
	As my site is a SharePoint site, I'm not interested (in this instance) 
	so I strip them out of the file via the $unwantedPaths parameter.
The prepared files are then grouped into one single output file (Logs.csv) that I can pivot and present in Excel
 

Feel free to change structure and final output to suit your needs 
	- the script should give the basic building blocks to get a decent usage report out quickly.  
	The other advantage is that it will only do work if new data exists.  
	So, if you delete the output directories or files or new logs exist then you'll get new output.

It should go without saying that you'll need to have installed logparser on your machine before running this file.
==================================
Function CopyLogFile ($LogFile, [ref]$FoldersToProcess) { 
 
     
    $YearWeekOfFile = get-date ($LogFile.CreationTime) -UFormat %Y-%V 
    $savePath = Join-Path -Path $weeklyLogRootFolder -ChildPath $YearWeekOfFile 
    CreateFolderIfNotExists $savePath 
     
    $logFileDestinationPath = Join-Path -Path $savePath -ChildPath $LogFile.Name 
     
    if ((Test-Path $logFileDestinationPath) -eq $false) { 
        Copy-Item -Path $LogFile.FullName -Destination $logFileDestinationPath 
        $FoldersToProcess.value += $savePath 
    } 
     
     
} 
Function CreateFolderIfNotExists ($FolderPath) { 
 
    if ((Test-Path $FolderPath) -eq $false) { 
        New-Item -Path $FolderPath -Type Directory 
    } 
 
} 
 
Function PathIsWanted ($RequestPath) { 
    $pathIsWanted = $true 
    foreach($path in $unwantedPaths) { 
        if ($RequestPath -like "$($path)*") { 
            $pathIsWanted = $false 
            break 
        } 
    } 
    $pathIsWanted 
} 
 
#Modify this section with your own values 
 
$rawLogFileRoot = "\\SERVER\c$\inetpub\logs\LogFiles\FOLDER" 
$unwantedPaths = "/_layouts/", "/apps/", "/Lists/", "/_catalogs/", "/_vti_bin/", "/themes", "/Workflow" 
$weeklyLogRootFolder = "C:\temp\logs\" 
$outputCSVLocation = "C:\temp\logs\csvOutput\" 
 
#End of variables to be modified 
 
 
#You may need to modify the exe path of Logparser.exe as well as the SELECT script you wish to run 
#I only wanted aspx pages from my site 
$logParserExe = "C:\Program Files (x86)\Log Parser 2.2\LogParser.exe" 
$logParserSQL =  "`"SELECT '{0}' AS Date, cs-username, STRCAT(EXTRACT_PATH(cs-uri-stem),'/') AS RequestPath, " 
$logParserSQL += "EXTRACT_FILENAME(cs-uri-stem) AS RequestedFile, COUNT(*) AS TotalHits, Max(time-taken) AS MaxTime, " 
$logParserSQL += "AVG(time-taken) AS AvgTime INTO {2} FROM {1}\*.log WHERE cs-username  IS NOT NULL AND " 
$logParserSQL += "SUBSTR(STRREV(EXTRACT_FILENAME(cs-uri-stem)),0,5) = 'xpsa.'   GROUP BY cs-username, cs-uri-stem ORDER BY TotalHits DESC`"" 
#  "STRREV(EXTRACT_FILENAME(cs-uri-stem)),0,5) = 'xpsa.'" gives us aspx pages only 
$logParserParams = "-i:IISW3C" , "-o:CSV" 
 
 
CreateFolderIfNotExists $weeklyLogRootFolder 
CreateFolderIfNotExists $outputCSVLocation 
 
$FoldersToProcess = @() 
 
$rawLogFiles = Get-ChildItem $rawLogFileRoot 
 
 
foreach ($logFile in $rawLogFiles) { 
    CopyLogFile -logFile $logFile -FoldersToProcess ([ref] $FoldersToProcess) 
} 
$FoldersToProcess = $FoldersToProcess | select -uniq 
 
#Log Parsing section 
if ($FoldersToProcess -ne $null) { 
 
    foreach ($folderToProcess in $FoldersToProcess) { 
        $yearWeekName = $folderToProcess.Replace($weeklyLogRootFolder, '') 
        $outputCSV = Join-Path -Path $outputCSVLocation -ChildPath ($yearWeekName + ".csv") 
        $logParserParamsInput = ([string]::Format($logParserSQL, $yearWeekName, $folderToProcess, $outputCSV)), $logParserParams[0], $logParserParams[1] 
         
        Start-Process -NoNewWindow -FilePath $logParserExe -ArgumentList $logParserParamsInput -wait 
 
        #Now process the CSV file - removing unwanted page entries 
        $data = Import-Csv -Path $outputCSV | ?{$unwantedPaths -notcontains $_.RequestPath}  
        $data | Where-Object { (PathIsWanted $_.RequestPath) -eq $true } | Export-CSV -Path $outputCSV -NoTypeInformation 
         
    } 
} 
 
 
$outputFile = $null 
$outputFilePath = Join-Path -Path $outputCSVLocation -ChildPath "Logs.csv" 
 
 
$resultFiles = Get-Childitem $outputCSVLocation  
$firstItem = $true 
if ($resultFiles -ne $null) { 
    foreach ($resultFile in ($resultFiles | ?{$_.Name -ne "Logs.csv"})) { 
        if ($firstItem) { 
            Copy-Item $resultFile.FullName $outputFilePath 
            $firstItem = $false 
        } 
        else { 
            get-content $resultFile.FullName | Select -Skip 1 | Add-Content $outputFilePath 
        } 
    } 
} 
 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>foreach_Switch</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>foreach_Switch</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function ll
{
    param ($dir = ".", $all = $false)
 
    $origFg = $Host.UI.RawUI.ForegroundColor
    if ( $all ) { $toList = ls -force $dir }
    else { $toList = ls $dir }
 
    foreach ($Item in $toList)
    {
        Switch ($Item.Extension)
        {
            ".exe" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".hta" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".cmd" {$Host.UI.RawUI.ForegroundColor="DarkRed"}
            ".ps1" {$Host.UI.RawUI.ForegroundColor="DarkGreen"}
            ".html" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".htm" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".7z" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".zip" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".gz" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".rar" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            Default {$Host.UI.RawUI.ForegroundColor=$origFg}
        }
        if ($item.Mode.StartsWith("d")) {$Host.UI.RawUI.ForegroundColor="Gray"}
        $item
    }
    $Host.UI.RawUI.ForegroundColor = $origFg
} </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Loop_Through_Computers_from_AD_and_Do_something</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Loop_Through_Computers_from_AD_and_Do_something</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

1]-------------------------------------------------

# Import the Active Directory module for the Get-ADComputer CmdLet 
Import-Module ActiveDirectory 
 
# Get today's date for the report 
$today = Get-Date 
 
# Setup email parameters 
$subject = "ACTIVE SERVER SESSIONS REPORT - " + $today 
$priority = "Normal" 
$smtpServer = "Barriere-com.mail.protection.outlook.com" 
$emailFrom = "DoNotReply@barriere.com" 
$emailTo = "glenng@barriere.com" 
 
# Create a fresh variable to collect the results. You can use this to output as desired 
$SessionList = "ACTIVE SERVER SESSIONS REPORT - " + $today + "`n`n" 
 
# Query Active Directory for computers running a Server operating system 
$Servers = Get-ADComputer -Filter {OperatingSystem -like "*server*"} 
 
# Loop through the list to query each server for login sessions 
ForEach ($Server in $Servers) { 
    $ServerName = $Server.Name 
 
    # When running interactively, uncomment the Write-Host line below to show which server is being queried 
    # Write-Host "Querying $ServerName" 
 
    # Run the qwinsta.exe and parse the output 
    $queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "\s+",","))} | ConvertFrom-Csv)  
     
    # Pull the session information from each instance 
    ForEach ($queryResult in $queryResults) { 
        $RDPUser = $queryResult.USERNAME 
        $sessionType = $queryResult.SESSIONNAME 
         
        # We only want to display where a "person" is logged in. Otherwise unused sessions show up as USERNAME as a number 
        If (($RDPUser -match "[a-z]") -and ($RDPUser -ne $NULL)) {  
            # When running interactively, uncomment the Write-Host line below to show the output to screen 
            # Write-Host $ServerName logged in by $RDPUser on $sessionType 
            $SessionList = $SessionList + "`n`n" + $ServerName + " logged in by " + $RDPUser + " on " + $sessionType 
        } 
    } 
} 
 
# Send the report email 
# Send-MailMessage -To $emailTo -Subject $subject -Body $SessionList -SmtpServer $smtpServer -From $emailFrom -Priority $priority 
 
# When running interactively, uncomment the Write-Host line below to see the full list on screen 
$SessionList </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Loop_Through_Records_from_TEXT_file_DoSomething_Export_To_Excel_file</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Loop_Through_Records_from_TEXT_file_DoSomething_Export_To_Excel_file</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'#Loop_Through_Records_from_TEXT_file_DoSomething_Export_To_Excel_file


#### Spreadsheet Location 
 $DirectoryToSaveTo = "c:\" 
 $date=Get-Date -format "yyyy-MM-d" 
 $Filename="Patchinfo-$($patch)" 
 
  
 ###InputLocation 
 $Computers = Get-Content "c:\computers.txt" 
 

  
 
  
# before we do anything else, are we likely to be able to save the file? 
# if the directory doesn't exist, then create it 
if (!(Test-Path -path "$DirectoryToSaveTo")) #create it if not existing 
  { 
  New-Item "$DirectoryToSaveTo" -type directory | out-null 
  } 
   
 
 
#Create a new Excel object using COM  
$Excel = New-Object -ComObject Excel.Application 
$Excel.visible = $True 
$Excel = $Excel.Workbooks.Add() 
$Sheet = $Excel.Worksheets.Item(1) 
 
$sheet.Name = 'Patch status - ' 
#Create a Title for the first worksheet 
$row = 1 
$Column = 1 
$Sheet.Cells.Item($row,$column)= 'Patch status'  
 
$range = $Sheet.Range("a1","f2") 
$range.Merge() | Out-Null 
$range.VerticalAlignment = -4160 
 
#Give it a nice Style so it stands out 
$range.Style = 'Title' 
 
#Increment row for next set of data 
$row++;$row++ 
 
#Save the initial row so it can be used later to create a border 
#Counter variable for rows 
$intRow = $row 
$xlOpenXMLWorkbook=[int]51 
 
#Read thru the contents of the Servers.txt file 
 
$Sheet.Cells.Item($intRow,1)  ="Name" 
$Sheet.Cells.Item($intRow,2)  ="status" 
$Sheet.Cells.Item($intRow,3)  ="Patch status" 
$Sheet.Cells.Item($intRow,4)  ="OS" 
$Sheet.Cells.Item($intRow,5)  ="SystemType" 
$Sheet.Cells.Item($intRow,6)  ="Last Boot Time" 
 
 
for ($col = 1; $col –le 6; $col++) 
     { 
          $Sheet.Cells.Item($intRow,$col).Font.Bold = $True 
          $Sheet.Cells.Item($intRow,$col).Interior.ColorIndex = 48 
          $Sheet.Cells.Item($intRow,$col).Font.ColorIndex = 34 
     } 
 
$intRow++ 
 
 
#Function GetStatusCode 
#{  
#    Param([int] $StatusCode)   
#    switch($StatusCode) 
#    { 
#        0         {"Success"} 
#        11001   {"Buffer Too Small"} 
#        11002   {"Destination Net Unreachable"} 
#        11003   {"Destination Host Unreachable"} 
#        11004   {"Destination Protocol Unreachable"} 
#        11005   {"Destination Port Unreachable"} 
#        11006   {"No Resources"} 
#        11007   {"Bad Option"} 
#        11008   {"Hardware Error"} 
#        11009   {"Packet Too Big"} 
#        11010   {"Request Timed Out"} 
#        11011   {"Bad Request"} 
#        11012   {"Bad Route"} 
#        11013   {"TimeToLive Expired Transit"} 
#        11014   {"TimeToLive Expired Reassembly"} 
#        11015   {"Parameter Problem"} 
#        11016   {"Source Quench"} 
#        11017   {"Option Too Big"} 
#        11018   {"Bad Destination"} 
#        11032   {"Negotiating IPSEC"} 
#        11050   {"General Failure"} 
#        default {"Failed"} 
#    } 
#} 
 
 
 
Function GetUpTime 
{ 
    param([string] $LastBootTime) 
    $Uptime = (Get-Date) - [System.Management.ManagementDateTimeconverter]::ToDateTime($LastBootTime) 
    "Days: $($Uptime.Days); Hours: $($Uptime.Hours); Minutes: $($Uptime.Minutes); Seconds: $($Uptime.Seconds)"  
} 
 
 
foreach ($Computer in $Computers)         
			 {                    #'&lt;===========   Loop Starts
 
				TRY 
					{ 
							$OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer 
							$sheetS = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Computer 
							$date = Get-Date 
					} 
  
				CATCH 
					{ 
							$pcnotfound = "true" 
					} 


				 #### Pump Data to Excel 
				 if ($pcnotfound -eq "true") 
				 { 

				 $sheet.Cells.Item($intRow, 1) = $computer 
				 $sheet.Cells.Item($intRow, 2) = "PC Not Found" 
				 } 
				 else 
				 { 
				 $sheet.Cells.Item($intRow, 1) = $computer 
				 $sheet.Cells.Item($intRow, 2) = $status 
				 $Sheet.Cells.Item($intRow, 3) = $kbinstall 
				 $sheet.Cells.Item($intRow, 4) = $OSRunning 
				 $Sheet.Cells.Item($intRow, 5) = $SystemType 
				 $sheet.Cells.Item($intRow, 6) = $uptime 
				 } 
 
  
				$intRow = $intRow + 1 
				 $pcnotfound = "false" 
			 }                       #'&lt;===========   Loop Ends
 
$erroractionpreference = “SilentlyContinue”  
 
$Sheet.UsedRange.EntireColumn.AutoFit() 
########################################333 
 
 
 
############################################################## 
 
$filename = "$DirectoryToSaveTo$filename.xlsx" 
#if (test-path $filename ) { rm $filename } #delete the file if it already exists 
$Sheet.UsedRange.EntireColumn.AutoFit() 
$Excel.SaveAs($filename, $xlOpenXMLWorkbook) #save as an XML Workbook (xslx) 
$Excel.Saved = $True 
$Excel.Close() 
$Excel.DisplayAlerts = $False 
$Excel.quit()</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Switch</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Switch</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


'EXAMPLE

function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[string]$VMName
	)
	
    switch ($VMName) {  										 
        'SQLInjectAttackName' {													&lt;===== So if VMName = 'SQLInjectAttackName'
            Write-Error -Message "OMG! Someone's trying to H@x0r our base!"		'Then do this
        }

        'AlreadyExists' {
            Write-Warning -Message "You got a problem. This VM already exists so you can't add it, dummy"
        }

        'DoesNotExistAlready' {
            Write-Verbose -Message 'The VM does not already exist. You may proceed to add a new one with that name'
        }

        'FlakyIssue' {
            $ThatVariable = 'notright'
            Write-Debug -Message 'I will add this VM on host 123, blade 4564 on the molecule H2S squared'
        }
    }
}

/////////////////////////////////////////////////////////////


# Switch statement for multiple conditions
Clear-Host
$var = 42                   # Also test with 43 and 49
switch  ($var)
{
  41 {"Forty One"}
  42 {"Forty Two"}
  43 {"Forty Three"}
  default {"default"}
}



# Will match all lines that match
Clear-Host
$var = 42
switch  ($var)
{
  42 {"Forty Two"}
  "42" {"Forty Two String"}
  default {"default"}
}
# Note type coercion will cause both 42 lines to have a match


# To stop processing once a block is found use break
# The semicolon (;) let's you put more than one command on the line
# the "break" ends processing within the brackets, or script block, and jumps to the code right after the brackets
Clear-Host
$var = 42
switch  ($var)
{
  42 {"Forty Two - 1"; break}
  42 {"Forty Two - 2"             #You can break the previous line into multiple lines w/out semicolons as well
       break
       }
  "42" {"Forty Two String"; break}
  default {"default"}
}
# Note, if you want to put multiple commands on a single line, use a ; to separate them


# Switch works with collections, looping and executing for each match
Clear-Host
switch (3,1,2,42)       # So it will go through the options for each item in this collection, and produce results for each.
{
  1 {"One"}
  2 {"Two"}
  3 {"Three"}
  default {"The default answer"}
}


# String compares are case insensitive by default
Clear-Host
switch ("PowerShell")
{
  "powershell" {"lowercase"}
  "POWERSHELL" {"uppercase"}
  "PowerShell" {"mixedcase"}
}



# Use the -casesenstive switch to make it so
Clear-Host
switch -casesensitive ("PowerShell")
{
  "powershell" {"lowercase"}
  "POWERSHELL" {"uppercase"}
  "PowerShell" {"mixedcase"}
}


# Supports wildcards
Clear-Host
switch -Wildcard ("Pluralsight")
{
  "plural*" {"*"}
  "?luralsight" {"?"}
  "Pluralsi???" {"???"}
}

# Note it will also support regex matches

#endregion Logic Branching

##
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>C#_in_Function</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>C#_in_Function</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>' Here's a script that many of my "profiles" depend on. 
'It allows calls to web services that use self signed SSL for ad hoc exploration of web services in development. 
'Yes, I freely mix C# in my powershell scripts.


# Using a target web service that requires SSL, but server is self-signed.  
# Without this, we'll fail unable to establish trust relationship. 
function Set-CertificateValidationCallback
{
    try
    {
       Add-Type @'
    using System;

    public static class CertificateAcceptor{

        public static void SetAccept()
        {
            System.Net.ServicePointManager.ServerCertificateValidationCallback = AcceptCertificate;
        }

        private static bool AcceptCertificate(Object sender,
                        System.Security.Cryptography.X509Certificates.X509Certificate certificate,
                        System.Security.Cryptography.X509Certificates.X509Chain chain,
                        System.Net.Security.SslPolicyErrors policyErrors)
            {
                Console.WriteLine("Accepting certificate and ignoring any SSL errors.");
                return true;
            }
    }
'@
    }
    catch {} # Already exists? Find a better way to check.

     [CertificateAcceptor]::SetAccept()
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_cmdlet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_cmdlet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://techibee.com/powershell/powershell-get-ip-address-subnet-gateway-dns-serves-and-mac-address-details-of-remote-computer/1367

'You can save this script to a PS1 fil(say Get-IPDetails.PS1) and run it against list of computers you need. Below is one example.

'USAGE
&gt; .\Get-IPDetails.ps1 -ComputerName MyPC1 | ft - Autosize




=======================================================================

[cmdletbinding()]            
param (            
 [parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]            
    [string[]]$ComputerName = $env:computername            
)                        
            
begin {}            
process {            
 foreach ($Computer in $ComputerName) {            
  if(Test-Connection -ComputerName $Computer -Count 1 -ea 0) {            
   try {            
    $Networks = Get-WmiObject Win32_NetworkAdapterConfiguration -ComputerName $Computer -EA Stop | ? {$_.IPEnabled}            
   } catch {            
        Write-Warning "Error occurred while querying $computer."            
        Continue            
   }            
   foreach ($Network in $Networks) {            
    $IPAddress  = $Network.IpAddress[0]            
    $SubnetMask  = $Network.IPSubnet[0]            
    $DefaultGateway = $Network.DefaultIPGateway            
    $DNSServers  = $Network.DNSServerSearchOrder            
    $IsDHCPEnabled = $false            
    If($network.DHCPEnabled) {            
     $IsDHCPEnabled = $true            
    }            
    $MACAddress  = $Network.MACAddress            
    $OutputObj  = New-Object -Type PSObject            
    $OutputObj | Add-Member -MemberType NoteProperty -Name ComputerName -Value $Computer.ToUpper()            
    $OutputObj | Add-Member -MemberType NoteProperty -Name IPAddress -Value $IPAddress            
    $OutputObj | Add-Member -MemberType NoteProperty -Name SubnetMask -Value $SubnetMask            
    $OutputObj | Add-Member -MemberType NoteProperty -Name Gateway -Value $DefaultGateway            
    $OutputObj | Add-Member -MemberType NoteProperty -Name IsDHCPEnabled -Value $IsDHCPEnabled            
    $OutputObj | Add-Member -MemberType NoteProperty -Name DNSServers -Value $DNSServers            
    $OutputObj | Add-Member -MemberType NoteProperty -Name MACAddress -Value $MACAddress            
    $OutputObj            
   }            
  }            
 }            
}            
            
end {}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Hosts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Hosts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Host									$Host.Name					$ShellId				HostId
====                                    ==========                  ===========				================
PowerShell								ConsoleHost					Microsoft.PowerShell	Microsoft.PowerShell
PowerShell ISE							Windows PowerShell ISE Host	Microsoft.PowerShell	Microsoft.PowerShellISE
Visual Studio Package Manager Console	Package Manager Host		Microsoft.PowerShell	NuGet

'Other PowerShell hosts could potentially have different $ShellId values 
'(for example, some of the freely available PowerShell IDEs include 
'PowerGUI, PowerShell Analyzer, and PowerShell Plus</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Interating_over_Objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Interating_over_Objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'there are 2 methods for iterating thru objects and are often confused:

ForEach-Object cmdlet and its aliases foreach and %.

foreach( in ){} statement.

'As you can see the main reason for the confusion is that Foreach-Object has an alias of foreach which can be confused with the statement. 
'Each method will take a collection and process the objects in a Scriptblock but each behaves differently, 
'however and its use will vary case by case.

=======================================================================================================
'The ForEach-Object 
'	cmdlet takes a stream of objects from the pipeline 
'	and processes each and it uses less memory do to garbage control, 
'	as objects gets processed and they are passed thru the pipeline they get removed from memory. 
'	The cmdlet takes 4 main parameters:

Begin &lt;Script block&gt; 		'executed before processing all objects
Process &lt;Script block&gt; 		'executed per each object being processed
End &lt;Script block &gt; 		'to be executed after all objects have been processing all objects.
InputObject &lt;PSObject&gt; 		'to take actions against. Typically this is taken thru the pipeline.

'The ScriptBlocks parameters are also positional

PS C:\&gt; 1..5 | ForEach-Object { $Sum = 0 } { $Sum += $_ } { $Sum } 
15 


'To skip to the next object to be process in ForEach-Object the keyword Continue is used. 
'For exiting the loop inside of a ForEach-Object the break keyword is used.

C:\PS&gt; $Numbers = 4..7 
C:\PS&gt; 1..10 | foreach-object { if ($Numbers -contains $_) { continue }; $_ } 
1 
2 
3 


=======================================================================================================
'The foreach( in ){} statement 
'	places on each iteration an element of a collection in to memory first and then processes each. 
'	(Not good for extremely large collections on memory constrained systems). 
'	Since the collection being worked on is loaded in to memory it tends to be faster than the ForEach-Object cmdlet.

'To skip to the next object to be process in foreach statement the keyword continue is used. 
'	For exiting the loop inside of a foreach statement the break keyword is used.

'The foreach statement has a special variable called $foreach 
'	with 2 special methods that can be used: 
'	
'	$foreach.MoveNext() to skip to the next element in the collection 
'		and continue to process the next element in the collection.
'		Returns a Boolean true value that should be handled.
'	$foreach.Current to represent the current element being processed

PS &gt;foreach ($i in (1..10)){ 
&gt;&gt;    if ($i -gt 5){ 
&gt;&gt;        continue 
&gt;&gt;    } 
&gt;&gt;    $i 
&gt;&gt; } 
&gt;&gt;
1 
2 
3 
4 
5</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Patch_Query_list_of_Computers_to_see_if_a_patch_is_installed</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Patch_Query_list_of_Computers_to_see_if_a_patch_is_installed</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://gallery.technet.microsoft.com/scriptcenter/Powershell-Query-a-patch-67cf35f8

#'The script uses GET-HOTFIX powershell cmdlet to query local or remote computers 
#'    to gather the patch/hotfix state either installed or missing on the list of servers based on the KB number. 
#'    It also queries and reports other basic OS details like OS version, system type , ping connectivity check and last boot time etc. 
#'These information is consolidate and saved into excel format to provide better human readable format.
#'
#' 
#'
#'The script, by default reads the list of servers from "C:\Computers.txt" , prompts for user input for kb number and saves the generated excel report to "C:\patchinfo*.xlsx"
#'
#'It doesn't overwrite the file automatically if the file exist by the name to avoid accidental deletion.
#'
#'The computer on which the script is run should have excel 2007 or later installed.


  
#### Spreadsheet Location 
 $DirectoryToSaveTo = "c:\" 
 $date=Get-Date -format "yyyy-MM-d" 
 $Filename="Patchinfo-$($patch)" 
 
  
 ###InputLocation 
 $Computers = Get-Content "c:\computers.txt" 
 # Enter KB to be checked here 
 $Patch = Read-Host 'Enter the KB number ? - eg: KB3011780 ' 
  
 
  
# before we do anything else, are we likely to be able to save the file? 
# if the directory doesn't exist, then create it 
if (!(Test-Path -path "$DirectoryToSaveTo")) #create it if not existing 
  { 
  New-Item "$DirectoryToSaveTo" -type directory | out-null 
  } 
   
 
 
#Create a new Excel object using COM  
$Excel = New-Object -ComObject Excel.Application 
$Excel.visible = $True 
$Excel = $Excel.Workbooks.Add() 
$Sheet = $Excel.Worksheets.Item(1) 
 
$sheet.Name = 'Patch status - ' 
#Create a Title for the first worksheet 
$row = 1 
$Column = 1 
$Sheet.Cells.Item($row,$column)= 'Patch status'  
 
$range = $Sheet.Range("a1","f2") 
$range.Merge() | Out-Null 
$range.VerticalAlignment = -4160 
 
#Give it a nice Style so it stands out 
$range.Style = 'Title' 
 
#Increment row for next set of data 
$row++;$row++ 
 
#Save the initial row so it can be used later to create a border 
#Counter variable for rows 
$intRow = $row 
$xlOpenXMLWorkbook=[int]51 
 
#Read thru the contents of the Servers.txt file 
 
$Sheet.Cells.Item($intRow,1)  ="Name" 
$Sheet.Cells.Item($intRow,2)  ="status" 
$Sheet.Cells.Item($intRow,3)  ="Patch status" 
$Sheet.Cells.Item($intRow,4)  ="OS" 
$Sheet.Cells.Item($intRow,5)  ="SystemType" 
$Sheet.Cells.Item($intRow,6)  ="Last Boot Time" 
 
 
for ($col = 1; $col –le 6; $col++) 
     { 
          $Sheet.Cells.Item($intRow,$col).Font.Bold = $True 
          $Sheet.Cells.Item($intRow,$col).Interior.ColorIndex = 48 
          $Sheet.Cells.Item($intRow,$col).Font.ColorIndex = 34 
     } 
 
$intRow++ 
 
 
Function GetStatusCode 
{  
    Param([int] $StatusCode)   
    switch($StatusCode) 
    { 
        0         {"Success"} 
        11001   {"Buffer Too Small"} 
        11002   {"Destination Net Unreachable"} 
        11003   {"Destination Host Unreachable"} 
        11004   {"Destination Protocol Unreachable"} 
        11005   {"Destination Port Unreachable"} 
        11006   {"No Resources"} 
        11007   {"Bad Option"} 
        11008   {"Hardware Error"} 
        11009   {"Packet Too Big"} 
        11010   {"Request Timed Out"} 
        11011   {"Bad Request"} 
        11012   {"Bad Route"} 
        11013   {"TimeToLive Expired Transit"} 
        11014   {"TimeToLive Expired Reassembly"} 
        11015   {"Parameter Problem"} 
        11016   {"Source Quench"} 
        11017   {"Option Too Big"} 
        11018   {"Bad Destination"} 
        11032   {"Negotiating IPSEC"} 
        11050   {"General Failure"} 
        default {"Failed"} 
    } 
} 
 
 
 
Function GetUpTime 
{ 
    param([string] $LastBootTime) 
    $Uptime = (Get-Date) - [System.Management.ManagementDateTimeconverter]::ToDateTime($LastBootTime) 
    "Days: $($Uptime.Days); Hours: $($Uptime.Hours); Minutes: $($Uptime.Minutes); Seconds: $($Uptime.Seconds)"  
} 
 
 
foreach ($Computer in $Computers) 
 { 
 
 TRY { 
 $OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer 
 $sheetS = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Computer 
 $sheetPU = Get-WmiObject -Class Win32_Processor -ComputerName $Computer 
 $drives = Get-WmiObject -ComputerName $Computer Win32_LogicalDisk | Where-Object {$_.DriveType -eq 3} 
 $pingStatus = Get-WmiObject -Query "Select * from win32_PingStatus where Address='$Computer'" 
 $OSRunning = $OS.caption + " " + $OS.OSArchitecture + " SP " + $OS.ServicePackMajorVersion 
 $systemType=$sheetS.SystemType 
 $date = Get-Date 
 $uptime = $OS.ConvertToDateTime($OS.lastbootuptime) 
   
 if  
 ($kb=get-hotfix -id $Patch -ComputerName $computer -ErrorAction 2) 
 
 { 
 $kbinstall="$patch is installed" 
 } 
 else 
 { 
 $kbinstall="$patch is not installed" 
 } 
 
  
  
 if($pingStatus.StatusCode -eq 0) 
    { 
        $Status = GetStatusCode( $pingStatus.StatusCode ) 
    } 
else 
    { 
    $Status = GetStatusCode( $pingStatus.StatusCode ) 
       } 
 } 
  
 CATCH 
 { 
 $pcnotfound = "true" 
 } 
 #### Pump Data to Excel 
 if ($pcnotfound -eq "true") 
 { 
 #$sheet.Cells.Item($intRow, 1) = "PC Not Found" 
 $sheet.Cells.Item($intRow, 1) = $computer 
 $sheet.Cells.Item($intRow, 2) = "PC Not Found" 
 } 
 else 
 { 
 $sheet.Cells.Item($intRow, 1) = $computer 
 $sheet.Cells.Item($intRow, 2) = $status 
 $Sheet.Cells.Item($intRow, 3) = $kbinstall 
 $sheet.Cells.Item($intRow, 4) = $OSRunning 
 $Sheet.Cells.Item($intRow, 5) = $SystemType 
 $sheet.Cells.Item($intRow, 6) = $uptime 
 } 
 
  
$intRow = $intRow + 1 
 $pcnotfound = "false" 
 } 
 
$erroractionpreference = “SilentlyContinue”  
 
$Sheet.UsedRange.EntireColumn.AutoFit() 
########################################333 
 
 
 
############################################################## 
 
$filename = "$DirectoryToSaveTo$filename.xlsx" 
#if (test-path $filename ) { rm $filename } #delete the file if it already exists 
$Sheet.UsedRange.EntireColumn.AutoFit() 
$Excel.SaveAs($filename, $xlOpenXMLWorkbook) #save as an XML Workbook (xslx) 
$Excel.Saved = $True 
$Excel.Close() 
$Excel.DisplayAlerts = $False 
$Excel.quit() </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>RESTART_REMOTE_computers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>RESTART_REMOTE_computers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://community.spiceworks.com/topic/1981643-remote-restart-from-txt-file-listing-computers
'https://mcpmag.com/articles/2012/04/10/how-to-restart-computers-remotely-via-powershell.aspx

$YourFile = Get-Content 'C:\users\joe\desktop\computers.txt'

foreach ($computer in $YourFile)
{

Restart-Computer -ComputerName $computer -force

}










https://mcpmag.com/articles/2012/04/10/how-to-restart-computers-remotely-via-powershell.aspx
https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/restart-computer?view=powershell-5.1
'you could shut down a list of computers:
&gt; restart-computer "server01","server02","server03" -whatif

'Because the cmdlet is using WMI objects and methods under the hood you can specify alternate credentials, either a saved credential object or a user name:
&gt; restart-computer (get-content c:\work\computers.txt) -credential "mycompany\administrator"
'I'll get prompted for the password, but then this credential will be used for every computer in the list.

'The Restart-Computer cmdlet will fail, if a logon session is detected. 
'PowerShell will raise an exception. However, you can force a reboot using -- what else? -- 
'the -force parameter. Be aware this will force applications to close 
'with the potential loss of unsaved work.
--------------------------------------------
'Another option for rebooting or even logging off 

&gt; Get-WmiObject win32_operatingsystem -ComputerName Quark | Invoke-WMIMethod -name Win32Shutdown
--------------------------------------------
'The Win32Shutdown method can accept parameters. 
'The default is 0 which means do a simple logoff. But if the user has open files 
'or if the default method fails, you can always resort to a forceful logoff:

&gt; Get-WmiObject win32_operatingsystem -ComputerName Quark | Invoke-WMIMethod -name Win32Shutdown -ArgumentList @(4)
--------------------------------------------
'Restart several computers including the local computer
Restart-Computer -ComputerName "Server01", "Server02", "localhost"

--------------------------------------------
'Restart computers as a background job

'The first command uses the *AsJob* parameter to run the command as a background job. 
'The command stores the resulting job object in the $j variable.
&gt; $j = Restart-Computer -ComputerName "Server01", "Server02" -AsJob

'The second command uses a pipeline operator to send the job object in $j to the Receive-Job cmdlet, 
'which gets the job results. The command stores the results in the $Results variable.
&gt; $Results = $j | Receive-Job

'The third command displays the result stores in the $Results variable.Because *AsJob* creates the job 
'on the local computer and automatically returns the results to the local computer, 
'you can run **Receive-Job** as a local command.
PS C:\&gt; $Results
--------------------------------------------

' Restart a remote computer
&gt;Restart-Computer -ComputerName "Server01" -Impersonation Anonymous -Authentication PacketIntegrity

-------------------------------------------

'Force restart of all computers from a list

'The first command uses the Get-Content cmdlet to get a list of computers in the domain 
'	from the Domain01.txt file. It stores the list in the $s variable.
PS C:\&gt; $s = Get-Content Domain01.txt

'The second command gets the credentials of a domain administrator and stores them in the $c variable.
PS C:\&gt; $c = Get-Credential Domain01\Admin01

'The third command restarts the computers. 
'It uses the *ComputerName* parameter to submit the list of computers in the $s variable, 
'the *Force* parameter to force an immediate restart, 
'and the *Credential* parameter to submit the credentials saved in the $c variable. It also uses the *ThrottleLimit* parameter to limit the command to 10 concurrent connections.
PS C:\&gt; Restart-Computer -ComputerName $s -Force -ThrottleLimit 10 -Credential $c


--------------------------------------------------

'Restart a computer by using WSMan, instead of DCOM, which is the default.
&gt;Restart-Computer -ComputerName "Server01" -Protocol WSMan -WSManAuthentication Kerberos</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Selecting_Objects</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Selecting_Objects</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

'The Select-Object cmdlets allows us to select from a collection of objects the ones we want when we specify the index position of the item. 
'Just like all programing languages we start our count with 0.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -Index 0,1,2,3,4 

'The Select-Object cmdlets allows us to select from a collection of objects the ones we want when we specify the index position of the item. 
'	Just like all programing languages we start our count with 0.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -Index 0,1,2,3,4 

'We can also use the range notation, 
'	this will return an array of number for the range and we can pass those to the index parameter.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -Index (0..4)

'Select the first number of objects, the last number of objects or even skip a certain number.

PS &gt; Get-Process | Sort-Object name -Descending | Select-Object -first 5 

'The select-object cmdlets also allows us to create and rename an objects property, 
'	this is very useful when the property name is not to descriptive and when we are passing from one comdlet to another 
'	where the next cmdlet accepts and processes objects by Property Name. 
'	The way it works is that we create a hash with 2 values in it, 
'	one is Name which is the name we want for the property and the other is expressions 
'	which is a script block whose returning value will be set as the value of the property we named.

PS &gt; Get-Process | Select-Object -Property name,@{name = 'PID'; expression = {$_.id}} 				'&lt;== NOT CLEAR where the renameing is being done

'One thing that we have to be very careful with when using Select-Object 
'	is that when we select property names using it actually generates a new object 
'	of the same type with only those properties that we selected and strips out the rest. </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Uninstall_Windows_10_Built-in_Apps</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Uninstall_Windows_10_Built-in_Apps</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://www.howtogeek.com/224798/how-to-uninstall-windows-10s-built-in-apps-and-how-to-reinstall-them/


Uninstall 3D Builder:
Get-AppxPackage *3dbuilder* | Remove-AppxPackage
Uninstall Alarms and Clock:
Get-AppxPackage *windowsalarms* | Remove-AppxPackage
Uninstall Calculator:
Get-AppxPackage *windowscalculator* | Remove-AppxPackage
Uninstall Calendar and Mail:
Get-AppxPackage *windowscommunicationsapps* | Remove-AppxPackage
Uninstall Camera:
Get-AppxPackage *windowscamera* | Remove-AppxPackage
Uninstall Contact Support:
This app can’t be removed.
Uninstall Cortana:
This app can’t be removed.
Uninstall Get Office:
Get-AppxPackage *officehub* | Remove-AppxPackage
Uninstall Get Skype:
Get-AppxPackage *skypeapp* | Remove-AppxPackage
Uninstall Get Started:
Get-AppxPackage *getstarted* | Remove-AppxPackage
Uninstall Groove Music:
Get-AppxPackage *zunemusic* | Remove-AppxPackage
Uninstall Maps:
Get-AppxPackage *windowsmaps* | Remove-AppxPackage
Uninstall Microsoft Edge:
This app can’t be removed.
Uninstall Microsoft Solitaire Collection:
Get-AppxPackage *solitairecollection* | Remove-AppxPackage
Uninstall Money:
Get-AppxPackage *bingfinance* | Remove-AppxPackage
Uninstall Movies &amp; TV:
Get-AppxPackage *zunevideo* | Remove-AppxPackage
Uninstall News:
Get-AppxPackage *bingnews* | Remove-AppxPackage
Uninstall OneNote:
Get-AppxPackage *onenote* | Remove-AppxPackage
Uninstall People:
Get-AppxPackage *people* | Remove-AppxPackage
Uninstall Phone Companion:
Get-AppxPackage *windowsphone* | Remove-AppxPackage
Uninstall Photos:
Get-AppxPackage *photos* | Remove-AppxPackage
Uninstall Store:
Get-AppxPackage *windowsstore* | Remove-AppxPackage
Uninstall Sports:
Get-AppxPackage *bingsports* | Remove-AppxPackage
Uninstall Voice Recorder:
Get-AppxPackage *soundrecorder* | Remove-AppxPackage
Uninstall Weather:
Get-AppxPackage *bingweather* | Remove-AppxPackage
Uninstall Windows Feedback:
This app can’t be removed.
Uninstall Xbox:
Get-AppxPackage *xboxapp* | Remove-AppxPackage



How to Reinstall All Built-in Apps
If you decide you want the preinstalled apps back, you can get them back with a single line of PowerShell code. Again, open a PowerShell window as Administrator. Copy and paste the following line into the PowerShell window and press Enter:
Get-AppxPackage -AllUsers| Foreach {Add-AppxPackage -DisableDevelopmentMode -Register “$($_.InstallLocation)\AppXManifest.xml”}

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Version?</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Version?</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Get-Host
 $PSVersionTable                   #'&lt;=====  just need this to get the version
 
 
 PowerShell v2 –Included with Windows 7 and Windows 2008 R2. 
 
 PowerShell v3 – Included with Windows 8 and Windows 2012. Available as a separate download for Windows 7 SP1 and Windows 2008 R2 SP2.
 Download http://www.microsoft.com/en-us/download/details.aspx?id=34595
 it points to: Windows Management Framework 3.0
 
 To install Windows Management Framework 3.0:
Download the correct package for your operating system and architecture.
Windows 7 Service Pack 1
64-bit versions: Windows6.1-KB2506143-x64.msu
32-bit versions: Windows6.1-KB2506143-x86.msu


===============================v 5.0
https://www.microsoft.com/en-us/download/details.aspx?id=50395
===============================

===============================v 4.0
https://www.microsoft.com/en-us/download/details.aspx?id=40855
Top prepare
1] To prepare for installation of Windows Management Framework 4.0:
Download the correct package for your operating system and architecture. The following architectures are supported.
Windows 7 SP1
x64: Windows6.1-KB2819745-x64-MultiPkg.msu
x86: Windows6.1-KB2819745-x86.msu
Windows Server 2008 R2 SP1
x64: Windows6.1-KB2819745-x64-MultiPkg.msu
Windows Server 2012
x64: Windows8-RT-KB2799888-x64.msu
2] Close all Windows PowerShell windows.
3] Uninstall any other copies of Windows Management Framework 4.0, including any prerelease copies or copies in other languages.
===============================0
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Write-Host</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Write-Host</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Write-Host "This is a message"

Write-Host "This is red text on a yellow background" -foregroundcolor red -backgroundcolor yellow



'Here are the colors you can use with the -foregroundcolor and -backgroundcolor parameters:
Black
DarkBlue
DarkGreen
DarkCyan
DarkRed
DarkMagenta
DarkYellow
Gray
DarkGray
Blue
Green
Cyan
Red
Magenta
Yellow
White

Write-Host "Data for " -nonewline; Write-Host "atl-ws-01" -foregroundcolor red -backgroundcolor yellow -nonewline; Write-Host " retrieved May 12, 2006"

'-nonewline. As the name implies, -nonewline causes the cursor to stay on the current line.
'by default, any time you call write-Host it tacks a carriage-return linefeed on the end, 
'	causing the cursor to drop to the next line in the console window. 
'	However, by using -nonewline we leave the cursor in place; 
'	that enables us to call Write-Host a second time (separating the individual calls using a semi-colon). 
'	This time around we write the name of the computer, but we also do the red-text-on-a-yellow-background thing. 
'	We add a semi-colon and then call Write-Host a third time, 
'	this time writing the phrase retrieved May 12, 2006 in regular text.
============================================================================================
'To write:         42 - Slim Shady - Eminem

$assoc = New-Object psobject -Property @{
    Id = 42
    Name = "Slim Shady"
    Owner = "Eminem"
}

Write-Host "$($assoc.Id) - $($assoc.Name) - $($assoc.Owner)"
'or
Write-host  ("{0}  -  {1}  -  {2}" -f $assoc.Id,$assoc.Name,$assoc.Owner )
'or
Write-host $assoc.Id  "  -  "   $assoc.Name  "  -  "  $assoc.Owner
'or wrapped in parenthesis
Write-host ($assoc.Id + "  -  "  + $assoc.Name + "  -  " + $assoc.Owner)
'or
	$string = $assoc.ID
	$string += " - "
	$string += $assoc.Name
	$string += " - "
	$string += $assoc.Owner
	Write-Host $string

============================================================================================
'SINGLE vs DOUBLE QOUTES

$name = 'Slim Shady'
Write-Host 'My name is'$name
-&gt; My name is Slim Shady

'Or you can do this:

$name = 'Slim Shady'
Write-Host "My name is $name"
-&gt; My name is Slim Shady

'The single quotes are for literal, output the string exactly like this, please. 
'The double quotes are for when you want some pre-processing done (such as variables, special characters etc)

'So:

$name = "Marshall Bruce Mathers III"
Write-Host "$name"
-&gt; Marshall Bruce Mathers III

'Whereas:

$name = "Marshall Bruce Mathers III"
Write-Host '$name'
-&gt; $name
============================================================================================
'To concatenate two strings to store in a variable/use in a function, you can use -join.
$name = -join("Jo", "h", "n");

'Would assign "John" to $name.
'So to output, in one line:

Write-Host (-join("Jo", "h", "n"))</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Modules</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Modules</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Modules</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Modules</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Modules  (.psm1)

'Good Source of scripts:
	http://technet.microsoft.com/scriptcenter
	http://www.codeplex.com/

'NOTE: the name of the parent folder MUST be the same as the Module name.

'Modules - A package that contains Windows PowerShell commands in the form of functions, 
'	cmdlerts and workflows, in addition it may contain variables, aliases and providers. 
'	Modules can be written in PowerShell and/or compiled as DLLs.

'============================================================================
'To load a module to memory you can use:

$modulePath = 'C:\PS\Beginning PowerShell Scripting for Developers\demo\'
$moduleName = 'bpsd-m05-module-simple'

$module = "$($modulePath)$($moduleName).psm1"

# To use a module, you first need to import it, which runs all the code in the module
# so now the functions in the modules are in memory
Import-Module $module

'BUT if you change the module and try to re-import it the changes will not take affect
'	b/c it loads a module only once
' SO use this in DEVELOPMENT

# Because the module is already loaded, by default PS won't reload
# To force it to reload, you have to use the -Force switch
Import-Module -Force $module
'============================================================================
#' Remove a module from memory (note just used the module name, not the whole path :
Remove-Module $moduleName

#' IF your module is located in one of the module paths of the env variable you can still call one of it's functions
#'	WITHOUT explicitly importing the module that contains the function
#'  BUT if the module file is NOT located in one of the paths of your environment variable 
#'  THEN you do need to explicitly import the module to invoke it's functions




'============================================================================
'Modules have primarily 2 locations on your system:

%windir%\system32\WindowsPowerShell\v1.0\Modules 		'this is the location for system wide modules available to any user in the system.
%USERPROFILE%\Documents\WindowsPowerShell\Modules

'Each module is stored in a folder where there is a psd1 file that is known as a Module Manifest, 
'	this manifest has the settings for the module and sets the restrictions for it in terms of .Net Framework version, 
'	version of PowerShell, files to load, version, copyright, author and many other settings. 
'	This file can load what is called a main module and sub-modules each can either be a psm1 or dll file, 
'	in addition they can also be scripts that gets processes. 

'We can also have modules in other locations that can be accessed by the PowerShell session we run in, 
'	the locations are defined in the environment variable $env:PSModulePath

C:\&gt; $env:PSModulePath

C:\Users\Carlos\Documents\WindowsPowerShell\Modules;C:\Windows\system32\WindowsPowerShell\v1.0\Modules\

'If we want to add another path for PowerShell to look at we just add that path to the current environment variable:

$env:psmodulepath = $env:psmodulepath + ";"

'To list the modules that are available we use the Get-Module cmdlet withe the -listavailable parameter:

Get-Module -ListAvailable

'If you only want to see the modules that are currently loaded in to the session the -All parameter is used with Get-Module:

C:\&gt; Get-Module -All

'To import a module in to our session we just use the Import-Module cmdlet and give it the name of the module. 

&gt;  Import-Module -Name Posh-SSH -Verbose

' If you are in a session and want to know if a module is loaded the Get-Module cmndlet with the -Name option 
'	is use and we give it the module name we want to know about, 
'	if it returns the information about the module the module is loaded, if nothing is returned the module is not:

C:\&gt; Get-Module -Name posh-ssh

'To remove the module from our session we use the Remove-Module cmdlet and give it the name of the module we want to remove:

C:\&gt; Remove-Module -Name posh-ssh -Verbose

' We can also load modules by calling directly the DLL or the PSM1 file, 
'lets call another module I'm still developing for controlling Metasploit:

C:\&gt; Import-Module C:\Users\Carlos\Desktop\Posh-Metasploit.psm1 -Verbose

'If you are developing a module and whant to reload the module with the changes you just made 
'	I recommend just using the Import-Module cmdlet with the -Force parameter instead of removing and importing the module again. 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_List_Features_Roles__local_server.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_List_Features_Roles__local_server.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Import-Module ServerManager
$Arr = Get-WindowsFeature | Where-Object {$_.Installed -match “True”} | Select-Object -Property Name
$loopCount = $Arr.Count
For($i=0; $i -le $loopCount; $i++) {
    Write-Host $Arr[$i]
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Computer_Age</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Computer_Age</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://community.spiceworks.com/topic/932043-powershell-computer-age


$Computer='IT-3023'

    $System = Get-WmiObject -ComputerName $Computer -Query "SELECT * FROM Win32_SystemEnclosure" -Namespace "root\CIMV2"
	$ComputerSystem = Get-WmiObject -ComputerName $Computer -Class Win32_ComputerSystem
	$BIOS = Get-WmiObject -ComputerName $Computer -Class Win32_BIOS
	$BIOSageInYears = (New-TimeSpan -Start ($BIOS.ConvertToDateTime($BIOS.releasedate).ToShortDateString()) -End $(Get-Date)).Days / 365
	$OperatingSystem = Get-WmiObject -ComputerName $Computer -Class Win32_OperatingSystem
	$OSInstallDate = ($OperatingSystem.ConvertToDateTime($OperatingSystem.InstallDate).ToShortDateString())
	New-Object -TypeName PSObject -Property @{
		Computer = $Computer
		SerialNumber = $System.SerialNumber
		Manufacturer = $ComputerSystem.Manufacturer
		Model = $ComputerSystem.Model
		BIOSreleaseDate = ($BIOS.ConvertToDateTime($BIOS.releasedate).ToShortDateString())
		BIOSageInYears = $BIOSageInYears
		$OSInstallDate = $OSInstallDate
        }

-------------------------------------------------------------------------
#'This will read from a list in a file:
--------------------------------------------------------------------------
### HTML Header	
$Header = @"
&lt;center&gt;
	&lt;style&gt;
		TABLE {border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;margin-left: auto;margin-right: auto;}
		TH {border-width: 1px;padding: 3px;border-style: solid;border-color: black;background-color: #808080;}
		TD {border-width: 1px;padding: 3px;border-style: solid;border-color: black;}
		.odd  { background-color:#ffffff; }
		.even { background-color:#dddddd; }
	&lt;/style&gt;
&lt;/center&gt;
&lt;title&gt;
	Computer Information Report
&lt;/title&gt;
"@
$Computers = Get-Content 'computers.txt';
#' or from AD
#'$Computers = Get-ADComputer -Filter { OperatingSystem -Like "*Windows*" } -Property Name,WhenCreated

$Results = ForEach ($computer in ($Computers | Select Name))
{
	$System = Get-WmiObject -ComputerName $Computer -Query "SELECT * FROM Win32_SystemEnclosure" -Namespace "root\CIMV2"
	$ComputerSystem = Get-WmiObject -ComputerName $Computer -Class Win32_ComputerSystem
	$BIOS = Get-WmiObject -ComputerName $Computer -Class Win32_BIOS
	$BIOSageInYears = (New-TimeSpan -Start ($BIOS.ConvertToDateTime($BIOS.releasedate).ToShortDateString()) -End $(Get-Date)).Days / 365
	$OperatingSystem = Get-WmiObject -ComputerName $Computer -Class Win32_OperatingSystem
	$OSInstallDate = ($OperatingSystem.ConvertToDateTime($OperatingSystem.InstallDate).ToShortDateString())
	New-Object -TypeName PSObject -Property @{
		Computer = $Computer
		SerialNumber = $System.SerialNumber
		Manufacturer = $ComputerSystem.Manufacturer
		Model = $ComputerSystem.Model
		BIOSreleaseDate = ($BIOS.ConvertToDateTime($BIOS.releasedate).ToShortDateString())
		BIOSageInYears = $BIOSageInYears
		$OSInstallDate = $OSInstallDate
	}
}

### HTML settings
$Pre = "&lt;h2&gt;Computer Information Report&lt;/h2&gt;"
$Results = $Results | ConvertTo-Html -Head $Header | Out-File "C:\ComputerInfoReport.htm"


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_get_LIST_of_SERVERS_on_Network</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_get_LIST_of_SERVERS_on_Network</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#FROM: https://gallery.technet.microsoft.com/PowerShell-script-to-Find-d2ba4252


#email_LIST_of_REMOTE_logins_for_all_SERVERS_on_our_Network.psf


# Import the Active Directory module for the Get-ADComputer CmdLet 
Import-Module ActiveDirectory 
 
# Get today's date for the report 
$today = Get-Date 
 
# Setup email parameters 
$subject = "ACTIVE SERVER SESSIONS REPORT - " + $today 
$priority = "Normal" 
$smtpServer = "Barriere-com.mail.protection.outlook.com" 
$emailFrom = "DoNotReply@barriere.com" 
$emailTo = "glenng@barriere.com" 
 
# Create a fresh variable to collect the results. You can use this to output as desired 
$SessionList = "ACTIVE SERVER SESSIONS REPORT - " + $today + "`n`n" 
 
# Query Active Directory for computers running a Server operating system 
$Servers = Get-ADComputer -Filter {OperatingSystem -like "*server*"} 
 
# Loop through the list to query each server for login sessions 
ForEach ($Server in $Servers) { 
    $ServerName = $Server.Name 
 
    # When running interactively, uncomment the Write-Host line below to show which server is being queried 
    # Write-Host "Querying $ServerName" 
 
    # Run the qwinsta.exe and parse the output 
    $queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "\s+",","))} | ConvertFrom-Csv)  
     
    # Pull the session information from each instance 
    ForEach ($queryResult in $queryResults) { 
        $RDPUser = $queryResult.USERNAME 
        $sessionType = $queryResult.SESSIONNAME 
         
        # We only want to display where a "person" is logged in. Otherwise unused sessions show up as USERNAME as a number 
        If (($RDPUser -match "[a-z]") -and ($RDPUser -ne $NULL)) {  
            # When running interactively, uncomment the Write-Host line below to show the output to screen 
            # Write-Host $ServerName logged in by $RDPUser on $sessionType 
            $SessionList = $SessionList + "`n`n" + $ServerName + " logged in by " + $RDPUser + " on " + $sessionType 
        } 
    } 
} 
 
# Send the report email 
# Send-MailMessage -To $emailTo -Subject $subject -Body $SessionList -SmtpServer $smtpServer -From $emailFrom -Priority $priority 
 
# When running interactively, uncomment the Write-Host line below to see the full list on screen 
$SessionList </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FIREWALL_set_rule_for_WMI_to_be_allowed_on_remote_Machines</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FIREWALL_set_rule_for_WMI_to_be_allowed_on_remote_Machines</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://stackoverflow.com/questions/11330874/get-wmiobject-the-rpc-server-is-unavailable-exception-from-hresult-0x800706

'Thought I would add that we also ran into this issue with multiple machines in our domain. 
'I created a list of offending machines and added them all to a text file from which to run the script. 
'I ran this from the CMD prompt using elevated privileges.

'psexec' is from SysInternals, and you should put the executable in the path of the computer ENV.
You must run it from the CMD (admin privileges)


 psexec @firewallFix.txt -d netsh advfirewall firewall 
        set rule name="Windows Management Instrumentation (WMI-In)" 
        profile=domain new enable=yes profile=domain</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FIREWALL_STATE_local_or_remote_machine_using_NETSH</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FIREWALL_STATE_local_or_remote_machine_using_NETSH</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://power-shell.com/2015/powershell-scripts/get-curent-firewall-status-utilizing-netsh/

#' USAGE:
&gt;Get-FirewallState -HOSTNAME SERVER01

#' The function:

Function Get-FirewallState
{
	[CmdletBinding()]
	
	Param ([Parameter(Mandatory = $true)][string]$HOSTNAME)
$ErrorActionPreference = "Stop"
Try {
$FirewallBlock = {
				$content = netsh advfirewall show allprofiles
				If ($domprofile = $content | Select-String 'Domain Profile' -Context 2 | Out-String)
				{ $domainpro = ($domprofile.Substring($domprofile.Length - 9)).Trim()}
				Else { $domainpro = $null }
				If ($priprofile = $content | Select-String 'Private Profile' -Context 2 | Out-String)
				{ $privatepro = ($priprofile.Substring($priprofile.Length - 9)).Trim()}
				Else { $privatepro = $null }
				If ($pubprofile = $content | Select-String 'Public Profile' -Context 2 | Out-String)
				{ $publicpro = ($pubprofile.Substring($pubprofile.Length - 9)).Trim()}
				Else { $publicpro = $null }
				
				$FirewallObject = New-Object PSObject
				Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallDomain" -value $domainpro
				Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPrivate" -value $privatepro
				Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPublic" -value $publicpro
				$FirewallObject
			}
 
Invoke-Command -computerName $HOSTNAME -command $FirewallBlock | Select-Object FirewallDomain, FirewallPrivate, FirewallPublic
 
}
Catch
		{
       Write-Host  ($_.Exception.Message -split ' For')[0] -ForegroundColor Red
        }
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FIREWALL_STATE_pipeline_input</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FIREWALL_STATE_pipeline_input</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gist.github.com/micmaher/f101132fd86554062aaaa50b234b3cdc
==============
'USAGE

'1] The Input file
LT-103336
LT-103110

'2] Call the function, and assign the items in the list to the 'Name' variable
'	Basically, the select operation is turning the object into a property value. 

&gt;$Computers = get-content computers_2.txt -OutVariable Name;
&gt;$Computers  | Select @{ Name = "Name"; Expression = {$_}} | Get-FirewallState ;


'OR
'3]

$Computers = get-content computers_2.txt -OutVariable Name;
$Computers  | Get-FirewallState -Hostname {$_} ;


=============

#Requires -Version 4.0
&lt;#
    .SYNOPSIS
        Gets the Firewall State for for a local, remote or a piped list of machines
    .DESCRIPTION
        Will require PowerShell 4.0 or later
        Gets Public, Private and Domain Profiles
    .EXAMPLE
        Gets the firewall state for all domain controllers
            Get-ADDomainController -filter * | Get-FirewallState
    .PARAMETER Hostname
        The host to query
	.NOTES
        Author: Based on http://power-shell.com/2015/powershell-scripts/get-curent-firewall-status-utilizing-netsh/
        I added pipeline support and the inclusion of the hostname in the results
    #&gt;
Function Get-FirewallState
{
	[CmdletBinding()]

	Param ([Parameter(Mandatory = $true, ValueFromPipelineByPropertyName)]
    [Alias("Name")]
    [string]$Hostname)

Begin{
    $ErrorActionPreference = "Stop"
}

Process{
    Try {
    $FirewallBlock = {
				    $content = netsh advfirewall show allprofiles
				    If ($domprofile = $content | Select-String 'Domain Profile' -Context 2 | Out-String)
				    { $domainpro = ($domprofile.Substring($domprofile.Length - 9)).Trim()}
				    Else { $domainpro = $null }
				    If ($priprofile = $content | Select-String 'Private Profile' -Context 2 | Out-String)
				    { $privatepro = ($priprofile.Substring($priprofile.Length - 9)).Trim()}
				    Else { $privatepro = $null }
				    If ($pubprofile = $content | Select-String 'Public Profile' -Context 2 | Out-String)
				    { $publicpro = ($pubprofile.Substring($pubprofile.Length - 9)).Trim()}
				    Else { $publicpro = $null }

				    $FirewallObject = New-Object PSObject
				    Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallDomain" -value $domainpro
				    Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPrivate" -value $privatepro
				    Add-Member -inputObject $FirewallObject -memberType NoteProperty -name "FirewallPublic" -value $publicpro
				    $FirewallObject
			    }

    Invoke-Command -computerName $HOSTNAME -command $FirewallBlock | Select-Object  @{N="Hostname";E={$hostname}},FirewallDomain, FirewallPrivate, FirewallPublic

    }
    Catch
		    {
           Write-Host  ($_.Exception.Message -split ' For')[0] -ForegroundColor Red
            }
}
End{}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>IP_address_details_for_Remote_computer</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>IP_address_details_for_Remote_computer</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://techibee.com/powershell/powershell-get-ip-address-subnet-gateway-dns-serves-and-mac-address-details-of-remote-computer/1367

'You can save this script to a PS1 fil(say Get-IPDetails.PS1) and run it against list of computers you need. Below is one example.

'USAGE

&gt; .\Get-IPDetails.ps1 -ComputerName BCC-EXPLORER3 | Format-table -AutoSize




=======================================================================

[cmdletbinding()]            
param (            
 [parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]            
    [string[]]$ComputerName = $env:computername            
)                        
            
begin {}            
process {            
 foreach ($Computer in $ComputerName) {            
  if(Test-Connection -ComputerName $Computer -Count 1 -ea 0) {            
   try {            
    $Networks = Get-WmiObject Win32_NetworkAdapterConfiguration -ComputerName $Computer -EA Stop | ? {$_.IPEnabled}            
   } catch {            
        Write-Warning "Error occurred while querying $computer."            
        Continue            
   }            
   foreach ($Network in $Networks) {            
    $IPAddress  = $Network.IpAddress[0]            
    $SubnetMask  = $Network.IPSubnet[0]            
    $DefaultGateway = $Network.DefaultIPGateway            
    $DNSServers  = $Network.DNSServerSearchOrder            
    $IsDHCPEnabled = $false            
    If($network.DHCPEnabled) {            
     $IsDHCPEnabled = $true            
    }            
    $MACAddress  = $Network.MACAddress            
    $OutputObj  = New-Object -Type PSObject            
    $OutputObj | Add-Member -MemberType NoteProperty -Name ComputerName -Value $Computer.ToUpper()            
    $OutputObj | Add-Member -MemberType NoteProperty -Name IPAddress -Value $IPAddress            
    $OutputObj | Add-Member -MemberType NoteProperty -Name SubnetMask -Value $SubnetMask            
    $OutputObj | Add-Member -MemberType NoteProperty -Name Gateway -Value $DefaultGateway            
    $OutputObj | Add-Member -MemberType NoteProperty -Name IsDHCPEnabled -Value $IsDHCPEnabled            
    $OutputObj | Add-Member -MemberType NoteProperty -Name DNSServers -Value $DNSServers            
    $OutputObj | Add-Member -MemberType NoteProperty -Name MACAddress -Value $MACAddress            
    $OutputObj            
   }            
  }            
 }            
}            
            
end {} </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ODBC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Modifying ODBC Settings with WMI and PowerShell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ODBC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Modifying ODBC Settings with WMI and PowerShell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://www.sqldataplatform.com/Blog/Post/9/Modifying-ODBC-Settings-with-WMI-and-PowerShell

#' This modifies an existing ODBC Setting

#'  The most important part of this script is the #Define Key to Modify section. 
#'  The $ValueName is the registry value you want to change, 
#'  in this case the "Server" value since we are moving databases to a new server. 
#'  The $Value is the new name of the server, for our example here it's SQLPROD1. 
#'  The $Key is the location of the registry key where you will change the ODBC values. 
#'  MYODBCNAME in the Key is the name of your DSN. 
#'  Create a new ODBC DSN connection and use the above script to modify it. 


#====================================================================================

#' Define Constants 

$HKEY_Local_Machine =2147483650 #This is the HKEY_Local_Machine well known value 

#' Get Class to call static methods on 

$regClass = [WMIClass]"ROOT\DEFAULT:StdRegProv" #WMIClass is a Type Accelerator 

#' Define key to modify 

$ValueName = "Server" #The registry value you want to change 

$Values = @('SQLPROD1') #SQLPROD1 is the name of the new server 

$Key = "SOFTWARE\odbc\odbc.ini\MYODBCNAME" #Location of the Key, MYODBCNAME is the DSN name. 

#' Create Value entry 

$results = $regClass.SetStringValue($HKEY_LOCAL_MACHINE, $Key, $ValueName, $Values) 

If ($results.Returnvalue -eq 0) {"Value Set"} 


#====================================================================================
#'  
#'  Now that we know how to change the ODBC on our local machine, 
#'  now we can change it on a remote PC. 
#'  This follows the same steps as our first script but now we need to add come credentials to authenticate to the target client machine. 
#'  Make sure the account you are using has elevated permissions on the remote machine. 

#Define credentials to connect to remote machine 

$Password = ConvertTo-SecureString "P@ssw0rD" -AsPlainText -Force 

$credential = New-Object System.Management.Automation.PSCredential "MyDomain\administrator", $Password 

# Define Constants 

$HKEY_Local_Machine =2147483650 #This is the HKEY_Local_Machine well known value 

# Get Class to call static methods on with credential - targets remote computername 

$regClass = get-wmiobject -list "StdRegProv" -namespace root\default -computername STL-W7User1 -credential $credential 

# Define key to modify 

$ValueName = "Server" #The registry value you want to change 

$Values = @('SQLPRD1') #Name of the new server 

$Key = "SOFTWARE\odbc\odbc.ini\MYODBCNAME" #MYODBCNAME is the DSN name. 

# Create Value entry 

$results = $regClass.SetStringValue($HKEY_LOCAL_MACHINE, $Key, $ValueName, $Values) 

If ($results.Returnvalue -eq 0) {"Value Set"} 

#'===============================================================================

#'  Here we have passed credentials to the remote machine so we can execute the script. 
#'  You will also notice the addition of –computername 
#'  under the #Define Constants section, 
#'  this is the target computer name STL-W7User1. 
#'  Setup a new ODBC on a remote PC and test again. 
#'  
#'  Now that we know how to change the ODBC connection for both local and remote PCs, 
#'  but how can we change it for more than a single remote PC, 
#'  for let's say 20 PC's? We are going to build an array, 
#'  a simple text file that has all the computer names you want to change the ODBC connection on. 
#'  After we build our array we will iterate through the array using foreach: 
#'  


#Define credentials to connect to remote machine 

$Password = ConvertTo-SecureString "P@ssw0rD" -AsPlainText -Force 

$credential = New-Object System.Management.Automation.PSCredential "MyDomain\administrator", $Password 

# Define Constants 

$HKEY_Local_Machine =2147483650 #This is the HKEY_Local_Machine well known value 

# Define array 

$strComputers = Get-Content -Path "C:\MyScripts\Computers.txt" 

# Get Class to call static methods on with credential – calls array 

$regClass = get-wmiobject -list "StdRegProv" -namespace root\default -computername $strComputers -credential $credential 

# Define key to modify 

$ValueName = "Server" #The registry value you want to change 

$Values = @('SQLPRD1') #Name of the new server 

$Key = "SOFTWARE\odbc\odbc.ini\MYODBCNAME" #MYODBCNAME is the DSN name. 

# Create Value entry 

Foreach ($objectName in $regClass) 

$results = $objectName.SetStringValue($HKEY_LOCAL_MACHINE, $Key, $ValueName, $Values) 

If ($results.Returnvalue -eq 0) {"Value Set"} 


#'  This script follows all the steps from the last script 
#'  but this time we are calling our text file to feed the computer names to build our array. 
#'  Under #Create Value Entry we use Foreach to iterate through the computer names, 
#'  this way all remote computers defined in your list will have their ODBC changed. 
#'  For the text file, I just created a simple txt file with each computer name in it. 
#'  I am calling the directory C:\MyScripts\ with the file name Computers.txt in the #Define Array section. 

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>SAMPLE_Profile_1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>SAMPLE_Profile_1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'http://www.zerrouki.com/powershell-profile-example/


&lt;#
.SYNOPSIS
    Microsoft.PowerShell_profile.ps1 - My PowerShell profile
.DESCRIPTION
    Microsoft.PowerShell_profile - Customizes the PowerShell console
.NOTES
    File Name   : Microsoft.PowerShell_profile.ps1
    Author      : Fabrice ZERROUKI - fabricezerrouki@hotmail.com
#&gt;
Set-Location D:\Documents\xxxxxx\PERSONNEL\powerscripts
$Shell=$Host.UI.RawUI
$size=$Shell.BufferSize
$size.width=120
$size.height=3000
$Shell.BufferSize=$size
$size=$Shell.WindowSize
$size.width=120
$size.height=30
$Shell.WindowSize=$size
 
$Shell.BackgroundColor="Black"
$Shell.ForegroundColor="White"
$Shell.CursorSize=10
 
function Get-Time {return $(Get-Date | ForEach {$_.ToLongTimeString()})}
function prompt
{
    Write-Host "[" -noNewLine
    Write-Host $(Get-Time) -ForegroundColor DarkYellow -noNewLine
    Write-Host "] " -noNewLine
    Write-Host $($(Get-Location).Path.replace($home,"~")) -ForegroundColor DarkGreen -noNewLine
    Write-Host $(if ($nestedpromptlevel -ge 1) { '&gt;&gt;' }) -noNewLine
    return "&gt; "
}
 
function ll
{
    param ($dir = ".", $all = $false)
 
    $origFg = $Host.UI.RawUI.ForegroundColor
    if ( $all ) { $toList = ls -force $dir }
    else { $toList = ls $dir }
 
    foreach ($Item in $toList)
    {
        Switch ($Item.Extension)
        {
            ".exe" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".hta" {$Host.UI.RawUI.ForegroundColor="DarkYellow"}
            ".cmd" {$Host.UI.RawUI.ForegroundColor="DarkRed"}
            ".ps1" {$Host.UI.RawUI.ForegroundColor="DarkGreen"}
            ".html" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".htm" {$Host.UI.RawUI.ForegroundColor="Cyan"}
            ".7z" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".zip" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".gz" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            ".rar" {$Host.UI.RawUI.ForegroundColor="Magenta"}
            Default {$Host.UI.RawUI.ForegroundColor=$origFg}
        }
        if ($item.Mode.StartsWith("d")) {$Host.UI.RawUI.ForegroundColor="Gray"}
        $item
    }
    $Host.UI.RawUI.ForegroundColor = $origFg
}
 
function Edit-HostsFile {
    Start-Process -FilePath notepad -ArgumentList "$env:windir\system32\drivers\etc\hosts"
}
 
function rdp ($ip) {
    Start-Process -FilePath mstsc -ArgumentList "/admin /w:1024 /h:768 /v:$ip"
}
 
function tail ($file) {
Get-Content $file -Wait
}
 
function whoami {
    [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
}
 
function Reload-Profile {
    @(
        $Profile.AllUsersAllHosts,
        $Profile.AllUsersCurrentHost,
        $Profile.CurrentUserAllHosts,
        $Profile.CurrentUserCurrentHost
    ) | % {
        if(Test-Path $_) {
            Write-Verbose "Running $_"
            . $_
        }
    }    
}
 
function Check-SessionArch {
    if ([System.IntPtr]::Size -eq 8) { return "x64" }
    else { return "x86" }
}
 
function Test-Port {
[cmdletbinding()]
param(
[parameter(mandatory=$true)]
[string]$Target,
[parameter(mandatory=$true)]
[int32]$Port,
[int32]$Timeout=2000
)
$outputobj=New-Object -TypeName PSobject
$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostName -Value $Target
if(Test-Connection -ComputerName $Target -Count 2) {$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "ONLINE"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name TargetHostStatus -Value "OFFLINE"}            
$outputobj | Add-Member -MemberType NoteProperty -Name PortNumber -Value $Port
$Socket=New-Object System.Net.Sockets.TCPClient
$Connection=$Socket.BeginConnect($Target,$Port,$null,$null)
$Connection.AsyncWaitHandle.WaitOne($timeout,$false) | Out-Null
if($Socket.Connected -eq $true) {$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Success"}
else
{$outputobj | Add-Member -MemberType NoteProperty -Name ConnectionStatus -Value "Failed"}            
$Socket.Close | Out-Null
$outputobj | Select TargetHostName, TargetHostStatus, PortNumber, Connectionstatus | Format-Table -AutoSize
}
 
Set-Alias powergui "C:\Program Files\PowerGUI\ScriptEditor.exe"
Set-Alias grep select-string
 
$MaximumHistoryCount=1024
$IPAddress=@(Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.DefaultIpGateway})[0].IPAddress[0]
$PSVersion=$host | Select-Object -ExpandProperty Version
$PSVersion=$PSVersion -replace '^.+@\s'
$SessionArch=Check-SessionArch
$Shell.WindowTitle="PowerFab rulez! ($SessionArch)"
 
Clear-Host
 
Write-Host "`r`nsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  ssssss`tHi Fab!" -nonewline; Write-Host "`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tComputerName`t`t" -nonewline
Write-Host $($env:COMPUTERNAME) -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssss  ssss`tIP Address`t`t" -nonewline
Write-Host $IPAddress -nonewline; Write-Host "`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "sss  sssss`tUserName`t`t" -nonewline
Write-Host $env:UserDomain\$env:UserName -nonewline; Write-Host "`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Version`t" -nonewline
Write-Host $PSVersion -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ss  s   ss`tPowerShell Session`t" -nonewline
Write-Host $SessionArch -nonewline; Write-Host "`t`t`ts" -ForegroundColor Yellow
Write-Host "s" -ForegroundColor Yellow -nonewline; Write-Host "ssssssssss" -nonewline; Write-Host "`t`t`t`t`t`t`ts" -ForegroundColor Yellow
Write-Host "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss`n" -ForegroundColor Yellow
 
$LogicalDisk = @()
Get-WmiObject Win32_LogicalDisk -filter "DriveType='3'" | % {
    $LogicalDisk += @($_ | Select @{n="Name";e={$_.Caption}},
    @{n="Volume Label";e={$_.VolumeName}},
    @{n="Size (Gb)";e={"{0:N2}" -f ($_.Size/1GB)}},
    @{n="Used (Gb)";e={"{0:N2}" -f (($_.Size/1GB) - ($_.FreeSpace/1GB))}},
    @{n="Free (Gb)";e={"{0:N2}" -f ($_.FreeSpace/1GB)}},
    @{n="Free (%)";e={if($_.Size) {"{0:N2}" -f (($_.FreeSpace/1GB) / ($_.Size/1GB) * 100 )} else {"NAN"} }})
  }
$LogicalDisk | Format-Table -AutoSize | Out-String</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Redirecting_Data_With_Out-*_Cmdlets</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Redirecting_Data_With_Out-*_Cmdlets</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Redirecting_Data_With_Out-*_Cmdlets</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Redirecting_Data_With_Out-*_Cmdlets</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Redirecting_Data_With_Out-*_Cmdlets

'Windows PowerShell provides several cmdlets that let you control data output directly.
'An Out cmdlet should always appear at the end of the pipeline. 

'First, they generally transform data to some form of text. 
'	They do this because they output the data to system components that require text input. 
'	This means they need to represent the objects as text. 
'	Therefore, the text is formatted as you see it in the Windows PowerShell console window.

'Second, these cmdlets use the Windows PowerShell verb Out because they send information out from Windows PowerShell to somewhere else. 

'when data is sent out of Windows PowerShell, it is actually removed. 
'	You can see this if you try to create a pipeline that pages data to the host window, 
'	and then attempt to format it as a list, as shown here:

&gt; Get-Process | Out-Host -Paging | Format-List		'ONCE it's out, you can NOT format it!

'The Out-Host cmdlet sends the data directly to the console

'The correct way to structure this command is to put the Out-Host cmdlet at the end of the pipeline as shown below. 
'	This causes the process data to be formatted in a list before being paged and displayed.

&gt; Get-Process | Format-List | Out-Host -Paging

'You can also use the more function to page data. In Windows PowerShell, more is a function that calls: 
																										Out-Host -Paging. 

&gt; Get-Command | more

'If you include one or more filenames as arguments to the more function, 
'	the function will read the specified files and page their contents to the host:

&gt; more c:\boot.ini
						[boot loader]
						timeout=5
						default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
						[operating systems]
						...
'Printing Data (Out-Printer)
'The Out-Printer cmdlet will use your default printer if you do not provide a printer name. 
'You can use any Windows-based printer by specifying its display name.	

&gt; Get-Command Get-Command | Out-Printer -Name "Microsoft Office Document Image Writer"

'Saving Data (Out-File)
'Out-file formats file contents to look like console output. 
'This causes the output to be truncated just as it is in a console window in most circumstances. 

PS&gt; Get-Process | Out-File -FilePath C:\temp\processlist.txt 

'By default, the Out-File cmdlet creates a Unicode file. 
'This is the best default in the long run, but it means that tools that expect ASCII files will not work correctly with the default output format. 
'You can change the default output format to ASCII by using the Encoding parameter:

&gt; Get-Process | Out-File -FilePath C:\temp\processlist.txt -Encoding ASCII

'To get output that does not force line wraps to match the screen width, 
'you can use the Width parameter to specify line width. Because Width is a 32-bit integer parameter, 
'the maximum value it can have is 2147483647. Type the following to set the line width to this maximum value:

Get-Command | Out-File -FilePath c:\temp\output.txt -Width 2147483647</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>How_To_from_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>How_To_from_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;#'-----------------------------------------------------------------------------
  Beginning PowerShell Scripting for Developers
  Simple script that will just 'Do Something'

  Author: Robert C. Cain | @ArcaneCode | arcanecode@gmail.com
          http://arcanecode.com
 
  This module is Copyright (c) 2015 Robert C. Cain. All rights reserved.
  The code herein is for demonstration purposes. No warranty or guarentee
  is implied or expressly granted. 
  This module may not be reproduced in whole or in part without the express
  written consent of the author. 
-----------------------------------------------------------------------------#&gt;


#'-----------------------------------------------------------------------------#'
#' A few definitions, the "remote" computer is the machine you want to remote
#' control from PowerShell. The "local" computer is the one you are using,
#' i.e. running PowerShell on. 
#'-----------------------------------------------------------------------------#'

#' First, you will need to enable remoting on the computer you want to control
#' ON the REMOTE COMPUTER, enter the command below. (-Force will run without
#' prompts)

Enable-PSRemoting -Force

#' If you are NOT running on a domain, for example doing this on a home
#' network, you will need to do a few other things. 
#' On both the remote computer and the local computer, run:
#' This tells it to trust ALL hosts (!!!!)

Set-Item wsman:\localhost\client\trustedhosts *

#' Instead of an *, you could specify the IP Addresses of the machines. 

#' You will then need to restart the Windows Remote Management service
#' on both computers.
Restart-Service WinRM

#' On the LOCAL computer you are using, you can test by using Test-WSMan
#' followed by the name of the remote computer. 
#' wsman
Test-WSMan ACSrv

#' Now execute a command on the remote system
#' The Script block could be stored in a variable
Invoke-Command -ComputerName BCC-EXPLORER3DB `
               -ScriptBlock { Get-ChildItem C:\ } `
               -Credential glenng
#' It immediately challenges me for my password, then it runs successfully


#' You can also open up a PowerShell window which will execute
#' on the remote computer
Enter-PSSession -ComputerName BCC-EXPLORER3 -Credential glenng

#' Now the console screen shows that it is actually on the remote server:
#' [BCC-EXPLORER3]: PS C:\Users\glenng\Documents&gt; 

#' To exit the remote server in the console window:
exit

#' In the PowerShell ISE there is an icon in the menu bar to launch a remote session
#' It will ask for the computer and my UserID, then challenge me for the password.
#' When it succeeds it will open a new tab in the ISE that is on the remote computer


#'-----------------------------------------------------------------------------#'
#' Fix for network connection profile public {this was not a problem for me at BCC}
#'-----------------------------------------------------------------------------#'
Get-NetConnectionProfile           #' I think this is not available in Windows 7

#' Temporarily Set to Private
Set-NetConnectionProfile `
  -InterfaceAlias 'vEthernet (HWired)' `
  -NetworkCategory Private

Set-NetConnectionProfile `
  -InterfaceAlias 'vEthernet (Internal Ethernet Port Windows Phone Emulator Internal Switch)' `
  -NetworkCategory Private


#' Put them back
Set-NetConnectionProfile `
  -InterfaceAlias 'vEthernet (HWired)' `
  -NetworkCategory Public

Set-NetConnectionProfile `
  -InterfaceAlias 'vEthernet (Internal Ethernet Port Windows Phone Emulator Internal Switch)' `
  -NetworkCategory Public
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>send_EMAIL_all_remote_logins_to_SERVERS_on_network</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>send_EMAIL_all_remote_logins_to_SERVERS_on_network</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#FROM: https://gallery.technet.microsoft.com/PowerShell-script-to-Find-d2ba4252


#email_LIST_of_REMOTE_logins_for_all_SERVERS_on_our_Network.psf


# Import the Active Directory module for the Get-ADComputer CmdLet 
Import-Module ActiveDirectory 
 
# Get today's date for the report 
$today = Get-Date 
 
# Setup email parameters 
$subject = "ACTIVE SERVER SESSIONS REPORT - " + $today 
$priority = "Normal" 
$smtpServer = "Barriere-com.mail.protection.outlook.com" 
$emailFrom = "DoNotReply@barriere.com" 
$emailTo = "glenng@barriere.com" 
 
# Create a fresh variable to collect the results. You can use this to output as desired 
$SessionList = "ACTIVE SERVER SESSIONS REPORT - " + $today + "`n`n" 
 
# Query Active Directory for computers running a Server operating system 
$Servers = Get-ADComputer -Filter {OperatingSystem -like "*server*"} 
 
# Loop through the list to query each server for login sessions 
ForEach ($Server in $Servers) { 
    $ServerName = $Server.Name 
 
    # When running interactively, uncomment the Write-Host line below to show which server is being queried 
    # Write-Host "Querying $ServerName" 
 
    # Run the qwinsta.exe and parse the output 
    $queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "\s+",","))} | ConvertFrom-Csv)  
     
    # Pull the session information from each instance 
    ForEach ($queryResult in $queryResults) { 
        $RDPUser = $queryResult.USERNAME 
        $sessionType = $queryResult.SESSIONNAME 
         
        # We only want to display where a "person" is logged in. Otherwise unused sessions show up as USERNAME as a number 
        If (($RDPUser -match "[a-z]") -and ($RDPUser -ne $NULL)) {  
            # When running interactively, uncomment the Write-Host line below to show the output to screen 
            # Write-Host $ServerName logged in by $RDPUser on $sessionType 
            $SessionList = $SessionList + "`n`n" + $ServerName + " logged in by " + $RDPUser + " on " + $sessionType 
        } 
    } 
} 
 
# Send the report email 
# Send-MailMessage -To $emailTo -Subject $subject -Body $SessionList -SmtpServer $smtpServer -From $emailFrom -Priority $priority 
 
# When running interactively, uncomment the Write-Host line below to see the full list on screen 
$SessionList </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ScheduledTask</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Task_Scheduler</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ScheduledTask</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Task_Scheduler</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Task Scheduler

http://sharepoint-community.net/profiles/blogs/scheduling-powershell-scripts-and-psconsolefile

'Windows Task Scheduler only allows executable (.exe files) and batch (.bat) files to be run.  
'To run a PowerShell script, you need to call the PowerShell executable. 
'One way to do this is to use the following command;

C:\WINDOWS\system32\windowspowershell\v1.0\powershell.exe -PSConsoleFile “C:\sharepointsnapins.psc1” -NoExit –Command &lt;ps1_file&gt;

'The above must be on a single line and the command can either be a file or a simple command.

'I am also using a custom PowerShell Console file (psc1).  
'You can create one of these by using Export-Console and then add the required SharePoint snap-ins. 
'This makes it simpler than employing various checks in the script to ensure all snap-ins are loaded.


================================================================

EXAMPLE:
' put PowerShell.exe in Program/Script field in Task Properties 
' and use 
 -ExecutionPolicy Bypass -File C:\T\AppPoolActivation.ps1 as argument
 
 
 '	I tried your approach at the beginning to call the .ps1 directly from the task, 
'but it never succeed I think the problem is related to a policy that we can not run PowerShell scripts 

'You can bypass execution policy with from Task Manager too.
===============================================================

'I am trying to get a rather long Powershell script to run as a scheduled task.
'So I have a batch wrapper script which I call using my scheduled task 
'I need a way to kill the Powershell session once my Powershell script has done its thing. 
'I have tried using exit in the last line of my batch file but it doesn't kill the Powershell session.

'Use:
Stop-Process $pid 
'or 
kill $pid 
'at the end of your script. It will kill the power shell instance.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ScheduledTask</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Using Task Scheduler to automate PowerShell Scripts </Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ScheduledTask</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Using Task Scheduler to automate PowerShell Scripts </Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

https://support.software.dell.com/appassure/kb/144451

'EXAMPLE: for AppAssure Core

'1] Open Task Scheduler

	'Open Task Scheduler and Create a new task. Name it and set your security options.

		'GENERAL {Tag}
		--------------
			'Name: TEST_Write_Time_to_File 
			'Location: \
			'Author: BCC\glenng
			'When running the task, use the following user Account: BCC\glenng
			'(x) Run whether user is logged on or not
			'[x] Run with highest privileges
			'Configure for: Windows Server 2012 R2
			 
			 
	'Check "Run with highest privileges" as our scripts need to run as admin.  
	'If you want this script to run without your account signed into the AppAssure Core, 
	'enable the 'Run whether user is logged on or not' radio button.
'2] Set Triggers

	'Click on the Triggers tab and set your schedule or event that will trigger the running of your PowerShell script. 

		'Triggers {Tag}
		--------------
		'[New]
		' One time: xxxxx
	
	
'3] Create your Action

	'Click on the Actions tab and click on New.
	'Action: Start a program
	'Program/script: Powershell.exe
	'You don't need to put a path as it should already be on your system.
	
		'Actions {Tag}
		--------------
		'Action: Start a program
		'Program/script: Powershell.exe
		'Add arguments: C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe -NoLogo -NonInteractive -File "C:\DATA\PowerShellScripts\WriteTimeToFile.ps1"
		
		
			
	
'4] Set Argument

	'First you need to set the ExecutionPolicy. You have two options here, you can set the ExecutionPolicy on the machine or you can do it on a per-script basis. 
	'	Read the PowerShell ExecutionPolicy link below as it talks about or you can issue the command:

	Get-Help About_execution_policies

	'To set the execution policy globally, you can issue this command from within PowerShell:

	Set-ExecutionPolicy Unrestricted

	'Or use one of the other settings available depending on your environment. 
	'In the context of this how-to, however, we want to set the execution policy on a per script basis and open up security for us to run the script. 
	'This security policy will only be in effect for the script we are running and not compromise security otherwise.
	'That means we use the following Argument:

	-ExecutionPolicy Bypass -File c:\temp\agent_repl.ps1

'5] Save and Test</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Serialize</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Persist_to_XML_file_and_then_recover_from_file</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Serialize</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Persist_to_XML_file_and_then_recover_from_file</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#'
#' Demo 11 - Serializing an Object
#'           i.e. Persist the values inside an object between executions of script
#'-----------------------------------------------------------------------------#'

  #' Create a simple object
  $mySiteProperties = [ordered]@{ 
                                  WebSite = 'ArcaneCode'
                                  URL = 'http://arcanecode.com'
                                  Twitter = '@ArcaneCode'
                                }

  #' Convert the set of properties to an object
  $mySite = New-Object –TypeName PSObject -Property $mySiteProperties
  
  #' Show the object
  $mySite
  
  #' Save the object to a file and 
  $savedDataFile = 'C:\JUNK\mySite.xml'
  $mySite | Export-Clixml $savedDataFile

  #'==========OUPUT FILE ==========================================================
  &lt;Objs Version="1.1.0.1" xmlns="http://schemas.microsoft.com/powershell/2004/04"&gt;
  &lt;Obj RefId="0"&gt;
    &lt;TN RefId="0"&gt;
      &lt;T&gt;System.Management.Automation.PSCustomObject&lt;/T&gt;
      &lt;T&gt;System.Object&lt;/T&gt;
    &lt;/TN&gt;
    &lt;MS&gt;
      &lt;S N="WebSite"&gt;ArcaneCode&lt;/S&gt;
      &lt;S N="URL"&gt;http://arcanecode.com&lt;/S&gt;
      &lt;S N="Twitter"&gt;@ArcaneCode&lt;/S&gt;
    &lt;/MS&gt;
  &lt;/Obj&gt;
&lt;/Objs&gt;
#'==========OUPUT FILE ==========================================================

#' This opens it up in PowerShell IDE
  psedit $savedDataFile 

  #' Now grab the saved object and recreate in a different variable
  $newMySite = Import-Clixml $savedDataFile
  $newMySite

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SnapIns</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_SnapIns</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SnapIns</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_SnapIns</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_SnapIns

'Snap-Ins - Are compiled cmdlets in to a DLL written in a .Net language
'	are being deprecated and 
'	no longer recommended as the way to create and package new cmdlets.

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SSRS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Download All Your SSRS RDL files</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SSRS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Download All Your SSRS RDL files</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' FROM: http://www.sqlmusings.com/2011/03/28/how-to-download-all-your-ssrs-report-definitions-rdl-files-using-powershell/comment-page-1/#comment-8629
'Here’s a short PowerShell script that :
'1. Connects to your report server
'2. Creates the same folder structure you have in your Report Server
'3. Download all the SSRS Report Definition (RDL) files into their respective folders
'Had to use 2005, not 2010 on the SQL 2008 R2 server
'Had to run it on the server itself

#note this is tested on PowerShell v2 and SSRS 2008 R2
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Xml.XmlDocument");
[void][System.Reflection.Assembly]::LoadWithPartialName("System.IO");
 
$ReportServerUri = "http://bcc-explorerdb/reportserver/reportservice2005.asmx";
$Proxy = New-WebServiceProxy -Uri $ReportServerUri -Namespace SSRS.ReportingService2005 -UseDefaultCredential ;
 
#check out all members of $Proxy
#$Proxy | Get-Member
#http://msdn.microsoft.com/en-us/library/aa225878(v=SQL.80).aspx
 
#second parameter means recursive
$items = $Proxy.ListChildren("/", $true) | `
         select Type, Path, ID, Name | `
         Where-Object {$_.type -eq "Report"};
 
#create a new folder where we will save the files
#PowerShell datetime format codes http://technet.microsoft.com/en-us/library/ee692801.aspx
 
#create a timestamped folder, format similar to 2011-Mar-28-0850PM
$folderName = Get-Date -format "yyyy-MMM-dd-hhmmtt";
$fullFolderName = "C:\JUNK\" + $folderName;
[System.IO.Directory]::CreateDirectory($fullFolderName) | out-null
 
foreach($item in $items)
{
    #need to figure out if it has a folder name
    $subfolderName = split-path $item.Path;
    $reportName = split-path $item.Path -Leaf;
    $fullSubfolderName = $fullFolderName + $subfolderName;
    if(-not(Test-Path $fullSubfolderName))
    {
        #note this will create the full folder hierarchy
        [System.IO.Directory]::CreateDirectory($fullSubfolderName) | out-null
    }
 
    $rdlFile = New-Object System.Xml.XmlDocument;
    [byte[]] $reportDefinition = $null;
    $reportDefinition = $Proxy.GetReportDefinition($item.Path);
 
    #note here we're forcing the actual definition to be 
    #stored as a byte array
    #if you take out the @() from the MemoryStream constructor, you'll 
    #get an error
    [System.IO.MemoryStream] $memStream = New-Object System.IO.MemoryStream(@(,$reportDefinition));
    $rdlFile.Load($memStream);
 
    $fullReportFileName = $fullSubfolderName + "\" + $item.Name +  ".rdl";
    #Write-Host $fullReportFileName;
    $rdlFile.Save( $fullReportFileName);
 
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SSRS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>List_or_Delete_Datasources_With_No_Dependencies</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SSRS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>List_or_Delete_Datasources_With_No_Dependencies</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>    #************************************************************************************************************************************
# FileName:     Delete-DataSources.ps1
# Date:         2015/04/23
# Author:       Hugh Scott
#
# Description:
# This script finds data sources with no dependencies in SSRS and removes them.
#
# Parameters:
#   $serverBase     - base URL for the server to check (ie, myserver.mydomain.com)
#   [$WhatIf]       - Option wwitch parameter to prevent actual deleting of objects (will list out reports that need to be deleted)
#***********************************************************************************************************************************
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$true,Position=0)]
    [string]$serverBase,
    [Parameter(Mandatory=$false,Position=1)]
    [switch]$WhatIf
)

$url = "http://$serverBase/reportserver/ReportService2010.asmx?WSDL"
$ssrs = New-WebServiceProxy -uri $url -UseDefaultCredential -Namespace "ReportingWebService"

$outFile = ".\DeleteItems_$serverBase.txt"

# Connection to Web Service, grab all data sources
$items = $ssrs.ListChildren("/", $true) | where-object {$_.typename -eq "DataSource"}
foreach($item in $items) {

    $dependencies = $ssrs.ListDependentItems($item.Path)
    $dependentReports = $dependencies.Count

    if($dependencies.Count -eq 0){
        [string]$itemName = $item.Path
        if($WhatIf){

            Write-Host "Item $itemName would be deleted."
            Add-Content $outFile "Item $itemName would be deleted."
        } else {
            try {
                $ssrs.DeleteItem($item.Path)
                Write-Host "Item $itemName deleted."
                Add-Content $outFile "Deleted item $itemName ."
            } catch [System.Exception] {
                $Msg = $_.Exception.Message
                Write-Host $itemName $Msg
                Add-Content $itemName $msg
            }
        }
    }
}
shareeditflag</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SSRS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>SECURITY_for_Reports_set_security_by_folder</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SSRS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>SECURITY_for_Reports_set_security_by_folder</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;#
.SYNOPSIS
    Set user permissions in SQL Reporting Services using Web Service
 
.DESCRIPTION
    Set user permissions in SQL Reporting Services using Web Service
 
.EXAMPLE
    Add-SSRSItemSecurity -webServiceUrl "http://[ServerName]/ReportServer/ReportService2005.asmx?WSDL" -itemPath "MyReportFolder" -groupUserName RPAULO\User1 -role Browser
 
.EXAMPLE
    Add-SSRSItemSecurity -url "http://[ServerName]/ReportServer/ReportService2005.asmx?WSDL" -itemPath "MyReportFolder" -u RPAULO\User1 -r "Content Manager"
 
#&gt;
function Add-SSRSItemSecurity
(
    [Parameter(Position=0,Mandatory=$true)]
    [Alias("url")]
    [string]$webServiceUrl,
 
    [Parameter(Position=1,Mandatory=$true)]
    [Alias("path")]
    [string]$itemPath,
     
    [Parameter(Position=2,Mandatory=$true)]
    [Alias("u")]
    [string]$groupUserName,
     
    [Parameter(Position=3,Mandatory=$true)]
    [Alias("r")]
    [string]$role,
     
    [Parameter(Position=4)]
    [bool]$inherit=$true
)
 
{
     
    #Fix item path if not starting with /
    if(!$itemPath.StartsWith("/")) { $itemPath = "/" + $itemPath}
     
    #Create Proxy
    Write-Host "[Add-SSRSItemSecurity()] Creating Proxy, connecting to : $webServiceUrl"
    $ssrsProxy = New-WebServiceProxy -Uri $webServiceUrl -UseDefaultCredential
     
    $type = $ssrsProxy.GetType().Namespace;
    $policyType = "{0}.Policy" -f $type;
    $roleType = "{0}.Role" -f $type;
     
    Write-Host "[Add-SSRSItemSecurity()] Retrieving all existing policies."
    $policies = $ssrsProxy.GetPolicies($itemPath, [ref]$inherit);
     
    $a = 1;
    foreach($policy in $policies)
    {
 
        foreach($r in $policy.Roles)
        {
            $msg = "[Add-SSRSItemSecurity()]  Existing Policy # {0} Group Name: {1}, Role: {2}" -f $a, $policy.GroupUserName, $r.Name
            Write-Host $msg
        }
        $a+=1;
    }
 
    $msg = "[Add-SSRSItemSecurity()] Total Existing Policies: " + $policies.Length;
    Write-Host $msg
     
    $Policy = $policies | 
    Where-Object { $_.GroupUserName -eq $groupUserName } | 
    Select-Object -First 1
     
    if (-not $Policy) {
        $Policy = New-Object ($policyType)
        $Policy.GroupUserName = $GroupUserName
        $Policy.Roles = @()
        $Policies += $Policy
        $msg = "[Add-SSRSItemSecurity()] Adding new policy: '{0}'" -f $GroupUserName
        Write-Host $msg
    }
 
    $r = $Policy.Roles |
        Where-Object { $_.Name -eq $role } |
        Select-Object -First 1
    if (-not $r) {
        $r = New-Object ($roleType)
        $r.Name = $role
        $Policy.Roles += $r
        $msg = "[Add-SSRSItemSecurity()] Adding new role: '{0}'" -f $role
        Write-Host $msg
    }
     
    #Set the policies
    $ssrsProxy.SetPolicies($itemPath,$policies);
 
}

#' To set the HOME folder Policies
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/" -groupUserName BCC\g_SSRS_CanSeeAllReports -role Browser

Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/" -groupUserName BCC\g_SSRS_Developers -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/" -groupUserName BCC\g_SSRS_Developers -role 'Content Manager'
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/" -groupUserName BCC\g_SSRS_Developers -role 'My Reports'
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/" -groupUserName BCC\g_SSRS_Developers -role Publisher
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/" -groupUserName BCC\g_SSRS_Developers -role 'Report Builder'
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/" -groupUserName 'NT AUTHORITY\Authenticated Users' -role Browser


#' To set the 'Eclipse_Admin' folder Policies
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Eclipse_Admin" -groupUserName BCC\g_ECLIPSE_Admin -role Browser
#' MANUALLY: remove the Browse permission, for 'NT AUTHORITY\Authenticated Users',  for the 'Eclipse_Admin' folder


#' To set the 'Eclipse_Admin' folder Policies
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Financial" -groupUserName 'BCC\g_eclipse_ACCT_AP' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Financial" -groupUserName 'BCC\g_eclipse_ACCT_CA' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Financial" -groupUserName 'BCC\g_eclipse_ACCT_CTL' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Financial" -groupUserName 'BCC\g_eclipse_ACCT_LEAD' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Financial" -groupUserName 'BCC\g_eclipse_OP_PM' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Financial" -groupUserName 'BCC\g_SSRS_BusinessGroupAdmins' -role Browser
#' MANUALLY: remove the Browse permission, for 'NT AUTHORITY\Authenticated Users', for this folder


#' To set the 'Financial_Trucks' folder Policies
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Financial_Trucks" -groupUserName 'BCC\g_eclipse_OP_PM' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Financial_Trucks" -groupUserName 'BCC\g_SSRS_BusinessGroupAdmins' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Financial_Trucks" -groupUserName 'BCC\g_SSRS_Trucking_Reports' -role Browser
#' MANUALLY: remove the Browse permission, for 'NT AUTHORITY\Authenticated Users', for this folder


#' To set the 'HR' folder Policies
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR" -groupUserName 'BCC\g_eclipse_ACCT_PAYRL' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR" -groupUserName 'BCC\g_eclipse_HR' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR" -groupUserName 'BCC\g_eclipse_HR_ADMIN' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR" -groupUserName 'BCC\g_eclipse_HR_PAY' -role Browser
#' MANUALLY: remove the Browse permission, for 'NT AUTHORITY\Authenticated Users', for this folder


#' To set the 'HR_ACCT' folder Policies
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR_ACCT" -groupUserName 'BCC\g_eclipse_ACCT_PAYRL' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR_ACCT" -groupUserName 'BCC\g_eclipse_HR' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR_ACCT" -groupUserName 'BCC\g_eclipse_HR_ADMIN' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR_ACCT" -groupUserName 'BCC\g_eclipse_HR_PAY' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR_ACCT" -groupUserName 'BCC\g_eclipse_ACCT_AP' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR_ACCT" -groupUserName 'BCC\g_eclipse_ACCT_CA' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR_ACCT" -groupUserName 'BCC\g_eclipse_ACCT_CTL' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/HR_ACCT" -groupUserName 'BCC\g_eclipse_ACCT_LEAD' -role Browser
#' MANUALLY: remove the Browse permission, for 'NT AUTHORITY\Authenticated Users', for this folder


#' To set the 'IT' folder Policies
#' MANUALLY: remove the Browse permission, for 'NT AUTHORITY\Authenticated Users', for this folder



#' To set the 'Job Cost' folder Policies
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Job Cost" -groupUserName 'BCC\g_eclipse_ACCT_PAYRL' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Job Cost" -groupUserName 'BCC\g_eclipse_ACCT_AP' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Job Cost" -groupUserName 'BCC\g_eclipse_ACCT_CA' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Job Cost" -groupUserName 'BCC\g_eclipse_ACCT_CTL' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Job Cost" -groupUserName 'BCC\g_eclipse_ACCT_LEAD' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Job Cost" -groupUserName 'BCC\g_eclipse_OP_PM' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Job Cost" -groupUserName 'BCC\g_SSRS_BusinessGroupAdmins' -role Browser
#' MANUALLY: remove the Browse permission, for 'NT AUTHORITY\Authenticated Users', for this folder


#' To set the 'Payroll Reports' folder Policies
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Payroll Reports" -groupUserName 'BCC\g_eclipse_ACCT_PAYRL' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Payroll Reports" -groupUserName 'BCC\g_eclipse_HR' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Payroll Reports" -groupUserName 'BCC\g_eclipse_HR_ADMIN' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Payroll Reports" -groupUserName 'BCC\g_eclipse_HR_PAY' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Payroll Reports" -groupUserName 'BCC\g_eclipse_ACCT_AP' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Payroll Reports" -groupUserName 'BCC\g_eclipse_ACCT_CA' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Payroll Reports" -groupUserName 'BCC\g_eclipse_ACCT_CTL' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Payroll Reports" -groupUserName 'BCC\g_eclipse_ACCT_LEAD' -role Browser
Add-SSRSItemSecurity -webServiceUrl "http://localhost/ReportServer/ReportService2005.asmx?WSDL" -itemPath "/Payroll Reports" -groupUserName 'BCC\g_SSRS_BusinessGroupAdmins' -role Browser
#' MANUALLY: remove the Browse permission, for 'NT AUTHORITY\Authenticated Users', for this folder


#' To set the 'Payroll Reports/Payroll_Reports_HR_ACCT' folder Policies
#' MANUALLY: remove the Browse permission, for 'BCC\g_SSRS_BusinessGroupAdmins', for this folder
#' Then create the LINKED Reports in the folder above it:
#'               401K Census
#'               Certified Payroll
#'               Child Support
#'               Employee Union Status
#'               Employees that Received Advancements
#'               Hourly Employee Verification
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_AdAccountManagementAutomator.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_AdAccountManagementAutomator.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>function New-EmployeeOnboardUser {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to perform all routine
		tasks that must be done when onboarding a new employee user account.
	.EXAMPLE
		PS&gt; New-EmployeeOnboardUser -FirstName 'adam' -MiddleInitial D -LastName Bertram -Title 'Dr. Awesome'
	
		This example creates an AD username based on company standards into a company-standard OU and adds the user
		into the company-standard main user group.
	.PARAMETER FirstName
	 	The first name of the employee
	.PARAMETER MiddleInitial
		The middle initial of the employee
	.PARAMETER LastName
		The last name of the employee
	.PARAMETER Title
		The current job title of the employee
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Firstname,
		[string]$MiddleInitial,
		[string]$LastName,
		[string]$Location = 'OU=Corporate Users',
		[string]$Title
	)
	process {
		## Not the best use of storing the password clear text
		## Google/Bing on using stored secure strings on the file system as a way to get around this
		$DefaultPassword = 'p@$$w0rd12'
		$DomainDn = (Get-AdDomain).DistinguishedName
		$DefaultGroup = 'Gigantic Corporation Inter-Intra Synergy Group'
			
		$Username = "$($FirstName.SubString(0, 1))$LastName"
		## Check if an existing user already has the first intial/last name username taken
		try {
            if (Get-ADUser $Username) {
				## If so, check to see if the first initial/middle initial/last name is taken.
				$Username = "$($FirstName.SubString(0, 1))$MiddleInitial$LastName"
				if (Get-AdUser $Username) {
					throw "No acceptable username schema could be created"
				}
			}
		} catch {
            Write-Error $_.Exception.Message
        }
		$NewUserParams = @{
            'UserPrincipalName' = $Username
            'Name' = $Username
            'GivenName' = $FirstName
            'Surname' = $LastName
            'Title' = $Title
            'SamAccountName' = $Username
            'AccountPassword' = (ConvertTo-SecureString $DefaultPassword -AsPlainText -Force)
            'Enabled' = $true
            'Initials' = $MiddleInitial
            'Path' = "$Location,$DomainDn"
            'ChangePasswordAtLogon' = $true
        }
			
		New-AdUser @NewUserParams
		Add-ADGroupMember $Username $DefaultGroup
        $Username
	}
}

function Set-MyAdUser {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to modify
		one or more Active Directory attributes on a single Active Directory user account.
	.EXAMPLE
		PS&gt; Set-MyAdUser -Username adam -Attributes @{'givenName' = 'bob'; 'DisplayName' = 'bobby bertram'; 'Title' = 'manager'}
	
		This example changes the givenName to bob, the display name to 'bobby bertram' and the title to 'manager' for the username 'adam'
	.PARAMETER Username
	 	An Active Directory username to modify
	.PARAMETER Attributes
		A hashtable with keys as Set-AdUser parameter values and values as Set-AdUser parameter argument values
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Username,
		[hashtable]$Attributes
	)
	process {
		try {
			## Attempt to find the username
			$UserAccount = Get-AdUser -Identity $Username
			if (!$UserAccount) {
				## If the username isn't found throw an error and exit
				#Write-Error "The username '$Username' does not exist"
				throw "The username '$Username' does not exist"
			}
			
			## The $Attributes parameter will contain only the parameters for the Set-AdUser cmdlet other than
			## Password.  If this is in $Attributes it needs to be treated differently.
			if ($Attributes.ContainsKey('Password')) {
				$UserAccount | Set-ADAccountPassword -Reset -NewPassword (ConvertTo-SecureString -AsPlainText $Attributes.Password -Force)
				## Remove the password key because we'll be passing this hashtable directly to Set-AdUser later
				$Attributes.Remove('Password')
			}
			
			$UserAccount | Set-AdUser @Attributes
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}

function Set-MyAdComputer {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to modify
		one or more Active Directory attributes on a single Active Directory computer account.
	.EXAMPLE
		PS&gt; Set-MyAdComputer -Computername adampc -Attributes @{'Location' = 'Phoenix'; 'Description' = 'is a little problematic'}
	
		This example changes the location to Phoenix and the description of the AD computer adampc to 'is a little problematic'
	.PARAMETER Computername
	 	An Active Directory computer account to modify
	.PARAMETER Attributes
		A hashtable with keys as Set-AdComputer parameter values and values as Set-AdComputer parameter argument values
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Computername,
		[hashtable]$Attributes
	)
	process {
		try {
			## Attempt to find the Computername
			$Computer = Get-AdComputer -Identity $Computername
			if (!$Computer) {
				## If the Computername isn't found throw an error and exit
				#Write-Error "The Computername '$Computername' does not exist"
				throw "The Computername '$Computername' does not exist"
			}
			
			## The $Attributes parameter will contain only the parameters for the Set-AdComputer cmdlet
			$Computer | Set-AdComputer @Attributes
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}

function New-EmployeeOnboardComputer {
	&lt;#
	.SYNOPSIS
		This function is part of the Active Directory Account Management Automator tool.  It is used to perform all routine
		tasks that must be done when onboarding a new AD computer account.
	.EXAMPLE
		PS&gt; New-EmployeeOnboardComputer -FirstName 'adam' -MiddleInitial D -LastName Bertram -Title 'Dr. Awesome'
	
		This example creates an AD username based on company standards into a company-standard OU and adds the user
		into the company-standard main user group.
	.PARAMETER Computername
	 	The name of the computer to create in AD
	.PARAMETER Location
		The AD distinguishedname of the OU that the computer account will be created in
	#&gt;
	[CmdletBinding()]
	param (
		[string]$Computername,
		[string]$Location
	)
	process {
		try {
			if (Get-AdComputer $Computername) {
				#Write-Error "The computer name '$Computername' already exists"
				throw "The computer name '$Computername' already exists"
			}
			
			$DomainDn = (Get-AdDomain).DistinguishedName
			$DefaultOuPath = "$Location,$DomainDn"
			
			New-ADComputer -Name $Computername -Path $DefaultOuPath
		} catch {
			Write-Error $_.Exception.Message
		}
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_CsvImportExample.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PowerShell_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_CsvImportExample.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>. C:\AdAccountManagementAutomator.ps1          #' &lt;=== dot source the file with all four functions in it.

$Employees = Import-Csv -Path C:\Users.csv     #' &lt;=== Import the CSV file
foreach ($Employee in $Employees) {            #' &lt;=== For each record in the CSV file
    ## Create the AD user accounts
    $NewUserParams = @{                         #' &lt;=== Populate a HashTable from
				        'FirstName' = $Employee.FirstName
				        'MiddleInitial' = $Employee.MiddleInitial
				        'LastName' = $Employee.LastName
				        'Title' = $Employee.Title
                      }
    if (!$Employee.Location) {                         #'&lt;== If the Location field is NOT populated, populate the field in $NewUserParams with a NULL
        						$NewUserParams.Location = $null 
    						 } 
    else { 
        	$NewUserParams.Location = $Employee.Location   #'&lt;== If the Location field is populated, that use it to populate the $NewUserParams
    	 }
    ## Grab the username created to use for Set-MyAdUser
    $Username = New-EmployeeOnboardUser @NewUserParams

    ## Create the employee's AD computer account
    New-EmployeeOnboardComputer -Computername $Employee.Computername

    ## Set the description for the employee's computer account
    Set-MyAdComputer -Computername $Employee.Computername -Attributes @{'Description' = "$($Employee.FirstName) $($Employee.LastName)'s computer" }

    ## Set the dept the employee is in
    Set-MyAdUser -Username $Username -Attributes @{'Department' = $Employee.Department}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>02_Get-InterestingEventsWithinTimeframe.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>02_Get-InterestingEventsWithinTimeframe.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' This one puts it all together, and has a validation script block BEFORE it runs

&lt;#
.SYNOPSIS
    This script finds all Windows events in all event logs and all log files on a local or remote machine
    recorded within a specific timeframe		
.EXAMPLE
	PS&gt; Get-InterestingEventsWithinTimeframe.ps1 -Computername MYCOMPUTER -StartTimestamp '04-15-15 04:00' -EndTimestamp '04-15-15 08:00' -LogFileExtension 'log'

    This example finds all events and .log files on all drives on the remote computer MYCOMPUTER from April 15th, 2015 at 4AM to April 15th, 2015 at 8AM.
.PARAMETER Computername
    The computer name you'd like to search for text and event logs on.  This defaults to localhost.
.PARAMETER StartTimestamp
    The earliest last write time of a log file and earliest time generated on an event you'd like to find
.PARAMETER EndTimestamp
    The latest last write time of a log file and latest time generated on an event you'd like to find
.PARAMETER LogFileExtension
    When searching log files, this is file extension you will be limiting your search to. This defaults to 'log'
#&gt;
[CmdletBinding()]
param ( #' This 'ValidateScript' tests the assumption that the computer is on-line, the script block returns true if the computer is on, and false if not
    [ValidateScript({Test-Connection -ComputerName $_ -Quiet -Count 1})]     #' The "$_" represents the parameter argument that will be passed to it.
    [string]$Computername = 'localhost',
    [Parameter(Mandatory)]
    [datetime]$StartTimestamp,
    [Parameter(Mandatory)]
    [datetime]$EndTimestamp,
    [string]$LogFileExtension = 'log'
)
begin {                           #' The 'begin' block is where you place code that you want to run only once, regardless if whether the script is used in a pipeline or not
                                  #' This is also a place where you can put functions that will be used in the 'process' block
    . C:\LogInvestigator.ps1
}
process {
	try {
        #' Parameter Hash table
        $Params = @{
            'Computername' = $Computername
            'StartTimestamp' = $StartTimestamp
            'EndTimestamp' = $EndTimestamp
        }
        Get-WinEventWithin @Params
	    Get-TextLogEventWithin @Params -LogFileExtension $LogFileExtension
	} catch {
		Write-Error "$($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>02_LogInvestigator.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>02_LogInvestigator.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' This holds two functions, but more could be added


function Get-WinEventWithin {
	&lt;#
	.SYNOPSIS
	    This function finds all events in all event logs on a local or remote computer between a start and end time	
	.EXAMPLE
		PS&gt; Get-WinEventWithin -StartTimestamp '04-15-15 04:00' -EndTimestamp '04-15-15 08:00'

        This example finds all events in all event logs from April 15th, 2015 at 4AM to April 15th, 2015 at 8AM.
	.PARAMETER Computername
        The computer in which you'd like to find event log entries on.  If this is not specified, it will default to localhost.
	.PARAMETER StartTimestamp
        The earlier time of the event you'd like to find an event 
	.PARAMETER EndTimestamp
        The latest time of the event you'd like to find 
	#&gt;
	[CmdletBinding()]
	param (
        [string]$Computername = 'localhost',
        [Parameter(Mandatory)]
        [datetime]$StartTimestamp,
        [Parameter(Mandatory)]
        [datetime]$EndTimestamp
	)
	process {
		try {
            $Logs = (Get-WinEvent -ListLog * -ComputerName $ComputerName | where { $_.RecordCount }).LogName
            $FilterTable = @{
	            'StartTime' = $StartTimestamp
	            'EndTime' = $EndTimestamp
	            'LogName' = $Logs
            }
		
            Get-WinEvent -ComputerName $ComputerName -FilterHashtable $FilterTable -ErrorAction 'SilentlyContinue'
		} catch {
			Write-Error "$($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
		}
	}
}

function Get-TextLogEventWithin {
	&lt;#
	.SYNOPSIS
	    This function finds all files matching a specified file extension that have a last write time
        between a specific start and end time.
	.EXAMPLE
		PS&gt; Get-TextLogEventWithin -Computername MYCOMPUTER -StartTimestamp '04-15-15 04:00' -EndTimestamp '04-15-15 08:00' -LogFileExtension 'log'

        This example finds all .log files on all drives on the remote computer MYCOMPUTER from April 15th, 2015 at 4AM to April 15th, 2015 at 8AM.
	.PARAMETER Computername
        The computer name you'd like to search for text log on.  This defaults to localhost.
	.PARAMETER StartTimestamp
        The earliest last write time of a log file you'd like to find
	.PARAMETER EndTimestamp
        The latest last write time of a log file you'd like to find
    .PARAMETER LogFileExtension
        The file extension you will be limiting your search to. This defaults to 'log'
	#&gt;
	[CmdletBinding()]
	param (
        [ValidateScript({Test-Connection -ComputerName $_ -Quiet -Count 1})]
        [string]$Computername = 'localhost',
        [Parameter(Mandatory)]
        [datetime]$StartTimestamp,
        [Parameter(Mandatory)]
        [datetime]$EndTimestamp,
        [ValidateSet('txt','log')]
        [string]$LogFileExtension = 'log'
	)
	process {
		try {
            ## Define the drives to look for log files if local or the shares to look for when remote
            if ($ComputerName -eq 'localhost') {
                $Locations = (Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType = '3'").DeviceID
            } else {
                ## Enumerate all shares
                $Shares = Get-CimInstance -ComputerName $ComputerName -Class Win32_Share | where { $_.Path -match '^\w{1}:\\$' }
                [System.Collections.ArrayList]$Locations = @()
                foreach ($Share in $Shares) {
	                $Share = "\\$ComputerName\$($Share.Name)"
	                if (!(Test-Path $Share)) {
		                Write-Warning "Unable to access the '$Share' share on '$Computername'"
	                } else {
		                $Locations.Add($Share) | Out-Null	
	                }
                }
            }

            ## Build the hashtable to perform splatting on Get-ChildItem
            $GciParams = @{
	            Path = $Locations
                Filter = "*.$LogFileExtension"
	            Recurse = $true
	            Force = $true
	            ErrorAction = 'SilentlyContinue'
	            File = $true
            }

            ## Build the Where-Object scriptblock on a separate line due to it's length
            $WhereFilter = {($_.LastWriteTime -ge $StartTimestamp) -and ($_.LastWriteTime -le $EndTimestamp) -and ($_.Length -ne 0)}

            ## Find all interesting log files
    Get-ChildItem @GciParams | Where-Object $WhereFilter
		} catch {
			Write-Error "$($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
		}
	}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_Variables_from_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_Variables_from_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>&lt;#-----------------------------------------------------------------------------
  Beginning PowerShell Scripting for Developers
  Using Variables in PowerShell

  Author: Robert C. Cain | @ArcaneCode | arcanecode@gmail.com
          http://arcanecode.com
 
  This module is Copyright (c) 2015 Robert C. Cain. All rights reserved.
  The code herein is for demonstration purposes. No warranty or guarentee
  is implied or expressly granted. 
  This module may not be reproduced in whole or in part without the express
  written consent of the author. 
-----------------------------------------------------------------------------#&gt;


#-----------------------------------------------------------------------------#
# Variables
#-----------------------------------------------------------------------------#
#region Variables

Clear-Host

# All variables start with a $. Show a simple assignment
$hi = "Hello World"

# Print the value
$hi

# This is a shortcut to Write-Host
Write-Host $hi

# Variables are objects. Show the type
$hi.GetType()

# Display all the members of this variable (object) - This gives list of "extension methods"
$hi | Get-Member

# Use some of those members
$hi.ToUpper()
$hi.ToLower()
$hi.Length

# Types are mutable, this changes it from string to INT
Clear-Host
$hi = 5
$hi.GetType()

$hi | Get-Member    #Now it would have a different set of "extension methods"

# Variables can be strongly typed 
Clear-Host 
[System.Int32]$myint = 42            #EXPLICITY type it for strong typing
$myint
$myint.GetType()

$myint = "This won't work"           #Will throw an error, b/c it is strongly typed as INT

# There are shortcuts for most .net types
Clear-Host
[int] $myotherint = 42               #[int] is a "alias" for [System.Int32]
$myotherint.GetType()

[string] $mystring="PowerShell"
$mystring.GetType()

# Others include short, float, decimal, single, bool, byte, etc

# Not just variables have types - so do static values
"PowerShell Rocks".GetType()

# Accessing methods on objects
"PowerShell Rocks".ToUpper()
"PowerShell Rocks".Contains("PowerShell")

# For nonstrings you need to wrap in () so PS will evaluate as an object, from which we can use "GetType()"
(33).GetType()  


# Comparisons
$var = 33

$var -gt 30
$var -lt 30
$var -eq 33

# List is:
#   -eq        Equals
#   -ne        Not equal to
#   -lt        Less Than
#   -gt        Greater then
#   -le        Less than or equal to
#   -ge        Greater then or equal to

#   -in        See if value in an array
#   -notin     See if a value is missing from an array
#   -Like      Like wildcard pattern matching
#   -NotLike   Not Like 
#   -Match     Matches based on regular expressions
#   -NotMatch  Non-Matches based on regular expressions

# Calculations are like any other language
$var = 3 * 11  # Also uses +, -, and / 
$var

# Supports post unary operators ++ and --
$var++  
$var

# And pre unary operators as well
++$var 
$var

Clear-Host
$var = 33
$post = $var++
$post
$var

Clear-Host
$var = 33
$post = ++$var
$post
$var



# Be cautious of Implicit Type Conversions
"42" -eq 42
42 -eq "42"

# Whatever is on the right is converted to the data type on the left
# Can lead to some odd conversions
42 -eq "042"   # True because the string on the right is coverted to an int
"042" -eq 42   # False because int on the right is converted to a string

##


#-----------------------------------------------------------------------------#
# Built in variables
#-----------------------------------------------------------------------------#
# Automatic Variables
Clear-Host

# False and true
$false
$true

# Null
$NULL

# Current directory
$pwd

# Users Home Directory
$Home  

# Info about a users scripting environment
$host

# Process ID
$PID

# Info about the current version of Powershell
$PSVersionTable

$_   # Current Object
Set-Location "C:\ps\01 - intro"
Get-ChildItem | Where-Object {$_.Name -like "*.ps1"}

#endregion Variables

##



#-----------------------------------------------------------------------------#
# Using the *-Variable cmdlets
#-----------------------------------------------------------------------------#
Clear-Host

# Normal variable usage
$normal = 33
$normal

$text = "In The Morning"
$text


# Long version of $var = 33
New-Variable -Name var -Value 33
$var

# Note if you try to use New-Variable and it already exists, you get an error
# Try again with $var already existing
New-Variable -Name var -Value 99
$var

# Displays the variable and it's value
Get-Variable var -valueonly

Get-Variable var

Get-Variable   # Without params it shows all variables

# Assign a new value to an existing variable
# $var = "In The Morning"
Set-Variable -Name var -Value "In The Morning"
$var

# Clear the contents of a variable
# Same as $var = $null
Clear-Variable -Name var
$var   

# Variable is now set to null, this sets it to empty, even it though it still exists
$var -eq $null

# Even though null, it still exists
Get-Variable var   


# Wipe out a variable, now it will not exist
Remove-Variable -Name var
# Now var is gone, if you try to remove or clear again an error occurs
# (note if you try to access it by just doing a $var the var is recreated)

Get-Variable var   # Now produces an error


##


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>String_numbers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>String_numbers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># String Formatting - C# like syntax is supported
#   In C you'd use a static method (i.e. [string]) with a place holder (i.e. {0} )
[string]::Format("There are {0} items.", $items)

# Powershell shortcut { "-f" is an indicator that is requesting formatting}
# see: http://ss64.com/ps/syntax-f-operator.html for list
		:c	Currency format
		:e	Scientific (exp) notation
		:f	Fixed point
		:f5 = fix to 5 places
		:g	Most compact format, fixed or sci
		:g5 = 5 significant digits
		:n	Number (:nP precision=number of decimal places), includes culture separator for thousands 1,000.00
		:p	percentage
		:r	reversible precision
		:x	Hex format
		:hh
		:mm
		:ss	Convert a DateTime to a 2 digit Hour/minute/second
		"{0:hh}:{0:mm}"
		:ddd	Convert a DateTime to Day of the Week
# Place {0} {1} etc. into the string as placemarkers where you want the variables to appear, 
# immediately follow the string with the -f operator and then lastly, 
#  a list of comma separated variables which will be used to populate the placemarkers.
"There are {0} items." -f $items

"There are {0} items in the location {1}." -f $items, $loc

# You can repeat place holders
"There are {0} items in the location {1}. Wow, {0} is a lot of items!" -f $items, $loc

# Predefined formats - For Decimal Places
# N - Number
"N0 {0:N0} formatted" -f 12345678.119    # N0 12,345,678 formatted           {N0 =&gt; zero places}
"N1 {0:N1} formatted" -f 12345678.119    # N1 12,345,678.1 formatted         {N1 =&gt; one place}
"N2 {0:N2} formatted" -f 12345678.119    # N2 12,345,678.12 formatted        {N2 =&gt; two places}
"N2 {0:N9} formatted" -f 12345678.119    # N2 12,345,678.119000000 formatted {N9 =&gt; 9 places, fill w/ zero}
"N0 {0:N0} formatted"   -f 123.119       # N0 123 formatted                  {N0 =&gt; zero places}
"N0 {0,8:N0} formatted" -f 123.119       # N0      123 formatted             {N0 =&gt; 8 spaces preceding, zero places}

# C - Currency (uses local currency)
"C0 {0:C0} formatted" -f 12345678.1234   # C0 $12,345,678 formatted
"C1 {0:C1} formatted" -f 12345678.1234   # C1 $12,345,678.1 formatted
"C2 {0:C2} formatted" -f 12345678.1234   # C2 $12,345,678.12 formatted

# P - Percentage
"P0 {0:P0} formatted" -f 0.1234          # P0 12 % formatted
"P2 {0:P2} formatted" -f 0.1234          # P2 12.34 % formatted

# X - Hex
"X0 0x{0:X0} formatted" -f 1234          # X0 0x4D2 formatted
"X0 0x{0:X0} formatted" -f 0x4D2         # X0 0x4D2 formatted

# D - Decimal {for integers
"D0 {0:D0} formatted"   -f 12345678      # D0 12345678 formatted
"D8 {0:D8} formatted"   -f 123           # D8 00000123 formatted   {pads it with zeros in the front}
"D0 {0:D0} formatted"   -f 123           # D0      123 formatted
"D0 {0,8:D0} formatted" -f 123           # D0      123 formatted

# Note, decimal only supports INTs. It causes an error, when you use a non-decimal number:
"D0 {0:D0} formatted"   -f 123.1         


                                                                            
# Calculations can be passed in as the item to be formatted                 
"The 20% tip of a 33.33 dollar bill is {0} dollars" -f (33.33 * 0.20)       # The 20% tip of a 33.33 dollar bill is 6.666 dollars

"The 20% tip of a 33.33 dollar bill is {0:0.00} dollars" -f (33.33 * 0.20)  # The 20% tip of a 33.33 dollar bill is 6.67 dollars

##</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Strings_from_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Strings_from_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#-----------------------------------------------------------------------------#
# String Handling
#-----------------------------------------------------------------------------#

# String Quoting 
Clear-Host
"This is a string"                           #Double Qoutes or Single Qoutes
'This is a string too!'

# Mixed quoted
'I just wanted to say "Hello World", OK?'     #Imbed double inside single qoutes
"I can't believe how cool Powershell is!"     #Imbed single inside double qoutes

# You can also double quote to get quotes in strings
"I just wanted to say ""Hello World"", OK?"
'I can''t believe how cool Powershell is!'     # Two single qoutes in a row, produces one single qoute in can't

# Escape Sequences - use the backtick (`) {It is located above the [Tab] key -----}
Clear-Host
#   backspace `b (does not work in ISE, only the regular script window)
"Power`bShell"

#   newline `n          #This puts a new line between the two words
"Power`nShell"

#   carriage return `r (doesn't really show anything, even though it does insert a "Carriage Return")
"Power`rShell"

#   crlf `r`n           (This is good for output)
"Power`r`nShell"

#   tabs                {This gives you tab spacing betwen the words}
"Power`tShell"          

# called "Here Strings" - for large blocks of text ------------------------------ 
# Nothing can follow the [@"] on the first line, and the last ["@] must be in the first column of the last line
# and you can put single and double quotes inside them
Clear-Host
$heretext = @"           
Some text here
Some more here
     a bit more

a blank line above
"@
     
$heretext

# the @ and quote must be last on starting line then first on ending line
# also works with single quotes
$moreheretext = @'
Here we go again
another line here
   let's indent this
   
a blank line above
'@

# note how the nested ' is handled OK, no double quoting needed
$moreheretext



# Without here strings
$sql = 'SELECT col1' `
     + '     , col2' `
     + '     , col3' `
     + '  FROM someTable ' `
     + ' WHERE col1 = ''a value'' '

# With here strings
$sql = @'
SELECT col1
     , col2
     , col3
  FROM someTable
 WHERE col1 = 'a value'
'@</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Windows_10</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Remove_App_Packages</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Windows_10</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Remove_App_Packages</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://www.digitalcitizen.life/how-remove-default-windows-10-apps-powershell-3-steps
This removes CORE Apps

'in order for you to properly run this command, you’ll have to know the "full package name" of the app (NOT the name) you want to uninstall. 
'To find the app’s package name, you first have to list all the apps installed on your Windows 10 computer:

 Get-AppxPackage
 
 'The Uninstall Commands For Windows 10 Core Apps
 ==================================================================================CAUTION !
 'there is one app which we highly recommend that you do not uninstall: the Store. 
 'If you choose to remove the Store from your Windows 10 device, 
 'you won't be able to reinstall any universal app afterwards. 
 'You won't be able to do it even if you refresh or reset your Windows 10 computer. 
 'The only way to get the Store back, and then be able to install other apps, 
 'is to make a clean Windows 10 installation.
 ================================================================================================
 
 
Uninstall 3D Builder: Get-AppxPackage *3dbuilder* | Remove-AppxPackage
Uninstall Alarms and Clock: Get-AppxPackage *alarms* | Remove-AppxPackage
Uninstall Calculator: Get-AppxPackage *calculator* | Remove-AppxPackage
Uninstall Calendar and Mail: Get-AppxPackage *communications* | Remove-AppxPackage
Uninstall Camera: Get-AppxPackage *camera* | Remove-AppxPackage
Uninstall Get Office: Get-AppxPackage *officehub* | Remove-AppxPackage
Uninstall Get Skype: Get-AppxPackage *skypeapp* | Remove-AppxPackage
Uninstall Get Started: Get-AppxPackage *getstarted* | Remove-AppxPackage
Uninstall Groove Music: Get-AppxPackage *zunemusic* | Remove-AppxPackage
Uninstall Maps: Get-AppxPackage *maps* | Remove-AppxPackage
Uninstall Microsoft Solitaire Collection: Get-AppxPackage *solitairecollection* | Remove-AppxPackage
Uninstall Money: Get-AppxPackage *bingfinance* | Remove-AppxPackage
Uninstall Movies &amp; TV: Get-AppxPackage *zunevideo* | Remove-AppxPackage
Uninstall News: Get-AppxPackage *bingnews* | Remove-AppxPackage
Uninstall OneNote: Get-AppxPackage *onenote* | Remove-AppxPackage
Uninstall People: Get-AppxPackage *people* | Remove-AppxPackage
Uninstall Phone Companion: Get-AppxPackage *windowsphone* | Remove-AppxPackage
Uninstall Photos: Get-AppxPackage *photos* | Remove-AppxPackage
Uninstall Store: Get-AppxPackage *windowsstore* | Remove-AppxPackage
Uninstall Sports: Get-AppxPackage *bingsports* | Remove-AppxPackage
Uninstall Voice Recorder: Get-AppxPackage *soundrecorder* | Remove-AppxPackage
Uninstall Weather: Get-AppxPackage *bingweather* | Remove-AppxPackage
Uninstall Xbox: Get-AppxPackage *xbox* | Remove-AppxPackage</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_WMI</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_WMI</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_WMI</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_WMI</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_WMI

ref: http://www.darkoperator.com/blog/2013/1/31/introduction-to-wmi-basics-with-powershell-part-1-what-it-is.html

WMI (Windows Management Instrumentation)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Loop_Get-Content_into_PIPELINE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Loop_Get-Content_into_PIPELINE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
=======================example of using Get-Content into Pipeline function
'USAGE

'1] The Input file
LT-103336
LT-103110

'2] Call the function, and assign the items in the list to the 'Name' variable
'	Basically, the select operation is turning the object into a property value. 

&gt;$Computers = get-content computers_2.txt -OutVariable Name;
&gt;$Computers  | Select @{ Name = "Name"; Expression = {$_}} | Get-FirewallState ;


'OR
'3]

$Computers = get-content computers_2.txt -OutVariable Name;
$Computers  | Get-FirewallState -Hostname {$_} ;

=======================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FOLDERS_Blocked_Inheritance</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FOLDERS_Blocked_Inheritance</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://www.petri.com/identify-folders-with-blocked-inheritance-using-powershell
'AreAccessRulesProtected is a boolean property. If the value is true, then inheritance has been disabled. 
cls
dir 'C:\Program Files' -Directory | get-acl | 
Select @{Name="Path";Expression={Convert-Path $_.Path}},AreAccessRulesProtected |
Format-table -AutoSize
#' If the value is true, then inheritance has been disabled

--------------

'Because the AreAccessRulesProtected property is a boolean, you don’t need to use the –eq operator, 
'	so it’s a simple matter to filter out folders that have blocked inheiritance
dir c:\work -Directory -recurse | get-acl | 
Where {$_.AreAccessRulesProtected} | 
Select @{Name="Path";Expression={Convert-Path $_.Path}},AreAccessRulesProtected |
format-table -AutoSize
'These are the folders under C:\Work that have inheritance disabled.
'If I want to find folders that have inheritance enabled, then I can use the –NOT operator in my filter.

-----------------
'This on the other had is the folders w/ blocked inheritance:
cls
dir 'C:\Program Files' -Directory -recurse | get-acl | 
Where  {-not $_.AreAccessRulesProtected} | 
Select @{Name="Path";Expression={Convert-Path $_.Path}},AreAccessRulesProtected |
format-table -AutoSize


====================================================
'Let’s say you want to re-enable inheritance once you’ve identified folders with blocked inheritance. The following outlines a simple way to do so.

'First, we need the access control list for a folder.
&gt;$acl = get-acl c:\work\demo2
'To modify, we can use the SetAccessRuleProtection() method, which takes a few parameters.

------------
'This will let you see the overloads
$acl.SetAccessRuleProtection.OverloadDefinitions
-----------

'The parameter values are both boolean. 
'The second parameter indicates if you want to save existing rules, and I generally do.

&gt;$acl.SetAccessRuleProtection($False,$True)

'All I’ve done is set the property on the ACL object. It hasn’t been applied to the folder. 
'To accomplish that, I need to use Set-ACL.

&gt;set-acl -Path c:\work\demo2 -AclObject $acl

==============================================================
'To make life easier, I have a function called Set-Inheritance.

#requires -version 3.0
 
Function Set-Inheritance {
 
[cmdletbinding(SupportsShouldProcess)]
 
	Param(
		[Parameter(Position=0,Mandatory,HelpMessage="Enter the file or folder path",
		 ValueFromPipeline=$True,ValueFromPipelineByPropertyName)]
	[ValidateNotNullOrEmpty()]
	[Alias("PSPath")]
	[string]$Path,
	[switch]$NoInherit,
	[switch]$NoPreserve,
	[switch]$Passthru
)

'With this function, I can easily reset inheritance with a one-line command:
&gt;dir c:\work -Directory -recurse | get-acl | Where {$_.AreAccessRulesProtected} | set-inheritance -whatif

'If I intentionally want to disable or block inheritance, I can do that as well.
&gt;Set-Inheritance C:\work\demo1 -NoInherit

'Be careful about using the –NoPreserve parameter with my function. If you use it all existing permissions will be wiped out</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_MISC</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>URL_WSDL_LookUp</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_MISC</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>URL_WSDL_LookUp</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.reddit.com/r/sysadmin/comments/2ls3ny/best_way_to_find_computer_age/

The basic to get the warranty info back from Dell, though is:
$Serial="XYZ" #(Would likely pipe this from a list or WMI
$proxy = New-WebServiceProxy -URI "http://xserv.dell.com/services/assetservice.asmx?WSDL" if (!$?) { Write-Error "Error accessing webservice" -warning; continue } $proxy.Url = "http://xserv.dell.com/services/AssetService.asmx" $WarrantyInformation = $proxy.GetAssetInformation(([guid]::NewGuid()).Guid, 'DellWarranty', $Serial) | Select-Object -ExpandProperty Entitlements
$WarrantyInformation.startdate | sort -unique | select -first 1


--==============


Workaround appears to be registering with techdirect.dell.com ( https://techdirect.dell.com/portal.30/Login.aspx ) and receiving an API key.
Then you can run something like:
Invoke-RestMethod -URI "https://api.dell.com/support/v2/assetinfo/header/tags.xml?svcta</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Computer_Age_using_WSDL_Lookup</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Computer_Age_using_WSDL_Lookup</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.reddit.com/r/sysadmin/comments/2ls3ny/best_way_to_find_computer_age/


'http://poshcode.org/4121 is a script I had at some point, though I'd use the below over that. I think the one I actually use now is slightly different but same API, I merged my HP and Dell lookups.
'The basic to get the warranty info back from Dell, though is:

$Serial="XYZ" #(Would likely pipe this from a list or WMI
$proxy = New-WebServiceProxy -URI "http://xserv.dell.com/services/assetservice.asmx?WSDL" if (!$?) { Write-Error "Error accessing webservice" -warning; continue } $proxy.Url = "http://xserv.dell.com/services/AssetService.asmx" $WarrantyInformation = $proxy.GetAssetInformation(([guid]::NewGuid()).Guid, 'DellWarranty', $Serial) | Select-Object -ExpandProperty Entitlements
$WarrantyInformation.startdate | sort -unique | select -first 1

'the last line would then give you your start date of your Dell warranty. You could pipe the list of serial #s by querying AD and polling each for WMI, but the preferred way in this case would be a list of system serial #s that you may have from another system, as then you wouldn't be dependent upon that system actually being online at the time to do the lookup of serial #. I have a powershell script to do similar w/ HP but it's a lot more involved.
'I personally use this for almost the same purpose--aging systems that are up for replacement--but we go by warranty expiration so it's the opposite date I am looking at. The only caveat on that end w/ Dell lookups is they include a super-long "Dell Digitial Delivery" period with a service level code "D" and "dell" entitlement type comes back with code "DL" that's also just a few days after the end of all entitlements; so you have to exclude warranty types with servicelevelcode set to "DL" or "D" to be really accurate. For start date it shouldn't matter, though.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Warranty_WDSL_Dell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Warranty_WDSL_Dell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
http://www.sysadminsblog.com/scripting/powershell/dell-warranty-information-api/

NOTE: the problem appears to be the API keys, you must be a DELL developer

This was from 2014
#'I’ve always used the SOAP API that’s provided by Dell, 
#'	however recently it stopped working due to a misconfiguration in the service. 
#'	This triggered me to find a different solution and luckily 
#'	Dell also provides a REST API that is even simpler, 
#'	gives more detailed information and actually still works.
#'
#'There are 3 APIs available at the moment, 
#'	but I will only dig into the warranty status as that is the most useful.
#'
#'Functional specification of the warranty status 
#'	API: http://en.community.dell.com/dell-groups/supportapisgroup/m/mediagallery/20438177/download.aspx
#'

Function Global:Get-DellAssetInformation {
    Param([String]$ServiceTag = $(Get-WmiObject -Class "Win32_Bios").SerialNumber)
    Try {
        # Possible API keys
        # 1adecee8a60444738f280aad1cd87d0e
        # d676cf6e1e0ceb8fd14e8cb69acd812d
        # 849e027f476027a394edd656eaef4842
        $APIKey = "1adecee8a60444738f280aad1cd87d0e"
        '$DellURL = "https://api.dell.com/support/v2/assetinfo/warranty/tags.xml?svctags=$ServiceTag&amp;apikey=$APIKey"
 		$DellURL = “https://api.dell.com/support/v2/assetinfo/warranty/tags.xmlsvctags=${ServiceTag}&amp;apikey=${APIKey}”
        $XML = New-Object System.Xml.XmlDocument
        $XML.Load($DellURL)
        $XML.GetAssetWarrantyResponse.GetAssetWarrantyResult.Response.DellAsset
        $XML.GetAssetWarrantyResponse.GetAssetWarrantyResult.Response.DellAsset.Warranties.Warranty
    }
    Catch {
        Write-Host $($_.Exception.Message)
    }
}


'Once you run this bit of code you can use the following 
'to get the detailed information.

'To get the information for the local machine use:

Get-DellAssetInformation
'To get the information for a different ServiceTag use the following:

Get-DellAssetInformation -ServiceTag AB12AB1
'If you have questions or comments, please post it below!

More information: http://en.community.dell.com/dell-groups/supportapisgroup/


'COMMENT
'==========
'There is a mistype on $DellURL variable.
'it should be
$DellURL = “https://api.dell.com/support/v2/assetinfo/warranty/tags.xmlsvctags=${ServiceTag}&amp;apikey=${APIKey}”

</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>