<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>eMail</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_for_BCC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>eMail</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_for_BCC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#email_LIST_of_REMOTE_logins_for_all_SERVERS_on_our_Network.psf


# Import the Active Directory module for the Get-ADComputer CmdLet 
Import-Module ActiveDirectory 
 
# Get today's date for the report 
$today = Get-Date 
 
# Setup email parameters 
$subject = "ACTIVE SERVER SESSIONS REPORT - " + $today 
$priority = "Normal" 
$smtpServer = "Barriere-com.mail.protection.outlook.com" 
$emailFrom = "DoNotReply@barriere.com" 
$emailTo = "glenng@barriere.com" 
 
# Create a fresh variable to collect the results. You can use this to output as desired 
$SessionList = "ACTIVE SERVER SESSIONS REPORT - " + $today + "`n`n" 
 
# Query Active Directory for computers running a Server operating system 
$Servers = Get-ADComputer -Filter {OperatingSystem -like "*server*"} 
 
# Loop through the list to query each server for login sessions 
ForEach ($Server in $Servers) { 
    $ServerName = $Server.Name 
 
    # When running interactively, uncomment the Write-Host line below to show which server is being queried 
    # Write-Host "Querying $ServerName" 
 
    # Run the qwinsta.exe and parse the output 
    $queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "\s+",","))} | ConvertFrom-Csv)  
     
    # Pull the session information from each instance 
    ForEach ($queryResult in $queryResults) { 
        $RDPUser = $queryResult.USERNAME 
        $sessionType = $queryResult.SESSIONNAME 
         
        # We only want to display where a "person" is logged in. Otherwise unused sessions show up as USERNAME as a number 
        If (($RDPUser -match "[a-z]") -and ($RDPUser -ne $NULL)) {  
            # When running interactively, uncomment the Write-Host line below to show the output to screen 
            # Write-Host $ServerName logged in by $RDPUser on $sessionType 
            $SessionList = $SessionList + "`n`n" + $ServerName + " logged in by " + $RDPUser + " on " + $sessionType 
        } 
    } 
} 
 
# Send the report email 
# Send-MailMessage -To $emailTo -Subject $subject -Body $SessionList -SmtpServer $smtpServer -From $emailFrom -Priority $priority 
 
# When running interactively, uncomment the Write-Host line below to see the full list on screen 
$SessionList </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>All_Groups_and_All_Members</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>All_Groups_and_All_Members</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://serverfault.com/questions/532945/list-all-groups-and-their-members-with-powershell-on-win2008r2


'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Import-Module ActiveDirectory

$Groups = (Get-AdGroup -filter * | Where {$_.name -like "**"} | select name -ExpandProperty name)

$Table = @()

$Record = @{
  "Group Name" = ""
  "Name" = ""
  "Username" = ""
}


Foreach ($Group in $Groups) {

  $Arrayofmembers = Get-ADGroupMember -identity $Group -recursive | select name,samaccountname

  foreach ($Member in $Arrayofmembers) {
    $Record."Group Name" = $Group
    $Record."Name" = $Member.name
    $Record."UserName" = $Member.samaccountname
    $objRecord = New-Object PSObject -property $Record
    $Table += $objrecord

  }
}

$Table | export-csv "C:\temp\SecurityGroups.csv" -NoTypeInformation

'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

$Groups = Get-ADGroup -Properties * -Filter * -SearchBase "OU=Groups,DC=corp,DC=ourcompany,DC=Com" 
Foreach($G In $Groups)
{
    Write-Host $G.Name
    Write-Host "-------------"
    $G.Members
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_AD</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>List_users_in_a_group</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_AD</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>List_users_in_a_group</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Get-ADGroupMember -Identity 'Domain Admins' | Export-CSV DomainAdmins.csv</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_and_DotNet</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Add_method_to_existing_object_from_a_Pipe</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_and_DotNet</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Add_method_to_existing_object_from_a_Pipe</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'-----------------------------------------------------------------------------#'
#' Demo 10 - Add to an existing object
#' Get-ChildItem will get list of files in the given folder
#' This demo adds a 'function' (i.e. a script block) to the objects returned by 'Get-ChildItem' 
#'-----------------------------------------------------------------------------#'

#' Define the custom script method that returns a value based on the extension of the file object
$script = { 
            $retValue = "Unknown"

            if($this.Extension -eq '.ps1')
            {
              $retValue = 'Script'
            }
            else
            {
              $retValue = 'Not A Script'
            }

            return $retValue
          }

#' Load a variable with a collection of file objects
Set-Location "C:\DATA\psScripts"
$items = Get-ChildItem

#' Add script property to the each file object in bulk
$items | Add-Member -MemberType ScriptMethod `                          #'&lt;====== Pipe the collection of objects to Add-Member (to add the script block)
                    -Name 'ScriptType' `
                    -Value $script                                      #'&lt;====== The 'Value' is the script block


#' Now, for illustrative purposes, add another property to 
#' each item using a foreach loop
$itemCount = 0
foreach($item in $items)
{
  $itemCount++

  #' Add a note property, setting it to the current item counter
  #' Could have also used $item | Add-Member...
  Add-Member -InputObject $item `
             –MemberType NoteProperty `
             –Name ItemNumber `
             –Value $itemCount
  
  #' Display the results of the file object with the new 
  #' property and script (function) added
  "$($item.ItemNumber): $($item.Name) = $($item.ScriptType())"
}
#'======================================================OUTPUT================
#'  1: Count_And_List_Sessions_on_BCC-EXPLORER3.ps1 = Script
#'  2: email_LIST_of_REMOTE_logins_for_all_SERVERS_on_our_Network.psf.ps1 = Script
#'  3: Get-IPDetails.PS1 = Script
#'  4: Get-MachineIPDetails.PS1 = Script
#'  5: Get-SubNetItems.txt = Not A Script
#'  6: Get-UserSession.ps1 = Script
#'  7: LIST_to_CSV_All_Groups_All_Users.ps1 = Script
#'  8: LogOff_DisconnectedSessions_on_server.ps1 = Script
#'  9: Query_Remote_Sessions_on_a_Server.ps1 = Script
#'  10: Set_Environment_To_Include_Modules.ps1 = Script</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_browser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Clear_Cache</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_browser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Clear_Cache</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'https://github.com/lemtek/Powershell/blob/master/Clear_Browser_Caches


Write-Host -ForegroundColor yellow "#######################################################"
""
Write-Host -ForegroundColor Green "Powershell commands to delete cache &amp; cookies in Firefox, Chrome &amp; IE browsers"
Write-Host -ForegroundColor Green "By Lee Bhogal, Paradise Computing Ltd - June 2014"
Write-Host -ForegroundColor Green "VERSION: 2"
""
Write-Host -ForegroundColor yellow "#######################################################"
""
Write-Host -ForegroundColor Green "CHANGE_LOG:
v2.4: - Resolved *.default issue, issue was with the file path name not with *.default, but issue resolved
v2.3: - Added Cache2 to Mozilla directories but found that *.default is not working
v2.2: - Added Cyan colour to verbose output
v2.1: - Added the location 'C:\Windows\Temp\*' and 'C:\`$recycle.bin\'
v2:   - Changed the retrieval of user list to dir the c:\users folder and export to csv
v1:   - Compiled script"
""
Write-Host -ForegroundColor yellow "#######################################################"
""
#########################
"-------------------"
Write-Host -ForegroundColor Green "SECTION 1: Getting the list of users"
"-------------------"
# Write Information to the screen
Write-Host -ForegroundColor yellow "Exporting the list of users to c:\users\%username%\users.csv"
# List the users in c:\users and export to the local profile for calling later
dir C:\Users | select Name | Export-Csv -Path C:\users\$env:USERNAME\users.csv -NoTypeInformation
$list=Test-Path C:\users\$env:USERNAME\users.csv
""
#########################
"-------------------"
Write-Host -ForegroundColor Green "SECTION 2: Beginning Script..."
"-------------------"
if ($list) {
    "-------------------"
    #Clear Mozilla Firefox Cache
    Write-Host -ForegroundColor Green "SECTION 3: Clearing Mozilla Firefox Caches"
    "-------------------"
    Write-Host -ForegroundColor yellow "Clearing Mozilla caches"
    Write-Host -ForegroundColor cyan
    Import-CSV -Path C:\users\$env:USERNAME\users.csv -Header Name | foreach {
            Remove-Item -path C:\Users\$($_.Name)\AppData\Local\Mozilla\Firefox\Profiles\*.default\cache\* -Recurse -Force -EA SilentlyContinue -Verbose
            Remove-Item -path C:\Users\$($_.Name)\AppData\Local\Mozilla\Firefox\Profiles\*.default\cache\*.* -Recurse -Force -EA SilentlyContinue -Verbose
	    Remove-Item -path C:\Users\$($_.Name)\AppData\Local\Mozilla\Firefox\Profiles\*.default\cache2\entries\*.* -Recurse -Force -EA SilentlyContinue -Verbose
            Remove-Item -path C:\Users\$($_.Name)\AppData\Local\Mozilla\Firefox\Profiles\*.default\thumbnails\* -Recurse -Force -EA SilentlyContinue -Verbose
            Remove-Item -path C:\Users\$($_.Name)\AppData\Local\Mozilla\Firefox\Profiles\*.default\cookies.sqlite -Recurse -Force -EA SilentlyContinue -Verbose
            Remove-Item -path C:\Users\$($_.Name)\AppData\Local\Mozilla\Firefox\Profiles\*.default\webappsstore.sqlite -Recurse -Force -EA SilentlyContinue -Verbose
            Remove-Item -path C:\Users\$($_.Name)\AppData\Local\Mozilla\Firefox\Profiles\*.default\chromeappsstore.sqlite -Recurse -Force -EA SilentlyContinue -Verbose
            }
    Write-Host -ForegroundColor yellow "Clearing Mozilla caches"
    Write-Host -ForegroundColor yellow "Done..."
    ""
    "-------------------"
    # Clear Google Chrome 
    Write-Host -ForegroundColor Green "SECTION 4: Clearing Google Chrome Caches"
    "-------------------"
    Write-Host -ForegroundColor yellow "Clearing Google caches"
    Write-Host -ForegroundColor cyan
    Import-CSV -Path C:\users\$env:USERNAME\users.csv -Header Name | foreach {
            Remove-Item -path "C:\Users\$($_.Name)\AppData\Local\Google\Chrome\User Data\Default\Cache\*" -Recurse -Force -EA SilentlyContinue -Verbose
Remove-Item -path "C:\Users\$($_.Name)\AppData\Local\Google\Chrome\User Data\Default\Cache2\entries\*" -Recurse -Force -EA SilentlyContinue -Verbose
            Remove-Item -path "C:\Users\$($_.Name)\AppData\Local\Google\Chrome\User Data\Default\Cookies" -Recurse -Force -EA SilentlyContinue -Verbose
            Remove-Item -path "C:\Users\$($_.Name)\AppData\Local\Google\Chrome\User Data\Default\Media Cache" -Recurse -Force -EA SilentlyContinue -Verbose
            Remove-Item -path "C:\Users\$($_.Name)\AppData\Local\Google\Chrome\User Data\Default\Cookies-Journal" -Recurse -Force -EA SilentlyContinue -Verbose
            # Comment out the following line to remove the Chrome Write Font Cache too.
            # Remove-Item -path "C:\Users\$($_.Name)\AppData\Local\Google\Chrome\User Data\Default\ChromeDWriteFontCache" -Recurse -Force -EA SilentlyContinue -Verbose
            }

    Write-Host -ForegroundColor yellow "Done..."
    ""
    "-------------------"
    # Clear Internet Explorer
    Write-Host -ForegroundColor Green "SECTION 5: Clearing Internet Explorer Caches"
     "-------------------"
    Write-Host -ForegroundColor yellow "Clearing Google caches"
    Write-Host -ForegroundColor cyan
    Import-CSV -Path C:\users\$env:USERNAME\users.csv | foreach {
            Remove-Item -path "C:\Users\$($_.Name)\AppData\Local\Microsoft\Windows\Temporary Internet Files\*" -Recurse -Force -EA SilentlyContinue -Verbose
	    Remove-Item -path "C:\Users\$($_.Name)\AppData\Local\Microsoft\Windows\WER\*" -Recurse -Force -EA SilentlyContinue -Verbose
	    Remove-Item -path "C:\Users\$($_.Name)\AppData\Local\Temp\*" -Recurse -Force -EA SilentlyContinue -Verbose
	    Remove-Item -path "C:\Windows\Temp\*" -Recurse -Force -EA SilentlyContinue -Verbose
	    Remove-Item -path "C:\`$recycle.bin\" -Recurse -Force -EA SilentlyContinue -Verbose
            }

    Write-Host -ForegroundColor yellow "Done..."
    ""
    Write-Host -ForegroundColor Green "All Tasks Done!"
    } else {
	Write-Host -ForegroundColor Yellow "Session Cancelled"	
	Exit
	}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_browser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>URL of each Favorite in alphabetical order =&gt; CSV file on Desktop</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_browser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>URL of each Favorite in alphabetical order =&gt; CSV file on Desktop</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'# URL of each Favorite in alphabetical order =&gt; CSV file on Desktop

# Gathers a list of the current users IE Favorites
Get-ChildItem $env:userprofile\favorites -Recurse -Include *.url |
 where {select-string -InputObject $_ -Quiet "^URL=http"} | 
 select @{Name="Name"; Expression={[IO.Path]::GetFileNameWithoutExtension($_.FullName)}},
 @{Name="URL"; Expression={get-content $_ | ? {$_ -match "^URL=http"} | % {$_.Substring(4)}}} |
#Sorts and exports them to a CSV on user's Desktop
 sort Name |Export-Csv -Path $env:userprofile\Desktop\favorites.csv -NoTypeInformation
#Opens the CSV file for reading
Invoke-Item $env:userprofile\Desktop\favorites.csv


'# OUTPUT
'=================================================================================
'Name							URL
'Access Achieve					https://magellan.learn.com/laprovider
'Anasazi - Logon					https://ansoaz.cernerworks.com/JEF/auth/login.aspx
'Bing							http://go.microsoft.com/fwlink/p/?LinkId=255142
'Clicial Advisor					https://ca.magellanhealth.com/vpn/index.html
'Contacts - New					http://wbsql1/Reports_PROD/report/Reports_For_All_Users/001_Telephone_Contacts
'Dev Essentials  - Visual Studio	https://www.visualstudio.com/dev-essentials/
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_open_Close_file</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_open_Close_file</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'Actually, Powershell ISE will keep a file open after your script runs until you close the ISE.  
'I know because I am running a script right now which creates a file and then emails it as an attachment.  
'But I can not delete the file in Explorer because " . . . file is open in Windows PowerShell ISE."  
'Also, the PS script can not overwrite the file because the SMTP portion of the PS script will not close the file. 

' I may have found a way... 
        $file = Get-ChildItem  -LiteralPath $path
        $stream = $file.OpenRead()
        ...
        $stream.Close()

'It's the .close() part at the end that makes all the difference.

==============================================================================
'You don't need to explicitly create, open, or close a file in Powershell. 
'Here are some ways to write to a file, in addition to New-Item:

$text = 'Hello World'

# Create file:

$text | Set-Content 'file.txt'
#or
$text | Out-File 'file.txt'
#or
$text &gt; 'file.txt'

# Append to file:

$text | Add-Content 'file.txt'
#or
$text | Out-File 'file.txt' -Append
#or
$text &gt;&gt; 'file.txt'


===========================================================


$path = '[your path here]'
$file = '[your TXT filename here].txt'
$file2 = '[your CSV filename here].csv'

New-Item -path $path -Name $file -Value 'Test of creating a new file using the New-Item cmdlet. So there!!!' -ItemType file -force
New-Item -path $path -Name $file2 -Value 'Test of creating a new file using the New-Item cmdlet. So there!!!' -ItemType file -force
# get-help new-item -Examples</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CSV_output___replace_spaces_with_COMMAs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CSV_output___replace_spaces_with_COMMAs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'We are taking each line of the output from the command, trimming the content and replacing the spaces with commas 
' and then piping it to a ConvertFrom-CSV to put the content into a table array with the appropriate headers 
'	of USERNAME and SESSIONNAME which is the information we are looking for. 
$queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "s+",","))} | ConvertFrom-Csv)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>CSV_output</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>CSV_output</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Get-Process | Export-Csv c:\scripts\test.txt</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LIST_Files_in_Folders_and_SubFolders</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LIST_Files_in_Folders_and_SubFolders</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'LIST_Files_in_Folders_and_SubFolders

 'Get all the PDF files in the folder/subfolders of  "D:\xplr" and write as .csv to: "C:\JUNK\directory.csv"
 Get-ChildItem -Path D:\xplr -Include *.pdf -Recurse | Export-Csv -Force -NoTypeInformation C:\JUNK\directory.csv

'Just a list of files and folders in a folder:, but not subfolders
Get-ChildItem -Path E:\music

'This would be the command to see only the directories at the E:\Music level:
Get-ChildItem -Path E:\music –Directory

'To see only the files at this level, I change it to use the –File switch:
Get-ChildItem -Path E:\music –File

'When I use the –Recurse switch, I can see the folders in addition to the files inside each of the folders.
' but it is not clean like a database, but rather formatted and broken up by folder
Get-ChildItem -Path E:\music\Santana –Recurse

'This sorts it, BUT still not right for a database, b/c it is formatted, and broken up by folders
Get-ChildItem -Path E:\music\Santana -Recurse -File | sort length –Descending

'tems that are normally invisible in File Explorer or Cmd.exe are not displayed in the output of a Get-ChildItem command. 
'	To display hidden items, use the Force parameter of Get-ChildItem. For example:
Get-ChildItem -Path C:\Windows -Force

'To find all files that begin with the letter x in the Windows directory, type:
 Get-ChildItem -Path C:\Windows\x*
 
'To find all files whose names begin with x or z, type:
Get-ChildItem -Path C:\Windows\[xz]*

'You can omit files that have any of these numbers in their names by using the Exclude parameter with the pattern *[9516]*:
Get-ChildItem -Path C:\WINDOWS\System32\w*32*.dll -Exclude *[9516]*

'To specify a recursive search for files whose names match a special pattern, use the -Include parameter.
&gt; Get-ChildItem -Path C:\Windows -Include *.dll -Recurse -Exclude [a-y]*.dll

'This one-line command will invoke Windows PowerShell to write a directory listing to a CSV file, 
'which is easy to use in spreadsheets and database programs. 
'It recurses subfolders, and it includes the following information: 
'			full file name, creation time, last modified time, file size, and owner (last modified by).


powershell "Get-ChildItem -Recurse c:\directory\to\scan\ | ForEach-Object {$_ | add-member -name "Owner" -membertype noteproperty -value (get-acl $_.fullname).owner -passthru} | Sort-Object fullname | Select FullName,CreationTime,LastWriteTime,Length,Owner | Export-Csv -Force -NoTypeInformation c:\folder\to\directory.csv"


'to limit to folders add 
	"| ?{ $_.PSIsContainer }" 
	'before 
	"| ForEach-Object" 		'(no quotation marks)
	
'this version uses relative paths (code not tested)
powershell "Get-ChildItem -Recurse . | ?{ $_.PSIsContainer } | ForEach-Object {$_ | add-member -name "Owner" -membertype noteproperty -value (get-acl $_.fullname).owner -passthru} | Sort-Object fullname | Select FullName,CreationTime,LastWriteTime,Length,Owner | Export-Csv -Force -NoTypeInformation .\directory.csv" 	

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


Get-ChildItem -Recurse 'W:\Equipment Titles and Registrations' |
     ForEach-Object {$_ |
                            add-member -name "Owner" -membertype noteproperty -value (get-acl $_.fullname).Owner -passthru       
                    } |   
     ForEach-Object {$_ |
                            add-member -name "TheFileName" -membertype noteproperty -value  $_.name -passthru    
                    } |                                    
       Sort-Object fullname |
        Select FullName,CreationTime,LastWriteTime,Length,Owner,TheFileName |
         Export-Csv -Force -NoTypeInformation c:\directory.csv

'OUTPUT:============================================================================================================
FullName																CreationTime	LastWriteTime	Length	Owner					TheFileName
C:\Junk\Report Project1													11/6/2015 16:47	11/6/2015 16:47			BUILTIN\Administrators	Report Project1
C:\Junk\Report Project1\Report Project1									11/6/2015 16:47	11/6/2015 16:47			BUILTIN\Administrators	Report Project1
C:\Junk\Report Project1\Report Project1.sln								11/6/2015 16:47	11/6/2015 16:47	1342	BUILTIN\Administrators	Report Project1.sln
C:\Junk\Report Project1\Report Project1\Report Project1.rptproj			11/6/2015 16:47	2/6/2014 13:49	204		BUILTIN\Administrators	Report Project1.rptproj
C:\Junk\Report Project1\Report Project1\Report Project1.rptproj.user	11/6/2015 16:47	11/9/2015 7:45	1076	BUILTIN\Administrators	Report Project1.rptproj.user
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Permissions_recursive_on_items_in_Directory</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Permissions_recursive_on_items_in_Directory</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code> 
 #' This is just a huge list by folder
 #' You have to CD to the target folder, and it saves the output file
 #' to the target folder
 Get-ChildItem -Recurse | where-object {($_.PsIsContainer)} | get-acl | format-list &gt; permission.txt
 
 =================================================================
 #' This is 3 column output: User, Access, folder
 #' You have to CD to the target folder, and it saves the output file
 #' to the target folder 
 
 Get-childitem \\jphsa.org\shared\Data\CPS -recurse | where{$_.psiscontainer} |
Get-Acl | % {
    $path = $_.Path
    $_.Access | % {
        New-Object PSObject -Property @{
            Folder = $path.Replace("Microsoft.PowerShell.Core\FileSystem::","")
            Access = $_.FileSystemRights
            Control = $_.AccessControlType
            User = $_.IdentityReference
            Inheritance = $_.IsInherited
            }
        }
    } | select-object -Property User, Access, Folder | export-csv output.csv -force
    
#' Sample output
User				Access						Folder
JPHSA01\tjohnson	Modify, Synchronize			\\jphsa.org\shared\Data\CPS\Aftercare Records
JPHSA01\dharris		Modify, Synchronize			\\jphsa.org\shared\Data\CPS\Aftercare Records
JPHSA01\ERiehl		Modify, Synchronize			\\jphsa.org\shared\Data\CPS\Aftercare Records
JPHSA01\CPS			ReadAndExecute, Synchronize	\\jphsa.org\shared\Data\CPS\Aftercare Records

 =================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_LogParser</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_LogParser</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_LogParser

http://logparserplus.com

HELP:  &gt;logparser.exe /h


As a quick reminder, Log Parser supports the following built-in input formats:

IIS Log File Input Formats
=========================
IISW3C: parses IIS log files in the W3C Extended Log File Format.
	This works with 'iCheckpoint'
	NOTE: -w3c did not work with 'iCheckpoint'
	https://www.microsoft.com/technet/prodtechnol/WindowsServer2003/Library/IIS/676400bc-8969-4aa7-851a-9319490a9bbb.mspx?mfr=true	
	http://words.strivinglife.com/post/A-brief-overview-of-IIS-60-and-the-W3C-extended-log-format/
	
IIS: parses IIS log files in the Microsoft IIS Log File Format.
	https://www.microsoft.com/technet/prodtechnol/WindowsServer2003/Library/IIS/be22e074-72f8-46da-bb7e-e27877c85bca.mspx?mfr=true
	
BIN: parses IIS log files in the Centralized Binary Log File Format.
IISODBC: returns database records from the tables logged to by IIS when configured to log in the ODBC Log Format.
HTTPERR: parses HTTP error log files generated by Http.sys.
URLSCAN: parses log files generated by the URLScan IIS filter.

Generic Text File Input Formats
=========================
CSV: parses comma-separated values text files.
TSV: parses tab-separated and space-separated values text files.
XML: parses XML text files.
W3C: parses text files in the W3C Extended Log File Format.
NCSA: parses web server log files in the NCSA Common, Combined, and Extended Log File Formats.
TEXTLINE: returns lines from generic text files.
TEXTWORD: returns words from generic text files.

System Information Input Formats
=========================
EVT: returns events from the Windows Event Log and from Event Log backup files (.evt files).
FS: returns information on files and directories.
REG: returns information on registry values.
ADS: returns information on Active Directory objects.

Special-purpose Input Formats
=========================
NETMON: parses network capture files created by NetMon.
ETW: parses Enterprise Tracing for Windows trace log files and live sessions.
COM: provides an interface to Custom Input Format COM plug-ins.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>help</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>help</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Microsoft (R) Log Parser Version 2.2.10
Copyright (C) 2004 Microsoft Corporation. All rights reserved.

Usage:   LogParser [-i:&lt;input_format&gt;] [-o:&lt;output_format&gt;] &lt;SQL query&gt; |
                   file:&lt;query_filename&gt;[?param1=value1+...]
                   [&lt;input_format_options&gt;] [&lt;output_format_options&gt;]
                   [-q[:ON|OFF]] [-e:&lt;max_errors&gt;] [-iw[:ON|OFF]]
                   [-stats[:ON|OFF]] [-saveDefaults] [-queryInfo]

         LogParser -c -i:&lt;input_format&gt; -o:&lt;output_format&gt; &lt;from_entity&gt;
                   &lt;into_entity&gt; [&lt;where_clause&gt;] [&lt;input_format_options&gt;]
                   [&lt;output_format_options&gt;] [-multiSite[:ON|OFF]]
                   [-q[:ON|OFF]] [-e:&lt;max_errors&gt;] [-iw[:ON|OFF]]
                   [-stats[:ON|OFF]] [-queryInfo]

 -i:&lt;input_format&gt;   :  one of IISW3C, NCSA, IIS, IISODBC, BIN, IISMSID,
                        HTTPERR, URLSCAN, CSV, TSV, W3C, XML, EVT, ETW,
                        NETMON, REG, ADS, TEXTLINE, TEXTWORD, FS, COM (if
                        omitted, will guess from the FROM clause)
 -o:&lt;output_format&gt;  :  one of CSV, TSV, XML, DATAGRID, CHART, SYSLOG,
                        NEUROVIEW, NAT, W3C, IIS, SQL, TPL, NULL (if omitted,
                        will guess from the INTO clause)
 -q[:ON|OFF]         :  quiet mode; default is OFF
 -e:&lt;max_errors&gt;     :  max # of parse errors before aborting; default is -1
                        (ignore all)
 -iw[:ON|OFF]        :  ignore warnings; default is OFF
 -stats[:ON|OFF]     :  display statistics after executing query; default is
                        ON
 -c                  :  use built-in conversion query
 -multiSite[:ON|OFF] :  send BIN conversion output to multiple files
                        depending on the SiteID value; default is OFF
 -saveDefaults       :  save specified options as default values
 -restoreDefaults    :  restore factory defaults
 -queryInfo          :  display query processing information (does not
                        execute the query)


Examples:
 LogParser "SELECT date, REVERSEDNS(c-ip) AS Client, COUNT(*) FROM file.log
            WHERE sc-status&lt;&gt;200 GROUP BY date, Client" -e:10
 LogParser file:myQuery.sql?myInput=C:\temp\ex*.log+myOutput=results.csv
 LogParser -c -i:BIN -o:W3C file1.log file2.log "ComputerName IS NOT NULL"

Help:
 -h GRAMMAR                  : SQL Language Grammar
 -h FUNCTIONS [ &lt;function&gt; ] : Functions Syntax
 -h EXAMPLES                 : Example queries and commands
 -h -i:&lt;input_format&gt;        : Help on &lt;input_format&gt;
 -h -o:&lt;output_format&gt;       : Help on &lt;output_format&gt;
 -h -c                       : Conversion help</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Query IIS Logs using Logparser via Powershell - example </Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Query IIS Logs using Logparser via Powershell - example </Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

#'Query IIS Logs using Logparser via Powershell
#' https://gallery.technet.microsoft.com/office/Query-IIS-Logs-using-fa66667f



&lt;#
=====================================
Script Created by - Binu Balan      
Script Created on - 11/8/2015
Version - V 1.1
Requirement *
PowerShell = 2.0 or above
This script is used to perform query
Huge IIS Log Files
	 .__.
     (oo)____
     (__)    )\
        ll--ll '
=====================================
#&gt;
cls
Write-Host " "
Write-Host " "
Write-host " AAAAAAAA     PPPPPPPPP    PPPPPPPPP    UUU    UUU" -ForegroundColor Green
Write-host "AAAAAAAAAA    PPP   PPPP   PPP   PPPP   UUU    UUU" -ForegroundColor Green
Write-host "AAA    AAA    PPP    PPP   PPP    PPP   UUU    UUU" -ForegroundColor Green
Write-host "AAAAAAAAAA    PPPPPPPP     PPPPPPPP     UUU    UUU" -ForegroundColor Green
Write-host "AAA    AAA    PPP          PPP          UUU    UUU" -ForegroundColor Green
Write-host "AAA    AAA    PPP          PPP           UUUUUUUU" -ForegroundColor Green
Write-Host " "
Write-Host " " 
Write-host "	           .__." -ForegroundColor Green
Write-host "                   (oo)____" -ForegroundColor Green
Write-host "                   (__)    )\" -ForegroundColor Green
Write-host "                      ll--ll '" -ForegroundColor Green
Write-Host "               SCRIPT BY BINU BALAN               " -ForegroundColor DarkYellow -BackgroundColor DarkBlue 
Write-Host " "
Write-Host " "


$i = 1

# Getting Input from User
# =======================
Write-Host " "
Write-Host " "
Write-Host "Pre-Requisite Check for the Logparser.exe on local path" -NoNewline

Start-Sleep -Seconds 2
If(Test-Path -Path Logparser.exe){
Write-Host "                 [   OK   ]" -ForegroundColor Green
} Else {
Write-Host "                 [ Failed ]" -ForegroundColor Red
Write-Host " "
Write-Host " "
Write-Warning "Either Logparser is not installed or you are running this script on a different folder where Logparser.exe file is unavailable."
Write-Host " "
Write-Host "To download logparser follow this link : " -NoNewline -BackgroundColor Yellow -ForegroundColor Black
Write-Host "http://www.microsoft.com/en-in/download/details.aspx?id=24659" -ForegroundColor Blue -BackgroundColor Yellow
Write-Host " "
exit
}



Write-Host " "
Write-Host " "
$ReportPath = Read-Host "Enter Report Folder Path [Ex: c:\reports] "
$ReportName = Read-Host "Enter the report file name [Ex: LogReport.csv] "
Write-Host " "
Write-Host " "

Write-Host "Select the query type that you want to perform against the log?" -ForegroundColor Yellow
Write-Host "&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt; " -ForegroundColor Blue
Write-Host "1. Date             Example -2014-12-02" -ForegroundColor Green
Write-Host "2. Time             Example -00:00:12" -ForegroundColor Green
Write-Host "3. s-ip             Example -192.168.1.20" -ForegroundColor Green
Write-Host "4. cs-method        Example - GET/POST" -ForegroundColor Green
Write-Host "5. cs-uri-query     Example - /EWS/Exchange.asmx" -ForegroundColor Green
Write-Host "6. s-port           Example -443" -ForegroundColor Green
Write-Host "7. cs-username      Example -appudomain\binu.balan" -ForegroundColor Green
Write-Host "8. c-ip             Example -106.33.98.222" -ForegroundColor Green
Write-Host "9. cs(user-Agent)   Example -Microsoft+office" -ForegroundColor Green
Write-Host "10. sc-status       Example -401" -ForegroundColor Green
Write-Host "11. sc-substatus    Example -1" -ForegroundColor Green
Write-Host "12. sc-win32-status " -ForegroundColor Green
Write-Host "13. time-taken" -ForegroundColor Green
Write-Host " "
Write-Host " "

$GetInput = Read-host "Enter the query number "

switch ($GetInput) 
    { 
        1 {$WhereVal = "Date"} 
        2 {$WhereVal = "Time"} 
        3 {$WhereVal = "s-ip"} 
        4 {$WhereVal = "cs-method"} 
        5 {$WhereVal = "cs-uri-query"} 
        6 {$WhereVal = "s-port"} 
        7 {$WhereVal = "cs-username"} 
        8 {$WhereVal = "c-ip"} 
        9 {$WhereVal = "cs(user-Agent)"} 
        10 {$WhereVal = "sc-status"} 
        11 {$WhereVal = "sc-substatus"} 
        12 {$WhereVal = "sc-win32-status"} 
        13 {$WhereVal = "time-taken"} 

        default {"You have input invalid data !!"}
    }

if ($WhereVal -eq $null) {

Write-Host "You have entered invalid data. Exiting the Script"

exit

}

Write-host "Enter Log folder path. For multiple folders use Comma separated value [Example [C:\Log1,C:\Log2"
$ORRFolderpath = Read-Host "Enter here "

$WhereQuery = Read-Host ("Enter the Query for $WhereVal ")
$EachFolder = $ORRFolderpath.Split(",")
$EachIP = $WhereQuery.Split(",")


#$RName = Read-Host ("Enter Report Name with CSV Extension - (Result.csv)")
#$RPath = Read-Host ("Enter the path where you want to store the report - (C:\Report)")



ForEach ($S_Folder in $EachFolder) {

    ForEach ($IP in $EachIP) {

    $LogPath = $S_Folder
    $FileNames = Get-childItem -Path $LogPath


            ForEach ($File in $FileNames) {

            Write-Host "Script Line $i - .\LogParser.exe SELECT * INTO $ReportPath\$ReportName FROM $LogPath\$File WHERE $WhereVal LIKE '%$IP%' -filemode:0" -ForegroundColor Yellow


            $i = $i + 1

            .\LogParser.exe "SELECT * INTO $ReportPath\$ReportName FROM $LogPath\$File WHERE $WhereVal LIKE '%$IP%'" -filemode:0

            Write-Host "[ Completed ]" -ForegroundColor Green

            Write-Host "    "
            Write-Host "    "

            }


    }

}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Use Logparser and Powershell to produce a single CSV output from IIS logs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Use Logparser and Powershell to produce a single CSV output from IIS logs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'https://gallery.technet.microsoft.com/office/Use-Logparser-and-59eaa5e5
#' Use Logparser and Powershell to produce a single CSV output from IIS logs

============================
I wanted to combine powershell and logparser to get me a single csv file of user activity on my ASPX website.

The following script acheives that by doing the following

It connects to a root IIS log repository. 
	Although the script looks at a single location, 
	it would be fairly simple to collect the logs from several servers first 
	(renaming them, possibly with the server name appended to give them a unique name) 
My IIS logs are generated fresh each day (the default) 
	so I used the create date to determine what day each log relates to.
I considered a week to be a reasonable block of time to track activity.  
	Therefore, I loop over the list of files and copy them into a week by week folder (named YYYY-WW)
Logparser then comes into action, 
	producing a single csv file for each set of logs for the week (i.e. for each folder)
You can modify the SELECT statement as needed, 
	but I was only interested in who hit which page, 
	where it was in the site and what their average and maximum rendering time was
Logparser will output some paths that I dont want in the report.  
	As my site is a SharePoint site, I'm not interested (in this instance) 
	so I strip them out of the file via the $unwantedPaths parameter.
The prepared files are then grouped into one single output file (Logs.csv) that I can pivot and present in Excel
 

Feel free to change structure and final output to suit your needs 
	- the script should give the basic building blocks to get a decent usage report out quickly.  
	The other advantage is that it will only do work if new data exists.  
	So, if you delete the output directories or files or new logs exist then you'll get new output.

It should go without saying that you'll need to have installed logparser on your machine before running this file.
==================================
Function CopyLogFile ($LogFile, [ref]$FoldersToProcess) { 
 
     
    $YearWeekOfFile = get-date ($LogFile.CreationTime) -UFormat %Y-%V 
    $savePath = Join-Path -Path $weeklyLogRootFolder -ChildPath $YearWeekOfFile 
    CreateFolderIfNotExists $savePath 
     
    $logFileDestinationPath = Join-Path -Path $savePath -ChildPath $LogFile.Name 
     
    if ((Test-Path $logFileDestinationPath) -eq $false) { 
        Copy-Item -Path $LogFile.FullName -Destination $logFileDestinationPath 
        $FoldersToProcess.value += $savePath 
    } 
     
     
} 
Function CreateFolderIfNotExists ($FolderPath) { 
 
    if ((Test-Path $FolderPath) -eq $false) { 
        New-Item -Path $FolderPath -Type Directory 
    } 
 
} 
 
Function PathIsWanted ($RequestPath) { 
    $pathIsWanted = $true 
    foreach($path in $unwantedPaths) { 
        if ($RequestPath -like "$($path)*") { 
            $pathIsWanted = $false 
            break 
        } 
    } 
    $pathIsWanted 
} 
 
#Modify this section with your own values 
 
$rawLogFileRoot = "\\SERVER\c$\inetpub\logs\LogFiles\FOLDER" 
$unwantedPaths = "/_layouts/", "/apps/", "/Lists/", "/_catalogs/", "/_vti_bin/", "/themes", "/Workflow" 
$weeklyLogRootFolder = "C:\temp\logs\" 
$outputCSVLocation = "C:\temp\logs\csvOutput\" 
 
#End of variables to be modified 
 
 
#You may need to modify the exe path of Logparser.exe as well as the SELECT script you wish to run 
#I only wanted aspx pages from my site 
$logParserExe = "C:\Program Files (x86)\Log Parser 2.2\LogParser.exe" 
$logParserSQL =  "`"SELECT '{0}' AS Date, cs-username, STRCAT(EXTRACT_PATH(cs-uri-stem),'/') AS RequestPath, " 
$logParserSQL += "EXTRACT_FILENAME(cs-uri-stem) AS RequestedFile, COUNT(*) AS TotalHits, Max(time-taken) AS MaxTime, " 
$logParserSQL += "AVG(time-taken) AS AvgTime INTO {2} FROM {1}\*.log WHERE cs-username  IS NOT NULL AND " 
$logParserSQL += "SUBSTR(STRREV(EXTRACT_FILENAME(cs-uri-stem)),0,5) = 'xpsa.'   GROUP BY cs-username, cs-uri-stem ORDER BY TotalHits DESC`"" 
#  "STRREV(EXTRACT_FILENAME(cs-uri-stem)),0,5) = 'xpsa.'" gives us aspx pages only 
$logParserParams = "-i:IISW3C" , "-o:CSV" 
 
 
CreateFolderIfNotExists $weeklyLogRootFolder 
CreateFolderIfNotExists $outputCSVLocation 
 
$FoldersToProcess = @() 
 
$rawLogFiles = Get-ChildItem $rawLogFileRoot 
 
 
foreach ($logFile in $rawLogFiles) { 
    CopyLogFile -logFile $logFile -FoldersToProcess ([ref] $FoldersToProcess) 
} 
$FoldersToProcess = $FoldersToProcess | select -uniq 
 
#Log Parsing section 
if ($FoldersToProcess -ne $null) { 
 
    foreach ($folderToProcess in $FoldersToProcess) { 
        $yearWeekName = $folderToProcess.Replace($weeklyLogRootFolder, '') 
        $outputCSV = Join-Path -Path $outputCSVLocation -ChildPath ($yearWeekName + ".csv") 
        $logParserParamsInput = ([string]::Format($logParserSQL, $yearWeekName, $folderToProcess, $outputCSV)), $logParserParams[0], $logParserParams[1] 
         
        Start-Process -NoNewWindow -FilePath $logParserExe -ArgumentList $logParserParamsInput -wait 
 
        #Now process the CSV file - removing unwanted page entries 
        $data = Import-Csv -Path $outputCSV | ?{$unwantedPaths -notcontains $_.RequestPath}  
        $data | Where-Object { (PathIsWanted $_.RequestPath) -eq $true } | Export-CSV -Path $outputCSV -NoTypeInformation 
         
    } 
} 
 
 
$outputFile = $null 
$outputFilePath = Join-Path -Path $outputCSVLocation -ChildPath "Logs.csv" 
 
 
$resultFiles = Get-Childitem $outputCSVLocation  
$firstItem = $true 
if ($resultFiles -ne $null) { 
    foreach ($resultFile in ($resultFiles | ?{$_.Name -ne "Logs.csv"})) { 
        if ($firstItem) { 
            Copy-Item $resultFile.FullName $outputFilePath 
            $firstItem = $false 
        } 
        else { 
            get-content $resultFile.FullName | Select -Skip 1 | Add-Content $outputFilePath 
        } 
    } 
} 
 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Loops</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Loop_Through_Computers_from_AD_and_Do_something</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Loops</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Loop_Through_Computers_from_AD_and_Do_something</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

1]-------------------------------------------------

# Import the Active Directory module for the Get-ADComputer CmdLet 
Import-Module ActiveDirectory 
 
# Get today's date for the report 
$today = Get-Date 
 
# Setup email parameters 
$subject = "ACTIVE SERVER SESSIONS REPORT - " + $today 
$priority = "Normal" 
$smtpServer = "Barriere-com.mail.protection.outlook.com" 
$emailFrom = "DoNotReply@barriere.com" 
$emailTo = "glenng@barriere.com" 
 
# Create a fresh variable to collect the results. You can use this to output as desired 
$SessionList = "ACTIVE SERVER SESSIONS REPORT - " + $today + "`n`n" 
 
# Query Active Directory for computers running a Server operating system 
$Servers = Get-ADComputer -Filter {OperatingSystem -like "*server*"} 
 
# Loop through the list to query each server for login sessions 
ForEach ($Server in $Servers) { 
    $ServerName = $Server.Name 
 
    # When running interactively, uncomment the Write-Host line below to show which server is being queried 
    # Write-Host "Querying $ServerName" 
 
    # Run the qwinsta.exe and parse the output 
    $queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "\s+",","))} | ConvertFrom-Csv)  
     
    # Pull the session information from each instance 
    ForEach ($queryResult in $queryResults) { 
        $RDPUser = $queryResult.USERNAME 
        $sessionType = $queryResult.SESSIONNAME 
         
        # We only want to display where a "person" is logged in. Otherwise unused sessions show up as USERNAME as a number 
        If (($RDPUser -match "[a-z]") -and ($RDPUser -ne $NULL)) {  
            # When running interactively, uncomment the Write-Host line below to show the output to screen 
            # Write-Host $ServerName logged in by $RDPUser on $sessionType 
            $SessionList = $SessionList + "`n`n" + $ServerName + " logged in by " + $RDPUser + " on " + $sessionType 
        } 
    } 
} 
 
# Send the report email 
# Send-MailMessage -To $emailTo -Subject $subject -Body $SessionList -SmtpServer $smtpServer -From $emailFrom -Priority $priority 
 
# When running interactively, uncomment the Write-Host line below to see the full list on screen 
$SessionList </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_get_LIST_of_SERVERS_on_Network</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Network_subnet_IP_DNS_etc</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_get_LIST_of_SERVERS_on_Network</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#FROM: https://gallery.technet.microsoft.com/PowerShell-script-to-Find-d2ba4252


#email_LIST_of_REMOTE_logins_for_all_SERVERS_on_our_Network.psf


# Import the Active Directory module for the Get-ADComputer CmdLet 
Import-Module ActiveDirectory 
 
# Get today's date for the report 
$today = Get-Date 
 
# Setup email parameters 
$subject = "ACTIVE SERVER SESSIONS REPORT - " + $today 
$priority = "Normal" 
$smtpServer = "Barriere-com.mail.protection.outlook.com" 
$emailFrom = "DoNotReply@barriere.com" 
$emailTo = "glenng@barriere.com" 
 
# Create a fresh variable to collect the results. You can use this to output as desired 
$SessionList = "ACTIVE SERVER SESSIONS REPORT - " + $today + "`n`n" 
 
# Query Active Directory for computers running a Server operating system 
$Servers = Get-ADComputer -Filter {OperatingSystem -like "*server*"} 
 
# Loop through the list to query each server for login sessions 
ForEach ($Server in $Servers) { 
    $ServerName = $Server.Name 
 
    # When running interactively, uncomment the Write-Host line below to show which server is being queried 
    # Write-Host "Querying $ServerName" 
 
    # Run the qwinsta.exe and parse the output 
    $queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "\s+",","))} | ConvertFrom-Csv)  
     
    # Pull the session information from each instance 
    ForEach ($queryResult in $queryResults) { 
        $RDPUser = $queryResult.USERNAME 
        $sessionType = $queryResult.SESSIONNAME 
         
        # We only want to display where a "person" is logged in. Otherwise unused sessions show up as USERNAME as a number 
        If (($RDPUser -match "[a-z]") -and ($RDPUser -ne $NULL)) {  
            # When running interactively, uncomment the Write-Host line below to show the output to screen 
            # Write-Host $ServerName logged in by $RDPUser on $sessionType 
            $SessionList = $SessionList + "`n`n" + $ServerName + " logged in by " + $RDPUser + " on " + $sessionType 
        } 
    } 
} 
 
# Send the report email 
# Send-MailMessage -To $emailTo -Subject $subject -Body $SessionList -SmtpServer $smtpServer -From $emailFrom -Priority $priority 
 
# When running interactively, uncomment the Write-Host line below to see the full list on screen 
$SessionList </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Find_IE_Version_on_Remote_Computers_Using_PowerShell</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Find_IE_Version_on_Remote_Computers_Using_PowerShell</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://gallery.technet.microsoft.com/scriptcenter/FInd-IE-Version-on-Remote-e6d5075c
'Reads the Registry
' IE 10 shows up as 9.10.nnnn
'IE 11 shows up as 9.11.nnnn. 
' IE 9 is 9.0.nnnn
' older versions: https://support.microsoft.com/en-us/help/969393/information-about-internet-explorer-versions

'ORIGINAL
$array =@() 
$keyname = 'SOFTWARE\\Microsoft\\Internet Explorer' 
$computernames = Get-Content C:\Computer.csv 
foreach ($server in $computernames) 
{ 
$reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $server) 
$key = $reg.OpenSubkey($keyname) 
$value = $key.GetValue('Version') 
 $obj = New-Object PSObject 
         
        $obj | Add-Member -MemberType NoteProperty -Name "ComputerName" -Value $server 
         
        $obj | Add-Member -MemberType NoteProperty -Name "IEVersion" -Value $value 
 
        $array += $obj  
 
 
} 
 
$array | select ComputerName,IEVersion | export-csv IE_Version.csv</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>send_EMAIL_all_remote_logins_to_SERVERS_on_network</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>send_EMAIL_all_remote_logins_to_SERVERS_on_network</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#FROM: https://gallery.technet.microsoft.com/PowerShell-script-to-Find-d2ba4252


#email_LIST_of_REMOTE_logins_for_all_SERVERS_on_our_Network.psf


# Import the Active Directory module for the Get-ADComputer CmdLet 
Import-Module ActiveDirectory 
 
# Get today's date for the report 
$today = Get-Date 
 
# Setup email parameters 
$subject = "ACTIVE SERVER SESSIONS REPORT - " + $today 
$priority = "Normal" 
$smtpServer = "Barriere-com.mail.protection.outlook.com" 
$emailFrom = "DoNotReply@barriere.com" 
$emailTo = "glenng@barriere.com" 
 
# Create a fresh variable to collect the results. You can use this to output as desired 
$SessionList = "ACTIVE SERVER SESSIONS REPORT - " + $today + "`n`n" 
 
# Query Active Directory for computers running a Server operating system 
$Servers = Get-ADComputer -Filter {OperatingSystem -like "*server*"} 
 
# Loop through the list to query each server for login sessions 
ForEach ($Server in $Servers) { 
    $ServerName = $Server.Name 
 
    # When running interactively, uncomment the Write-Host line below to show which server is being queried 
    # Write-Host "Querying $ServerName" 
 
    # Run the qwinsta.exe and parse the output 
    $queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "\s+",","))} | ConvertFrom-Csv)  
     
    # Pull the session information from each instance 
    ForEach ($queryResult in $queryResults) { 
        $RDPUser = $queryResult.USERNAME 
        $sessionType = $queryResult.SESSIONNAME 
         
        # We only want to display where a "person" is logged in. Otherwise unused sessions show up as USERNAME as a number 
        If (($RDPUser -match "[a-z]") -and ($RDPUser -ne $NULL)) {  
            # When running interactively, uncomment the Write-Host line below to show the output to screen 
            # Write-Host $ServerName logged in by $RDPUser on $sessionType 
            $SessionList = $SessionList + "`n`n" + $ServerName + " logged in by " + $RDPUser + " on " + $sessionType 
        } 
    } 
} 
 
# Send the report email 
# Send-MailMessage -To $emailTo -Subject $subject -Body $SessionList -SmtpServer $smtpServer -From $emailFrom -Priority $priority 
 
# When running interactively, uncomment the Write-Host line below to see the full list on screen 
$SessionList </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>What_Sessions_are_Connected_to_a_serverr_NOT_actually_Remoting</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>What_Sessions_are_Connected_to_a_serverr_NOT_actually_Remoting</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

//////////////////////////////////////
cls
$serverName = 'BCC-EXPLORER3db' 
 
$serverName + ' Sessions'
Write-Host ''
Query session /server:$serverName

/////////////////////////////////////////
&gt; Query session /server:BCC-EXPLORER3DB

'OUTPUT
'==========================================================================
SESSIONNAME       USERNAME                 ID  STATE   TYPE        DEVICE 
 services                                    0  Disc                        
                   explorer1                 1  Disc                        
                   glenng                    2  Disc                        
 console                                     3  Conn                        
 rdp-tcp                                 65536  Listen         
 
 'To logoff the session:
 &gt;Reset session 1 /server:Server100    
 
         
/////////////////////////////////////////////////////////////////////

'We are taking each line of the output from the command, trimming the content and replacing the spaces with commas 
' and then piping it to a ConvertFrom-CSV to put the content into a table array with the appropriate headers 
'	of USERNAME and SESSIONNAME which is the information we are looking for. 
$queryResults = (qwinsta /server:$ServerName | foreach { (($_.trim() -replace "s+",","))} | ConvertFrom-Csv)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_SSRS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Create_List_of_Objects_on_SSRS_Server</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_SSRS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Create_List_of_Objects_on_SSRS_Server</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$ReportServerUri = "http://bcc-explorerdb/reportserver/reportservice2010.asmx";
$Proxy = New-WebServiceProxy -Uri $ReportServerUri -Namespace SSRS.ReportingService2005 -UseDefaultCredential ;

$items = $Proxy.ListChildren("/", $true);

$items | sort-object Type, Name;
'ID                    : c4acd466-c1cb-46ba-8a0b-66fb7687d6a0
'Name                  : Current Job List
'Path                  : /Job Cost/Current Job List
'VirtualPath           : 
'TypeName              : Report
'Size                  : 64009
'SizeSpecified         : True
'Description           : 
'Hidden                : False
'HiddenSpecified       : False
'CreationDate          : 5/9/2016 10:05:51 AM
'CreationDateSpecified : True
'ModifiedDate          : 5/9/2016 10:05:51 AM
'ModifiedDateSpecified : True
'CreatedBy             : BCC\deweyh
'ModifiedBy            : BCC\deweyh
'ItemMetadata          : {}

$items | select Type, Path, ID, Name | sort-object Type, Name;

$items | select Name, Path, TypeName, CreationDate, CreatedBy | sort-object Type, Name  | Format-Table -AutoSize

$items | select Name, Path, TypeName, CreationDate, CreatedBy | sort-object Type, Name  | Export-Csv c:\JUNK\SSRS_Reports_2016_11_07.csv


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>01_CsvImportExample.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PowerShell_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>01_CsvImportExample.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>. C:\AdAccountManagementAutomator.ps1          #' &lt;=== dot source the file with all four functions in it.

$Employees = Import-Csv -Path C:\Users.csv     #' &lt;=== Import the CSV file
foreach ($Employee in $Employees) {            #' &lt;=== For each record in the CSV file
    ## Create the AD user accounts
    $NewUserParams = @{                         #' &lt;=== Populate a HashTable from
				        'FirstName' = $Employee.FirstName
				        'MiddleInitial' = $Employee.MiddleInitial
				        'LastName' = $Employee.LastName
				        'Title' = $Employee.Title
                      }
    if (!$Employee.Location) {                         #'&lt;== If the Location field is NOT populated, populate the field in $NewUserParams with a NULL
        						$NewUserParams.Location = $null 
    						 } 
    else { 
        	$NewUserParams.Location = $Employee.Location   #'&lt;== If the Location field is populated, that use it to populate the $NewUserParams
    	 }
    ## Grab the username created to use for Set-MyAdUser
    $Username = New-EmployeeOnboardUser @NewUserParams

    ## Create the employee's AD computer account
    New-EmployeeOnboardComputer -Computername $Employee.Computername

    ## Set the description for the employee's computer account
    Set-MyAdComputer -Computername $Employee.Computername -Attributes @{'Description' = "$($Employee.FirstName) $($Employee.LastName)'s computer" }

    ## Set the dept the employee is in
    Set-MyAdUser -Username $Username -Attributes @{'Department' = $Employee.Department}
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_ToolKit</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>02_Usage</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_ToolKit</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>02_Usage</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>This will get a list of event logs and LOG files, but it is really not to usefull, as is, 
It would be better to output it to a CSV file

&gt; Get-InterestingEventsWithinTimeframe.ps1 -Computername 'BCC-EXPLORER3DB' -StartTimestamp '04-15-15 04:00' -EndTimeStamp '04-15-15 04:10'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Files_Folders_Directories</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>FOLDERS_that_do_not_inherit_permissions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Files_Folders_Directories</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>FOLDERS_that_do_not_inherit_permissions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

=========================
https://stackoverflow.com/questions/25126877/getting-names-of-folders-that-do-not-inherit-permissions

'CMD
&gt;DIR "C:\temp" -directory -recurse | GET-ACL | where {$_.Access.IsInherited -eq $false}

'POWERSHELL:
'The concept is: if a folder has at least 1 inherited access rule, 
'	then inheritance is enabled, 
'	if it has 0 inherited rules, inheritance is disabled.
&gt; Get-ChildItem C:\temp -recurse | Select @{Name='Path';Expression={$_.FullName}},@{Name='InheritedCount';Expression={(Get-Acl $_.FullName | Select -ExpandProperty Access | Where { $_.IsInherited }).Count}} | Where { $_.InheritedCount -eq 0 } | Select Path

=================================================================

'	You can use Add-Member to add the path as a property on each ACE object:
'	I also wrapped Get-Acl in a try block because it throws terminating errors.
dir c:\temp -Directory -Recurse | ForEach-Object {
    $Path = $_.FullName
    try {
        Get-Acl $Path | 
            select -ExpandProperty Access | 
            where { $_.IsInherited -eq $false } | 
            Add-Member -MemberType NoteProperty -Name Path -Value $Path -PassThru
    }
    catch {
        Write-Error $_
    }
}

================================================================
#'https://www.experts-exchange.com/questions/28395713/How-to-enumerate-which-folders-are-not-inheriting-permissions-from-parent-folder.html

NOTE: the output did not make sense, it only listed the subfolders, not sub-sub folders
	  and the output did not match what I was observing in the permissions

#requires -version 3

$Path = "c:\temp"
$Folders = Get-ChildItem $Path -Directory -Recurse
$statuses = @()

Foreach ($Folder in $Folders)
{
    $ACLs = Get-Acl -Path $Folder.fullname | ForEach-Object { $_.Access }
    Foreach ($ACL in $ACLs)
    {
        if (!($ACL.IsInherited))
        {
                $status = [ordered]@{ 
                FolderPath = $Folder.Fullname;
                IsInherited = $ACL.IsInherited;
                InheritanceFlags = $ACL.InheritanceFlags;
                PropagationFlags = $ACL.PropagationFlags }
            $statuses += (New-Object -TypeName PSObject -Property $status)
            break;
        }
        
    }
}
$statuses | Export-Csv -Path c:\temp\report.csv -Encoding ASCII -NoTypeInformation </Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>