<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Map_Drives</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>from_BCC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Map_Drives</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>from_BCC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'********************************************************************************
'This login scripts will do the following items for non-People Trak Users
'	Map all user drives based on group user belongs to
'	write a record to a database to track PC make and Models
'	Write a record to a database to track user logon times
'	Set the local time on the user PC to match the server
'********************************************************************************

strComputer="."
on error resume next


'****************
'   Variables
'****************

Dim WSHNetwork
Dim wshShell
Dim wshSysEnv
Dim nReturnCode
Dim FSO
Dim strUsername
Dim strUseName
Dim strUserDomain
Dim objGroupDict

'*********************************************************
'	DRIVE MAPPING SECTION OF SCRIPT
'*********************************************************

Set WSHNetwork = WScript.CreateObject("WScript.Network")
Set FSO = CreateObject("Scripting.FileSystemObject")

'**** Wait Until User is Logged In ****

strUserName = ""
While strUserName = ""
WScript.Sleep 1000 ' 1 second
strUserName = WSHNetwork.UserName
Wend
strUserDomain = WSHNetwork.UserDomain

'**** Insert the user's account "Member Of" tab info ****


Set ObjGroupDict = CreateMemberOfObject(strUserDomain, strUserName)

'****Remove drive letters first****

	WshNetwork.RemoveNetworkDrive "G:", True, false
	WshNetwork.RemoveNetworkDrive "H:", True, false
	WshNetwork.RemoveNetworkDrive "J:", True, false
	WshNetwork.RemoveNetworkDrive "K:", True, false
	WshNetwork.RemoveNetworkDrive "Q:", True, false
	WshNetwork.RemoveNetworkDrive "S:", True, false
	WshNetwork.RemoveNetworkDrive "T:", True, false
	WshNetwork.RemoveNetworkDrive "U:", True, false
	WshNetwork.RemoveNetworkDrive "V:", True, false
	WshNetwork.RemoveNetworkDrive "W:", True, false
	WshNetwork.RemoveNetworkDrive "X:", True, false
	WshNetwork.RemoveNetworkDrive "Y:", True, false
	WshNetwork.RemoveNetworkDrive "Z:", True, false

'****Map Drive based on Group Membership****

'*********** Boutte **********

If MemberOf(ObjGroupDict, "BoutteLA") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "BoutteLA") Then
WSHNetwork.MapNetworkDrive "t:", "\\bcc-bouttedcfs\Boutteshare"
End If

If MemberOf(ObjGroupDict, "BoutteLA") Then
WSHNetwork.MapNetworkDrive "u:", "\\bcc-bouttedcfs\Users\" &amp; WSHNetwork.UserName
End If

'*********** Concrete Paving **********

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "CPD") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** Executive **********

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "j:", "\\bcc-explorer2\XPLRF"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "k:", "\\bcc-explorer2\XPLR"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "Executive") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** HR **********

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "H:", "\\bcc-explorer2\xplrf\barriere\images"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "J:", "\\bcc-explorer2\xplr"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "K:", "\\bcc-explorer2\XPLRF"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "HR") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If


'*********** Gravel Pit **********

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "Ponder") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If


'*********** Interns**********

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "y:", "\\bcc-bouttedcfs\BoutteShare"
End If

If MemberOf(ObjGroupDict, "Interns") Then
WSHNetwork.MapNetworkDrive "z:", "\\bcc-nshore\1A_Northshore"
End If

'*********** New Orleans **********

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "NOLA") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** North Shore **********

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "s:", "\\bcc-nshore\1A_Northshore"
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "u:", "\\bcc-nshore\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

If MemberOf(ObjGroupDict, "NShore") Then
WSHNetwork.MapNetworkDrive "z:", "\\ts-frank2\share\archive"
End If

'*********** South Shore **********

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "s:", "\\BCC-FS1\Divisions"
End If

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "t:", "\\BCC-FS1\Applications"
End If

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "u:", "\\BCC-FS1\Users\" &amp; WSHNetwork.UserName
End If

If MemberOf(ObjGroupDict, "SSC") Then
WSHNetwork.MapNetworkDrive "v:", "\\BCC-FS1\Reports"
End If

'*********** All Common **********

WSHNetwork.MapNetworkDrive "g:", "\\BCC-CONTROL\PeopleTrak"
WSHNetwork.MapNetworkDrive "q:", "\\bcc-hcss\HCSS"
WSHNetwork.MapNetworkDrive "w:", "\\BCC-FS1\Public"
WSHNetwork.MapNetworkDrive "x:", "\\bcc-explorer2\CLI"
'==========================================================CUSTOM MAPPINGS
WSHNetwork.MapNetworkDrive "y:", "\\bcc-explorer\d$"
WSHNetwork.MapNetworkDrive "z:", "\\bcc-explorer3\d$"

'==========================================================

'**** Group Membership Function Subroutines ****

Function MemberOf(ObjDict, strKey)

MemberOf = CBool(ObjGroupDict.Exists(strKey))

End Function


Function CreateMemberOfObject(strDomain, strUserName)

Dim objUser, objGroup

Set CreateMemberOfObject = CreateObject("Scripting.Dictionary")
CreateMemberOfObject.CompareMode = vbTextCompare
Set objUser = GetObject("WinNT://" _
&amp; strDomain &amp; "/" _
&amp; strUserName &amp; ",user")
For Each objGroup In objUser.Groups
CreateMemberOfObject.Add objGroup.Name, "-"
Next
Set objUser = Nothing

End Function

'*****************************************************
'	END OF DRIVE MAPPING SECTION
'*****************************************************


'*****************************************************
'	SECTION TO SET LOCAL COMPUTER TIME
'*****************************************************
strComputer="."
Set WshNetwork = WScript.CreateObject("WScript.Network")
Set wshShell = WScript.CreateObject("Wscript.Shell")
Set wshSysEnv = wshShell.Environment("SYSTEM")
If (wshSysEnv("OS") = "Windows_NT") Then
    nReturnCode = wshShell.Run("net time /domain:" &amp; wshNetwork.UserDomain &amp; " /set /yes", 0, TRUE)
    Else
	WScript.Echo "This Logon Script Supports only Windows 2000 or Windows XP" &amp; vbNewLine &amp; "Exiting..."
    Set wshNetwork = Nothing
    Set wshShell = Nothing
    WScript.Quit(1)
End If

'*****************************************************
result=Msgbox("Good To Go!",vbYesNo+vbInformation, "")
'*****************************************************


Set wshNetwork = Nothing
Set wshShell = Nothing
WScript.Quit(nReturnCode)

'*****************************************************
'	END OF SETTING LOCAL TIME
'*****************************************************













</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Map_Drives</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Map_Multiple_Drives</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Map_Drives</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Map_Multiple_Drives</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Dim WSHNetwork
Dim FSO


Set WSHNetwork = WScript.CreateObject("WScript.Network")
Set FSO = CreateObject("Scripting.FileSystemObject")


WshNetwork.RemoveNetworkDrive "H:", True, false
WshNetwork.RemoveNetworkDrive "i:", True, false
WshNetwork.RemoveNetworkDrive "j:", True, false
WshNetwork.RemoveNetworkDrive "k:", True, false

WSHNetwork.MapNetworkDrive "H:", "\\b2wtimesheet\C$"
WSHNetwork.MapNetworkDrive "i:", "\\bcc-explorerdb\C$"
WSHNetwork.MapNetworkDrive "j:", "\\bcc-explorer3db\C$"
WSHNetwork.MapNetworkDrive "k:", "\\bcc-explorer3\C$"

'*****************************************************
result=Msgbox("Good To Go!",vbYesNo+vbInformation, "")
'*****************************************************


Set wshNetwork = Nothing
Set wshShell = Nothing
WScript.Quit</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>error_from_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>error_from_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># No error handling produces ugly errors

function divver($enum,$denom)
{   
  Write-Host "Divver begin."
  $result = $enum / $denom
  Write-Host "Result: $result"
  Write-Host "Divver done."    
}

Clear-Host
divver 33 3   # No Error
divver 33 0   # Generate Error

# Handle errors using try/catch/finally
function divver($enum,$denom)
{   
  Write-Host "Divver begin."

  try
  {
    $result = $enum / $denom
    Write-Host "Result: $result"
  }
  catch
  {
    Write-Host "Oh NO! An error has occurred!!"
    Write-Host $_.ErrorID
    Write-Host $_.Exception.Message
    break  # With break, or omitting it, error bubbles up to parent
  }
  finally
  {
    Write-Host "Divver done."    
  }
}

Clear-Host
divver 33 3   # No Error
divver 33 0   # Generate Error

#endregion Error Handling

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Write-Error_Write-Warning_Write-Verbose_Write-Debug</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_DEBUG_ERROR_TroubleShooting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Write-Error_Write-Warning_Write-Verbose_Write-Debug</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'EXAMPLE

function New-VirtualMachine
{
	[CmdletBinding()]
	param
	(
		[string]$VMName
	)
	
    switch ($VMName) {  										 
        'SQLInjectAttackName' {													&lt;===== So if VMName = 'SQLInjectAttackName'
            Write-Error -Message "OMG! Someone's trying to H@x0r our base!"		'Then do this
			#' NOTE: this is a non-terminating Error
        }

        'AlreadyExists' {
            Write-Warning -Message "You got a problem. This VM already exists so you can't add it, dummy"
        }

        'DoesNotExistAlready' {
            Write-Verbose -Message 'The VM does not already exist. You may proceed to add a new one with that name'
        }

        'FlakyIssue' {
            $ThatVariable = 'notright'					#'  &lt;==== This variable gets set inorder to demo suspended mode with the "-debug" Parameter
            Write-Debug -Message 'I will add this VM on host 123, blade 4564 on the molecule H2S squared'
        }
    }
}
======================================================================================
'Demo results--------
======================================================================================ERROR

##' Check what the $ErrorActionPreference variable is set at to see what kind of behavior to expect
$ErrorActionPreference
'OUTPUT
--------
'Continue				'&lt;==== This means when it hits a terminating or non-terminating error it is just going to keep going
						'&lt;==== 		so it will send the error output to the console and then continue
##' A major error occurs!!
&gt;New-VirtualMachine -VMName 'SQLInjectAttackName'

'OUTPUT (in Red)
----------------
#'New-VirtualMachine : OMG! Someone's trying to H@x0r our base!
#'At line:1 char:1
#'+ New-VirtualMachine -VMName 'SQLInjectAttackName'
#'+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
#'    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,New-VirtualMachine

======================================================================================

##' During debugging maybe I don't care for now if it throws an error. Override default behaviour in just this function
&gt;New-VirtualMachine -VMName 'SQLInjectAttackName' -ErrorAction SilentlyContinue
'OUTPUT
--------
'{none}
======================================================================================ERROR
&gt;$ErrorActionPreference = 'SilentlyContinue'			'&lt;===== Set it globally
&gt;$ErrorActionPreference
'OUTPUT
------------
'SilentlyContinue

##' Override it locally during this command
&gt;New-VirtualMachine -VMName 'AlreadyExists' -WarningAction Stop
'OUTPUT (in Red)
----------------
#'New-VirtualMachine : OMG! Someone's trying to H@x0r our base!
#'At line:1 char:1
#'+ New-VirtualMachine -VMName 'SQLInjectAttackName'
#'+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
#'    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,New-VirtualMachine
======================================================================================Warning

&gt;$WarningPreference				'&lt;===== global Warning preference
'OUTPUT
-------------
'Continue				'&lt;==== This means when it hits a terminating or non-terminating error it is just going to keep going
						'&lt;==== 		so it will send the error output to the console and then continue


&gt;New-VirtualMachine -VMName 'AlreadyExists'						
'OUTPUT   (in Orange)
------------
'WARNING: You got a problem. This VM already exists so you can't add it, dummy	

					
##' Override global behaviour w/ 'Stop' value for the Warningaction parameter
&gt;New-VirtualMachine -VMName 'AlreadyExists' -WarningAction Stop		
'OUTPUT  (first line is orange, then the rest is Red)
-------
#'WARNING: You got a problem. This VM already exists so you can't add it, dummy
#'Write-Warning : The running command stopped because the preference variable "WarningPreference" or common parameter is set to Stop: 
#'You got a problem. This VM already exists so you can't add it, dummy
#'At line:15 char:13
#'+             Write-Warning -Message "You got a problem. This VM alread ...
#'+             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'    + CategoryInfo          : OperationStopped: (:) [Write-Warning], ParentContainsErrorRecordException
#'    + FullyQualifiedErrorId : ActionPreferenceStop,Microsoft.PowerShell.Commands.WriteWarningCommand

======================================================================================Verbose
&gt;$VerbosePreference
'OUPUT
-----------
'SilentlyContinue
			
#' So by default this does not have any output
&gt;New-VirtualMachine -VMName 'DoesNotExistAlready'

#' Forgot -Verbose since $VerbosePreference defaults to SilentlyContinue
&gt;New-VirtualMachine -VMName 'DoesNotExistAlready' -Verbose
'OUTPUT   (in Blue)
----------
'VERBOSE: The VM does not already exist. You may proceed to add a new one with that name

'and you can set Global value to show Verbose messages:
&gt;$VerbosePreference = 'Continue'
======================================================================================Debug
'This is the line with the "Write-Debug" command
&gt;New-VirtualMachine -VMName 'FlakyIssue'
'OUTPUT
------------
'{none}

#' Setting a breakpoint to further investigate the variable
New-VirtualMachine -VMName 'FlakyIssue' -Debug
'In the IDE it throws up a pop-up:
'---------------------------------
'	Continue with this operation? 
'		[YES]
'		[Yes to All]
'		[Halt Command]
'		[Suspend]
'---------------------------------
#' IF you choose [Suspend] then it stops processing and throws you to the command line
'		it is supposed to be a double '&gt;&gt;' rather than a single '&gt;' BUT I did nto see that
'		To get out of the Suspended mode I typed 'Exit'
'	While in the 'DEBUG' suspended mode you can text the value of variables
&gt;$ThatVariable
'OUTPUT (from debug mode)
------------------------
'notright

======================================================================================PRODUCTION
'In production you can silence all the noise:
$ErrorActionPreference = 'SilentlyContinue'
$WarningPreference = 'SilentlyContinue'
$VerbosePreference = 'SilentlyContinue'
$DebugPreference = 'SilentlyContinue'


#' A VM already exists so instead of confusing the user let's just log to fictional file instead
'	This outputs the message to a variable "VMAlreadyExists", then appends that to a file
'NOTE: no "$" in front of the variable name, on the first line
&gt;New-VirtualMachine -VMName 'AlreadyExists' -WarningVariable VMAlreadyExists
if ($VMAlreadyExists) {
    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "WARNING: $VMAlreadyExists"
}
'OR output it to a new variable called "err"
New-VirtualMachine -VMName 'SQLInjectAttackName' -ErrorVariable err
if ($err) {
    Add-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log' -Value "ERR: $($err.Exception.Message)"
}

#' Check out the log
Get-Content -Path 'C:\Users\Administrator\Documents\somelogfile.log'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Format_Commands_to_change_output_vie</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Out-GridView</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Format_Commands_to_change_output_vie</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Out-GridView</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#-----------------------------------------------------------------------------#
# Out-GridView
#-----------------------------------------------------------------------------#
#region Out-GridView

	# With no params, just displays the results in the output panel
	Get-ChildItem | Out-GridView
	
	# Use -passthru to pipe the results to the next item
	# (without -PassThru nothing gets displayed)
	Get-ChildItem | Out-GridView -PassThru
	
	# Use output mode to determine way in which user 
	# can select output, single or mutliple
	Get-ChildItem | Out-GridView -OutputMode Single
	
	Get-ChildItem | Out-GridView -OutputMode Multiple
	
	# Can add useful titles to the display
	Get-ChildItem | Out-GridView -PassThru -Title "Hello World" 
	
	# You can send the output of the GridView to a variable,  note the output =&gt; 'ov'
	$ov = ""
	Get-ChildItem | Out-GridView -PassThru -OutVariable ov
	
	Clear-Host
	$ov     # Show the result
	
	# Works with -OutputMode too!
	Get-ChildItem | Out-GridView -OutputMode Single -OutVariable ov
	
	Clear-Host
	$ov
	
	# Cancel stops the flow. Run this twice, the second time hit cancel
	Get-ChildItem |
	  Out-GridView -OutputMode Single |
	  Format-Table -AutoSize 
	
	# Waiting around
	# Without wait, when launched from a command line 
	# the gridview won't wait. Open a CMD window then 
	# try these two commands.
	Powershell "Get-ChildItem | Out-GridView"
	Powershell "Get-ChildItem | Out-GridView -Wait" 
	
	
	# Gotcha: Don't try to use format-* before it
	# Yields an error b/c Out-GridView expects a collection of objects, BUT Format-Table sends a collection of TEXT
	Get-ChildItem |
	  Format-Table -Property Name,Length -AutoSize |
	  Out-GridView -PassThru
	
	# Instead use Select-Object, b/c this outputs objects
	Get-ChildItem |
	  Select-Object -Property Name, Length |
	  Out-GridView -PassThru

#endregion Out-GridView

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_LogParser</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>LogParser =&gt; SQL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_LogParser</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>LogParser =&gt; SQL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'This command asks Log Parser to filter out entries for pages 
#'	ending up in ".gif", ".jpg", and ".png", 
#'	regardless of the capitalization of the URL. 
#'	It also leaves out requests that generated the HTTP error code "404", 
#'	that is, "page not found".

#'Everything else is handed to the SQL output format, 
#'	which will save the records to the table specified in the INTO clause. 
#'	Also, this output format accepts a "database" parameter 
#'	that we can use to specify the name of the target database, 
#'	together with many other parameters that let us specify other properties of the connection 
#'	to the SQL database.

#'To do this, you could put the command above in a batch file, use the SCHTASKS.EXE utility to schedule the batch 
#'	file to run, say, every hour, and ' poof! ' you'd have an automated mechanism that periodically 
#'	uploads entries from your log files to your SQL database.
#'Note that every time you execute the command above, 
#'	Log Parser goes through all the log entries over and over, 
#'	uploading all of them multiple times to the database. 
#'	What we really need is a mechanism to say "only parse the log entries not parsed yet."
#'Here's where a new Log Parser 2.2 feature comes handy: the "incremental parsing" feature, 
#'	also know as "checkpointing."

Checkpoints
===========
#'Most Log Parser input formats support a parameter, called "iCheckpoint", 
#'	that tells the input format to save to a private data file (a "checkpoint" file) 
#'	the current state of all the files being parsed. 
#'	When you execute a query using a checkpoint file generated during a previous run, 
#'	the input format will only parse those portions of the input files that were not parsed before, that is, new entries only.


logparser "SELECT * INTO LogsTable FROM ex*.log WHERE TO_LOWERCASE (EXTRACT_EXTENSION(cs-uri-stem)) NOT IN ('gif';'jpg';'png') AND sc-status &lt;&gt; 404" -i:IISW3C -o:SQL -database:LogsDatabase

#'So, all you need to do is specify the name of a checkpoint file with the "iCheckpoint" parameter, as follows:

&gt;logparser "SELECT * INTO LogsTable FROM ex*.log WHERE TO_LOWERCASE (EXTRACT_EXTENSION(cs-uri-stem)) NOT IN ('gif';'jpg';'png') AND sc-status &lt;&gt; 404" -i:IISW3C -o:SQL -database:LogsDatabase -iCheckpoint:MyCheckpoint.lpc

#'The very first time you execute this command, 
#'	the "MyCheckpoint.lpc" file does not exist, 
#'	and the IISW3C input format parses all the entries in all the log files, 
#'	filtering and uploading the resulting data to the database. 
#'After parsing all the logs, the IISW3C input format saves the current size of each log file to the "MyCheckpoint.lpc" file.
#'When you execute the same command at a later time, 
#'	the IISW3C input format will load the checkpoint file 
#'	and will parse the logs starting at the position where they were left in the previous run, 
#'	thus processing, filtering, and uploading new log entries only. 
#'When completed, it will update the checkpoint file with the new size of the log files, 
#'	and the cycle repeats itself continually.


#'	-o:sql
#'	-database:AdventureWorks2012
#'	-server:localhost\sqlsrv2012
#'	-driver:"sql server"
#'	SELECT...into ScmEvents  {the SQL table}
&gt; logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" "select extract_token(EventTypeName, 0, ' ') as TypeEvent,  to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where SourceName = 'Service  Control Manager' and SID is not null"

'Delete
===========
#'there might also be times when you want to delete the data in the target table before inserting the new information. 
#'	To do so, you can use the -clearTable parameter with the sql output format, as shown in the following example:
#' IT IS MUCH MORE EFFICIENT TO USE SQL and run a truncate statement
&gt; logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on "select extract_token(EventTypeName, 0, ' ') as  TypeEvent, to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where SourceName =  'Service Control Manager' and SID is not null"

Insert data into table with IDENTITY Fields in table
====================================================
#'when you insert Log Parser data into a SQL Server table, 
#'    the number and position of fields must match the target table, 
#'    as was the case in the preceding two examples. 
#'However, there is one exception to the rule. 
#'    If the target table includes a column configured with the IDENTITY property, 
#'    you can specify that no data be inserted into that column. 
#'    Let’s re-create our target table to demonstrate how this works. 
#'The following T-SQL again creates the ScmEvents table, but this time includes the EventID column, 
#'    which is configured with the IDENTITY property:

USE AdventureWorks2012;
GO
IF OBJECT_ID('ScmEvents','U')IS NOT NULL
DROP TABLEScmEvents;
GO
CREATETABLE dbo.ScmEvents
(
  EventIDint primarykey identity,
  TypeEventvarchar(25) NOT NULL,
  DateGenerateddatetime NOT NULL,
  SecurityIDvarchar(50) NULL
);
GO

#'When using Log Parser to insert data into a table with an IDENTITY column, 
#'    we can use the -ignoreIdCols parameter with the sql output format to prevent the utility from trying to insert data into that column. 
#'    The following example includes the -ignoreIdCols parameter with it set to on:

logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on -ignoreIdCols:on "select extract_token(EventTypeName,  0, ' ') as TypeEvent, to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where  SourceName = 'Service Control Manager' and SID is not null"

CreateTable
============
#'When you run the command, Log Parser will create the table in the target database if the table does not already exist. 
#'However, if you were to run this command without including the -createTable parameter and the table did not exist, 
#'Log Parser would return an error.

&gt;logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on -createTable:on "select extract_token(EventTypeName, 0,  ' ') as TypeEvent, to_date(TimeGenerated) as DateGenerated, SID as SecurityID into ScmEvents from system where  SourceName = 'Service Control Manager' and SID is not null"


Query in External File
========================
#'When your SQL query becomes too unwieldy, 
#'    you can put the SQL in a separate file and call that file from your Log Parser command. 
#'For example, suppose we save the query in the previous example to the file C:\DataFiles\EvtQuery.sql

#'Once we’ve created the file for our query, we can modify our command as follows:

logparser -i:evt -resolveSIDs:on -o:sql -server:localhost\sqlsrv2012  -database:AdventureWorks2012 -driver:"sql server" -clearTable:on -createTable:on file:c:\datafiles\evtquery.sql
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Modules</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Example_01_Manifest.psd1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Modules</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Example_01_Manifest.psd1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#'Example_01_Manifest.psd1

#' Manifests extension is: .psd1

&lt;#-----------------------------------------------------------------------------
 The .psd1 file MUST have the same name as its parent folder!
-----------------------------------------------------------------------------#&gt;

@{

# Name of the module to process
ModuleToProcess = 'bpsd-m05-module-advanced-module.psm1'

# Each module has to be uniquely identified. To do that PS uses a GUID.
# To generate a GUID, use the New-Guid cmdlet and copy the result in here
GUID = 'f8b3f920-a8e9-4e25-aef0-e0f3b3fb9978'

# Who wrote this module
Author = 'Robert C. Cain'

# Company who made this module
CompanyName = 'Pluralsight'

# Copyright 
Copyright = '(c) 2015 All rights reserved'

# Description of the module
Description = 'Sample demo for the Beginning PowerShell for Developers course'

# Version number for the module
ModuleVersion = '1.0.0.0'

# Minimum version of PowerShell needed to run this module
PowerShellVersion = '3.0'

# Min version of .NET Framework required 
DotNetFrameworkVersion = '2.0'

# Min version of the CLR required 
CLRVersion = '2.0.50727'

# Note there are many more items you can set.
}


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_poswsus</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Install-WSUSServer.ps1</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_poswsus</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Install-WSUSServer.ps1</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#' TO install only the console
#'			. .\Install-WSUSServer.ps1 –ConsoleOnly -verbose
===========================================================================================
This script allows you to install a WSUS server locally or remotely using a variety of configuration options. 
	You can also just install the WSUS Administration Console without having to install the entire server! 
	This script makes use of psexec.exe, 
		which is available to download from this link: 
		http://download.sysinternals.com/Files/SysinternalsSuite.zip. 
	This file must be in the same location as the script, 
		otherwise the script will not run.

The script also requires either the x86 or x64 installation file, 
	which the script will download for you if you allow it to and have an available internet connection 
		from the location you are running the script. 
Keep in mind that the installation files must be in the same location as the script 
	and you also need to keep the installation file's original name.

Also, be sure to check out my companion script: Uninstall-WSUSServer.ps1 as well!
============================================================================================
&lt;#  
.SYNOPSIS  
    Downloads (if needed) and performs an unattended installation of WSUS Server with SP2 on a local or remote system. Requires psexec.exe to be in the same
    location as the script in order to run properly.

.DESCRIPTION
    Downloads (if needed) and performs an unattended installation of WSUS Server with SP2 on a local or remote system. Requires psexec.exe to be in the same
    location as the script in order to run properly. Also optional to have the installation files in the same location as the script, otherwise the files will
    be downloaded from the internet.
     
.PARAMETER Computername
    Name of computer to install WSUS server on.

.PARAMETER ConsoleOnlyServer
    Switch used to only install the console without installing the server application.

.PARAMETER StoreUpdatesLocally
    Switch used to determine if updates will be downloaded and saved to system locally.

.PARAMETER ContentDirectory
    Path to the local content folder holding update files. Default location is: %rootdrive%\WSUS\WSUSContent where the root drive is the largest local drive on the system.

.PARAMETER InternalDatabasePath
    Path to install the internal database
    
.PARAMETER CreateDatabase
    Create a database on the SQL server. Will not create database and attempt to use existing database if switch not used.

.PARAMETER WebsitePort
    Determine the port of the WSUS Site. Accepted Values are "80" and "8530". 

.PARAMETER SQLInstance
    Name of the SQL Instance to connect to for database
    
.PARAMETER IsFrontEndServer
    This server will be a front end server in an NLB

.NOTES  
    Name: Install-WSUSServer
    Author: Boe Prox
    DateCreated: 29NOV2011 
           
.LINK  
    https://learn-powershell.net
    
.EXAMPLE
Install-WSUSServer.ps1 -ConsoleOnly

Description
-----------
Installs the WSUS Console on the local system

.EXAMPLE
Install-WSUSServer.ps1 -ConsoleOnly -Computername Server1

Description
-----------
Installs the WSUS Console on the remote system Server1

.EXAMPLE
Install-WSUSServer.ps1 -Computername TestServer -StoreUpdatesLocally -ContentDirectory "D:\WSUS" -InternalDatabasePath "D:\" -CreateDatabase

Description
-----------
Installs WSUS server on TestServer and stores content locally on D:\WSUS and installs an internal database on D:\

.EXAMPLE
Install-WSUSServer.ps1 -Computername A24 -StoreUpdatesLocally -ContentDirectory "D:\WSUS" -SQLInstance "Server1\Server1" -CreateDatabase

Description
-----------
Installs WSUS server on TestServer and stores content locally on D:\WSUS and creates a database on Server1\Server1 SQL instance

.EXAMPLE
Install-WSUSServer.ps1 -Computername A24 -StoreUpdatesLocally -ContentDirectory "D:\WSUS" -SQLInstance "Server1\Server1"

Description
-----------
Installs WSUS server on TestServer and stores content locally on D:\WSUS and uses an existing WSUS database on Server1\Server1 SQL instance
#&gt; 
[cmdletbinding(
    DefaultParameterSetName = 'Console',
    SupportsShouldProcess = $True
)]
Param (
    [parameter(ValueFromPipeLine = $True)]
    [string]$Computername = $Env:Computername,
    [parameter(ParameterSetName = 'Console')]
    [switch]$ConsoleOnly,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [switch]$StoreUpdatesLocally,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [string]$ContentDirectory,
    [parameter(ParameterSetName = 'InternalDatabase')]
    [string]$InternalDatabasePath, 
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [ValidateSet("80","8530")]
    [string]$WebsitePort,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [switch]$CreateDatabase,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [string]$SQLInstance,
    [parameter(ParameterSetName = 'SQLInstanceDatabase')]
    [parameter(ParameterSetName = 'InternalDatabase')]
    [switch]$IsFrontEndServer    
    
)
Begin {
    If (-NOT (Test-Path psexec.exe)) {
        Write-Warning ("Psexec.exe is not in the current directory! Please copy psexec to this location: {0} or change location to where psexec.exe is currently at.`nPsexec can be downloaded from the following site:`
        http://download.sysinternals.com/Files/SysinternalsSuite.zip" -f $pwd)
        Break
    }
    
    #Source Files for X86 and X64
    Write-Verbose "Setting source files"
    $x86 = Join-Path $pwd "WSUS30-KB972455-x86.exe"
    $x64 = Join-Path $pwd "WSUS30-KB972455-x64.exe"
        
    #Menu items for later use if required
    Write-Verbose "Building scriptblock for later use"
    $sb = {$title = "WSUS File Required"
    $message = "The executable you specified needs to be downloaded from the internet. Do you wish to allow this?"
    $yes = New-Object System.Management.Automation.Host.ChoiceDescription "&amp;Yes", `
        "Download the file."
    $no = New-Object System.Management.Automation.Host.ChoiceDescription "&amp;No", `
        "Do not download the file. I will download it myself."    
    $options = [System.Management.Automation.Host.ChoiceDescription[]]($yes, $no)
    Write-Verbose "Launching menu for file download"
    $Host.ui.PromptForChoice($title, $message, $options, 0)}             
    
    Write-Verbose "Adding URIs for installation files"
    #URI of specified files if needed to download        
    $WSUS_X86 = "http://download.microsoft.com/download/B/0/6/B06A69C3-CF97-42CF-86BF-3C59D762E0B2/WSUS30-KB972455-x86.exe"
    $WSUS_X64 = "http://download.microsoft.com/download/B/0/6/B06A69C3-CF97-42CF-86BF-3C59D762E0B2/WSUS30-KB972455-x64.exe"
    
    #Define Quiet switch first
    $arg = "/q "
    
    #Process parameters
    If ($PSBoundParameters['ConsoleOnly']) {
        Write-Verbose "Setting argument to Console Install Only"
        $arg += "CONSOLE_INSTALL=1 "
    }
    If ($PSBoundParameters['StoreUpdatesLocally']){
        $arg += "CONTENT_LOCAL=1 "
        If ($PSBoundParameters['ContentDirectory']) {
            $arg += "CONTENT_DIR=$ContentDirectory "
        }
    }
    If ($PSBoundParameters['WebsitePort']) {
            Switch ($WebsitePort) {
            "80" {
                $arg += "DEFAULT_WEBSITE=1 "
            }
            "8530" {
                $arg += "DEFAULT_WEBSITE=0 "
            }
            Default {
                $arg += "DEFAULT_WEBSITE=1 "
            }
        }
    }
    If ($PSBoundParameters['InternalDatabasePath']) {
        $arg += "WYUKON_DATA_DIR=$InternalDatabasePath "
    }
    If ($PSBoundParameters['CreateDatabase']) {
        $arg += "CREATE_DATABASE=1 "
    } ElseIf ($PSCmdlet.ParameterSetName -ne 'Console') {
        #Use default database
        $arg += "CREATE_DATABASE=0 "
    }
    If ($PSBoundParameters['SQLInstance']) {
        $arg += "SQLINSTANCE_NAME=$SQLInstance "
    }
    If ($PSBoundParameters['IsFrontEndServer']) {
        $arg += "FRONTEND_SETUP=1 "
    }
}
Process {
    Try {
        $OSArchitecture = Get-WmiObject Win32_OperatingSystem -ComputerName $Computername | Select -Expand OSArchitecture -EA Stop
    } Catch {
        Write-Warning ("{0}: Unable to perform lookup of operating system!`n{1}" -f $Computername,$_.Exception.Message)
    }  
    If ($OSArchitecture -eq "64-bit") {
        Write-Verbose ("{0} using 64-bit" -f $Computername)
        If (-NOT (Test-Path $x64)) {
            Write-Verbose ("{0} not found, download from internet" -f $x64)
            switch (&amp;$sb) {
                0 {
                    If ($pscmdlet.ShouldProcess($WSUS_X64,"Download File")) {
                        Write-Verbose "Configuring webclient to download file"
                        $wc = New-Object Net.WebClient
                        $wc.UseDefaultCredentials = $True              
                        Write-Host -ForegroundColor Green -BackgroundColor Black ("Downloading from {0} to {1} prior to installation. This may take a few minutes" -f $WSUS_X64,$x64)
                        Try {
                            $wc.DownloadFile($WSUS_X64,$x64)                                                                                    
                        } Catch {
                            Write-Warning ("Unable to download file!`nReason: {0}" -f $_.Exception.Message)
                            Break
                        } 
                    }                   
                }
                1 {
                    #Cancel action
                    Break
                }                
            }
        } 
        #Copy file to root drive
        If (-NOT (Test-Path ("\\$Computername\c$\{0}" -f (Split-Path $x64 -Leaf)))) {
            Write-Verbose ("Copying {0} to {1}" -f $x64,$Computername)
            If ($pscmdlet.ShouldProcess($Computername,"Copy File")) {                                
                Try {
                    Copy-Item -Path $x64 -Destination "\\$Computername\c$" -EA Stop
                } Catch {
                    Write-Warning ("Unable to copy {0} to {1}`nReason: {2}" -f $x64,$Computername,$_.Exception.Message)
                }
            }
        } Else {Write-Verbose ("{0} already exists on {1}" -f (Split-Path $x64 -Leaf),$Computername)}
        #Perform the installation
        Write-Verbose ("Begin installation on {0} using specified options" -f $Computername)
        If ($pscmdlet.ShouldProcess($Computername,"Install WSUS")) {
            .\psexec.exe -accepteula -i -s \\$Computername cmd /c ("C:\{0} $arg" -f (Split-Path $x64 -Leaf))                                
        }
    } Else {
        Write-Verbose ("{0} using 32-bit" -f $Computername)
        If (-NOT (Test-Path $x86)) {
            Write-Verbose ("{0} not found, download from internet" -f $x86)
            switch (&amp;$sb) {
                0 {
                    If ($pscmdlet.ShouldProcess($WSUS_X86,"Download File")) {
                        Write-Verbose "Configuring webclient to download file"
                        $wc = New-Object Net.WebClient
                        $wc.UseDefaultCredentials = $True              
                        Write-Host -ForegroundColor Green -BackgroundColor Black ("Downloading from {0} to {1} prior to installation. This may take a few minutes" -f $WSUS_X86,$x86)
                        Try {
                            $wc.DownloadFile($WSUS_X86,$x86)                                                                                          
                        } Catch {
                            Write-Warning ("Unable to download file!`nReason: {0}" -f $_.Exception.Message)
                            Break
                        }
                    }                    
                }
                1 {
                    #Cancel action
                    Break
                }                                
            }
        }
        #Copy file to root drive
        If (-NOT (Test-Path ("\\$Computername\c$\{0}" -f (Split-Path $x86 -Leaf)))) {
            Write-Verbose ("Copying {0} to {1}" -f $x86,$Computername) 
            If ($pscmdlet.ShouldProcess($Computername,"Copy File")) {
                Try {
                    Copy-Item -Path $x86 -Destination "\\$Computername\c$" -EA Stop
                } Catch {
                    Write-Warning ("Unable to copy {0} to {1}`nReason: {2}" -f $x86,$Computername,$_.Exception.Message)
                }
            }
        } Else {Write-Verbose ("{0} already exists on {1}" -f $x86,$Computername)}
        #Perform the installation
        Write-Verbose ("Begin installation on {0} using specified options" -f $Computername)
        If ($pscmdlet.ShouldProcess($Computername,"Install WSUS")) {
            .\psexec.exe -accepteula -i -s \\$Computername cmd /c ("C:\{0} $arg" -f (Split-Path $x86 -Leaf))
        }
    }   
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Profile</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>issues_for_a_single_profile_for_multiple_Hosts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Profile</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>issues_for_a_single_profile_for_multiple_Hosts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Most of your profile stuff will probably be common to any host, 
' so using a single profile means that any changes down the road will be done in exactly one file. 
' For the stuff that differs amongst hosts, just include a section specific to each host you care about. 


if ($Host.Name -eq 'ConsoleHost')
{
    Import-Module PSReadline
    # differentiate verbose from warnings!
    $privData = (Get-Host).PrivateData
    $privData.VerboseForegroundColor = "cyan"
}
elseif ($Host.Name -like '*ISE Host')
{
    Start-Steroids
    Import-Module PsIseProjectExplorer
}
if (!$env:github_shell)
{
    # not sure why, but this fails in a git-flavored host
    Add-PSSnapin Microsoft.TeamFoundation.PowerShell
}</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Regex</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>about_POWERSHELL_Regex</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Regex</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>about_POWERSHELL_Regex</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_POWERSHELL_Regex

some examples: https://blogs.technet.microsoft.com/heyscriptingguy/2016/10/28/powershell-regex-crash-course-part-5-of-5/
=============================================================
*	Means zero or more of something
+	Means one or more of something
?	Means zero or one of something

Special character	Meaning							Example
-----------------	----------------------------	--------------------------------------------------------
. (period)			Matches any single character	‘something’ -match ‘some.hing’ 				#'returns true because the ‘t’ is a single character that matches this pattern

\n					Matches a newline character		@”
													This is some multi
													Line text
													“@ -match ‘\n’  				 			#'returns true because there is a new line between ‘multi’ and ‘line’

\t					Matches a tab character			Works just like the newline except for tabs instead of new lines
\d					Matches any digit (0-9)			‘testing123’ -match ‘\d’  					#'returns true because there are numbers present
\D					Matches a non-digit			    ‘1234’ -match ‘\D’  						#'returns false because everything in the string is a number
\w					Matches an alphanumeric character		‘hello123’ -match ‘\w’  			#'returns true because alpha numeric characters are present
\W					Matches a non-alphanumeric character	‘hello123’ -match ‘\W’ 				#'returns false because everything is an alphanumeric character
\s					Matches a whitespace character			‘ ‘ -match ‘\s’ 					#'returns true because between the quotation marks is a single space
\S					Matches a non-whitespace character		‘ ‘ -match ‘\S’  				 	#'returns false because all the characters are whitespace
\					Use \ to escape special characters		\. matches a dot and Error! Hyperlink reference not valid. matches a backslash
^					Matches the start of a string	
$					Matches the end of a string	

=============================================================[regex]
'Here, I’m looking for the digits in “abc123” using the matches() method of the [regex] accelerator. 
'The first parameter is the string to look within, and the second is the regex pattern to match.
'Here, I’m looking for the digits in “abc123” using the matches() method of the [regex] accelerator.
[regex]::matches(‘abc123’,‘\d’).value  #'returns 1, 2, 3 in an array

[regex]::matches(‘abc123’,‘\d\d\d’).value  #returns 123 in a string
============================================================={}
'We use curly braces to signify the number of times that we want a specific pattern or character to occur in our matches. 
something123’ -match ‘\d{3}’  #'returns true
'We know that the \d part of this pattern matches any digit. 
'the part that comes right before the curly braces to occur the number of times shown within the curly braces.

'We can also specify ranges.
something123’ -match ‘\d{2,4}  #returns true
'You can also go {2,} to specify “two or more times”.
=============================================================()
' round () brackets. In regex, we can use round brackets to group things. 
'whatever is in the brackets will be evaluated and returned as a match together. 
‘hello123hello123hello123’ -match ‘(hello123){3}’  #'returns true

‘hello123hello123 something else’ -match ‘(hello123){1,4}\s?something’  #'returns true
'but what I’m matching is “one to four occurrences of ‘hello123’ followed by zero or one whitespace, followed by ‘something'”

‘192.168.1.1’ -match ‘(\d{1,3}\.){3}\d{1,3}’
'Let’s break it down.
\d{1,3} 	' looking for one to three digits
\. 			' looking for a period
'Therefore, \d{1,3}\. is looking for one to three digits, followed by a period

(\d{1,3}\.){3} ' looking for three occurrences of “one to three digits followed by a period”
=============================================================[]
'In regex, we use square brackets to denote a set. 
'That might mean a range of characters or an array of characters that we’re interested in.

‘something’ -match ‘[f-q]$’ #'returns true
'In the first example, we’re looking for the pattern “a letter between f and q, 
'followed by the end of the line”. 
'Because “something” ends in g, which is between f and q, the pattern is a match. 


‘something’ -match ‘[h-q]$’  #'returns false
'we’re looking for “a letter between h and q, followed by the end of the line” 
'which doesn’t exist since g falls outside that range. 
'This is case sensitive in regex, 
'but the –match operator doesn’t take case into account.
=============================================================^
'You can negate a set, too, using the ^ symbol. That is to say, match “not this character”.
‘something’ -match ‘[^q]$’  #'returns true
‘something’ -match ‘[^g]$’  #'returns false
'The first example says, “something that is not a q followed by the end of the line” which matches our string of “something”. 
'The next example says, “something that is not a g followed by the end of the line” which returns false, because “something” ends in a g followed by the end of the line.



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Remoting</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>WORKGROUP_machines</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Remoting</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>WORKGROUP_machines</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

https://blogs.msdn.microsoft.com/wmi/2009/07/24/powershell-remoting-between-two-workgroup-machines/

The computer you’re sitting in front of is called the client machine, 
	while the computer you’re trying to remotely access is called the server machine.
	
First, configure the SERVER machine to allow access. 
---------------------------------------------------	
&gt;Enable-PSRemoting –force

If one of the network cards on your computer has the network connection type set to “Public” 
	then the required port won’t be opened in your firewall settings.
	
If you’d rather not change your network connection type, 
	you’ll have to manually configure your firewall to allow traffic through.	
	
Make sure that the password for your Administrator account is not empty!  
	If it is, you won’t be able to log in remotely.
	
Now you’ll need to configure your CLIENT machine. 
------------------------------------------------

 enable WinRM local access so that you can modify the proper settings. 
 To do this, start the WinRM service and enable the local account token filter policy 
 
 Both of the next 2 steps are unnecessary if 
 	you’ve already run the Enable-PSRemoting cmdlet on your client machine.
 
 &gt;Start-Service WinRM
 &gt;Set-ItemProperty –Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System –Name  LocalAccountTokenFilterPolicy –Value 1 –Type DWord
 
 next (on the SERVER)
 --------
 Now that WinRM local access is enabled, 
 	you’ll need to add the name of your server machine to the TrustedHosts setting in the WinRM configuration, 
 	which enables your client machine to connect to your server machine 
 	using an authentication mechanism that does not authenticate the server (like Kerberos does):

&gt;Set-Item WSMan:\localhost\Client\TrustedHosts –Value &lt;ServerMachineName&gt; -Force

This command replaces any previous value that was stored in TrustedHosts!  
	If there is an existing list of servers and you don’t want to remove then, 
	use the –Concatenate parameter:
	
&gt;Set-Item WSMan:\localhost\Client\TrustedHosts –Value &lt;ServerMachineName&gt; -Force -Concatenate

If you want to use your server machine’s IP address instead of its name, 
	you must specify explicit credentials when you connect.
	
------------------------------------------------
'From client (HOMETOWER) to server (HOME-LAPTOP)	
&gt;Test-WSMan home-laptop	
'OUTPUT
--------
#'wsmid           : http://schemas.dmtf.org/wbem/wsman/identity/1/wsmanidentity.xsd
#'ProtocolVersion : http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd
#'ProductVendor   : Microsoft Corporation
#'ProductVersion  : OS: 0.0.0 SP: 0.0 Stack: 3.0#'
#'	

'INVOKE-COMMAND works	
&gt;Invoke-Command -ComputerName home-laptop -ScriptBlock { Get-ChildItem C:\ } -credential glenn
'OUTPUT
--------
#'
#'    Directory: C:\
#'
#'
#'Mode                LastWriteTime         Length Name                                                         PSComputerName                                             
#'----                -------------         ------ ----                                                         --------------                                             
#'d-----       12/18/2016   3:20 PM                DATA                                                         home-laptop                                                
#'d-----       12/18/2016   7:58 AM                Downloads                                                    home-laptop                                                
#'d-----        4/12/2016   1:36 AM                eSupport                                                     home-laptop                                                
#'d-----        7/16/2016   6:47 AM                PerfLogs                                                     home-laptop                                                
#'d-r---        8/29/2017   9:21 AM                Program Files                                                home-laptop                                                
#'d-r---        5/13/2017   4:48 PM                Program Files (x86)                                          home-laptop                                                
#'d-r---       12/18/2016   1:13 PM                Users                                                        home-laptop                                                
#'d-----        8/29/2017   5:50 PM                Windows                                                      home-laptop                                                
#'d-----        3/31/2017   5:49 AM                Windows.old                                                  home-laptop   
	
'BUT 'Get-CimInstance' fails from the client
&gt;Get-CimInstance –ClassName Win32_ComputerSystem –Computer HOME-LAPTOP -Verbose	
' Access is denied.	

'I can enter a session on the client (i.e. HOMETOWER) to the server:
&gt;Enter-PSSession -ComputerName home-laptop -Credential glenn
'Now we are actually on the server
'Then create an option variable
[home-laptop]: &gt; $CimOption = New-CimSessionOption -Protocol Dcom
'Then enter a CIM Session locally on the Server:
[home-laptop]: PS C:\Users\glenn\Documents&gt; $CimSession = New-CimSession  -SessionOption $CimOption
'and we can confirm we are on the Server:
&gt;Get-ChildItem C:\
'it returns the contents of the Server's C Drive
	
------------------------------------------------	
To check if the WinRM service is running:
               &gt;Get-Service WinRM

To check the version of WinRM that’s installed:
               &gt;Test-WSMan –Auth default

To check the remoting configuration for PowerShell:
               &gt;Get-PSSessionConfiguration

To verify that local WinRM access is working:
               &gt;New-PSSession

To check if the local account token filter policy is enabled (on Windows Vista and Windows Server 2008):
                &gt;Get-ItemProperty –Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System –Name LocalAccountTokenFilterPolicy*

To check if the network access policy “Sharing and security model for local accounts” is set to Classic (on Windows XP):
                Get-ItemProperty –Path HKLM:\System\CurrentControlSet\Control\Lsa –Name ForceGuest*

To check the WinRM listener settings:
               &gt;winrm enumerate winrm/config/listener

For additional help and troubleshooting steps:
                Get-Help about_remote_troubleshooting</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Updates_WSUS</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>PendingUpdates_GetList</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Updates_WSUS</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>PendingUpdates_GetList</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>This is just to see what updates I have pending on my workstation

'Finding Pending Updates Using PowerShell
'https://mcpmag.com/articles/2016/06/23/finding-pending-updates.aspx
=======================================================================
#'We can't easily see what updates are currently available on a system 
#'    'unless we go into the Windows Updates settings and view the updates 
#'    or we can query the event log to see what updates have been downloaded 
#'    and are waiting to install. 
#'I am going with a different approach by directly going into the windows update agent 
#'    via its API to search for and report on downloaded updates that are waiting to be installed.  
#'To do this, I am going to make use of Microsoft.Update.Session COM object 
#'    to get our foot in the door to begin hunting down pending updates.

$Computername = $env:COMPUTERNAME
$updatesession =  [activator]::CreateInstance([type]::GetTypeFromProgID("Microsoft.Update.Session",$Computername))

#'In this case, I am just going to look at my local system for updates. 
#'    Because I want to have something that will work remotely, 
#'    I am choosing to use the [Activator] with its CreateInstance() method 
#'    and supplying the type that I am looking to connect to remotely as well as supplying the computer name. 
#'By doing this, I will have created my UpdateSearcher object that will be used to look for updates.
#'
#'Once I have this created, 
#'    I can then begin a search using the Search() method and supplying a string which contains a specific query. 
#'More information about what kinds of queries you can perform can be found at this MSDN link. 
#'Note that the following code may take a few minutes to run.
#'
$searchresult = $updatesearcher.Search("IsInstalled=0")  #' 0 = NotInstalled | 1 = Installed 

#'In this case, 
#'    I am only looking for updates that are not currently installed. 
#'    Now I cannot query whether an update has been downloaded or not, 
#'    so I will need to deal with that later on. 
#'Once completed, we can get an idea on how many updates are available 
#'    by looking at the count of the results returned for updates.
#'
$searchresult.Updates.Count

========'all the pieces 
$Computername = $env:COMPUTERNAME
$updatesession = [activator]::CreateInstance([type]::GetTypeFromProgID("Microsoft.Update.Session",$Computername))
$UpdateSearcher = $updatesession.CreateUpdateSearcher()
$searchresult = $updatesearcher.Search("IsInstalled=0") # 0 = NotInstalled | 1 = Installed 
$searchresult.Updates.Count

-------------------------------------------------------------------------
'Since I do have updates which are available and not yet installed, 
'	it is time to take a look and see what they are.

-------------------------------------------------------------------------
$Updates = If ($searchresult.Updates.Count  -gt 0) {

  #Updates are  waiting to be installed

  $count  = $searchresult.Updates.Count

  Write-Verbose  "Found $Count update\s!"

  #Cache the  count to make the For loop run faster   

  For ($i=0; $i -lt $Count; $i++) {

  #Create  object holding update

  $Update  = $searchresult.Updates.Item($i)

  [pscustomobject]@{

  Title =  $Update.Title

  KB =  $($Update.KBArticleIDs)

  SecurityBulletin = $($Update.SecurityBulletinIDs)

  MsrcSeverity = $Update.MsrcSeverity

  IsDownloaded = $Update.IsDownloaded

  Url =  $Update.MoreInfoUrls

  Categories =  ($Update.Categories  | Select-Object  -ExpandProperty Name)

  BundledUpdates = @($Update.BundledUpdates)|ForEach{

  [pscustomobject]@{

  Title = $_.Title

  DownloadUrl = @($_.DownloadContents).DownloadUrl

  }

  }

  }      

  }

  } 
========================================================================


$Updates = If ($searchresult.Updates.Count -gt 0) {
                                                    #'Updates are waiting to be installed
                                                    $count = $searchresult.Updates.Count
                                                    Write-Verbose "Found $Count update\s!"
                                                    #'Cache the count to make the For loop run faster 
                                                    For ($i=0; $i -lt $Count; $i++) {
                                                                                    #'Create object holding update
                                                                                    $Update = $searchresult.Updates.Item($i)
                                                                                    [pscustomobject]@{
                                                                                                    Title = $Update.Title
                                                                                                    KB = $($Update.KBArticleIDs)
                                                                                                    SecurityBulletin = $($Update.SecurityBulletinIDs)
                                                                                                    MsrcSeverity = $Update.MsrcSeverity
                                                                                                    IsDownloaded = $Update.IsDownloaded
                                                                                                    Url = $Update.MoreInfoUrls
                                                                                                    Categories = ($Update.Categories | Select-Object -ExpandProperty Name)
                                                                                                    BundledUpdates = @($Update.BundledUpdates)|ForEach{
                                                                                                                                                        [pscustomobject]@{
                                                                                                                                                                            Title = $_.Title
                                                                                                                                                                            DownloadUrl = @($_.DownloadContents).DownloadUrl
                                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                    } 
                                                                                    }
                                                    }

#' Then to see the results

$IsDownloaded = $Updates|group IsDownloaded

#Index 1 is downloaded updates 

$IsDownloaded[1].Group

#'$IsDownloaded[1].Group[1]

$IsDownloaded[1].Group[1].BundledUpdates|Format-List 

$IsDownloaded[1].Group  | Export-Csv -NoTypeInformation  -Path DownloadedUpdates.csv </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>String_Formatting</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>String_Formatting</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
# String Formatting - C# like syntax is supported
#   In C you'd use a static method (i.e. [string]) with a place holder (i.e. {0} )
[string]::Format("There are {0} items.", $items)

# Powershell shortcut { "-f" is an indicator that is requesting formatting}
# Place {0} {1} etc. into the string as placemarkers where you want the variables to appear, 
# immediately follow the string with the -f operator and then lastly, 
#  a list of comma separated variables which will be used to populate the placemarkers.
"There are {0} items." -f $items

"There are {0} items in the location {1}." -f $items, $loc

# You can repeat place holders
"There are {0} items in the location {1}. Wow, {0} is a lot of items!" -f $items, $loc

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>String_METHODS</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>String_METHODS</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>$s.Length           #' &lt;==== this is a property
$s.ToUpper()        #' &lt;==== this is a Method

$s.Substring.OverloadDefinitions	#' To see the overloads for the method 'Substring'

=============================================================
$s = "powershell rocks!"
$s | Get-Member
'OUTPUT is list of methods and properties
--------
   TypeName: System.String

Name             MemberType            Definition                                                                                                                        
----             ----------            ----------                                                                                                                        
Clone            Method                System.Object Clone(), System.Object ICloneable.Clone()                                                                           
CompareTo        Method                int CompareTo(System.Object value), int CompareTo(string strB), int IComparable.CompareTo(System.Object obj), int IComparable[s...
Contains         Method                bool Contains(string value)                                                                                                       
CopyTo           Method                void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count)                                                 
EndsWith         Method                bool EndsWith(string value), bool EndsWith(string value, System.StringComparison comparisonType), bool EndsWith(string value, b...
Equals           Method                bool Equals(System.Object obj), bool Equals(string value), bool Equals(string value, System.StringComparison comparisonType), b...
GetEnumerator    Method                System.CharEnumerator GetEnumerator(), System.Collections.IEnumerator IEnumerable.GetEnumerator(), System.Collections.Generic.I...
GetHashCode      Method                int GetHashCode()                                                                                                                 
GetType          Method                type GetType()                                                                                                                    
GetTypeCode      Method                System.TypeCode GetTypeCode(), System.TypeCode IConvertible.GetTypeCode()                                                         
IndexOf          Method                int IndexOf(char value), int IndexOf(char value, int startIndex), int IndexOf(char value, int startIndex, int count), int Index...
										---------------------
										#'this is case-sensitive, results in the position of the first occurance of the letter 's'
										$s.IndexOf("s")
										---------------------
IndexOfAny       Method                int IndexOfAny(char[] anyOf), int IndexOfAny(char[] anyOf, int startIndex), int IndexOfAny(char[] anyOf, int startIndex, int co...
Insert           Method                string Insert(int startIndex, string value)                                                                                       
IsNormalized     Method                bool IsNormalized(), bool IsNormalized(System.Text.NormalizationForm normalizationForm)                                           
LastIndexOf      Method                int LastIndexOf(char value), int LastIndexOf(char value, int startIndex), int LastIndexOf(char value, int startIndex, int count...
										-----------------
										'Get the position of the last occurance of the letter 's'
										$s.LastIndexOf("s")
										-----------------
LastIndexOfAny   Method                int LastIndexOfAny(char[] anyOf), int LastIndexOfAny(char[] anyOf, int startIndex), int LastIndexOfAny(char[] anyOf, int startI...
Normalize        Method                string Normalize(), string Normalize(System.Text.NormalizationForm normalizationForm)                                             
PadLeft          Method                string PadLeft(int totalWidth), string PadLeft(int totalWidth, char paddingChar)                                                  
PadRight         Method                string PadRight(int totalWidth), string PadRight(int totalWidth, char paddingChar)                                                
Remove           Method                string Remove(int startIndex, int count), string Remove(int startIndex)                                                           
Replace          Method                string Replace(char oldChar, char newChar), string Replace(string oldValue, string newValue)                                      
										-----------------
										#'this is case-sensitive, replaces occurrances of 'e' with '3'
										$s.Replace("e","3")
										#'make multiple changes at once
										$name = $s.Replace("p","P").Replace("s","S")
										-----------------
Split            Method                string[] Split(Params char[] separator), string[] Split(char[] separator, int count), string[] Split(char[] separator, System.S...
										-----------------
										$t = 'a,b,c,d,e,f,g'    #'This is a string, not an array
										$t
										$t -is [array]
										$split = $t.Split(",")	#'This creates an Array named $split
										$split 
										$split -is [array]
										--------------------
										$name = 'glenn garson'
										$first = $name.split(' ')[0]
										$last = $name.split(' ')[1]
										-----------------
StartsWith       Method                bool StartsWith(string value), bool StartsWith(string value, System.StringComparison comparisonType), bool StartsWith(string va...
Substring        Method                string Substring(int startIndex), string Substring(int startIndex, int length)                                                    
										-----------------
										'0 is the first position, this gives the string's value starting at the 6th position
										$s.Substring(5)
										'0 is the first position, this gives the 3 characters starting at the 2nd position, ending at the 5th position
										$s.Substring(1,4)	
										------------------
ToBoolean        Method                bool IConvertible.ToBoolean(System.IFormatProvider provider)                                                                      
ToByte           Method                byte IConvertible.ToByte(System.IFormatProvider provider)                                                                         
ToChar           Method                char IConvertible.ToChar(System.IFormatProvider provider)                                                                         
ToCharArray      Method                char[] ToCharArray(), char[] ToCharArray(int startIndex, int length)                                                              
ToDateTime       Method                datetime IConvertible.ToDateTime(System.IFormatProvider provider)                                                                 
ToDecimal        Method                decimal IConvertible.ToDecimal(System.IFormatProvider provider)                                                                   
ToDouble         Method                double IConvertible.ToDouble(System.IFormatProvider provider)                                                                     
ToInt16          Method                int16 IConvertible.ToInt16(System.IFormatProvider provider)                                                                       
ToInt32          Method                int IConvertible.ToInt32(System.IFormatProvider provider)                                                                         
ToInt64          Method                long IConvertible.ToInt64(System.IFormatProvider provider)                                                                        
ToLower          Method                string ToLower(), string ToLower(cultureinfo culture)                                                                             
ToLowerInvariant Method                string ToLowerInvariant()                                                                                                         
ToSByte          Method                sbyte IConvertible.ToSByte(System.IFormatProvider provider)                                                                       
ToSingle         Method                float IConvertible.ToSingle(System.IFormatProvider provider)                                                                      
ToString         Method                string ToString(), string ToString(System.IFormatProvider provider), string IConvertible.ToString(System.IFormatProvider provider)
ToType           Method                System.Object IConvertible.ToType(type conversionType, System.IFormatProvider provider)                                           
ToUInt16         Method                uint16 IConvertible.ToUInt16(System.IFormatProvider provider)                                                                     
ToUInt32         Method                uint32 IConvertible.ToUInt32(System.IFormatProvider provider)                                                                     
ToUInt64         Method                uint64 IConvertible.ToUInt64(System.IFormatProvider provider)                                                                     
ToUpper          Method                string ToUpper(), string ToUpper(cultureinfo culture)  
										------------------
										'Gets uppercase
										------------------										                                                                           
ToUpperInvariant Method                string ToUpperInvariant()                                                                                                         
Trim             Method                string Trim(Params char[] trimChars), string Trim()                                                                               
TrimEnd          Method                string TrimEnd(Params char[] trimChars)                                                                                           
TrimStart        Method                string TrimStart(Params char[] trimChars)                                                                                         
Chars            ParameterizedProperty char Chars(int index) {get;}                                                                                                      
Length           Property              int Length {get;}  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>String_numbers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>String_numbers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code># String Formatting - C# like syntax is supported
#   In C you'd use a static method (i.e. [string]) with a place holder (i.e. {0} )
[string]::Format("There are {0} items.", $items)

# Powershell shortcut { "-f" is an indicator that is requesting formatting}
# see: http://ss64.com/ps/syntax-f-operator.html for list
		:c	Currency format
		:e	Scientific (exp) notation
		:f	Fixed point
		:f5 = fix to 5 places
		:g	Most compact format, fixed or sci
		:g5 = 5 significant digits
		:n	Number (:nP precision=number of decimal places), includes culture separator for thousands 1,000.00
		:p	percentage
		:r	reversible precision
		:x	Hex format
		:hh
		:mm
		:ss	Convert a DateTime to a 2 digit Hour/minute/second
		"{0:hh}:{0:mm}"
		:ddd	Convert a DateTime to Day of the Week
# Place {0} {1} etc. into the string as placemarkers where you want the variables to appear, 
# immediately follow the string with the -f operator and then lastly, 
#  a list of comma separated variables which will be used to populate the placemarkers.
"There are {0} items." -f $items

"There are {0} items in the location {1}." -f $items, $loc

# You can repeat place holders
"There are {0} items in the location {1}. Wow, {0} is a lot of items!" -f $items, $loc

# Predefined formats - For Decimal Places
# N - Number
"N0 {0:N0} formatted" -f 12345678.119    # N0 12,345,678 formatted           {N0 =&gt; zero places}
"N1 {0:N1} formatted" -f 12345678.119    # N1 12,345,678.1 formatted         {N1 =&gt; one place}
"N2 {0:N2} formatted" -f 12345678.119    # N2 12,345,678.12 formatted        {N2 =&gt; two places}
"N2 {0:N9} formatted" -f 12345678.119    # N2 12,345,678.119000000 formatted {N9 =&gt; 9 places, fill w/ zero}
"N0 {0:N0} formatted"   -f 123.119       # N0 123 formatted                  {N0 =&gt; zero places}
"N0 {0,8:N0} formatted" -f 123.119       # N0      123 formatted             {N0 =&gt; 8 spaces preceding, zero places}

# C - Currency (uses local currency)
"C0 {0:C0} formatted" -f 12345678.1234   # C0 $12,345,678 formatted
"C1 {0:C1} formatted" -f 12345678.1234   # C1 $12,345,678.1 formatted
"C2 {0:C2} formatted" -f 12345678.1234   # C2 $12,345,678.12 formatted

# P - Percentage
"P0 {0:P0} formatted" -f 0.1234          # P0 12 % formatted
"P2 {0:P2} formatted" -f 0.1234          # P2 12.34 % formatted

# X - Hex
"X0 0x{0:X0} formatted" -f 1234          # X0 0x4D2 formatted
"X0 0x{0:X0} formatted" -f 0x4D2         # X0 0x4D2 formatted

# D - Decimal {for integers
"D0 {0:D0} formatted"   -f 12345678      # D0 12345678 formatted
"D8 {0:D8} formatted"   -f 123           # D8 00000123 formatted   {pads it with zeros in the front}
"D0 {0:D0} formatted"   -f 123           # D0      123 formatted
"D0 {0,8:D0} formatted" -f 123           # D0      123 formatted

# Note, decimal only supports INTs. It causes an error, when you use a non-decimal number:
"D0 {0:D0} formatted"   -f 123.1         


                                                                            
# Calculations can be passed in as the item to be formatted                 
"The 20% tip of a 33.33 dollar bill is {0} dollars" -f (33.33 * 0.20)       # The 20% tip of a 33.33 dollar bill is 6.666 dollars

"The 20% tip of a 33.33 dollar bill is {0:0.00} dollars" -f (33.33 * 0.20)  # The 20% tip of a 33.33 dollar bill is 6.67 dollars

##</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>POWERSHELL_Variables</Category>
        <Language>VBSCRIPT</Language>
        <Public>false</Public>
        <Name>Strings_from_PluralSight</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>POWERSHELL_Variables</Category>
          <Language>VBSCRIPT</Language>
          <Public>false</Public>
          <Name>Strings_from_PluralSight</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>#-----------------------------------------------------------------------------#
# String Handling
#-----------------------------------------------------------------------------#

# String Quoting 
Clear-Host
"This is a string"                           #Double Qoutes or Single Qoutes
'This is a string too!'

# Mixed quoted
'I just wanted to say "Hello World", OK?'     #Imbed double inside single qoutes
"I can't believe how cool Powershell is!"     #Imbed single inside double qoutes

# You can also double quote to get quotes in strings
"I just wanted to say ""Hello World"", OK?"
'I can''t believe how cool Powershell is!'     # Two single qoutes in a row, produces one single qoute in can't

# Escape Sequences - use the backtick (`) {It is located above the [Tab] key -----}
Clear-Host
#   backspace `b (does not work in ISE, only the regular script window)
"Power`bShell"

#   newline `n          #This puts a new line between the two words
"Power`nShell"

#   carriage return `r (doesn't really show anything, even though it does insert a "Carriage Return")
"Power`rShell"

#   crlf `r`n           (This is good for output)
"Power`r`nShell"

#   tabs                {This gives you tab spacing betwen the words}
"Power`tShell"          

# called "Here Strings" - for large blocks of text ------------------------------ 
# Nothing can follow the [@"] on the first line, and the last ["@] must be in the first column of the last line
# and you can put single and double quotes inside them
Clear-Host
$heretext = @"           
Some text here
Some more here
     a bit more

a blank line above
"@
     
$heretext

# the @ and quote must be last on starting line then first on ending line
# also works with single quotes
$moreheretext = @'
Here we go again
another line here
   let's indent this
   
a blank line above
'@

# note how the nested ' is handled OK, no double quoting needed
$moreheretext



# Without here strings
$sql = 'SELECT col1' `
     + '     , col2' `
     + '     , col3' `
     + '  FROM someTable ' `
     + ' WHERE col1 = ''a value'' '

# With here strings
$sql = @'
SELECT col1
     , col2
     , col3
  FROM someTable
 WHERE col1 = 'a value'
'@</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Filter_Combo_Box_Based_on_Another_ComboBox</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Filter_Combo_Box_Based_on_Another_ComboBox</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>How to Filter Combo Box Values Based on Another Combo Box
https://www.youtube.com/watch?v=8pMSkNGlF54

My example: DataGovernance
-----------------

1] {Main Form:} F_001_PickSchemaTable_EditFieldDefinition

3 drop-downs
-------------
a) cmbDatabases
=================
	{RowSource}
	SELECT [q_Databases].[DatabaseName] 
	FROM q_Databases ORDER BY [DatabaseName]; 
	
	{After Update Event}
	Private Sub cmbDatabases_AfterUpdate()
	    Me.cmbPickSchemaGivenDatabase.Requery
	End Sub	

b) cmbPickSchemaGivenDatabase
===============================
	{RowSource}
	SELECT 
			q_Database_Schema_ALL.schema_id
			, "[" &amp; [q_Database_Schema_All].[DatabaseName] &amp; "].[" &amp; [q_Database_Schema_All].[schemaName] &amp; "]" AS Database_SchemaName 
	FROM q_Database_Schema_ALL 
	WHERE 
		(
			(
				(q_Database_Schema_ALL.DatabaseName)=forms!F_001_PickSchemaTable_EditFieldDefinition!cmbDatabases    
			)
		); 

	
	{After Update Event}
	Private Sub cmbPickSchemaGivenDatabase_AfterUpdate()
	    Me.cmb_PickTable.Requery
	End Sub	
		
c) cmb_PickTable
==================
	{RowSource}
	SELECT 
			q_SchemaID_Table.schema_id
			, q_SchemaID_Table.tableName
			, q_SchemaID_Table.TABLE_object_id 
	FROM q_SchemaID_Table
	WHERE 
		(
			(
				(q_SchemaID_Table.schema_id)=forms!F_001_PickSchemaTable_EditFieldDefinition!cmbPickSchemaGivenDatabase
			) 
			And 
			(
				(q_SchemaID_Table.DatabaseName)=forms!F_001_PickSchemaTable_EditFieldDefinition!cmbDatabases
			)
		) 
	ORDER BY q_SchemaID_Table.tableName; 
	
	{After Update Event}
	Private Sub cmb_PickTable_AfterUpdate()
	    Me.sf_001_TableColumnDefinition.Requery
	End Sub

1 SubForm
-----------------
	
d) sf_001_TableColumnDefinition
=================================	
	{Record Source}
	SELECT * 
	FROM Reporting_T222_Columns_for_Tables_in_Databases 
	WHERE TABLE_object_id = forms!F_001_PickSchemaTable_EditFieldDefinition!cmb_PickTable; 


3 Queries
-------------------

e) q_Databases
=================================
SELECT DISTINCT 
	q_Database_Schema_ALL.DatabaseName
FROM q_Database_Schema_ALL;


f) q_Database_Schema_ALL
=================================
SELECT DISTINCT 
	Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.DatabaseName
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.schemaName
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.schema_id
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.isTable_Current
FROM Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database
WHERE (
		(
			(Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.isTable_Current)=True
		)
	  );


g) q_SchemaID_Table
=================================
SELECT DISTINCT 
	Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.schema_id
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.tableName
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.TABLE_object_id
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.isTable_Current
	, Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.DatabaseName
FROM Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database
WHERE (
		(
			(Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.isTable_Current)=True
		)
	  )
ORDER BY Reporting_T221_ListOfTablesAndTheirSCHEMAS_By_Database.tableName;
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>OpenArgs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>OpenArgs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>OpenArgs




Sub OpenToCallahan()
	DoCmd.OpenForm "Employees", acNormal, , , acReadOnly, , "Callahan"
End Sub


Sub Form_Open(Cancel As Integer)
	Dim strEmployeeName As String
	' If OpenArgs property contains employee name, find corresponding
	' employee record and display it on form. For example,
	' if the OpenArgs property contains "Callahan", move to first
	' "Callahan" record.
	strEmployeeName = Forms!Employees.OpenArgs
	If Len(strEmployeeName) &gt; 0 Then
		DoCmd.GoToControl "LastName"

               DoCmd.FindRecord strEmployeeName, , True, , True, , True
	End If
End Sub

'The next example uses the FindFirst method to locate the employee named in the OpenArgs Property.

Private Sub Form_Open(Cancel As Integer)
	If Not IsNull(Me.OpenArgs) Then
		Dim strEmployeeName As String
		strEmployeeName = Me.OpenArgs
		Dim RS As Recordset
		Set RS = Me.RecordsetClone
		RS.FindFirst "LastName = '" &amp; strEmployeeName &amp; "'"
		If Not RS.NoMatch Then
			Me.Bookmark = RS.Bookmark
		End If
	End If
End Sub

'----------Another Example --------------------------

Private Sub cmd_ClaimsManager_Click()

    Dim iX As Integer
    Dim sX As String
    '-------------------
    Dim sName As String
    Dim sNumber As String
    Dim sOpenArgs As String
    
    sName = [Forms]![Main_f]![vw_T1_T2_sf].[Form]![PCP_Official_CA_Name]
    sNumber = [Forms]![Main_f]![vw_T1_T2_sf].[Form]![PCP_CA_Number]
    sOpenArgs = sNumber &amp; " : " &amp; sName
    '-------------------
    
    iX = [Forms]![Main_f]![vw_T1_T2_sf].[Form]![T1_PK]
    sX = "T1_PK=" &amp; iX
    
      
     DoCmd.OpenForm "T11_PCP_CM_Assignments_mf", , , sX, , , sOpenArgs
    



End Sub

Private Sub Form_Load()

    Me.lbl_PCP_Name.Caption = Me.OpenArgs

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_Forms</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>subForm_requery</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_Forms</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>subForm_requery</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://access.mvps.org/access/forms/frm0031.htm


https://stackoverflow.com/questions/1929219/how-to-requery-a-subform-from-another-form
'You must use the name of the subform control, not the name of the subform, though these are often the same:

 Forms![MainForm]![subform control name Name].Form.Requery

'Or, if you are on the main form:

 Me.[subform control name Name].Form.Requery
 
 'The later syntax will perform better. (Bang operators cause an implicit type conversion.) 
 
 \\\\\\\\\\\\\\\\\\\\\\\
 
 Me.subformname.Requery</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_StoredProc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>LongListOfExamples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_StoredProc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>LongListOfExamples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Option Compare Database





Public Function fn_RunSP_UpdatePensionDate(iClaim_PK As Integer, _
                                            sPensionDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg009_DMC_Pension_UpdateClaim_WithDate"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sPensionDate", adVarChar, adParamInput, 10, sPensionDate)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_UpdatePensionDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function






Public Function fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet(sTransactionNumber As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sTransactionNumber: " &amp; sTransactionNumber
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg008_DMC_Pension_GetClaim_GivenHECTransactionNumber"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sTransactionNumber", adVarChar, adParamInput, 18, sTransactionNumber)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'
    
    Set fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    If iReturnValue &gt; 1 Then
            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg008_DMC_Pension_GetClaim_GivenHECTransactionNumber =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
    End If
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            MsgBox ("More than one Claim was returned that matched that Confirmation Number" &amp; vbCrLf &amp; "You need to use the COMPLETE and EXACT confirmation number")
'            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
            Debug.Print "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)

        Case Else
            Debug.Print "fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_DMC_GetPensionClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function


Public Function fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg006_DMC_Pension_GetClaimForHECDate_PlaceHold"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'    If iReturnValue = 50 Then
'        Err.Raise vbObjectError + 111
'    End If
'
    
    Set fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=50, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; No records left for that facility"
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_For_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function


'
Public Function fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    

    
'ALTER PROCEDURE gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN(
'    @SSN_Full AS NVARCHAR(9),
'    @sClaim_TEMP_PK as NVARCHAR(25),
'    @Hold_UserName AS nvarchar(255),
'    @MessageFromSQL AS NVARCHAR(1000) OUTPUT
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg003_DMC_Pension_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Private Sub ClearCommandParameters(ByRef oCMD As ADODB.Command)
    Dim lngX As Long
    For lngX = (oCMD.Parameters.Count - 1) To 0 Step -1
        oCMD.Parameters.Delete lngX
    Next

End Sub
'
'
'Public Function fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet(sFullSSN As String) As recordset




Public Function fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet(sFullSSN As String) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sFullSSN: " &amp; sFullSSN
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'=============================================================================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg010_DMC_GetClaims_Given_SSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)

    End With
'=============================================================================
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
    
'    If iReturnValue = 0 Then
'        Err.Raise vbObjectError + 111
'    End If
        
    
    Set fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
'        Case vbObjectError + 111
''            Err.Raise vbObjectError + 111
'            MsgBox ("There were No Records in the database already with that SSN!")
        Case Else
            Debug.Print "fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GivenFullSSN_GetRecordsInClaimsTable_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function




Public Function fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable(sSSN As String) As Integer
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sSSN: " &amp; sSSN
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

'    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg005_DMC_CountOccuranceOfSSN_In_DMC_Claim_t"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN)
'===================================================================================
        .Execute

'===================================================================================

    End With
    
    
    iReturnValue = objCmd.Parameters("RETURN_VALUE")
    
    fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable = iReturnValue
        
    
    
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objConn = Nothing
    Set objCmd = Nothing
'    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_RunSP_gig_DMC_Count_SSNAlreadyInClaimsTable ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function

'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet
'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet



Public Function fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg001_DMC_Pension_GetClaimForSSN_PlaceHOLDonTEMPclaim" 'gg001_DMC_Pension_GetClaimForSSN_PlaceHOLDonTEMPclaim
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================


'===================================================================================


'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
    

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 50 Then
        Err.Raise vbObjectError + 111
    End If
        
    
    Set fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function


Public Sub RunSP_PP_ReportProblems(iPP_WorkList_PK As Integer, _
                                            sFullSSN As String, _
                                            sWorkList_Note As String, _
                                            sArchived_UserName As String, _
                                            sArchived_DateTime As String _
                                            )
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gig_PP_ReportProblem"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        'Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("@PP_WorkList_PK", adInteger, adParamInput, 0, iPP_WorkList_PK)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)
        .Parameters.Append .CreateParameter("@WorkList_Note", adVarChar, adParamInput, 1000, sWorkList_Note)
        .Parameters.Append .CreateParameter("@Archived_UserName", adVarChar, adParamInput, 255, sArchived_UserName)
        .Parameters.Append .CreateParameter("@Archived_DateTime", adVarChar, adParamInput, 255, sArchived_DateTime)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working

         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
    
    End With
    
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Sub
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "RunSP_PP_ReportProblems ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "RunSP_PP_ReportProblems ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Sub


Public Sub RunSP_MarkPrePayDone_ArchiveIt(iPP_WorkList_PK As Integer, _
                                            sFullSSN As String, _
                                            sWorkList_HoldReason As String, _
                                            sWorkList_Note As String, _
                                            sArchived_UserName As String, _
                                            sArchived_DateTime As String, _
                                            sHold_ProblemReported_Notes As String, _
                                            sHoldProblemResolved_DateTime As String, _
                                            sHoldProblemResolved_Notes As String, _
                                            sAction_Taken As String _
                                            ) 'As ADODB.recordset

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

'    Dim objRs As New ADODB.recordset
    Dim sConnect As String
'    Dim iIN As Integer
'    Dim iOUT As Integer
'    Dim sX As String
'    Dim iX As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gig_MarkPrePayDone_ArchiveIt"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        'Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("@PP_WorkList_PK", adInteger, adParamInput, 0, iPP_WorkList_PK)
'        .Parameters.Append .CreateParameter("@Date_Last_Updated", adVarChar, adParamInput, 255, sDate_Last_Updated)
        .Parameters.Append .CreateParameter("@FullSSN", adVarChar, adParamInput, 9, sFullSSN)
        .Parameters.Append .CreateParameter("@WorkList_HoldReason", adVarChar, adParamInput, 255, sWorkList_HoldReason)
        .Parameters.Append .CreateParameter("@WorkList_Note", adVarChar, adParamInput, 1000, sWorkList_Note)
        .Parameters.Append .CreateParameter("@Archived_UserName", adVarChar, adParamInput, 255, sArchived_UserName)
        .Parameters.Append .CreateParameter("@Archived_DateTime", adVarChar, adParamInput, 255, sArchived_DateTime)
        .Parameters.Append .CreateParameter("@Hold_ProblemReported_Notes", adVarChar, adParamInput, 1000, sHold_ProblemReported_Notes)
        .Parameters.Append .CreateParameter("@HoldProblemResolved_DateTime", adVarChar, adParamInput, 255, sHoldProblemResolved_DateTime)
        .Parameters.Append .CreateParameter("@HoldProblemResolved_Notes", adVarChar, adParamInput, 1000, sHoldProblemResolved_Notes)
        .Parameters.Append .CreateParameter("@Action_Taken", adVarChar, adParamInput, 255, sAction_Taken)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
   

    End With
    
    
'        objRs.CursorLocation = adUseClient
'        objRs.CursorType = adOpenDynamic
'        objRs.LockType = adLockOptimistic
'        objRs.Open objCmd
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
    

'    Set RunSP_gig_GetPrePayInfo_PlaceTempHoldOnPrePay_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Sub
    
ErrHandler:
    'clean up
'    If objRs.State = adStateOpen Then
'        objRs.Close
'    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
'    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Sub



Public Function RunSP_gig_GetPrePayInfo_PlaceTempHoldOnPrePay_ReturnRecordSet(iFacility_FK As Long, sHold_UserName As String, iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "iFacility_FK: " &amp; iFacility_FK
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
'    Dim iIN As Integer
'    Dim iOUT As Integer
'    Dim sX As String
'    Dim iX As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gig_GetPrePayInfo_PlaceTempHoldOnPrePay"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_FK", adInteger, adParamInput, 0, iFacility_FK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================


'===================================================================================


'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
    

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 50 Then
        Err.Raise vbObjectError + 111
    End If
        
    
    Set RunSP_gig_GetPrePayInfo_PlaceTempHoldOnPrePay_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "RunStoredProcedure_Parms_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function



Public Function fRun_SQLString_NoParms_ReturnDisconnectedRecordSet(sSQL As String) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
'    Dim objCmd As New ADODB.Command
    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    Dim iX As Integer
    

            
    ' Connect to the data source.
'=========================
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    objCmd.ActiveConnection = objConn
        
'=======================================

' Setting the cursor location to client side is important
' to get a disconnected recordset.
objRs.CursorLocation = adUseClient
objRs.Open sSQL, objConn, ADODB.adOpenForwardOnly, ADODB.adLockBatchOptimistic

' Disconnect the recordset.
Set objRs.ActiveConnection = Nothing



'======================================
    ' Execute once and display...
'    Set objRs = objCmd.Execute
        

    For iX = 0 To objRs.Fields.Count - 1
        Debug.Print "Field " &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
    Next iX
        
    Set fRun_SQLString_NoParms_ReturnDisconnectedRecordSet = objRs
    
    'clean up
'    objRs.Close
'    objConn.Close
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
'    MsgBox "Done!"
    
    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing


    
    If Err &lt;&gt; 0 Then
        MsgBox "ERROR: fRun_SQLString_NoParms_ReturnDisconnectedRecordSet: " &amp; Err.Number &amp; ", " &amp; Err.Description
    End If

End Function

Public Sub RunStoredProcedure_NoParms_NoReturnInfo(sNameOfStoredProc As String)

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim objParm1 As New ADODB.Parameter
    Dim objRs As New ADODB.recordset
    Dim stConnect As String
    
    ' Set CommandText equal to the stored procedure name.
    objCmd.CommandText = sNameOfStoredProc
    objCmd.CommandType = adCmdStoredProc
            
    ' Connect to the data source.
'    Set objConn = GetNewConnection

'========================= OPTION to use a connection string
    stConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open stConnect
'==========================
    objCmd.ActiveConnection = objConn
    
    ' Execute once
    objCmd.Execute
                
    'clean up

    objConn.Close

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
'    MsgBox "Done!"
    Exit Sub

ErrHandler:
    'clean up

    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        MsgBox Err.Source &amp; "--&gt;" &amp; Err.Description, , "Error"
    Else
        MsgBox "Done!, but it went to the ErrHandler!"
    End If


End Sub





Public Function fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    
    
'ALTER PROCEDURE gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord(
'    @SSN_Full AS NVARCHAR(9),
'    @sClaim_TEMP_PK as NVARCHAR(25),
'    @Hold_UserName AS nvarchar(255),
'    @MessageFromSQL AS NVARCHAR(1000) OUTPUT
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg002_DMC_Pension_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function










Public Function fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t(sClaim_TEMP_PK As String) As Integer
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg004_DMC_Delete_Claim_From_Claim_TEMP_t"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        
         .Execute
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg004_DMC_Delete_Claim_From_Claim_TEMP_t ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Public Function fn_RunStoredProcedure_NoParms_ReturnRecordSet(sNameOfStoredProc As String) As recordset
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    ' Set CommandText equal to the stored procedure name.
    objCmd.CommandText = "CustOrdersOrders"
    objCmd.CommandType = adCmdStoredProc
            
    ' Connect to the data source.
'=========================
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    objCmd.ActiveConnection = objConn
        
    ' Automatically fill in parameter info from stored procedure.
    objCmd.Parameters.Refresh
    
    ' Set the param value.

    
    ' Execute once and display...
    Set objRs = objCmd.Execute
        

    Do While Not objRs.EOF
        Debug.Print vbTab &amp; objRs(0) &amp; vbTab &amp; objRs(1) &amp; vbTab &amp; _
                    objRs(2) &amp; vbTab &amp; objRs(3)
        objRs.MoveNext
    Loop
        
    RunStoredProcedure_NoParms_ReturnRecordSet = objRs
    
    'clean up
    objRs.Close
    objConn.Close
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    MsgBox "Done!"
    
    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        MsgBox Err.Source &amp; "--&gt;" &amp; Err.Description, , "Error"
    End If

End Function
'
'
'
'
'
'Public Sub BAD_RunSP_MarkClaim_SentRequestToHEC(iClaim_PK As Integer, _
'                                            sClaimNote As String _
'                                            )
'
'    On Error GoTo ErrHandler:
'
'    Dim objConn As New ADODB.Connection
'    Dim objCmd As New ADODB.Command
'
'    Dim sConnect As String
'
'    ' Connect to the data source.
''========================= OPTION to use a connection string
'    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
'    objConn.Open sConnect
'
'    With objCmd
'        ' Set CommandText equal to the stored procedure name.
'        .CommandText = "gg007_DMC_Pension_Date_UpdateClaim_RequestSentToHEC"
'        .CommandType = adCmdStoredProc
'
'        .ActiveConnection = objConn
''=============================================================================
'
'        .Parameters.Append .CreateParameter("@Claim_PK", adInteger, adParamInput, 0, iClaim_PK)
'        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
'        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'        '--------
'         .Execute
'         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
'
'
'    End With
'
'
'        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
'
'
'    objConn.Close
'    Set objConn = Nothing
'    Set objCmd = Nothing
'
''    MsgBox "Done!"
'
'    Exit Sub
'
'ErrHandler:
'
'    If objConn.State = adStateOpen Then
'        objConn.Close
'    End If
'
'    Set objConn = Nothing
'    Set objCmd = Nothing
'    Set objParm1 = Nothing
'
'    If Err &lt;&gt; 0 Then
'        Debug.Print "RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
'
'        MsgBox "RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
'    End If
'
'End Sub



Public Function OLD_fn_RunSP_MarkClaim_SentRequestToHEC(iClaim_PK As Integer, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg007_DMC_Pension_Date_UpdateClaim_RequestSentToHEC"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_MarkClaim_SentRequestToHEC = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_MarkClaim_SentRequestToHEC ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function





Public Function fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate(iClaim_PK As Integer, _
                                            sPensionDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg007A_DMC_Pension_PensionDate_Either_gg007_OR_gg009"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK_IN", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sPensionDate_IN", adVarChar, adParamInput, 10, sPensionDate)
        .Parameters.Append .CreateParameter("@ClaimNote_IN", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        
    objConn.Close
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvidePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function


'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet
'fn_SP_gig_DMC_GetClaimInfo_ForPensions_PlaceHoldOnClaim_ReturnRecordSet



Public Function fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg011_DMC_SC_GetClaimForSSN_PlaceHOLDonTEMPclaim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================


'===================================================================================


'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
    

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 50 Then
        Err.Raise vbObjectError + 111
    End If
        
    
    Set fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            Err.Raise vbObjectError + 111
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_ForSCs_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function








Public Function fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg012_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function




'
Public Function fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Integer
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg013_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function




Public Function fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg016_DMC_SC_GetClaimForHECDate_PlaceHold"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'    If iReturnValue = 50 Then
'        Err.Raise vbObjectError + 111
'    End If
'
    
    Set fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=50, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; No records left for that facility"
        Case Else
            Debug.Print "fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_SP_gig_DMC_GetClaimInfo_For_SC_HEC_Date_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function




Public Function fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate(iClaim_PK As Integer, _
                                            sSCDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg017A_DMC_SC_SCDate_Either_gg017_OR_gg019"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK_IN", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sSCDate_IN", adVarChar, adParamInput, 10, sSCDate)
        .Parameters.Append .CreateParameter("@ClaimNote_IN", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        
    objConn.Close
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_MarkClaim_SentRequestToHEC_OR_ProvideSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function






Public Function fn_RunSP_UpdateSCDate(iClaim_PK As Integer, _
                                            sSCDate As String, _
                                            sClaimNote As String _
                                            ) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(iClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg019_DMC_SC_UpdateClaim_WithDate"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sSCDate", adVarChar, adParamInput, 10, sSCDate)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_RunSP_UpdateSCDate = iReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_UpdateSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_UpdateSCDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function







Public Function fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet(sTransactionNumber As String, _
                                                                                sHold_UserName As String, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sTransactionNumber: " &amp; sTransactionNumber
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg018_DMC_SC_GetClaim_GivenHECTransactionNumber"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sTransactionNumber", adVarChar, adParamInput, 18, sTransactionNumber)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
'
    
    Set fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    If iReturnValue &gt; 1 Then
            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg008_DMC_Pension_GetClaim_GivenHECTransactionNumber =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
    End If
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
            MsgBox ("More than one Claim was returned that matched that Confirmation Number" &amp; vbCrLf &amp; "You need to use the COMPLETE and EXACT confirmation number")
'            Err.Raise vbObjectError + 111, "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)
            Debug.Print "Return Code &gt; 1, from: gg006_DMC_Pension_GetClaimForHECDate_PlaceHold =&gt; Number of records for the Transaction Number was: " &amp; CStr(iReturnValue)

        Case Else
            Debug.Print "fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_DMC_GetSCClaimInfo_For_HEC_TransactionNumber_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
    End Select

End Function





Public Function fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet(sMedical_Center_STN As String, _
                                                                                sHold_UserName As String, _
                                                                                bSortBy_SC_First As Boolean, _
                                                                                iTimeLimitForHoldInMinutes As Integer) As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sMedical_Center_STN: " &amp; sMedical_Center_STN
    Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer
    Dim iSortBy_SC_First As Integer
    
'========================================
' Translate input values

    If bSortBy_SC_First = True Then
        iSortBy_SC_First = 1
    Else
        iSortBy_SC_First = 0
    End If
    
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
'    Clear the paramaters before reusing
'-------------------------------------------------------
'    Dim lngX As Long
'    For lngX = (objCmd.Parameters.Count - 1) To 0 Step -1
'        objCmd.Parameters.Delete lngX
'    Next
'-------------------------------------------------------

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg020_DMC_GetNewOrIncompleteClaim_ToValidate"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@Facility_Number", adVarChar, adParamInput, 3, sMedical_Center_STN)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)
        .Parameters.Append .CreateParameter("@SortBy_SC_First", adInteger, adParamInput, 0, iSortBy_SC_First)

        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================
'        Set objRs = .Execute                                                       ' one way to do it, but the
'        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value      'This is still not working
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")    '( 1 means there were no problems, 0 means there were problems)
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue = 0 Then
        Err.Raise vbObjectError + 111
    End If
'
    
    Set fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet = objRs
        
    
    
'    For iX = 0 To objRs.Fields.Count - 1
'        Debug.Print "Field" &amp; CStr(iX) &amp; "]  (  " &amp; objRs(iX).Name &amp; "  ) " &amp; objRs(iX)
'    Next iX
'
        
    'clean up
'    objRs.Close           'This has to be commented out otherwise the recordset is empty when it is passed out of the function
'    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=0 in: fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet, from: gg020_DMC_GetNewOrIncompleteClaim_ToValidate =&gt; There was a problem"
        Case Else
            Debug.Print "fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GetClaimToValidate_PlaceHoldOnClaim_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function



Public Function fn_Tickle_ClaimPK_Hold(sClaim_PK As String, _
                                        sUserName As String, _
                                        sNumberOfDays As String) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg000A_TickleOutHOLD_Claim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sUserName", adVarChar, adParamInput, 255, sUserName)
        .Parameters.Append .CreateParameter("@sNumberOfDays", adVarChar, adParamInput, 2, sNumberOfDays)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_Tickle_ClaimPK_Hold = iReturnValue   '0 if there was a problem, 1 if it was ok

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_Tickle_ClaimPK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_Tickle_ClaimPK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function





Public Function fn_Tickle_Claim_TEMP_PK_Hold(sClaim_TEMP_PK As String, _
                                        sUserName As String, _
                                        sNumberOfDays As String) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg000B_TickleOutHOLD_ClaimTEMP"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@sUserName", adVarChar, adParamInput, 255, sUserName)
        .Parameters.Append .CreateParameter("@sNumberOfDays", adVarChar, adParamInput, 2, sNumberOfDays)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_Tickle_Claim_TEMP_PK_Hold = iReturnValue   '0 if there was a problem, 1 if it was ok

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_Tickle_Claim_TEMP_PK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_Tickle_Claim_TEMP_PK_Hold ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function








Public Function fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet(sClaim_PK As String, _
                                                                   sClaim_TEMP_PK As String) _
                                                                   As ADODB.recordset
    On Error GoTo ErrHandler:
    
    
    Debug.Print "sClaim_PK: " &amp; sClaim_PK
    Debug.Print "sClaim_TEMP_PK: " &amp; sClaim_TEMP_PK
    
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer

    

    
    
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg000C_DMC_CountBillsToValidateForTheClaim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@sClaim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
'===================================================================================

    End With
    
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")    '( 1 means there were no problems, 0 means there were problems)
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue:" &amp; iReturnValue
    
    If iReturnValue &gt; 0 Then
    ' @@ERROR should be 0 if everything is ok.
        Err.Raise vbObjectError + 111
    End If
'
    
    Set fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet = objRs
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
        Case vbObjectError + 111
'            Err.Raise vbObjectError + 111
            Debug.Print "Return Code=0 in: fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet, from: gg020_DMC_GetNewOrIncompleteClaim_ToValidate =&gt; There was a problem"
        Case Else
            Debug.Print "fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_GetBillCountToValidate_GivenPKs_ReturnRecordSet ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function









Public Function fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Long
    
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim lReturnValue As Integer
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        lReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord = lReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg012A_DMC_SC_SaveNewClaim_CreateMilestoneSubRecord ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Public Function fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN(sSSN_Full As String, _
                                            sClaim_TEMP_PK As String, _
                                            sHold_UserName As String, _
                                            sClaimNote As String _
                                            ) As Long
    
    
    
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim lReturnValue As Long
    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@SSN_Full", adVarChar, adParamInput, 9, sSSN_Full)
        .Parameters.Append .CreateParameter("@Claim_TEMP_PK", adVarChar, adParamInput, 25, sClaim_TEMP_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sClaimNote)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
 
         .Execute
         Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        lReturnValue = .Parameters("RETURN_VALUE")
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN = lReturnValue

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
        
        MsgBox "fn_SP_gg013A_DMC_SC_SaveClaim_CreateMilestone_ForDuplicateSSN ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End If

End Function


Public Function fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim(sClaim_PK As String, _
                                                                            sHold_UserName As String, _
                                                                            iTimeLimitForHoldInMinutes As Integer) _
                                                                            As ADODB.recordset
    On Error GoTo ErrHandler:
    
     Debug.Print "sHold_UserName: " &amp; sHold_UserName
    Debug.Print "sClaim_PK: " &amp; sClaim_PK
    Debug.Print "iTimeLimitForHoldInMinutes: " &amp; iTimeLimitForHoldInMinutes
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command

    Dim objRs As New ADODB.recordset
    Dim sConnect As String
    
    Dim iReturnValue As Integer

     ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================

    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        Dim prmX As New ADODB.Parameter

        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 25, sHold_UserName)
        .Parameters.Append .CreateParameter("@TimeLimitForHoldInMinutes", adInteger, adParamInput, 0, iTimeLimitForHoldInMinutes)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 255)
        
'===================================================================================

    End With
    
        objRs.CursorLocation = adUseClient
        objRs.CursorType = adOpenDynamic
        objRs.LockType = adLockOptimistic
        objRs.Open objCmd
        iReturnValue = objCmd.Parameters("RETURN_VALUE")    '( This is the DMC_Bills_PK)
        Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL") &amp; ", iReturnValue (DMC_Bills_PK):" &amp; iReturnValue
    
'    If iReturnValue &gt; 0 Then
'    ' @@ERROR should be 0 if everything is ok.
'        Err.Raise vbObjectError + 111
'    End If
'
    
    Set fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim = objRs
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing

'    MsgBox "Done!"

    Exit Function
    
ErrHandler:
    'clean up
    If objRs.State = adStateOpen Then
        objRs.Close
    End If
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    Select Case Err.Number
    
'        Case vbObjectError + 111
''            Err.Raise vbObjectError + 111
'            Debug.Print "Return Code=0 in: fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim, from: gg020_DMC_GetNewOrIncompleteClaim_ToValidate =&gt; There was a problem"
        Case Else
            Debug.Print "fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
            MsgBox "fn_gg021_GetABillToValidate_PutHoldOnIt_UpdateHoldOnClaim ERROR: " &amp; Err.Number &amp; Err.Description, , "Error"
    End Select

End Function







Public Function fn_gg022_Bill_and_Milestone_UpdateServiceDates( _
                                            sBill_PK As String, _
                                            sFirstDateServiced As String, _
                                            sLastDateServiced As String, _
                                            sBillNote As String, _
                                            sHold_UserName As String _
                                            ) As Integer
                                            
' create PROCEDURE gg022_Bill_and_Milestone_UpdateServiceDates(
'    @sBills_PK as NVARCHAR(25),
'    @sFirstDateServiced as VARCHAR(10) ,
'    @sLastDateServiced as VARCHAR(10) ,
'    @BillNote AS NVARCHAR(1000),
'    @Hold_UserName AS NVARCHAR(25),
'    @MessageFromSQL AS NVARCHAR(1000) OUTPUT
'    )
                                            
    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg022_Bill_and_Milestone_UpdateServiceDates"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sBill_PK", adVarChar, adParamInput, 25, sBill_PK)
        .Parameters.Append .CreateParameter("@sFirstDateServiced", adVarChar, adParamInput, 10, sFirstDateServiced)
        .Parameters.Append .CreateParameter("@sLastDateServiced", adVarChar, adParamInput, 10, sLastDateServiced)
        .Parameters.Append .CreateParameter("@ClaimNote", adVarChar, adParamInput, 1000, sBillNote)
        .Parameters.Append .CreateParameter("@Hold_UserName", adVarChar, adParamInput, 255, sHold_UserName)
        .Parameters.Append .CreateParameter("@MessageFromSQL", adVarChar, adParamOutput, 1000)
'-----
         .Execute
        Debug.Print "MessageFromSQL: " &amp; .Parameters("@MessageFromSQL").Value
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        'Debug.Print "MessageFromSQL: " &amp; objCmd.Parameters("@MessageFromSQL")
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_gg022_Bill_and_Milestone_UpdateServiceDates = iReturnValue '0=No errors, otherwise the number indicates which step had the error

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_gg022_Bill_and_Milestone_UpdateServiceDates ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_gg022_Bill_and_Milestone_UpdateServiceDates ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function

'\\\\\\\


Public Function fn_gg023_DMC_Claim_Validate_Phase_1_Done(lClaim_PK As Long) As Integer

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim sConnect As String
    Dim iReturnValue As Integer
    Dim sClaim_PK As String
    
    sClaim_PK = CStr(lClaim_PK)
    

    ' Connect to the data source.
'========================= OPTION to use a connection string
    sConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open sConnect
'==========================
    With objCmd
        ' Set CommandText equal to the stored procedure name.
        .CommandText = "gg023_DMC_Claim_Validate_Phase_1_Done"
        .CommandType = adCmdStoredProc
        
        .ActiveConnection = objConn
'=============================================================================
        .Parameters.Append .CreateParameter("RETURN_VALUE", adInteger, adParamReturnValue)
        .Parameters.Append .CreateParameter("@sClaim_PK", adVarChar, adParamInput, 25, sClaim_PK)
'-----
         .Execute
        
        iReturnValue = .Parameters("RETURN_VALUE")
        
    End With
    
        
    objConn.Close        'This has to be commented out otherwise the recordset is empty when it is passed out of the function
    Set objConn = Nothing
    Set objCmd = Nothing

    fn_gg023_DMC_Claim_Validate_Phase_1_Done = iReturnValue       'RETURN(@@ERROR),  @@ERROR should be 0 if everything is ok.

    Exit Function
    
ErrHandler:
    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        Debug.Print "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
        
        MsgBox "fn_RunSP_UpdatePensionDate ERROR: " &amp; Err.Number &amp; " " &amp; Err.Description, , "Error"
    End If

End Function

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_StoredProc</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>RunStoredProcedure_NoParms_NoReturnInfo(sNameOfStoredProc</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_StoredProc</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>RunStoredProcedure_NoParms_NoReturnInfo(sNameOfStoredProc</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'==============================================================
' How to call the sub:

    '1] Run stored Procedure to truncate the table on the SQL Server
        '[gig_TRUNCATE_DMCValidity_RawData_t]
        
        RunStoredProcedure_NoParms_NoReturnInfo ("gig_DMCValidity_TRUNCATE_RawData_t")
        MsgBox "WorkList has been Truncated!"




'==============================================================




Public Sub RunStoredProcedure_NoParms_NoReturnInfo(sNameOfStoredProc As String)

    On Error GoTo ErrHandler:
    
    Dim objConn As New ADODB.Connection
    Dim objCmd As New ADODB.Command
    Dim objParm1 As New ADODB.Parameter
    Dim objRs As New ADODB.Recordset
    Dim stConnect As String
    
    ' Set CommandText equal to the stored procedure name.
    objCmd.CommandText = sNameOfStoredProc
    objCmd.CommandType = adCmdStoredProc
            
    ' Connect to the data source.
'    Set objConn = GetNewConnection

'========================= OPTION to use a connection string
    stConnect = "DRIVER=SQL Server;SERVER=vhacpasql3\firstparty;DATABASE=Firstparty;Trusted_Connection=Yes"
    objConn.Open stConnect
'==========================
    objCmd.ActiveConnection = objConn
    
    ' Execute once
    objCmd.Execute
                
    'clean up

    objConn.Close

    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
'    MsgBox "Done!"
    Exit Sub

ErrHandler:
    'clean up

    
    If objConn.State = adStateOpen Then
        objConn.Close
    End If
    
    Set objRs = Nothing
    Set objConn = Nothing
    Set objCmd = Nothing
    Set objParm1 = Nothing
    
    If Err &lt;&gt; 0 Then
        MsgBox Err.Source &amp; "--&gt;" &amp; Err.Description, , "Error"
    Else
        MsgBox "Done!, but it went to the ErrHandler!"
    End If


End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_String</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>fn_AtLeastOneOfACommaSeperatedStringIsInTheTargetString</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_String</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>fn_AtLeastOneOfACommaSeperatedStringIsInTheTargetString</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code> Function fn_bIsStringInTargetString(sStringToLookFor As String, sTargetStringToSearch As String) As Boolean


           Dim String1 As String
           Dim String2 As String
           Dim bX As Boolean


           String1 = sTargetStringToSearch
           String2 = "*" &amp; sStringToLookFor &amp; "*"

           bX = String1 Like String2
           fn_bIsStringInTargetString = bX


End Function


Function fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString(sTargetStringToSearch As String, sCommaSeperatedStringOfStringsToSearchFor As String) As String

         Dim arrX() As String
         Dim iX As Integer
         Dim iCounter As Integer
         arrX = Split(sCommaSeperatedStringOfStringsToSearchFor, ",")

         iCounter = 0
         For iX = 0 To UBound(arrX)

             If fn_bIsStringInTargetString(arrX(iX), sTargetStringToSearch) Then
                 iCounter = iCounter + 1
             End If

         Next '

'         If iCounter &gt; 0 Then
'             fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString = True
'         Else
'             fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString = False
'         End If

        fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString = CStr(iCounter * 100)




End Function


Private Sub Test()

     Dim bX As Boolean
     Dim sX As String
     Dim sListToLookFor As String

     sX = "Public Function fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString(sTargetStringToSearch As String, sCommaSeperatedStringOfStringsToSearchFor) As Boolean"
     sListToLookFor = "One,target,String"

     bX = fn_bAtLeastOneOfACommaSeperatedStringIsInTheTargetString(sX, sListToLookFor)

     If bX Then
         MsgBox ("YES! The string is there")
     Else
         MsgBox ("NO! The string is NOT there")

     End If

End Sub</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VBA_ACCESS_RowSource</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>ComboBox_RowSource</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VBA_ACCESS_RowSource</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>ComboBox_RowSource</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://docs.microsoft.com/en-us/office/vba/api/access.combobox.rowsource


RowSourcetype		RowSource
===============		=============================
"Table/Query"		A table name, query name, or SQL statement.
"Value List"		A list of items with semicolons (;) as separators.
"Field List"		A table name, query name, or SQL statement.


'EXAMPLE: set to a query
---------------------------
Forms!Employees!cmboNames.RowSourceType = "Table/Query" 
Forms!Employees!cmboNames.RowSource = "EmployeeList"

'EXAMPLE: set to SQL
----------------------
Private Sub Form_Load()
    Me.Caption = "Today is " &amp; Format$(Date, "dddd mmm-d-yyyy")
    Me.RecordSource = "tblDepartments"
    DoCmd.Maximize  
    txtDept.ControlSource = "Department"
    cmdClose.Caption = "&amp;Close"
    cboDept.RowSourceType = "Table/Query"
    cboDept.RowSource = "SELECT Department FROM tblDepartments"
End Sub</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>