<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>AD_Active_Directory</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ALL ActiveDirectoryObjects_computers_domainControllers_users_contacts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>AD_Active_Directory</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ALL ActiveDirectoryObjects_computers_domainControllers_users_contacts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--ALL ActiveDirectoryObjects_computers_domainControllers_users_contacts 

https://stackoverflow.com/questions/8594775/error-cannot-fetch-a-row-from-ole-db-provider-adsdsoobject-for-linked-server

CREATE TABLE #ADData(
    Login           NVARCHAR(256)
    ,CommonName     NVARCHAR(256)
    ,GivenName      NVARCHAR(256)
    ,FamilyName     NVARCHAR(256)   
    ,DisplayName    NVARCHAR(256)
    ,Title          NVARCHAR(256)
    ,Department     NVARCHAR(256)
    ,Location       NVARCHAR(256)
    ,Info           NVARCHAR(256)
    ,LastLogin      BIGINT
    ,flags          INT
    ,Email          NVARCHAR(256)
    ,Phone          NVARCHAR(256)   
    ,Mobile         NVARCHAR(256)
    ,Quickdial      NVARCHAR(256)
    , usnCreated    INT
)

DECLARE @Query      VARCHAR (2000)
DECLARE @Filter     VARCHAR(200)
DECLARE @Rowcount   INT

select @Filter =''

WHILE ISNULL(@rowcount,901)  = 901 BEGIN

    SELECT @Query = '
    SELECT top 901
            Login           = SamAccountName
            , CommonName    = cn
            , GivenName
            , FamilyName    = sn    
            , DisplayName
            , Title
            , Department
            , Location      = physicalDeliveryOfficeName
            , Info
            , LastLogin     = CAST(LastLogon AS bigint)
            , flags         = CAST (UserAccountControl as int)
            , Email         = mail
            , Phone         = telephoneNumber
            , Mobile        = mobile
            , QuickDial     = Pager
            , usnCreated
        FROM OPENROWSET(''ADSDSOObject'', '''', ''
                SELECT cn, givenName, sn, userAccountControl, lastLogon, displayName, samaccountname, 
                title,  department, physicalDeliveryOfficeName, info, mail, telephoneNumber, mobile, pager, usncreated
            FROM ''''LDAP://dc=jphsa,dc=org'''' 
            WHERE objectClass=''''Person''''
            AND objectClass = ''''User''''
            ' + @filter + '
            ORDER BY usnCreated'')'             
    INSERT INTO #ADData EXEC (@Query) 
    SELECT @Rowcount = @@ROWCOUNT
    SELECT @Filter = 'and usnCreated &gt; '+ LTRIM(STR((SELECT MAX(usnCreated) FROM #ADData)))

END

SELECT LOGIN            
        , CommonName    
        , GivenName
        , FamilyName
        , DisplayName
        , Title         
        , Department
        , Location      
        , Email         
        , Phone         
        , QuickDial     
        , Mobile        
        , Info          
        , Disabled      = CASE WHEN CAST (flags AS INT) &amp; 2 &gt; 0 THEN 'Y' ELSE NULL END 
        , Locked        = CASE WHEN CAST (flags AS INT) &amp; 16  &gt; 0 THEN 'Y' ELSE NULL END 
        , NoPwdExpiry   = CASE WHEN CAST (flags AS INT) &amp; 65536  &gt; 0 THEN 'Y' ELSE NULL END 
        , LastLogin     = CASE WHEN ISNULL(CAST (LastLogin AS BIGINT),0) = 0 THEN NULL ELSE 
                            DATEADD(ms, (CAST (LastLogin AS BIGINT) / CAST(10000 AS BIGINT)) % 86400000,
                            DATEADD(day, CAST (LastLogin AS BIGINT) / CAST(864000000000 AS BIGINT) - 109207, 0)) END 
        , Type = CASE WHEN flags  &amp; 512 = 512 THEN 'user' 
                    WHEN flags IS NULL THEN 'contact' 
                    WHEN flags &amp; 4096 = 4096 THEN 'computer'
                    WHEN flags &amp; 532480 = 532480 THEN 'computer (DC)' END
FROM #ADData
ORDER BY Login

DROP TABLE #ADData</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>AD_Active_Directory</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>GetUserGroups_Given_UserName</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>AD_Active_Directory</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>GetUserGroups_Given_UserName</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


//--Usage of SP

use IT_DEPT
go

EXEC prj_0014_SP_206_UseTheSP__GetLdapUserGroups_Given_UserName 'glenng'


///////////////--OUTPUT

--LdapGroup
===========
--Administrators
--BOD_Reports
--Construction Div
--Denied RODC Password Replication Group
--Domain Admins
--Everyone-Barriere
--Exchange Organization Administrators
--Exchange Public Folder Administrators
--Exchange Recipient Administrators
--Exchange View-Only Administrators
--g PeopleTrak users
--g_Board_Files
--g_citrix_explorer
--g_ECLIPSE_Admin
--g_SELA_folder
--g_SQL_Level1
--gCitrix PeopleTrak
--HRPhotos
--New Orleans
--NOLA
--PlantDB_Users
--REPORT_test_report
--Websense Barriere Te

///////////////-- 2nd SP (calls the first SP)

use IT_DEPT
go

create PROCEDURE [dbo].[prj_0014_SP_206_UseTheSP__GetLdapUserGroups_Given_UserName]
    (
    @LdapUsername NVARCHAR(max)
    )
AS
BEGIN

		DECLARE @UserGroup table (LdapGroup nvarchar(max))
		INSERT INTO @UserGroup exec [prj_0014_SP_205_GetLdapUserGroups_Given_UserName] @LdapUsername

		SELECT * from @UserGroup

END


///////////////-- First SP:


--prj_0014_SP_205_GetLdapUserGroups_Given_UserName.sql
--from: http://stackoverflow.com/questions/13914698/query-ad-group-membership-recursively-through-sql

use IT_DEPT
go

alter PROCEDURE [dbo].[GetLdapUserGroups_Given_UserName]
    (
    @LdapUsername NVARCHAR(max)
    )
AS
BEGIN
		DECLARE @Query NVARCHAR(max), @Path NVARCHAR(max)

		SET @Query = '
			SELECT @Path = distinguishedName
			FROM OPENQUERY(ADSI, ''
				SELECT distinguishedName 
				FROM ''''LDAP://DC=barriere,DC=COM''''
				WHERE 
					objectClass = ''''user'''' AND
					sAMAccountName = ''''' + @LdapUsername + '''''
			'')
		'
		
		EXEC sp_executesql @Query, N'@Path NVARCHAR(max) OUTPUT', @Path = @Path OUTPUT 

		  SET @Query = '
			SELECT cn AS [LdapGroup]
			FROM OPENQUERY (ADSI, ''&lt;LDAP://barriere.COM&gt;;
			(&amp;(objectClass=group)(member:1.2.840.113556.1.4.1941:= ' + @Path + '));
			cn, adspath;subtree'')
			ORDER BY cn;
		'

		EXEC sp_executesql @Query
END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>AD_Active_Directory</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SQL ADSI Query limitation__255_char_limit</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>AD_Active_Directory</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SQL ADSI Query limitation__255_char_limit</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Definite 255 char limit. See http://www.sqlteam.com/forums/topic.asp?TOPIC_ID=65584

I used the function to get around and loop through

declare @Apptemp3 table (BSamName varchar(255),
BDisplayName varchar(255),
BPhone varchar(100),
BEMail varchar(255),
BFirstName varchar(100),
BLastName varchar(100))



DECLARE @sChar char(1)
declare @body varchar(8000)
DECLARE @nAsciiValue smallint


SELECT @nAsciiValue = 65

WHILE @nAsciiValue &lt; 91
BEGIN

SELECT @sChar= CHAR(@nAsciiValue)

SET @body = (select dbo.fnSprintf('SELECT sAMAccountName, displayName, mail, telephoneNumber, sn, givenName FROM OPENQUERY( ADSI, ''SELECT displayName, sAMAccountName, mail, telephoneNumber, sn, givenName FROM ''''LDAP://dc=jphsa,dc=org''''WHERE objectCategory = ''''Person'''' AND SAMAccountName = ''''%s*'''''' )', @SChar +'*', default))

INSERT @Apptemp3
EXEC( @body)

SELECT @nAsciiValue = @nAsciiValue + 1
END

Select ISNULL(Upper(BSamName),'NoSamID'),ISNULL(BDisplayName,'NoDName'),ISNULL(BPhone,'NoPhone'),ISNULL(BEMail,'Nomail'),ISNULL(BFirstName,'NoFname'),ISNULL(BLastName,'NoLname') from @Apptemp3
order by BSamName 

--==================================================================
http://www.sqlteam.com/forums/topic.asp?TOPIC_ID=65584
--select dbo.fnSprintf('INSERT INTO %s VALUES (%s, %s)', 'table1,1,2', default)


create function dbo.fnSprintf (@s varchar(8000), @params varchar(8000), @separator char(1) = ',')
returns varchar(8000)
as
begin
declare @p varchar(8000)

set @params = @params + @separator
while not @params = ''
begin
    set @p = left(@params+@separator, charindex(@separator, @params)-1)
    set @s = STUFF(@s, charindex('%s', @s), 2, @p)
    set @params = substring(@params, len(@p)+2, 8000)
end
return @s
end</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>AD_Active_Directory</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SQL ADSI Query limitation_1000_records</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>AD_Active_Directory</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SQL ADSI Query limitation_1000_records</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--SQL ADSI Query limitation
--This worked at JPHSA for the Users
--============================================================================================================================
CREATE TABLE #tmpADUsers
( employeeId varchar(10) NULL,
SAMAccountName varchar(255) NOT NULL,
email varchar(255) NULL)
GO

/* AD is limited to send 1000 records in one batch. In an ADO interface you can define this batch size, not in OPENQUERY.
Because of this limitation, we just loop through the alphabet.
*/

DECLARE @cmdstr varchar(255)
DECLARE @nAsciiValue smallint
DECLARE @sChar char(1)

SELECT @nAsciiValue = 65

WHILE @nAsciiValue &lt; 91
BEGIN

SELECT @sChar= CHAR(@nAsciiValue)

EXEC master..xp_sprintf @cmdstr OUTPUT, 'SELECT employeeId, SAMAccountName, Mail FROM OPENQUERY( ADSI, ''SELECT Mail, SAMAccountName, employeeID FROM ''''LDAP://cn=Users,dc=jphsa,dc=org''''WHERE objectCategory = ''''Person'''' AND SAMAccountName = ''''%s*'''''' )', @sChar

INSERT #tmpADUsers
EXEC( @cmdstr )

SELECT @nAsciiValue = @nAsciiValue + 1
END

SELECT *
FROM #tmpADUsers
order by SAMAccountName

DROP TABLE #tmpADUsers
--============================================================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Aggregate_among_Columns</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>MINIMUM_value_from_several_columns</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Aggregate_among_Columns</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>MINIMUM_value_from_several_columns</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://stackoverflow.com/questions/368351/whats-the-best-way-to-select-the-minimum-value-from-several-columns



--Given the following table in SQL Server 2005:

--ID   Col1   Col2   Col3
----   ----   ----   ----
1       3     34     76  
2      32    976     24
3       7    235      3
4     245      1    792

--What is the best way to write the query that yields the following result 
--(i.e. one that yields the final column - a column containing the minium values out of Col1, Col2, and Col 3 for each row)?

--ID   Col1   Col2   Col3  TheMin
----   ----   ----   ----  ------
1       3     34     76       3
2      32    976     24      24
3       7    235      3       3
4     245      1    792       1



//////////////////////////////////////-- using UNPIVOT

with cte (ID, Col1, Col2, Col3)
as
(
    select ID, Col1, Col2, Col3
    from TestTable
)
select cte.ID, Col1, Col2, Col3, TheMin from cte
join
(
    select
    	ID, min(Amount) as TheMin
    from 
    	cte 
    	UNPIVOT (Amount for AmountCol in (Col1, Col2, Col3)) as unpvt
    group by ID
) as minValues
on cte.ID = minValues.ID

//////////////////////////////////////-- Case/When
Select Id,
       Case When Col1 &lt; Col2 And Col1 &lt; Col3 Then Col1
            When Col2 &lt; Col1 And Col2 &lt; Col3 Then Col2 
            Else Col3
            End As TheMin
From   YourTableNameHere


//////////////////////////////////////-- CROSS APPLY

create table YourTable (ID int, col1 int, col2 int, col3 int)
insert into YourTable values (1,1,3,4)
insert into YourTable values (2,5,2,4)
insert into YourTable values (3,7,10,4)


SELECT ID, Col1, Col2, Col3, MinValue
FROM YourTable
CROSS APPLY (SELECT MIN(d) MinValue FROM (VALUES (Col1), (Col2), (Col3)) AS a(d)) A


////////////////////////////////////-- re-design the problem:
--The right way to do this, in my opinion, is to have the following table:

ID    Col    Val
--    ---    ---
 1      1      3
 1      2     34
 1      3     76

 2      1     32
 2      2    976
 2      3     24

 3      1      7
 3      2    235
 3      3      3

 4      1    245
 4      2      1
 4      3    792

--with ID/Col as the primary key and possibly Col as an extra key, depending on your needs. 
--Then your query becomes a simple

select min(val) from tbl
--and you can still treat the individual 'old columns' separately by using
where col = 2


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Aggregate</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Group_By__Cube_vs_Rollup</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Aggregate</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Group_By__Cube_vs_Rollup</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Group_By__Cube_vs_Rollup

The Difference Between Rollup and Cube
Ref: http://www.sqlservercentral.com/articles/T-SQL/163572/

--The GROUP BY clause is used to group the results of aggregate functions according to a specified column. 
--However, the GROUP BY clause doesn’t perform aggregate operations on multiple levels of a hierarchy. 
--For example, you can calculate the total of all employee salaries for each department in a company 
--(one level of hierarchy) 
--but you cannot calculate the total salary of all employees regardless of the department they work in 
--(two levels of hierarchy

--ROLLUP operators 
--	let you extend the functionality of GROUP BY 
--	clauses by calculating subtotals and grand totals for a set of columns. 
--The CUBE operator is similar in functionality to the ROLLUP operator; 
--however, 
--the CUBE operator 
--	can calculate subtotals and grand totals for all permutations of the columns specified in i

--There is only one major difference between the functionality of the ROLLUP operator 
--and the CUBE operator. 
--ROLLUP operator generates aggregated results for the selected columns in a hierarchical way. 
--On the other hand, 
--CUBE generates a aggregated result that contains all the possible combinations for the selected columns.

--Which One Should I Use?
------------------------
/*
A simple rule of thumb is that if you have hierarchical data (for example, 
	country-&gt;state-&gt;city or Department-&gt;Manager-Salesman, etc.), 
you usually want hierarchical results, and you use ROLLUP to group the data.

If you have non-hierarchical data (for example, 
	City-Gender-Nationality), 
then you don’t want hierarchical results and so you use CUBE as it will provide all possible combinations.
*/
\\\\\\\\\\\\\\\\\\\\\\\\
--Creating Dummy Data
---------------------
  USE company;

  CREATE TABLE employee
  (
      id INT PRIMARY KEY,
      name VARCHAR(50) NOT NULL,
      gender VARCHAR(50) NOT NULL,
      salary INT NOT NULL,
      department VARCHAR(50) NOT NULL
   )
  INSERT INTO employee
  VALUES
  (1, 'David', 'Male', 5000, 'Sales'),
  (2, 'Jim', 'Female', 6000, 'HR'),
  (3, 'Kate', 'Female', 7500, 'IT'),
  (4, 'Will', 'Male', 6500, 'Marketing'),
  (5, 'Shane', 'Female', 5500, 'Finance'),
  (6, 'Shed', 'Male', 8000, 'Sales'),
  (7, 'Vik', 'Male', 7200, 'HR'),
  (8, 'Vince', 'Female', 6600, 'IT'),
  (9, 'Jane', 'Female', 5400, 'Marketing'),
  (10, 'Laura', 'Female', 6300, 'Finance'),
  (11, 'Mac', 'Male', 5700, 'Sales'),
  (12, 'Pat', 'Male', 7000, 'HR'),
  (13, 'Julie', 'Female', 7100, 'IT'),
  (14, 'Elice', 'Female', 6800,'Marketing'),
  (15, 'Wayne', 'Male', 5000, 'Finance')

  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  --The ROLLUP operator can also be used to calculate sub-totals for each column,
  --	 based on the groupings within that column.
  
  --Simple GROUP BY Clause
  ---------------------------
  SELECT department, sum(salary) as Salary_Sum
  FROM employee
  GROUP BY department
  
 	 --OUTPUT
 	 --------------
  	Department	Salary_Sum
	--------------	----------------
	Finance			16800
	HR				20200
	IT				21200
	Marketing		18700
	Sales			18700
  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  
  --The ROLLUP Operator
  ----------------------
  SELECT 
  	coalesce (department, 'All Departments') AS Department,  --the grand total ROLLUP will return a NULL for department. To avoid this, we have used the “Coalesce” clause
    sum(salary) as Salary_Sum
  FROM employee
  GROUP BY ROLLUP (department)
  
--  Finding Subtotals Using ROLLUP Operator
----------------------------------------------
  SELECT
	  coalesce (department, 'All Departments') AS Department, --the grand total ROLLUP will return a NULL for department. To avoid this, we have used the “Coalesce” clause
	  coalesce (gender,'All Genders') AS Gender,
	  sum(salary) as Salary_Sum
  FROM employee
  GROUP BY ROLLUP (department, gender)  --&lt;== NOTE: b/c gender is last (i.e. lowest in Hierarchy) you get (each dept &amp; all Genders)
  										--		BUT you don't get (each Gender &amp; all Dept)
  
--OUTPUT
-----------------------------------------  
Department		Gender		Salary_Sum
Finance			Female		11800
Finance			Male		5000
Finance			All Genders	16800
HR				Female		6000
HR				Male		14200
HR				All Genders	20200
IT				Female		21200
IT				All Genders	21200
Marketing		Female		12200
Marketing		Male		6500
Marketing		All Genders	18700
Sales			Male		18700
Sales			All Genders	18700
All Departments	All Genders	95600

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
--The CUBE Operator

--the CUBE operator produces results by generating all combinations of columns specified in the GROUP BY CUBE clause.

  SELECT
  coalesce (department, 'All Departments') AS Department,
  coalesce (gender,'All Genders') AS Gender,
  sum(salary) as Salary_Sum
  FROM employee
  GROUP BY CUBE (department, gender)
  
--OUTPUT
-------------------------------------------
Row No	Department		Gender			Salary_Sum
------	---------		-------			-----------
1		Finance			Female			11800
2		HR				Female			6000
3		IT				Female			21200
4		Marketing		Female			12200
5		All Departments	Female			51200
6		Finance			Male			5000
7		HR				Male			14200
8		Marketing		Male			6500
9		Sales			Male			18700
10		All Departments	Male			44400
11		All Departments	All Genders		95600
12		Finance			All Genders		16800
13		HR				All Genders		20200
14		IT				All Genders		21200
15		Marketing		All Genders		18700
16		Sales			All Genders		18700
  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Aggregate</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>sum_Negative_and_Positive_numbersFromOneColumn_into_2_fields</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Aggregate</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>sum_Negative_and_Positive_numbersFromOneColumn_into_2_fields</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--junk4.sql


USE JUNK

IF OBJECT_ID ('junkTable', 'U') IS NOT NULL
DROP TABLE dbo.junkTable;


create table junkTable(someNumber numeric);


insert into junkTable(someNumber) values
  (2),
  (-2),
  (4),
  (-4),
  (-3),
  (0),
  (2) ;


  select 
	sum(case 
			when someNumber &gt; 0 then someNumber 
			else 0 
			end
		) as sum_pos,
	sum(case 
			when someNumber &lt; 0 then someNumber 
			else 0 
			end) as sum_neg 
	from junkTable;
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>aspnetdb_StoredProcedures_ORIG</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>aspnet_Membership_CreateUser</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>aspnetdb_StoredProcedures_ORIG</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>aspnet_Membership_CreateUser</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE [aspnetdb]
GO

/**
This SP calls: aspnet_Users_CreateUser

*/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[aspnet_Membership_CreateUser]
    @ApplicationName                        nvarchar(256),
    @UserName                               nvarchar(256),
    @Password                               nvarchar(128),
    @PasswordSalt                           nvarchar(128),
    @Email                                  nvarchar(256),
    @PasswordQuestion                       nvarchar(256),
    @PasswordAnswer                         nvarchar(128),
    @IsApproved                             bit,
    @CurrentTimeUtc                         datetime,
    @CreateDate                             datetime = NULL,
    @UniqueEmail                            int      = 0,
    @PasswordFormat                         int      = 0,
    @UserId                                 uniqueidentifier OUTPUT		-- need the calling subroutine to provide this: 	
AS
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL

    DECLARE @NewUserId uniqueidentifier
    SELECT @NewUserId = NULL

    DECLARE @IsLockedOut bit
    SET @IsLockedOut = 0

    DECLARE @LastLockoutDate  datetime
    SET @LastLockoutDate = CONVERT( datetime, '17540101', 112 )

    DECLARE @FailedPasswordAttemptCount int
    SET @FailedPasswordAttemptCount = 0

    DECLARE @FailedPasswordAttemptWindowStart  datetime
    SET @FailedPasswordAttemptWindowStart = CONVERT( datetime, '17540101', 112 )

    DECLARE @FailedPasswordAnswerAttemptCount int
    SET @FailedPasswordAnswerAttemptCount = 0

    DECLARE @FailedPasswordAnswerAttemptWindowStart  datetime
    SET @FailedPasswordAnswerAttemptWindowStart = CONVERT( datetime, '17540101', 112 )

    DECLARE @NewUserCreated bit
    DECLARE @ReturnValue   int
    SET @ReturnValue = 0

    DECLARE @ErrorCode     int
    SET @ErrorCode = 0

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
	    BEGIN TRANSACTION
	    SET @TranStarted = 1
    END
    ELSE
    	SET @TranStarted = 0
    	
	-- Create Application and get it's PK if it does not already exist, otherwise does nothing.
    EXEC dbo.aspnet_Applications_CreateApplication @ApplicationName, @ApplicationId OUTPUT

    IF( @@ERROR &lt;&gt; 0 )	--i.e. if there was an error creating the application, in the case that it did not exist
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    SET @CreateDate = @CurrentTimeUtc

	-- Check to see if there is a user with the same name for the same application
    SELECT  @NewUserId = UserId FROM dbo.aspnet_Users WHERE LOWER(@UserName) = LoweredUserName AND @ApplicationId = ApplicationId
    IF ( @NewUserId IS NULL )
    BEGIN
    -- If the user does not exist then create the user, using the incoming UserID
        SET @NewUserId = @UserId
        EXEC @ReturnValue = dbo.aspnet_Users_CreateUser @ApplicationId, @UserName, 0, @CreateDate, @NewUserId OUTPUT
        SET @NewUserCreated = 1
    END
    ELSE
    BEGIN
		-- Else the user does exist for that application
        SET @NewUserCreated = 0
        IF( @NewUserId &lt;&gt; @UserId AND @UserId IS NOT NULL )
        BEGIN
            SET @ErrorCode = 6 -- The user already exists
            GOTO Cleanup
        END
    END

    IF( @@ERROR &lt;&gt; 0 )
    BEGIN
        SET @ErrorCode = -1	-- There were some errors somewhere in the previous statements
        GOTO Cleanup
    END

    IF( @ReturnValue = -1 )
    BEGIN
        SET @ErrorCode = 10	--There was a problem creating the user
        GOTO Cleanup
    END

    IF ( EXISTS ( SELECT UserId
                  FROM   dbo.aspnet_Membership
                  WHERE  @NewUserId = UserId ) )
    BEGIN
        SET @ErrorCode = 6	--The UserId exists in aspnet_Membership
        GOTO Cleanup
    END

    SET @UserId = @NewUserId

    IF (@UniqueEmail = 1)
    BEGIN
        IF (EXISTS (SELECT *
                    FROM  dbo.aspnet_Membership m WITH ( UPDLOCK, HOLDLOCK )
                    WHERE ApplicationId = @ApplicationId AND LoweredEmail = LOWER(@Email)))
        BEGIN
            SET @ErrorCode = 7 --The email was supposed to be unique, but was not
            GOTO Cleanup
        END
    END

    IF (@NewUserCreated = 0)
    BEGIN
        UPDATE dbo.aspnet_Users
        SET    LastActivityDate = @CreateDate
        WHERE  @UserId = UserId
        IF( @@ERROR &lt;&gt; 0 )
        BEGIN
            SET @ErrorCode = -1	--There was a problem updating the LastActivityDate
            GOTO Cleanup
        END
    END

    INSERT INTO dbo.aspnet_Membership
                ( ApplicationId,
                  UserId,
                  Password,
                  PasswordSalt,
                  Email,
                  LoweredEmail,
                  PasswordQuestion,
                  PasswordAnswer,
                  PasswordFormat,
                  IsApproved,
                  IsLockedOut,
                  CreateDate,
                  LastLoginDate,
                  LastPasswordChangedDate,
                  LastLockoutDate,
                  FailedPasswordAttemptCount,
                  FailedPasswordAttemptWindowStart,
                  FailedPasswordAnswerAttemptCount,
                  FailedPasswordAnswerAttemptWindowStart )
         VALUES ( @ApplicationId,
                  @UserId,
                  @Password,
                  @PasswordSalt,
                  @Email,
                  LOWER(@Email),
                  @PasswordQuestion,
                  @PasswordAnswer,
                  @PasswordFormat,
                  @IsApproved,
                  @IsLockedOut,
                  @CreateDate,
                  @CreateDate,
                  @CreateDate,
                  @LastLockoutDate,
                  @FailedPasswordAttemptCount,
                  @FailedPasswordAttemptWindowStart,
                  @FailedPasswordAnswerAttemptCount,
                  @FailedPasswordAnswerAttemptWindowStart )

    IF( @@ERROR &lt;&gt; 0 )
    BEGIN
        SET @ErrorCode = -1	--There was an error in:  INSERT INTO dbo.aspnet_Membership
        GOTO Cleanup
    END

    IF( @TranStarted = 1 )
    BEGIN
	    SET @TranStarted = 0
	    COMMIT TRANSACTION
    END

    RETURN 0

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
    	ROLLBACK TRANSACTION
    END

    RETURN @ErrorCode

END
GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>AUDIT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>AuditManyTables_To_OneTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>AUDIT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>AuditManyTables_To_OneTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Auditing tables can be a complicated procedure if you require a new table for every table being audited. 
--Fortunately the new XML datatype can help to automate this procedure of auditing multiple tables into a single table.

--The following trigger template can be used to audit a table into a single table.

--First let’s create the table needed to hold the audited values:



CREATE TABLE [Log].[AuditTableHistory](
	[HistoryID] [int] IDENTITY(1,1) NOT NULL,
	[TableSchema] [varchar](10) NULL,
	[TableName] [varchar](100) NULL,
	[AuditValue] [xml] NULL,
	[DateCreated] [datetime] NULL,
 CONSTRAINT [PK_AUDITTABLEHISTORY] PRIMARY KEY CLUSTERED
(
	[HistoryID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 80) ON [PRIMARY]
) ON [PRIMARY]

-- Now let's create the trigger

CREATE TRIGGER [Audit].[Trg_Schema_Table]
   ON  [Schema].[Table]
   AFTER UPDATE,DELETE
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @AuditValue xml

	SET @AuditValue =
	(
		SELECT TOP 1 *
		FROM DELETED
		FOR XML AUTO
	)

	INSERT INTO Log.AuditTableHistory
	(
		AuditValue,
		TableSchema,
		TableName,
		DateCreated
	)
	SELECT
		AuditValue	= @AuditValue,
		TableSchema	= OBJECT_SCHEMA_NAME(parent_obj),
		TableName	= OBJECT_NAME(parent_obj),
		DateCreated	= GETDATE()

	FROM sysobjects so
	WHERE so.id = @@PROCID

END

GO



--We can apply this trigger to any table we want just by changing the “ON” statement. 
--It will work for any table. The only difficulty comes in when we change the schema for a particular table. When this happens, 
--we need to know the date/time the table schema changed so we can query the table appropriately. 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>BIT_and_TruthTable_math</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>BIT_Test_Data</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>BIT_and_TruthTable_math</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>BIT_Test_Data</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE TruthTable

--====================================


IF OBJECT_ID ('TT_1', 'U') IS NOT NULL
DROP TABLE dbo.TT_1;
 
CREATE TABLE dbo.TT_1  -- target
(
  TT_1_ID INT NOT NULL PRIMARY KEY,
  P bit,
  Q bit
);

INSERT TT_1 VALUES
  (1, 1, 1),
  (2, 1, 0),
  (3, 0, 1),
  (4, 0, 0);

--====================================


IF OBJECT_ID ('TT_2', 'U') IS NOT NULL
DROP TABLE dbo.TT_2;
 
CREATE TABLE dbo.TT_2  -- target
(
  TT_2_ID INT NOT NULL PRIMARY KEY,
  P bit,
  Q bit
);

INSERT TT_2 VALUES
  (1, 'TRUE', 'TRUE'),
  (2, 'TRUE','FALSE'),
  (3, 'FALSE', 'TRUE'),
  (4, 'FALSE', 'FALSE');
  
SELECT * from TT_1

SELECT * from TT_2
  
  
--OUTPUT
TT_1_ID	P	Q
1	1	1
2	1	0
3	0	1
4	0	0  

TT_2_ID	P	Q
1	1	1
2	1	0
3	0	1
4	0	0</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>BIT_and_TruthTable_math</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Operator_results</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>BIT_and_TruthTable_math</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Operator_results</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE TruthTable

--====================================


IF OBJECT_ID ('TT_1', 'U') IS NOT NULL
DROP TABLE dbo.TT_1;
 
CREATE TABLE dbo.TT_1  -- target
(
  TT_1_ID INT NOT NULL PRIMARY KEY,
  P bit,
  Q bit
);

INSERT TT_1 VALUES
  (1, 1, 1),
  (2, 1, 0),
  (3, 0, 1),
  (4, 0, 0);

--====================================

SELECT  [TT_1_ID]
      ,[P]
      ,[Q]
      --, (SELECT 'TheCalculation' = TT_1.P &amp; TT_1.Q ) AS [_AND_]] 
      ,p &amp; q  as [_and_]
      , p | q  as [_or_] 
      , p ^ q  as [_XOR_]     
      , ~p &amp; ~q  as [_NOTand_]
      , ~p | ~q  as [_NOTor_] 
      , ~p ^ ~q  as [_NOTXOR_]  
      , ~(p &amp; q)  as [_NOT_Parenthesis_and_]
      , ~(p | q)  as [_NOT_Parenthesis_or_] 
      , ~(p ^ q)  as [_NOT_Parenthesis_XOR_]                   
  FROM [TT_1]


--OUTPUT

TT_1_ID	P	Q	_and_	_or_	_XOR_	_NOTand_	_NOTor_	_NOTXOR_	_NOT_Parenthesis_and_	_NOT_Parenthesis_or_	_NOT_Parenthesis_XOR_
1		1	1	1		1		0		0			0			0			0						0						1
2		1	0	0		1		1		0			1			1			1						0						0
3		0	1	0		1		1		0			1			1			1						0						0
4		0	0	0		0		0		1			1			0			1						1						1</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Bulk_Insert</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>BCP_ReadMe</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Bulk_Insert</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>BCP_ReadMe</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--So, for example, in order to minimize logging for bulk activities, such as those used by BCP.exe, 
--you can temporarily switch from Full recovery mode to Bulklogged mode, 
--while retaining the ability to back up the transaction log. 

--One downside of Bulk-logged mode, however, is that you lose the ability to restore to a 
--point in time if there are any bulk transactions, though you
--can still restore the entire transaction log in Bulk-logged mode

--Alternatively, you can set the database to Simple mode, in which bulk operations are also minimally logged. 
--By definition, the Simple mode does not support point in time recovery, since the transaction log cannot be backed up, 
--and is truncated  each time a checkpoint is issued for the database.
 
--However, this "truncate on checkpoint" 
--process does have the benefit that the log is continually freed of committed transactions, and will not grow indefinitely

--The dangers of rampant log file growth can be mitigated to some extent by
--committing bulk update, inserts or delete transactions in batches, say every
--100,000 records. In BCP, for example, you can control the batch size using the
--batch size flag. This is a good practice regardless of recovery model, as it means
--that the committed transaction can be removed from the log file, either via a log
--backup or a checkpoint truncate.

--if recovering to a point in time is important, then your databases will
--need to be in Full recovery mode. In this case, I'd recommend switching to Bulk
--logged mode for bulk operations, performing a full backup after bulk loading the
--data and then subsequently switching back to Full recovery and continuing log
--backups from that point.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Bulk_Insert</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Bulk_Insert_EscapeCharacters_NonPrintables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Bulk_Insert</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Bulk_Insert_EscapeCharacters_NonPrintables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

BULK INSERT [table]
FROM 'c:\file'
WITH
(
   FIELDTERMINATOR = CHAR(0x01),
   ROWTERMINATOR = CHAR(0x02),
   FIRSTROW = 2
);</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Bulk_Insert</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Bulk_Insert_WithFormatTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Bulk_Insert</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Bulk_Insert_WithFormatTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>



-- http://www.tek-tips.com/faqs.cfm?fid=1602






--You have to setup a format file to process a text file that has quotes around every field.  Here are the details:

--this is two lines from a sample text file:
--"1","2","3","4","5","6","7","8"
--"22","23","33","44","45","56","57","58"

--There are 8 fields to process.  Here is how the BULK INSERT would look:

bulk insert SALESTemp
    from '\\sales\sales.txt'
    with
        (
            formatfile='\\sales\sales.fmt'
        )

--The fmt format file is coded as follows:

--8.0
--17
--1       SQLCHAR       0       0       "\""                      0     dummy1             ""
--2       SQLCHAR       0       50      "\""                      1     Field1             ""
--3       SQLCHAR       0       0       ",\""                     0     dummy2             ""
--4       SQLCHAR       0       50      "\""                      2     Field2             ""
--5       SQLCHAR       0       0       ",\""                     0     dummy3             ""
--6       SQLCHAR       0       50      "\""                      3     Field3             ""
--7       SQLCHAR       0       0       ",\""                     0     dummy4             ""
--8       SQLCHAR       0       50      "\""                      4     Field4             ""
--9       SQLCHAR       0       0       ",\""                     0     dummy5             ""
--10      SQLCHAR       0       50      "\""                      5     Field5             ""
--11      SQLCHAR       0       0       ",\""                     0     dummy6             ""
--12      SQLCHAR       0       50      "\""                      6     Field6             ""
--13      SQLCHAR       0       0       ",\""                     0     dummy7             ""
--14      SQLCHAR       0       50      "\""                      7     Field7             ""
--15      SQLCHAR       0       0       ",\""                     0     dummy8             ""
--16      SQLCHAR       0       50      "\""                      8     Field8             ""
--17      SQLCHAR       0       0       "\r\n"                    0     dummy9             ""

--The format file basically</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CCWNC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Add_New_Team_Record</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CCWNC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Add_New_Team_Record</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_8011_SP_046_Add_New_Team_Record_To_T17.sql
-----------------------------------------

/* This SP will:

  		1] do not need to check to see if the Team is already assigned to the Group 
  			record b/c of constraint: [[T17_UNIQUE_TeamName_T14FK]] 		
  				
  		2] Insert the new Team Record into T17, get the T17_PK for the new record
  				
  		3] Return the T17_PK for the new Team record, or zero (0) if there was a problem

	************************************************************************************
	NOTE: 
	Uses: 
	Created: 10/26/2012
	By: glenn garson
	************************************************************************************

*/

SET NOCOUNT ON
Use DB2_CRM
go



alter PROCEDURE SP_046_Add_New_Team_Record_To_T17(
	@iT14_FK as int,
	@Team_Name AS nvarchar(255),
	@Team_AlternateName AS nvarchar(255),
	@Team_Focus AS  nvarchar(max),
	@Team_Notes AS  nvarchar(max),
	@b_Active AS  bit
	)
	
	AS
	
-- START DEBUGGING SECTION -------------------	
			PRINT '1) Input @iT14_FK: [' + 	 CAST(@iT14_FK AS varchar(5)) + ']'
			PRINT '2) Input @Team_Name: [' + coalesce(@Team_Name, '{NULL}')	 + ']' 
			PRINT '3) Input @Team_AlternateName: [' + coalesce(@Team_AlternateName, '{NULL}')	 + ']' 			
			PRINT '4) Input @Team_Focus: [' + coalesce(@Team_Focus, '{NULL}')	 + ']' 			
			PRINT '5) Input @Team_Notes: [' + coalesce(@Team_Notes, '{NULL}')	 + ']' 				
			PRINT '6) Input @b_Active: [' +  SUBSTRING('FalseTrue', @b_Active * 5 + 1, 5) + ']' 			
		
																	
-- END DEBUGGING SECTION -------------------	


-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


	DECLARE @iTheNew_T17_PK INT

		
	

-- 111111111111111111111111111111111111111111111111111111111111111111111111111111222
INSERT INTO [T17_Team]
						(
						  [T14_FK]
						  ,[Team_Name]
						  ,[Team_AlternateName]
						  ,[Team_Focus]
						  ,[Team_Notes]
						  ,[b_Active]
						)
VALUES
		(
			@iT14_FK,
			@Team_Name,
			@Team_AlternateName,
			@Team_Focus,
			@Team_Notes,
			@b_Active

		);
		
		
	IF @@ERROR = 0
		BEGIN
			SELECT @iTheNew_T17_PK = @@IDENTITY
			PRINT 'The PK for the new Team Record is: ' + CAST(@iTheNew_T17_PK as varchar(5))
			RETURN @iTheNew_T17_PK
		END		
	ELSE	
		BEGIN
			PRINT 'Woops! There was an error while trying to insert the new Team.'	
			RETURN 0
		END				

-- 111111111111111111111111111111111111111111111111111111111111111111111111111111222


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CDC_Change_Data_Capture</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Insert_Operation_and_CaptureDataFrom_Insert_Operation</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CDC_Change_Data_Capture</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Insert_Operation_and_CaptureDataFrom_Insert_Operation</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--From: http://www.dotnetfunda.com/articles/show/1924/cdc-in-sql-server-2008-r2-part-i
-- Using the first Snippet


--INSERT:  Following query would insert a record into Employee table

INSERT INTO [TrialDB].[DBO].[Employee]

           ([NationalIDNumber]          

           ,[ContactID]

           ,[LoginID]

           ,[ManagerID]

           ,[Title]

           ,[BirthDate]

           ,[MaritalStatus]

           ,[Gender]

           ,[HireDate]        

           ,[VacationHours]

           ,[SickLeaveHours] 

)

VALUES

       (14417807

           ,1209

           ,'trial\guy1'

           ,16

           ,'Production Technician - WC60'

           ,NULL

           ,'M'

           ,'M'

           ,GETDATE()          

           ,21

           ,30

           )
           
           
-- This would capture the operation

SELECT            
           
           
           
           
           </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CDC_Change_Data_Capture</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ReadMe_CDC_Change_Data_Capture</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CDC_Change_Data_Capture</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ReadMe_CDC_Change_Data_Capture</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ReadMe_CDC_Change_Data_Capture


CDC- Change Data Capture. 
It provides ability to record all data change operations such as INSERT, UPDATE and DELETE. 
The data is captured asynchronously which means it is not captured in transactions containing these operations 
rather it is captured through the transaction logs reducing the performance impact.


--When I tried to run it on SQL 2008 R2 standard it gave me this:
Msg 22988, Level 16, State 1, Procedure sp_cdc_enable_db, Line 12
This instance of SQL Server is the Standard Edition (64-bit). Change data capture is only available in the Enterprise, Developer, and Enterprise Evaluation editions.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CrossApply</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>APPLY_with_Table_valued_Function</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CrossApply</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>APPLY_with_Table_valued_Function</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--FROM: http://www.mssqltips.com/sqlservertip/1958/sql-server-cross-apply-and-outer-apply/


--So in summary the APPLY operator is required when you have to use table-valued function in the query, 
--	but it can also be used with an inline SELECT statements.

USE [tempdb]
GO
IF EXISTS (SELECT * FROM sys.objects WHERE OBJECT_ID = OBJECT_ID(N'[Employee]') AND type IN (N'U'))
	BEGIN
	   DROP TABLE [Employee]
	END
GO
IF EXISTS (SELECT * FROM sys.objects WHERE OBJECT_ID = OBJECT_ID(N'[Department]') AND type IN (N'U'))
	BEGIN
	   DROP TABLE [Department]
	END
	
CREATE TABLE [Department](
   [DepartmentID] [int] NOT NULL PRIMARY KEY,
   [Name] VARCHAR(250) NOT NULL,
) ON [PRIMARY]
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (1, N'Engineering')
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (2, N'Administration')
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (3, N'Sales')
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (4, N'Marketing')
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (5, N'Finance')
GO

CREATE TABLE [Employee](
   [EmployeeID] [int] NOT NULL PRIMARY KEY,
   [FirstName] VARCHAR(250) NOT NULL,
   [LastName] VARCHAR(250) NOT NULL,
   [DepartmentID] [int] NOT NULL REFERENCES [Department](DepartmentID),
) ON [PRIMARY]
GO
	INSERT [Employee] ([EmployeeID], [FirstName], [LastName], [DepartmentID])
	VALUES (1, N'Orlando', N'Gee', 1 )
	INSERT [Employee] ([EmployeeID], [FirstName], [LastName], [DepartmentID])
	VALUES (2, N'Keith', N'Harris', 2 )
	INSERT [Employee] ([EmployeeID], [FirstName], [LastName], [DepartmentID])
	VALUES (3, N'Donna', N'Carreras', 3 )
	INSERT [Employee] ([EmployeeID], [FirstName], [LastName], [DepartmentID])
	VALUES (4, N'Janet', N'Gates', 3 ) 
	
--///////////APPLY with table-valued function //////////////////////////////


IF EXISTS 
	(	SELECT * 
		FROM sys.objects 
		WHERE OBJECT_ID = OBJECT_ID(N'[fn_GetAllEmployeeOfADepartment]'
	) 
	AND 
	type IN (N'IF'))
	
	BEGIN
	   DROP FUNCTION dbo.fn_GetAllEmployeeOfADepartment
	END
	
GO

CREATE FUNCTION dbo.fn_GetAllEmployeeOfADepartment(@DeptID AS INT) 
RETURNS TABLE
AS
RETURN
   (
   SELECT * 
   FROM Employee E
   WHERE E.DepartmentID = @DeptID
   )
GO

--/////////// CROSS APPLY //////////////////////////////

SELECT * 
FROM 
	Department D
	CROSS APPLY 
	dbo.fn_GetAllEmployeeOfADepartment(D.DepartmentID)
	
GO

--/////////// OUTER APPLY //////////////////////////////

SELECT * 
FROM 
	Department D
	OUTER APPLY 
	dbo.fn_GetAllEmployeeOfADepartment(D.DepartmentID)
GO </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CrossApply</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CrossApply_BasicExample</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CrossApply</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CrossApply_BasicExample</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--From: http://technet.microsoft.com/en-us/library/ms175156.aspx


--The APPLY operator allows you to invoke a table-valued function for each row returned by an outer table expression of a query. 
--The table-valued function acts as the right input and the outer table expression acts as the left input. 
--The right input is evaluated for each row from the left input and the rows produced are combined for the final output. 
--The list of columns produced by the APPLY operator is the set of columns in the left input followed by the list of columns returned by the right input. 


--CROSS APPLY returns only rows from the outer table that produce a result set from the table-valued function. 
--OUTER APPLY returns both rows that produce a result set, and rows that do not, with NULL values in the columns produced by the table-valued function.

--As an example, consider the following tables, Employees and Departments:

--Create Employees table and insert values.
CREATE TABLE Employees
(
    empid   int         NOT NULL
    ,mgrid   int         NULL
    ,empname varchar(25) NOT NULL
    ,salary  money       NOT NULL
    CONSTRAINT PK_Employees PRIMARY KEY(empid)
);
GO
INSERT INTO Employees VALUES(1 , NULL, 'Nancy'   , $10000.00);
INSERT INTO Employees VALUES(2 , 1   , 'Andrew'  , $5000.00);
INSERT INTO Employees VALUES(3 , 1   , 'Janet'   , $5000.00);
INSERT INTO Employees VALUES(4 , 1   , 'Margaret', $5000.00);
INSERT INTO Employees VALUES(5 , 2   , 'Steven'  , $2500.00);
INSERT INTO Employees VALUES(6 , 2   , 'Michael' , $2500.00);
INSERT INTO Employees VALUES(7 , 3   , 'Robert'  , $2500.00);
INSERT INTO Employees VALUES(8 , 3   , 'Laura'   , $2500.00);
INSERT INTO Employees VALUES(9 , 3   , 'Ann'     , $2500.00);
INSERT INTO Employees VALUES(10, 4   , 'Ina'     , $2500.00);
INSERT INTO Employees VALUES(11, 7   , 'David'   , $2000.00);
INSERT INTO Employees VALUES(12, 7   , 'Ron'     , $2000.00);
INSERT INTO Employees VALUES(13, 7   , 'Dan'     , $2000.00);
INSERT INTO Employees VALUES(14, 11  , 'James'   , $1500.00);
GO
--Create Departments table and insert values.
CREATE TABLE Departments
(
    deptid    INT NOT NULL PRIMARY KEY
    ,deptname  VARCHAR(25) NOT NULL
    ,deptmgrid INT NULL REFERENCES Employees
);
GO
INSERT INTO Departments VALUES(1, 'HR',           2);
INSERT INTO Departments VALUES(2, 'Marketing',    7);
INSERT INTO Departments VALUES(3, 'Finance',      8);
INSERT INTO Departments VALUES(4, 'R&amp;D',          9);
INSERT INTO Departments VALUES(5, 'Training',     4);
INSERT INTO Departments VALUES(6, 'Gardening', NULL);

--Most departments in the Departments table have a manager ID that corresponds to an employee in the Employees table. 
--The following table-valued function accepts an employee ID as an argument and returns that employee and all of his or her subordinates.

CREATE FUNCTION dbo.fn_getsubtree(@empid AS INT) 
    RETURNS @TREE TABLE
(
    empid   INT NOT NULL
    ,empname VARCHAR(25) NOT NULL
    ,mgrid   INT NULL
    ,lvl     INT NOT NULL
)
AS
BEGIN
  WITH Employees_Subtree(empid, empname, mgrid, lvl)
  AS
  ( 
    -- Anchor Member (AM)
    SELECT empid, empname, mgrid, 0
    FROM Employees
    WHERE empid = @empid

    UNION all
    
    -- Recursive Member (RM)
    SELECT e.empid, e.empname, e.mgrid, es.lvl+1
    FROM Employees AS e
      JOIN Employees_Subtree AS es
        ON e.mgrid = es.empid
  )
  INSERT INTO @TREE
    SELECT * FROM Employees_Subtree;

  RETURN
END
GO

--To return all of the subordinates in all levels for the manager of each department, use the following query.

SELECT D.deptid, D.deptname, D.deptmgrid
    ,ST.empid, ST.empname, ST.mgrid
FROM Departments AS D
    CROSS APPLY fn_getsubtree(D.deptmgrid) AS ST;

--Here is the result set.

--deptid      deptname   deptmgrid   empid       empname    mgrid       lvl
------------- ---------- ----------- ----------- ---------- ----------- ---
--1           HR         2           2           Andrew     1           0
--1           HR         2           5           Steven     2           1
--1           HR         2           6           Michael    2           1
--2           Marketing  7           7           Robert     3           0
--2           Marketing  7           11          David      7           1
--2           Marketing  7           12          Ron        7           1
--2           Marketing  7           13          Dan        7           1
--2           Marketing  7           14          James      11          2
--3           Finance    8           8           Laura      3           0
--4           R&amp;D        9           9           Ann        3           0
--5           Training   4           4           Margaret   1           0
--5           Training   4           10          Ina        4           1

--Notice that each row from the Departments table is duplicated as many times as there are rows returned from fn_getsubtree for the department's manager.

--Also, the Gardening department does not appear in the results. Because this department has no manager, 
--fn_getsubtree returned an empty set for it. By using OUTER APPLY, the Gardening department will also appear in the result set, 
--with null values in the deptmgrid field, as well as in the fields returned by fn_getsubtree.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CrossApply</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INNER_JOIN_same_as_CROSS_APPLY_Example_with_DATA</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CrossApply</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INNER_JOIN_same_as_CROSS_APPLY_Example_with_DATA</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>use JUNK
go 

IF OBJECT_ID('dbo.Company') IS NOT NULL
    DROP TABLE dbo.Company

go

IF OBJECT_ID('dbo.Person') IS NOT NULL
    DROP TABLE dbo.Person

go

create table Company (
    companyId int identity(1,1)
,   companyName varchar(100)
,   zipcode varchar(10) 
,   constraint PK_Company primary key (companyId)
)
GO

create table Person (
    personId int identity(1,1)
,   personName varchar(100)
,   companyId int
,   constraint FK_Person_CompanyId foreign key (companyId) references dbo.Company(companyId)
,   constraint PK_Person primary key (personId)
)
GO

insert Company
select 'ABC Company', '19808' union
select 'XYZ Company', '08534' union
select '123 Company', '10016'


insert Person
select 'Alan', 1 union
select 'Bobby', 1 union
select 'Chris', 1 union
select 'Xavier', 2 union
select 'Yoshi', 2 union
select 'Zambrano', 2 union
select 'Player 1', 3 union
select 'Player 2', 3 union
select 'Player 3', 3 


/* using CROSS APPLY */
select *
from 
	Person p
	cross apply 
	(
		select *
		from Company c
		where p.companyid = c.companyId
	) Czip

/* the equivalent query using INNER JOIN */
select *
from 
		Person p
		inner join 
		Company c 
		on p.companyid = c.companyId</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CrossApply</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Similar_to_INNER_and_OUTER_JOIN</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CrossApply</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Similar_to_INNER_and_OUTER_JOIN</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--From: http://www.mssqltips.com/sqlservertip/1958/sql-server-cross-apply-and-outer-apply/




USE [tempdb]
GO
IF EXISTS (SELECT * FROM sys.objects WHERE OBJECT_ID = OBJECT_ID(N'[Employee]') AND type IN (N'U'))
	BEGIN
	   DROP TABLE [Employee]
	END
GO
IF EXISTS (SELECT * FROM sys.objects WHERE OBJECT_ID = OBJECT_ID(N'[Department]') AND type IN (N'U'))
	BEGIN
	   DROP TABLE [Department]
	END
	
CREATE TABLE [Department](
   [DepartmentID] [int] NOT NULL PRIMARY KEY,
   [Name] VARCHAR(250) NOT NULL,
) ON [PRIMARY]
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (1, N'Engineering')
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (2, N'Administration')
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (3, N'Sales')
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (4, N'Marketing')
	INSERT [Department] ([DepartmentID], [Name]) 
	VALUES (5, N'Finance')
GO

CREATE TABLE [Employee](
   [EmployeeID] [int] NOT NULL PRIMARY KEY,
   [FirstName] VARCHAR(250) NOT NULL,
   [LastName] VARCHAR(250) NOT NULL,
   [DepartmentID] [int] NOT NULL REFERENCES [Department](DepartmentID),
) ON [PRIMARY]
GO
	INSERT [Employee] ([EmployeeID], [FirstName], [LastName], [DepartmentID])
	VALUES (1, N'Orlando', N'Gee', 1 )
	INSERT [Employee] ([EmployeeID], [FirstName], [LastName], [DepartmentID])
	VALUES (2, N'Keith', N'Harris', 2 )
	INSERT [Employee] ([EmployeeID], [FirstName], [LastName], [DepartmentID])
	VALUES (3, N'Donna', N'Carreras', 3 )
	INSERT [Employee] ([EmployeeID], [FirstName], [LastName], [DepartmentID])
	VALUES (4, N'Janet', N'Gates', 3 ) 
	
--///////////CROSS APPLY similar to: INNER JOIN //////////////////////////////

SELECT * 
FROM 
	Department D
	CROSS APPLY
	   (
		   SELECT * 
		   FROM Employee E
		   WHERE E.DepartmentID = D.DepartmentID
	   ) A
GO
SELECT * 
FROM 
	Department D
	INNER JOIN 
	Employee E 
	ON D.DepartmentID = E.DepartmentID
GO

--///////////OUTER APPLY similar to: LEFT OUTER JOIN //////////////////////////////

SELECT * 
FROM 
	Department D
	OUTER APPLY
	   (
		   SELECT * FROM Employee E
		   WHERE E.DepartmentID = D.DepartmentID
	   ) A
GO

SELECT * 
FROM 
	Department D
	LEFT OUTER JOIN 
	Employee E ON D.DepartmentID = E.DepartmentID
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CSV_Export</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>some_ideas</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CSV_Export</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>some_ideas</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://stackoverflow.com/questions/12567410/i-need-best-practice-in-t-sql-export-data-to-csv-with-header

--Using Microsoft.Jet.OLEDB.4.0, like this:

INSERT INTO OPENROWSET('Microsoft.Jet.OLEDB.4.0',
                       'Text;Database=C:\Temp\;HDR=Yes;',
                       'SELECT * FROM test.csv')
            (object_id, name)
SELECT object_id, name
  FROM sys.tables;
  
  
-----------------------
---You could use a UNION to create a header row, like this:

SELECT 'object_id', 'name'

UNION ALL

SELECT object_id, name
FROM sys.tables  

------------------------------------------------------
EXEC xp_cmdshell 'SQLCMD -S . -d MsVehicleReg2 -Q "SELECT * FROM tempViolationInfo" -s "," -o "O:\result.csv"'

--------------------------------------------------------
-- need to have the Microsoft.ACE.OLEDB.12.0 provider available
--The Jet 4.0 provider will work, too, but it's ancient, so I used this one instead.
--The .CSV file will have to exist already. 
--	If you're using headers (HDR=YES), make sure the first line of the .CSV file is a delimited list of all the fields.

INSERT INTO OPENROWSET('Microsoft.ACE.OLEDB.12.0','Text;Database=D:\;HDR=YES;FMT=Delimited','SELECT * FROM [FileName.csv]')
SELECT Field1, Field2, Field3 FROM DatabaseName

---------------------------------------------------------------------
https://www.codeproject.com/Questions/546777/HowplusToplusExportplusDataplusToplustheplus-csvpl

declare @sql varchar(8000)
select @sql = 'bcp "select * from EmailVarification..tblTransaction" queryout c:\bcp\Tom.xls -c -t, -T -S' + @@servername
exec master..xp_cmdshell @sql

--in this query EmailVarification is DB name and tblTransaction is table name.
--for execute this query you have to set path for write file.
--currently in this query you have to create a "bcp" folder in "C:\ "Drive .</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CSV_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Split_CSV_Put_into_Table_variable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CSV_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Split_CSV_Put_into_Table_variable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
--here is the code I use to split a comma-delimited input variable into individual values, and put it into a table variable.





-- Create temporary table to parse the list of accounting cycles.
DECLARE @tblAccountingCycles table
(
    AccountingCycle varchar(10)
)

DECLARE @vchAccountingCycle varchar(10)
DECLARE @intPosition int

SET @vchAccountingCycleIDs = LTRIM(RTRIM(@vchAccountingCycleIDs)) + ','
SET @intPosition = CHARINDEX(',', @vchAccountingCycleIDs, 1)

IF REPLACE(@vchAccountingCycleIDs, ',', '') &lt;&gt; ''
BEGIN
    WHILE @intPosition &gt; 0
    BEGIN
        SET @vchAccountingCycle = LTRIM(RTRIM(LEFT(@vchAccountingCycleIDs, @intPosition - 1)))
        IF @vchAccountingCycle &lt;&gt; ''
        BEGIN
            INSERT INTO @tblAccountingCycles (AccountingCycle) VALUES (@vchAccountingCycle)
        END
        SET @vchAccountingCycleIDs = RIGHT(@vchAccountingCycleIDs, LEN(@vchAccountingCycleIDs) - @intPosition)
        SET @intPosition = CHARINDEX(',', @vchAccountingCycleIDs, 1)
    END
END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CTE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CTE_and_IF</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CTE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CTE_and_IF</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
--FROM: http://www.sqlservercentral.com/Forums/Topic599836-338-1.aspx#bm599936

--The issue that I have is that I can create a temporary table in the beginning of a stored procedure
-- and then use that temporary table anywhere in the procedure whereas a CTE must be followed by a
--  Select, Insert, Update or Delete.

--For instance, if my stored procedure followed the following steps:

--Step #1 - Create Temporary Table
--Step #2 - If @SomeParameter is Null Then Do Something, Otherwise Do Something Else

--won't work if Step #1 Creates a CTE instead of a Temporary table.

--That is why I stated that the CTE seems to be limited. I guess that is a limitation that 
--I will have to accept in order to get the other benefits of the CTE.


--You're right. CTEs are limited in that they are meant to be a one-time view that gets used 
--immediately and then destroyed. To do what you intend, you may have to do the 
--IF check first and then have two different CTEs for each outcome. In this case,
-- you're probably better off using a temp table or a table variable.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CTE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CTE_ReadMe</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CTE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CTE_ReadMe</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
Common Table Expressions 

--After CTE there should be a SELECT and DML statements only. You can use SELECT/INSERT/UPDATE/DELETE only.

--If you need to have condition then you have to use alternate way like Table variable.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CTE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>TableVariable_with_PrimaryKey_created_from_CTE_without_PrimaryKey</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CTE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>TableVariable_with_PrimaryKey_created_from_CTE_without_PrimaryKey</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--TableVariable_with_PrimaryKey_created_from_CTE_without_PrimaryKey

--example uses the list of Triggers


DECLARE @tmp table (Id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, Trigger_Name nvarchar(Max))
--DECLARE @CustomerId INT 
DECLARE @Id INT = 0

;WITH CTE_Triggers(Trigger_Name)
AS
(
	SELECT 
		 sysobjects.name AS Trigger_Name 
	FROM sysobjects 
	WHERE sysobjects.type = 'TR'
)

INSERT INTO @tmp SELECT Trigger_Name FROM CTE_Triggers

Select * from @tmp


///////--OUTPUT

Id	Trigger_Name
1	trg_Astec_Internal_Job_Insert
2	trg_Astec_RetailJob_Insert
3	trg_Astec_Hauler_Insert
4	trg_HCSS_Insert_EmployeeTypes
5	trg_Astec_RetailCustomer_Insert
6	trg_HCSS_Update_EmployeeTypes
7	trg_Astec_Vendor_Insert
8	trg_B2W_Insert_Equipment
9	trg_B2W_Insert_Vendor
10	trg_HCSS_Insert_Equipment
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CURSOR</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>about_CURSOR</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CURSOR</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>about_CURSOR</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_CURSOR


https://www.mssqltips.com/sqlservertip/1599/sql-server-cursor-example/

--How to Create a SQL Server Cursor
--Creating a SQL Server cursor is a consistent process, 
--	so once you learn the steps you are easily able to duplicate them with various sets of logic to loop through data. 
--	Let's walk through the steps:

--First, you declare your variables that you need in the logic.
--Second you declare cursor with a specific name that you will use throughout the logic. 
--	This is immediately followed by opening the cursor.
--Third, you fetch a record from cursor to begin the data processing.
--Fourth, is the data process that is unique to each set of logic. 
--	This could be inserting, updating, deleting, etc. for each row of data that was fetched. 
--	This is the most important set of logic during this process that is performed on each row.
--Fifth, you fetch the next record from cursor as you did in step 3 
--	and then step 4 is repeated again by processing the selected data.
--Sixth, once all of the data has been processed, then you close cursor.
--As a final and important step, you need to deallocate the cursor 
--	to release all of the internal resources SQL Server is holdin

--Here is an example cursor from tip Simple script to backup all SQL Server databases where backups are issued in a serial manner:

DECLARE @name VARCHAR(50) -- database name 
DECLARE @path VARCHAR(256) -- path for backup files 
DECLARE @fileName VARCHAR(256) -- filename for backup 
DECLARE @fileDate VARCHAR(20) -- used for file name 

SET @path = 'C:\Backup\' 

SELECT @fileDate = CONVERT(VARCHAR(20),GETDATE(),112) 

DECLARE db_cursor CURSOR FOR 
SELECT name 
FROM MASTER.dbo.sysdatabases 
WHERE name NOT IN ('master','model','msdb','tempdb') 

--===================================================================== 
OPEN db_cursor 

FETCH NEXT FROM db_cursor INTO @name  

WHILE @@FETCH_STATUS = 0  
BEGIN 
	 --------------------------------------------------------------- 
      SET @fileName = @path + @name + '_' + @fileDate + '.BAK' 
      BACKUP DATABASE @name TO DISK = @fileName 

      FETCH NEXT FROM db_cursor INTO @name 
	 ---------------------------------------------------------------
END 

CLOSE db_cursor  
DEALLOCATE db_cursor 
--=====================================================================

--SQL Server Cursor Components
--Based on the example above, cursors include these components:

--DECLARE 
--	- Declare variables used in the code block
--SET\SELECT
--	- Initialize the variables to a specific value
--DECLARE CURSOR  
--	- Populate the cursor with values that will be evaluated
--	NOTE - There are an equal number of variables in the DECLARE CURSOR FOR statement as there are in the SELECT statement.  
--	This could be 1 or many variables and associated columns.
--OPEN  
--	- Open the cursor to begin data processing
--FETCH NEXT 
--	 - Assign the specific values from the cursor to the variables
--		NOTE - This logic is used for the initial population before the WHILE statement 
--		and then again during each loop in the process as a portion of the WHILE statement
--WHILE sta
--	- Condition to begin and continue data processing
--BEGIN...END st
--	 - Start and end of the code block
--		NOTE - Based on the data processing multiple BEGIN...END statements can be used
--Data processing 
--	- In this example, this logic is to backup a database to a specific path and file name, but this could be just about any DML or administrative logic
--CLOSE statement 
--	- Releases the current data and associated locks, but permits the cursor to be re-opened
--DEALLOCATE statement 
--	- Destroys the cursor</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>CURSOR</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Cursor_in_a_TRIGGER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>CURSOR</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Cursor_in_a_TRIGGER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE [barriere]
GO

/****** Object:  Trigger [dbo].[QueueMail]    Script Date: 02/26/2016 14:43:23 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TRIGGER [dbo].[QueueMail]
ON [dbo].[BC_ReportMailQueue]
FOR INSERT
AS

SET NOCOUNT ON

---if @@ROWCOUNT=0 RETURN

Declare T1 CURSOR FOR Select * From Inserted
Declare 
	@mySequence as int,
	@myRecipients as varchar(256),
	@mySubject as varchar(256),
	@myMessage as varchar(1024),
	@myUserID as varchar(15)
Declare @ErrMessage as varchar(2048)

OPEN T1

FETCH NEXT FROM T1 INTO @mySequence, @myRecipients, @mySubject, @myMessage, @myUserID
WHILE (@@FETCH_STATUS &lt;&gt; -1)
   BEGIN
	if (@@FETCH_STATUS &lt;&gt; -2)
	   BEGIN
		EXEC msdb.dbo.sp_send_dbmail @recipients=@myRecipients, @body=@myMessage, @subject=@mySubject, @profile_name='SQLUSER'
		if @@ERROR &lt;&gt; 0 
			begin
				Set @ErrMessage = 'Report Mail Queue Message not sent due to SQL Error: ' + @@ERROR + '. ' + char(13) +
						'User: ' + @myUserID + ', Recepient(s): ' + @myRecipients + char(13) +
						'Subject: ' + @mySubject
				EXEC [Master].[dbo].xp_logevent 70000, @ErrMessage, error
			end
	   END
	FETCH NEXT FROM T1 INTO @mySequence, @myRecipients, @mySubject, @myMessage, @myUserID
   END

CLOSE T1
DEALLOCATE T1




GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Database</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Build_SQLCMD_script_to_Move_Databases</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Database</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Build_SQLCMD_script_to_Move_Databases</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code> --From Dewey Hebert
 /* Build Script to Move Databses for 2016 Explorer Conversion */
 
 DECLARE @DBTables TABLE
    (
      id BIGINT IDENTITY(1, 1)
                PRIMARY KEY ,
      DatabaseName VARCHAR(500) ,
      NameofFile VARCHAR(500) ,
      PhysicalFile VARCHAR(500) ,
      FileType VARCHAR(50)
    );
 
 INSERT INTO @DBTables
        ( DatabaseName ,
          NameofFile ,
          PhysicalFile ,
          FileType
        )
        SELECT  B.name AS DatabaseName ,
                CAST(A.name AS VARCHAR(500)) AS NameofFile ,
                CAST(A.physical_name AS VARCHAR(100)) AS PhysicalFile ,
                CASE WHEN A.type_desc = 'ROWS' THEN 'DataFile'
                     WHEN A.type_desc = 'LOG' THEN 'LogFile'
                     ELSE ''
                END AS FileType
        FROM    sys.master_files A
                JOIN master.sys.databases B ON A.database_id = B.database_id
        WHERE   ( A.type_desc IN ( 'LOG', 'ROWS' ) )
                AND B.name NOT IN ( 'master', 'model', 'tempdb', 'msdb', 'barriere', 'Barriere_sandbox', 'ReportServer',
                                    'ReportServerTempDB' );

DECLARE @id_mdf as BIGINT ,
	  @DatabaseName_mdf AS VARCHAR(500),
      @NameofFile_mdf AS VARCHAR(500) ,
      @PhysicalFile_mdf AS VARCHAR(500) ,
      @FileType_mdf AS VARCHAR(50)

DECLARE @id_ldf as BIGINT ,
	  @DatabaseName_ldf AS VARCHAR(500),
      @NameofFile_ldf AS VARCHAR(500) ,
      @PhysicalFile_ldf AS VARCHAR(500) ,
      @FileType_ldf AS VARCHAR(50)

 DECLARE T1 CURSOR	FOR SELECT * FROM @DBTables WHERE FileType = 'DataFile' ORDER BY id
 OPEN	T1

 FETCH NEXT FROM T1 INTO @id_mdf, @DatabaseName_mdf, @NameofFile_mdf, @PhysicalFile_mdf, @FileType_mdf
 WHILE @@FETCH_STATUS = 0
 BEGIN
	SELECT @NameofFile_ldf = l.NameofFile,
		   @PhysicalFile_ldf = l.PhysicalFile,
		   @DatabaseName_ldf = l.DatabaseName 
	FROM @DBTables AS l 
	WHERE l.DatabaseName = @DatabaseName_mdf AND l.FileType = 'LogFile'

	--Detach Databases
	PRINT 'SQLCMD -Q "sp_detach_db @dbname = ' + @DatabaseName_mdf + '" -S "BCC-EXPLORERdb"'
	PRINT 'SQLCMD -Q "sp_detach_db @dbname = ' + @DatabaseName_mdf + '" -S "BCC-EXPLORER3db" -U xplr -P Expl0r3r'

	--Copy mdf and ldf files. Overwite if they exist
	PRINT 'xCOPY "' + REPLACE(@PhysicalFile_mdf,'D:\','\\bcc-explorerdb\d$\') +  '" "\\bcc-explorer3db\d$\Barriere\MSSQL\data\' + RTRIM(@DatabaseName_mdf) + '.mdf"' + ' /f /v /y'
	PRINT 'xCOPY "' + REPLACE(@PhysicalFile_ldf,'E:\','\\bcc-explorerdb\e$\') + '" "\\bcc-explorer3db\e$\Barriere\SQL_Logs\' + RTRIM(@DatabaseName_ldf) + '.ldf"' + ' /f /v /y'
	
	--Attach the Database 
	PRINT 'SQLCMD -Q "CREATE DATABASE ' + @DatabaseName_mdf + ' ON (FILENAME = ''D:\Barriere\MSSQL\data\' + RTRIM(@DatabaseName_mdf) + '.mdf''), (FILENAME = ''E:\Barriere\SQL_Logs\' + RTRIM(@DatabaseName_mdf) + '.ldf'') FOR ATTACH" -S "BCC-EXPLORER3db" -U xplr -P Expl0r3r'

	PRINT ''
    PRINT '===================================================================================='
	PRINT ''

	FETCH NEXT FROM T1 INTO @id_mdf, @DatabaseName_mdf, @NameofFile_mdf, @PhysicalFile_mdf, @FileType_mdf
 END

 CLOSE T1
 DEALLOCATE T1</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Databases</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>LIST_of_all_FIELDS_in_all_TABLES_of_database</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Databases</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>LIST_of_all_FIELDS_in_all_TABLES_of_database</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--P_0017_TASK_006_RES_04_STEP_3_LIST_of_all_FIELDS_in_all_TABLES_of_database_INSERT_INTO_T210_v3.sql



use edwCollections
go
DECLARE @sDatabase nvarchar(25)	
SELECT @sDatabase = 'edwCollections'

DECLARE @dataAcquiredDateTime as DateTime = getdate()	

--IF OBJECT_ID('riskmngt.reporting.gg_junk') IS NOT NULL
--    DROP TABLE riskmngt.reporting.gg_junk



--INSERT INTO [RiskMngt].[Reporting].[T210_Columns_for_Tables_in_Databases](	[DatabaseName]
--      ,[DataAcquiredDateTime]
--      ,[Table_Name]
--      ,[Column_Name]
--      ,[Data_Type]
--      ,[Size]
--      ,[Precision_Scale]
--      ,[flag_Current]
--      ,[schemaName])
	
 SELECT
	@sDatabase AS [DatabaseName]
	,@dataAcquiredDateTime AS [DataAcquiredDateTime]
	,T.name AS [Table_Name]
	,C.name AS [Column_Name]
	,P.name AS [Data_Type]
	,P.max_length AS [Size]
	,CAST(P.precision AS VARCHAR) + '/' + CAST(P.scale AS VARCHAR) AS [Precision_Scale]
	,1 AS [flag_Current]
	------------------------------
	,SCHEMA_NAME(T.schema_id) AS [schemaName]


--INTO riskmngt.reporting.gg_junk
FROM   
		sys.objects AS T
		JOIN 
		sys.columns AS C 
		ON T.object_id = C.object_id
		
		JOIN 
		sys.types AS P 
		ON 
			C.system_type_id = P.system_type_id
			and
			C.user_type_id = P.user_type_id		



WHERE  T.type_desc = 'USER_TABLE';
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Databases</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>LIST_of_all_INDEXES_in_all_TABLES_of_database</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Databases</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>LIST_of_all_INDEXES_in_all_TABLES_of_database</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--P_0017_TASK_006_RES_06_STEP_2_LIST_of_all_INDEXES_in_all_TABLES_of_database_INSERT_INTO_T211.sql



use DL4
go
DECLARE @sDatabase nvarchar(25)	
SELECT @sDatabase = 'DL4'

DECLARE @dataAcquiredDateTime as DateTime = getdate()	



--INSERT INTO [RiskMngt].[Reporting].[T211_INDEXES_in_all_TABLES_of_Database]
select 
		@sDatabase as DatabaseName,
		@dataAcquiredDateTime as DataAcquiredDateTime, 


	i.[name] as index_name,
    substring(column_names, 1, len(column_names)-1) as [columns],
    case when i.[type] = 1 then 'Clustered index'
        when i.[type] = 2 then 'Nonclustered unique index'
        when i.[type] = 3 then 'XML index'
        when i.[type] = 4 then 'Spatial index'
        when i.[type] = 5 then 'Clustered columnstore index'
        when i.[type] = 6 then 'Nonclustered columnstore index'
        when i.[type] = 7 then 'Nonclustered hash index'
        end as index_type,
    case when i.is_unique = 1 then 'Unique'
        else 'Not unique' end as [unique],
    schema_name(t.schema_id) as schemaName,
	 t.[name] as table_or_view_Name, 
    case when t.[type] = 'U' then 'Table'
        when t.[type] = 'V' then 'View'
        end as [object_type],


		1 as [flag_Current]
from sys.objects t
    inner join sys.indexes i
        on t.object_id = i.object_id
    cross apply (select col.[name] + ', '
                    from sys.index_columns ic
                        inner join sys.columns col
                            on ic.object_id = col.object_id
                            and ic.column_id = col.column_id
                    where ic.object_id = t.object_id
                        and ic.index_id = i.index_id
                            order by index_column_id
                            for xml path ('') ) D (column_names)
where t.is_ms_shipped &lt;&gt; 1
and index_id &gt; 0
order by schema_name(t.schema_id) + '.' + t.[name]
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Databases</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>LIST_of_all_SCHEMA_and_TABLES_of_database</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Databases</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>LIST_of_all_SCHEMA_and_TABLES_of_database</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--P_0017_TASK_006_RES_05_STEP_3_LIST_of_all_SCHEMA_and_TABLES_of_database_INSERT_INTO_T212.sql



use edwCollections
go
DECLARE @sDatabase nvarchar(25)	
SELECT @sDatabase = 'edwCollections'

DECLARE @dataAcquiredDateTime as DateTime = getdate()	

--IF OBJECT_ID('riskmngt.reporting.gg_junk') IS NOT NULL
--    DROP TABLE riskmngt.reporting.gg_junk



--INSERT INTO [RiskMngt].[Reporting].[T212_ListOfTablesAndTheirSCHEMAS_of_Database]
SELECT
	@sDatabase as DatabaseName
	,@dataAcquiredDateTime as DataAcquiredDateTime 
	,SCHEMA_NAME(schema_id) as schemaName
	, st.name as tableName
	, 1 as [flag_Current]
--INTO riskmngt.reporting.gg_junk
FROM sys.tables st
ORDER BY SCHEMA_NAME(schema_id), st.name
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DATES</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Create_Datetime_fields_in_Table_and_Select_Null_Dates</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DATES</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Create_Datetime_fields_in_Table_and_Select_Null_Dates</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>/****** Object:  Table [dbo].[DateTest]    Script Date: 09/26/2008 10:44:21 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[DateTest](
    [Date1] [datetime] NULL,
    [Date2] [datetime] NOT NULL
) ON [PRIMARY]

GO
Insert into DateTest (Date1,Date2) VALUES (NULL,'1-Jan-2008')
Insert into DateTest (Date1,Date2) VALUES ('1-Jan-2008','1-Jan-2008')
Go
SELECT * FROM DateTest WHERE Date1 is not NULL
GO
SELECT * FROM DateTest WHERE Date2 is not NULL</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DATES</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Format_DateTime</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DATES</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Format_DateTime</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://anubhavg.wordpress.com/2009/06/11/how-to-format-datetime-date-in-sql-server-2005/

SELECT convert(varchar, getdate(), 100) — mon dd yyyy hh:mmAM (or PM)
                                        — Oct  2 2008 11:01AM          
SELECT convert(varchar, getdate(), 101) — mm/dd/yyyy – 10/02/2008                  
SELECT convert(varchar, getdate(), 102) — yyyy.mm.dd – 2008.10.02           
SELECT convert(varchar, getdate(), 103) — dd/mm/yyyy
SELECT convert(varchar, getdate(), 104) — dd.mm.yyyy
SELECT convert(varchar, getdate(), 105) — dd-mm-yyyy
SELECT convert(varchar, getdate(), 106) — dd mon yyyy
SELECT convert(varchar, getdate(), 107) — mon dd, yyyy
SELECT convert(varchar, getdate(), 108) — hh:mm:ss
SELECT convert(varchar, getdate(), 109) — mon dd yyyy hh:mm:ss:mmmAM (or PM)
                                        — Oct  2 2008 11:02:44:013AM   
SELECT convert(varchar, getdate(), 110) — mm-dd-yyyy
SELECT convert(varchar, getdate(), 111) — yyyy/mm/dd
SELECT convert(varchar, getdate(), 112) — yyyymmdd
SELECT convert(varchar, getdate(), 113) — dd mon yyyy hh:mm:ss:mmm
                                        — 02 Oct 2008 11:02:07:577     
SELECT convert(varchar, getdate(), 114) — hh:mm:ss:mmm(24h)
SELECT convert(varchar, getdate(), 120) — yyyy-mm-dd hh:mm:ss(24h)
SELECT convert(varchar, getdate(), 121) — yyyy-mm-dd hh:mm:ss.mmm
SELECT convert(varchar, getdate(), 126) — yyyy-mm-ddThh:mm:ss.mmm
                                        — 2008-10-02T10:52:47.513
— SQL create different date styles with t-sql string functions
SELECT replace(convert(varchar, getdate(), 111), ‘/’, ‘ ‘) — yyyy mm dd
SELECT convert(varchar(7), getdate(), 126)                 — yyyy-mm
SELECT right(convert(varchar, getdate(), 106), 8)          — mon yyyy
————
— SQL Server date formatting function – convert datetime to string
————
— SQL datetime functions
— SQL Server date formats
— T-SQL convert dates
— Formatting dates sql server
CREATE FUNCTION dbo.fnFormatDate (@Datetime DATETIME, @FormatMask VARCHAR(32))
RETURNS VARCHAR(32)
AS
BEGIN
    DECLARE @StringDate VARCHAR(32)
    SET @StringDate = @FormatMask
    IF (CHARINDEX (‘YYYY’,@StringDate) &gt; 0)
       SET @StringDate = REPLACE(@StringDate, ‘YYYY’,
                         DATENAME(YY, @Datetime))
    IF (CHARINDEX (‘YY’,@StringDate) &gt; 0)
       SET @StringDate = REPLACE(@StringDate, ‘YY’,
                         RIGHT(DATENAME(YY, @Datetime),2))
    IF (CHARINDEX (‘Month’,@StringDate) &gt; 0)
       SET @StringDate = REPLACE(@StringDate, ‘Month’,
                         DATENAME(MM, @Datetime))
    IF (CHARINDEX (‘MON’,@StringDate COLLATE SQL_Latin1_General_CP1_CS_AS)&gt;0)
       SET @StringDate = REPLACE(@StringDate, ‘MON’,
                         LEFT(UPPER(DATENAME(MM, @Datetime)),3))
    IF (CHARINDEX (‘Mon’,@StringDate) &gt; 0)
       SET @StringDate = REPLACE(@StringDate, ‘Mon’,
                                     LEFT(DATENAME(MM, @Datetime),3))
    IF (CHARINDEX (‘MM’,@StringDate) &gt; 0)
       SET @StringDate = REPLACE(@StringDate, ‘MM’,
                  RIGHT(‘0’+CONVERT(VARCHAR,DATEPART(MM, @Datetime)),2))
    IF (CHARINDEX (‘M’,@StringDate) &gt; 0)
       SET @StringDate = REPLACE(@StringDate, ‘M’,
                         CONVERT(VARCHAR,DATEPART(MM, @Datetime)))
    IF (CHARINDEX (‘DD’,@StringDate) &gt; 0)
       SET @StringDate = REPLACE(@StringDate, ‘DD’,
                         RIGHT(‘0’+DATENAME(DD, @Datetime),2))
    IF (CHARINDEX (‘D’,@StringDate) &gt; 0)
       SET @StringDate = REPLACE(@StringDate, ‘D’,
                                     DATENAME(DD, @Datetime))   
RETURN @StringDate
END
GO
 
— Microsoft SQL Server date format function test
— MSSQL formatting dates
SELECT dbo.fnFormatDate (getdate(), ‘MM/DD/YYYY’)           — 01/03/2012
SELECT dbo.fnFormatDate (getdate(), ‘DD/MM/YYYY’)           — 03/01/2012
SELECT dbo.fnFormatDate (getdate(), ‘M/DD/YYYY’)            — 1/03/2012
SELECT dbo.fnFormatDate (getdate(), ‘M/D/YYYY’)             — 1/3/2012
SELECT dbo.fnFormatDate (getdate(), ‘M/D/YY’)               — 1/3/12
SELECT dbo.fnFormatDate (getdate(), ‘MM/DD/YY’)             — 01/03/12
SELECT dbo.fnFormatDate (getdate(), ‘MON DD, YYYY’)         — JAN 03, 2012
SELECT dbo.fnFormatDate (getdate(), ‘Mon DD, YYYY’)         — Jan 03, 2012
SELECT dbo.fnFormatDate (getdate(), ‘Month DD, YYYY’)       — January 03, 2012
SELECT dbo.fnFormatDate (getdate(), ‘YYYY/MM/DD’)           — 2012/01/03
SELECT dbo.fnFormatDate (getdate(), ‘YYYYMMDD’)             — 20120103
SELECT dbo.fnFormatDate (getdate(), ‘YYYY-MM-DD’)           — 2012-01-03
— CURRENT_TIMESTAMP returns current system date and time in standard internal format
SELECT dbo.fnFormatDate (CURRENT_TIMESTAMP,‘YY.MM.DD’)      — 12.01.03
GO
————
 
/***** SELECTED SQL DATE/DATETIME FORMATS WITH NAMES *****/
 
— SQL format datetime
— Default format: Oct 23 2006 10:40AM
SELECT [Default]=CONVERT(varchar,GETDATE(),100)
 
— US-Style format: 10/23/2006
SELECT [US-Style]=CONVERT(char,GETDATE(),101)
 
— ANSI format: 2006.10.23
SELECT [ANSI]=CONVERT(char,CURRENT_TIMESTAMP,102)
 
— UK-Style format: 23/10/2006
SELECT [UK-Style]=CONVERT(char,GETDATE(),103)
 
— German format: 23.10.2006
SELECT [German]=CONVERT(varchar,GETDATE(),104)
 
— ISO format: 20061023
SELECT ISO=CONVERT(varchar,GETDATE(),112)
 
— ISO8601 format: 2008-10-23T19:20:16.003
SELECT [ISO8601]=CONVERT(varchar,GETDATE(),126)
————
 
— SQL Server datetime formats
— Century date format MM/DD/YYYY usage in a query
— Format dates SQL Server 2005
SELECT TOP (1)
      SalesOrderID,
      OrderDate = CONVERT(char(10), OrderDate, 101),
      OrderDateTime = OrderDate
FROM AdventureWorks.Sales.SalesOrderHeader
/* Result
 
SalesOrderID      OrderDate               OrderDateTime
43697             07/01/2001          2001-07-01 00:00:00.000
*/
 
— SQL update datetime column
— SQL datetime DATEADD
UPDATE Production.Product
SET ModifiedDate=DATEADD(dd,1, ModifiedDate)
WHERE ProductID = 1001
 
— MM/DD/YY date format
— Datetime format sql
SELECT TOP (1)
      SalesOrderID,
      OrderDate = CONVERT(varchar(8), OrderDate, 1),
      OrderDateTime = OrderDate
FROM AdventureWorks.Sales.SalesOrderHeader
ORDER BY SalesOrderID desc
/* Result
 
SalesOrderID      OrderDate         OrderDateTime
75123             07/31/04          2004-07-31 00:00:00.000
*/
 
— Combining different style formats for date &amp; time
— Datetime formats
— Datetime formats sql
DECLARE @Date DATETIME
SET @Date = ‘2015-12-22 03:51 PM’
SELECT CONVERT(CHAR(10),@Date,110) + SUBSTRING(CONVERT(varchar,@Date,0),12,8)
— Result: 12-22-2015  3:51PM
 
— Microsoft SQL Server cast datetime to string
SELECT stringDateTime=CAST (getdate() as varchar)
— Result: Dec 29 2012  3:47AM
————
— SQL Server date and time functions overview
————
— SQL Server CURRENT_TIMESTAMP function
— SQL Server datetime functions
— local NYC – EST – Eastern Standard Time zone
— SQL DATEADD function – SQL DATEDIFF function
SELECT CURRENT_TIMESTAMP                        — 2012-01-05 07:02:10.577
— SQL Server DATEADD function
SELECT DATEADD(month,2,‘2012-12-09’)            — 2013-02-09 00:00:00.000
— SQL Server DATEDIFF function
SELECT DATEDIFF(day,‘2012-12-09’,‘2013-02-09’)  — 62
— SQL Server DATENAME function
SELECT DATENAME(month,   ‘2012-12-09’)          — December
SELECT DATENAME(weekday, ‘2012-12-09’)          — Sunday
— SQL Server DATEPART function
SELECT DATEPART(month, ‘2012-12-09’)            — 12
— SQL Server DAY function
SELECT DAY(‘2012-12-09’)                        — 9
— SQL Server GETDATE function
— local NYC – EST – Eastern Standard Time zone
SELECT GETDATE()                                — 2012-01-05 07:02:10.577
— SQL Server GETUTCDATE function
— London – Greenwich Mean Time
SELECT GETUTCDATE()                             — 2012-01-05 12:02:10.577
— SQL Server MONTH function
SELECT MONTH(‘2012-12-09’)                      — 12
— SQL Server YEAR function
SELECT YEAR(‘2012-12-09’)                       — 2012
 
 
————
— T-SQL Date and time function application
— CURRENT_TIMESTAMP and getdate() are the same in T-SQL
————
— SQL first day of the month
— SQL first date of the month
— SQL first day of current month – 2012-01-01 00:00:00.000
SELECT DATEADD(dd,0,DATEADD(mm, DATEDIFF(mm,0,CURRENT_TIMESTAMP),0))
— SQL last day of the month
— SQL last date of the month
— SQL last day of current month – 2012-01-31 00:00:00.000
SELECT DATEADD(dd,-1,DATEADD(mm, DATEDIFF(mm,0,CURRENT_TIMESTAMP)+1,0))
— SQL first day of last month
— SQL first day of previous month – 2011-12-01 00:00:00.000
SELECT DATEADD(mm,-1,DATEADD(mm, DATEDIFF(mm,0,CURRENT_TIMESTAMP),0))
— SQL last day of last month
— SQL last day of previous month – 2011-12-31 00:00:00.000
SELECT DATEADD(dd,-1,DATEADD(mm, DATEDIFF(mm,0,DATEADD(MM,-1,GETDATE()))+1,0))
— SQL first day of next month – 2012-02-01 00:00:00.000
SELECT DATEADD(mm,1,DATEADD(mm, DATEDIFF(mm,0,CURRENT_TIMESTAMP),0))
— SQL last day of next month – 2012-02-28 00:00:00.000
SELECT DATEADD(dd,-1,DATEADD(mm, DATEDIFF(mm,0,DATEADD(MM,1,GETDATE()))+1,0))
GO
— SQL first day of a month – 2012-10-01 00:00:00.000
DECLARE @Date datetime; SET @Date = ‘2012-10-23’
SELECT DATEADD(dd,0,DATEADD(mm, DATEDIFF(mm,0,@Date),0))
GO
— SQL last day of a month – 2012-03-31 00:00:00.000
DECLARE @Date datetime; SET @Date = ‘2012-03-15’
SELECT DATEADD(dd,-1,DATEADD(mm, DATEDIFF(mm,0,@Date)+1,0))
GO
— SQL first day of year 
— SQL first day of the year  –  2012-01-01 00:00:00.000
SELECT DATEADD(yy, DATEDIFF(yy,0,CURRENT_TIMESTAMP), 0)
— SQL last day of year  
— SQL last day of the year   – 2012-12-31 00:00:00.000
SELECT DATEADD(yy,1, DATEADD(dd, –1, DATEADD(yy,
                     DATEDIFF(yy,0,CURRENT_TIMESTAMP), 0)))
— SQL last day of last year
— SQL last day of previous year   – 2011-12-31 00:00:00.000
SELECT DATEADD(dd,-1,DATEADD(yy,DATEDIFF(yy,0,CURRENT_TIMESTAMP), 0))
GO
— SQL calculate age in years, months, days
— SQL table-valued function
— SQL user-defined function – UDF
— SQL Server age calculation – date difference
— Format dates SQL Server 2008
USE AdventureWorks2008;
GO
CREATE FUNCTION fnAge  (@BirthDate DATETIME)
RETURNS @Age TABLE(Years  INT,
                   Months INT,
                   Days   INT)
AS
  BEGIN
    DECLARE  @EndDate     DATETIME, @Anniversary DATETIME
    SET @EndDate = Getdate()
    SET @Anniversary = Dateadd(yy,Datediff(yy,@BirthDate,@EndDate),@BirthDate)
    
    INSERT @Age
    SELECT Datediff(yy,@BirthDate,@EndDate) – (CASE
                                                 WHEN @Anniversary &gt; @EndDate THEN 1
                                                 ELSE 0
                                               END), 0, 0
     UPDATE @Age     SET    Months = Month(@EndDate – @Anniversary) – 1
    UPDATE @Age     SET    Days = Day(@EndDate – @Anniversary) – 1
    RETURN
  END
GO
 
— Test table-valued UDF
SELECT * FROM   fnAge(‘1956-10-23’)
SELECT * FROM   dbo.fnAge(‘1956-10-23’)
/* Results
Years       Months      Days
52          4           1
*/
 
———-
— SQL date range between
———-
— SQL between dates
USE AdventureWorks;
— SQL between
SELECT POs=COUNT(*) FROM Purchasing.PurchaseOrderHeader
WHERE OrderDate BETWEEN ‘20040301’ AND ‘20040315’
— Result: 108
 
— BETWEEN operator is equivalent to &gt;=…AND….&lt;=
SELECT POs=COUNT(*) FROM Purchasing.PurchaseOrderHeader
WHERE OrderDate
BETWEEN ‘2004-03-01 00:00:00.000’ AND ‘2004-03-15  00:00:00.000’
/*
Orders with OrderDates
‘2004-03-15  00:00:01.000’  – 1 second after midnight (12:00AM)
‘2004-03-15  00:01:00.000’  – 1 minute after midnight
‘2004-03-15  01:00:00.000’  – 1 hour after midnight
 
are not included in the two queries above.
*/
— To include the entire day of 2004-03-15 use the following two solutions
SELECT POs=COUNT(*) FROM Purchasing.PurchaseOrderHeader
WHERE OrderDate &gt;= ‘20040301’ AND OrderDate &lt; ‘20040316’
 
— SQL between with DATE type (SQL Server 2008)
SELECT POs=COUNT(*) FROM Purchasing.PurchaseOrderHeader
WHERE CONVERT(DATE, OrderDate) BETWEEN ‘20040301’ AND ‘20040315’
———-
— Non-standard format conversion: 2011 December 14
— SQL datetime to string
SELECT [YYYY Month DD] =
CAST(YEAR(GETDATE()) AS VARCHAR(4))+ ‘ ‘+
DATENAME(MM, GETDATE()) + ‘ ‘ +
CAST(DAY(GETDATE()) AS VARCHAR(2))
 
— Converting datetime to YYYYMMDDHHMMSS format: 20121214172638
SELECT replace(convert(varchar, getdate(),111),‘/’,”) +
replace(convert(varchar, getdate(),108),‘:’,”)
 
— Datetime custom format conversion to YYYY_MM_DD
select CurrentDate=rtrim(year(getdate())) + ‘_’ +
right(‘0’ + rtrim(month(getdate())),2) + ‘_’ +
right(‘0’ + rtrim(day(getdate())),2)
 
— Converting seconds to HH:MM:SS format
declare @Seconds int
set @Seconds = 10000
select TimeSpan=right(‘0’ +rtrim(@Seconds / 3600),2) + ‘:’ +
right(‘0’ + rtrim((@Seconds % 3600) / 60),2) + ‘:’ +
right(‘0’ + rtrim(@Seconds % 60),2)
— Result: 02:46:40
 
— Test result
select 2*3600 + 46*60 + 40
— Result: 10000
— Set the time portion of a datetime value to 00:00:00.000
— SQL strip time from date
— SQL strip time from datetime
SELECT CURRENT_TIMESTAMP ,DATEADD(dd, DATEDIFF(dd, 0, CURRENT_TIMESTAMP), 0)
— Results: 2014-01-23 05:35:52.793 2014-01-23 00:00:00.000
/*******
 
VALID DATE RANGES FOR DATE/DATETIME DATA TYPES
 
SMALLDATETIME date range:
January 1, 1900 through June 6, 2079
 
DATETIME date range:
January 1, 1753 through December 31, 9999
 
DATETIME2 date range (SQL Server 2008):
January 1,1 AD through December 31, 9999 AD
 
DATE date range (SQL Server 2008):
January 1, 1 AD through December 31, 9999 AD
 
*******/
— Selecting with CONVERT into different styles
— Note: Only Japan &amp; ISO styles can be used in ORDER BY
SELECT TOP(1)
     Italy  = CONVERT(varchar, OrderDate, 105)
   , USA    = CONVERT(varchar, OrderDate, 110)
   , Japan  = CONVERT(varchar, OrderDate, 111)
   , ISO    = CONVERT(varchar, OrderDate, 112)
FROM AdventureWorks.Purchasing.PurchaseOrderHeader
ORDER BY PurchaseOrderID DESC
/* Results
Italy       USA         Japan       ISO
25-07-2004  07-25-2004  2004/07/25  20040725
*/
— SQL Server convert date to integer
DECLARE @Datetime datetime
SET @Datetime = ‘2012-10-23 10:21:05.345’
SELECT DateAsInteger = CAST (CONVERT(varchar,@Datetime,112) as INT)
— Result: 20121023
 
— SQL Server convert integer to datetime
DECLARE @intDate int
SET @intDate = 20120315
SELECT IntegerToDatetime = CAST(CAST(@intDate as varchar) as datetime)
— Result: 2012-03-15 00:00:00.000
————
— SQL Server CONVERT script applying table INSERT/UPDATE
————
— SQL Server convert date
— Datetime column is converted into date only string column
USE tempdb;
GO
CREATE TABLE sqlConvertDateTime   (
            DatetimeCol datetime,
            DateCol char(8));
INSERT sqlConvertDateTime (DatetimeCol) SELECT GETDATE()
 
UPDATE sqlConvertDateTime
SET DateCol = CONVERT(char(10), DatetimeCol, 112)
SELECT * FROM sqlConvertDateTime
 
— SQL Server convert datetime
— The string date column is converted into datetime column
UPDATE sqlConvertDateTime
SET DatetimeCol = CONVERT(Datetime, DateCol, 112)
SELECT * FROM sqlConvertDateTime
 
— Adding a day to the converted datetime column with DATEADD
UPDATE sqlConvertDateTime
SET DatetimeCol = DATEADD(day, 1, CONVERT(Datetime, DateCol, 112))
SELECT * FROM sqlConvertDateTime
 
— Equivalent formulation
— SQL Server cast datetime
UPDATE sqlConvertDateTime
SET DatetimeCol = DATEADD(dd, 1, CAST(DateCol AS datetime))
SELECT * FROM sqlConvertDateTime
GO
DROP TABLE sqlConvertDateTime
GO
/* First results
DatetimeCol                   DateCol
2014-12-25 16:04:15.373       20141225 */
 
/* Second results:
DatetimeCol                   DateCol
2014-12-25 00:00:00.000       20141225  */
 
/* Third results:
DatetimeCol                   DateCol
2014-12-26 00:00:00.000       20141225  */
————
— SQL month sequence – SQL date sequence generation with table variable
— SQL Server cast string to datetime – SQL Server cast datetime to string
— SQL Server insert default values method
DECLARE @Sequence table (Sequence int identity(1,1))
DECLARE @i int; SET @i = 0
DECLARE @StartDate datetime;
SET @StartDate = CAST(CONVERT(varchar, year(getdate()))+
                 RIGHT(‘0’+convert(varchar,month(getdate())),2) + ’01’ AS DATETIME)
WHILE ( @i &lt; 120)
BEGIN
      INSERT @Sequence DEFAULT VALUES
      SET @i = @i + 1
END
SELECT MonthSequence = CAST(DATEADD(month, Sequence,@StartDate) AS varchar)
FROM @Sequence
GO
/* Partial results:
MonthSequence
Jan  1 2012 12:00AM
Feb  1 2012 12:00AM
Mar  1 2012 12:00AM
Apr  1 2012 12:00AM
*/
————
 
————
— SQL Server Server datetime internal storage
— SQL Server datetime formats
————
— SQL Server datetime to hex
SELECT Now=CURRENT_TIMESTAMP, HexNow=CAST(CURRENT_TIMESTAMP AS BINARY(8))
/* Results
 
Now                     HexNow
2009-01-02 17:35:59.297 0x00009B850122092D
*/
— SQL Server date part – left 4 bytes – Days since 1900-01-01
SELECT Now=DATEADD(DAY, CONVERT(INT, 0x00009B85), ‘19000101’)
GO
— Result: 2009-01-02 00:00:00.000
 
— SQL time part – right 4 bytes – milliseconds since midnight
— 1000/300 is an adjustment factor
— SQL dateadd to Midnight
SELECT Now=DATEADD(MS, (1000.0/300)* CONVERT(BIGINT, 0x0122092D), ‘2009-01-02’)
GO
— Result: 2009-01-02 17:35:59.290
————
————
— String date and datetime date&amp;time columns usage
— SQL Server datetime formats in tables
————
USE tempdb;
SET NOCOUNT ON;
— SQL Server select into table create
SELECT TOP (5)
      FullName=convert(nvarchar(50),FirstName+‘ ‘+LastName),
      BirthDate = CONVERT(char(8), BirthDate,112),
      ModifiedDate = getdate()
INTO Employee
FROM AdventureWorks.HumanResources.Employee e
INNER JOIN AdventureWorks.Person.Contact c
ON c.ContactID = e.ContactID
ORDER BY EmployeeID
GO
— SQL Server alter table
ALTER TABLE Employee ALTER COLUMN FullName nvarchar(50) NOT NULL
GO
ALTER TABLE Employee
ADD CONSTRAINT [PK_Employee] PRIMARY KEY (FullName )
GO
/* Results
 
Table definition for the Employee table
Note: BirthDate is string date (only)
 
CREATE TABLE dbo.Employee(
      FullName nvarchar(50) NOT NULL PRIMARY KEY,
      BirthDate char(8) NULL,
      ModifiedDate datetime NOT NULL
      )
*/
SELECT * FROM Employee ORDER BY FullName
GO
/* Results
FullName                BirthDate   ModifiedDate
Guy Gilbert             19720515    2009-01-03 10:10:19.217
Kevin Brown             19770603    2009-01-03 10:10:19.217
Rob Walters             19650123    2009-01-03 10:10:19.217
Roberto Tamburello      19641213    2009-01-03 10:10:19.217
Thierry D’Hers          19490829    2009-01-03 10:10:19.217
*/
 
— SQL Server age
SELECT FullName, Age = DATEDIFF(YEAR, BirthDate, GETDATE()),
       RowMaintenanceDate = CAST (ModifiedDate AS varchar)
FROM Employee ORDER BY FullName
GO
/* Results
FullName                Age   RowMaintenanceDate
Guy Gilbert             37    Jan  3 2009 10:10AM
Kevin Brown             32    Jan  3 2009 10:10AM
Rob Walters             44    Jan  3 2009 10:10AM
Roberto Tamburello      45    Jan  3 2009 10:10AM
Thierry D’Hers          60    Jan  3 2009 10:10AM
*/
 
— SQL Server age of Rob Walters on specific dates
— SQL Server string to datetime implicit conversion with DATEADD
SELECT AGE50DATE = DATEADD(YY, 50, ‘19650123’)
GO
— Result: 2015-01-23 00:00:00.000
 
— SQL Server datetime to string, Italian format for ModifiedDate
— SQL Server string to datetime implicit conversion with DATEDIFF
SELECT FullName,
         AgeDEC31 = DATEDIFF(YEAR, BirthDate, ‘20141231’),
         AgeJAN01 = DATEDIFF(YEAR, BirthDate, ‘20150101’),
         AgeJAN23 = DATEDIFF(YEAR, BirthDate, ‘20150123’),
         AgeJAN24 = DATEDIFF(YEAR, BirthDate, ‘20150124’),
       ModDate = CONVERT(varchar, ModifiedDate, 105)
FROM Employee
WHERE FullName = ‘Rob Walters’
ORDER BY FullName
GO
/* Results
Important Note: age increments on Jan 1 (not as commonly calculated)
 
FullName    AgeDEC31    AgeJAN01    AgeJAN23    AgeJAN24    ModDate
Rob Walters 49          50          50          50          03-01-2009
*/
 
————
— SQL combine integer date &amp; time into datetime
————
— Datetime format sql
— SQL stuff
DECLARE @DateTimeAsINT TABLE ( ID int identity(1,1) primary key, 
   DateAsINT int, 
   TimeAsINT int 
) 
— NOTE: leading zeroes in time is for readability only!  
INSERT @DateTimeAsINT (DateAsINT, TimeAsINT) VALUES (20121023, 235959)  
INSERT @DateTimeAsINT (DateAsINT, TimeAsINT) VALUES (20121023, 010204)  
INSERT @DateTimeAsINT (DateAsINT, TimeAsINT) VALUES (20121023, 002350)
INSERT @DateTimeAsINT (DateAsINT, TimeAsINT) VALUES (20121023, 000244)  
INSERT @DateTimeAsINT (DateAsINT, TimeAsINT) VALUES (20121023, 000050)  
INSERT @DateTimeAsINT (DateAsINT, TimeAsINT) VALUES (20121023, 000006)  
 
SELECT DateAsINT, TimeAsINT,
  CONVERT(datetime, CONVERT(varchar(8), DateAsINT) + ‘ ‘+
  STUFF(STUFF ( RIGHT(REPLICATE(‘0’, 6) + CONVERT(varchar(6), TimeAsINT), 6),
                  3, 0, ‘:’), 6, 0, ‘:’))  AS DateTimeValue
FROM   @DateTimeAsINT 
ORDER BY ID
GO
/* Results
DateAsINT   TimeAsINT   DateTimeValue
20121023    235959      2012-10-23 23:59:59.000
20121023    10204       2012-10-23 01:02:04.000
20121023    2350        2012-10-23 00:23:50.000
20121023    244         2012-10-23 00:02:44.000
20121023    50          2012-10-23 00:00:50.000
20121023    6           2012-10-23 00:00:06.000
*/
————
 
— SQL Server string to datetime, implicit conversion with assignment
UPDATE Employee SET ModifiedDate = ‘20150123’
WHERE FullName = ‘Rob Walters’
GO
SELECT ModifiedDate FROM Employee WHERE FullName = ‘Rob Walters’
GO
— Result: 2015-01-23 00:00:00.000
 
/* SQL string date, assemble string date from datetime parts  */
— SQL Server cast string to datetime – sql convert string date
— SQL Server number to varchar conversion
— SQL Server leading zeroes for month and day
— SQL Server right string function
UPDATE Employee SET BirthDate =
      CONVERT(char(4),YEAR(CAST(‘1965-01-23’ as DATETIME)))+
      RIGHT(‘0’+CONVERT(varchar,MONTH(CAST(‘1965-01-23’ as DATETIME))),2)+
      RIGHT(‘0’+CONVERT(varchar,DAY(CAST(‘1965-01-23’ as DATETIME))),2)
      WHERE FullName = ‘Rob Walters’
GO
SELECT BirthDate FROM Employee WHERE FullName = ‘Rob Walters’
GO
— Result: 19650123
 
— Perform cleanup action
DROP TABLE Employee
— SQL nocount
SET NOCOUNT OFF;
GO
————
————
— sql isdate function
————
USE tempdb;
— sql newid – random sort
SELECT top(3) SalesOrderID,
stringOrderDate = CAST (OrderDate AS varchar)
INTO DateValidation
FROM AdventureWorks.Sales.SalesOrderHeader
ORDER BY NEWID()
GO
SELECT * FROM DateValidation
/* Results
SalesOrderID      stringOrderDate
56720             Oct 26 2003 12:00AM
73737             Jun 25 2004 12:00AM
70573             May 14 2004 12:00AM
*/
— SQL update with top
UPDATE TOP(1) DateValidation
SET stringOrderDate = ‘Apb 29 2004 12:00AM’
GO
— SQL string to datetime fails without validation
SELECT SalesOrderID, OrderDate = CAST (stringOrderDate as datetime)
FROM DateValidation
GO
/* Msg 242, Level 16, State 3, Line 1
The conversion of a varchar data type to a datetime data type resulted in an
out-of-range value.
*/
— sql isdate – filter for valid dates
SELECT SalesOrderID, OrderDate = CAST (stringOrderDate as datetime)
FROM DateValidation
WHERE ISDATE(stringOrderDate) = 1
GO
/* Results
SalesOrderID      OrderDate
73737             2004-06-25 00:00:00.000
70573             2004-05-14 00:00:00.000
*/
— SQL drop table
DROP TABLE DateValidation
Go
 
————
— SELECT between two specified dates – assumption TIME part is 00:00:00.000
————
— SQL datetime between
— SQL select between two dates
SELECT EmployeeID, RateChangeDate
FROM AdventureWorks.HumanResources.EmployeePayHistory
WHERE RateChangeDate &gt;= ‘1997-11-01’ AND 
      RateChangeDate &lt; DATEADD(dd,1,‘1998-01-05’)
GO
/* Results
EmployeeID  RateChangeDate
3           1997-12-12 00:00:00.000
4           1998-01-05 00:00:00.000
*/
 
/* Equivalent to
 
— SQL datetime range
SELECT EmployeeID, RateChangeDate
FROM AdventureWorks.HumanResources.EmployeePayHistory
WHERE RateChangeDate &gt;= ‘1997-11-01 00:00:00’ AND 
      RateChangeDate &lt;  ‘1998-01-06 00:00:00’
GO
*/
————
— SQL datetime language setting
— SQL Nondeterministic function usage – result varies with language settings
SET LANGUAGE  ‘us_english’;  –– Jan 12 2015 12:00AM 
SELECT US = convert(VARCHAR,convert(DATETIME,’01/12/2015′));
SET LANGUAGE  ‘British’;     –– Dec  1 2015 12:00AM 
SELECT UK = convert(VARCHAR,convert(DATETIME,’01/12/2015′));
SET LANGUAGE  ‘German’;      –– Dez  1 2015 12:00AM 
SET LANGUAGE  ‘Deutsch’;     –– Dez  1 2015 12:00AM 
SELECT Germany = convert(VARCHAR,convert(DATETIME,’01/12/2015′));
SET LANGUAGE  ‘French’;      –– déc  1 2015 12:00AM 
SELECT France = convert(VARCHAR,convert(DATETIME,’01/12/2015′));
SET LANGUAGE  ‘Spanish’;     –– Dic  1 2015 12:00AM 
SELECT Spain = convert(VARCHAR,convert(DATETIME,’01/12/2015′));
SET LANGUAGE  ‘Hungarian’;   –– jan 12 2015 12:00AM 
SELECT Hungary = convert(VARCHAR,convert(DATETIME,’01/12/2015′));
SET LANGUAGE  ‘us_english’;
GO
————
————
— Function for Monday dates calculation
————
USE AdventureWorks2008;
GO
— SQL user-defined function
— SQL scalar function – UDF
CREATE FUNCTION fnMondayDate
               (@Year          INT,
                @Month         INT,
                @MondayOrdinal INT)
RETURNS DATETIME
AS
  BEGIN
    DECLARE  @FirstDayOfMonth CHAR(10),
             @SeedDate        CHAR(10)
    
    SET @FirstDayOfMonth = convert(VARCHAR,@Year) + ‘-‘ + convert(VARCHAR,@Month) + ‘-01’
    SET @SeedDate = ‘1900-01-01’
    
    RETURN DATEADD(DD,DATEDIFF(DD,@SeedDate,DATEADD(DD,(@MondayOrdinal * 7) – 1,
                  @FirstDayOfMonth)) / 7 * 7,  @SeedDate)
  END
GO
 
— Test Datetime UDF
— Third Monday in Feb, 2015
SELECT dbo.fnMondayDate(2016,2,3)
— 2015-02-16 00:00:00.000
 
— First Monday of current month
SELECT dbo.fnMondayDate(Year(getdate()),Month(getdate()),1)
— 2009-02-02 00:00:00.000  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DATES</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>GENERATE_Date_Dimension_TABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DATES</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>GENERATE_Date_Dimension_TABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0013_0001_Create_B2W_LIST_DateDimension_TABLE_v2.sql

/*
	************************************************************************************
	NOTE: from: https://www.mssqltips.com/sqlservertip/4054/creating-a-date-dimension-or-calendar-table-in-sql-server/
				This script:
								1] creates the Table [DateDimension] for storing the results
								2] generates the Temp Table #dim, which is then used to store intermediate results
	Uses: 
	Created: 10/12/2016
	By: glenn garson
	************************************************************************************
*/

use B2W_Reports
go

IF OBJECT_ID('dbo.LIST_DateDimension') IS NOT NULL
    DROP TABLE dbo.LIST_DateDimension

go

IF OBJECT_ID('tempdb..#dim') IS NOT NULL
    DROP TABLE #dim

go

--===============================================================================

DECLARE @StartDate DATE = '20100101', @NumberOfYears INT = 7;

--===============================================================================

-- prevent set or regional settings from interfering with 
-- interpretation of dates / literals

SET DATEFIRST 1;			-- Set first day of week to Monday(1) 
SET DATEFORMAT mdy;			--Sets the order of the month, day, and year date parts for interpreting date, smalldatetime, datetime, datetime2 and datetimeoffset character strings
							--  this means that you need to enter the data parms as mm/dd/yyyy
SET LANGUAGE US_ENGLISH;

--===============================================================================

CREATE TABLE dbo.LIST_DateDimension
(
  DateKey             INT         NOT NULL PRIMARY KEY,
  [Date]              DATE        NOT NULL,
  [Day]               TINYINT     NOT NULL,
  DaySuffix           CHAR(2)     NOT NULL,
  [Weekday]           TINYINT     NOT NULL,
  WeekDayName         VARCHAR(10) NOT NULL,
  IsWeekend           BIT         NOT NULL,
  IsHoliday           BIT         NOT NULL,
  HolidayText         VARCHAR(64) SPARSE,
  DOWInMonth          TINYINT     NOT NULL,
  [DayOfYear]         SMALLINT    NOT NULL,
  WeekOfMonth         TINYINT     NOT NULL,
  WeekOfYear          TINYINT     NOT NULL,
  ISOWeekOfYear       TINYINT     NOT NULL,
  [Month]             TINYINT     NOT NULL,
  [MonthName]         VARCHAR(10) NOT NULL,
  [Quarter]           TINYINT     NOT NULL,
  QuarterName         VARCHAR(6)  NOT NULL,
  [Year]              INT         NOT NULL,
  MMYYYY              CHAR(6)     NOT NULL,
  MonthYear           CHAR(7)     NOT NULL,
  FirstDayOfWeek      DATE        NOT NULL,
  FirstDayOfMonth     DATE        NOT NULL,
  LastDayOfWeek       DATE        NOT NULL,
  LastDayOfMonth      DATE        NOT NULL,
  FirstDayOfQuarter   DATE        NOT NULL,
  LastDayOfQuarter    DATE        NOT NULL,
  FirstDayOfYear      DATE        NOT NULL,
  LastDayOfYear       DATE        NOT NULL,
  FirstDayOfNextMonth DATE        NOT NULL,
  FirstDayOfNextYear  DATE        NOT NULL
);




DECLARE @CutoffDate DATE = DATEADD(YEAR, @NumberOfYears, @StartDate);

-- this is just a holding table for intermediate calculations:

CREATE TABLE #dim
(
  [date]       DATE PRIMARY KEY, 
  [day]        AS DATEPART(DAY,      [date]),
  [month]      AS DATEPART(MONTH,    [date]),
  FirstDayOfWeek AS CONVERT(DATE, DATEADD(WEEK, DATEDIFF(wk, 0, [date]), 0)),		--&lt;=== NEW 
  FirstOfMonth AS CONVERT(DATE, DATEADD(MONTH, DATEDIFF(MONTH, 0, [date]), 0)),
  [MonthName]  AS DATENAME(MONTH,    [date]),
  [week]       AS DATEPART(WEEK,     [date]),
  [ISOweek]    AS DATEPART(ISO_WEEK, [date]),
  [DayOfWeek]  AS DATEPART(WEEKDAY,  [date]),
  [quarter]    AS DATEPART(QUARTER,  [date]),
  [year]       AS DATEPART(YEAR,     [date]),
  FirstOfYear  AS CONVERT(DATE, DATEADD(YEAR,  DATEDIFF(YEAR,  0, [date]), 0)),
  YYYYMMDD     AS CONVERT(CHAR(8),   [date], 112),
  MM_slash_DD_slash_YYYY     AS CONVERT(CHAR(10),  [date], 101),
  MM_hyphen_DD_hyphen_YYYY     AS CONVERT(CHAR(10),  [date], 110) 
);

-- use the catalog views to generate as many rows as we need

INSERT #dim([date]) 
SELECT d
FROM
(
  SELECT d = DATEADD(DAY, rn - 1, @StartDate)
  FROM 
  (
    SELECT TOP (DATEDIFF(DAY, @StartDate, @CutoffDate)) 
      rn = ROW_NUMBER() OVER (ORDER BY s1.[object_id])
    FROM sys.all_objects AS s1
    CROSS JOIN sys.all_objects AS s2
    -- on my system this would support &gt; 5 million days
    ORDER BY s1.[object_id]
  ) AS x
) AS y;


--Select * from #dim

INSERT dbo.LIST_DateDimension WITH (TABLOCKX)
SELECT
  DateKey       = CONVERT(INT, YYYYMMDD),
  [Date]        = [date],
  [Day]         = CONVERT(TINYINT, [day]),
  DaySuffix     = CONVERT(CHAR(2), CASE WHEN [day] / 10 = 1 THEN 'th' ELSE 
                  CASE RIGHT([day], 1) WHEN '1' THEN 'st' WHEN '2' THEN 'nd' 
	              WHEN '3' THEN 'rd' ELSE 'th' END END),
  [Weekday]     = CONVERT(TINYINT, [DayOfWeek]),
  [WeekDayName] = CONVERT(VARCHAR(10), DATENAME(WEEKDAY, [date])),
  [IsWeekend]   = CONVERT(BIT, CASE WHEN [DayOfWeek] IN (6,7) THEN 1 ELSE 0 END),	-- 6=Saturday, 7=Sunday
  [IsHoliday]   = CONVERT(BIT, 0),
  HolidayText   = CONVERT(VARCHAR(64), NULL),
  [DOWInMonth]  = CONVERT(TINYINT, ROW_NUMBER() OVER 
                  (PARTITION BY FirstOfMonth, [DayOfWeek] ORDER BY [date])),
  [DayOfYear]   = CONVERT(SMALLINT, DATEPART(DAYOFYEAR, [date])),
  WeekOfMonth   = CONVERT(TINYINT, DENSE_RANK() OVER 
                  (PARTITION BY [year], [month] ORDER BY [week])),
  WeekOfYear    = CONVERT(TINYINT, [week]),
  ISOWeekOfYear = CONVERT(TINYINT, ISOWeek),
  [Month]       = CONVERT(TINYINT, [month]),
  [MonthName]   = CONVERT(VARCHAR(10), [MonthName]),
  [Quarter]     = CONVERT(TINYINT, [quarter]),
  QuarterName   = CONVERT(VARCHAR(6), CASE [quarter] WHEN 1 THEN 'First' 
                  WHEN 2 THEN 'Second' WHEN 3 THEN 'Third' WHEN 4 THEN 'Fourth' END), 
  [Year]        = [year],
  MMYYYY        = CONVERT(CHAR(6), LEFT(MM_slash_DD_slash_YYYY, 2)    + LEFT(YYYYMMDD, 4)),
  MonthYear     = CONVERT(CHAR(7), LEFT([MonthName], 3) + LEFT(YYYYMMDD, 4)),
  FirstDayOfWeek     = FirstDayOfWeek,
  FirstDayOfMonth     = FirstOfMonth,
  LastDayOfWeek      = MAX([date]) OVER (PARTITION BY [year], [month], [week] ),
  LastDayOfMonth      = MAX([date]) OVER (PARTITION BY [year], [month]),
  FirstDayOfQuarter   = MIN([date]) OVER (PARTITION BY [year], [quarter]),
  LastDayOfQuarter    = MAX([date]) OVER (PARTITION BY [year], [quarter]),
  FirstDayOfYear      = FirstOfYear,
  LastDayOfYear       = MAX([date]) OVER (PARTITION BY [year]),
  FirstDayOfNextMonth = DATEADD(MONTH, 1, FirstOfMonth),
  FirstDayOfNextYear  = DATEADD(YEAR,  1, FirstOfYear)
FROM #dim
OPTION (MAXDOP 1);    -- restricts the usage of number of CPUs in a single batch

go</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DATES</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>GENERATE_incrementing_series_of_Dates_With_Numbers_in_TABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DATES</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>GENERATE_incrementing_series_of_Dates_With_Numbers_in_TABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--GENERATE_incrementing_series_of_Dates_With_Numbers_in_TABLE

--http://stackoverflow.com/questions/1478951/generate-a-resultset-of-incrementing-dates-in-tsql
--For this method to work, you need to do this one time table setup:

SELECT TOP 10000 IDENTITY(int,1,1) AS Number
    INTO Numbers
    FROM sys.objects s1
    CROSS JOIN sys.objects s2
ALTER TABLE Numbers ADD CONSTRAINT PK_Numbers PRIMARY KEY CLUSTERED (Number)

--Once the Numbers table is set up, use this query:

SELECT
    @Start+Number-1
    FROM Numbers
    WHERE Number&lt;=DATEDIFF(day,@Start,@End)+1

--to capture them do:

DECLARE  @Start datetime
         ,@End  datetime
DECLARE @AllDates table
        (Date datetime)

SELECT @Start = 'Mar 1 2009', @End = 'Aug 1 2009'

INSERT INTO @AllDates
        (Date)
    SELECT
        @Start+Number-1
        FROM Numbers
        WHERE Number&lt;=DATEDIFF(day,@Start,@End)+1

SELECT * FROM @AllDates

--OUTPUT:

Date
-----------------------
2009-03-01 00:00:00.000
2009-03-02 00:00:00.000
2009-03-03 00:00:00.000
2009-03-04 00:00:00.000
2009-03-05 00:00:00.000
2009-03-06 00:00:00.000
2009-03-07 00:00:00.000
2009-03-08 00:00:00.000
2009-03-09 00:00:00.000
2009-03-10 00:00:00.000
....
2009-07-25 00:00:00.000
2009-07-26 00:00:00.000
2009-07-27 00:00:00.000
2009-07-28 00:00:00.000
2009-07-29 00:00:00.000
2009-07-30 00:00:00.000
2009-07-31 00:00:00.000
2009-08-01 00:00:00.000
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DATES</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Month_number_to_Month_Name</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DATES</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Month_number_to_Month_Name</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://www.sqlservercentral.com/Forums/Topic310063-8-1.aspx

DECLARE @ArbitraryDateInJanuary datetime

DECLARE @MonthColumns table (MonthNumber int)
insert into @MonthColumns
select 1 union all
select 2 union all
select 3 union all
select 4 union all
select 5 union all
select 6 union all
select 7 union all
select 8 union all
select 9 union all
select 10 union all
select 11 union all
select 12

SET @ArbitraryDateInJanuary = '01/19/19'

SELECT DATENAME(mm,DATEADD(mm,(MonthNumber - 1),@ArbitraryDateInJanuary))
--SELECT SUBSTRING(DATENAME(mm,DATEADD(mm,(MonthNumber - 1),@ArbitraryDateInJanuary)),1,3)     --&lt;== just first 3 letters of the month
FROM @MonthColumns

--OUTPUT
------------
(No column name)
January
February
March
April
May
June
July
August
September
October
November
December


///////////////////////////////////////////////////////////////////////////////////


DECLARE @date datetime

SET @Date = '01/01/01'

SELECT DATENAME(mm,DATEADD(mm,(&lt;YOUR COLUMN&gt; - 1),@date))
FROM &lt;YOUR TABLE&gt;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DATES</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Time_from_string</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DATES</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Time_from_string</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>see time formats: https://docs.microsoft.com/en-us/sql/t-sql/data-types/time-transact-sql?view=sql-server-2017

------------------------------------------------------------------
DECLARE @startdate datetime2 = '2007-05-05 12:10:09.3312722';  
DECLARE @enddate   datetime2 = '2007-05-04 12:10:09.3312722';   
SELECT DATEDIFF(day, @startdate, @enddate); 
-----------------------------------------------------------------


--example using one of the formats
DECLARE @timeFrom time(4) = '12:34:54.1237';  
DECLARE @timeTo time(3) = @timeFrom;  

SELECT @timeTo AS 'time(3)', @timeFrom AS 'time(4)';  

---------------------
declare @first datetime
set @first = '2009-04-30 19:47:16.123'
declare @second datetime
set @second = '2009-04-10 19:47:16.123'

select (cast(@first as float) - floor(cast(@first as float))) -
       (cast(@second as float) - floor(cast(@second as float)))
       as Difference
-----------------------------------------------------------------

CREATE TABLE dbo.Duration  
    (startDate datetime2, endDate datetime2);  

INSERT INTO dbo.Duration(startDate, endDate)  
    VALUES ('2007-05-06 12:10:09', '2007-05-07 12:10:09');  

SELECT DATEDIFF(day, startDate, endDate) AS 'Duration'  
    FROM dbo.Duration; 
-----------------------------------------------------------------
    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DEBUG_and_Try_Catch</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Put_Bad_Records_into_seperate_Table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DEBUG_and_Try_Catch</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Put_Bad_Records_into_seperate_Table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Not exactly a cursor, but as effective - I had over 4 million rows to examine with multiple conversion failrues. 
--Here is what I used, and it resulted in a two temp tables one with all my values 
--and assigned rows and one that simply contained a list of rows in the first temp table that failed to convert.




select row_number() 
over (order by TimeID) as rownum,timeID 
into #TestingTable from MyTableWithBadData

set nocount on
declare @row as int
declare @last as int
set @row=0
select @last = count(*) from #TestingTable
declare @timeid as decimal(24,0)
create table #fails (rownum int)
while @row&lt;=@last
begin
    Begin Try
        select @timeid=cast(timeID as decimal(24,0)) from #TestingTable where rownum = @row 
    end try
    begin catch 
        print cast(@row as varchar(25)) + ' : failed'
        insert into #fails(rownum) values(@row)
    end catch
    set @row = @row+1
end</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DISTINCT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>1_SELECT DISTINCT on one column</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DISTINCT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>1_SELECT DISTINCT on one column</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--PROBLEM
--Using SQL Server, I have...

ID  SKU	PRODUCT
=======================
1   FOO-23	Orange
2   BAR-23	Orange
3   FOO-24	Apple
4   FOO-25	Orange

--I want to DISTINCT on just the column 'PRODUCT', and get the first row that it occurs on

1   FOO-23	Orange
3   FOO-24	Apple


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-- DERIVED TABLE

declare @TestData table (ID int, sku char(6), product varchar(15))
insert into @TestData values (1 ,  'FOO-23'      ,'Orange')
insert into @TestData values (2 ,  'BAR-23'      ,'Orange')
insert into @TestData values (3 ,  'FOO-24'      ,'Apple')
insert into @TestData values (4 ,  'FOO-25'      ,'Orange')



SELECT  *
FROM    (SELECT ID, SKU, Product,
                ROW_NUMBER() OVER (PARTITION BY PRODUCT ORDER BY ID) AS RowNumber
         FROM   @TestData
         WHERE  SKU LIKE 'FOO%') AS a
WHERE   a.RowNumber = 1


-- The sub-SELECT gives this:
ID	SKU		Product	RowNumber
3	FOO-24	Apple	1
1	FOO-23	Orange	1
2	BAR-23	Orange	2
4	FOO-25	Orange	3

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-- SUBQUERY

declare @TestData table (ID int, sku char(6), product varchar(15))
insert into @TestData values (1 ,  'FOO-23'      ,'Orange')
insert into @TestData values (2 ,  'BAR-23'      ,'Orange')
insert into @TestData values (3 ,  'FOO-24'      ,'Apple')
insert into @TestData values (4 ,  'FOO-25'      ,'Orange')


SELECT * FROM @TestData WHERE [ID] IN (
   SELECT MIN([ID]) FROM @TestData
   WHERE [SKU] LIKE 'FOO-%'
   GROUP BY [PRODUCT]
   
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\-- SELECT OVER

declare @TestData table (ID int, sku char(6), product varchar(15))
insert into @TestData values (1 ,  'FOO-23'      ,'Orange')
insert into @TestData values (2 ,  'BAR-23'      ,'Orange')
insert into @TestData values (3 ,  'FOO-24'      ,'Apple')
insert into @TestData values (4 ,  'FOO-25'      ,'Orange')

--basically the same as @Aaron Alton's answer:
SELECT
    dt.ID, dt.SKU, dt.Product
    FROM (SELECT
              ID, SKU, Product, ROW_NUMBER() OVER (PARTITION BY PRODUCT ORDER BY ID) AS RowID
              FROM @TestData
              WHERE  SKU LIKE 'FOO-%'
         ) AS dt
    WHERE dt.RowID=1
    ORDER BY dt.ID  
    
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ Sub-query for each field
 
declare @TestData table (ID int, sku char(6), product varchar(15))
insert into @TestData values (1 ,  'FOO-23'      ,'Orange')
insert into @TestData values (2 ,  'BAR-23'      ,'Orange')
insert into @TestData values (3 ,  'FOO-24'      ,'Apple')
insert into @TestData values (4 ,  'FOO-25'      ,'Orange')

    SELECT DISTINCT  [ID] = ( SELECT TOP 1 [ID]  FROM @TestData Y WHERE Y.[Product] = X.[Product])
                ,[SKU]= ( SELECT TOP 1 [SKU] FROM @TestData Y WHERE Y.[Product] = X.[Product])
                ,[PRODUCT] 
            FROM @TestData X  

 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\ this would work and is simple
 
 declare @TestData table (ID int, sku char(6), product varchar(15))
insert into @TestData values (1 ,  'FOO-23'      ,'Orange')
insert into @TestData values (2 ,  'BAR-23'      ,'Orange')
insert into @TestData values (3 ,  'FOO-24'      ,'Apple')
insert into @TestData values (4 ,  'FOO-25'      ,'Orange')


select * from @TestData  Where ID in(Select Distinct Min(ID) from @TestData Group By PRODUCT)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Documentation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>__DocumentationTemplate</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Documentation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>__DocumentationTemplate</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Documenation TEMPLATE


--================================================
--	0001_007_4CM_Mission_Census_Part1.sql was: 0001_007_OutPut_Mission_Part_1_v3.sql   DERIVED FROM: 0001_001_InsertMidaCensus1_v2.sql
--	TEMPLATE FOR:	0001_007_Output_MissionImbedded_Part_1_ptq
--  Input: 			T1_MissionCensus_Daily_t, T4_Medicaid_Enrollees_t
--  Save Data as: 	
--  Delete: 		
--  UPDate: 		
--  NOTE:			v2 now get's the pediatric Mission patients from their morning Census
--					v3 replaces nulls with blank spaces

--================================================


--================================================
--	CreateTable_prj_0003_Test_1_v1.sql
--	TEMPLATE FOR:	
--  Input: 			{none}
--  Save Data as: 	
--  Delete: 		
--  UPDate: 
--	Create: 		prj_0003_Test_1	
--  NOTE:			Have not put the Delete table part into the script

--================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DynamicSQL</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>DELETE_a_LIST_of_Tables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DynamicSQL</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>DELETE_a_LIST_of_Tables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--p_0048_MAINT_007_Delete_MultipleTables_afterStorageIn__ARCHIVE_01_BHCS_AS_v1.sql
/*
	************************************************************************************
	NOTE: This is from Tri's script (assess_BHCS_V1.sql) with My notes

	Input: 
		the aaa_yyyy_mm_dd_BHCS_AS tables
	INSERT_INTO:
		ARCHIVE_01_BHCS_AS
	Created: 1/29/2018
	By: glenn garson
	************************************************************************************
*/
USE [OBH_Data_Factory]
go

SET NOCOUNT ON

DECLARE @TableList TABLE (TableName NVARCHAR(128) NOT NULL) 

-- This is where you put the list of tables to be archived.
INSERT @TableList VALUES 
('aaa_2017_11_06_BHCS_AS'),
('aaa_2017_11_14_BHCS_AS'),
('aaa_2017_11_28_BHCS_AS'),
('aaa_2017_12_12_BHCS_AS'),
('aaa_2017_12_29_BHCS_AS'),
('aaa_2018_01_10_BHCS_AS')

DECLARE 
  @sqlcmd VARCHAR(4000),
  @table  VARCHAR(128)

-- Loop through the tables in the list
DECLARE c CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR
SELECT TableName
FROM @TableList
ORDER BY TableName

OPEN c 
FETCH NEXT FROM c INTO @table
WHILE @@FETCH_STATUS = 0 
BEGIN 
-------------------------------------------------------------------------------


  SET @sqlcmd = 'IF OBJECT_ID(''dbo.' + @table + ''' ) IS NOT NULL
				 DROP TABLE dbo.' + @table + ''

-------------------------------------------------------------------------------
   print '-------------------'
   PRINT @sqlcmd
   print '-------------------'
  EXEC (@sqlcmd) 
  FETCH NEXT FROM c INTO @table
END

CLOSE c 
DEALLOCATE c

go
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DynamicSQL</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>DeleteFromListOfMultipleTablesBased_on_arbitrary_array_of_values</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DynamicSQL</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>DeleteFromListOfMultipleTablesBased_on_arbitrary_array_of_values</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>DeleteFromListOfMultipleTablesBased_on_arbitrary_array_of_values
https://stackoverflow.com/questions/11680698/sql-server-how-to-delete-from-multiple-tables-based-on-arbitrary-array-of-values

SET NOCOUNT ON

-- Temp table so it can be joined against in dynamic SQL
IF OBJECT_ID('tempdb..#RequestIDList') IS NOT NULL 
  DROP TABLE #RequestIDList
GO

CREATE TABLE #RequestIDList (Request_ID nvarchar(50) NOT NULL)
INSERT INTO #RequestIDList (Request_ID) VALUES 
('00987172'),('01013218'),('01027886'),('01029552'), 
('01031476'),('01032882'),('01033085'),('01034446'), 
('01039261')

DECLARE @TableList TABLE (TableName NVARCHAR(128) NOT NULL) 
INSERT @TableList VALUES 
('Request'),
('RequestTest')

DECLARE 
  @sqlcmd VARCHAR(4000),
  @table  VARCHAR(128)

-- Loop through the tables in your delete list
DECLARE c CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR
SELECT TableName
FROM @TableList
ORDER BY TableName

OPEN c 
FETCH NEXT FROM c INTO @table
WHILE @@FETCH_STATUS = 0 
BEGIN 

  -- Assuming all tables in schema dbo
  -- Assuming all tables have column Request_ID
  SET @sqlcmd = 'DELETE FROM t FROM ' + QUOTENAME(@table) 
              + ' t JOIN #RequestIDList r ON r.Request_ID = t.Request_ID'

  -- PRINT @sqlcmd
  EXEC (@sqlcmd) 
  FETCH NEXT FROM c INTO @table
END

CLOSE c 
DEALLOCATE c

-- Clean up
DROP TABLE #RequestIDList</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DynamicSQL</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>EXCEL_to_SQL_Import_multiple_Files</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DynamicSQL</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>EXCEL_to_SQL_Import_multiple_Files</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--p_0063_MAINT_301_NaturalHazards_ReadInData_CreateTables_v2.sql
/*
	************************************************************************************
	NOTE: This runs in the DEV instance, and uses "Local System" to run the SQL Server
	Uses: 
	Modified: 3/19/2018 - uses dynamic SQL
	Created: 3/19/2018
	By: glenn garson
	************************************************************************************
*/

use p_0063
go

--CREATE TABLE --------------------------------------------
IF OBJECT_ID('dbo.NaturalHazards_2018_03_19') IS NOT NULL
    DROP TABLE dbo.NaturalHazards_2018_03_19

SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 100)) AS RowOrder, *, 'Beverly' as fromWho 
Into NaturalHazards_2018_03_19
FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=NO;Database=C:\DATA\p_0063\TEST\Beverly.xlsx',
				         'SELECT * FROM [Natural_Hazards$A7:H15]');

--=======================================Variables - START
SET NOCOUNT ON

DECLARE @ExcelWorkBookList TABLE (ExcelWorkBookName NVARCHAR(128) NOT NULL) 

-- This is where you put the list of tables to be archived.
INSERT @ExcelWorkBookList VALUES 
('Nicole'),
('Rosanna'),
('Tammy'),
('Thomas'),
('Trudy'),
('Wanda')

DECLARE 
  @sqlcmd VARCHAR(4000),
  @theDynamicRecord  VARCHAR(128)
  --=======================================Variables - END

  -- Loop through the Excel Workbooks in the list
DECLARE theCursor CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR
SELECT ExcelWorkBookName
FROM @ExcelWorkBookList
ORDER BY ExcelWorkBookName

OPEN theCursor 
FETCH NEXT FROM theCursor INTO @theDynamicRecord
WHILE @@FETCH_STATUS = 0 
BEGIN 
-------------------------------------------------------------------------------


  --SET @sqlcmd = 'IF OBJECT_ID(''dbo.' + @theDynamicRecord + ''' ) IS NOT NULL
		--		 DROP TABLE dbo.' + @theDynamicRecord + ''

  SET @sqlcmd = 'INSERT INTO NaturalHazards_2018_03_19
				 SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 100)) AS RowOrder, *, '''+ @theDynamicRecord + ''' as fromWho 
				 FROM OPENROWSET(''Microsoft.ACE.OLEDB.15.0'',
                 ''Excel 12.0 Xml;HDR=NO;Database=C:\DATA\p_0063\TEST\'+ @theDynamicRecord + '.xlsx'',
				 ''SELECT * FROM [Natural_Hazards$A7:H15]'');'

-------------------------------------------------------------------------------
   print '-------------------'
   PRINT @sqlcmd
   print '-------------------'
  EXEC (@sqlcmd) 
  FETCH NEXT FROM theCursor INTO @theDynamicRecord
END

CLOSE theCursor 
DEALLOCATE theCursor

go


-------------------------------------------
Select * from NaturalHazards_2018_03_19</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DynamicSQL</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>EXEC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DynamicSQL</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>EXEC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
--	[EXEC()]

--	EXEC() takes one parameter which is an SQL statement to execute. 
--	The parameter can be a concatenation of string variables and string literals, 
--	but cannot include calls to functions or other operators. 
--	For very simple cases, EXEC() is less hassle than sp_executesql. 
--	For instance, say that you want to run UPDATE STATISTICS WITH FULLSCAN on some selected tables. 
--	It could look like this:

FETCH tblcur INTO @tbl
IF @@fetch_status &lt;&gt; 0 BREAK
EXEC('UPDATE STATISTICS [' + @tbl + '] WITH FULLSCAN')

-- In the example with sp_executesql, I used quotename(), 
--	but here I've let it suffice with adding brackets, in case there is a table named Order Details 
--	(which there is in the Northwind database). Since EXEC only permits string literals and string variables to be concatenated 
--	and not arbitrary expressions, this is not legal:

EXEC('UPDATE STATISTICS ' + quotename(@tbl) + ' WITH FULLSCAN')	--&lt;== Not good

-------------------------------------------------------------------------------

--	The fact that you can concatenate strings within EXEC() permits you to make very quick things, 
--	which can be convenient at times, but it can lead to poor habits in application code. However, 
--	there are situations where this is an enormous blessing. As I mentioned, in SQL 7 and SQL 2000, 
--	you can in practice only use 4000 characters in your SQL string with sp_executesql. 
--	EXEC does not have this limitation, since you can say:

EXEC(@sql1 + @sql2 + @sql3)

--	Where all of @sql1, @sql2 and @sql3 can be 4000 characters long – or even 8000 characters as EXEC() permits you to use varchar.

-------------------------------------------------------------------------------

--	Since you cannot use parameters, you cannot as easily get values out from EXEC() as you can with sp_executesql. 
--	You can, however, use INSERT-EXEC to insert the result set from EXEC() into a table

-------------------------------------------------------------------------------

--In SQL 2005 and later, EXEC() permits impersonation so that you can say:

EXEC(@sql) AS USER = 'mitchell'
EXEC(@sql) AS LOGIN = 'CORDOBA\Miguel'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DynamicSQL</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSERT_and_DELETE_a_list_of_Tables_into_the_ARCHIVE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DynamicSQL</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSERT_and_DELETE_a_list_of_Tables_into_the_ARCHIVE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--p_0048_MAINT_008_Append_Delete_MultipleTables_INSERT_INTO__ARCHIVE_01_BHCS_AS_v1.sql
/*
	************************************************************************************
	NOTE: This appends each table to the table: ARCHIVE_01_BHCS_AS
		   and then deletes the table from the database

	Input: 
		the aaa_yyyy_mm_dd_BHCS_AS tables
	INSERT_INTO:
		ARCHIVE_01_BHCS_AS
	Created: 1/29/2018
	By: glenn garson
	************************************************************************************
*/
USE [OBH_Data_Factory]
go

SET NOCOUNT ON

DECLARE @TableList TABLE (TableName NVARCHAR(128) NOT NULL) 

-- This is where you put the list of tables to be archived.
INSERT @TableList VALUES 
('aaa_2017_11_06_BHCS_AS'),
('aaa_2017_11_14_BHCS_AS'),
('aaa_2017_11_28_BHCS_AS'),
('aaa_2017_12_12_BHCS_AS'),
('aaa_2017_12_29_BHCS_AS'),
('aaa_2018_01_10_BHCS_AS')

DECLARE 
  @sqlcmd_APPEND VARCHAR(4000),
  @sqlcmd_DELETE VARCHAR(4000),
  @table  VARCHAR(128)

-- Loop through the tables in the list
DECLARE c CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR
SELECT TableName
FROM @TableList
ORDER BY TableName

OPEN c 
FETCH NEXT FROM c INTO @table
WHILE @@FETCH_STATUS = 0 
BEGIN 
-------------------------------------------------------------------------------
  SET @sqlcmd_APPEND = 'INSERT INTO ARCHIVE_01_BHCS_AS
	(
		[fromTable]
		,[ARRESTS]
		,[ARRESTS_UPDATE]
		,[ASSESS_DT]
		,[ASSESS_TYPE]
		,[CP_ALCOHOL]
		,[CP_DRUGS]
		,[DISABILITY_1]
		,[DISABILITY_2]
		,[DISABILITY_3]
		,[DISABILITY_4]
		,[DISABILITY_5]
		,[DRUG_1]
		,[DRUG_1_UPDATE]
		,[DRUG_2]
		,[DRUG_2_UPDATE]
		,[DRUG_3]
		,[DRUG_3_UPDATE]
		,[DRUG_1_AGE]
		,[DRUG_2_AGE]
		,[DRUG_3_AGE]
		,[DRUG_1_FREQ]
		,[DRUG_1_FREQ_UPDATE]
		,[DRUG_2_FREQ]
		,[DRUG_2_FREQ_UPDATE]
		,[DRUG_3_FREQ]
		,[DRUG_3_FREQ_UPDATE]
		,[DRUG_1_RTE]
		,[DRUG_1_RTE_UPDATE]
		,[DRUG_2_RTE]
		,[DRUG_2_RTE_UPDATE]
		,[DRUG_3_RTE]
		,[DRUG_3_RTE_UPDATE]
		,[DX_PRIMARY]
		,[DX_SEC]
		,[ENCOUNTERS]
		,[ENCOUNTERS_UPDATE]
		,[EPISODE_UID]
		,[SCHOOL_ABSENCE]
		,[SCHOOL_ABSENCE_UPDATE]
		,[SCHOOL_ENROLLMENT]
		,[SCHOOL_ENROLL_UPDATE]
		,[SCHOOL_SUSPENSION]
		,[SCHOOL_SUSP_UPDATE]
		,[SP_DATE]
		,[SP_SMI]
		,[REGION]
		,[DX_3]
		,[DX_4]
		,[DX_5]
		,[DX_6]
		,[DX_7]
		,[DX_8]
	)
SELECT
		''' + @table +''' 
		,[ARRESTS]
		,[ARRESTS_UPDATE]
		,[ASSESS_DT]
		,[ASSESS_TYPE]
		,[CP_ALCOHOL]
		,[CP_DRUGS]
		,[DISABILITY_1]
		,[DISABILITY_2]
		,[DISABILITY_3]
		,[DISABILITY_4]
		,[DISABILITY_5]
		,[DRUG_1]
		,[DRUG_1_UPDATE]
		,[DRUG_2]
		,[DRUG_2_UPDATE]
		,[DRUG_3]
		,[DRUG_3_UPDATE]
		,[DRUG_1_AGE]
		,[DRUG_2_AGE]
		,[DRUG_3_AGE]
		,[DRUG_1_FREQ]
		,[DRUG_1_FREQ_UPDATE]
		,[DRUG_2_FREQ]
		,[DRUG_2_FREQ_UPDATE]
		,[DRUG_3_FREQ]
		,[DRUG_3_FREQ_UPDATE]
		,[DRUG_1_RTE]
		,[DRUG_1_RTE_UPDATE]
		,[DRUG_2_RTE]
		,[DRUG_2_RTE_UPDATE]
		,[DRUG_3_RTE]
		,[DRUG_3_RTE_UPDATE]
		,[DX_PRIMARY]
		,[DX_SEC]
		,[ENCOUNTERS]
		,[ENCOUNTERS_UPDATE]
		,[EPISODE_UID]
		,[SCHOOL_ABSENCE]
		,[SCHOOL_ABSENCE_UPDATE]
		,[SCHOOL_ENROLLMENT]
		,[SCHOOL_ENROLL_UPDATE]
		,[SCHOOL_SUSPENSION]
		,[SCHOOL_SUSP_UPDATE]
		,[SP_DATE]
		,[SP_SMI]
		,[REGION]
		,[DX_3]
		,[DX_4]
		,[DX_5]
		,[DX_6]
		,[DX_7]
		,[DX_8]
FROM [OBH_Data_Factory].[dbo].' + QUOTENAME(@table) 

-------------------------------------------------------------------------------
  SET @sqlcmd_DELETE = 'IF OBJECT_ID(''dbo.' + @table + ''' ) IS NOT NULL
				 DROP TABLE dbo.' + @table + ''
-------------------------------------------------------------------------------
   print '-------------------'
   PRINT @sqlcmd_APPEND
   print '-------------------'
  EXEC (@sqlcmd_APPEND) 
     print '-------------------'
   PRINT @sqlcmd_DELETE
   print '-------------------'
  EXEC (@sqlcmd_DELETE) 
  FETCH NEXT FROM c INTO @table
END

CLOSE c 
DEALLOCATE c

go

Select count(*), fromTable
From ARCHIVE_01_BHCS_AS
Group by fromTable
Order by fromTable</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DynamicSQL</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSERT_from_LIST_of_Tables_into_one_Table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DynamicSQL</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSERT_from_LIST_of_Tables_into_one_Table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--p_0048_MAINT_006_AppendMultipleTables_INSERT_INTO__ARCHIVE_01_BHCS_AS_v1.sql
/*
	************************************************************************************
	NOTE: This is from Tri's script (assess_BHCS_V1.sql) with My notes

	Input: 
		the aaa_yyyy_mm_dd_BHCS_AS tables
	INSERT_INTO:
		ARCHIVE_01_BHCS_AS
	Created: 1/29/2018
	By: glenn garson
	************************************************************************************
*/
USE [OBH_Data_Factory]
go

SET NOCOUNT ON

DECLARE @TableList TABLE (TableName NVARCHAR(128) NOT NULL) 

INSERT @TableList VALUES 
('aaa_2017_11_06_BHCS_AS'),
('aaa_2017_11_14_BHCS_AS')

DECLARE 
  @sqlcmd VARCHAR(4000),
  @table  VARCHAR(128)

-- Loop through the tables in the list
DECLARE c CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR
SELECT TableName
FROM @TableList
ORDER BY TableName

OPEN c 
FETCH NEXT FROM c INTO @table
WHILE @@FETCH_STATUS = 0 
BEGIN 
-------------------------------------------------------------------------------

  SET @sqlcmd = 'INSERT INTO ARCHIVE_01_BHCS_AS
	(
		[fromTable]
		,[ARRESTS]
		,[ARRESTS_UPDATE]
		,[ASSESS_DT]
		,[ASSESS_TYPE]
		,[CP_ALCOHOL]
		,[CP_DRUGS]
		,[DISABILITY_1]
		,[DISABILITY_2]
		,[DISABILITY_3]
		,[DISABILITY_4]
		,[DISABILITY_5]
		,[DRUG_1]
		,[DRUG_1_UPDATE]
		,[DRUG_2]
		,[DRUG_2_UPDATE]
		,[DRUG_3]
		,[DRUG_3_UPDATE]
		,[DRUG_1_AGE]
		,[DRUG_2_AGE]
		,[DRUG_3_AGE]
		,[DRUG_1_FREQ]
		,[DRUG_1_FREQ_UPDATE]
		,[DRUG_2_FREQ]
		,[DRUG_2_FREQ_UPDATE]
		,[DRUG_3_FREQ]
		,[DRUG_3_FREQ_UPDATE]
		,[DRUG_1_RTE]
		,[DRUG_1_RTE_UPDATE]
		,[DRUG_2_RTE]
		,[DRUG_2_RTE_UPDATE]
		,[DRUG_3_RTE]
		,[DRUG_3_RTE_UPDATE]
		,[DX_PRIMARY]
		,[DX_SEC]
		,[ENCOUNTERS]
		,[ENCOUNTERS_UPDATE]
		,[EPISODE_UID]
		,[SCHOOL_ABSENCE]
		,[SCHOOL_ABSENCE_UPDATE]
		,[SCHOOL_ENROLLMENT]
		,[SCHOOL_ENROLL_UPDATE]
		,[SCHOOL_SUSPENSION]
		,[SCHOOL_SUSP_UPDATE]
		,[SP_DATE]
		,[SP_SMI]
		,[REGION]
		,[DX_3]
		,[DX_4]
		,[DX_5]
		,[DX_6]
		,[DX_7]
		,[DX_8]
	)
SELECT
		''' + @table +''' 
		,[ARRESTS]
		,[ARRESTS_UPDATE]
		,[ASSESS_DT]
		,[ASSESS_TYPE]
		,[CP_ALCOHOL]
		,[CP_DRUGS]
		,[DISABILITY_1]
		,[DISABILITY_2]
		,[DISABILITY_3]
		,[DISABILITY_4]
		,[DISABILITY_5]
		,[DRUG_1]
		,[DRUG_1_UPDATE]
		,[DRUG_2]
		,[DRUG_2_UPDATE]
		,[DRUG_3]
		,[DRUG_3_UPDATE]
		,[DRUG_1_AGE]
		,[DRUG_2_AGE]
		,[DRUG_3_AGE]
		,[DRUG_1_FREQ]
		,[DRUG_1_FREQ_UPDATE]
		,[DRUG_2_FREQ]
		,[DRUG_2_FREQ_UPDATE]
		,[DRUG_3_FREQ]
		,[DRUG_3_FREQ_UPDATE]
		,[DRUG_1_RTE]
		,[DRUG_1_RTE_UPDATE]
		,[DRUG_2_RTE]
		,[DRUG_2_RTE_UPDATE]
		,[DRUG_3_RTE]
		,[DRUG_3_RTE_UPDATE]
		,[DX_PRIMARY]
		,[DX_SEC]
		,[ENCOUNTERS]
		,[ENCOUNTERS_UPDATE]
		,[EPISODE_UID]
		,[SCHOOL_ABSENCE]
		,[SCHOOL_ABSENCE_UPDATE]
		,[SCHOOL_ENROLLMENT]
		,[SCHOOL_ENROLL_UPDATE]
		,[SCHOOL_SUSPENSION]
		,[SCHOOL_SUSP_UPDATE]
		,[SP_DATE]
		,[SP_SMI]
		,[REGION]
		,[DX_3]
		,[DX_4]
		,[DX_5]
		,[DX_6]
		,[DX_7]
		,[DX_8]
FROM [OBH_Data_Factory].[dbo].' + QUOTENAME(@table) 

-------------------------------------------------------------------------------
   print '-------------------'
   PRINT @sqlcmd
   print '-------------------'
  EXEC (@sqlcmd) 
  FETCH NEXT FROM c INTO @table
END

CLOSE c 
DEALLOCATE c

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DynamicSQL</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>StoredProcedure_usingTEMP_table_atScopeOfTheSP_v2</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DynamicSQL</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>StoredProcedure_usingTEMP_table_atScopeOfTheSP_v2</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--StoredProcedure_usingTEMP_table_atScopeOfTheSP_v2
------------------------------------------------------------------------------
use RiskMngt
go

--P_0017_TASK_006_SP_03_MAIN_INDEXES_in_all_TABLES_of_Database_v4.sql
/*
	************************************************************************************
	SSRS Report: 0025_REP_18_INDEXES_TABLES_Database
	NOTE: 
	Uses: 
	Created: 12/03/2019
	By: glenn garson
	************************************************************************************
*/


--================================================	
--DECLARE @DBtoFind AS NVARCHAR (100)
--SET @DBtoFind = 'RiskMngt'

--DECLARE @tableToFind AS NVARCHAR (100)
--SET @tableToFind = ''
--================================================  


alter Procedure [Reporting].[P_0017_TASK_006_SP_03_MAIN_INDEXES_in_all_TABLES_of_Database](@DBtoFind NVARCHAR (100), @tableToFind  NVARCHAR (100))
as

------------------------------------------------------------------------------------------------------------------------------

--This creates the temp table in the higher SCOPE, so that it is visible both in the SP, and in the Dynamic SQL
IF OBJECT_ID('tempdb..#P_0017_TASK_006_SP_03') IS NOT NULL DROP TABLE #P_0017_TASK_006_SP_03

CREATE TABLE #P_0017_TASK_006_SP_03(
	[DatabaseName] [varchar](8) NOT NULL,
	[schemaName] [nvarchar](128) NULL,
	[table_or_view_Name] [sysname] NOT NULL,
	[index_name] [sysname] NULL,
	[columns] [nvarchar](max) NULL,
	[index_type] [varchar](30) NULL,
	[unique] [varchar](10) NOT NULL,
	[object_type] [varchar](5) NULL
) 


------------------------------------------------------------------------------------------------------------------------------

DECLARE @query_string AS NVARCHAR (MAX)
SET @query_string = '


INSERT INTO #P_0017_TASK_006_SP_03
select 
	'''  + CAST(@DBtoFind AS NVARCHAR)  +'''as DatabaseName,
    schema_name(t.schema_id) as schemaName,
	 t.[name] as table_or_view_Name, 

	i.[name] as index_name,
    substring(column_names, 1, len(column_names)-1) as [columns],
    case when i.[type] = 1 then ''Clustered index''
        when i.[type] = 2 then ''Nonclustered unique index''
        when i.[type] = 3 then ''XML index''
        when i.[type] = 4 then ''Spatial index''
        when i.[type] = 5 then ''Clustered columnstore index''
        when i.[type] = 6 then ''Nonclustered columnstore index''
        when i.[type] = 7 then ''Nonclustered hash index''
        end as index_type,
    case when i.is_unique = 1 then ''Unique''
        else ''Not unique'' end as [unique],


    case when t.[type] = ''U'' then ''Table''
        when t.[type] = ''V'' then ''View''
        end as [object_type]

from 
	' + CAST(@DBtoFind AS NVARCHAR) +'.sys.objects t
    inner join 
	' + CAST(@DBtoFind AS NVARCHAR) +'.sys.indexes i

    on t.object_id = i.object_id
    cross apply 
	(
		select col.[name] + '', ''
        from 
			sys.index_columns ic
            inner join 
			sys.columns col
            on 
				ic.object_id = col.object_id
                and 
				ic.column_id = col.column_id
        where 
			ic.object_id = t.object_id
            and 
			ic.index_id = i.index_id
        order by index_column_id
        for xml path ('''') 
	) D (column_names)

where 
		t.is_ms_shipped &lt;&gt; 1
		and 
		index_id &gt; 0
		AND
		(
			LEN(rtrim(ltrim(''' + CAST(@tableToFind AS NVARCHAR(50)) +'''))) = 0
			OR
			t.[name] = ''' + CAST(@tableToFind AS NVARCHAR(50)) +'''
		)
order by DatabaseName, schema_name(t.schema_id),  t.[name]

'
PRINT(@query_string)

EXEC sys.sp_executesql @query_string

SELECT * from #P_0017_TASK_006_SP_03
order by DatabaseName, schemaName,  table_or_view_Name</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DynamicSQL</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>StoredProcedure_usingTEMP_table_atScopeOfTheSP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DynamicSQL</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>StoredProcedure_usingTEMP_table_atScopeOfTheSP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--https://stackoverflow.com/questions/2917728/t-sql-dynamic-sql-and-temp-tables


use RiskMngt
go
--P_0017_TASK_006_SP_04_LIST_TABLES_given_Database_v3.sql


--================================================	


DECLARE @DBtoFind nvarchar(100)
SET @DBtoFind = 'riskmngt'
--================================================  



--alter Procedure [Reporting].[P_0017_TASK_006_SP_04_LIST_TABLES_given_Database]( @DBtoFind nvarchar(100))
--	as


--This creates the temp table in the higher SCOPE, so that it is visible both in the SP, and in the Dynamic SQL
IF OBJECT_ID('tempdb..#P_0017_TASK_006_SP_04') IS NOT NULL DROP TABLE #P_0017_TASK_006_SP_04

CREATE TABLE #P_0017_TASK_006_SP_04(
	[TableName_Label] [nvarchar](258) NULL,
	[TableName_Value] [sysname] NOT NULL
) 


DECLARE @query_string AS NVARCHAR (MAX)
SET @query_string = '


IF OBJECT_ID(''tempdb..##t_P_0017_TASK_006_SP_04'') IS NOT NULL DROP TABLE ##t_P_0017_TASK_006_SP_04

			    INSERT INTO #P_0017_TASK_006_SP_04
				SELECT 
						SCHEMA_NAME(oTables.schema_id) + ''__'' + oTables.name as [TableName_Label]
						,oTables.name as [TableName_Value]
				
				FROM
					' + CAST(@DBtoFind AS NVARCHAR) +'.sys.objects	oTables


						WHERE
								(

									oTables.type = ' + '''U''' + '
								)	

'
PRINT(@query_string)

EXEC sys.sp_executesql @query_string;

SELECT * from #P_0017_TASK_006_SP_04
ORDER BY TableName_Label</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>EXPORT_Excel_CSV_TEXT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ExportToExcel_withAScrip</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>EXPORT_Excel_CSV_TEXT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ExportToExcel_withAScrip</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Normally for exporting data from SQL Server to Excel one would use DTS (SQL 2k) or SSIS (SQL Server 2005).

--For some reason if at all you want to do it via query read on:

--Step 1: Execute the code snippet


EXEC sp_configure 'show advanced options', 1;

GO

RECONFIGURE;

GO

EXEC sp_configure 'Ad Hoc Distributed Queries', 1;

GO

RECONFIGURE;

GO

--Step 2: Create the excel file and then add the headings in the .xls file.

-– Create one Excel File in c:\Test.xls and rename the Sheet1 to Emp. The Sheet should contain 2 columns EmployeeID,Title

--Step 3: Run the following query to export data from sql server to excel

USE [AdventureWorks]

INSERT INTO OPENROWSET ('Microsoft.Jet.OLEDB.4.0', 'Excel 8.0;Database=c:\Test.xls;','Select * from [Emp$]')

SELECT EmployeeID, Title FROM HumanResources.Employee

--Points which might interest you:

--1. As long as the file is within your C: drive this sample would work. If at all your database is in a different machine from that .xls file you need to change Database=c:\Test.xls; to UNC path. For example, Database=\\Servername\shareName (And need to provide appropriate permission).

--2. Instead of “Emp” replace it with your excel worksheet name.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>EXPORT_Excel_CSV_TEXT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Import_Export_Excel_To_From_SQL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>EXPORT_Excel_CSV_TEXT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Import_Export_Excel_To_From_SQL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Apart from using DTS and Import/Export wizard, we can also use this query to export data 
--from SQL Server2000 to Excel and vice versa

--To export data from SQL Server table to Excel file, create an Excel file named testing having the headers same as that of table columns and use this query

insert into OPENROWSET('Microsoft.Jet.OLEDB.4.0',
'Excel 8.0;Database=D:\testing.xls;',
'SELECT * FROM [SheetName$]') select * from SQLServerTable

--To export data from Excel to new SQL Server table,

select *
into SQLServerTable FROM OPENROWSET('Microsoft.Jet.OLEDB.4.0',
'Excel8.0;Database=D:\testing.xls;HDR=YES',
'SELECT * FROM [Sheet1$]')

--To export data from Excel to existing SQL Server table,

Insert into SQLServerTable Select * FROM OPENROWSET('Microsoft.Jet.OLEDB.4.0',
'Excel8.0;Database=D:\testing.xls;HDR=YES',
'SELECT * FROM [SheetName$]')


--ERRATA NOTES:
===================

there is an space between Excel and 8.0.

SELECT * into table FROM OPENROWSET('Microsoft.Jet.OLEDB.4.0',

'Excel 8.0;Database=C:\file.xls; HDR=YES', 'SELECT * FROM [Sheet1$]')


===================================
in using the export to Excel script I get the following message

insert into OPENROWSET('Microsoft.Jet.OLEDB.4.0',

'Excel 8.0;Database=C:\testing.xls;HDR=YES',

'SELECT * FROM [Sheet1$]')

select * from cdbLink

WHERE (((cdbLink.extObjType)=11 Or (cdbLink.extObjType)=-1))

error message

Server: Msg 213, Level 16, State 5, Line 1

Insert Error: Column name or number of supplied values does not match table definition.

------------
Make sure the number of columns in excel sheet is same as the table


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Extended_Events_and_Trace_Profiler</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>01_ConvertTraceToExtendedEvents___create_SP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Extended_Events_and_Trace_Profiler</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>01_ConvertTraceToExtendedEvents___create_SP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>01_ConvertTraceToExtendedEvents___create_SP


--prj_0000_SP_202_ConvertTraceToExtendedEvents.sql
/*
	Stored procedure to convert an existing trace to
	an extended events session
	https://www.sqlskills.com/blogs/jonathan/converting-sql-trace-to-extended-events-in-sql-server-2012/

	Before you run this SP, You can use this to get a list of the traceIDs for existing traces.
	select * from sys.fn_trace_getinfo(0)

	Example of Usage:
	===================
	EXECUTE sp_SQLskills_ConvertTraceToExtendedEvents 
		@TraceID = 2, 
		@SessionName = 'XE_ReadsFilter_Trace',		--&lt;== give it a name for the session
		@PrintOutput = 1,							--&lt;== 1=true, i.e. print the output
		@Execute = 0;								--&lt;== 0=False, i.e. don't execute

	The output in the Messages pane is the script for generating the Extended Events
	The last line marks this as a system object
	
	Just copy the output in the Messages pane into a new Query pane and you have the script
		to create an extended events session

*/

USE [master]
GO
IF OBJECT_ID('prj_0000_SP_202_ConvertTraceToExtendedEvents') IS NOT NULL
       DROP PROCEDURE prj_0000_SP_202_ConvertTraceToExtendedEvents;
GO

CREATE PROCEDURE prj_0000_SP_202_ConvertTraceToExtendedEvents
(	@TraceID INT,
	@SessionName NVARCHAR(128),
	@PrintOutput BIT = 1,
	@Execute BIT = 0)
AS

SET NOCOUNT ON

IF NOT EXISTS (SELECT 1 FROM sys.traces WHERE id = @TraceID)
BEGIN
	RAISERROR('The specified @TraceID does not exist on the server.  Please check the id of the trace in sys.traces.', 16, 1) WITH NOWAIT;
	RETURN;
END

CREATE TABLE [#SQLskills_Trace_XE_Column_Map](
	[trace_event_id] [int] NOT NULL,
	[trace_column_id] [int] NOT NULL,
	[event_package_name] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[xe_event_name] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[column_name] [nvarchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[action_package_name] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[xe_action_name] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
) ON [PRIMARY]

CREATE CLUSTERED INDEX CX_#SQLskills_Trace_XE_Column_Map ON [#SQLskills_Trace_XE_Column_Map](trace_event_id, trace_column_id)
INSERT INTO [#SQLskills_Trace_XE_Column_Map]
SELECT 
	te.trace_event_id,
	tc.trace_column_id AS trace_column_id,
	txem.package_name AS event_package_name,
	txem.xe_event_name,
	tab.column_name,
	CASE WHEN tab.column_name IS NOT NULL THEN NULL ELSE txam.package_name END AS action_package_name,
	CASE WHEN tab.column_name IS NOT NULL THEN NULL ELSE txam.xe_action_name END AS xe_action_name
FROM sys.trace_events AS te
JOIN sys.trace_categories AS cat
	ON te.category_id = cat.category_id
JOIN sys.trace_event_bindings AS teb
	ON te.trace_event_id = teb.trace_event_id
JOIN sys.trace_columns AS tc
	ON teb.trace_column_id = tc.trace_column_id
JOIN sys.trace_xe_event_map AS txem
	ON te.trace_event_id = txem.trace_event_id
LEFT JOIN (
		SELECT 
			p.name AS event_package_name,
			o.name AS event_name,
			oc.name AS column_name
		FROM sys.dm_xe_packages AS p
		JOIN sys.dm_xe_objects AS o 
			 ON p.guid = o.package_guid
		JOIN sys.dm_xe_object_columns AS oc 
			 ON o.name = oc.object_name 
			AND o.package_guid = oc.object_package_guid
		WHERE (p.capabilities IS NULL OR p.capabilities &amp; 1 = 0)
		  AND (o.capabilities IS NULL OR o.capabilities &amp; 1 = 0)
		  AND o.object_type = 'event'
		  AND oc.column_type = 'data') as tab
	ON tab.event_package_name COLLATE SQL_Latin1_General_CP1_CI_AS = txem.package_name COLLATE SQL_Latin1_General_CP1_CI_AS
		AND tab.event_name COLLATE SQL_Latin1_General_CP1_CI_AS = txem.xe_event_name COLLATE SQL_Latin1_General_CP1_CI_AS
		AND CASE
				WHEN tc.name = 'ObjectID' THEN 'object_id'
				WHEN tc.name = 'Type' THEN 'object_type'
				--WHEN tc.name = 'NestLevel' THEN 'nest_level'
				WHEN tc.name = 'ObjectName' THEN 'object_name'
				WHEN tc.name = 'DatabaseID' THEN 'database_id'
				WHEN tc.name = 'DatabaseName' THEN 'database_name'
				WHEN tc.name = 'IndexID' THEN 'index_id'
				WHEN tc.name = 'Reads' THEN 'logical_reads'
				WHEN tc.name = 'CPU' THEN 'cpu_time'
				WHEN tc.name = 'RowCounts' THEN 'row_count'
				--WHEN tc.name = 'Severity' THEN 'error_severity'
				--WHEN tc.name = 'Type' THEN 'object_type'
				WHEN tc.name = 'Error' THEN 'error_number'
				ELSE tc.name
			END = tab.column_name
LEFT JOIN sys.trace_xe_action_map AS txam
	ON tc.trace_column_id = txam.trace_column_id
WHERE cat.name NOT IN ('User configurable')
  AND tc.name NOT IN ('EventClass', 'StartTime', 'EndTime')
  AND (tab.column_name IS NOT NULL
		OR txam.xe_action_name IS NOT NULL)
UNION ALL 
SELECT 
	CAST(trace_event_id AS INT) AS trace_event_id, 
--	trace_event_name, 
	CAST(trace_column_id AS INT) AS trace_column_id, 
--	trace_column_name, 
	event_package_name, 
	xe_event_name, 
	NULLIF(column_name, '') AS column_name, 
	NULLIF(action_package_name, '') AS action_package_name,
	NULLIF(xe_action_name, '') AS xe_action_name
FROM
(
	VALUES 
		('10', 'RPC:Completed', '1', 'TextData', 'sqlserver', 'rpc_completed', 'statement', '', ''),
		('10', 'RPC:Completed', '31', 'Error', 'sqlserver', 'rpc_completed', 'result', '', ''),
		('11', 'RPC:Starting', '1', 'TextData', 'sqlserver', 'rpc_starting', 'statement', '', ''),
		('12', 'SQL:BatchCompleted', '1', 'TextData', 'sqlserver', 'sql_batch_completed', 'batch_text', '', ''),
		('12', 'SQL:BatchCompleted', '31', 'Error', 'sqlserver', 'sql_batch_completed', 'result', '', ''),
		('13', 'SQL:BatchStarting', '1', 'TextData', 'sqlserver', 'sql_batch_starting', 'batch_text', '', ''),
		('14', 'Audit Login', '1', 'TextData', 'sqlserver', 'login', 'options_text', '', ''),
		('14', 'Audit Login', '2', 'BinaryData', 'sqlserver', 'login', 'options', '', ''),
		('14', 'Audit Login', '25', 'IntegerData', 'sqlserver', 'login', 'packet_size', '', ''),
		('17', 'ExistingConnection', '1', 'TextData', 'sqlserver', 'existing_connection', 'options_text', '', ''),
		('17', 'ExistingConnection', '2', 'BinaryData', 'sqlserver', 'existing_connection', 'options', '', ''),
		('17', 'ExistingConnection', '25', 'IntegerData', 'sqlserver', 'existing_connection', 'packet_size', '', ''),
		('18', 'Audit Server Starts And Stops', '21', 'EventSubClass', 'sqlserver', 'server_start_stop', 'operation', '', ''),
		('19', 'DTCTransaction', '2', 'BinaryData', 'sqlserver', 'dtc_transaction', 'unit_of_work_id', '', ''),
		('19', 'DTCTransaction', '21', 'EventSubClass', 'sqlserver', 'dtc_transaction', 'transaction_state', '', ''),
		('19', 'DTCTransaction', '25', 'IntegerData', 'sqlserver', 'dtc_transaction', 'isolation_level', '', ''),
		('21', 'EventLog', '1', 'TextData', 'sqlserver', 'error_reported', 'message', '', ''),
		('22', 'ErrorLog', '1', 'TextData', 'sqlserver', 'errorlog_written', 'message', '', ''),
		('23', 'Lock:Released', '1', 'TextData', 'sqlserver', 'lock_released', 'resource_description', '', ''),
		('23', 'Lock:Released', '2', 'BinaryData', 'sqlserver', 'lock_released', 'lockspace_workspace_id', '', ''),
		('23', 'Lock:Released', '52', 'BigintData1', 'sqlserver', 'lock_released', 'resource_2', '', ''),
		('23', 'Lock:Released', '56', 'ObjectID2', 'sqlserver', 'lock_released', 'associated_object_id', '', ''),
		('23', 'Lock:Released', '57', 'Type', 'sqlserver', 'lock_released', 'resource_type', '', ''),
		('23', 'Lock:Released', '58', 'OwnerID', 'sqlserver', 'lock_released', 'owner_type', '', ''),
		('24', 'Lock:Acquired', '1', 'TextData', 'sqlserver', 'lock_acquired', 'resource_description', '', ''),
		('24', 'Lock:Acquired', '2', 'BinaryData', 'sqlserver', 'lock_acquired', 'lockspace_workspace_id', '', ''),
		('24', 'Lock:Acquired', '52', 'BigintData1', 'sqlserver', 'lock_acquired', 'resource_2', '', ''),
		('24', 'Lock:Acquired', '56', 'ObjectID2', 'sqlserver', 'lock_acquired', 'associated_object_id', '', ''),
		('24', 'Lock:Acquired', '57', 'Type', 'sqlserver', 'lock_acquired', 'resource_type', '', ''),
		('24', 'Lock:Acquired', '58', 'OwnerID', 'sqlserver', 'lock_acquired', 'owner_type', '', ''),
		('25', 'Lock:Deadlock', '1', 'TextData', 'sqlserver', 'lock_deadlock', 'resource_description', '', ''),
		('25', 'Lock:Deadlock', '2', 'BinaryData', 'sqlserver', 'lock_deadlock', 'lockspace_workspace_id', '', ''),
		('25', 'Lock:Deadlock', '25', 'IntegerData', 'sqlserver', 'lock_deadlock', 'deadlock_id', '', ''),
		('25', 'Lock:Deadlock', '56', 'ObjectID2', 'sqlserver', 'lock_deadlock', 'associated_object_id', '', ''),
		('25', 'Lock:Deadlock', '57', 'Type', 'sqlserver', 'lock_deadlock', 'resource_type', '', ''),
		('25', 'Lock:Deadlock', '58', 'OwnerID', 'sqlserver', 'lock_deadlock', 'owner_type', '', ''),
		('26', 'Lock:Cancel', '1', 'TextData', 'sqlserver', 'lock_cancel', 'resource_description', '', ''),
		('26', 'Lock:Cancel', '2', 'BinaryData', 'sqlserver', 'lock_cancel', 'lockspace_workspace_id', '', ''),
		('26', 'Lock:Cancel', '52', 'BigintData1', 'sqlserver', 'lock_cancel', 'resource_2', '', ''),
		('26', 'Lock:Cancel', '56', 'ObjectID2', 'sqlserver', 'lock_cancel', 'associated_object_id', '', ''),
		('26', 'Lock:Cancel', '57', 'Type', 'sqlserver', 'lock_cancel', 'resource_type', '', ''),
		('26', 'Lock:Cancel', '58', 'OwnerID', 'sqlserver', 'lock_cancel', 'owner_type', '', ''),
		('27', 'Lock:Timeout', '1', 'TextData', 'sqlserver', 'lock_timeout', 'resource_description', '', ''),
		('27', 'Lock:Timeout', '2', 'BinaryData', 'sqlserver', 'lock_timeout', 'lockspace_workspace_id', '', ''),
		('27', 'Lock:Timeout', '56', 'ObjectID2', 'sqlserver', 'lock_timeout', 'associated_object_id', '', ''),
		('27', 'Lock:Timeout', '57', 'Type', 'sqlserver', 'lock_timeout', 'resource_type', '', ''),
		('27', 'Lock:Timeout', '58', 'OwnerID', 'sqlserver', 'lock_timeout', 'owner_type', '', ''),
		('28', 'Degree of Parallelism', '2', 'BinaryData', 'sqlserver', 'degree_of_parallelism', 'dop', '', ''),
		('28', 'Degree of Parallelism', '21', 'EventSubClass', 'sqlserver', 'degree_of_parallelism', 'statement_type', '', ''),
		('28', 'Degree of Parallelism', '25', 'IntegerData', 'sqlserver', 'degree_of_parallelism', 'workspace_memory_grant_kb', '', ''),
		('34', 'SP:CacheMiss', '1', 'TextData', 'sqlserver', 'sp_cache_miss', 'cached_text', '', ''),
		('34', 'SP:CacheMiss', '28', 'ObjectType', 'sqlserver', 'sp_cache_miss', 'object_type', '', ''),
		('35', 'SP:CacheInsert', '1', 'TextData', 'sqlserver', 'sp_cache_insert', 'cached_text', '', ''),
		('35', 'SP:CacheInsert', '28', 'ObjectType', 'sqlserver', 'sp_cache_insert', 'object_type', '', ''),
		('36', 'SP:CacheRemove', '1', 'TextData', 'sqlserver', 'sp_cache_remove', 'cached_text', '', ''),
		('36', 'SP:CacheRemove', '21', 'EventSubClass', 'sqlserver', 'sp_cache_remove', 'remove_method', '', ''),
		('36', 'SP:CacheRemove', '28', 'ObjectType', 'sqlserver', 'sp_cache_remove', 'object_type', '', ''),
		('37', 'SP:Recompile', '1', 'TextData', 'sqlserver', 'sql_statement_recompile', 'statement', '', ''),
		('37', 'SP:Recompile', '21', 'EventSubClass', 'sqlserver', 'sql_statement_recompile', 'recompile_cause', '', ''),
		('37', 'SP:Recompile', '28', 'ObjectType', 'sqlserver', 'sql_statement_recompile', 'object_type', '', ''),
		('37', 'SP:Recompile', '29', 'NestLevel', 'sqlserver', 'sql_statement_recompile', 'nest_level', '', ''),
		('37', 'SP:Recompile', '55', 'IntegerData2', 'sqlserver', 'sql_statement_recompile', 'offset_end', '', ''),
		('38', 'SP:CacheHit', '1', 'TextData', 'sqlserver', 'sp_cache_hit', 'cached_text', '', ''),
		('38', 'SP:CacheHit', '28', 'ObjectType', 'sqlserver', 'sp_cache_hit', 'object_type', '', ''),
		('40', 'SQL:StmtStarting', '1', 'TextData', 'sqlserver', 'sql_statement_starting', 'statement', '', ''),
		('40', 'SQL:StmtStarting', '29', 'NestLevel', 'sqlserver', 'sql_statement_starting', '', 'sqlserver', 'tsql_stack'),
		('40', 'SQL:StmtStarting', '55', 'IntegerData2', 'sqlserver', 'sql_statement_starting', 'offset_end', '', ''),
		('41', 'SQL:StmtCompleted', '1', 'TextData', 'sqlserver', 'sql_statement_completed', 'statement', '', ''),
		('41', 'SQL:StmtCompleted', '25', 'IntegerData', 'sqlserver', 'sql_statement_completed', 'row_count', '', ''),
		('41', 'SQL:StmtCompleted', '29', 'NestLevel', 'sqlserver', 'sql_statement_completed', '', 'sqlserver', 'tsql_stack'),
		('41', 'SQL:StmtCompleted', '55', 'IntegerData2', 'sqlserver', 'sql_statement_completed', 'offset_end', '', ''),
		('42', 'SP:Starting', '1', 'TextData', 'sqlserver', 'module_start', 'statement', '', ''),
		('42', 'SP:Starting', '28', 'ObjectType', 'sqlserver', 'module_start', 'object_type', '', ''),
		('42', 'SP:Starting', '29', 'NestLevel', 'sqlserver', 'module_start', '', 'sqlserver', 'tsql_stack'),
		('42', 'SP:Starting', '62', 'SourceDatabaseID', 'sqlserver', 'module_start', 'source_database_id', '', ''),
		('43', 'SP:Completed', '1', 'TextData', 'sqlserver', 'module_end', 'statement', '', ''),
		('43', 'SP:Completed', '28', 'ObjectType', 'sqlserver', 'module_end', 'object_type', '', ''),
		('43', 'SP:Completed', '29', 'NestLevel', 'sqlserver', 'module_end', '', 'sqlserver', 'tsql_stack'),
		('43', 'SP:Completed', '62', 'SourceDatabaseID', 'sqlserver', 'module_end', 'source_database_id', '', ''),
		('44', 'SP:StmtStarting', '1', 'TextData', 'sqlserver', 'sp_statement_starting', 'statement', '', ''),
		('44', 'SP:StmtStarting', '28', 'ObjectType', 'sqlserver', 'sp_statement_starting', 'object_type', '', ''),
		('44', 'SP:StmtStarting', '29', 'NestLevel', 'sqlserver', 'sp_statement_starting', 'nest_level', '', ''),
		('44', 'SP:StmtStarting', '55', 'IntegerData2', 'sqlserver', 'sp_statement_starting', 'offset_end', '', ''),
		('44', 'SP:StmtStarting', '62', 'SourceDatabaseID', 'sqlserver', 'sp_statement_starting', 'source_database_id', '', ''),
		('45', 'SP:StmtCompleted', '1', 'TextData', 'sqlserver', 'sp_statement_completed', 'statement', '', ''),
		('45', 'SP:StmtCompleted', '28', 'ObjectType', 'sqlserver', 'sp_statement_completed', 'object_type', '', ''),
		('45', 'SP:StmtCompleted', '29', 'NestLevel', 'sqlserver', 'sp_statement_completed', 'nest_level', '', ''),
		('45', 'SP:StmtCompleted', '55', 'IntegerData2', 'sqlserver', 'sp_statement_completed', 'offset_end', '', ''),
		('45', 'SP:StmtCompleted', '62', 'SourceDatabaseID', 'sqlserver', 'sp_statement_completed', 'source_database_id', '', ''),
		('46', 'Object:Created', '21', 'EventSubClass', 'sqlserver', 'object_created', 'ddl_phase', '', ''),
		--('46', 'Object:Created', '25', 'IntegerData', 'sqlserver', 'object_created', '', 'package0', 'attach_activity_id'),
		('46', 'Object:Created', '28', 'ObjectType', 'sqlserver', 'object_created', 'object_type', '', ''),
		('46', 'Object:Created', '56', 'ObjectID2', 'sqlserver', 'object_created', 'related_object_id', '', ''),
		('47', 'Object:Deleted', '21', 'EventSubClass', 'sqlserver', 'object_deleted', 'ddl_phase', '', ''),
		--('47', 'Object:Deleted', '25', 'IntegerData', 'sqlserver', 'object_deleted', '', 'package0', 'attach_activity_id'),
		('47', 'Object:Deleted', '28', 'ObjectType', 'sqlserver', 'object_deleted', 'object_type', '', ''),
		('47', 'Object:Deleted', '56', 'ObjectID2', 'sqlserver', 'object_deleted', 'related_object_id', '', ''),
		('50', 'SQLTransaction', '21', 'EventSubClass', 'sqlserver', 'sql_transaction', 'transaction_state', '', ''),
		('50', 'SQLTransaction', '25', 'IntegerData', 'sqlserver', 'sql_transaction', 'transaction_type', '', ''),
		('53', 'CursorOpen', '25', 'IntegerData', 'sqlserver', 'cursor_open', 'cursor_type', '', ''),
		('53', 'CursorOpen', '33', 'Handle', 'sqlserver', 'cursor_open', 'protocol_execution_id', '', ''),
		('54', 'TransactionLog', '22', 'ObjectID', 'sqlserver', 'transaction_log', 'alloc_unit_id', '', ''),
		('54', 'TransactionLog', '24', 'IndexID', 'sqlserver', 'transaction_log', 'alloc_unit_id', '', ''),
		('55', 'Hash Warning', '21', 'EventSubClass', 'sqlserver', 'hash_warning', 'hash_warning_type', '', ''),
		('55', 'Hash Warning', '22', 'ObjectID', 'sqlserver', 'hash_warning', 'query_operation_node_id', '', ''),
		('55', 'Hash Warning', '25', 'IntegerData', 'sqlserver', 'hash_warning', 'recursion_level', '', ''),
		('58', 'Auto Stats', '1', 'TextData', 'sqlserver', 'auto_stats', 'statistics_list', '', ''),
		('58', 'Auto Stats', '21', 'EventSubClass', 'sqlserver', 'auto_stats', 'status', '', ''),
		('58', 'Auto Stats', '25', 'IntegerData', 'sqlserver', 'auto_stats', 'count', '', ''),
		('58', 'Auto Stats', '31', 'Error', 'sqlserver', 'auto_stats', 'last_error', '', ''),
		('58', 'Auto Stats', '55', 'IntegerData2', 'sqlserver', 'auto_stats', 'job_id', '', ''),
		('58', 'Auto Stats', '57', 'Type', 'sqlserver', 'auto_stats', 'job_type', '', ''),
		('59', 'Lock:Deadlock Chain', '1', 'TextData', 'sqlserver', 'lock_deadlock_chain', 'resource_description', '', ''),
		('59', 'Lock:Deadlock Chain', '2', 'BinaryData', 'sqlserver', 'lock_deadlock_chain', 'lockspace_workspace_id', '', ''),
		('59', 'Lock:Deadlock Chain', '21', 'EventSubClass', 'sqlserver', 'lock_deadlock_chain', 'resource_owner_type', '', ''),
		('59', 'Lock:Deadlock Chain', '25', 'IntegerData', 'sqlserver', 'lock_deadlock_chain', 'deadlock_id', '', ''),
		('59', 'Lock:Deadlock Chain', '56', 'ObjectID2', 'sqlserver', 'lock_deadlock_chain', 'associated_object_id', '', ''),
		('59', 'Lock:Deadlock Chain', '57', 'Type', 'sqlserver', 'lock_deadlock_chain', 'resource_type', '', ''),
		('59', 'Lock:Deadlock Chain', '58', 'OwnerID', 'sqlserver', 'lock_deadlock_chain', 'owner_type', '', ''),
		('60', 'Lock:Escalation', '1', 'TextData', 'sqlserver', 'lock_escalation', 'statement', '', ''),
		('60', 'Lock:Escalation', '21', 'EventSubClass', 'sqlserver', 'lock_escalation', 'escalation_cause', '', ''),
		('60', 'Lock:Escalation', '25', 'IntegerData', 'sqlserver', 'lock_escalation', 'hobt_lock_count', '', ''),
		('60', 'Lock:Escalation', '55', 'IntegerData2', 'sqlserver', 'lock_escalation', 'escalated_lock_count', '', ''),
		('60', 'Lock:Escalation', '56', 'ObjectID2', 'sqlserver', 'lock_escalation', 'hobt_id', '', ''),
		('60', 'Lock:Escalation', '57', 'Type', 'sqlserver', 'lock_escalation', 'resource_type', '', ''),
		('60', 'Lock:Escalation', '58', 'OwnerID', 'sqlserver', 'lock_escalation', 'owner_type', '', ''),
		('61', 'OLEDB Errors', '1', 'TextData', 'sqlserver', 'oledb_error', 'parameters', '', ''),
		('61', 'OLEDB Errors', '31', 'Error', 'sqlserver', 'oledb_error', 'hresult', '', ''),
		('61', 'OLEDB Errors', '45', 'LinkedServerName', 'sqlserver', 'oledb_error', 'linked_server_name', '', ''),
		('61', 'OLEDB Errors', '46', 'ProviderName', 'sqlserver', 'oledb_error', 'provider_name', '', ''),
		('61', 'OLEDB Errors', '47', 'MethodName', 'sqlserver', 'oledb_error', 'method_name', '', ''),
		('67', 'Execution Warnings', '1', 'TextData', 'sqlserver', 'execution_warning', 'server_memory_grants', '', ''),
		('67', 'Execution Warnings', '21', 'EventSubClass', 'sqlserver', 'execution_warning', 'warning_type', '', ''),
		('68', 'Showplan Text (Unencoded)', '1', 'TextData', 'sqlserver', 'query_pre_execution_showplan', 'showplan_xml', '', ''),
		('68', 'Showplan Text (Unencoded)', '2', 'BinaryData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_cost', '', ''),
		('68', 'Showplan Text (Unencoded)', '25', 'IntegerData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_rows', '', ''),
		('68', 'Showplan Text (Unencoded)', '28', 'ObjectType', 'sqlserver', 'query_pre_execution_showplan', 'object_type', '', ''),
		('68', 'Showplan Text (Unencoded)', '29', 'NestLevel', 'sqlserver', 'query_pre_execution_showplan', 'nest_level', '', ''),
		('69', 'Sort Warnings', '21', 'EventSubClass', 'sqlserver', 'sort_warning', 'sort_warning_type', '', ''),
		('70', 'CursorPrepare', '33', 'Handle', 'sqlserver', 'cursor_prepare', 'protocol_execution_id', '', ''),
		('71', 'Prepare SQL', '33', 'Handle', 'sqlserver', 'prepare_sql', 'statement_handle', '', ''),
		('72', 'Exec Prepared SQL', '33', 'Handle', 'sqlserver', 'exec_prepared_sql', 'statement_handle', '', ''),
		('73', 'Unprepare SQL', '33', 'Handle', 'sqlserver', 'unprepare_sql', 'statement_handle', '', ''),
		('74', 'CursorExecute', '25', 'IntegerData', 'sqlserver', 'cursor_execute', 'cursor_type', '', ''),
		('74', 'CursorExecute', '33', 'Handle', 'sqlserver', 'cursor_execute', 'protocol_execution_id', '', ''),
		('76', 'CursorImplicitConversion', '2', 'BinaryData', 'sqlserver', 'cursor_implicit_conversion', 'final_cursor_type', '', ''),
		('76', 'CursorImplicitConversion', '25', 'IntegerData', 'sqlserver', 'cursor_implicit_conversion', 'initial_cursor_type', '', ''),
		('76', 'CursorImplicitConversion', '33', 'Handle', 'sqlserver', 'cursor_implicit_conversion', 'protocol_execution_id', '', ''),
		('77', 'CursorUnprepare', '33', 'Handle', 'sqlserver', 'cursor_unprepare', 'protocol_execution_id', '', ''),
		('78', 'CursorClose', '33', 'Handle', 'sqlserver', 'cursor_close', 'protocol_execution_id', '', ''),
		('79', 'Missing Column Statistics', '1', 'TextData', 'sqlserver', 'missing_column_statistics', 'column_list', '', ''),
		('81', 'Server Memory Change', '21', 'EventSubClass', 'sqlserver', 'server_memory_change', 'memory_change', '', ''),
		('81', 'Server Memory Change', '25', 'IntegerData', 'sqlserver', 'server_memory_change', 'new_memory_size_mb', '', ''),
		('92', 'Data File Auto Grow', '25', 'IntegerData', 'sqlserver', 'database_file_size_change', 'size_change_kb', '', ''),
		('92', 'Data File Auto Grow', '36', 'FileName', 'sqlserver', 'database_file_size_change', 'file_name', '', ''),
		('93', 'Log File Auto Grow', '25', 'IntegerData', 'sqlserver', 'database_file_size_change', 'size_change_kb', '', ''),
		('93', 'Log File Auto Grow', '36', 'FileName', 'sqlserver', 'database_file_size_change', 'file_name', '', ''),
		('94', 'Data File Auto Shrink', '25', 'IntegerData', 'sqlserver', 'database_file_size_change', 'size_change_kb', '', ''),
		('94', 'Data File Auto Shrink', '36', 'FileName', 'sqlserver', 'database_file_size_change', 'file_name', '', ''),
		('95', 'Log File Auto Shrink', '25', 'IntegerData', 'sqlserver', 'database_file_size_change', 'size_change_kb', '', ''),
		('95', 'Log File Auto Shrink', '36', 'FileName', 'sqlserver', 'database_file_size_change', 'file_name', '', ''),
		('96', 'Showplan Text', '2', 'BinaryData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_cost', '', ''),
		('96', 'Showplan Text', '25', 'IntegerData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_rows', '', ''),
		('96', 'Showplan Text', '28', 'ObjectType', 'sqlserver', 'query_pre_execution_showplan', 'object_type', '', ''),
		('96', 'Showplan Text', '29', 'NestLevel', 'sqlserver', 'query_pre_execution_showplan', 'nest_level', '', ''),
		('97', 'Showplan All', '2', 'BinaryData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_cost', '', ''),
		('97', 'Showplan All', '25', 'IntegerData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_rows', '', ''),
		('97', 'Showplan All', '28', 'ObjectType', 'sqlserver', 'query_pre_execution_showplan', 'object_type', '', ''),
		('97', 'Showplan All', '29', 'NestLevel', 'sqlserver', 'query_pre_execution_showplan', 'nest_level', '', ''),
		('98', 'Showplan Statistics Profile', '2', 'BinaryData', 'sqlserver', 'query_post_execution_showplan', 'estimated_cost', '', ''),
		('98', 'Showplan Statistics Profile', '25', 'IntegerData', 'sqlserver', 'query_post_execution_showplan', 'estimated_rows', '', ''),
		('98', 'Showplan Statistics Profile', '28', 'ObjectType', 'sqlserver', 'query_post_execution_showplan', 'object_type', '', ''),
		('98', 'Showplan Statistics Profile', '29', 'NestLevel', 'sqlserver', 'query_post_execution_showplan', 'nest_level', '', ''),
		('100', 'RPC Output Parameter', '1', 'TextData', 'sqlserver', 'rpc_completed', 'output_parameters', '', ''),
		('119', 'OLEDB Call Event', '1', 'TextData', 'sqlserver', 'oledb_call', 'parameters', '', ''),
		('119', 'OLEDB Call Event', '21', 'EventSubClass', 'sqlserver', 'oledb_call', 'opcode', '', ''),
		('119', 'OLEDB Call Event', '31', 'Error', 'sqlserver', 'oledb_call', 'hresult', '', ''),
		('119', 'OLEDB Call Event', '45', 'LinkedServerName', 'sqlserver', 'oledb_call', 'linked_server_name', '', ''),
		('119', 'OLEDB Call Event', '46', 'ProviderName', 'sqlserver', 'oledb_call', 'provider_name', '', ''),
		('119', 'OLEDB Call Event', '47', 'MethodName', 'sqlserver', 'oledb_call', 'method_name', '', ''),
		('120', 'OLEDB QueryInterface Event', '1', 'TextData', 'sqlserver', 'oledb_query_interface', 'parameters', '', ''),
		('120', 'OLEDB QueryInterface Event', '21', 'EventSubClass', 'sqlserver', 'oledb_query_interface', 'opcode', '', ''),
		('120', 'OLEDB QueryInterface Event', '31', 'Error', 'sqlserver', 'oledb_query_interface', 'hresult', '', ''),
		('120', 'OLEDB QueryInterface Event', '45', 'LinkedServerName', 'sqlserver', 'oledb_query_interface', 'linked_server_name', '', ''),
		('120', 'OLEDB QueryInterface Event', '46', 'ProviderName', 'sqlserver', 'oledb_query_interface', 'provider_name', '', ''),
		('120', 'OLEDB QueryInterface Event', '47', 'MethodName', 'sqlserver', 'oledb_query_interface', 'method_name', '', ''),
		('121', 'OLEDB DataRead Event', '1', 'TextData', 'sqlserver', 'oledb_data_read', 'parameters', '', ''),
		('121', 'OLEDB DataRead Event', '21', 'EventSubClass', 'sqlserver', 'oledb_data_read', 'opcode', '', ''),
		('121', 'OLEDB DataRead Event', '31', 'Error', 'sqlserver', 'oledb_data_read', 'hresult', '', ''),
		('121', 'OLEDB DataRead Event', '45', 'LinkedServerName', 'sqlserver', 'oledb_data_read', 'linked_server_name', '', ''),
		('121', 'OLEDB DataRead Event', '46', 'ProviderName', 'sqlserver', 'oledb_data_read', 'provider_name', '', ''),
		('121', 'OLEDB DataRead Event', '47', 'MethodName', 'sqlserver', 'oledb_data_read', 'method_name', '', ''),
		('122', 'Showplan XML', '1', 'TextData', 'sqlserver', 'query_pre_execution_showplan', 'showplan_xml', '', ''),
		('122', 'Showplan XML', '2', 'BinaryData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_cost', '', ''),
		('122', 'Showplan XML', '25', 'IntegerData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_rows', '', ''),
		('122', 'Showplan XML', '28', 'ObjectType', 'sqlserver', 'query_pre_execution_showplan', 'object_type', '', ''),
		('122', 'Showplan XML', '29', 'NestLevel', 'sqlserver', 'query_pre_execution_showplan', 'nest_level', '', ''),
		('124', 'Broker:Conversation', '1', 'TextData', 'sqlserver', 'broker_conversation', 'conversation_state', '', ''),
		('124', 'Broker:Conversation', '21', 'EventSubClass', 'sqlserver', 'broker_conversation', 'conversation_action', '', ''),
		('124', 'Broker:Conversation', '34', 'ObjectName', 'sqlserver', 'broker_conversation', 'conversation_handle', '', ''),
		('124', 'Broker:Conversation', '38', 'RoleName', 'sqlserver', 'broker_conversation', 'is_initiator', '', ''),
		('124', 'Broker:Conversation', '42', 'TargetLoginName', 'sqlserver', 'broker_conversation', 'service_contract_name', '', ''),
		('124', 'Broker:Conversation', '47', 'MethodName', 'sqlserver', 'broker_conversation', 'conversation_group_id', '', ''),
		('124', 'Broker:Conversation', '54', 'GUID', 'sqlserver', 'broker_conversation', 'conversation_id', '', ''),
		('125', 'Deprecation Announcement', '1', 'TextData', 'sqlserver', 'deprecation_announcement', 'message', '', ''),
		('125', 'Deprecation Announcement', '22', 'ObjectID', 'sqlserver', 'deprecation_announcement', 'feature_id', '', ''),
		('125', 'Deprecation Announcement', '34', 'ObjectName', 'sqlserver', 'deprecation_announcement', 'feature', '', ''),
		('125', 'Deprecation Announcement', '55', 'IntegerData2', 'sqlserver', 'deprecation_announcement', '', 'sqlserver', 'tsql_frame'),
		('126', 'Deprecation Final Support', '1', 'TextData', 'sqlserver', 'deprecation_final_support', 'message', '', ''),
		('126', 'Deprecation Final Support', '22', 'ObjectID', 'sqlserver', 'deprecation_final_support', 'feature_id', '', ''),
		('126', 'Deprecation Final Support', '34', 'ObjectName', 'sqlserver', 'deprecation_final_support', 'feature', '', ''),
		('126', 'Deprecation Final Support', '55', 'IntegerData2', 'sqlserver', 'deprecation_final_support', '', 'sqlserver', 'tsql_frame'),
		('127', 'Exchange Spill Event', '21', 'EventSubClass', 'sqlserver', 'exchange_spill', 'opcode', '', ''),
		('127', 'Exchange Spill Event', '22', 'ObjectID', 'sqlserver', 'exchange_spill', 'query_operation_node_id', '', ''),
		('136', 'Broker:Conversation Group', '21', 'EventSubClass', 'sqlserver', 'broker_conversation_group', 'conversation_group_action', '', ''),
		('136', 'Broker:Conversation Group', '54', 'GUID', 'sqlserver', 'broker_conversation_group', 'conversation_group_id', '', ''),
		('137', 'Blocked process report', '1', 'TextData', 'sqlserver', 'blocked_process_report', 'blocked_process', '', ''),
		('137', 'Blocked process report', '32', 'Mode', 'sqlserver', 'blocked_process_report', 'lock_mode', '', ''),
		('138', 'Broker:Connection', '1', 'TextData', 'ucs', 'ucs_connection_setup', 'error_message', '', ''),
		('138', 'Broker:Connection', '21', 'EventSubClass', 'ucs', 'ucs_connection_setup', 'setup_event', '', ''),
		('138', 'Broker:Connection', '34', 'ObjectName', 'ucs', 'ucs_connection_setup', 'connection_id', '', ''),
		('138', 'Broker:Connection', '54', 'GUID', 'ucs', 'ucs_connection_setup', 'address', '', ''),
		('139', 'Broker:Forwarded Message Sent', '22', 'ObjectID', 'sqlserver', 'broker_forwarded_message_sent', 'time_to_live_sec', '', ''),
		('139', 'Broker:Forwarded Message Sent', '23', 'Success', 'sqlserver', 'broker_forwarded_message_sent', 'live_time_sec', '', ''),
		('139', 'Broker:Forwarded Message Sent', '24', 'IndexID', 'sqlserver', 'broker_forwarded_message_sent', 'remaining_hop_count', '', ''),
		('139', 'Broker:Forwarded Message Sent', '25', 'IntegerData', 'sqlserver', 'broker_forwarded_message_sent', 'fragment_number', '', ''),
		('139', 'Broker:Forwarded Message Sent', '36', 'FileName', 'sqlserver', 'broker_forwarded_message_sent', 'to_service_name', '', ''),
		('139', 'Broker:Forwarded Message Sent', '37', 'OwnerName', 'sqlserver', 'broker_forwarded_message_sent', 'to_broker_name', '', ''),
		('139', 'Broker:Forwarded Message Sent', '38', 'RoleName', 'sqlserver', 'broker_forwarded_message_sent', 'is_initiator', '', ''),
		('139', 'Broker:Forwarded Message Sent', '39', 'TargetUserName', 'sqlserver', 'broker_forwarded_message_sent', 'from_service_name', '', ''),
		('139', 'Broker:Forwarded Message Sent', '40', 'DBUserName', 'sqlserver', 'broker_forwarded_message_sent', 'from_broker_name', '', ''),
		('139', 'Broker:Forwarded Message Sent', '42', 'TargetLoginName', 'sqlserver', 'broker_forwarded_message_sent', 'to_broker_name', '', ''),
		('139', 'Broker:Forwarded Message Sent', '47', 'MethodName', 'sqlserver', 'broker_forwarded_message_sent', 'message_type_name', '', ''),
		('139', 'Broker:Forwarded Message Sent', '52', 'BigintData1', 'sqlserver', 'broker_forwarded_message_sent', 'message_sequence', '', ''),
		('139', 'Broker:Forwarded Message Sent', '54', 'GUID', 'sqlserver', 'broker_forwarded_message_sent', 'conversation_id', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '1', 'TextData', 'sqlserver', 'broker_forwarded_message_dropped', 'dropped_reason', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '20', 'Severity', 'sqlserver', 'broker_forwarded_message_dropped', 'error_severity', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '22', 'ObjectID', 'sqlserver', 'broker_forwarded_message_dropped', 'time_to_live_sec', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '24', 'IndexID', 'sqlserver', 'broker_forwarded_message_dropped', 'remaining_hop_count', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '25', 'IntegerData', 'sqlserver', 'broker_forwarded_message_dropped', 'fragment_number', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '30', 'State', 'sqlserver', 'broker_forwarded_message_dropped', 'error_state', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '36', 'FileName', 'sqlserver', 'broker_forwarded_message_dropped', 'to_service_name', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '37', 'OwnerName', 'sqlserver', 'broker_forwarded_message_dropped', 'to_broker_name', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '38', 'RoleName', 'sqlserver', 'broker_forwarded_message_dropped', 'is_initiator', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '39', 'TargetUserName', 'sqlserver', 'broker_forwarded_message_dropped', 'from_service_name', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '40', 'DBUserName', 'sqlserver', 'broker_forwarded_message_dropped', 'from_broker_name', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '42', 'TargetLoginName', 'sqlserver', 'broker_forwarded_message_dropped', 'to_broker_name', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '47', 'MethodName', 'sqlserver', 'broker_forwarded_message_dropped', 'message_type_name', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '52', 'BigintData1', 'sqlserver', 'broker_forwarded_message_dropped', 'message_sequence', '', ''),
		('140', 'Broker:Forwarded Message Dropped', '54', 'GUID', 'sqlserver', 'broker_forwarded_message_dropped', 'conversation_id', '', ''),
		('141', 'Broker:Message Classify', '21', 'EventSubClass', 'sqlserver', 'broker_message_classify', 'route_type', '', ''),
		('141', 'Broker:Message Classify', '31', 'Error', 'sqlserver', 'broker_message_classify', 'delayed_error_number', '', ''),
		('141', 'Broker:Message Classify', '36', 'FileName', 'sqlserver', 'broker_message_classify', 'to_service_name', '', ''),
		('141', 'Broker:Message Classify', '37', 'OwnerName', 'sqlserver', 'broker_message_classify', 'to_broker_instance', '', ''),
		('141', 'Broker:Message Classify', '38', 'RoleName', 'sqlserver', 'broker_message_classify', 'is_initiator', '', ''),
		('141', 'Broker:Message Classify', '45', 'LinkedServerName', 'sqlserver', 'broker_message_classify', 'message_source', '', ''),
		('141', 'Broker:Message Classify', '54', 'GUID', 'sqlserver', 'broker_message_classify', 'conversation_id', '', ''),
		('142', 'Broker:Transmission', '20', 'Severity', 'sqlserver', 'broker_transmission_exception', 'error_severity', '', ''),
		('142', 'Broker:Transmission', '30', 'State', 'sqlserver', 'broker_transmission_exception', 'error_state', '', ''),
		('146', 'Showplan XML Statistics Profile', '1', 'TextData', 'sqlserver', 'query_post_execution_showplan', 'showplan_xml', '', ''),
		('146', 'Showplan XML Statistics Profile', '2', 'BinaryData', 'sqlserver', 'query_post_execution_showplan', 'estimated_cost', '', ''),
		('146', 'Showplan XML Statistics Profile', '25', 'IntegerData', 'sqlserver', 'query_post_execution_showplan', 'estimated_rows', '', ''),
		('146', 'Showplan XML Statistics Profile', '28', 'ObjectType', 'sqlserver', 'query_post_execution_showplan', 'object_type', '', ''),
		('146', 'Showplan XML Statistics Profile', '29', 'NestLevel', 'sqlserver', 'query_post_execution_showplan', 'nest_level', '', ''),
		('148', 'Deadlock graph', '1', 'TextData', 'sqlserver', 'xml_deadlock_report', 'xml_report', '', ''),
		('149', 'Broker:Remote Message Acknowledgement', '21', 'EventSubClass', 'sqlserver', 'broker_remote_message_acknowledgement', 'acknowledgement_type', '', ''),
		('149', 'Broker:Remote Message Acknowledgement', '25', 'IntegerData', 'sqlserver', 'broker_remote_message_acknowledgement', 'acknowledgement_fragment_number', '', ''),
		('149', 'Broker:Remote Message Acknowledgement', '38', 'RoleName', 'sqlserver', 'broker_remote_message_acknowledgement', 'is_initiator', '', ''),
		('149', 'Broker:Remote Message Acknowledgement', '52', 'BigintData1', 'sqlserver', 'broker_remote_message_acknowledgement', 'acknowlegment_message_sequence', '', ''),
		('149', 'Broker:Remote Message Acknowledgement', '53', 'BigintData2', 'sqlserver', 'broker_remote_message_acknowledgement', 'message_sequence', '', ''),
		('149', 'Broker:Remote Message Acknowledgement', '54', 'GUID', 'sqlserver', 'broker_remote_message_acknowledgement', 'conversation_id', '', ''),
		('149', 'Broker:Remote Message Acknowledgement', '55', 'IntegerData2', 'sqlserver', 'broker_remote_message_acknowledgement', 'fragment_number', '', ''),
		('155', 'FT:Crawl Started', '1', 'TextData', 'sqlserver', 'full_text_crawl_started', 'crawl_operation', '', ''),
		('160', 'Broker:Message Undeliverable', '1', 'TextData', 'sqlserver', 'broker_message_undeliverable', 'message_drop_reason', '', ''),
		('160', 'Broker:Message Undeliverable', '20', 'Severity', 'sqlserver', 'broker_message_undeliverable', 'error_severity', '', ''),
		('160', 'Broker:Message Undeliverable', '21', 'EventSubClass', 'sqlserver', 'broker_message_undeliverable', 'sequenced_message', '', ''),
		('160', 'Broker:Message Undeliverable', '25', 'IntegerData', 'sqlserver', 'broker_message_undeliverable', 'message_fragment_number', '', ''),
		('160', 'Broker:Message Undeliverable', '30', 'State', 'sqlserver', 'broker_message_undeliverable', 'error_state', '', ''),
		('160', 'Broker:Message Undeliverable', '38', 'RoleName', 'sqlserver', 'broker_message_undeliverable', 'is_initiator', '', ''),
		('160', 'Broker:Message Undeliverable', '52', 'BigintData1', 'sqlserver', 'broker_message_undeliverable', 'message_sequence_number', '', ''),
		('160', 'Broker:Message Undeliverable', '53', 'BigintData2', 'sqlserver', 'broker_message_undeliverable', 'acknowledgement_sequence_number', '', ''),
		('160', 'Broker:Message Undeliverable', '54', 'GUID', 'sqlserver', 'broker_message_undeliverable', 'conversation_id', '', ''),
		('160', 'Broker:Message Undeliverable', '55', 'IntegerData2', 'sqlserver', 'broker_message_undeliverable', 'acknowledgement_fragment_number', '', ''),
		('161', 'Broker:Corrupted Message', '1', 'TextData', 'sqlserver', 'broker_corrupted_message', 'corruption_description', '', ''),
		('161', 'Broker:Corrupted Message', '20', 'Severity', 'sqlserver', 'broker_corrupted_message', 'error_severity', '', ''),
		('161', 'Broker:Corrupted Message', '30', 'State', 'sqlserver', 'broker_corrupted_message', 'error_state', '', ''),
		('162', 'User Error Message', '1', 'TextData', 'sqlserver', 'error_reported', 'message', '', ''),
		('163', 'Broker:Activation', '1', 'TextData', 'sqlserver', 'broker_activation', 'activation_message', '', ''),
		('163', 'Broker:Activation', '21', 'EventSubClass', 'sqlserver', 'broker_activation', 'activation_state', '', ''),
		('163', 'Broker:Activation', '22', 'ObjectID', 'sqlserver', 'broker_activation', 'queue_id', '', ''),
		('163', 'Broker:Activation', '25', 'IntegerData', 'sqlserver', 'broker_activation', 'active_task_count', '', ''),
		('164', 'Object:Altered', '21', 'EventSubClass', 'sqlserver', 'object_altered', 'ddl_phase', '', ''),
		--('164', 'Object:Altered', '25', 'IntegerData', 'sqlserver', 'object_altered', '', 'package0', 'attach_activity_id'),
		('164', 'Object:Altered', '28', 'ObjectType', 'sqlserver', 'object_altered', 'object_type', '', ''),
		('164', 'Object:Altered', '56', 'ObjectID2', 'sqlserver', 'object_altered', 'related_object_id', '', ''),
		('165', 'Performance statistics', '1', 'TextData', 'sqlserver', 'query_cache_removal_statistics', 'execution_statistics', '', ''),
		('165', 'Performance statistics', '1', 'TextData', 'sqlserver', 'query_pre_execution_showplan', 'showplan_xml', '', ''),
		('165', 'Performance statistics', '1', 'TextData', 'sqlserver', 'uncached_sql_batch_statistics', 'statement', '', ''),
		('165', 'Performance statistics', '2', 'BinaryData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_cost', '', ''),
		('165', 'Performance statistics', '22', 'ObjectID', 'sqlserver', 'query_cache_removal_statistics', 'compiled_object_id', '', ''),
		('165', 'Performance statistics', '25', 'IntegerData', 'sqlserver', 'query_cache_removal_statistics', 'begin_offset', '', ''),
		('165', 'Performance statistics', '25', 'IntegerData', 'sqlserver', 'query_pre_execution_showplan', 'estimated_rows', '', ''),
		('165', 'Performance statistics', '28', 'ObjectType', 'sqlserver', 'query_cache_removal_statistics', 'compiled_object_type', '', ''),
		('165', 'Performance statistics', '28', 'ObjectType', 'sqlserver', 'query_pre_execution_showplan', 'object_type', '', ''),
		('165', 'Performance statistics', '52', 'BigintData1', 'sqlserver', 'query_cache_removal_statistics', 'recompile_count', '', ''),
		('165', 'Performance statistics', '55', 'IntegerData2', 'sqlserver', 'query_cache_removal_statistics', 'end_offset', '', ''),
		('166', 'SQL:StmtRecompile', '1', 'TextData', 'sqlserver', 'sql_statement_recompile', 'statement', '', ''),
		('166', 'SQL:StmtRecompile', '21', 'EventSubClass', 'sqlserver', 'sql_statement_recompile', 'recompile_cause', '', ''),
		('166', 'SQL:StmtRecompile', '28', 'ObjectType', 'sqlserver', 'sql_statement_recompile', 'object_type', '', ''),
		('166', 'SQL:StmtRecompile', '29', 'NestLevel', 'sqlserver', 'sql_statement_recompile', 'nest_level', '', ''),
		('166', 'SQL:StmtRecompile', '55', 'IntegerData2', 'sqlserver', 'sql_statement_recompile', 'offset_end', '', ''),
		('167', 'Database Mirroring State Change', '1', 'TextData', 'sqlserver', 'database_mirroring_state_change', 'state_change_desc', '', ''),
		('167', 'Database Mirroring State Change', '25', 'IntegerData', 'sqlserver', 'database_mirroring_state_change', 'prior_state', '', ''),
		('167', 'Database Mirroring State Change', '30', 'State', 'sqlserver', 'database_mirroring_state_change', 'new_state', '', ''),
		('168', 'Showplan XML For Query Compile', '1', 'TextData', 'sqlserver', 'query_post_compilation_showplan', 'showplan_xml', '', ''),
		('168', 'Showplan XML For Query Compile', '2', 'BinaryData', 'sqlserver', 'query_post_compilation_showplan', 'estimated_cost', '', ''),
		('168', 'Showplan XML For Query Compile', '25', 'IntegerData', 'sqlserver', 'query_post_compilation_showplan', 'estimated_rows', '', ''),
		('168', 'Showplan XML For Query Compile', '28', 'ObjectType', 'sqlserver', 'query_post_compilation_showplan', 'object_type', '', ''),
		('168', 'Showplan XML For Query Compile', '29', 'NestLevel', 'sqlserver', 'query_post_compilation_showplan', 'nest_level', '', ''),
		('169', 'Showplan All For Query Compile', '2', 'BinaryData', 'sqlserver', 'query_post_compilation_showplan', 'estimated_cost', '', ''),
		('169', 'Showplan All For Query Compile', '25', 'IntegerData', 'sqlserver', 'query_post_compilation_showplan', 'estimated_rows', '', ''),
		('169', 'Showplan All For Query Compile', '28', 'ObjectType', 'sqlserver', 'query_post_compilation_showplan', 'object_type', '', ''),
		('169', 'Showplan All For Query Compile', '29', 'NestLevel', 'sqlserver', 'query_post_compilation_showplan', 'nest_level', '', ''),
		('181', 'TM: Begin Tran starting', '1', 'TextData', 'sqlserver', 'begin_tran_starting', 'statement', '', ''),
		('182', 'TM: Begin Tran completed', '1', 'TextData', 'sqlserver', 'begin_tran_completed', 'statement', '', ''),
		('184', 'TM: Promote Tran completed', '2', 'BinaryData', 'sqlserver', 'promote_tran_completed', 'dtc_trasaction_token', '', ''),
		('185', 'TM: Commit Tran starting', '1', 'TextData', 'sqlserver', 'commit_tran_starting', 'statement', '', ''),
		('185', 'TM: Commit Tran starting', '21', 'EventSubClass', 'sqlserver', 'commit_tran_starting', 'new_transaction_started', '', ''),
		('186', 'TM: Commit Tran completed', '1', 'TextData', 'sqlserver', 'commit_tran_completed', 'statement', '', ''),
		('186', 'TM: Commit Tran completed', '21', 'EventSubClass', 'sqlserver', 'commit_tran_completed', 'new_transaction_started', '', ''),
		('187', 'TM: Rollback Tran starting', '1', 'TextData', 'sqlserver', 'rollback_tran_starting', 'statement', '', ''),
		('187', 'TM: Rollback Tran starting', '21', 'EventSubClass', 'sqlserver', 'rollback_tran_starting', 'new_transaction_started', '', ''),
		('188', 'TM: Rollback Tran completed', '1', 'TextData', 'sqlserver', 'rollback_tran_completed', 'statement', '', ''),
		('188', 'TM: Rollback Tran completed', '21', 'EventSubClass', 'sqlserver', 'rollback_tran_completed', 'new_transaction_started', '', ''),
		('189', 'Lock:Timeout (timeout &gt; 0)', '1', 'TextData', 'sqlserver', 'lock_timeout_greater_than_0', 'resource_description', '', ''),
		('189', 'Lock:Timeout (timeout &gt; 0)', '2', 'BinaryData', 'sqlserver', 'lock_timeout_greater_than_0', 'lockspace_workspace_id', '', ''),
		('189', 'Lock:Timeout (timeout &gt; 0)', '56', 'ObjectID2', 'sqlserver', 'lock_timeout_greater_than_0', 'associated_object_id', '', ''),
		('189', 'Lock:Timeout (timeout &gt; 0)', '57', 'Type', 'sqlserver', 'lock_timeout_greater_than_0', 'resource_type', '', ''),
		('189', 'Lock:Timeout (timeout &gt; 0)', '58', 'OwnerID', 'sqlserver', 'lock_timeout_greater_than_0', 'owner_type', '', ''),
		('190', 'Progress Report: Online Index Operation', '21', 'EventSubClass', 'sqlserver', 'progress_report_online_index_operation', 'build_stage', '', ''),
		('190', 'Progress Report: Online Index Operation', '52', 'BigintData1', 'sqlserver', 'progress_report_online_index_operation', 'rows_inserted', '', ''),
		('190', 'Progress Report: Online Index Operation', '53', 'BigintData2', 'sqlserver', 'progress_report_online_index_operation', 'parallel_process_thread_id', '', ''),
		('191', 'TM: Save Tran starting', '1', 'TextData', 'sqlserver', 'save_tran_starting', 'statement', '', ''),
		('192', 'TM: Save Tran completed', '1', 'TextData', 'sqlserver', 'save_tran_completed', 'statement', '', ''),
		('193', 'Background Job Error', '20', 'Severity', 'sqlserver', 'background_job_error', 'error_severity', '', ''),
		('193', 'Background Job Error', '21', 'EventSubClass', 'sqlserver', 'background_job_error', 'job_failure_type', '', ''),
		('193', 'Background Job Error', '25', 'IntegerData', 'sqlserver', 'background_job_error', 'retries', '', ''),
		('193', 'Background Job Error', '30', 'State', 'sqlserver', 'background_job_error', 'error_state', '', ''),
		('193', 'Background Job Error', '55', 'IntegerData2', 'sqlserver', 'background_job_error', 'job_id', '', ''),
		('193', 'Background Job Error', '57', 'Type', 'sqlserver', 'background_job_error', 'job_type', '', ''),
		('194', 'OLEDB Provider Information', '1', 'TextData', 'sqlserver', 'oledb_provider_information', 'parameters', '', ''),
		('194', 'OLEDB Provider Information', '45', 'LinkedServerName', 'sqlserver', 'oledb_provider_information', 'linked_server_name', '', ''),
		('194', 'OLEDB Provider Information', '46', 'ProviderName', 'sqlserver', 'oledb_provider_information', 'provider_name', '', ''),
		('196', 'Assembly Load', '1', 'TextData', 'sqlserver', 'assembly_load', 'success', '', ''),
		('196', 'Assembly Load', '22', 'ObjectID', 'sqlserver', 'assembly_load', 'assembly_id', '', ''),
		('196', 'Assembly Load', '34', 'ObjectName', 'sqlserver', 'assembly_load', 'assembly_name', '', ''),
		('198', 'XQuery Static Type', '1', 'TextData', 'sqlserver', 'xquery_static_type', 'inferred_type', '', ''),
		('198', 'XQuery Static Type', '47', 'MethodName', 'sqlserver', 'xquery_static_type', 'oledb_method', '', ''),
		('199', 'QN: Subscription', '1', 'TextData', 'sqlserver', 'qn_subscription', 'query_notification_xml_information', '', ''),
		('199', 'QN: Subscription', '21', 'EventSubClass', 'sqlserver', 'qn_subscription', 'activity', '', ''),
		('200', 'QN: Parameter table', '1', 'TextData', 'sqlserver', 'qn_parameter_table', 'query_notification_xml_information', '', ''),
		('200', 'QN: Parameter table', '21', 'EventSubClass', 'sqlserver', 'qn_parameter_table', 'activity', '', ''),
		('201', 'QN: Template', '1', 'TextData', 'sqlserver', 'qn_template', 'query_notification_xml_information', '', ''),
		('201', 'QN: Template', '21', 'EventSubClass', 'sqlserver', 'qn_template', 'activity', '', ''),
		('202', 'QN: Dynamics', '1', 'TextData', 'sqlserver', 'qn_dynamics', 'query_notification_xml_information', '', ''),
		('202', 'QN: Dynamics', '21', 'EventSubClass', 'sqlserver', 'qn_dynamics', 'activity', '', ''),
		('212', 'Bitmap Warning', '22', 'ObjectID', 'sqlserver', 'bitmap_disabled_warning', 'query_operation_node_id', '', ''),
		('213', 'Database Suspect Data Page', '31', 'Error', 'sqlserver', 'database_suspect_data_page', 'page_error', '', ''),
		('214', 'CPU threshold exceeded', '58', 'OwnerID', 'sqlserver', 'cpu_threshold_exceeded', 'session_id', '', ''),
		('215', 'PreConnect:Starting', '21', 'EventSubClass', 'sqlserver', 'preconnect_starting', 'preconnect_type', '', ''),
		('215', 'PreConnect:Starting', '28', 'ObjectType', 'sqlserver', 'preconnect_starting', 'object_type', '', ''),
		('216', 'PreConnect:Completed', '21', 'EventSubClass', 'sqlserver', 'preconnect_completed', 'preconnect_type', '', ''),
		('216', 'PreConnect:Completed', '28', 'ObjectType', 'sqlserver', 'preconnect_completed', 'object_type', '', ''),
		('216', 'PreConnect:Completed', '30', 'State', 'sqlserver', 'preconnect_completed', 'error_state', '', ''),
		('216', 'PreConnect:Completed', '39', 'TargetUserName', 'sqlserver', 'preconnect_completed', 'workload_group_name', '', '')
) AS tab (trace_event_id, trace_event_name, trace_column_id, trace_column_name, event_package_name, xe_event_name, column_name, action_package_name, xe_action_name)

-- Create table variable to hold the trace definition
DECLARE @TraceInfo TABLE
(
	eventid INT,
	te_name NVARCHAR(128) COLLATE SQL_Latin1_General_CP1_CI_AS,
	columnid INT,
	columnname NVARCHAR(128) COLLATE SQL_Latin1_General_CP1_CI_AS,
	event_package_name NVARCHAR(128) COLLATE SQL_Latin1_General_CP1_CI_AS,
	xe_event_name NVARCHAR(128) COLLATE SQL_Latin1_General_CP1_CI_AS,
	column_name NVARCHAR(128) COLLATE SQL_Latin1_General_CP1_CI_AS,
	action_package_name NVARCHAR(128) COLLATE SQL_Latin1_General_CP1_CI_AS,
	xe_action_name NVARCHAR(128) COLLATE SQL_Latin1_General_CP1_CI_AS,
	filter_operator NVARCHAR(128) COLLATE SQL_Latin1_General_CP1_CI_AS,
	filter_value sql_variant 
)

-- Query the trace functions to get the trace definition 
INSERT INTO @TraceInfo 
	(eventid, te_name, columnid, columnname, event_package_name, xe_event_name, 
	 column_name, action_package_name, xe_action_name, filter_operator, filter_value)
SELECT 
	eventid,
	te.name,
	tgei.columnid,
	tc.name,
	event_package_name,
	xe_event_name,
	column_name,
	action_package_name,
	xe_action_name,
	CASE comparison_operator
		WHEN 0 THEN '='
		WHEN 1 THEN '&lt;&gt;'
		WHEN 2 THEN '&gt;'
		WHEN 3 THEN '&lt;'
		WHEN 4 THEN '&gt;='
		WHEN 5 THEN '&lt;='
		WHEN 6 THEN 'LIKE'
		WHEN 7 THEN 'NOT LIKE'
	END AS filter_operator,
	value AS filter_value
FROM sys.fn_trace_geteventinfo(@TraceID) AS tgei
LEFT JOIN sys.fn_trace_getfilterinfo(@TraceID) AS tfgi
	ON tgei.columnid = tfgi.columnid
		AND CAST(value AS NVARCHAR) NOT LIKE 'SQL Server Profiler%'
JOIN sys.trace_columns AS tc
	ON tgei.columnid = tc.trace_column_id
JOIN sys.trace_events AS te
	ON tgei.eventid = te.trace_event_id
LEFT JOIN [#SQLskills_Trace_XE_Column_Map] AS txcm
	ON tgei.eventid = txcm.trace_event_id
		AND tgei.columnid = txcm.trace_column_id
ORDER BY tgei.eventid, tgei.columnid

-- Generate the drop command for the Event Session if it already exists
DECLARE @DropCmd NVARCHAR(MAX) = 'IF EXISTS (SELECT 1 FROM sys.server_event_sessions WHERE name = '''+@SessionName+''')' + CHAR(10) +
'	DROP EVENT SESSION '+QUOTENAME(@SessionName)+' ON SERVER;' + CHAR(10)

-- Execute the drop command if @Execute = 1
IF @Execute = 1
	EXECUTE(@DropCmd);

-- Generate the start of the create statement for the Event Sesssion
DECLARE @sqlcmd NVARCHAR(MAX) = 'CREATE EVENT SESSION '+QUOTENAME(@SessionName)+ CHAR(10) +
'ON SERVER' + CHAR(10)

DECLARE @event_list NVARCHAR(MAX) = ''

-- Generate the Event list DDL definition for the event session
SELECT @event_list = @event_list + 
-- Add Events to Session
	CASE 
		WHEN event_package_name IS NULL 
			THEN '/* ' + tab.te_name + ' is not implemented in Extended Events it may be a Server Audit Event */' + CHAR(10)
		WHEN event_package_name IS NOT NULL AND RowID &lt;&gt; 1
			THEN '/* ' + tab.te_name + ' is implemented as the ' + tab.event_package_name + '.' + tab.xe_event_name + ' event in Extended Events */' + CHAR(10)
		ELSE
			'ADD EVENT ' + event_package_name + '.' + xe_event_name + '(' + CHAR(10) +
				-- Determine whether to create an Action List for Event
				CASE 
					WHEN NOT EXISTS (SELECT 1
										FROM @TraceInfo AS ti
										WHERE ti.eventid = tab.eventid
										  AND column_name IS NULL)
						OR RowID &lt;&gt; 1
						THEN ''
					ELSE 
						-- Build Action List for Event
						CHAR(9) + 'ACTION ' + CHAR(10) +
						CHAR(9) + '(' + CHAR(10) +
						STUFF((
								SELECT 
									CASE 
										WHEN action_package_name IS NULL AND columnname NOT IN ('StartTime', 'EndTime')
											THEN CHAR(9) + CHAR(9) + CHAR(9) + '-- ' + columnname + ' not implemented in XE for this event' + CHAR(10)
										ELSE CHAR(9) + CHAR(9) + CHAR(9) + ', '+ action_package_name + '.' + xe_action_name  + CHAR(9) + '-- ' + columnname + ' from SQLTrace' + CHAR(10)
									END
								FROM @TraceInfo AS ti
								WHERE ti.eventid = tab.eventid
								  AND column_name IS NULL
								ORDER BY CASE WHEN xe_action_name IS NULL THEN 1 ELSE 0 END, xe_action_name
								FOR XML PATH('')), 1, 4, CHAR(9) + CHAR(9) + CHAR(9)+' ') -- Actions
						+ CHAR(9) + ')' + CHAR(10) 
				END +
			-- Build in Predicate information
				CASE 
					WHEN NOT EXISTS (SELECT 1
										FROM @TraceInfo AS ti
										WHERE ti.eventid = tab.eventid
										  AND filter_operator IS NOT NULL)
						THEN ''
					ELSE 
						CHAR(9) + 'WHERE ' + CHAR(10) +
						CHAR(9) + '(' + CHAR(10) +
						REPLACE(
							REPLACE(
								STUFF(
										(
											SELECT 
												CASE 
													WHEN action_package_name IS NULL 
														THEN CHAR(9) + CHAR(9) + CHAR(9) + 'AND ' + column_name + ' ' + filter_operator + ' ' + 
															CASE 
																WHEN SQL_VARIANT_PROPERTY(filter_value, 'BaseType') IN ('nvarchar', 'varchar', 'char', 'nchar') 
																	THEN '''%'+CAST(filter_value AS NVARCHAR)+'%'''
																ELSE CAST(filter_value AS NVARCHAR)
															END + CHAR(10)
													ELSE CHAR(9) + CHAR(9) + CHAR(9) + 'AND '+ action_package_name + '.' + xe_action_name + ' ' + filter_operator + ' ' + 
															CASE 
																WHEN SQL_VARIANT_PROPERTY(filter_value, 'BaseType') IN ('nvarchar', 'varchar', 'char', 'nchar') 
																	THEN '''%'+CAST(filter_value AS NVARCHAR)+'%'''
																ELSE CAST(filter_value AS NVARCHAR)
															END + CHAR(10)
												END
											FROM @TraceInfo AS ti
											WHERE ti.eventid = tab.eventid
											  AND filter_operator IS NOT NULL
											ORDER BY xe_action_name
											FOR XML PATH('')
										), 1, 7, CHAR(9) + CHAR(9) + CHAR(9)+'')
									, '&amp;gt;', '&gt;')
								, '&amp;lt;', '&lt;') -- Predicates
						+ CHAR(9) + ')' 
				END 
		+ CHAR(10) + '),' + CHAR(10)
	END
FROM
(	
	SELECT eventid, te_name, event_package_name, xe_event_name, ROW_NUMBER() OVER (PARTITION BY event_package_name, xe_event_name ORDER BY eventid) AS RowID
	FROM
	(
		SELECT DISTINCT eventid, te_name, event_package_name, xe_event_name, ROW_NUMBER() OVER (PARTITION BY eventid ORDER BY event_package_name DESC) AS Row_ID
		FROM @TraceInfo
	) AS tab2
	WHERE Row_ID = 1
) AS tab;

-- Add Event List to the output command
SET @sqlcmd = @sqlcmd + SUBSTRING(@event_list, 0, LEN(@event_list)-1)+CHAR(10)

-- Add target definitions to the output command based on trace configuration
SELECT @sqlcmd = @sqlcmd + 
CASE 
	WHEN path IS NULL THEN 'ADD TARGET package0.ring_buffer' + CHAR(10)
	ELSE 
'ADD TARGET package0.event_file' + CHAR(10) +
'(' + CHAR(10) +
'	SET filename = '''+ SUBSTRING(path, 0, LEN(path)-CHARINDEX('\', REVERSE(path))+1) + '\'+@SessionName+'.xel'',' + CHAR(10) +
'		max_file_size = ' + CAST(max_size AS NVARCHAR) + ',' + CHAR(10) +
'		max_rollover_files = ' + CAST(max_files AS NVARCHAR) + CHAR(10) +
')' + CHAR(10) 
END
FROM sys.traces   
WHERE id = @TraceID

-- Print the DDL for the Event Session
IF @PrintOutput = 1
BEGIN
	DECLARE @Position INT = 1, 
			@Next INT = 0, 
			@Delimeter NCHAR(1) = CHAR(10),
			@WorkString VARCHAR(MAX) = @DropCmd + 'GO' + CHAR(10) + @sqlcmd;

	WHILE (1 = 1)
	BEGIN
		SELECT @Next = CHARINDEX(@Delimeter, @WorkString, @Position)

		IF (@Next = 0) 
			BREAK

		IF (@Position &lt;&gt; @Next)
			PRINT SUBSTRING(@WorkString, @Position, @Next - @Position)

		SELECT @Position = @Next + 1
    END
END

-- Execute the DDL the create the Event Session on the Server
IF @Execute = 1
BEGIN
	EXECUTE(@sqlcmd);
END

Quit:

GO

-- Mark the SP as a system object
EXEC sys.sp_MS_marksystemobject prj_0000_SP_202_ConvertTraceToExtendedEvents;
GO 

-- Test the procedure
--GO

--EXECUTE sp_SQLskills_ConvertTraceToExtendedEvents 
--		@TraceID = 1, 
--		@SessionName = 'XE_Default_Trace', 
--		@PrintOutput = 1, 
--		@Execute = 0;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Extended_Events_and_Trace_Profiler</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>01_ConvertTraceToExtendedEvents___EXAMPLE_of_a_Trace</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Extended_Events_and_Trace_Profiler</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>01_ConvertTraceToExtendedEvents___EXAMPLE_of_a_Trace</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>01_ConvertTraceToExtendedEvents___EXAMPLE_of_a_Trace


--This is an example of the original scripted Trace, it both creates the Trace and starts it


/****************************************************/
/* Created by: SQL Server 2012  Profiler          */
/* Date: 05/17/2016  11:06:31 PM         */
/****************************************************/


-- Create a Queue
declare @rc int
declare @TraceID int
declare @maxfilesize bigint
set @maxfilesize = 100 

-- Please replace the text InsertFileNameHere, with an appropriate
-- filename prefixed by a path, e.g., c:\MyFolder\MyTrace. The .trc extension
-- will be appended to the filename automatically. If you are writing from
-- remote server to local drive, please use UNC path and make sure server has
-- write access to your network share

--exec @rc = sp_trace_create @TraceID output, 0, N'InsertFileNameHere', @maxfilesize, NULL 			--&lt;===== Original Line
exec @rc = sp_trace_create @TraceID output, 0, N'C:\Pluralsight\XE\PSDemo1', @maxfilesize, NULL 		--&lt;== This is a .trc file b/ you don't have to include the extension
if (@rc != 0) goto error

-- Client side File and Table cannot be scripted

-- Set the events
declare @on bit
set @on = 1
												--eventid 10 = RPC: Completed
exec sp_trace_setevent @TraceID, 10, 1, @on		--columnid 1 = TextData			--&lt;=== So this is for a completed RPC, and TextData Column
exec sp_trace_setevent @TraceID, 10, 9, @on		--columnid 9 = ClientProcessID
exec sp_trace_setevent @TraceID, 10, 10, @on	--columnid 10 = ApplicationName
exec sp_trace_setevent @TraceID, 10, 3, @on		--columnid 3 = DatabaseID
exec sp_trace_setevent @TraceID, 10, 11, @on	--columnid 11 = loginID
exec sp_trace_setevent @TraceID, 10, 12, @on	--columnid 12 = SPID
exec sp_trace_setevent @TraceID, 10, 13, @on	--columnid 13 = Duration
exec sp_trace_setevent @TraceID, 10, 14, @on	--columnid 14 = StartTime
exec sp_trace_setevent @TraceID, 10, 15, @on	--columnid 15 = EndTime
exec sp_trace_setevent @TraceID, 10, 16, @on	--columnid 16 = Reads
exec sp_trace_setevent @TraceID, 10, 17, @on	--columnid 17 = Writes
exec sp_trace_setevent @TraceID, 10, 18, @on	--columnid 18 = CPU
exec sp_trace_setevent @TraceID, 10, 26, @on	--columnid 26 = ServerName

												--eventid 41 = SQL:StatementCompleted
exec sp_trace_setevent @TraceID, 41, 1, @on	
exec sp_trace_setevent @TraceID, 41, 9, @on
exec sp_trace_setevent @TraceID, 41, 3, @on
exec sp_trace_setevent @TraceID, 41, 10, @on
exec sp_trace_setevent @TraceID, 41, 11, @on
exec sp_trace_setevent @TraceID, 41, 12, @on
exec sp_trace_setevent @TraceID, 41, 13, @on
exec sp_trace_setevent @TraceID, 41, 14, @on
exec sp_trace_setevent @TraceID, 41, 15, @on
exec sp_trace_setevent @TraceID, 41, 16, @on
exec sp_trace_setevent @TraceID, 41, 17, @on
exec sp_trace_setevent @TraceID, 41, 18, @on
exec sp_trace_setevent @TraceID, 41, 26, @on


-- Set the Filters
declare @intfilter int
declare @bigintfilter bigint

exec sp_trace_setfilter @TraceID, 10, 0, 7, N'SQL Server Profiler - 61a3cdc0-1d56-474e-b517-0dea8cd779db'

--reads filter
--remove reads filter before running workload!
set @bigintfilter = 10000
exec sp_trace_setfilter @TraceID, 16, 0, 4, @bigintfilter


-- Set the trace status to start
exec sp_trace_setstatus @TraceID, 1


-- display trace id for future references
select TraceID=@TraceID
goto finish

error: 
select ErrorCode=@rc

finish: 
go

/*
--select * from sys.fn_trace_getinfo(0)			--&lt;== gives summary of all the traces that are running

-- exec sp_trace_setstatus 2, 0
-- exec sp_trace_setstatus 2, 2


--delete file before re-run script to create XE session
--remove filter before re-run when comparing
*/</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Extended_Events_and_Trace_Profiler</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>monitoring log activity with Extended Events</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Extended_Events_and_Trace_Profiler</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>monitoring log activity with Extended Events</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--https://www.sqlskills.com/blogs/paul/t-sql-tuesday-67-monitoring-log-activity-with-extended-events/

--Yesterday in class I was discussing monitoring transaction log activity with a student,
--to show that when a transaction commits, there is a write to the transaction log file. 
--This is easy to do with Extended Events.

--I’m going to use the file_write_completed event to track writes occurring 
--and the transaction_log event to watch log records being generated so we can see transactions committing.

--First of all I’ll setup my simple scenario:

USE [master];
GO
 
IF DATABASEPROPERTYEX (N'Test', N'Version') &gt; 0
BEGIN
    ALTER DATABASE [Test] SET SINGLE_USER
        WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [Test];
END
GO
 
CREATE DATABASE [Test] ON PRIMARY (
    NAME = N'Test_data',
    FILENAME = N'D:\SQLskills\Test_data.mdf')
LOG ON (
    NAME = N'Test_log',
    FILENAME = N'C:\SQLskills\Test_log.ldf',
    SIZE = 1MB,
    FILEGROWTH = 0MB);
GO
 
USE [test];
GO
 
CREATE TABLE TestTable (
    c1 INT IDENTITY,
    c2 CHAR (1000) DEFAULT 'a');
GO
 
INSERT INTO [TestTable] DEFAULT VALUES;
GO
And here’s the simple Extended Event session:

-- Drop the session if it exists. 
IF EXISTS (
    SELECT * FROM sys.server_event_sessions
        WHERE [name] = N'MonitorLog')
    DROP EVENT SESSION [MonitorLog] ON SERVER
GO
 
-- Create the event session
CREATE EVENT SESSION [MonitorLog] ON SERVER
    ADD EVENT [sqlserver].[file_write_completed],
    ADD EVENT [sqlserver].[transaction_log]
    ADD TARGET [package0].[ring_buffer]
        WITH (MAX_MEMORY = 50MB, max_dispatch_latency = 1 seconds)
GO
 
-- Start the session
ALTER EVENT SESSION [MonitorLog] ON SERVER
STATE = START;
GO

--I ran both of those scripts, then executed the INSERT a few times.

--Now if I go to Object Explorer, 
--I can use the Live Data Viewer (in SQL Server 2012 onwards). 
--Find the session, right-click on it and select Watch Live Data.

--Choose the following columns to view (right click on any column name and select Choose Columns…): 
--	name, timestamp, database_id, file_id, size, operation.

--And then run another INSERT (you might have to run two to make the first set of data show in the Viewer)
--and you’ll see data like below.

--Is this a bug that i cannot locate transaction_log under the GUI for XEvents even in SQL Server 2014? I wonder how many more events are there…..
--No – it’s by design. Use New Session and then click Channel and tick the Debug box. Then all events will show up.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions_WINDOW_FUNCTIONS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Cumulative_example_CumulativeAge_and_CumulativeAgeByGender</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions_WINDOW_FUNCTIONS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Cumulative_example_CumulativeAge_and_CumulativeAgeByGender</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Cumulative_example_CumulativeAge_and_CumulativeAgeByGender

--Calculating Running Total with OVER Clause and PARTITION BY Clause in SQL Server
--https://codingsight.com/calculating-running-total-with-over-clause-and-partition-by-clause-in-sql-server/


USE RiskMngt
GO

CREATE TABLE junk
(
	Id INT PRIMARY KEY IDENTITY,
	StudentName VARCHAR (50),
	StudentGender VARCHAR (50),
	StudentAge INT
)
GO

INSERT INTO junk VALUES ('Sally', 'Female', 14 )
INSERT INTO junk VALUES ('Edward', 'Male', 12 )
INSERT INTO junk VALUES ('Jon', 'Male', 13 )
INSERT INTO junk VALUES ('Liana', 'Female', 10 )
INSERT INTO junk VALUES ('Ben', 'Male', 11 )
INSERT INTO junk VALUES ('Elice', 'Female', 12 )
INSERT INTO junk VALUES ('Nick', 'Male', 9 )
INSERT INTO junk VALUES ('Josh', 'Male', 12 )
INSERT INTO junk VALUES ('Liza', 'Female', 10 )
INSERT INTO junk VALUES ('Wick', 'Male', 15 )

SELECT *
From Junk

/*
OUTPUT
----------------------------------------------
Id	StudentName	StudentGender	StudentAge
1	Sally	Female	14
2	Edward	Male	12
3	Jon		Male	13
4	Liana	Female	10
5	Ben		Male	11
6	Elice	Female	12
7	Nick	Male	9
8	Josh	Male	12
9	Liza	Female	10
10	Wick	Male	15
*/

/*
To calculate the running total, we have to use an OVER clause and adds the column which we want to calculate the running total for. 
The following script calculates the running total of the values in the StudentAge column and adds the result to the RunningAgeTotal column.
the OVER clause determines that the addition should be performed in the form of running total ordered by the Id column.
*/
SELECT Id, StudentName, StudentGender, StudentAge,
SUM (StudentAge) OVER (ORDER BY Id) AS RunningAgeTotal
FROM junk

/*
OUPUT
--------------------------------------------------------
Id	StudentName	StudentGender	StudentAge	RunningAgeTotal
1	Sally		Female			14			14
2	Edward		Male			12			26
3	Jon			Male			13			39
4	Liana		Female			10			49
5	Ben			Male			11			60
6	Elice		Female			12			72
7	Nick		Male			9			81
8	Josh		Male			12			93
9	Liza		Female			10			103
10	Wick		Male			15			118
--------------------------------------------------------
*/

/* 
Running AVERAGE, rather than just SUM
*/


SELECT Id, StudentName, StudentGender, StudentAge,
SUM(StudentAge) OVER (ORDER BY Id) AS RunningAgeTotal,
AVG(StudentAge) OVER (ORDER BY Id) AS RunningAgeAverage
FROM junk

/*
Partitioning Running Total by Column Values (e.g. running SUM, by GENDER
*/



SELECT Id, StudentName, StudentGender, StudentAge,
SUM (StudentAge) OVER (PARTITION BY StudentGender ORDER BY Id) AS RunningAgeTotal
FROM junk

/*
OUPUT
----------------------------------------------------------------
Id	StudentName	StudentGender	StudentAge	RunningAgeTotal
1	Sally		Female			14			14
4	Liana		Female			10			24
6	Elice		Female			12			36
9	Liza		Female			10			46
2	Edward		Male			12			12
3	Jon			Male			13			25
5	Ben			Male			11			36
7	Nick		Male			9			45
8	Josh		Male			12			57
10	Wick		Male			15			72
----------------------------------------------------------------
*/

/*
Problems with OVER when a Column has a Duplicate Column
A problem arises if a column with duplicate values is used with an OVER clause in order to calculate a  running total.

*/


SELECT Id, StudentName, StudentGender, StudentAge,
SUM (StudentAge) OVER (ORDER BY StudentAge) AS RunningAgeTotal
FROM junk

/*
OUTPUT
--------------------------------------------------------------
Id	StudentName	StudentGender	StudentAge	RunningAgeTotal
7	Nick		Male			9			9
9	Liza		Female			10			29	--&lt;===
4	Liana		Female			10			29	--&lt;===
5	Ben			Male			11			40
6	Elice		Female			12			76	--&lt;===
2	Edward		Male			12			76	--&lt;===
8	Josh		Male			12			76	--&lt;===
3	Jon			Male			13			89
1	Sally		Female			14			103
10	Wick		Male			15			118
--------------------------------------------------------------
*/</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions_WINDOW_FUNCTIONS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>MIN_WHERE_aField_equals_some_Value</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions_WINDOW_FUNCTIONS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>MIN_WHERE_aField_equals_some_Value</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://stackoverflow.com/questions/41479161/select-min-dateusing-window-function-and-max-datewith-related-field-using-joi


THE PROBLEM
==========================================
Table T1

+----+------------+------------+--------+------+
| ID |   Sdate    |   Edate    | Reason | Type |
+----+------------+------------+--------+------+
|  1 | 5/30/2016  |            |        | A    |
|  1 | 1/19/2016  | 12/15/2016 | USD    | B    |
|  1 | 11/20/2016 | 10/1/2016  | IT     | B    |
|  2 | 10/25/2016 |            |        | A    |
|  2 | 9/22/2016  | 7/11/2016  | SD     | B    |
|  2 | 2/13/2016  |            |        | A    |
|  2 | 1/1/2016   | 4/3/2016   | IT     | B    |
+----+------------+------------+--------+------+
--For each ID, I need to select the minimum Sdate for Type=A 
--	and maximum Edate for Type=B, 
--	alongwith the Discharge Reason associated with Type=B. 
--There are more than just two types but I have shown A and B as an example

--Desired Output:

+-------------+-----------+------------+------------------+
| Customer ID | Startdate |  Enddate   | Discharge Reason |
+-------------+-----------+------------+------------------+
|           1 | 5/30/2016 | 12/15/2016 | USD              |
|           2 | 2/13/2016 | 7/11/2016  | SD               |
+-------------+-----------+------------+------------------+

--======================================================================
The response
--======================================================================

This is a classic top-n-per-group problem, which you need to do twice.

Sample data

DECLARE @T TABLE (ID int, Sdate date, Edate date, Reason varchar(50), Type char(1));
INSERT INTO @T (ID, Sdate, Edate, Reason, Type) VALUES
(1, '2016-05-30', NULL         , NULL , 'A'),
(1, '2016-01-19', '2016-12-15' , 'USD', 'B'),
(1, '2016-11-20', '2016-10-01' , 'IT' , 'B'),
(2, '2016-10-25', NULL         , NULL , 'A'),
(2, '2016-09-22', '2016-07-11' , 'SD' , 'B'),
(2, '2016-02-13', NULL         , NULL , 'A'),
(2, '2016-01-01', '2016-04-03' , 'IT' , 'B');
----------------------------------------------

--Number the rows twice.

PARTITION BY ID ORDER BY Type, Sdate will give row number 1 for each ID and smallest Sdate and  Type=A.

----------------------------------------------

PARTITION BY ID ORDER BY Type DESC, Edate DESC will give row number 1 for each ID and largest Edate and Type=B.

----------------------------------------------

SELECT
    ID
    ,Sdate
    ,Edate
    ,Reason
    ,Type
    ,ROW_NUMBER() OVER (PARTITION BY ID ORDER BY Type, Sdate) AS rnA
    ,ROW_NUMBER() OVER (PARTITION BY ID ORDER BY Type DESC, Edate DESC) AS rnB
FROM @T
ORDER BY ID, Type, Sdate
;
Intermediate result

+----+------------+------------+--------+------+-----+-----+
| ID |   Sdate    |   Edate    | Reason | Type | rnA | rnB |
+----+------------+------------+--------+------+-----+-----+
|  1 | 2016-05-30 | NULL       | NULL   | A    |   1 |   3 |
|  1 | 2016-01-19 | 2016-12-15 | USD    | B    |   2 |   1 |
|  1 | 2016-11-20 | 2016-10-01 | IT     | B    |   3 |   2 |
|  2 | 2016-02-13 | NULL       | NULL   | A    |   1 |   3 |
|  2 | 2016-10-25 | NULL       | NULL   | A    |   2 |   4 |
|  2 | 2016-01-01 | 2016-04-03 | IT     | B    |   3 |   2 |
|  2 | 2016-09-22 | 2016-07-11 | SD     | B    |   4 |   1 |
+----+------------+------------+--------+------+-----+-----+
--Now we need to get rows with rnA=1 and rnB=1 and put them together joining by ID.

--Query

WITH
CTE
AS
(
    SELECT
        ID
        ,Sdate
        ,Edate
        ,Reason
        ,Type
        ,ROW_NUMBER() OVER (PARTITION BY ID ORDER BY Type, Sdate) AS rnA
        ,ROW_NUMBER() OVER (PARTITION BY ID ORDER BY Type DESC, Edate DESC) AS rnB
    FROM @T
)
,CTE_A
AS
(
    SELECT
        ID
        ,Sdate
    FROM CTE
    WHERE rnA = 1
)
,CTE_B
AS
(
    SELECT
        ID
        ,Edate
        ,Reason
    FROM CTE
    WHERE rnB = 1
)
SELECT
    CTE_A.ID
    ,CTE_A.Sdate
    ,CTE_B.Edate
    ,CTE_B.Reason
FROM
    CTE_A
    INNER JOIN CTE_B ON CTE_B.ID = CTE_A.ID
ORDER BY ID
;
--Result

+----+------------+------------+--------+
| ID |   Sdate    |   Edate    | Reason |
+----+------------+------------+--------+
|  1 | 2016-05-30 | 2016-12-15 | USD    |
|  2 | 2016-02-13 | 2016-07-11 | SD     |
+----+------------+------------+--------+</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions_WINDOW_FUNCTIONS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>WindowStartingAtAParticularRecordPattern</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions_WINDOW_FUNCTIONS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>WindowStartingAtAParticularRecordPattern</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.sqlservercentral.com/Forums/Topic1749931-3077-1.aspx


1] Here is what the data looks like:
----------------------------------------------------------------------------------
SELECT TOP (1000) [id]
      ,[rowdata]
  FROM [RiskMngt].[dbo].[ggTEST]
  
 --OUTPUT
 ----------------------
 id	rowdata
1	5001x
2	600
3	700
4	800
5	5002y
6	6000
7	700
8	800
9	5003z
10	600
11	700
12	800
----------------------------------------------------------------------------------
2] Here is the final solution
----------------------------------------------------------------------------------
USE RiskMngt;
GO
SET NOCOUNT ON;

IF OBJECT_ID(N'dbo.ggTEST') IS NOT NULL DROP TABLE dbo.ggTEST
CREATE TABLE dbo.ggTEST
(
    [id] [int] NOT NULL identity,
    [rowdata] [nvarchar](10) NULL
)

INSERT INTO dbo.ggTEST (rowdata) 
VALUES ('5001x')
      ,('600')
      ,('700')
      ,('800')
      ,('5002y')
      ,('6000')
      ,('700')
      ,('800')
      ,('5003z')
      ,('600')
      ,('700')
      ,('800');
      
;WITH BASE_DATA AS
( 
    SELECT
        T.id
       ,T.rowdata
       ,SUM(SIGN(PATINDEX('%[A-z]%',T.rowdata))) OVER
            (
                ORDER BY T.id
                ROWS BETWEEN UNBOUNDED PRECEDING
                     AND     CURRENT ROW
            ) AS RID
    FROM dbo.ggTEST T
)
SELECT
    BD.id
   ,BD.rowdata
   ,ROW_NUMBER() OVER
        (
            PARTITION BY BD.RID
            ORDER BY     BD.id
        ) AS Row_numb
FROM    BASE_DATA   BD;

 --OUTPUT
 ----------------------
id	rowdata	Row_numb
1	5001x	1
2	600		2
3	700		3
4	800		4
5	5002y	1
6	6000	2
7	700		3
8	800		4
9	5003z	1
10	600		2
11	700		3
12	800		4


----------------------------------------------------------------------------------


3] Here is the Middle step: Notice how whatever2 is the starting point for the RowNumber

SELECT TOP (1000) [id]
      ,[rowdata]
	  ,PATINDEX('%[A-z]%',rowdata) as whatever1
	  ,SIGN(PATINDEX('%[A-z]%',rowdata)) as whatever2
       ,SUM(SIGN(PATINDEX('%[A-z]%',rowdata))) OVER
            (
                ORDER BY id
                ROWS BETWEEN UNBOUNDED PRECEDING
                     AND     CURRENT ROW
            ) AS RID
  FROM [RiskMngt].[dbo].[ggTEST]
  
  
  
  id	rowdata	whatever1	whatever2	RID
1		5001x		5		1			1
2		600			0		0			1
3		700			0		0			1
4		800			0		0			1
5		5002y		5		1			2
6		6000		0		0			2
7		700			0		0			2
8		800			0		0			2
9		5003z		5		1			3
10		600			0		0			3
11		700			0		0			3
12		800			0		0			3</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CAST_CONVERT_text_to_number</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CAST_CONVERT_text_to_number</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--How to use CAST or CONVERT?
SELECT CAST(YourVarcharCol AS INT) FROM Table
SELECT CONVERT(INT, YourVarcharCol) FROM Table

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Table structure...very basic:

create table tabla(ID int, Stuff varchar (50));

insert into tabla values(1, '32.43');
insert into tabla values(2, '43.33');
insert into tabla values(3, '23.22');
--Query:

SELECT SUM(cast(Stuff as decimal(4,2))) as result FROM tabla
--Or, try this:

SELECT SUM(cast(isnull(Stuff,0) as decimal(12,2))) as result FROM tabla</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Example_Function</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Example_Function</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>INSERT INTO Authors (FirstName, LastName) VALUES ('John', 'Doe')

INSERT INTO Authors (FirstName, LastName) VALUES ('Sally', 'Smith')

UPDATE AUTHORS 
SET [Address] = '100 Main Street',
	[City] = 'New Orleans',
	[State] = 'LA',
	[Zip] = '70931'
WHERE LastName = 'Smith'

UPDATE AUTHORS 
SET [Address] = '700 Willow Street',
	[City] = 'Buffalo',
	[State] = 'NY',
	[Zip] = '30951'
WHERE LastName = 'Doe'

-------------------------------------------------------

CREATE FUNCTION formatAddress
(@street as varchar(50),
 @city as varchar(50),
 @state as varchar(50),
 @zip as varchar(50)
 )
 RETURNS varchar(255)
 AS

 BEGIN

	IF (@street IS NULL OR  
		@city IS NULL OR  
		@state IS NULL OR  
		@zip IS NULL)
		
		RETURN 'Incomplete Address'

	SET @state = 
	CASE @state
		WHEN 'LA' THEN 'Louisiana'
		WHEN 'NY' THEN 'New York'
		WHEN 'CA' THEN 'California'  
	END 
		 
	RETURN @street + ' ' + @city + ', ' + @state + ' ' + @zip
 END

---------------------------

SELECT  dbo.formatAddress ('100 Main', 'Buffalo', 'NY', '39117')

-----------------------------------------------------

SELECT FirstName, LastName, dbo.formatAddress([address], city, [state], zip)
FROM AUTHORS

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Example_TABLE_Function</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Example_TABLE_Function</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>CREATE FUNCTION dbo.AuthorsByStatus(@isActive int)
RETURNS @AuthorsTable TABLE 
(	[FirstName] [varchar](50) NOT NULL,
	[LastName] [varchar](50) NOT NULL,
	[PhoneNumber] [varchar](50) NULL,
	[Address] [varchar](50) NULL,
	[City] [varchar](50) NULL,
	[State] [varchar](50) NULL,
	[Zip] [varchar](50) NULL,
	[Active] [int] NULL
)  
AS 
BEGIN

	INSERT INTO @AuthorsTable
	    SELECT * 
	    FROM AUTHORS
	    WHERE Active = @isActive

	RETURN;
END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>fn_ReturnTableFromStringOfConcantenatedSubstringsAndDelimiters</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>fn_ReturnTableFromStringOfConcantenatedSubstringsAndDelimiters</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>fn_ReturnTableFromStringOfConcantenatedSubstringsAndDelimiters

--I used this function for a multivalue parameter report in  SSRS 

--SUMMARY: 
/*
a) Let a user pick one or more values for a particular Parm.
b) Use an Expression in the 'Value' of a Parameter that concatenates the multiple values into one string
c) Feed the multi-value string to the Stored Procedure
d) Then have a function that un-packs the substrings into seperate pieces, with commas between each piece
e) Then use that comma-seperated string of multiple values in an 'IN' statement of a WHERE clause in the 
	Stored Proc that gets the data for the DataSet of the SSRS Report



use a function that returns a table, of substrings, given a Large string made up of of Concatenated sub-strings



*/
--1] In the SSRS dataset properties, pass the multi-value param to the stored procedure as a comma-delimited string

-- for the Dataset, in the SSRS Report, right click =&gt; Properties =&gt; Parameters (e.g. for Parm '@BU'), for the Parm 'Value' 
--		use this expression:
								=JOIN(Parameters!BU.Value,",")

--2] Create this function in SQL Server to be used by the stored procedure that provides the data to the report

CREATE FUNCTION [dbo].[fn_ReturnTableFromStringOfConcantenatedSubstringsAndDelimiters]
   (@ConcatenatedSubStrings nvarchar(max), @Delim char(1)= ',')
RETURNS @Values TABLE (Item nvarchar(100))AS
-- based on John Sansoms StackOverflow answer:
-- http://stackoverflow.com/a/512300/22194

  BEGIN
  DECLARE @chrind INT
  DECLARE @Piece nvarchar(100)
  SELECT @chrind = 1 
  WHILE @chrind &gt; 0
    BEGIN
      SELECT @chrind = CHARINDEX(@Delim,@ConcatenatedSubStrings)
      IF @chrind  &gt; 0
        SELECT @Piece = LEFT(@ConcatenatedSubStrings,@chrind - 1)
      ELSE
        SELECT @Piece = @ConcatenatedSubStrings
      INSERT  @Values(Item) VALUES(@Piece)
      SELECT @ConcatenatedSubStrings = RIGHT(@ConcatenatedSubStrings,LEN(@ConcatenatedSubStrings) - @chrind)
      IF LEN(@ConcatenatedSubStrings) = 0 BREAK
    END
  RETURN
  END 
  
 --3] Then in the Stored procedure, for the Dataset, you can call the function 
  
--======= How to Use the function in the Stored Proc for the report:=========================================================================================
SELECT *
FROM SomeTable
WHERE
	(BU_Name IN (select Item from dbofn_ReturnTableFromStringOfConcantenatedSubstringsAndDelimiters(@BU,','))	)	
--===================================================================================================================  
 
  
  
  
  
  
  
  


--ORIGINAL Version:
--=======================

--prj_0013_FN_401_unSplit.sql
USE B2W_Reports
go
CREATE FUNCTION [dbo].[prj_0013_FN_401_unSplit]
   (@RepParam nvarchar(max), @Delim char(1)= ',')
RETURNS @Values TABLE (Item nvarchar(100))AS
-- based on John Sansoms StackOverflow answer:
-- http://stackoverflow.com/a/512300/22194

  BEGIN
  DECLARE @chrind INT
  DECLARE @Piece nvarchar(100)
  SELECT @chrind = 1 
  WHILE @chrind &gt; 0
    BEGIN
      SELECT @chrind = CHARINDEX(@Delim,@RepParam)
      IF @chrind  &gt; 0
        SELECT @Piece = LEFT(@RepParam,@chrind - 1)
      ELSE
        SELECT @Piece = @RepParam
      INSERT  @Values(Item) VALUES(@Piece)
      SELECT @RepParam = RIGHT(@RepParam,LEN(@RepParam) - @chrind)
      IF LEN(@RepParam) = 0 BREAK
    END
  RETURN
  END 
  
  
  --======= Use the function:
  (BU_Name IN (select Item from dbo.prj_0013_FN_401_unSplit(@BU,','))	)	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>fn_SplitString_at_Seperator_Into_Table-2</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>fn_SplitString_at_Seperator_Into_Table-2</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--1] Call function
--2] Create Function


--Notes;
Didn't work for select * from dbo.ethos_SplitString_fn('guy,wicks,was here',',') id part ----------- -------------------------------------------------- 1 guy 2 wick – Guy Oct 20 '08 at 15:25
1 	 
	
watch out with len() as it'll not return correct number if its argument has trailing spaces., e.g. len(' - ') = 2. – Rory Oct 17 '09 at 16:30
	
Doesn't work on: select * from dbo.SplitString('foo,foo test,,,,foo',',') – cbp Apr 14 '10 at 5:14

/////////////////////////////////////////

select * From SplitString('Hello**John**Smith','**')

Select * From SplitString('Hello John Smith',' ')

//////////////////////////////////////////


CREATE FUNCTION SplitString 
(
    -- Add the parameters for the function here
    @myString varchar(500),
    @deliminator varchar(10)
)
RETURNS 
@ReturnTable TABLE 
(
    -- Add the column definitions for the TABLE variable here
    [id] [int] IDENTITY(1,1) NOT NULL,
    [part] [varchar](50) NULL
)
AS
BEGIN
        Declare @iSpaces int
        Declare @part varchar(50)

        --initialize spaces
        Select @iSpaces = charindex(@deliminator,@myString,0)
        While @iSpaces &gt; 0

        Begin
            Select @part = substring(@myString,0,charindex(@deliminator,@myString,0))

            Insert Into @ReturnTable(part)
            Select @part

    Select @myString = substring(@mystring,charindex(@deliminator,@myString,0)+ len(@deliminator),len(@myString) - charindex(' ',@myString,0))


            Select @iSpaces = charindex(@deliminator,@myString,0)
        end

        If len(@myString) &gt; 0
            Insert Into @ReturnTable
            Select @myString

    RETURN 
END
GO


Select @myString = substring(@mystring,@iSpaces + len(@deliminator),len(@myString) - charindex(@deliminator,@myString,0))</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>fn_SplitString_at_Seperator_Into_Table-4</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>fn_SplitString_at_Seperator_Into_Table-4</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--1] Call function
--2] Create Function

-- NOTES:
--I've gone through it &amp; it is perfectly like what I want! 
--even I can also customize it for ignoring special characters that I choose! 

/////////////////////////////////////////

select * from SplitWordList('Hello John Smith')

/////////////////////////////////////////
CREATE function [SplitWordList]
(
 @list varchar(8000)
)
returns @t table 
(
 Word varchar(50) not null,
 Position int identity(1,1) not null
)
as begin
  declare 
    @pos int,
    @lpos int,
    @item varchar(100),
    @ignore varchar(100),
    @dl int,
    @a1 int,
    @a2 int,
    @z1 int,
    @z2 int,
    @n1 int,
    @n2 int,
    @c varchar(1),
    @a smallint
  select 
    @a1 = ascii('a'),
    @a2 = ascii('A'),
    @z1 = ascii('z'),
    @z2 = ascii('Z'),
    @n1 = ascii('0'),
    @n2 = ascii('9')
  set @ignore = '''"'
  set @pos = 1
  set @dl = datalength(@list)
  set @lpos = 1
  set @item = ''
  while (@pos &lt;= @dl) begin
    set @c = substring(@list, @pos, 1)
    if (@ignore not like '%' + @c + '%') begin
      set @a = ascii(@c)
      if ((@a &gt;= @a1) and (@a &lt;= @z1))  
        or ((@a &gt;= @a2) and (@a &lt;= @z2))
        or ((@a &gt;= @n1) and (@a &lt;= @n2))
      begin
        set @item = @item + @c
      end else if (@item &gt; '') begin
        insert into @t values (@item)
        set @item = ''
      end
    end 
    set @pos = @pos + 1
  end</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>fn_SplitString_at_Seperator_Into_Table-5</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>fn_SplitString_at_Seperator_Into_Table-5</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--1] Call function
--2] Create Function

/////////////////////////////////////////

SELECT * FROM dbo.split('ram shyam hari gopal',' ')

/////////////////////////////////////////

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [dbo].[Split](@String VARCHAR(8000), @Delimiter CHAR(1))       
	RETURNS @temptable TABLE (items VARCHAR(8000))       
	AS       
	BEGIN       
		DECLARE @idx INT       
		DECLARE @slice VARCHAR(8000)        
		SELECT @idx = 1       
		IF len(@String)&lt;1 OR @String IS NULL  RETURN       
		while @idx!= 0       
		BEGIN       
				SET @idx = charindex(@Delimiter,@String)
				       
				IF @idx!=0       
					SET @slice = LEFT(@String,@idx - 1)       
				ELSE       
					SET @slice = @String 
					      
				IF(len(@slice)&gt;0)  
					INSERT INTO @temptable(Items) VALUES(@slice)       
				SET @String = RIGHT(@String,len(@String) - @idx)       
					IF len(@String) = 0 break  
				     
			END   
		RETURN       
		END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>fn_SplitString_at_Seperator_Into_Table-6</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>fn_SplitString_at_Seperator_Into_Table-6</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--It's a user-defined-function to split a given string into 'words'.
--I'm delimiting words using commas and spaces. So 'Smith, Fred' 
--		(with a comma AND a space) will be separated into 'Smith' and 'Fred'.
--For convenience, it returns a table with a 'pos' column, 
--	representing the position in the original text that the word was found.



CREATE FUNCTION SplitWords(@text varchar(8000))
   RETURNS @words TABLE (
      pos smallint primary key,
      value varchar(8000)
   )
AS
BEGIN
   DECLARE
      @pos smallint,
      @i smallint,
      @j smallint,
      @s varchar(8000)

   SET @pos = 1
   WHILE @pos &lt;= LEN(@text) 
   BEGIN 
      SET @i = CHARINDEX(' ', @text, @pos)
      SET @j = CHARINDEX(',', @text, @pos)
      IF @i &gt; 0 OR @j &gt; 0
      BEGIN
         IF @i = 0 OR (@j &gt; 0 AND @j &lt; @i)
            SET @i = @j

         IF @i &gt; @pos
         BEGIN
            -- @i now holds the earliest delimiter in the string
            SET @s = SUBSTRING(@text, @pos, @i - @pos)

            INSERT INTO @words
            VALUES (@pos, @s)
         END 
         SET @pos = @i + 1

         WHILE @pos &lt; LEN(@text) 
            AND SUBSTRING(@text, @pos, 1) IN (' ', ',')
            SET @pos = @pos + 1 
      END 
      ELSE 
      BEGIN 
         INSERT INTO @words 
         VALUES (@pos, SUBSTRING(@text, @pos, LEN(@text) - @pos + 1))

         SET @pos = LEN(@text) + 1 
      END 
   END 
   RETURN 
END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Hierarchies</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Simple_Way_Generate_HierarchyID_from_Employee_Boss_table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Hierarchies</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Simple_Way_Generate_HierarchyID_from_Employee_Boss_table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--This is the simple way to map from employee/boss to Hierarchy 
-- but is not as universally applicable.
-- Use CTE's recursive query and ranking functions


create table [TABLE_personnel (parented)]
(
employee int identity primary key,
name nvarchar(50),
[hourly rate] money,
boss int -- parent in TABLE_personnel tree
);

--This is the way most of my data is organized
 set identity_insert dbo.[TABLE_personnel (parented)] on;
 insert into [TABLE_personnel (parented)] (employee, name, [hourly rate], [boss])
 values
 (1, 'Big Boss', 1000.00, 1),	--both the 'employee' and the 'boss' are the same - this is the convention for marking the root of the tree
 (2, 'Joe', 10.00, 1),
 (8, 'Mary', 20.00, 1),
 (14, 'Jack', 15.00, 1),
 (3, 'Jane', 10.00, 2),
 (5, 'Max', 35.00, 2),
 (9, 'Lynn', 15.00, 8),
 (10, 'Miles', 60.00, 8),
 (12, 'Sue', 15.00, 8),
 (15, 'June', 50.00, 14),
 (18, 'Jim', 55.00, 14),
 (19, 'Bob', 40.00, 14),
 (4, 'Jayne', 35.00, 3),
 (6, 'Ann', 45.00, 5),
 (7, 'Art', 10.00, 5),
 (11, 'Al', 70.00, 10),
 (13, 'Mike', 50.00, 12),
 (16, 'Marty', 55.00, 15),
 (17, 'Barb', 60.00, 15),
 (20, 'Bart', 1000.00, 19);
  set identity_insert dbo.[TABLE_personnel (parented)] off;
  
select * from [TABLE_personnel (parented)]
order by boss

-- add a column to the table to hold the 'hierarchyid'
alter table [TABLE_personnel (parented)]
add [node] hierarchyid;

-----------------------------------------------------------------------
-- fills all nodes, i.e. POPULATE the node field (i.e. [sib])
-- The Hierarchy ID consists of Hierarchy ID of the parent,
--		AND a suffix that marks the sibling uniquely among the other 
--		sibblings of the parent node
with CTE_SIBS
as
(select boss, 
		employee, 
		--Next: for all the children of the parent, assign a ordered row number, starting from one (1)
		--		for each set of sibblings
		--		then concatenate a '/' to the end of each
		cast(row_number() over (partition by boss order by employee) as varchar) + '/' as sib
from [TABLE_personnel (parented)]
where employee != boss		-- except for the boss, or root node
) 
--select * from CTE_SIBS

-----------------------------------------------------------------------
-- Find all the HiearchyID that don't have anything assigned to them yet
-- using a RECURSIVE QUERY
,[CTE_no_node]
as
(
	-- Part 1] The RECURSIVE QUERY requires the anchor records, or initializer
	--			In this case the root of the tree
	--		'GetRoot' function generates the Hierarchy ID for the root of the tree
	select 
			boss
			, employee
			, hierarchyid::GetRoot() as node   from [TABLE_personnel (parented)]
	where employee = boss	--&lt;== get the root
	
	UNION ALL
	
	--Part 2] The Recursive part, which is called over and over until there are no results
	--		  sometimes called the "fixed point"
	select 
			P.boss
			, P.employee
			, cast([CTE_no_node].node.ToString() + CTE_SIBS.sib as hierarchyid)  as node
	from 
			[TABLE_personnel (parented)] as P
			join 
			[CTE_no_node] 
			on P.boss = [CTE_no_node].employee
	
			join CTE_SIBS 
			on P.employee = CTE_SIBS.employee
)
--select node.ToString(), * from [CTE_no_node]

-----------------------------------------------------------------------

	update [TABLE_personnel (parented)] 
	set node = [CTE_no_node].node
	from  
		[TABLE_personnel (parented)] as P 
		join 
		[CTE_no_node]
		on P.employee = [CTE_no_node].employee

	select node.ToString(), * from [TABLE_personnel (parented)]
	order by boss
 
 

  ---------------------------------------------------------------------------
  OUTPUT - Original Table
  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  employee	name	hourly rate	boss
1	Big Boss	1000.00	1
2	Joe	10.00	1
8	Mary	20.00	1
14	Jack	15.00	1
5	Max	35.00	2
3	Jane	10.00	2
4	Jayne	35.00	3
6	Ann	45.00	5
7	Art	10.00	5
12	Sue	15.00	8
9	Lynn	15.00	8
10	Miles	60.00	8
11	Al	70.00	10
13	Mike	50.00	12
15	June	50.00	14
18	Jim	55.00	14
19	Bob	40.00	14
16	Marty	55.00	15
17	Barb	60.00	15
20	Bart	1000.00	19
----------------------------------------------------------------------------
FINAL TABLE
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
(No column name)	employee	name	hourly rate	boss	node
/		1	Big Boss	1000.00	1	0x
/1/		2	Joe			10.00	1	0x58
/2/		8	Mary		20.00	1	0x68
/3/		14	Jack		15.00	1	0x78
/1/2/	5	Max			35.00	2	0x5B40
/1/1/	3	Jane		10.00	2	0x5AC0
/1/1/1/	4	Jayne		35.00	3	0x5AD6
/1/2/1/	6	Ann			45.00	5	0x5B56
/1/2/2/	7	Art			10.00	5	0x5B5A
/2/3/	12	Sue			15.00	8	0x6BC0
/2/1/	9	Lynn		15.00	8	0x6AC0
/2/2/	10	Miles		60.00	8	0x6B40
/2/2/1/	11	Al			70.00	10	0x6B56
/2/3/1/	13	Mike		50.00	12	0x6BD6
/3/1/	15	June		50.00	14	0x7AC0
/3/2/	18	Jim			55.00	14	0x7B40
/3/3/	19	Bob			40.00	14	0x7BC0
/3/1/1/	16	Marty		55.00	15	0x7AD6
/3/1/2/	17	Barb		60.00	15	0x7ADA
/3/3/1/	20	Bart		1000.00	19	0x7BD6</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>IMPORT_Excel_CSV_TEXT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>OPENROWSET__CreateTable_Append_xlsx_to_SQL_table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>IMPORT_Excel_CSV_TEXT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>OPENROWSET__CreateTable_Append_xlsx_to_SQL_table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--p_0063_MAINT_301_NaturalHazards_ReadInData_CreateTables_v1.sql

/*
	************************************************************************************
	NOTE: This runs in the DEV instance, and uses "Local System" to run the SQL Server
	Uses: 
	Created: 3/19/2018
	By: glenn garson
	************************************************************************************
*/

use p_0063
go

--CREATE TABLE --------------------------------------------
IF OBJECT_ID('dbo.NaturalHazards_2018_03_19') IS NOT NULL
    DROP TABLE dbo.NaturalHazards_2018_03_19

SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 100)) AS RowOrder, *, 'Beverly' as fromWho 
Into NaturalHazards_2018_03_19
FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=NO;Database=C:\DATA\p_0063\TEST\Beverly.xlsx',
				         'SELECT * FROM [Natural_Hazards$A7:H15]');

-- Append to Table -----------------------------------------
INSERT INTO NaturalHazards_2018_03_19
SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 100)) AS RowOrder, *, 'Nicole' as fromWho 
FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=NO;Database=C:\DATA\p_0063\TEST\Nicole.xlsx',
				         'SELECT * FROM [Natural_Hazards$A7:H15]');


INSERT INTO NaturalHazards_2018_03_19
SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 100)) AS RowOrder, *, 'Rosanna' as fromWho 
FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=NO;Database=C:\DATA\p_0063\TEST\Rosanna.xlsx',
				         'SELECT * FROM [Natural_Hazards$A7:H15]');

INSERT INTO NaturalHazards_2018_03_19
SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 100)) AS RowOrder, *, 'Tammy' as fromWho 
FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=NO;Database=C:\DATA\p_0063\TEST\Tammy.xlsx',
				         'SELECT * FROM [Natural_Hazards$A7:H15]');

INSERT INTO NaturalHazards_2018_03_19
SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 100)) AS RowOrder, *, 'Thomas' as fromWho 
FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=NO;Database=C:\DATA\p_0063\TEST\Thomas.xlsx',
				         'SELECT * FROM [Natural_Hazards$A7:H15]');

INSERT INTO NaturalHazards_2018_03_19
SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 100)) AS RowOrder, *, 'Trudy' as fromWho 
FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=NO;Database=C:\DATA\p_0063\TEST\Trudy.xlsx',
				         'SELECT * FROM [Natural_Hazards$A7:H15]');


INSERT INTO NaturalHazards_2018_03_19
SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 100)) AS RowOrder, *, 'Wanda' as fromWho 
FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=NO;Database=C:\DATA\p_0063\TEST\Wanda.xlsx',
				         'SELECT * FROM [Natural_Hazards$A7:H15]');

-------------------------------------------
Select * from NaturalHazards_2018_03_19</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>IMPORT_Excel_CSV_TEXT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>OPENROWSET_to_read_EXCEL_data_v2</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>IMPORT_Excel_CSV_TEXT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>OPENROWSET_to_read_EXCEL_data_v2</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>OPENROWSET_to_read_EXCEL_data_v2
-- This is based on WBSQL1 at JPHSA

////////////////////////////////////////////////////--OLEDB drivers
https://community.flexerasoftware.com/archive/index.php?t-201524.html

--Check registry:
--For 64-bit:
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Office\14.0\Access Connectivity Engine\InstallRoot
--For 32-bit:
HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Office\14.0\Access Connectivity Engine\InstallRoot


Microsoft Access Runtime 2010
v 14.0.4763.1000
Microsoft Access Runtime 2013
v 15.0.4569.1506
Microsoft Access Runtime 2016  (Installed today)  
v 16.0.4288.1001

in the folder: C:\Program Files (x86)\Microsoft Office


/////////////////////////////////////////////////////-- SETUP
--I  set the OLEDB.15 Provider to the following
		--Dynamic parameter [1]
		--DisallowAdHocAccess [0]
		--AllowInProcess [1]


EXEC sp_configure 'Show Advanced', 1
RECONFIGURE

EXEC sp_configure 'Ad hoc dis', 1
RECONFIGURE
--Then used regedit to change the 1 to 0
--The above setting, created a registry entry DisallowAdHocAccess at: 
	HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SQL Server\MSSQL11.SQL2012\Providers\Microsoft.ACE.OLEDB.12.0
--Set the value of DisallowAdHocAccess to 0.
--Restart the SQL service.

EXEC master.dbo.sp_MSset_oledb_prop N'Microsoft.ACE.OLEDB.15.0' 
    , N'AllowInProcess', 1
RECONFIGURE     
GO

EXEC master.dbo.sp_MSset_oledb_prop N'Microsoft.ACE.OLEDB.15.0'
    , N'DynamicParameters', 1
RECONFIGURE
GO

/////////////////////////////////////////////////////-- run as administrator

-- Initially I was able to read an Excel file by opening SSMS "run as Administrator" using this:

SELECT * FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=YES;Database=C:\DATA\TESTv4.xlsx',
				         'SELECT * FROM [NaturalHazards$]');

////////////////////////////////////////////////////-- run as me

--Add local administrator login:  WBSQL1\Administrator
--	Default database:master
--Server Roles {tab}
--	public
--	serveradmin
--		Members of the serveradmin fixed server role can change server-wide configuration options and shut down the server.
--	sysadmin
--		Members of the sysadmin fixed server role can perform any activity in the server.
--	setupadmin
--		Members of the setupadmin fixed server role can add and remove linked servers by using Transact-SQL statements.
--	diskadmin
--		The diskadmin fixed server role is used for managing disk files.
--	bulkadmin
--		Members of the bulkadmin fixed server role can run the BULK INSERT statement

--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||This script runs, while logged on as ggarson
use master
go

EXECUTE AS LOGIN='WBSQL1\Administrator'

SELECT * FROM OPENROWSET('Microsoft.ACE.OLEDB.15.0',
                         'Excel 12.0 Xml;HDR=YES;Database=C:\DATA\TESTv4.xlsx',
				         'SELECT * FROM [NaturalHazards$]');
REVERT

GO
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INDEXs</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>about_INDEXs</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INDEXs</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>about_INDEXs</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_INDEXs


There are limitations to creating indexes that make covering queries difficult:

    A 900-byte size limit on indexes
    A maximum of 16 columns can be named in the index
    Columns with data types like nvarchar(max), text, and ntext cannot be used in indexes

--    CLUSTERED | NONCLUSTERED
--    Indicate that a clustered or a nonclustered index is created for the PRIMARY KEY or UNIQUE constraint. 

--    PRIMARY KEY constraints default to CLUSTERED, 
--		and 
--	  UNIQUE constraints default to NONCLUSTERED.

--    In a CREATE TABLE statement, CLUSTERED can be specified for only one constraint. 
--    If CLUSTERED is specified for a UNIQUE constraint and a PRIMARY KEY constraint 
--    is also specified, the PRIMARY KEY defaults to NONCLUSTERED.

PRIMARY KEY and UNIQUE constraints
--	When you create a PRIMARY KEY constraint, a unique clustered index on the column or columns is automatically created 
--		if a clustered index on the table does not already exist and you do not specify a unique nonclustered index. 
--	The primary key column cannot allow NULL values.

--

--NOTE: nomenclature of index: INDEX$tableName$fieldName
CREATE NONCLUSTERED INDEX INDEX$LNK06_T1_T12$T12_FK ON dbo.[LNK06_T1_T12] (T12_FK)
GO

/*
A table or view can contain the following types of indexes:
Clustered
=========
Clustered indexes sort and store the data rows in the table or view based on their key values. 
These are the columns included in the index definition. 
There can be only one clustered index per table, 
because the data rows themselves can be sorted in only one order.

The only time the data rows in a table are stored in sorted order is when the table contains a clustered index. 
When a table has a clustered index, the table is called a clustered table.
If a table has no clustered index, its data rows are stored in an unordered structure called a heap.
 
Nonclustered
=============
Nonclustered indexes have a structure separate from the data rows. 
	A nonclustered index contains the nonclustered index key values 
	and each key value entry has a pointer to the data row that contains the key value.

The pointer from an index row in a nonclustered index to a data row is called a row locator. 
	The structure of the row locator depends on whether the data pages are stored in a heap or a clustered table. 
	For a heap, a row locator is a pointer to the row. For a clustered table, the row locator is the clustered index key.
	You can add nonkey columns to the leaf level of the nonclustered index to by-pass existing index key limits, 
	900 bytes and 16 key columns, and execute fully covered, indexed, queries. 

Both clustered and nonclustered indexes can be unique. 
	This means no two rows can have the same value for the index key. 
	Otherwise, the index is not unique and multiple rows can share the same key value.  


Covering or Included 
====================

Covering index is just an ordinary index. It's called "covering" if it can satisfy query without necessity to analyze data
	Covering indexes are indexes which "cover" all columns needed from a specific table, 
	removing the need to access the physical table at all for a given query/ operation. */
CREATE TABLE MyTable

(
  ID INT IDENTITY PRIMARY KEY, 
  Foo INT
) 

CREATE NONCLUSTERED INDEX index1 ON MyTable(ID, Foo)

SELECT ID, Foo FROM MyTable -- All requested data are covered by index

/*
Since the index contains the desired columns (or a superset of them), 
	table access can be replaced with an index lookup or scan -- which is generally much faster.

	Columns to cover:
		- parameterized or static conditions; columns restricted by a parameterized or constant condition.
		- join columns; columns dynamically used for joining
		- selected columns; to answer selected values.
		
While covering indexes can often provide good benefit for retrieval, 
they do add somewhat to insert/ update overhead; 
due to the need to write extra or larger index rows on every update.

Covering indexes for Joined Queries
------------------------------------
Covering indexes are probably most valuable as a performance technique for joined queries. 
This is because joined queries are more costly &amp; more likely then single-table retrievals to suffer high cost performance problems.

	- in a joined query, covering indexes should be considered per-table.
	- each 'covering index' removes a physical table access from the plan &amp; replaces it with index-only access.
	- investigate the plan costs &amp; experiment with which tables are most worthwhile to replace by a covering index.
	- by this means, the multiplicative cost of large join plans can be significantly reduced.





</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INDEXs</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>DropCreate_Index</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INDEXs</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>DropCreate_Index</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- STRATEGY TO REMOVE CLUSTERED INDEX
--make sure that if you have any other indexes on the table that you drop those first.
--Otherwise SQL Server will have to rebuild them all when you remove the clustered index then
--rebuild them all again when you add back a new clustered index. The usual steps are:

    --Remove all non-clustered indexes
    --Remove clustered index
    --Add new clustered index
    --Add back all non-clustered indexes
    

    
 \\\\\\\\\\ Simple way, but not when table is large \\\\\\\\\\\\   
   --1] Create a new table:

    CREATE TABLE newtable (colA INT, colB INT)

    --2] Insert all values from the old table into the new table:

    INSERT
    INTO    newtable
    SELECT  *
    FROM    table

    --3] Drop the old table:

    DROP TABLE table

   --4]  Rename the new table to the old table

    EXEC sp_rename 'newtable', 'table'

    --5]Build the indexes:

    ALTER TABLE Table
    ADD CONSTRAINT
    PK_Table PRIMARY KEY NONCLUSTERED     --&lt;== Primary Key, Non-Clustered
    (
    ColA,
    ColB
    ) WITH( STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
    
    
    \\\\\\\\\\\\\\\\\\\\\\
--When you drop a clustered index the table becomes a heap. 
--Since heaps have a very different physical structure from indexes, 
--the data will have to be copied into the new structure. 
--Heaps have no order whatsoever. 
--When you add back a new clustered index, 
--the data will be copied from the heap into the new index, 
--and the order will be defined by the new clustered ke
 
 -- This was an example where the index was a GUID   
 ALTER TABLE Table ADD Integer_Id INT;
GO

WITH cte AS (
  SELECT ROW_NUMBER() OVER (ORDER BY Guid_Id) as RowOrderByGuid,
    Guid_Id
  FROM Table)
UPDATE t
  SET t.Integer_Id = c.RowOrderByGuid
FROM Table t
JOIN cte c ON t.Guid_Id = c.Guid_Id;   

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INDEXs</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INCLUDE_index___covering</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INDEXs</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INCLUDE_index___covering</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--you can create a covering index in one of the following two ways.

CREATE INDEX idx1 ON MyTable (Col1, Col2, Col3)
-- OR --

CREATE INDEX idx1 ON MyTable (Col1) INCLUDE (Col2, Col3)

/*
The INCLUDE clause: 
Why would you use it and what guidelines would you suggest in determining whether to create a covering index with or without the INCLUDE 

-	If the column is not in the WHERE/JOIN/GROUP BY/ORDER BY, but only in the column list in the SELECT clause.

-	The INCLUDE clause adds the data at the lowest/leaf level, rather than in the index tree. 
	This makes the index smaller because it's not part of the tree

-	This means it isn't really useful for predicates, sorting etc as I mentioned above. 
	However, it may be useful if you have a residual lookup in a few rows from the key column(s)
*/
USE AdventureWorks2012;  
GO  
-- Creates a nonclustered index on the Person.Address table with four included (nonkey) columns.   
-- index key column is PostalCode and the nonkey columns are  
-- AddressLine1, AddressLine2, City, and StateProvinceID.  
CREATE NONCLUSTERED INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
GO  

//////////////////////////////////////////////

--Why and how to implement a covering index 
http://www.practicalsqldba.com/2013/03/sql-server-part-8-explaining-covering.html

//////////////////////////////////////////////
--Example of adding an INCLUDE index to a table with a Foreign Key:

use JUNK
go


CREATE TABLE StudentDetails
(
StudentID INTEGER PRIMARY KEY,				--&lt;== Here is the Primary Key, referenced by the FK below
StudentName VARCHAR(15)
)
GO
INSERT INTO StudentDetails
VALUES(1,'WANG')
INSERT INTO StudentDetails
VALUES(2,'JOHNSON')
GO

CREATE TABLE StudentTotalMarks
(
Id INT IDENTITY PRIMARY KEY,
StudentID INTEGER REFERENCES StudentDetails,	--&lt;=== Here is the Foreign Key: StudentID
StudentMarks INTEGER
)
GO
INSERT INTO StudentTotalMarks
VALUES(1,230)
INSERT INTO StudentTotalMarks
VALUES(2,255)
GO

INSERT INTO StudentTotalMarks
VALUES(1,230)
INSERT INTO StudentTotalMarks
VALUES(2,255)
GO
--====================================================

CREATE UNIQUE INDEX uq1 
ON dbo.StudentTotalMarks (StudentID)             --&lt;== This adds a covering (INCLUDE) index
INCLUDE (StudentMarks);
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INDEXs</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>UNIQUE_Index_vs_Constraint</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INDEXs</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>UNIQUE_Index_vs_Constraint</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--https://www.mssqltips.com/sqlservertip/4270/difference-between-sql-server-unique-indexes-and-unique-constraints/

--A unique INDEX ensures that the values in the index key columns are unique.

--A unique CONSTRAINT also guarantees that no duplicate values can be inserted into the column(s) on which the constraint is created. 
--When a unique CONSTRAINT is created a corresponding unique INDEX is automatically created on the column(s).

/*
Generally there is no functional difference between a unique index and a unique constraint. 
The latter is also listed as a constraint, however this is only a method to emphasize the purpose of the index. 
There is no difference for the query optimizer whether the index is created as a unique index or a unique constraint, therefore there is no performance difference. 
However there are some differences for creation where some index creation options are not available for unique constraints.

*/


USE TestDB   --&lt;== CODE AT THE BOTTOM TO CREATE THIS
GO

-- Creating unique index
CREATE UNIQUE INDEX UIX_TestTable_Value ON TestTable(Value)
GO

--Creating unique constraint
ALTER TABLE TestTable
ADD CONSTRAINT UC_TestTable_NewValue
UNIQUE (NewValue)
GO

--As a result we can see that there are two unique non-clustered indexes on the table TestTable:

--We can also see these indexes using T-SQL:

USE TestDB
GO

EXEC sys.sp_helpindex @objname = N'TestTable' 
GO

--Dropping a SQL Server Unique Index or Unique Constraint
USE TestDB
GO

-- Dropping indexes
DROP INDEX TestTable.UIX_TestTable_Value
GO

DROP INDEX TestTable.UC_TestTable_NewValue
GO

--We can see that the first index has been deleted, 
--however the second cannot be deleted with the "DROP INDEX" command and an error arises:

--Disable a SQL Server Unique Constraint
--Now let's check if it is possible to disable a unique constraint. The following command disables all constraints on the "TestTable" table:

USE TestDB
GO

-- Creating unique constraint
ALTER TABLE TestTable
ADD CONSTRAINT UC_TestTable_NewValue
UNIQUE (NewValue)
GO

-- Disabling all constraints
ALTER TABLE TestTable
NOCHECK CONSTRAINT ALL 
GO

--====================create table and db=====================================================
USE master 
GO

-- Creating database
CREATE DATABASE TestDB
GO

USE TestDB
GO

-- Creating table
CREATE TABLE TestTable
(
 ID INT,
 Value INT,
 NewValue INT,
 CONSTRAINT PK_TestTable_ID PRIMARY KEY (ID)
)

GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Info_Tables</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Compare Two Tables_3</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Info_Tables</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Compare Two Tables_3</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
-- http://www.experts-exchange.com/Microsoft/Development/MS-SQL-Server/SQL-Server-2005/Q_23675913.html





set nocount on
 
declare    @dbName1      varchar(64)
          ,@dbName2      varchar(64)
          ,@IncludeIndex bit
 
set @dbName1        = 'YourFirstDBName'
set @dbName2        = 'YourSecondDBName'
set @IncludeIndex   = 1
 
declare   @errStr        varchar(255)
 
if    not exists (select null from master.sys.sysdatabases where Name = @dbName1)
   or not exists (select null from master.sys.sysdatabases where Name = @dbName2)
     begin
          set @errStr='One or more of the databases to test were not found (' + @dbName1 + ', ' + @dbName2 + ')'
          goto exit_error
     end
 
create table #dbData1
     (TABLE_CATALOG                     varchar(64)
     ,TABLE_SCHEMA                      varchar(64)
     ,TABLE_NAME                        varchar(255)
     ,COLUMN_NAME                       varchar(255)
     ,ORDINAL_POSITION                  int
     ,COLUMN_DEFAULT                    varchar(255)
     ,IS_NULLABLE                       char(3)
     ,DATA_TYPE                         varchar(32)
     ,CHARACTER_MAXIMUM_LENGTH          bigint
     ,CHARACTER_OCTET_LENGTH            bigint
     ,NUMERIC_PRECISION                 int
     ,NUMERIC_PRECISION_RADIX           int
     ,NUMERIC_SCALE                     int
     ,DATETIME_PRECISION                int
     ,CHARACTER_SET_CATALOG             varchar(64)
     ,CHARACTER_SET_SCHEMA              varchar(64)
     ,CHARACTER_SET_NAME                varchar(64)
     ,COLLATION_CATALOG                 varchar(64)
     ,COLLATION_SCHEMA                  varchar(64)
     ,COLLATION_NAME                    varchar(64)
     ,DOMAIN_CATALOG                    varchar(64)
     ,DOMAIN_SCHEMA                     varchar(64)
     ,DOMAIN_NAME                       varchar(64)
     )
 
create table #dbData2
     (TABLE_CATALOG                     varchar(64)
     ,TABLE_SCHEMA                      varchar(64)
     ,TABLE_NAME                        varchar(255)
     ,COLUMN_NAME                       varchar(255)
     ,ORDINAL_POSITION                  int
     ,COLUMN_DEFAULT                    varchar(255)
     ,IS_NULLABLE                       char(3)
     ,DATA_TYPE                         varchar(32)
     ,CHARACTER_MAXIMUM_LENGTH          bigint
     ,CHARACTER_OCTET_LENGTH            bigint
     ,NUMERIC_PRECISION                 int
     ,NUMERIC_PRECISION_RADIX           int
     ,NUMERIC_SCALE                     int
     ,DATETIME_PRECISION                int
     ,CHARACTER_SET_CATALOG             varchar(64)
     ,CHARACTER_SET_SCHEMA              varchar(64)
     ,CHARACTER_SET_NAME                varchar(64)
     ,COLLATION_CATALOG                 varchar(64)
     ,COLLATION_SCHEMA                  varchar(64)
     ,COLLATION_NAME                    varchar(64)
     ,DOMAIN_CATALOG                    varchar(64)
     ,DOMAIN_SCHEMA                     varchar(64)
     ,DOMAIN_NAME                       varchar(64)
     )
 
create table #IndexData1
     (Table_Schema                      varchar(64)
     ,Table_Name                        nvarchar(255)
     ,Index_Name                        nvarchar(255)
     ,Index_Description                 nvarchar(1000)
     ,Index_Keys                        nvarchar(255)
     )
 
create table #IndexData2
     (Table_Schema                      varchar(64)
     ,Table_Name                        nvarchar(255)
     ,Index_Name                        nvarchar(255)
     ,Index_Description                 nvarchar(1000)
     ,Index_Keys                        nvarchar(255)
     )
 
create table #missingTables
     (TABLE_CATALOG                     varchar(64)
     ,TABLE_SCHEMA                      varchar(64)
     ,TABLE_NAME                        varchar(255)
     )
 
create table #missingColumns
     (TABLE_CATALOG                     varchar(64)
     ,TABLE_SCHEMA                      varchar(64)
     ,TABLE_NAME                        varchar(255)
     ,COLUMN_NAME                       varchar(255)
     ,ORDINAL_POSITION                  int
     )
 
create table #DiffColumnDef
     (TABLE_SCHEMA                      varchar(64)
     ,TABLE_NAME                        varchar(255)
     ,COLUMN_NAME                       varchar(255)
     ,DATA_TYPE1                        varchar(32)
     ,DATA_TYPE2                        varchar(32)
     ,CHARACTER_MAXIMUM_LENGTH1         bigint
     ,CHARACTER_MAXIMUM_LENGTH2         bigint
     ,COLUMN_DEFAULT1                   varchar(255)
     ,COLUMN_DEFAULT2                   varchar(255)
     ,IS_NULLABLE1                      char(3)
     ,IS_NULLABLE2                      char(3)
     )
 
create table #DiffColumnPos
     (TABLE_SCHEMA                      varchar(64)
     ,TABLE_NAME                        varchar(255)
     ,COLUMN_NAME                       varchar(255)
     ,ORDINAL_POSITION1                 int
     ,ORDINAL_POSITION2                 int
     )
 
create table #IndexDiff
     (Database_Name                     varchar(64)
     ,Table_Name                        varchar(64)
     ,Table_Schema                      varchar(64)
     ,Index_Name                        varchar(64)
     ,Index_Description                 nvarchar(1000)
     ,Index_Keys                        nvarchar(1000)
     )
 
insert into #dbData1
exec ('select * from [' + @dbName1 + '].information_schema.columns')
insert into #dbData2
exec ('select * from [' + @dbName2 + '].information_schema.columns')
 
 
if @IncludeIndex=1
begin -- if @IncludeIndex=1
     /* Gather index info
     */
     declare @Cmd   nvarchar(1000)
     declare IndexCursor cursor for
     select distinct 'Print ''Checking Index: ' + d1.Table_Schema +'.' + d1.Table_name  +'''
insert into #IndexData1 (Index_Name,Index_Description,Index_Keys)
          exec ' + @dbName1 + '.' + d1.Table_Schema + '.sp_helpindex [' + d1.Table_Name + ']
     insert into #IndexData2 (Index_Name,Index_Description,Index_Keys)
          exec ' + @dbName2 + '.' + d1.Table_Schema + '.sp_helpindex [' + d1.Table_Name + ']
     update #IndexData1 set Table_Name = ''' + d1.Table_Name + ''',Table_Schema = ''' + d1.Table_Schema + ''' where Table_Name is null
     update #IndexData2 set Table_Name = ''' + d1.Table_Name + ''',Table_Schema = ''' + d1.Table_Schema + ''' where Table_Name is null
     '
 
     from #DbData1 d1
       join #DbData2 d2
         on d1.table_Name = d2.Table_Name
         and d1.Table_Schema = d2.table_schema
 
 
     open IndexCursor
     fetch next from IndexCursor into @Cmd
     while @@Fetch_Status=0
     begin
 
          exec(@Cmd)
 
          fetch next from IndexCursor into @Cmd
     end
     close IndexCursor
     deallocate IndexCursor
 
 
     insert into #IndexDiff (database_name,Table_Name,table_schema,Index_Name,Index_Description,Index_Keys)
     select @DbName2,d1.Table_Name,d1.Table_Schema,d1.Index_Name,d1.Index_Description,d1.Index_Keys
     from #IndexData1 d1
       left outer join #IndexData2 d2
         on d1.Table_Name = d2.Table_Name
         and d1.Index_Name= d2.Index_Name
         and d1.Index_Description = d2.Index_Description
         and d1.Index_Keys = d2.Index_Keys
     where d2.Index_Name is null
 
     insert into #IndexDiff (database_name,Table_Name,table_schema,Index_Name,Index_Description,Index_Keys)
     select @DbName1,d2.Table_Name,d2.Table_Schema,d2.Index_Name,d2.Index_Description,d2.Index_Keys
     from #IndexData2 d2
       left outer join #IndexData1 d1
         on d1.Table_Name = d2.Table_Name
         and d1.Index_Name= d2.Index_Name
         and d1.Index_Description = d2.Index_Description
         and d1.Index_Keys = d2.Index_Keys
     where d1.Index_Name is null
end -- if @IncludeIndex=1
 
insert into #missingTables
select distinct @dbName2, d1.table_schema, d1.table_name
from #dbData1 d1
where not exists 
     (select null from #dbData2 d2 
      where d1.table_schema = d2.table_schema
        and d1.table_name = d2.table_name
     )
 
insert into #missingTables
select distinct @dbName1, d2.table_schema, d2.table_name
from #dbData2 d2
where not exists 
     (select null from #dbData1 d1
      where d1.table_schema = d2.table_schema
        and d1.table_name = d2.table_name
     )
 
 
 
 
insert into #missingcolumns
select distinct @dbName2, d1.table_schema, d1.table_name, d1.column_name,d1.Ordinal_Position
from #dbData1 d1
where not exists 
     (select null from #dbData2 d2 
      where d1.table_schema = d2.table_schema
        and d1.table_name = d2.table_name
        and d1.column_name = d2.column_name
     )
and not exists 
     (select null from #missingTables m2
      where d1.table_schema = m2.table_schema
        and d1.table_name = m2.table_name
     )
 
insert into #missingcolumns
select distinct @dbName1, d2.table_schema, d2.table_name, d2.column_name,d2.Ordinal_Position
from #dbData2 d2
where not exists 
     (select null from #dbData1 d1
      where d1.table_schema = d2.table_schema
        and d1.table_name = d2.table_name
        and d1.column_name = d2.column_name
     )
and not exists 
     (select null from #missingTables m2
      where d2.table_schema = m2.table_schema
        and d2.table_name = m2.table_name
     )
 
 
 
 
insert into #DiffColumnDef
select d1.table_schema, d1.table_name, d1.column_name
     ,d1.DATA_TYPE,d2.DATA_TYPE,d1.CHARACTER_MAXIMUM_LENGTH,d2.CHARACTER_MAXIMUM_LENGTH
     ,d1.COLUMN_DEFAULT,d2.COLUMN_DEFAULT
     ,d1.IS_NULLABLE,d2.IS_NULLABLE
from #dbData1 d1
  join #dbData2 d2
    on d1.table_schema = d2.table_schema
    and d1.table_name = d2.table_name
    and d1.column_name = d2.column_name
where d1.DATA_TYPE &lt;&gt; d2.DATA_TYPE
   or d1.COLUMN_DEFAULT &lt;&gt; d2.COLUMN_DEFAULT
   or d1.IS_NULLABLE &lt;&gt; d2.IS_NULLABLE
   or isnull(d1.CHARACTER_MAXIMUM_LENGTH,0) &lt;&gt; isnull(d2.CHARACTER_MAXIMUM_LENGTH,0)
 
insert into #DiffColumnPos
select d1.table_schema, d1.table_name, d1.column_name
     ,d1.ORDINAL_POSITION,d2.ORDINAL_POSITION
from #dbData1 d1
  join #dbData2 d2
    on d1.table_schema = d2.table_schema
    and d1.table_name = d2.table_name
    and d1.column_name = d2.column_name
where d1.ORDINAL_POSITION &lt;&gt; d2.ORDINAL_POSITION
 
select * from #missingTables
order by table_catalog,table_schema,table_name
 
select * from #DiffColumnDef
order by table_schema,table_name,column_name
 
select * from #missingColumns
order by table_catalog,table_schema,table_name,column_name
 
select * from #DiffColumnPos
order by table_schema,table_name,ordinal_position1,column_name
 
if @IncludeIndex=1
begin
     select * from #IndexDiff 
     order by database_name,table_name,table_schema,index_name,index_description,index_keys
end
 
 
 
goto exit_ok
 
exit_error:
raiserror(@errStr,16,1)
exit_ok:
 
 
 
go
if object_id('tempdb..#dbData1') is not null
     drop table #dbData1
if object_id('tempdb..#dbData2') is not null
     drop table #dbData2
if object_id('tempdb..#missingtables') is not null
     drop table #missingtables
if object_id('tempdb..#missingcolumns') is not null
     drop table #missingcolumns
if object_id('tempdb..#DiffColumnDef') is not null
     drop table #DiffColumnDef
if object_id('tempdb..#DiffColumnPos') is not null
     drop table #DiffColumnPos
if object_id('tempdb..#IndexData1') is not null
     drop table #IndexData1
if object_id('tempdb..#IndexData2') is not null
     drop table #IndexData2
if object_id('tempdb..#IndexDiff') is not null
     drop table #IndexDiff

Open in New WindowSelect All
bashka_abdyli:
08/25/08 11:00 AM, ID: 22307609
You can use this tool it is very sofisticated. Also there is a trial to download :

http://www.apexsql.com/sql_tools_diff.asp
townsma:
08/25/08 11:11 AM, ID: 22307705
I have found one of the best tools for this to be Redgate at www.red-gate.com. Again there is a trial version, but it is really easy to use, 
        and will also fix up the differences if you want it to.
Conain:
08/25/08 11:15 AM, ID: 22307728
Hey Brandon Thanks very much for the script sure it would help me a lot.
I have few questions does this script only brings the differences in table structures from two tables.
I would also like to know like if one table has Default, check constraint and all other constraints which might be missing in other table.

If the script given by you can bring that differences as well, also if not then please let me know where to modify to get that information.

Thanks for your help.
BrandonGalderisi:
08/25/08 11:42 AM, ID: 22307944
It only shows differences, not the items that are alike.

It does not give differences in constraints (check or default).

Default and check constraints can be implemented by comparing the data in sys.default_constraints and sys.check_constraints respectively.

You can just add a temp table and use the other queries as templates.  The parent_object_id is the id of the table in those tables.
Conain:
08/25/08 12:57 PM, ID: 22308654
Hi,
Thanks all for your help, I have downloaded the red-gate tool as well, this tool is very comprehensive.

Also the query given by Brandon is very good, I would use query and modify to get what I need thanks very much guys.
20110705-EE-VQP-215-X
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>01_C_SP_into_Table_step_3_TEST_insert_from_SP_into_TEMP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>01_C_SP_into_Table_step_3_TEST_insert_from_SP_into_TEMP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--01_C_SP_into_Table_step_3_TEST_insert_from_SP_into_TEMP


------------------------------------------------
--P_0020_TASK_020_RES_04_TEST_insert_from_SP_into_TEMP_v0.sql



--------------------------------DEBUG PARMS START
DECLARE @SearchString nvarchar(100)			--TranCode, TxnDesc, AcctNbr, CustomerName, CustomerNbr
SET @SearchString = ''
DECLARE @PaymentCategory nvarchar(100)			
SET @PaymentCategory = 'ALL'
DECLARE @PaymentChannel nvarchar(100)			
SET @PaymentChannel = 'ALL'
DECLARE @PaymentType nvarchar(100)			
SET @PaymentType = 'ALL'
DECLARE @PaymentDescription nvarchar(100)			
SET @PaymentDescription = 'ALL'

DECLARE @StartDate date
SELECT @StartDate = '10-01-2019'

DECLARE @EndDate date
SELECT @EndDate = '10-17-2019'
--------------------------------DEBUG PARMS END

IF OBJECT_ID('tempdb..#Details01') IS NOT NULL
	DROP TABLE #Details01

CREATE TABLE #Details01
(
	[PaymentCategory] [varchar](25) NULL,
	[PaymentChannel] [varchar](50) NULL,
	[PaymentType] [varchar](16) NOT NULL,
	[PaymentDescription] [varchar](200) NULL,
	[TranCode] [varchar](4) NULL,
	[TxnDesc] [varchar](10) NULL,
	[ProcessDate] [datetime] NOT NULL,
	[AcctNbr] [char](20) NOT NULL,
	[CustomerName] [varchar](15) NULL,
	[CustomerNbr] [char](7) NOT NULL,
	[PrinAmt] [money] NULL,
	[IntAmt] [money] NULL,
	[MiscAmt] [money] NULL,
	[TotalAmt] [money] NULL,
	[PaymentCategorySort] [varchar](25) NULL,
	[PaymentChannelSort] [varchar](50) NULL
)

INSERT #Details01 EXEC	[RiskMngt].[Reporting].[P_0020_TASK_021_SP_01_MAIN_PaymentDetail]     --&lt;========== INSERT into Temp table
		 @SearchString = @SearchString,	
         @PaymentCategory = @PaymentCategory,
         @PaymentChannel = @PaymentChannel,
         @PaymentType = @PaymentType,
         @PaymentDescription = @PaymentDescription,
		 @StartDate = @StartDate,
		 @EndDate = @EndDate  
		 
Select TOP(111) * from 	#Details01	                 	
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Append_to_existing_Table__using_SELECT_OVER_example</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Append_to_existing_Table__using_SELECT_OVER_example</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE [Success];
GO


DECLARE @BeginDate_DateRange as date
DECLARE @EndDate_DateRange as date
SELECT @BeginDate_DateRange = '01-01-2017'
SELECT @EndDate_DateRange = '03-31-2017'	



----------------------- Local Variables
   DECLARE @LineNumber int
   DECLARE @Source nvarchar(100)
   DECLARE @Title nvarchar(255)
----------------------------------------
IF OBJECT_ID('dbo.zzz_p0021_21_IDR_part_B_and_C') IS NOT NULL
    DROP TABLE dbo.zzz_p0021_21_IDR_part_B_and_C


CREATE TABLE [dbo].[zzz_p0021_21_IDR_part_B_and_C]
(
		[IDR_a_b_PK] [int] IDENTITY(1,1) NOT NULL,		
		[LineNumber] [int] NOT NULL,
		[Source] nvarchar(100) NOT NULL,
		[Line_Title] nvarchar(255) NOT NULL,
		[DateTime_Created] [datetime] NOT NULL CONSTRAINT IDR_a_b_TheDateTime_Default_GETDATE DEFAULT GETDATE(),
		[Result] [int] NOT NULL,
		[YYYY_MM] nvarchar(7),
		[IDR_a_b_RowVersion] [timestamp] NULL
	,CONSTRAINT [zzz_p0021_21_IDR_part_B_and_C$IDR_a_b_PK] PRIMARY KEY NONCLUSTERED 
		(
			[IDR_a_b_PK] ASC
		)
		WITH 
				(
					PAD_INDEX  = OFF, 
					STATISTICS_NORECOMPUTE  = OFF, 
					IGNORE_DUP_KEY = OFF, 
					ALLOW_ROW_LOCKS  = ON, 
					ALLOW_PAGE_LOCKS  = ON
				) ON [PRIMARY]
)

--Line: [4]----Source: [B-001]-----Description: [East Jefferson Health Center] =================================START

SELECT @LineNumber = 4
SELECT @Source = '[B-001]'
SELECT @Title = '[East Jefferson Health Center]'
;
WITH cte_Line_4
AS
(
	SELECT distinct
		  [Office_Location],
		  [Bill_Provider_Name],
		  [Patient_No],
		  [Patient_Name],
		  [Check-In_Day],
		  --------------------New Distinct fields below this line
		  [YYYY_MM]
	  FROM [Success].[dbo].[zzz_p0021_20_DataFromARCHIVE_for_DateRange]
	  Where (
				[Office_Location] = 'EB JeffCare'
				--Office_Name = 'JEFFCARE EAST JEFFERSON'
				AND
				Bill_Provider_Specialty = 'FAMILY PRACTICE'

			)


)

INSERT INTO [Success].[dbo].[zzz_p0021_21_IDR_part_B_and_C]   --&lt;============== APPEND to existing table
		(
		[LineNumber],
		[Source],
		[Line_Title],
		[YYYY_MM],
		[Result]
		)
SELECT DISTINCT
			@LineNumber as [LineNumber]
			,@Source as [Source]
			,@Title as [Title]
			,[YYYY_MM]
			, Count(*) OVER(PARTITION BY [YYYY_MM]) As [Result]
FROM cte_Line_4 
ORDER BY YYYY_MM
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSERT_INTO_from_a_CTE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSERT_INTO_from_a_CTE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0006_305_Create_Individual_INVREG_WorkFlows.sql

use barriere
go

--NEED TO LEAVE the PK in this b/c that is the counter for the last step
DECLARE @tmp table (
					 PK INT IDENTITY(1,1) PRIMARY KEY NOT NULL
					 , [APM_TYPE] nvarchar(8)
					 , [APM_SUBTYPE] nvarchar(8)
					 , [RULE_DESC] nvarchar(30)
					 , [SELECTED] nvarchar(1)
					 , [FORM] nvarchar(4)
					 , [WORKFLOW_IND] nvarchar(1)					 					 					 					 					 					 
					)
					
DECLARE @PK INT = 0					
					
DECLARE @APM_TYPE nvarchar(8) 
DECLARE @APM_SUBTYPE nvarchar(8)
DECLARE @RULE_DESC nvarchar(30)
DECLARE @SELECTED nvarchar(1)
DECLARE @FORM nvarchar(4)
DECLARE @WORKFLOW_IND nvarchar(1)


;with CTE_WorkFlowParms as
(select 
		cast('INVREG' as [nvarchar](8)) as [APM_TYPE]
		, cast('JUNK' as [nvarchar](8)) as [APM_SUBTYPE]
		, cast('junk for testing' as [nvarchar](30)) as [RULE_DESC]
		, cast(N' ' as [nvarchar](1)) as [SELECTED]
		, cast(N' ' as [nvarchar](4)) as [FORM]
		, cast(N' ' as [nvarchar](1)) as [WORKFLOW_IND]
		
union select 'INVREG',N'invALO',N'inv to: Aaron Lofton',N' ',N' ',N' '
union select 'INVREG',N'invABG',N'inv to: Abbie Graffeo',N' ',N' ',N' '
union select 'INVREG',N'invAGO',N'inv to: Adriane Gonzalez',N' ',N' ',N' '
union select 'INVREG',N'invAR',N'inv to: Amber Reese',N' ',N' ',N' '
union select 'INVREG',N'invAW',N'inv to: Andrew Wilson',N' ',N' ',N' '

)
--select TOP(2)
--		[APM_TYPE]
--		,[APM_SUBTYPE]
--		,[RULE_DESC]
--		,[SELECTED]
--		,[FORM]
--		,[WORKFLOW_IND]
--from CTE_WorkFlowParms;


INSERT INTO @tmp SELECT --TOP(2)
						[APM_TYPE] 
						,[APM_SUBTYPE]
						,[RULE_DESC]
						,[SELECTED]
						,[FORM]
						,[WORKFLOW_IND]
FROM CTE_WorkFlowParms


--SELECT * FROM @tmp


WHILE (1=1)
BEGIN
    SELECT 
			@PK = PK    
			,@APM_TYPE = APM_TYPE
			,@APM_SUBTYPE = APM_SUBTYPE
			,@RULE_DESC = RULE_DESC
			,@SELECTED = SELECTED
			,@FORM = FORM
			,@WORKFLOW_IND = WORKFLOW_IND										
			
			
			
    FROM @tmp
    WHERE PK = @PK + 1
	--PRINT '============================================================PK = @PK + 1,   PK is: '  + CAST(@PK AS varchar(5))
	--PRINT '@APM_TYPE: ' + @APM_TYPE
	--PRINT '@APM_SUBTYPE: ' + @APM_SUBTYPE
	--PRINT '@RULE_DESC: ' + @RULE_DESC
	
	
		
    IF @@rowcount = 0 BREAK;
	PRINT '============================================================PK = @PK + 1,   PK is: '  + CAST(@PK AS varchar(5))
	PRINT '@APM_TYPE: ' + @APM_TYPE
	PRINT '@APM_SUBTYPE: ' + @APM_SUBTYPE
	PRINT '@RULE_DESC: ' + @RULE_DESC    
	PRINT '@@rowcount was not 0'
    -- call your sproc
    exec prj_0006_SP_0001_CreateWorkFlow @APM_TYPE, @APM_SUBTYPE, @RULE_DESC, @SELECTED, @FORM, @WORKFLOW_IND   --&lt;==== calls the SP
	PRINT 'SP ran'    
END


\\\\\\\\\\\\\\\\\\\\\SP that does the work:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

--prj_0006_SP_0001_CreateWorkFlow.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 7/15/2016
	By: glenn garson
	************************************************************************************
*/



USE barriere
GO


create Procedure prj_0006_SP_0001_CreateWorkFlow(
		 @APM_TYPE as NVARCHAR(8)
		,@APM_SUBTYPE as NVARCHAR(8)
		,@RULE_DESC as NVARCHAR(30)
		,@SELECTED as NVARCHAR(1)
		,@FORM as NVARCHAR(4)
		,@WORKFLOW_IND as NVARCHAR(1)						
	)

as
INSERT into SW_APM_FLM (
							APM_TYPE,			--This is the name of the workflow type (e.g. INVREG, or PO
							APM_SUBTYPE,		--This corresponds to the Sub Rule in the "WorkFlow Rules" panel (max Length: 8) can use persons UserID her	
							RULE_DESC,			--This corresponds to the Comment in the "WorkFlow Rules" panel (max length: 30)
							SELECTED,
							FORM,				--(max length: 3)
							WORKFLOW_IND
						)
values(
		@APM_TYPE
		,@APM_SUBTYPE
		,@RULE_DESC
		,@SELECTED
		,@FORM
		,@WORKFLOW_IND
		)	
	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSERT_INTO_from_a_JOIN_select_statement</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSERT_INTO_from_a_JOIN_select_statement</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>/*	prj_8011_404_UPDATE_LNK06_from_LNK05_and_LNK01.sql
	************************************************************************************
	NOTE: Use this to copy the data from LNK05 and LNK01, in order to remove LNK01, and replace it with LNK06
	Uses: 
	Created: 11/19/2014
	By: glenn garson
	************************************************************************************
*/

Use DB2_CRM
go

INSERT INTO LNK06_T1_T12 (LNK06_T1_T12.T1_FK, LNK06_T1_T12.T12_FK)
--from here down is actually a sub-query
SELECT  
	T5_Practice_Branch.T1_FK,
	LNK01_T5_T12_T13.T12_FK

FROM  T5_Practice_Branch 
	  INNER JOIN
      LNK01_T5_T12_T13 ON T5_Practice_Branch.T5_PK = LNK01_T5_T12_T13.T5_FK

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSERT_INTO_from_a_SELECT_statement</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSERT_INTO_from_a_SELECT_statement</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--INSERT_INTO_from_a_SELECT_statement

INSERT INTO table2
SELECT * FROM table1;

--Or we can copy only the columns we want to into another, existing table:
--------------------------------------------------------------------------
INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSERT_INTO_temp_table_From_STORED_PROC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSERT_INTO_temp_table_From_STORED_PROC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--INSERT_INTO_temp_table_From_STORED_PROC



CREATE PROCEDURE [dbo].[spex_B2W_Equipment]
AS
    BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
        SET NOCOUNT ON;

    -- Insert statements for procedure here

        CREATE TABLE #BusinessUnits
            (
              Name VARCHAR(128) ,
              Location VARCHAR(128) ,
              ParentBusinessUnits VARCHAR(128)
            )            
        INSERT  INTO #BusinessUnits
                EXEC spex_B2W_BusinessUnits   -- &lt;==============================================
                
        ...
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\Source SP       
 CREATE PROCEDURE [dbo].[spex_B2W_BusinessUnits]
AS
    BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
        SET NOCOUNT ON;
	
        DECLARE @BusinessUnits TABLE
            (
              Name VARCHAR(128) ,
              Location VARCHAR(128) ,
              ParentBusinessUnits VARCHAR(128)
            )

    -- Insert statements for procedure here
        INSERT  INTO @BusinessUnits
                ( Name ,
                  Location ,
                  ParentBusinessUnits
                )
        VALUES  ( 'Barriere Construction Co., L.L.C.' ,
                  'Metairie, LA' ,
                  ''
                )
        INSERT  INTO @BusinessUnits
                ( Name ,
                  Location ,
                  ParentBusinessUnits
                )
        VALUES  ( 'NSA' ,
                  '' ,
                  'Barriere Construction Co., L.L.C.'
                )		
        INSERT  INTO @BusinessUnits
                ( Name ,
                  Location ,
                  ParentBusinessUnits
                )
        VALUES  ( 'MAT' ,
                  '' ,
                  'Barriere Construction Co., L.L.C.'
                )		
        INSERT  INTO @BusinessUnits
                ( Name ,
                  Location ,
                  ParentBusinessUnits
                )
        VALUES  ( 'HCC' ,
                  '' ,
                  'Barriere Construction Co., L.L.C.'
                )		
        INSERT  INTO @BusinessUnits
                ( Name ,
                  Location ,
                  ParentBusinessUnits
                )
        VALUES  ( 'SSA' ,
                  '' ,
                  'Barriere Construction Co., L.L.C.'
                )		
        INSERT  INTO @BusinessUnits
                ( Name ,
                  Location ,
                  ParentBusinessUnits
                )
        VALUES  ( 'IND' ,
                  '' ,
                  'Barriere Construction Co., L.L.C.'
                )		
        INSERT  INTO @BusinessUnits
                ( Name ,
                  Location ,
                  ParentBusinessUnits
                )
        VALUES  ( 'BRD' ,
                  '' ,
                  'Barriere Construction Co., L.L.C.'
                )	
		
        SELECT  *
        FROM    @BusinessUnits			
    END

GO
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSERT_INTO</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSERT_INTO</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>INSERT INTO PV_VoucherComments_sst
	(Public_Vouchers_FK, PV_Bills_FK, HOLD_UserName, HOLD_Started_DateTime)
VALUES
	(@Public_Vouchers_PK, @PV_Bills_PK, @UserName, GETDATE() )
	
	
///////////////////////////////////////////////////

--prj_1027_409_Insert_TestData_into_T22.sql
-- This is optional for debugging purposes


use DB2_CRM
go



INSERT INTO [DB2_CRM].[dbo].[T22_CCWNC_Employee_AccountingPortal]
           ([T9_FK]
           ,[ADP_Number]
           ,[Full_Time_Employment_Percent]
           ,[Employment_Start_Date]
           ,[Employment_End_Date]
           ,[Accounting_First_Name]
           ,[Accounting_Middle_Name]
           ,[Accounting_Last_Name]
           ,[Accounting_Effective_Date_Start]
           ,[Accounting_Effective_Date_End]
           ,[Accounting_Effective_Change_e28]
           ,[b_Accounting_Unfilled_Position]
           ,[b_Accounting_Unfilled_Position_onHOLD]
           ,[Accounting_Unfilled_PositionDescription]
           ,[Accounting_ParentGroup_e29]
           ,[Accounting_ChildGroup_e30]
           ,[Accounting_Notes])
     VALUES
           (0,0000,1.00,NULL,NULL,NULL,NULL,NULL,'2013-05-29','2014-05-29',1,1,0,'DATA ANALYST',1,1,'Test Unfilled Position')
GO          
                                          
//////Multiple rows/////////////////////////////////////////////	
	
--INSERT INTO Table ( Column1, Column2 ) VALUES
--( Value1, Value2 ), ( Value1, Value2 )	


...............


/*	prj_0038_701_TestDataFor_T30.sql
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 5/27/2014
	By: glenn garson
	************************************************************************************
*/

USE [DB2_CRM]
GO

INSERT INTO [DB2_CRM].[dbo].[T30_NewHire]
	(  --[T30_PK]
       [IncludeInNewHireListForHR_e00]
      ,[FirstName]
      ,[MiddleName]
      ,[LastName]
      ,[SupervisorName]
      ,[SupervisorEmailAddress]
      ,[Supervisor_T9_FK]
      ,[StartDate]
      ,[90DayReviewDate]
      ,[NCDriversLicenseNumber]
      ,[SSNLast4]
      )
  VALUES
		(
			2,
			'F1test',
			'M1Test',
			'L1Test',
			'Glenn Garson',
			'ggarson@ccwnc.org',
			33,
			'05/28/2014',
			'08/28/2014',
			'12345678',
			'2468'
		),
		(
			2,
			'F2test',
			'M2Test',
			'L2Test',
			'Glenn Garson',
			'ggarson@ccwnc.org',
			33,
			'05/29/2014',
			'08/29/2014',
			'23456789',
			'4680'
		),
		(
			2,
			'F3test',
			'M3Test',
			'L3Test',
			'Glenn Garson',
			'ggarson@ccwnc.org',
			33,
			'05/30/2014',
			'08/30/2014',
			'34567891',
			'6802'
		)				</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSERT_where_They_DoNot_Already_Exist</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSERT_where_They_DoNot_Already_Exist</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Add Cost Codes that have Original Quantities, but no Job Cost Transactions
    INSERT  @JCholder2
            ( COMPANY ,
              JOB ,
              COST_CODE ,
              PrevQty ,
              CurrQty ,
              PrevQtyBilled ,
              PrevAccrualQty
            )
            SELECT  @inCOMPANY ,
                    a.JOB ,
                    a.COST_CODE ,
                    0 ,
                    0 ,
                    0 ,
                    0
            FROM    JC_CONTROLESTIM AS a
            WHERE   a.ORIG_QTY &lt;&gt; 0
                    AND a.JOB = @inJOB
                    AND NOT EXISTS ( SELECT *
                                     FROM   @JCholder2 AS b
                                     WHERE  b.COST_CODE = a.COST_CODE )
            GROUP BY a.JOB ,
                    a.COST_CODE</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ReadMe_INSERT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ReadMe_INSERT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ReadMe_INSERT</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>INSERT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>rowversion_or_timestamp_in_DestinationTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>INSERT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>rowversion_or_timestamp_in_DestinationTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


--For this table definition, which has a rowversion:
--You must list the columns in the INSERT statement , see below


CREATE TABLE [Reporting].[T210_Columns_for_Tables_in_Databases](

	[T210_PK] [int] IDENTITY(1,1) NOT NULL,
	[T210_RowVersion] [timestamp] NOT NULL,
	----------------------------------------
	[DatabaseName] [nvarchar](25) NULL,
	[DataAcquiredDateTime] [datetime] NULL,
	[Table_Name] [sysname] NOT NULL,
	[Column_Name] [sysname] NULL,
	[Data_Type] [sysname] NOT NULL,
	[Size] [smallint] NOT NULL,
	[Precision_Scale] [varchar](61) NULL,
	[flag_Current] [int] NOT NULL,
	[schemaName] [nvarchar](128) NULL,
	----------------------------------------


 CONSTRAINT [T210_PrimaryKey_$_T210_PK] PRIMARY KEY CLUSTERED 
(
	[T210_PK] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO


---==================================================================================

--P_0017_TASK_006_RES_04_STEP_3_LIST_of_all_FIELDS_in_all_TABLES_of_database_INSERT_INTO_T210_v2.sql



use RiskMngt
go
DECLARE @sDatabase nvarchar(25)	
SELECT @sDatabase = 'RiskMngt'

DECLARE @dataAcquiredDateTime as DateTime = getdate()	

--IF OBJECT_ID('riskmngt.reporting.gg_junk') IS NOT NULL
--    DROP TABLE riskmngt.reporting.gg_junk



INSERT INTO [RiskMngt].[Reporting].[T210_Columns_for_Tables_in_Databases](	[DatabaseName]           --&lt;============ LIST THE COLUMNS
      ,[DataAcquiredDateTime]
      ,[Table_Name]
      ,[Column_Name]
      ,[Data_Type]
      ,[Size]
      ,[Precision_Scale]
      ,[flag_Current]
      ,[schemaName])
	
 SELECT
		@sDatabase as [DatabaseName]
		,
		@dataAcquiredDateTime as [DataAcquiredDateTime]
		, 
		T.name AS [Table_Name] 
		,
		C.name AS [Column_Name] 
		,
		P.name AS [Data_Type]
		 ,
		P.max_length AS [Size]
		 ,
		CAST(P.precision AS VARCHAR) + '/' + CAST(P.scale AS VARCHAR) AS [Precision_Scale]
		,
		1 as [flag_Current]
		------------------------------
		,
		SCHEMA_NAME(T.schema_id) as [schemaName]


--INTO riskmngt.reporting.gg_junk
FROM   
		sys.objects AS T
		JOIN 
		sys.columns AS C 
		ON T.object_id = C.object_id
		
		JOIN 
		sys.types AS P 
		ON C.system_type_id = P.system_type_id



WHERE  T.type_desc = 'USER_TABLE';
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>LOG_file</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name> fn_dblog() _To_view the transaction log records</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>LOG_file</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name> fn_dblog() _To_view the transaction log records</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--FROM: https://logicalread.com/sql-server-dbcc-log-command-tl01/#.WNkPqvnyvcs

--The fn_dblog() function (formerly known as the DBCC command) is one of several undocumented functions for SQL Server; 
--it allows you to view the transaction log records in the active part of the transaction log file for the current database.

--Note that use of the fn_dblog() function (and all other undocumented commands) against a production database instance is executed at your own risk.

--fn_dblog() Parameters

--The fn_dblog() function accepts two parameters:

--    The first is starting log sequence number, or LSN. You can also specify NULL, which means it will return everything from the start of the log.
--    The second is the ending LSN. You can also specify NULL, which means you want to return everything to the end of the log.

--The fn_dblog() function is fairly simple. Use the fn_dblog() function as shown below in Example 1 to get info from the transaction log.

--fn_dblog() Example 1

--This basic fn_dblog() function statement will return details from the transaction log:

SELECT * FROM fn_dblog(NULL, NULL)

--This sample statement will find all log records associated with dropped objects:

SELECT * FROM fn_dblog(NULL, NULL) WHERE [Transaction Name] = ‘DROPOBJ’

--You can also examine the results to track parent and child objects, as shown in Example 3.

SELECT [Current LSN], [Operation], [Context], [Transaction ID], [AllocUnitName], [Page ID], [Transaction Name], [Parent Transaction ID], [Description] FROM fn_dblog(NULL, NULL)

--When the [Parent Transaction ID] value is not NULL, 
--	that means you can see the actions that initiated the log activity by filtering for that [Transaction ID] value. 
--	For example, let’s say that I find a [Parent Transaction ID] of 0000:00004b1d. 
--	I can then run this command to see what triggered that event (with special thanks for the 


SET NOCOUNT ON
DECLARE @LSN NVARCHAR(46)
DECLARE @LSN_HEX NVARCHAR(25)
DECLARE @trx_id NVARCHAR(28) = '0000:00004b1d'
DECLARE @tbl TABLE (id INT identity(1,1), i VARCHAR(10))
DECLARE @stmt VARCHAR(256)

SET @LSN = (SELECT TOP 1 [Current LSN] FROM fn_dblog(NULL, NULL) WHERE [Transaction ID] = @trx_id)

SET @stmt = 'SELECT CAST(0x' + SUBSTRING(@LSN, 1, 8) + ' AS INT)'
INSERT @tbl EXEC(@stmt)
SET @stmt = 'SELECT CAST(0x' + SUBSTRING(@LSN, 10, 8) + ' AS INT)'
INSERT @tbl EXEC(@stmt)
SET @stmt = 'SELECT CAST(0x' + SUBSTRING(@LSN, 19, 4) + ' AS INT)'
INSERT @tbl EXEC(@stmt)

SET @LSN_HEX =
 (SELECT i FROM @tbl WHERE id = 1) + ':' + (SELECT i FROM @tbl WHERE id = 2) + ':' + (SELECT i FROM @tbl WHERE id = 3)

SELECT [Current LSN], [Operation], [Context], [Transaction ID], [AllocUnitName], [Page ID], [Transaction Name], [Parent Transaction ID], [Description] 
FROM fn_dblog(@LSN_HEX, NULL)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Logins_Users</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>MigrateCreate_UserAccounts_and_Logins</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Logins_Users</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>MigrateCreate_UserAccounts_and_Logins</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://dba.stackexchange.com/questions/40844/after-moving-database-backup-restore-i-have-to-re-add-user

/*
 Run it from the Server that you have restored the database to and supply the original Server name as a parameter to the procedure.
 */
 
USE [master]
GO
/****** Object:  StoredProcedure [dbo].[stp_Admin_ReplicateUserLogins]    Script Date: 10/29/2015 08:22:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


ALTER Procedure [dbo].[stp_Admin_ReplicateUserLogins] --'OriginalSourceDatabase', 1
    @PartnerServer sysname,
    @Debug bit = 0 -- 0 = Create Users, 1 = Display SQL command but doesn't execute query.
As

Declare @MaxID int,
    @CurrID int,
    @SQL nvarchar(max),
    @LoginName sysname,
    @IsDisabled int,
    @Type char(1),
    @SID varbinary(85),
    @SIDString nvarchar(100),
    @PasswordHash varbinary(256),
    @PasswordHashString nvarchar(300),
    @RoleName sysname,
    @Machine sysname,
    @PermState nvarchar(60),
    @PermName sysname,
    @Class tinyint,
    @MajorID int,
    @ErrNumber int,
    @ErrSeverity int,
    @ErrState int,
    @ErrProcedure sysname,
    @ErrLine int,
    @ErrMsg nvarchar(2048)
Declare @Logins Table (LoginID int identity(1, 1) not null primary key,
                        [Name] sysname not null,
                        [SID] varbinary(85) not null,
                        IsDisabled int not null,
                        [Type] char(1) not null,
                        PasswordHash varbinary(256) null)
Declare @Roles Table (RoleID int identity(1, 1) not null primary key,
                    RoleName sysname not null,
                    LoginName sysname not null)
Declare @Perms Table (PermID int identity(1, 1) not null primary key,
                    LoginName sysname not null,
                    PermState nvarchar(60) not null,
                    PermName sysname not null,
                    Class tinyint not null,
                    ClassDesc nvarchar(60) not null,
                    MajorID int not null,
                    SubLoginName sysname null,
                    SubEndPointName sysname null)

Set NoCount On;

If CharIndex('\', @PartnerServer) &gt; 0
  Begin
    Set @Machine = LEFT(@PartnerServer, CharIndex('\', @PartnerServer) - 1);
  End
Else
  Begin
    Set @Machine = @PartnerServer;
  End

-- Get all Windows logins from principal server
Set @SQL = 'Select P.name, P.sid, P.is_disabled, P.type, L.password_hash' + CHAR(10) +
        'From ' + QUOTENAME(@PartnerServer) + '.master.sys.server_principals P' + CHAR(10) +
        'Left Join ' + QUOTENAME(@PartnerServer) + '.master.sys.sql_logins L On L.principal_id = P.principal_id' + CHAR(10) +
        'Where P.type In (''U'', ''G'', ''S'')' + CHAR(10) +
        'And P.name &lt;&gt; ''sa''' + CHAR(10) +
        'And P.name Not Like ''##%''' + CHAR(10) +
        'and P.Name Not like ''NT SERVICE%''' + CHAR(10) +
        'And CharIndex(''' + @Machine + '\'', P.name) = 0;';

Insert Into @Logins (Name, SID, IsDisabled, Type, PasswordHash)
Exec sp_executesql @SQL;

-- Get all roles from principal server
Set @SQL = 'Select RoleP.name, LoginP.name' + CHAR(10) +
        'From ' + QUOTENAME(@PartnerServer) + '.master.sys.server_role_members RM' + CHAR(10) +
        'Inner Join ' + QUOTENAME(@PartnerServer) + '.master.sys.server_principals RoleP' +
        CHAR(10) + char(9) + 'On RoleP.principal_id = RM.role_principal_id' + CHAR(10) +
        'Inner Join ' + QUOTENAME(@PartnerServer) + '.master.sys.server_principals LoginP' +
        CHAR(10) + char(9) + 'On LoginP.principal_id = RM.member_principal_id' + CHAR(10) +
        'Where LoginP.type In (''U'', ''G'', ''S'')' + CHAR(10) +
        'And LoginP.name &lt;&gt; ''sa''' + CHAR(10) +
        'And LoginP.name Not Like ''##%''' + CHAR(10) +
        'And LoginP.name Not Like ''NT SERVICE%''' + CHAR(10) +
        'And RoleP.type = ''R''' + CHAR(10) +
        'And CharIndex(''' + @Machine + '\'', LoginP.name) = 0;';

Insert Into @Roles (RoleName, LoginName)
Exec sp_executesql @SQL;

-- Get all explicitly granted permissions
Set @SQL = 'Select P.name Collate database_default,' + CHAR(10) +
        '   SP.state_desc, SP.permission_name, SP.class, SP.class_desc, SP.major_id,' + CHAR(10) +
        '   SubP.name Collate database_default,' + CHAR(10) +
        '   SubEP.name Collate database_default' + CHAR(10) +
        'From ' + QUOTENAME(@PartnerServer) + '.master.sys.server_principals P' + CHAR(10) +
        'Inner Join ' + QUOTENAME(@PartnerServer) + '.master.sys.server_permissions SP' + CHAR(10) +
        CHAR(9) + 'On SP.grantee_principal_id = P.principal_id' + CHAR(10) +
        'Left Join ' + QUOTENAME(@PartnerServer) + '.master.sys.server_principals SubP' + CHAR(10) +
        CHAR(9) + 'On SubP.principal_id = SP.major_id And SP.class = 101' + CHAR(10) +
        'Left Join ' + QUOTENAME(@PartnerServer) + '.master.sys.endpoints SubEP' + CHAR(10) +
        CHAR(9) + 'On SubEP.endpoint_id = SP.major_id And SP.class = 105' + CHAR(10) +
        'Where P.type In (''U'', ''G'', ''S'')' + CHAR(10) +
        'And P.name &lt;&gt; ''sa''' + CHAR(10) +
        'And P.name Not Like ''##%''' + CHAR(10) +
        'And P.name Not Like ''NT SERVICE%''' + CHAR(10) +
        'And CharIndex(''' + @Machine + '\'', P.name) = 0;'

Insert Into @Perms (LoginName, PermState, PermName, Class, ClassDesc, MajorID, SubLoginName, SubEndPointName)
Exec sp_executesql @SQL;



Select @MaxID = Max(LoginID), @CurrID = 1
From @Logins;

While @CurrID &lt;= @MaxID
  Begin
    Select @LoginName = Name,
        @IsDisabled = IsDisabled,
        @Type = [Type],
        @SID = [SID],
        @PasswordHash = PasswordHash
    From @Logins
    Where LoginID = @CurrID;

    If Not Exists (Select 1 From sys.server_principals
                Where name = @LoginName)
      Begin
        Set @SQL = 'Create Login ' + quotename(@LoginName)
        If @Type In ('U', 'G')
          Begin
            Set @SQL = @SQL + ' From Windows;'
          End
        Else
          Begin
            Set @PasswordHashString = '0x' +
                Cast('' As XML).value('xs:hexBinary(sql:variable("@PasswordHash"))', 'nvarchar(300)');

            Set @SQL = @SQL + ' With Password = ' + @PasswordHashString + ' HASHED, ';

            Set @SIDString = '0x' +
                Cast('' As XML).value('xs:hexBinary(sql:variable("@SID"))', 'nvarchar(100)');
            Set @SQL = @SQL + 'SID = ' + @SIDString + ';';
          End

        If @Debug = 0
          Begin
            Begin Try
                Exec sp_executesql @SQL;
            End Try
            Begin Catch
                Set @ErrNumber = ERROR_NUMBER();
                Set @ErrSeverity = ERROR_SEVERITY();
                Set @ErrState = ERROR_STATE();
                Set @ErrProcedure = ERROR_PROCEDURE();
                Set @ErrLine = ERROR_LINE();
                Set @ErrMsg = ERROR_MESSAGE();
                RaisError(@ErrMsg, 1, 1);
            End Catch
          End
        Else
          Begin
            Print @SQL;
          End

        If @IsDisabled = 1
          Begin
            Set @SQL = 'Alter Login ' + quotename(@LoginName) + ' Disable;'
            If @Debug = 0
              Begin
                Begin Try
                    Exec sp_executesql @SQL;
                End Try
                Begin Catch
                    Set @ErrNumber = ERROR_NUMBER();
                    Set @ErrSeverity = ERROR_SEVERITY();
                    Set @ErrState = ERROR_STATE();
                    Set @ErrProcedure = ERROR_PROCEDURE();
                    Set @ErrLine = ERROR_LINE();
                    Set @ErrMsg = ERROR_MESSAGE();
                    RaisError(@ErrMsg, 1, 1);
                End Catch
              End
            Else
              Begin
                Print @SQL;
              End
          End
        End
    Set @CurrID = @CurrID + 1;
  End

Select @MaxID = Max(RoleID), @CurrID = 1
From @Roles;

While @CurrID &lt;= @MaxID
  Begin
    Select @LoginName = LoginName,
        @RoleName = RoleName
    From @Roles
    Where RoleID = @CurrID;

    If Not Exists (Select 1 From sys.server_role_members RM
                Inner Join sys.server_principals RoleP
                    On RoleP.principal_id = RM.role_principal_id
                Inner Join sys.server_principals LoginP
                    On LoginP.principal_id = RM.member_principal_id
                Where LoginP.type In ('U', 'G', 'S')
                And RoleP.type = 'R'
                And RoleP.name = @RoleName
                And LoginP.name = @LoginName)
      Begin
        If @Debug = 0
          Begin
            Exec sp_addsrvrolemember @rolename = @RoleName,
                            @loginame = @LoginName;
          End
        Else
          Begin
            Print 'Exec sp_addsrvrolemember @rolename = ''' + @RoleName + ''',';
            Print '     @loginame = ''' + @LoginName + ''';';
          End
      End

    Set @CurrID = @CurrID + 1;
  End

Select @MaxID = Max(PermID), @CurrID = 1
From @Perms;

While @CurrID &lt;= @MaxID
  Begin
    Select @PermState = PermState,
        @PermName = PermName,
        @Class = Class,
        @LoginName = LoginName,
        @MajorID = MajorID,
        @SQL = PermState + space(1) + PermName + SPACE(1) +
            Case Class When 101 Then 'On Login::' + QUOTENAME(SubLoginName)
                    When 105 Then 'On ' + ClassDesc + '::' + QUOTENAME(SubEndPointName)
                    Else '' End +
            ' To ' + QUOTENAME(LoginName) + ';'
    From @Perms
    Where PermID = @CurrID;

    If Not Exists (Select 1 From sys.server_principals P
                Inner Join sys.server_permissions SP On SP.grantee_principal_id = P.principal_id
                Where SP.state_desc = @PermState
                And SP.permission_name = @PermName
                And SP.class = @Class
                And P.name = @LoginName
                And SP.major_id = @MajorID)
      Begin
        If @Debug = 0
          Begin
            Begin Try
                Exec sp_executesql @SQL;
            End Try
            Begin Catch
                Set @ErrNumber = ERROR_NUMBER();
                Set @ErrSeverity = ERROR_SEVERITY();
                Set @ErrState = ERROR_STATE();
                Set @ErrProcedure = ERROR_PROCEDURE();
                Set @ErrLine = ERROR_LINE();
                Set @ErrMsg = ERROR_MESSAGE();
                RaisError(@ErrMsg, 1, 1);
            End Catch
          End
        Else
          Begin
            Print @SQL;
          End
      End

    Set @CurrID = @CurrID + 1;
  End


Set NoCount Off;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>LOOPS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Dynamic_IF_THEN</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>LOOPS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Dynamic_IF_THEN</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--http://www.sqlteam.com/article/using-bulk-insert-to-load-a-text-file

-- Not sure if this will work outside a stored proc
--  Dynamic SQL statement execution


--Step 1: Build Valid BULK INSERT Statement
DECLARE @SQL varchar(2000)
IF @FileType = 1
 BEGIN
  -- Valid format: "John","Smith","john@smith.com"
  SET @SQL = "BULK INSERT TmpStList FROM '"+@PathFileName+"' WITH (FIELDTERMINATOR = '"",""') "
 END
ELSE
 BEGIN
  -- Valid format: John,Smith,john@smith.com
  SET @SQL = "BULK INSERT TmpStList FROM '"+@PathFileName+"' WITH (FIELDTERMINATOR = ',') "
 END

--Step 2: Execute BULK INSERT statement
EXEC (@SQL)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MaintenancePlan</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>From_eBook_by_RodneyLandrum</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MaintenancePlan</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>From_eBook_by_RodneyLandrum</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--NOTE: has a few errors in the script

--The script implments the following:

 
--• SQL Server Memory
--• If  64-bit, do not enable AWE 
--• If  32-bit SQL 2008 Standard on Windows 2003 Enterprise and
--RAM is more than 4G 
--• Set max server memory = 2G less than Total Server Memory
--• If  32-bit SQL 2008 Standard on Windows 2003 Standard and 
--RAM is less than 4G
--• Set max server memory = 2G 
--• E-Mail
--• If  &gt; 2005 automate setup with DBMail SPs 
--• Send Test Mail
--• If  &lt; 2005 Document necessity to create MAPI profile 
--• Print steps to configure e-mail 
--20
 
--1 – Eating SQL Server installations for breakfast 
--• DDL Triggers
--• Add Server Trigger to notify upon database create or drop 
--• Security
--• Set to Log Successful and Failed logins 
--• DB Maintenance Database
--• Create the _DBAMain database 
--• Create the stored procedures in the _DBAMain database
--• Create and Schedule Maintenance Jobs via stored procedures 
--• Other Modifications
--• Change Model Database Options





/* SQL Server Automated Configuration Script
   2009 - Rodney Landrum
*/

--Create Temp table #SerProp. This table will be used
--to hold the output of xp_msver to control server property configurations

SET NOCOUNT ON
GO

IF EXISTS ( SELECT  name
            FROM    tempdb..sysobjects
            Where   name like '#SerProp%' )
--If So Drop it
    DROP TABLE #SerProp
create table #SerProp
    (
      ID int,
      Name sysname,
      Internal_Value int,
      Value nvarchar(512)
    )
    
  GO
  

--Set Show Advanced Option
sp_configure 'Show Advanced Options', 1
Reconfigure
GO

DECLARE @PhysMem int
DECLARE @ProcType int
DECLARE @MaxMem int

  
INSERT  INTO #SerProp
        Exec xp_msver
  
Select  @PhysMem = Internal_Value
from    #SerProp
where   Name = 'PhysicalMemory'

Select  @ProcType = Internal_Value
from    #SerProp
where   Name = 'ProcessorType'

--Set Memory Configuration from server properties 
--(memory level and processortype)

If @PhysMem &gt; 4096 AND @ProcType = 8664
BEGIN
   SET @MaxMem = @PhysMem - 3072
   EXEC sp_configure 'max server memory', @MaxMem
   Reconfigure
END   

ELSE
IF @PhysMem &gt; 4096 AND @ProcType &lt;&gt; 8664
BEGIN
   SET @MaxMem = @PhysMem - 3072
   EXEC sp_configure 'awe enabled', 1
   Reconfigure
   EXEC sp_configure 'max server memory', @MaxMem
   Reconfigure
END   

--Setup Database Mail (SQL Server &gt; 2005 )
--Turn on Mail XPs via sp_configure
--sp_configure (To turn on Mail XPs)

-- Add Profile

If @@microsoftversion / power(2, 24) &gt; 8
BEGIN

EXECUTE msdb.dbo.sysmail_add_profile_sp
       @profile_name = 'Admin Profile',
       @description = 'Mail Profile For Alerts' ;
       
--Add Mail Account
       
       EXECUTE msdb.dbo.sysmail_add_account_sp
    @account_name = 'Admin Account',
    @description = 'General SQL Admin Account for DBA Notification',
    @email_address = '&lt;Your DBA e-mail account&gt;',
    @display_name = 'SQL Admin Account',
    @mailserver_name = '&lt;Yourmailservername&gt;';

--Add Mail Account to Profile

EXECUTE msdb.dbo.sysmail_add_profileaccount_sp
    @profile_name = 'Admin Profile',
    @account_name = 'Admin Account',
    @sequence_number = 1 ;
    
--Send Test Mail
       
EXEC msdb.dbo.sp_send_dbmail
    @profile_name = 'Admin Profile',
    @recipients = '&lt;Your DBA e-mail Account&gt;',
    @body = 'Server Mail Configuration Completed',
    @subject = 'Successful Mail Test';
 
 END
 ELSE


--Print Instructions for SQl Server 2000

 BEGIN
 PRINT 'For SQL Server 2000, you will need to
        configure a MAPI client'
 PRINT 'such as Outlook and create a profile to use
        for SQL Mail and SQL Agent'
 PRINT 'mail. Instructions can be found
        at:______________________________'
 END

--Setup Security Logging
--Enable Successful and Unsuccessful Login Attempts
--SQL Server Services must be restarted to take affect

exec master.dbo.xp_instance_regwrite N'HKEY_LOCAL_MACHINE', N'Software\Microsoft\MSSQLServer\MSSQLServer',
N'AuditLevel', REG_DWORD,3

--Create Maintenance Database "_DBAMain"

USE [master]
GO

/****** Object:  Database [_DBAMain]    
                  Script Date: 02/05/2009 20:41:24 ******/
IF  EXISTS (SELECT name FROM sys.databases 
              WHERE name = N'_DBAMain')
DROP DATABASE [_DBAMain]
GO

/****** Object:  Database [_DBAMain]
                  Script Date: 02/05/2009 20:41:24 ******/
CREATE DATABASE [_DBAMain] ON  PRIMARY 
( NAME = N'_DBAMain_Data', 
   FILENAME = N'C:\Data\_DBAMain_Data.MDF',
   SIZE = 5120KB,
   MAXSIZE = UNLIMITED,
   FILEGROWTH = 10%)
 LOG ON 
( NAME = N'_DBAMain_Log',
   FILENAME = N'C:\Logs\_DBAMain_Log.LDF' ,
   SIZE = 3072KB ,
   MAXSIZE = 2048GB ,
   FILEGROWTH = 10%)
GO

/*    
   Run Script To Create Stored Procedures
   In _DBAMain
*/

sp_configure 'xp_cmdshell', 1
Reconfigure

exec xp_cmdshell 'sqlcmd -i C:\Writing\Create_DBAMain_2.sql'

-- Schedule Indexing Stored Procedure

/*
Usage:
spxCreateIDXMaintenanceJob
     'Owner Name'
   , 'Operator'
   , 'Sunday'
   , 0
*/
Create Procedure
     [dbo].[spxCreateIDXMaintenanceJob]
   (
     @JobOwner      nvarchar(75) 
   , @ValidOperator      nvarchar(50) 
   , @DayToReindex       nvarchar(8) 
   , @NightlyStartTime   int --230000 (11pm), 0 (12am), 120000 (12pm)
   )
As
BEGIN TRANSACTION

DECLARE
     @ReturnCode   INT
   , @jobId   BINARY(16)
   , @MyServer   nvarchar(75)
   , @SQL      nvarchar(4000)
   , @CR      nvarchar(2)

SELECT
     @ReturnCode = 0
   , @CR = char(13) + char(10)

IF NOT EXISTS   (
            SELECT
                 name
            FROM
                 msdb.dbo.syscategories
            WHERE
                 name = N'Database Maintenance'
            AND
                 category_class = 1
            )
BEGIN
   EXEC @ReturnCode = msdb.dbo.sp_add_category
        @class = N'JOB'
      , @type = N'LOCAL'
      , @name = N'Database Maintenance'

   IF
        @@ERROR &lt;&gt; 0
   OR
        @ReturnCode &lt;&gt; 0
   Begin
        GOTO QuitWithRollback
   End
END

IF EXISTS   (
         SELECT
              name
         FROM
              msdb.dbo.sysjobs
         WHERE
              name = N'IDX Maintenance'
         AND
              category_id =   (
                        Select
                             category_id
                        From
                             msdb.dbo.syscategories
                        Where
                             name = 'Database Maintenance'
                        )
         )
Begin
   Exec msdb.dbo.sp_delete_job
        @job_name = 'IDX Maintenance'
End

EXEC @ReturnCode = msdb.dbo.sp_add_job
           @job_name = N'IDX Maintenance'
         , @enabled = 1
         , @notify_level_eventlog = 0
         , @notify_level_email = 0
         , @notify_level_netsend = 0
         , @notify_level_page = 0
         , @delete_level = 0
         , @description = N'Index Tuning'
         , @category_name = N'Database Maintenance'
         , @owner_login_name = @JobOwner
         , @job_id = @jobId OUTPUT

IF
     @@ERROR &lt;&gt; 0
OR
     @ReturnCode &lt;&gt; 0
Begin
     GOTO QuitWithRollback
End

Select @SQL = 'exec spxIDXMaint ' 
                 + char(39) + @DayToReindex + char(39)

EXEC @ReturnCode = msdb.dbo.sp_add_jobstep
           @job_id = @jobId
         , @step_name = N'Index Maintenance'
         , @step_id = 1
         , @cmdexec_success_code = 0
         , @on_success_action = 1
         , @on_success_step_id = 0
         , @on_fail_action = 2
         , @on_fail_step_id = 0
         , @retry_attempts = 0
         , @retry_interval = 0
         , @os_run_priority = 0
         , @subsystem = N'TSQL'
         , @command = @SQL
         , @database_name = N'_DBAMain'
         , @flags = 0

IF
     @@ERROR &lt;&gt; 0
OR
     @ReturnCode &lt;&gt; 0
Begin
     GOTO QuitWithRollback
End

EXEC @ReturnCode = msdb.dbo.sp_update_job
           @job_id = @jobId
         , @start_step_id = 1

IF
     @@ERROR &lt;&gt; 0
OR
     @ReturnCode &lt;&gt; 0
Begin
     GOTO QuitWithRollback
End

EXEC @ReturnCode = msdb.dbo.sp_update_job
     @job_id = @jobId
   , @notify_level_email = 2
   , @notify_level_netsend = 2
   , @notify_level_page = 2
   , @notify_email_operator_name = @ValidOperator

IF
     @@ERROR &lt;&gt; 0
OR
     @ReturnCode &lt;&gt; 0
Begin
     GOTO QuitWithRollback
End

EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule
     @job_id = @jobId
   , @name = N'Nightly Index Tuning Schedule'
   , @enabled = 1
   , @freq_type = 4
   , @freq_interval = 1
   , @freq_subday_type = 1
   , @freq_subday_interval = 0
   , @freq_relative_interval = 0
   , @freq_recurrence_factor = 0
   , @active_start_date = 20080101
   , @active_end_date = 99991231
   , @active_start_time = @NightlyStartTime
   , @active_end_time = 235959

IF
     @@ERROR &lt;&gt; 0
OR
     @ReturnCode &lt;&gt; 0
Begin
     GOTO QuitWithRollback
End

EXEC @ReturnCode = msdb.dbo.sp_add_jobserver
     @job_id = @jobId
   , @server_name = N'(local)'
IF
     @@ERROR &lt;&gt; 0
OR
     @ReturnCode &lt;&gt; 0
Begin
     GOTO QuitWithRollback
End

COMMIT TRANSACTION

GOTO EndSave

QuitWithRollback:
   IF @@TRANCOUNT &gt; 0
   Begin
        ROLLBACK TRANSACTION
   End

EndSave:

GO

--Create Index Maintenance Job

EXEC _dbaMain..spxCreateIDXMaintenanceJob
     'sa'
   , 'sqlsupport'
   , 'Sunday'
   , 0
   


--Setup DDL Triggers
--Setup Create Database or Drop Database DDL Trigger

/****** Object:  DdlTrigger [AuditDatabaseDDL]
                  Script Date: 02/05/2009 19:56:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TRIGGER [AuditDatabaseDDL]
ON ALL SERVER
FOR CREATE_DATABASE, DROP_DATABASE
AS

DECLARE @data XML,
      @tsqlCommand NVARCHAR(MAX),
      @eventType NVARCHAR(100),
      @serverName NVARCHAR(100),
      @loginName NVARCHAR(100),
      @username NVARCHAR(100),
      @databaseName NVARCHAR(100),
      @objectName NVARCHAR(100),
      @objectType NVARCHAR(100),
      @emailBody NVARCHAR(MAX)

SET @data = EVENTDATA()
SET @tsqlCommand = EVENTDATA().value('(/EVENT_INSTANCE/TSQLCommand/CommandText)[1]','nvarchar(max)')
SET @eventType = EVENTDATA().value('(/EVENT_INSTANCE/EventType)[1]','nvarchar(max)')
SET @serverName = EVENTDATA().value('(/EVENT_INSTANCE/ServerName)[1]','nvarchar(max)')
SET @loginName = EVENTDATA().value('(/EVENT_INSTANCE/LoginName)[1]','nvarchar(max)')
SET @userName = EVENTDATA().value('(/EVENT_INSTANCE/UserName)[1]','nvarchar(max)')
SET @databaseName = EVENTDATA().value('(/EVENT_INSTANCE/DatabaseName)[1]','nvarchar(max)')
SET @objectName = EVENTDATA().value('(/EVENT_INSTANCE/ObjectName)[1]','nvarchar(max)')
SET @objectType = EVENTDATA().value('(/EVENT_INSTANCE/ObjectType)[1]','nvarchar(max)')

SET @emailBody = + '--------------------------------' + CHAR(13)
             + '- DDL Trigger Activation Report      -' + CHAR(13)
             + '--------------------------------------' + CHAR(13)
             + 'Sql Command: '
                 + ISNULL(@tsqlCommand, 'No Command Given') + CHAR(13)
             + 'Event Type: '
                 + ISNULL(@eventType, 'No Event Type Given') + CHAR(13)
             + 'Server Name: 
               ' + ISNULL(@serverName, 'No Server Given') + CHAR(13)
             + 'Login Name: '
                 + ISNULL(@loginName, 'No LOGIN Given') + CHAR(13)
             + 'User Name: '
                 + ISNULL(@username, 'No User Name Given') + CHAR(13)
             + 'DB Name: '
                 + ISNULL(@databaseName, 'No Database Given') + CHAR(13)
             + 'Object Name: '
                 + ISNULL(@objectName, 'No Object Given') + CHAR(13)
             + 'Object Type: '
                 + ISNULL(@objectType, 'No Type Given') + CHAR(13)
             + '-------------------------------------------';

EXEC msdb..sp_send_dbmail @profile_name='Admin Profile', @recipients='yourmail@yourmail.com', @subject='DDL Alteration Trigger', @body=@emailBody

GO

SET ANSI_NULLS OFF
GO

SET QUOTED_IDENTIFIER OFF
GO

ENABLE TRIGGER [AuditDatabaseDDL] ON ALL SERVER
GO

   
-- Change Model Database Recovery Option from Full to Simple
-- This will prevent unmitigated log file growth.


ALTER Database Model
SET RECOVERY SIMPLE

-- Turn configurations back off

sp_configure 'xp_cmdshell', 0
reconfigure

sp_configure 'Show Advanced Options', 0
Reconfigure

-- End Script
PRINT 'All Done...Add Server to DBA Repository for further documentation'
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MaintenancePlan</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ola_hallengren_MaintenanceSolution.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MaintenancePlan</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ola_hallengren_MaintenanceSolution.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>/*
--http://ola.hallengren.com/sql-server-index-and-statistics-maintenance.html
SQL Server Maintenance Solution - SQL Server 2005, SQL Server 2008, SQL Server 2008 R2, and SQL Server 2012

Backup: http://ola.hallengren.com/sql-server-backup.html
Integrity Check: http://ola.hallengren.com/sql-server-integrity-check.html
Index and Statistics Maintenance: http://ola.hallengren.com/sql-server-index-and-statistics-maintenance.html

The solution is free: http://ola.hallengren.com/license.html

You can contact me by e-mail at ola@hallengren.com.

Last updated 23 February, 2014.

Ola Hallengren
http://ola.hallengren.com

*/

USE [master] -- Specify the database in which the objects will be created.

SET NOCOUNT ON

DECLARE @CreateJobs nvarchar(max)
DECLARE @BackupDirectory nvarchar(max)
DECLARE @OutputFileDirectory nvarchar(max)
DECLARE @LogToTable nvarchar(max)
DECLARE @Version numeric(18,10)
DECLARE @Error int

SET @CreateJobs          = 'Y'          -- Specify whether jobs should be created.
SET @BackupDirectory     = N'C:\Backup' -- Specify the backup root directory.
SET @OutputFileDirectory = NULL         -- Specify the output file directory. If no directory is specified, then the SQL Server error log directory is used.
SET @LogToTable          = 'Y'          -- Log commands to a table.

SET @Error = 0

SET @Version = CAST(LEFT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)),CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - 1) + '.' + REPLACE(RIGHT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)), LEN(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)))),'.','') AS numeric(18,10))

IF IS_SRVROLEMEMBER('sysadmin') = 0
BEGIN
  RAISERROR('You need to be a member of the SysAdmin server role to install the solution.',16,1)
  SET @Error = @@ERROR
END

IF OBJECT_ID('tempdb..#Config') IS NOT NULL DROP TABLE #Config

CREATE TABLE #Config ([Name] nvarchar(max),
                      [Value] nvarchar(max))

IF @CreateJobs = 'Y' AND @OutputFileDirectory IS NULL AND SERVERPROPERTY('EngineEdition') &lt;&gt; 4
BEGIN
  IF @Version &gt;= 11
  BEGIN
    SELECT @OutputFileDirectory = [path]
    FROM sys.dm_os_server_diagnostics_log_configurations
  END
  ELSE
  BEGIN
    SELECT @OutputFileDirectory = LEFT(CAST(SERVERPROPERTY('ErrorLogFileName') AS nvarchar(max)),LEN(CAST(SERVERPROPERTY('ErrorLogFileName') AS nvarchar(max))) - CHARINDEX('\',REVERSE(CAST(SERVERPROPERTY('ErrorLogFileName') AS nvarchar(max)))))
  END
END

IF @CreateJobs = 'Y' AND RIGHT(@OutputFileDirectory,1) = '\' AND SERVERPROPERTY('EngineEdition') &lt;&gt; 4
BEGIN
  SET @OutputFileDirectory = LEFT(@OutputFileDirectory, LEN(@OutputFileDirectory) - 1)
END

INSERT INTO #Config ([Name], [Value])
VALUES('CreateJobs', @CreateJobs)

INSERT INTO #Config ([Name], [Value])
VALUES('BackupDirectory', @BackupDirectory)

INSERT INTO #Config ([Name], [Value])
VALUES('OutputFileDirectory', @OutputFileDirectory)

INSERT INTO #Config ([Name], [Value])
VALUES('LogToTable', @LogToTable)

INSERT INTO #Config ([Name], [Value])
VALUES('DatabaseName', DB_NAME(DB_ID()))

INSERT INTO #Config ([Name], [Value])
VALUES('Error', CAST(@Error AS nvarchar))

IF OBJECT_ID('[dbo].[DatabaseBackup]') IS NOT NULL DROP PROCEDURE [dbo].[DatabaseBackup]
IF OBJECT_ID('[dbo].[DatabaseIntegrityCheck]') IS NOT NULL DROP PROCEDURE [dbo].[DatabaseIntegrityCheck]
IF OBJECT_ID('[dbo].[IndexOptimize]') IS NOT NULL DROP PROCEDURE [dbo].[IndexOptimize]
IF OBJECT_ID('[dbo].[CommandExecute]') IS NOT NULL DROP PROCEDURE [dbo].[CommandExecute]

IF OBJECT_ID('[dbo].[CommandLog]') IS NULL AND OBJECT_ID('[dbo].[PK_CommandLog]') IS NULL
BEGIN
CREATE TABLE [dbo].[CommandLog](
[ID] int IDENTITY(1,1) NOT NULL CONSTRAINT [PK_CommandLog] PRIMARY KEY CLUSTERED,
[DatabaseName] sysname NULL,
[SchemaName] sysname NULL,
[ObjectName] sysname NULL,
[ObjectType] char(2) NULL,
[IndexName] sysname NULL,
[IndexType] tinyint NULL,
[StatisticsName] sysname NULL,
[PartitionNumber] int NULL,
[ExtendedInfo] xml NULL,
[Command] nvarchar(max) NOT NULL,
[CommandType] nvarchar(60) NOT NULL,
[StartTime] datetime NOT NULL,
[EndTime] datetime NULL,
[ErrorNumber] int NULL,
[ErrorMessage] nvarchar(max) NULL
)
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[CommandExecute]

@Command nvarchar(max),
@CommandType nvarchar(max),
@Mode int,
@Comment nvarchar(max) = NULL,
@DatabaseName nvarchar(max) = NULL,
@SchemaName nvarchar(max) = NULL,
@ObjectName nvarchar(max) = NULL,
@ObjectType nvarchar(max) = NULL,
@IndexName nvarchar(max) = NULL,
@IndexType int = NULL,
@StatisticsName nvarchar(max) = NULL,
@PartitionNumber int = NULL,
@ExtendedInfo xml = NULL,
@LogToTable nvarchar(max),
@Execute nvarchar(max)

AS

BEGIN

  ----------------------------------------------------------------------------------------------------
  --// Source: http://ola.hallengren.com                                                          //--
  ----------------------------------------------------------------------------------------------------

  SET NOCOUNT ON

  DECLARE @StartMessage nvarchar(max)
  DECLARE @EndMessage nvarchar(max)
  DECLARE @ErrorMessage nvarchar(max)
  DECLARE @ErrorMessageOriginal nvarchar(max)

  DECLARE @StartTime datetime
  DECLARE @EndTime datetime

  DECLARE @StartTimeSec datetime
  DECLARE @EndTimeSec datetime

  DECLARE @ID int

  DECLARE @Error int
  DECLARE @ReturnCode int

  SET @Error = 0
  SET @ReturnCode = 0

  ----------------------------------------------------------------------------------------------------
  --// Check core requirements                                                                    //--
  ----------------------------------------------------------------------------------------------------

  IF @LogToTable = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandLog')
  BEGIN
    SET @ErrorMessage = 'The table CommandLog is missing. Download http://ola.hallengren.com/scripts/CommandLog.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Error &lt;&gt; 0
  BEGIN
    SET @ReturnCode = @Error
    GOTO ReturnCode
  END

  ----------------------------------------------------------------------------------------------------
  --// Check input parameters                                                                     //--
  ----------------------------------------------------------------------------------------------------

  IF @Command IS NULL OR @Command = ''
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Command is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @CommandType IS NULL OR @CommandType = '' OR LEN(@CommandType) &gt; 60
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @CommandType is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Mode NOT IN(1,2) OR @Mode IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Mode is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LogToTable NOT IN('Y','N') OR @LogToTable IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @LogToTable is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Execute NOT IN('Y','N') OR @Execute IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Execute is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Error &lt;&gt; 0
  BEGIN
    SET @ReturnCode = @Error
    GOTO ReturnCode
  END

  ----------------------------------------------------------------------------------------------------
  --// Log initial information                                                                    //--
  ----------------------------------------------------------------------------------------------------

  SET @StartTime = GETDATE()
  SET @StartTimeSec = CONVERT(datetime,CONVERT(nvarchar,@StartTime,120),120)

  SET @StartMessage = 'Date and time: ' + CONVERT(nvarchar,@StartTimeSec,120) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Command: ' + @Command
  IF @Comment IS NOT NULL SET @StartMessage = @StartMessage + CHAR(13) + CHAR(10) + 'Comment: ' + @Comment
  SET @StartMessage = REPLACE(@StartMessage,'%','%%')
  RAISERROR(@StartMessage,10,1) WITH NOWAIT

  IF @LogToTable = 'Y'
  BEGIN
    INSERT INTO dbo.CommandLog (DatabaseName, SchemaName, ObjectName, ObjectType, IndexName, IndexType, StatisticsName, PartitionNumber, ExtendedInfo, CommandType, Command, StartTime)
    VALUES (@DatabaseName, @SchemaName, @ObjectName, @ObjectType, @IndexName, @IndexType, @StatisticsName, @PartitionNumber, @ExtendedInfo, @CommandType, @Command, @StartTime)
  END

  SET @ID = SCOPE_IDENTITY()

  ----------------------------------------------------------------------------------------------------
  --// Execute command                                                                            //--
  ----------------------------------------------------------------------------------------------------

  IF @Mode = 1 AND @Execute = 'Y'
  BEGIN
    EXECUTE(@Command)
    SET @Error = @@ERROR
    SET @ReturnCode = @Error
  END

  IF @Mode = 2 AND @Execute = 'Y'
  BEGIN
    BEGIN TRY
      EXECUTE(@Command)
    END TRY
    BEGIN CATCH
      SET @Error = ERROR_NUMBER()
      SET @ReturnCode = @Error
      SET @ErrorMessageOriginal = ERROR_MESSAGE()
      SET @ErrorMessage = 'Msg ' + CAST(@Error AS nvarchar) + ', ' + ISNULL(@ErrorMessageOriginal,'')
      RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    END CATCH
  END

  ----------------------------------------------------------------------------------------------------
  --// Log completing information                                                                 //--
  ----------------------------------------------------------------------------------------------------

  SET @EndTime = GETDATE()
  SET @EndTimeSec = CONVERT(datetime,CONVERT(varchar,@EndTime,120),120)

  SET @EndMessage = 'Outcome: ' + CASE WHEN @Execute = 'N' THEN 'Not Executed' WHEN @Error = 0 THEN 'Succeeded' ELSE 'Failed' END + CHAR(13) + CHAR(10)
  SET @EndMessage = @EndMessage + 'Duration: ' + CASE WHEN DATEDIFF(ss,@StartTimeSec, @EndTimeSec)/(24*3600) &gt; 0 THEN CAST(DATEDIFF(ss,@StartTimeSec, @EndTimeSec)/(24*3600) AS nvarchar) + '.' ELSE '' END + CONVERT(nvarchar,@EndTimeSec - @StartTimeSec,108) + CHAR(13) + CHAR(10)
  SET @EndMessage = @EndMessage + 'Date and time: ' + CONVERT(nvarchar,@EndTimeSec,120) + CHAR(13) + CHAR(10) + ' '
  SET @EndMessage = REPLACE(@EndMessage,'%','%%')
  RAISERROR(@EndMessage,10,1) WITH NOWAIT

  IF @LogToTable = 'Y'
  BEGIN
    UPDATE dbo.CommandLog
    SET EndTime = @EndTime,
        ErrorNumber = CASE WHEN @Execute = 'N' THEN NULL ELSE @Error END,
        ErrorMessage = @ErrorMessageOriginal
    WHERE ID = @ID
  END

  ReturnCode:
  IF @ReturnCode &lt;&gt; 0
  BEGIN
    RETURN @ReturnCode
  END

  ----------------------------------------------------------------------------------------------------

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[DatabaseBackup]

@Databases nvarchar(max),
@Directory nvarchar(max) = NULL,
@BackupType nvarchar(max),
@Verify nvarchar(max) = 'N',
@CleanupTime int = NULL,
@Compress nvarchar(max) = NULL,
@CopyOnly nvarchar(max) = 'N',
@ChangeBackupType nvarchar(max) = 'N',
@BackupSoftware nvarchar(max) = NULL,
@CheckSum nvarchar(max) = 'N',
@BlockSize int = NULL,
@BufferCount int = NULL,
@MaxTransferSize int = NULL,
@NumberOfFiles int = NULL,
@CompressionLevel int = NULL,
@Description nvarchar(max) = NULL,
@Threads int = NULL,
@Throttle int = NULL,
@Encrypt nvarchar(max) = 'N',
@EncryptionAlgorithm nvarchar(max) = NULL,
@EncryptionKey nvarchar(max) = NULL,
@ReadWriteFileGroups nvarchar(max) = 'N',
@OverrideBackupPreference nvarchar(max) = 'N',
@LogToTable nvarchar(max) = 'N',
@Execute nvarchar(max) = 'Y'

AS

BEGIN

  ----------------------------------------------------------------------------------------------------
  --// Source: http://ola.hallengren.com                                                          //--
  ----------------------------------------------------------------------------------------------------

  SET NOCOUNT ON

  DECLARE @StartMessage nvarchar(max)
  DECLARE @EndMessage nvarchar(max)
  DECLARE @DatabaseMessage nvarchar(max)
  DECLARE @ErrorMessage nvarchar(max)

  DECLARE @Version numeric(18,10)
  DECLARE @AmazonRDS bit

  DECLARE @Cluster nvarchar(max)

  DECLARE @DefaultDirectory nvarchar(4000)

  DECLARE @CurrentRootDirectoryID int
  DECLARE @CurrentRootDirectoryPath nvarchar(4000)

  DECLARE @CurrentDBID int
  DECLARE @CurrentDatabaseID int
  DECLARE @CurrentDatabaseName nvarchar(max)
  DECLARE @CurrentBackupType nvarchar(max)
  DECLARE @CurrentFileExtension nvarchar(max)
  DECLARE @CurrentFileNumber int
  DECLARE @CurrentDifferentialBaseLSN numeric(25,0)
  DECLARE @CurrentDifferentialBaseIsSnapshot bit
  DECLARE @CurrentLogLSN numeric(25,0)
  DECLARE @CurrentLatestBackup datetime
  DECLARE @CurrentDatabaseNameFS nvarchar(max)
  DECLARE @CurrentDirectoryID int
  DECLARE @CurrentDirectoryPath nvarchar(max)
  DECLARE @CurrentFilePath nvarchar(max)
  DECLARE @CurrentDate datetime
  DECLARE @CurrentCleanupDate datetime
  DECLARE @CurrentIsDatabaseAccessible bit
  DECLARE @CurrentAvailabilityGroup nvarchar(max)
  DECLARE @CurrentAvailabilityGroupRole nvarchar(max)
  DECLARE @CurrentAvailabilityGroupBackupPreference nvarchar(max)
  DECLARE @CurrentIsPreferredBackupReplica bit
  DECLARE @CurrentDatabaseMirroringRole nvarchar(max)
  DECLARE @CurrentLogShippingRole nvarchar(max)

  DECLARE @CurrentCommand01 nvarchar(max)
  DECLARE @CurrentCommand02 nvarchar(max)
  DECLARE @CurrentCommand03 nvarchar(max)
  DECLARE @CurrentCommand04 nvarchar(max)

  DECLARE @CurrentCommandOutput01 int
  DECLARE @CurrentCommandOutput02 int
  DECLARE @CurrentCommandOutput03 int
  DECLARE @CurrentCommandOutput04 int

  DECLARE @CurrentCommandType01 nvarchar(max)
  DECLARE @CurrentCommandType02 nvarchar(max)
  DECLARE @CurrentCommandType03 nvarchar(max)
  DECLARE @CurrentCommandType04 nvarchar(max)

  DECLARE @Directories TABLE (ID int PRIMARY KEY,
                              DirectoryPath nvarchar(max),
                              Completed bit)

  DECLARE @DirectoryInfo TABLE (FileExists bit,
                                FileIsADirectory bit,
                                ParentDirectoryExists bit)

  DECLARE @tmpDatabases TABLE (ID int IDENTITY,
                               DatabaseName nvarchar(max),
                               DatabaseNameFS nvarchar(max),
                               DatabaseType nvarchar(max),
                               Selected bit,
                               Completed bit,
                               PRIMARY KEY(Selected, Completed, ID))

  DECLARE @SelectedDatabases TABLE (DatabaseName nvarchar(max),
                                    DatabaseType nvarchar(max),
                                    Selected bit)

  DECLARE @CurrentDirectories TABLE (ID int PRIMARY KEY,
                                     DirectoryPath nvarchar(max),
                                     CreateCompleted bit,
                                     CleanupCompleted bit,
                                     CreateOutput int,
                                     CleanupOutput int)

  DECLARE @CurrentFiles TABLE (CurrentFilePath nvarchar(max))

  DECLARE @CurrentCleanupDates TABLE (CleanupDate datetime)

  DECLARE @Error int
  DECLARE @ReturnCode int

  SET @Error = 0
  SET @ReturnCode = 0

  SET @Version = CAST(LEFT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)),CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - 1) + '.' + REPLACE(RIGHT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)), LEN(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)))),'.','') AS numeric(18,10))

  SET @AmazonRDS = CASE WHEN DB_ID('rdsadmin') IS NOT NULL AND SUSER_SNAME(0x01) = 'rdsa' THEN 1 ELSE 0 END

  ----------------------------------------------------------------------------------------------------
  --// Log initial information                                                                    //--
  ----------------------------------------------------------------------------------------------------

  SET @StartMessage = 'Date and time: ' + CONVERT(nvarchar,GETDATE(),120) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Server: ' + CAST(SERVERPROPERTY('ServerName') AS nvarchar) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Version: ' + CAST(SERVERPROPERTY('ProductVersion') AS nvarchar) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Edition: ' + CAST(SERVERPROPERTY('Edition') AS nvarchar) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Procedure: ' + QUOTENAME(DB_NAME(DB_ID())) + '.' + (SELECT QUOTENAME(schemas.name) FROM sys.schemas schemas INNER JOIN sys.objects objects ON schemas.[schema_id] = objects.[schema_id] WHERE [object_id] = @@PROCID) + '.' + QUOTENAME(OBJECT_NAME(@@PROCID)) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Parameters: @Databases = ' + ISNULL('''' + REPLACE(@Databases,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @Directory = ' + ISNULL('''' + REPLACE(@Directory,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @BackupType = ' + ISNULL('''' + REPLACE(@BackupType,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @Verify = ' + ISNULL('''' + REPLACE(@Verify,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @CleanupTime = ' + ISNULL(CAST(@CleanupTime AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @Compress = ' + ISNULL('''' + REPLACE(@Compress,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @CopyOnly = ' + ISNULL('''' + REPLACE(@CopyOnly,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @ChangeBackupType = ' + ISNULL('''' + REPLACE(@ChangeBackupType,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @BackupSoftware = ' + ISNULL('''' + REPLACE(@BackupSoftware,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @CheckSum = ' + ISNULL('''' + REPLACE(@CheckSum,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @BlockSize = ' + ISNULL(CAST(@BlockSize AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @BufferCount = ' + ISNULL(CAST(@BufferCount AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @MaxTransferSize = ' + ISNULL(CAST(@MaxTransferSize AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @NumberOfFiles = ' + ISNULL(CAST(@NumberOfFiles AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @CompressionLevel = ' + ISNULL(CAST(@CompressionLevel AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @Description = ' + ISNULL('''' + REPLACE(@Description,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @Threads = ' + ISNULL(CAST(@Threads AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @Throttle = ' + ISNULL(CAST(@Throttle AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @Encrypt = ' + ISNULL('''' + REPLACE(@Encrypt,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @EncryptionAlgorithm = ' + ISNULL('''' + REPLACE(@EncryptionAlgorithm,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @EncryptionKey = ' + ISNULL('''' + REPLACE(@EncryptionKey,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @ReadWriteFileGroups = ' + ISNULL('''' + REPLACE(@ReadWriteFileGroups,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @OverrideBackupPreference = ' + ISNULL('''' + REPLACE(@OverrideBackupPreference,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @LogToTable = ' + ISNULL('''' + REPLACE(@LogToTable,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @Execute = ' + ISNULL('''' + REPLACE(@Execute,'''','''''') + '''','NULL') + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Source: http://ola.hallengren.com' + CHAR(13) + CHAR(10)
  SET @StartMessage = REPLACE(@StartMessage,'%','%%') + ' '
  RAISERROR(@StartMessage,10,1) WITH NOWAIT

  ----------------------------------------------------------------------------------------------------
  --// Check core requirements                                                                    //--
  ----------------------------------------------------------------------------------------------------

  IF NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute')
  BEGIN
    SET @ErrorMessage = 'The stored procedure CommandExecute is missing. Download http://ola.hallengren.com/scripts/CommandExecute.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute' AND (OBJECT_DEFINITION(objects.[object_id]) NOT LIKE '%@LogToTable%' OR OBJECT_DEFINITION(objects.[object_id]) LIKE '%LOCK_TIMEOUT%'))
  BEGIN
    SET @ErrorMessage = 'The stored procedure CommandExecute needs to be updated. Download http://ola.hallengren.com/scripts/CommandExecute.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LogToTable = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandLog')
  BEGIN
    SET @ErrorMessage = 'The table CommandLog is missing. Download http://ola.hallengren.com/scripts/CommandLog.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @AmazonRDS = 1
  BEGIN
    SET @ErrorMessage = 'The stored procedure DatabaseBackup is not supported on Amazon RDS.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Error &lt;&gt; 0
  BEGIN
    SET @ReturnCode = @Error
    GOTO Logging
  END

  ----------------------------------------------------------------------------------------------------
  --// Select databases                                                                           //--
  ----------------------------------------------------------------------------------------------------

  SET @Databases = REPLACE(@Databases, ', ', ',');

  WITH Databases1 (StartPosition, EndPosition, DatabaseItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Databases, 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, 1, ISNULL(NULLIF(CHARINDEX(',', @Databases, 1), 0), LEN(@Databases) + 1) - 1) AS DatabaseItem
  WHERE @Databases IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) - EndPosition - 1) AS DatabaseItem
  FROM Databases1
  WHERE EndPosition &lt; LEN(@Databases) + 1
  ),
  Databases2 (DatabaseItem, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem LIKE '-%' THEN RIGHT(DatabaseItem,LEN(DatabaseItem) - 1) ELSE DatabaseItem END AS DatabaseItem,
         CASE WHEN DatabaseItem LIKE '-%' THEN 0 ELSE 1 END AS Selected
  FROM Databases1
  ),
  Databases3 (DatabaseItem, DatabaseType, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem IN('ALL_DATABASES','SYSTEM_DATABASES','USER_DATABASES') THEN '%' ELSE DatabaseItem END AS DatabaseItem,
         CASE WHEN DatabaseItem = 'SYSTEM_DATABASES' THEN 'S' WHEN DatabaseItem = 'USER_DATABASES' THEN 'U' ELSE NULL END AS DatabaseType,
         Selected
  FROM Databases2
  ),
  Databases4 (DatabaseName, DatabaseType, Selected) AS
  (
  SELECT CASE WHEN LEFT(DatabaseItem,1) = '[' AND RIGHT(DatabaseItem,1) = ']' THEN PARSENAME(DatabaseItem,1) ELSE DatabaseItem END AS DatabaseItem,
         DatabaseType,
         Selected
  FROM Databases3
  )
  INSERT INTO @SelectedDatabases (DatabaseName, DatabaseType, Selected)
  SELECT DatabaseName,
         DatabaseType,
         Selected
  FROM Databases4
  OPTION (MAXRECURSION 0)

  INSERT INTO @tmpDatabases (DatabaseName, DatabaseNameFS, DatabaseType, Selected, Completed)
  SELECT [name] AS DatabaseName,
         REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE([name],'\',''),'/',''),':',''),'*',''),'?',''),'"',''),'&lt;',''),'&gt;',''),'|',''),' ','') AS DatabaseNameFS,
         CASE WHEN name IN('master','msdb','model') THEN 'S' ELSE 'U' END AS DatabaseType,
         0 AS Selected,
         0 AS Completed
  FROM sys.databases
  WHERE [name] &lt;&gt; 'tempdb'
  AND source_database_id IS NULL
  ORDER BY [name] ASC

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  WHERE SelectedDatabases.Selected = 1

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  WHERE SelectedDatabases.Selected = 0

  IF @Databases IS NULL OR NOT EXISTS(SELECT * FROM @SelectedDatabases) OR EXISTS(SELECT * FROM @SelectedDatabases WHERE DatabaseName IS NULL OR DatabaseName = '')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Databases is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  ----------------------------------------------------------------------------------------------------
  --// Check database names                                                                       //--
  ----------------------------------------------------------------------------------------------------

  SET @ErrorMessage = ''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '
  FROM @tmpDatabases
  WHERE Selected = 1
  AND DatabaseNameFS = ''
  ORDER BY DatabaseName ASC
  IF @@ROWCOUNT &gt; 0
  BEGIN
    SET @ErrorMessage = 'The names of the following databases are not supported: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  SET @ErrorMessage = ''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '
  FROM @tmpDatabases
  WHERE UPPER(DatabaseNameFS) IN(SELECT UPPER(DatabaseNameFS) FROM @tmpDatabases GROUP BY UPPER(DatabaseNameFS) HAVING COUNT(*) &gt; 1)
  AND UPPER(DatabaseNameFS) IN(SELECT UPPER(DatabaseNameFS) FROM @tmpDatabases WHERE Selected = 1)
  AND DatabaseNameFS &lt;&gt; ''
  ORDER BY DatabaseName ASC
  OPTION (RECOMPILE)
  IF @@ROWCOUNT &gt; 0
  BEGIN
    SET @ErrorMessage = 'The names of the following databases are not unique in the file system: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  ----------------------------------------------------------------------------------------------------
  --// Select directories                                                                         //--
  ----------------------------------------------------------------------------------------------------

  IF @Directory IS NULL
  BEGIN
    EXECUTE [master].dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\MSSQLServer', N'BackupDirectory', @DefaultDirectory OUTPUT

    INSERT INTO @Directories (ID, DirectoryPath, Completed)
    SELECT 1, @DefaultDirectory, 0
  END
  ELSE
  BEGIN
    SET @Directory = REPLACE(@Directory, ', ', ',');

    WITH Directories (StartPosition, EndPosition, Directory) AS
    (
    SELECT 1 AS StartPosition,
           ISNULL(NULLIF(CHARINDEX(',', @Directory, 1), 0), LEN(@Directory) + 1) AS EndPosition,
           SUBSTRING(@Directory, 1, ISNULL(NULLIF(CHARINDEX(',', @Directory, 1), 0), LEN(@Directory) + 1) - 1) AS Directory
    WHERE @Directory IS NOT NULL
    UNION ALL
    SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
           ISNULL(NULLIF(CHARINDEX(',', @Directory, EndPosition + 1), 0), LEN(@Directory) + 1) AS EndPosition,
           SUBSTRING(@Directory, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @Directory, EndPosition + 1), 0), LEN(@Directory) + 1) - EndPosition - 1) AS Directory
    FROM Directories
    WHERE EndPosition &lt; LEN(@Directory) + 1
    )
    INSERT INTO @Directories (ID, DirectoryPath, Completed)
    SELECT ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS ID,
           Directory,
           0
    FROM Directories
    OPTION (MAXRECURSION 0)
  END

  ----------------------------------------------------------------------------------------------------
  --// Check directories                                                                          //--
  ----------------------------------------------------------------------------------------------------

  IF EXISTS(SELECT * FROM @Directories WHERE NOT (DirectoryPath LIKE '_:' OR DirectoryPath LIKE '_:\%' OR DirectoryPath LIKE '\\%\%') OR DirectoryPath IS NULL OR LEFT(DirectoryPath,1) = ' ' OR RIGHT(DirectoryPath,1) = ' ') OR EXISTS (SELECT * FROM @Directories GROUP BY DirectoryPath HAVING COUNT(*) &lt;&gt; 1)
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Directory is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END
  ELSE
  BEGIN
    WHILE EXISTS(SELECT * FROM @Directories WHERE Completed = 0)
    BEGIN
      SELECT TOP 1 @CurrentRootDirectoryID = ID,
                   @CurrentRootDirectoryPath = DirectoryPath
      FROM @Directories
      WHERE Completed = 0
      ORDER BY ID ASC

      INSERT INTO @DirectoryInfo (FileExists, FileIsADirectory, ParentDirectoryExists)
      EXECUTE [master].dbo.xp_fileexist @CurrentRootDirectoryPath

      IF NOT EXISTS (SELECT * FROM @DirectoryInfo WHERE FileExists = 0 AND FileIsADirectory = 1 AND ParentDirectoryExists = 1)
      BEGIN
        SET @ErrorMessage = 'The directory ' + @CurrentRootDirectoryPath + ' does not exist.' + CHAR(13) + CHAR(10) + ' '
        RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
        SET @Error = @@ERROR
      END

      UPDATE @Directories
      SET Completed = 1
      WHERE ID = @CurrentRootDirectoryID

      SET @CurrentRootDirectoryID = NULL
      SET @CurrentRootDirectoryPath = NULL

      DELETE FROM @DirectoryInfo
    END
  END

  ----------------------------------------------------------------------------------------------------
  --// Get default compression                                                                    //--
  ----------------------------------------------------------------------------------------------------

  IF @Compress IS NULL
  BEGIN
    SELECT @Compress = CASE
    WHEN @BackupSoftware IS NULL AND EXISTS(SELECT * FROM sys.configurations WHERE name = 'backup compression default' AND value_in_use = 1) THEN 'Y'
    WHEN @BackupSoftware IS NULL AND NOT EXISTS(SELECT * FROM sys.configurations WHERE name = 'backup compression default' AND value_in_use = 1) THEN 'N'
    WHEN @BackupSoftware IS NOT NULL AND (@CompressionLevel IS NULL OR @CompressionLevel &gt; 0)  THEN 'Y'
    WHEN @BackupSoftware IS NOT NULL AND @CompressionLevel = 0  THEN 'N'
    END
  END

  ----------------------------------------------------------------------------------------------------
  --// Get number of files                                                                        //--
  ----------------------------------------------------------------------------------------------------

  IF @NumberOfFiles IS NULL
  BEGIN
    SELECT @NumberOfFiles = (SELECT COUNT(*) FROM @Directories)
  END

  ----------------------------------------------------------------------------------------------------
  --// Check input parameters                                                                     //--
  ----------------------------------------------------------------------------------------------------

  IF @BackupType NOT IN ('FULL','DIFF','LOG') OR @BackupType IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @BackupType is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Verify NOT IN ('Y','N') OR @Verify IS NULL OR (@BackupSoftware = 'SQLSAFE' AND @Encrypt = 'Y' AND @Verify = 'Y')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Verify is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @CleanupTime &lt; 0
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @CleanupTime is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Compress NOT IN ('Y','N') OR @Compress IS NULL OR (@Compress = 'Y' AND @BackupSoftware IS NULL AND NOT ((@Version &gt;= 10 AND @Version &lt; 10.5 AND SERVERPROPERTY('EngineEdition') = 3) OR (@Version &gt;= 10.5 AND (SERVERPROPERTY('EngineEdition') = 3 OR SERVERPROPERTY('EditionID') IN (-1534726760, 284895786))))) OR (@Compress = 'N' AND @BackupSoftware IS NOT NULL AND (@CompressionLevel IS NULL OR @CompressionLevel &gt;= 1)) OR (@Compress = 'Y' AND @BackupSoftware IS NOT NULL AND @CompressionLevel = 0)
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Compress is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @CopyOnly NOT IN ('Y','N') OR @CopyOnly IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @CopyOnly is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @ChangeBackupType NOT IN ('Y','N') OR @ChangeBackupType IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @ChangeBackupType is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @BackupSoftware NOT IN ('LITESPEED','SQLBACKUP','SQLSAFE')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @BackupSoftware is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @BackupSoftware = 'LITESPEED' AND NOT EXISTS (SELECT * FROM [master].sys.objects WHERE [type] = 'X' AND [name] = 'xp_backup_database')
  BEGIN
    SET @ErrorMessage = 'NetVault LiteSpeed for SQL Server is not installed. Download http://www.quest.com/litespeed-for-sql-server/.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @BackupSoftware = 'SQLBACKUP' AND NOT EXISTS (SELECT * FROM [master].sys.objects WHERE [type] = 'X' AND [name] = 'sqlbackup')
  BEGIN
    SET @ErrorMessage = 'Red Gate SQL Backup is not installed. Download http://www.red-gate.com/products/dba/sql-backup/.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @BackupSoftware = 'SQLSAFE' AND NOT EXISTS (SELECT * FROM [master].sys.objects WHERE [type] = 'X' AND [name] = 'xp_ss_backup')
  BEGIN
    SET @ErrorMessage = 'Idera SQL safe backup is not installed. Download http://www.idera.com/Products/SQL-Server/SQL-safe-backup/.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @CheckSum NOT IN ('Y','N') OR @CheckSum IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @CheckSum is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @BlockSize NOT IN (512,1024,2048,4096,8192,16384,32768,65536) OR (@BlockSize IS NOT NULL AND @BackupSoftware = 'SQLBACKUP') OR (@BlockSize IS NOT NULL AND @BackupSoftware = 'SQLSAFE')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @BlockSize is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @BufferCount &lt;= 0 OR @BufferCount &gt; 2147483647 OR (@BufferCount IS NOT NULL AND @BackupSoftware = 'SQLBACKUP') OR (@BufferCount IS NOT NULL AND @BackupSoftware = 'SQLSAFE')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @BufferCount is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @MaxTransferSize &lt; 65536 OR @MaxTransferSize &gt; 4194304 OR @MaxTransferSize % 65536 &gt; 0 OR (@MaxTransferSize &gt; 1048576 AND @BackupSoftware = 'SQLBACKUP') OR (@MaxTransferSize IS NOT NULL AND @BackupSoftware = 'SQLSAFE')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @MaxTransferSize is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @NumberOfFiles &lt; 1 OR @NumberOfFiles &gt; 64 OR (@NumberOfFiles &gt; 32 AND @BackupSoftware = 'SQLBACKUP') OR @NumberOfFiles IS NULL OR @NumberOfFiles &lt; (SELECT COUNT(*) FROM @Directories) OR @NumberOfFiles % (SELECT COUNT(*) FROM @Directories) &gt; 0
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @NumberOfFiles is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF (@BackupSoftware IS NULL AND @CompressionLevel IS NOT NULL) OR (@BackupSoftware = 'LITESPEED' AND (@CompressionLevel &lt; 0 OR @CompressionLevel &gt; 8)) OR (@BackupSoftware = 'SQLBACKUP' AND (@CompressionLevel &lt; 0 OR @CompressionLevel &gt; 4)) OR (@BackupSoftware = 'SQLSAFE' AND (@CompressionLevel &lt; 1 OR @CompressionLevel &gt; 4))
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @CompressionLevel is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF LEN(@Description) &gt; 255 OR (@BackupSoftware = 'LITESPEED' AND LEN(@Description) &gt; 128)
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Description is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Threads IS NOT NULL AND (@BackupSoftware NOT IN('LITESPEED','SQLBACKUP','SQLSAFE') OR @BackupSoftware IS NULL) OR @Threads &lt; 2 OR @Threads &gt; 32
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Threads is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Throttle IS NOT NULL AND (@BackupSoftware NOT IN('LITESPEED') OR @BackupSoftware IS NULL) OR @Throttle &lt; 1 OR @Throttle &gt; 100
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Throttle is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Encrypt NOT IN('Y','N') OR @Encrypt IS NULL OR (@Encrypt = 'Y' AND @BackupSoftware IS NULL)
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Encrypt is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF (@EncryptionAlgorithm IS NOT NULL AND @BackupSoftware IS NULL) OR (@EncryptionAlgorithm IS NOT NULL AND @Encrypt = 'N') OR ((@EncryptionAlgorithm NOT IN('RC2_40','RC2_56','RC2_112','RC2_128','3DES_168','RC4_128','AES_128','AES_192','AES_256') OR @EncryptionAlgorithm IS NULL) AND @Encrypt = 'Y' AND @BackupSoftware = 'LITESPEED') OR ((@EncryptionAlgorithm NOT IN('AES_128','AES_256') OR @EncryptionAlgorithm IS NULL) AND @Encrypt = 'Y' AND @BackupSoftware = 'SQLBACKUP') OR ((@EncryptionAlgorithm NOT IN('AES_128','AES_256') OR @EncryptionAlgorithm IS NULL) AND @Encrypt = 'Y' AND @BackupSoftware = 'SQLSAFE')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @EncryptionAlgorithm is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF (@EncryptionKey IS NOT NULL AND @BackupSoftware IS NULL) OR (@EncryptionKey IS NOT NULL AND @Encrypt = 'N') OR (@EncryptionKey IS NULL AND @Encrypt = 'Y' AND @BackupSoftware IN('LITESPEED','SQLBACKUP','SQLSAFE'))
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @EncryptionKey is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @ReadWriteFileGroups NOT IN('Y','N') OR @ReadWriteFileGroups IS NULL OR (@ReadWriteFileGroups = 'Y' AND @BackupType = 'LOG')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @ReadWriteFileGroups is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @OverrideBackupPreference NOT IN('Y','N') OR @OverrideBackupPreference IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @OverrideBackupPreference is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LogToTable NOT IN('Y','N') OR @LogToTable IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @LogToTable is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Execute NOT IN('Y','N') OR @Execute IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Execute is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Error &lt;&gt; 0
  BEGIN
    SET @ErrorMessage = 'The documentation is available at http://ola.hallengren.com/sql-server-backup.html.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @ReturnCode = @Error
    GOTO Logging
  END

  ----------------------------------------------------------------------------------------------------
  --// Check Availability Group cluster name                                                      //--
  ----------------------------------------------------------------------------------------------------

  IF @Version &gt;= 11
  BEGIN
    SELECT @Cluster = cluster_name
    FROM sys.dm_hadr_cluster
  END

  ----------------------------------------------------------------------------------------------------
  --// Execute backup commands                                                                    //--
  ----------------------------------------------------------------------------------------------------

  WHILE EXISTS (SELECT * FROM @tmpDatabases WHERE Selected = 1 AND Completed = 0)
  BEGIN

    SELECT TOP 1 @CurrentDBID = ID,
                 @CurrentDatabaseName = DatabaseName,
                 @CurrentDatabaseNameFS = DatabaseNameFS
    FROM @tmpDatabases
    WHERE Selected = 1
    AND Completed = 0
    ORDER BY ID ASC

    SET @CurrentDatabaseID = DB_ID(@CurrentDatabaseName)

    IF DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') = 'ONLINE'
    BEGIN
      IF EXISTS (SELECT * FROM sys.database_recovery_status WHERE database_id = @CurrentDatabaseID AND database_guid IS NOT NULL)
      BEGIN
        SET @CurrentIsDatabaseAccessible = 1
      END
      ELSE
      BEGIN
        SET @CurrentIsDatabaseAccessible = 0
      END
    END
    ELSE
    BEGIN
      SET @CurrentIsDatabaseAccessible = 0
    END

    SELECT @CurrentDifferentialBaseLSN = differential_base_lsn
    FROM sys.master_files
    WHERE database_id = @CurrentDatabaseID
    AND [type] = 0
    AND [file_id] = 1

    -- Workaround for a bug in SQL Server 2005
    IF @Version &gt;= 9 AND @Version &lt; 10
    AND EXISTS(SELECT * FROM sys.master_files WHERE database_id = @CurrentDatabaseID AND [type] = 0 AND [file_id] = 1 AND differential_base_lsn IS NOT NULL AND differential_base_guid IS NOT NULL AND differential_base_time IS NULL)
    BEGIN
      SET @CurrentDifferentialBaseLSN = NULL
    END

    SELECT @CurrentDifferentialBaseIsSnapshot = is_snapshot
    FROM msdb.dbo.backupset
    WHERE database_name = @CurrentDatabaseName
    AND [type] = 'D'
    AND checkpoint_lsn = @CurrentDifferentialBaseLSN

    IF DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') = 'ONLINE'
    BEGIN
      SELECT @CurrentLogLSN = last_log_backup_lsn
      FROM sys.database_recovery_status
      WHERE database_id = @CurrentDatabaseID
    END

    SET @CurrentBackupType = @BackupType

    IF @ChangeBackupType = 'Y'
    BEGIN
      IF @CurrentBackupType = 'LOG' AND DATABASEPROPERTYEX(@CurrentDatabaseName,'Recovery') &lt;&gt; 'SIMPLE' AND @CurrentLogLSN IS NULL AND @CurrentDatabaseName &lt;&gt; 'master'
      BEGIN
        SET @CurrentBackupType = 'DIFF'
      END
      IF @CurrentBackupType = 'DIFF' AND @CurrentDifferentialBaseLSN IS NULL AND @CurrentDatabaseName &lt;&gt; 'master'
      BEGIN
        SET @CurrentBackupType = 'FULL'
      END
    END

    IF @CurrentBackupType = 'LOG'
    BEGIN
      SELECT @CurrentLatestBackup = MAX(backup_finish_date)
      FROM msdb.dbo.backupset
      WHERE [type] IN('D','I')
      AND is_damaged = 0
      AND database_name = @CurrentDatabaseName
    END

    IF @CurrentBackupType = 'LOG' AND @CurrentLatestBackup IS NULL
    BEGIN
      SELECT @CurrentLatestBackup = MAX(backup_finish_date)
      FROM msdb.dbo.backupset
      WHERE database_backup_lsn &lt; @CurrentDifferentialBaseLSN
      AND is_damaged = 0
      AND database_name = @CurrentDatabaseName
    END

    IF @Version &gt;= 11 AND @Cluster IS NOT NULL
    BEGIN
      SELECT @CurrentAvailabilityGroup = availability_groups.name,
             @CurrentAvailabilityGroupRole = dm_hadr_availability_replica_states.role_desc,
             @CurrentAvailabilityGroupBackupPreference = UPPER(availability_groups.automated_backup_preference_desc)
      FROM sys.databases databases
      INNER JOIN sys.availability_databases_cluster availability_databases_cluster ON databases.group_database_id = availability_databases_cluster.group_database_id
      INNER JOIN sys.availability_groups availability_groups ON availability_databases_cluster.group_id = availability_groups.group_id
      INNER JOIN sys.dm_hadr_availability_replica_states dm_hadr_availability_replica_states ON availability_groups.group_id = dm_hadr_availability_replica_states.group_id AND databases.replica_id = dm_hadr_availability_replica_states.replica_id
      WHERE databases.name = @CurrentDatabaseName
    END

    IF @Version &gt;= 11 AND @Cluster IS NOT NULL AND @CurrentAvailabilityGroup IS NOT NULL
    BEGIN
      SELECT @CurrentIsPreferredBackupReplica = sys.fn_hadr_backup_is_preferred_replica(@CurrentDatabaseName)
    END

    SELECT @CurrentDatabaseMirroringRole = UPPER(mirroring_role_desc)
    FROM sys.database_mirroring
    WHERE database_id = @CurrentDatabaseID

    IF EXISTS (SELECT * FROM msdb.dbo.log_shipping_primary_databases WHERE primary_database = @CurrentDatabaseName)
    BEGIN
      SET @CurrentLogShippingRole = 'PRIMARY'
    END
    ELSE
    IF EXISTS (SELECT * FROM msdb.dbo.log_shipping_secondary_databases WHERE secondary_database = @CurrentDatabaseName)
    BEGIN
      SET @CurrentLogShippingRole = 'SECONDARY'
    END

    -- Set database message
    SET @DatabaseMessage = 'Date and time: ' + CONVERT(nvarchar,GETDATE(),120) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Database: ' + QUOTENAME(@CurrentDatabaseName) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Status: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') AS nvarchar) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Standby: ' + CASE WHEN DATABASEPROPERTYEX(@CurrentDatabaseName,'IsInStandBy') = 1 THEN 'Yes' ELSE 'No' END + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Updateability: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'Updateability') AS nvarchar) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'User access: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'UserAccess') AS nvarchar) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Is accessible: ' + CASE WHEN @CurrentIsDatabaseAccessible = 1 THEN 'Yes' ELSE 'No' END + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Recovery model: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'Recovery') AS nvarchar) + CHAR(13) + CHAR(10)
    IF @CurrentAvailabilityGroup IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Availability group: ' + @CurrentAvailabilityGroup + CHAR(13) + CHAR(10)
    IF @CurrentAvailabilityGroup IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Availability group role: ' + @CurrentAvailabilityGroupRole + CHAR(13) + CHAR(10)
    IF @CurrentAvailabilityGroup IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Availability group backup preference: ' + @CurrentAvailabilityGroupBackupPreference + CHAR(13) + CHAR(10)
    IF @CurrentAvailabilityGroup IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Is preferred backup replica: ' + CASE WHEN @CurrentIsPreferredBackupReplica = 1 THEN 'Yes' WHEN @CurrentIsPreferredBackupReplica = 0 THEN 'No' ELSE 'N/A' END + CHAR(13) + CHAR(10)
    IF @CurrentDatabaseMirroringRole IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Database mirroring role: ' + @CurrentDatabaseMirroringRole + CHAR(13) + CHAR(10)
    IF @CurrentLogShippingRole IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Log shipping role: ' + @CurrentLogShippingRole + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Differential base LSN: ' + ISNULL(CAST(@CurrentDifferentialBaseLSN AS nvarchar),'N/A') + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Differential base is snapshot: ' + CASE WHEN @CurrentDifferentialBaseIsSnapshot = 1 THEN 'Yes' WHEN @CurrentDifferentialBaseIsSnapshot = 0 THEN 'No' ELSE 'N/A' END + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Last log backup LSN: ' + ISNULL(CAST(@CurrentLogLSN AS nvarchar),'N/A') + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = REPLACE(@DatabaseMessage,'%','%%') + ' '
    RAISERROR(@DatabaseMessage,10,1) WITH NOWAIT

    IF DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') = 'ONLINE'
    AND NOT (DATABASEPROPERTYEX(@CurrentDatabaseName,'UserAccess') = 'SINGLE_USER' AND @CurrentIsDatabaseAccessible = 0)
    AND DATABASEPROPERTYEX(@CurrentDatabaseName,'IsInStandBy') = 0
    AND NOT (@CurrentBackupType = 'LOG' AND (DATABASEPROPERTYEX(@CurrentDatabaseName,'Recovery') = 'SIMPLE' OR @CurrentLogLSN IS NULL))
    AND NOT (@CurrentBackupType = 'DIFF' AND @CurrentDifferentialBaseLSN IS NULL)
    AND NOT (@CurrentBackupType IN('DIFF','LOG') AND @CurrentDatabaseName = 'master')
    AND NOT (@CurrentAvailabilityGroup IS NOT NULL AND @CurrentBackupType = 'FULL' AND @CopyOnly = 'N' AND (@CurrentAvailabilityGroupRole &lt;&gt; 'PRIMARY' OR @CurrentAvailabilityGroupRole IS NULL))
    AND NOT (@CurrentAvailabilityGroup IS NOT NULL AND @CurrentBackupType = 'FULL' AND @CopyOnly = 'Y' AND (@CurrentIsPreferredBackupReplica &lt;&gt; 1 OR @CurrentIsPreferredBackupReplica IS NULL) AND @OverrideBackupPreference = 'N')
    AND NOT (@CurrentAvailabilityGroup IS NOT NULL AND @CurrentBackupType = 'DIFF' AND (@CurrentAvailabilityGroupRole &lt;&gt; 'PRIMARY' OR @CurrentAvailabilityGroupRole IS NULL))
    AND NOT (@CurrentAvailabilityGroup IS NOT NULL AND @CurrentBackupType = 'LOG' AND @CopyOnly = 'N' AND (@CurrentIsPreferredBackupReplica &lt;&gt; 1 OR @CurrentIsPreferredBackupReplica IS NULL) AND @OverrideBackupPreference = 'N')
    AND NOT (@CurrentAvailabilityGroup IS NOT NULL AND @CurrentBackupType = 'LOG' AND @CopyOnly = 'Y' AND (@CurrentAvailabilityGroupRole &lt;&gt; 'PRIMARY' OR @CurrentAvailabilityGroupRole IS NULL))
    AND NOT ((@CurrentLogShippingRole = 'PRIMARY' AND @CurrentLogShippingRole IS NOT NULL) AND @CurrentBackupType = 'LOG')
    BEGIN

      -- Set variables
      SET @CurrentDate = GETDATE()

      INSERT INTO @CurrentCleanupDates (CleanupDate)
      SELECT @CurrentDate

      IF @CurrentBackupType = 'LOG'
      BEGIN
        INSERT INTO @CurrentCleanupDates (CleanupDate)
        SELECT @CurrentLatestBackup
      END

      SELECT @CurrentFileExtension = CASE
      WHEN @BackupSoftware IS NULL AND @CurrentBackupType = 'FULL' THEN 'bak'
      WHEN @BackupSoftware IS NULL AND @CurrentBackupType = 'DIFF' THEN 'bak'
      WHEN @BackupSoftware IS NULL AND @CurrentBackupType = 'LOG' THEN 'trn'
      WHEN @BackupSoftware = 'LITESPEED' AND @CurrentBackupType = 'FULL' THEN 'bak'
      WHEN @BackupSoftware = 'LITESPEED' AND @CurrentBackupType = 'DIFF' THEN 'bak'
      WHEN @BackupSoftware = 'LITESPEED' AND @CurrentBackupType = 'LOG' THEN 'trn'
      WHEN @BackupSoftware = 'SQLBACKUP' AND @CurrentBackupType = 'FULL' THEN 'sqb'
      WHEN @BackupSoftware = 'SQLBACKUP' AND @CurrentBackupType = 'DIFF' THEN 'sqb'
      WHEN @BackupSoftware = 'SQLBACKUP' AND @CurrentBackupType = 'LOG' THEN 'sqb'
      WHEN @BackupSoftware = 'SQLSAFE' AND @CurrentBackupType = 'FULL' THEN 'safe'
      WHEN @BackupSoftware = 'SQLSAFE' AND @CurrentBackupType = 'DIFF' THEN 'safe'
      WHEN @BackupSoftware = 'SQLSAFE' AND @CurrentBackupType = 'LOG' THEN 'safe'
      END

      INSERT INTO @CurrentDirectories (ID, DirectoryPath, CreateCompleted, CleanupCompleted)
      SELECT ROW_NUMBER() OVER (ORDER BY ID), DirectoryPath + CASE WHEN RIGHT(DirectoryPath,1) = '\' THEN '' ELSE '\' END + CASE WHEN @CurrentAvailabilityGroup IS NOT NULL THEN @Cluster + '$' + @CurrentAvailabilityGroup ELSE REPLACE(CAST(SERVERPROPERTY('servername') AS nvarchar),'\','$') END + '\' + @CurrentDatabaseNameFS + '\' + UPPER(@CurrentBackupType) + CASE WHEN @ReadWriteFileGroups = 'Y' THEN '_PARTIAL' ELSE '' END + CASE WHEN @CopyOnly = 'Y' THEN '_COPY_ONLY' ELSE '' END, 0, 0
      FROM @Directories
      ORDER BY ID ASC

      SET @CurrentFileNumber = 0

      WHILE @CurrentFileNumber &lt; @NumberOfFiles
      BEGIN
        SET @CurrentFileNumber = @CurrentFileNumber + 1

        SELECT @CurrentDirectoryPath = DirectoryPath
        FROM @CurrentDirectories
        WHERE @CurrentFileNumber &gt;= (ID - 1) * (SELECT @NumberOfFiles / COUNT(*) FROM @CurrentDirectories) + 1
        AND @CurrentFileNumber &lt;= ID * (SELECT @NumberOfFiles / COUNT(*) FROM @CurrentDirectories)

        SET @CurrentFilePath = @CurrentDirectoryPath + '\' + CASE WHEN @CurrentAvailabilityGroup IS NOT NULL THEN @Cluster + '$' + @CurrentAvailabilityGroup ELSE REPLACE(CAST(SERVERPROPERTY('servername') AS nvarchar),'\','$') END + '_' + @CurrentDatabaseNameFS + '_' + UPPER(@CurrentBackupType) + CASE WHEN @ReadWriteFileGroups = 'Y' THEN '_PARTIAL' ELSE '' END + CASE WHEN @CopyOnly = 'Y' THEN '_COPY_ONLY' ELSE '' END + '_' + REPLACE(REPLACE(REPLACE((CONVERT(nvarchar,@CurrentDate,120)),'-',''),' ','_'),':','') + CASE WHEN @NumberOfFiles &gt; 1 AND @NumberOfFiles &lt;= 9 THEN '_' + CAST(@CurrentFileNumber AS nvarchar) WHEN @NumberOfFiles &gt;= 10 THEN '_' + RIGHT('0' + CAST(@CurrentFileNumber AS nvarchar),2) ELSE '' END + '.' + @CurrentFileExtension

        IF LEN(@CurrentFilePath) &gt; 259
        BEGIN
          SET @CurrentFilePath = @CurrentDirectoryPath + '\' + @CurrentDatabaseNameFS + '_' + UPPER(@CurrentBackupType) + CASE WHEN @ReadWriteFileGroups = 'Y' THEN '_PARTIAL' ELSE '' END + CASE WHEN @CopyOnly = 'Y' THEN '_COPY_ONLY' ELSE '' END + '_' + REPLACE(REPLACE(REPLACE((CONVERT(nvarchar,@CurrentDate,120)),'-',''),' ','_'),':','') + CASE WHEN @NumberOfFiles &gt; 1 AND @NumberOfFiles &lt;= 9 THEN '_' + CAST(@CurrentFileNumber AS nvarchar) WHEN @NumberOfFiles &gt;= 10 THEN '_' + RIGHT('0' + CAST(@CurrentFileNumber AS nvarchar),2) ELSE '' END + '.' + @CurrentFileExtension
        END

        IF LEN(@CurrentFilePath) &gt; 259
        BEGIN
          SET @CurrentFilePath = @CurrentDirectoryPath + '\' + LEFT(@CurrentDatabaseNameFS,CASE WHEN (LEN(@CurrentDatabaseNameFS) + 259 - LEN(@CurrentFilePath) - 3) &lt; 20 THEN 20 ELSE (LEN(@CurrentDatabaseNameFS) + 259 - LEN(@CurrentFilePath) - 3) END) + '...' + '_' + UPPER(@CurrentBackupType) + CASE WHEN @ReadWriteFileGroups = 'Y' THEN '_PARTIAL' ELSE '' END + CASE WHEN @CopyOnly = 'Y' THEN '_COPY_ONLY' ELSE '' END + '_' + REPLACE(REPLACE(REPLACE((CONVERT(nvarchar,@CurrentDate,120)),'-',''),' ','_'),':','') + CASE WHEN @NumberOfFiles &gt; 1 AND @NumberOfFiles &lt;= 9 THEN '_' + CAST(@CurrentFileNumber AS nvarchar) WHEN @NumberOfFiles &gt;= 10 THEN '_' + RIGHT('0' + CAST(@CurrentFileNumber AS nvarchar),2) ELSE '' END + '.' + @CurrentFileExtension
        END

        INSERT INTO @CurrentFiles (CurrentFilePath)
        SELECT @CurrentFilePath

        SET @CurrentDirectoryPath = NULL
        SET @CurrentFilePath = NULL
      END

      -- Create directory
      WHILE EXISTS (SELECT * FROM @CurrentDirectories WHERE CreateCompleted = 0)
      BEGIN
        SELECT TOP 1 @CurrentDirectoryID = ID,
                     @CurrentDirectoryPath = DirectoryPath
        FROM @CurrentDirectories
        WHERE CreateCompleted = 0
        ORDER BY ID ASC

        SET @CurrentCommandType01 = 'xp_create_subdir'
        SET @CurrentCommand01 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.xp_create_subdir N''' + REPLACE(@CurrentDirectoryPath,'''','''''') + ''' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error creating directory.'', 16, 1)'
        EXECUTE @CurrentCommandOutput01 = [dbo].[CommandExecute] @Command = @CurrentCommand01, @CommandType = @CurrentCommandType01, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute
        SET @Error = @@ERROR
        IF @Error &lt;&gt; 0 SET @CurrentCommandOutput01 = @Error
        IF @CurrentCommandOutput01 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput01

        UPDATE @CurrentDirectories
        SET CreateCompleted = 1,
            CreateOutput = @CurrentCommandOutput01
        WHERE ID = @CurrentDirectoryID

        SET @CurrentDirectoryID = NULL
        SET @CurrentDirectoryPath = NULL

        SET @CurrentCommand01 = NULL

        SET @CurrentCommandOutput01 = NULL

        SET @CurrentCommandType01 = NULL
      END

      -- Perform a backup
      IF NOT EXISTS (SELECT * FROM @CurrentDirectories WHERE CreateOutput &lt;&gt; 0 OR CreateOutput IS NULL)
      BEGIN
        IF @BackupSoftware IS NULL
        BEGIN
          SELECT @CurrentCommandType02 = CASE
          WHEN @CurrentBackupType IN('DIFF','FULL') THEN 'BACKUP_DATABASE'
          WHEN @CurrentBackupType = 'LOG' THEN 'BACKUP_LOG'
          END

          SELECT @CurrentCommand02 = CASE
          WHEN @CurrentBackupType IN('DIFF','FULL') THEN 'BACKUP DATABASE ' + QUOTENAME(@CurrentDatabaseName)
          WHEN @CurrentBackupType = 'LOG' THEN 'BACKUP LOG ' + QUOTENAME(@CurrentDatabaseName)
          END

          IF @ReadWriteFileGroups = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + ' READ_WRITE_FILEGROUPS'

          SET @CurrentCommand02 = @CurrentCommand02 + ' TO'

          SELECT @CurrentCommand02 = @CurrentCommand02 + ' DISK = N''' + REPLACE(CurrentFilePath,'''','''''') + '''' + CASE WHEN ROW_NUMBER() OVER (ORDER BY CurrentFilePath ASC) &lt;&gt; @NumberOfFiles THEN ',' ELSE '' END
          FROM @CurrentFiles
          ORDER BY CurrentFilePath ASC

          SET @CurrentCommand02 = @CurrentCommand02 + ' WITH '
          IF @CheckSum = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + 'CHECKSUM'
          IF @CheckSum = 'N' SET @CurrentCommand02 = @CurrentCommand02 + 'NO_CHECKSUM'
          IF @Compress = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + ', COMPRESSION'
          IF @Compress = 'N' AND @Version &gt;= 10 SET @CurrentCommand02 = @CurrentCommand02 + ', NO_COMPRESSION'
          IF @CurrentBackupType = 'DIFF' SET @CurrentCommand02 = @CurrentCommand02 + ', DIFFERENTIAL'
          IF @CopyOnly = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + ', COPY_ONLY'
          IF @BlockSize IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', BLOCKSIZE = ' + CAST(@BlockSize AS nvarchar)
          IF @BufferCount IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', BUFFERCOUNT = ' + CAST(@BufferCount AS nvarchar)
          IF @MaxTransferSize IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', MAXTRANSFERSIZE = ' + CAST(@MaxTransferSize AS nvarchar)
          IF @Description IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', DESCRIPTION = N''' + REPLACE(@Description,'''','''''') + ''''
        END

        IF @BackupSoftware = 'LITESPEED'
        BEGIN
          SELECT @CurrentCommandType02 = CASE
          WHEN @CurrentBackupType IN('DIFF','FULL') THEN 'xp_backup_database'
          WHEN @CurrentBackupType = 'LOG' THEN 'xp_backup_log'
          END

          SELECT @CurrentCommand02 = CASE
          WHEN @CurrentBackupType IN('DIFF','FULL') THEN 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.xp_backup_database @database = N''' + REPLACE(@CurrentDatabaseName,'''','''''') + ''''
          WHEN @CurrentBackupType = 'LOG' THEN 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.xp_backup_log @database = N''' + REPLACE(@CurrentDatabaseName,'''','''''') + ''''
          END

          SELECT @CurrentCommand02 = @CurrentCommand02 + ', @filename = N''' + REPLACE(CurrentFilePath,'''','''''') + ''''
          FROM @CurrentFiles
          ORDER BY CurrentFilePath ASC

          SET @CurrentCommand02 = @CurrentCommand02 + ', @with = '''
          IF @CheckSum = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + 'CHECKSUM'
          IF @CheckSum = 'N' SET @CurrentCommand02 = @CurrentCommand02 + 'NO_CHECKSUM'
          IF @CurrentBackupType = 'DIFF' SET @CurrentCommand02 = @CurrentCommand02 + ', DIFFERENTIAL'
          IF @CopyOnly = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + ', COPY_ONLY'
          IF @BlockSize IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', BLOCKSIZE = ' + CAST(@BlockSize AS nvarchar)
          SET @CurrentCommand02 = @CurrentCommand02 + ''''
          IF @ReadWriteFileGroups = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + ', @read_write_filegroups = 1'
          IF @CompressionLevel IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @compressionlevel = ' + CAST(@CompressionLevel AS nvarchar)
          IF @BufferCount IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @buffercount = ' + CAST(@BufferCount AS nvarchar)
          IF @MaxTransferSize IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @maxtransfersize = ' + CAST(@MaxTransferSize AS nvarchar)
          IF @Threads IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @threads = ' + CAST(@Threads AS nvarchar)
          IF @Throttle IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @throttle = ' + CAST(@Throttle AS nvarchar)
          IF @Description IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @desc = N''' + REPLACE(@Description,'''','''''') + ''''

          IF @EncryptionAlgorithm IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @cryptlevel = ' + CASE
          WHEN @EncryptionAlgorithm = 'RC2_40' THEN '0'
          WHEN @EncryptionAlgorithm = 'RC2_56' THEN '1'
          WHEN @EncryptionAlgorithm = 'RC2_112' THEN '2'
          WHEN @EncryptionAlgorithm = 'RC2_128' THEN '3'
          WHEN @EncryptionAlgorithm = '3DES_168' THEN '4'
          WHEN @EncryptionAlgorithm = 'RC4_128' THEN '5'
          WHEN @EncryptionAlgorithm = 'AES_128' THEN '6'
          WHEN @EncryptionAlgorithm = 'AES_192' THEN '7'
          WHEN @EncryptionAlgorithm = 'AES_256' THEN '8'
          END

          IF @EncryptionKey IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @encryptionkey = N''' + REPLACE(@EncryptionKey,'''','''''') + ''''
          SET @CurrentCommand02 = @CurrentCommand02 + ' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error performing LiteSpeed backup.'', 16, 1)'
        END

        IF @BackupSoftware = 'SQLBACKUP'
        BEGIN
          SET @CurrentCommandType02 = 'sqlbackup'

          SELECT @CurrentCommand02 = CASE
          WHEN @CurrentBackupType IN('DIFF','FULL') THEN 'BACKUP DATABASE ' + QUOTENAME(@CurrentDatabaseName)
          WHEN @CurrentBackupType = 'LOG' THEN 'BACKUP LOG ' + QUOTENAME(@CurrentDatabaseName)
          END

          IF @ReadWriteFileGroups = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + ' READ_WRITE_FILEGROUPS'

          SET @CurrentCommand02 = @CurrentCommand02 + ' TO'

          SELECT @CurrentCommand02 = @CurrentCommand02 + ' DISK = N''' + REPLACE(CurrentFilePath,'''','''''') + '''' + CASE WHEN ROW_NUMBER() OVER (ORDER BY CurrentFilePath ASC) &lt;&gt; @NumberOfFiles THEN ',' ELSE '' END
          FROM @CurrentFiles
          ORDER BY CurrentFilePath ASC

          SET @CurrentCommand02 = @CurrentCommand02 + ' WITH '
          IF @CheckSum = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + 'CHECKSUM'
          IF @CheckSum = 'N' SET @CurrentCommand02 = @CurrentCommand02 + 'NO_CHECKSUM'
          IF @CurrentBackupType = 'DIFF' SET @CurrentCommand02 = @CurrentCommand02 + ', DIFFERENTIAL'
          IF @CopyOnly = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + ', COPY_ONLY'
          IF @CompressionLevel IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', COMPRESSION = ' + CAST(@CompressionLevel AS nvarchar)
          IF @Threads IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', THREADCOUNT = ' + CAST(@Threads AS nvarchar)
          IF @MaxTransferSize IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', MAXTRANSFERSIZE = ' + CAST(@MaxTransferSize AS nvarchar)
          IF @Description IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', DESCRIPTION = N''' + REPLACE(@Description,'''','''''') + ''''

          IF @EncryptionAlgorithm IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', KEYSIZE = ' + CASE
          WHEN @EncryptionAlgorithm = 'AES_128' THEN '128'
          WHEN @EncryptionAlgorithm = 'AES_256' THEN '256'
          END

          IF @EncryptionKey IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', PASSWORD = N''' + REPLACE(@EncryptionKey,'''','''''') + ''''
          SET @CurrentCommand02 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.sqlbackup N''-SQL "' + REPLACE(@CurrentCommand02,'''','''''') + '"''' + ' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error performing SQLBackup backup.'', 16, 1)'
        END

        IF @BackupSoftware = 'SQLSAFE'
        BEGIN
          SET @CurrentCommandType02 = 'xp_ss_backup'

          SET @CurrentCommand02 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.xp_ss_backup @database = N''' + REPLACE(@CurrentDatabaseName,'''','''''') + ''''

          SELECT @CurrentCommand02 = @CurrentCommand02 + ', ' + CASE WHEN ROW_NUMBER() OVER (ORDER BY CurrentFilePath ASC) = 1 THEN '@filename' ELSE '@backupfile' END + ' = N''' + REPLACE(CurrentFilePath,'''','''''') + ''''
          FROM @CurrentFiles
          ORDER BY CurrentFilePath ASC

          SET @CurrentCommand02 = @CurrentCommand02 + ', @backuptype = ' + CASE WHEN @CurrentBackupType = 'FULL' THEN '''Full''' WHEN @CurrentBackupType = 'DIFF' THEN '''Differential''' WHEN @CurrentBackupType = 'LOG' THEN '''Log''' END
          IF @ReadWriteFileGroups = 'Y' SET @CurrentCommand02 = @CurrentCommand02 + ', @readwritefilegroups = 1'
          SET @CurrentCommand02 = @CurrentCommand02 + ', @checksum = ' + CASE WHEN @CheckSum = 'Y' THEN '1' WHEN @CheckSum = 'N' THEN '0' END
          SET @CurrentCommand02 = @CurrentCommand02 + ', @copyonly = ' + CASE WHEN @CopyOnly = 'Y' THEN '1' WHEN @CopyOnly = 'N' THEN '0' END
          IF @CompressionLevel IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @compressionlevel = ' + CAST(@CompressionLevel AS nvarchar)
          IF @Threads IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @threads = ' + CAST(@Threads AS nvarchar)
          IF @Description IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @desc = N''' + REPLACE(@Description,'''','''''') + ''''

          IF @EncryptionAlgorithm IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @encryptiontype = N''' + CASE
          WHEN @EncryptionAlgorithm = 'AES_128' THEN 'AES128'
          WHEN @EncryptionAlgorithm = 'AES_256' THEN 'AES256'
          END + ''''

          IF @EncryptionKey IS NOT NULL SET @CurrentCommand02 = @CurrentCommand02 + ', @encryptedbackuppassword = N''' + REPLACE(@EncryptionKey,'''','''''') + ''''
          SET @CurrentCommand02 = @CurrentCommand02 + ' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error performing SQLsafe backup.'', 16, 1)'
        END

        EXECUTE @CurrentCommandOutput02 = [dbo].[CommandExecute] @Command = @CurrentCommand02, @CommandType = @CurrentCommandType02, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute
        SET @Error = @@ERROR
        IF @Error &lt;&gt; 0 SET @CurrentCommandOutput02 = @Error
        IF @CurrentCommandOutput02 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput02
      END

      -- Verify the backup
      IF @CurrentCommandOutput02 = 0 AND @Verify = 'Y'
      BEGIN
        IF @BackupSoftware IS NULL
        BEGIN
          SET @CurrentCommandType03 = 'RESTORE_VERIFYONLY'

          SET @CurrentCommand03 = 'RESTORE VERIFYONLY FROM'

          SELECT @CurrentCommand03 = @CurrentCommand03 + ' DISK = N''' + REPLACE(CurrentFilePath,'''','''''') + '''' + CASE WHEN ROW_NUMBER() OVER (ORDER BY CurrentFilePath ASC) &lt;&gt; @NumberOfFiles THEN ',' ELSE '' END
          FROM @CurrentFiles
          ORDER BY CurrentFilePath ASC

          SET @CurrentCommand03 = @CurrentCommand03 + ' WITH '
          IF @CheckSum = 'Y' SET @CurrentCommand03 = @CurrentCommand03 + 'CHECKSUM'
          IF @CheckSum = 'N' SET @CurrentCommand03 = @CurrentCommand03 + 'NO_CHECKSUM'
        END

        IF @BackupSoftware = 'LITESPEED'
        BEGIN
          SET @CurrentCommandType03 = 'xp_restore_verifyonly'

          SET @CurrentCommand03 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.xp_restore_verifyonly'

          SELECT @CurrentCommand03 = @CurrentCommand03 + ' @filename = N''' + REPLACE(CurrentFilePath,'''','''''') + '''' + CASE WHEN ROW_NUMBER() OVER (ORDER BY CurrentFilePath ASC) &lt;&gt; @NumberOfFiles THEN ',' ELSE '' END
          FROM @CurrentFiles
          ORDER BY CurrentFilePath ASC

          SET @CurrentCommand03 = @CurrentCommand03 + ', @with = '''
          IF @CheckSum = 'Y' SET @CurrentCommand03 = @CurrentCommand03 + 'CHECKSUM'
          IF @CheckSum = 'N' SET @CurrentCommand03 = @CurrentCommand03 + 'NO_CHECKSUM'
          SET @CurrentCommand03 = @CurrentCommand03 + ''''
          IF @EncryptionKey IS NOT NULL SET @CurrentCommand03 = @CurrentCommand03 + ', @encryptionkey = N''' + REPLACE(@EncryptionKey,'''','''''') + ''''

          SET @CurrentCommand03 = @CurrentCommand03 + ' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error verifying LiteSpeed backup.'', 16, 1)'
        END

        IF @BackupSoftware = 'SQLBACKUP'
        BEGIN
          SET @CurrentCommandType03 = 'sqlbackup'

          SET @CurrentCommand03 = 'RESTORE VERIFYONLY FROM'

          SELECT @CurrentCommand03 = @CurrentCommand03 + ' DISK = N''' + REPLACE(CurrentFilePath,'''','''''') + '''' + CASE WHEN ROW_NUMBER() OVER (ORDER BY CurrentFilePath ASC) &lt;&gt; @NumberOfFiles THEN ',' ELSE '' END
          FROM @CurrentFiles
          ORDER BY CurrentFilePath ASC

          SET @CurrentCommand03 = @CurrentCommand03 + ' WITH '
          IF @CheckSum = 'Y' SET @CurrentCommand03 = @CurrentCommand03 + 'CHECKSUM'
          IF @CheckSum = 'N' SET @CurrentCommand03 = @CurrentCommand03 + 'NO_CHECKSUM'
          IF @EncryptionKey IS NOT NULL SET @CurrentCommand03 = @CurrentCommand03 + ', PASSWORD = N''' + REPLACE(@EncryptionKey,'''','''''') + ''''

          SET @CurrentCommand03 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.sqlbackup N''-SQL "' + REPLACE(@CurrentCommand03,'''','''''') + '"''' + ' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error verifying SQLBackup backup.'', 16, 1)'
        END

        IF @BackupSoftware = 'SQLSAFE'
        BEGIN
          SET @CurrentCommandType03 = 'xp_ss_verify'

          SET @CurrentCommand03 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.xp_ss_verify @database = N''' + REPLACE(@CurrentDatabaseName,'''','''''') + ''''

          SELECT @CurrentCommand03 = @CurrentCommand03 + ', ' + CASE WHEN ROW_NUMBER() OVER (ORDER BY CurrentFilePath ASC) = 1 THEN '@filename' ELSE '@backupfile' END + ' = N''' + REPLACE(CurrentFilePath,'''','''''') + ''''
          FROM @CurrentFiles
          ORDER BY CurrentFilePath ASC

          SET @CurrentCommand03 = @CurrentCommand03 + ' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error verifying SQLsafe backup.'', 16, 1)'
        END

        EXECUTE @CurrentCommandOutput03 = [dbo].[CommandExecute] @Command = @CurrentCommand03, @CommandType = @CurrentCommandType03, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute
        SET @Error = @@ERROR
        IF @Error &lt;&gt; 0 SET @CurrentCommandOutput03 = @Error
        IF @CurrentCommandOutput03 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput03
      END

      INSERT INTO @CurrentCleanupDates (CleanupDate)
      SELECT DATEADD(hh,-(@CleanupTime),GETDATE())

      IF EXISTS(SELECT * FROM @CurrentCleanupDates WHERE CleanupDate IS NULL)
      BEGIN
        SET @CurrentCleanupDate = NULL
      END
      ELSE
      BEGIN
        SELECT @CurrentCleanupDate = MIN(CleanupDate)
        FROM @CurrentCleanupDates
      END

      -- Delete old backup files
      IF ((@CurrentCommandOutput02 = 0 AND @Verify = 'N' AND @CurrentCleanupDate IS NOT NULL)
      OR (@CurrentCommandOutput02 = 0 AND @Verify = 'Y' AND @CurrentCommandOutput03 = 0 AND @CurrentCleanupDate IS NOT NULL))
      AND @CurrentBackupType = @BackupType
      BEGIN
        WHILE EXISTS (SELECT * FROM @CurrentDirectories WHERE CleanupCompleted = 0)
        BEGIN
          SELECT TOP 1 @CurrentDirectoryID = ID,
                       @CurrentDirectoryPath = DirectoryPath
          FROM @CurrentDirectories
          WHERE CleanupCompleted = 0
          ORDER BY ID ASC

          IF @BackupSoftware IS NULL
          BEGIN
            SET @CurrentCommandType04 = 'xp_delete_file'

            SET @CurrentCommand04 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.xp_delete_file 0, N''' + REPLACE(@CurrentDirectoryPath,'''','''''') + ''', ''' + @CurrentFileExtension + ''', ''' + CONVERT(nvarchar(19),@CurrentCleanupDate,126) + ''' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error deleting files.'', 16, 1)'
          END

          IF @BackupSoftware = 'LITESPEED'
          BEGIN
            SET @CurrentCommandType04 = 'xp_slssqlmaint'

            SET @CurrentCommand04 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.xp_slssqlmaint N''-MAINTDEL -DELFOLDER "' + REPLACE(@CurrentDirectoryPath,'''','''''') + '" -DELEXTENSION "' + @CurrentFileExtension + '" -DELUNIT "' + CAST(DATEDIFF(mi,@CurrentCleanupDate,GETDATE()) + 1 AS nvarchar) + '" -DELUNITTYPE "minutes" -DELUSEAGE'' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error deleting LiteSpeed backup files.'', 16, 1)'
          END

          IF @BackupSoftware = 'SQLBACKUP'
          BEGIN
            SET @CurrentCommandType04 = 'sqbutility'

            SET @CurrentCommand04 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.sqbutility 1032, N''' + REPLACE(@CurrentDatabaseName,'''','''''') + ''', N''' + REPLACE(@CurrentDirectoryPath,'''','''''') + ''', ''' + CASE WHEN @CurrentBackupType = 'FULL' THEN 'D' WHEN @CurrentBackupType = 'DIFF' THEN 'I' WHEN @CurrentBackupType = 'LOG' THEN 'L' END + ''', ''' + CAST(DATEDIFF(hh,@CurrentCleanupDate,GETDATE()) + 1 AS nvarchar) + 'h'', ' + ISNULL('''' + REPLACE(@EncryptionKey,'''','''''') + '''','NULL') + ' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error deleting SQLBackup backup files.'', 16, 1)'
          END

          IF @BackupSoftware = 'SQLSAFE'
          BEGIN
            SET @CurrentCommandType04 = 'xp_ss_delete'

            SET @CurrentCommand04 = 'DECLARE @ReturnCode int EXECUTE @ReturnCode = [master].dbo.xp_ss_delete @filename = N''' + REPLACE(@CurrentDirectoryPath,'''','''''') + '\*.' + @CurrentFileExtension + ''', @age = ''' + CAST(DATEDIFF(mi,@CurrentCleanupDate,GETDATE()) + 1 AS nvarchar) + 'Minutes'' IF @ReturnCode &lt;&gt; 0 RAISERROR(''Error deleting SQLsafe backup files.'', 16, 1)'
          END

          EXECUTE @CurrentCommandOutput04 = [dbo].[CommandExecute] @Command = @CurrentCommand04, @CommandType = @CurrentCommandType04, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute
          SET @Error = @@ERROR
          IF @Error &lt;&gt; 0 SET @CurrentCommandOutput04 = @Error
          IF @CurrentCommandOutput04 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput04

          UPDATE @CurrentDirectories
          SET CleanupCompleted = 1,
              CleanupOutput = @CurrentCommandOutput04
          WHERE ID = @CurrentDirectoryID

          SET @CurrentDirectoryID = NULL
          SET @CurrentDirectoryPath = NULL

          SET @CurrentCommand04 = NULL

          SET @CurrentCommandOutput04 = NULL

          SET @CurrentCommandType04 = NULL
        END
      END
    END

    -- Update that the database is completed
    UPDATE @tmpDatabases
    SET Completed = 1
    WHERE Selected = 1
    AND Completed = 0
    AND ID = @CurrentDBID

    -- Clear variables
    SET @CurrentDBID = NULL
    SET @CurrentDatabaseID = NULL
    SET @CurrentDatabaseName = NULL
    SET @CurrentBackupType = NULL
    SET @CurrentFileExtension = NULL
    SET @CurrentFileNumber = NULL
    SET @CurrentDifferentialBaseLSN = NULL
    SET @CurrentDifferentialBaseIsSnapshot = NULL
    SET @CurrentLogLSN = NULL
    SET @CurrentLatestBackup = NULL
    SET @CurrentDatabaseNameFS = NULL
    SET @CurrentDate = NULL
    SET @CurrentCleanupDate = NULL
    SET @CurrentIsDatabaseAccessible = NULL
    SET @CurrentAvailabilityGroup = NULL
    SET @CurrentAvailabilityGroupRole = NULL
    SET @CurrentAvailabilityGroupBackupPreference = NULL
    SET @CurrentIsPreferredBackupReplica = NULL
    SET @CurrentDatabaseMirroringRole = NULL
    SET @CurrentLogShippingRole = NULL

    SET @CurrentCommand02 = NULL
    SET @CurrentCommand03 = NULL

    SET @CurrentCommandOutput02 = NULL
    SET @CurrentCommandOutput03 = NULL

    SET @CurrentCommandType02 = NULL
    SET @CurrentCommandType03 = NULL

    DELETE FROM @CurrentDirectories
    DELETE FROM @CurrentFiles
    DELETE FROM @CurrentCleanupDates

  END

  ----------------------------------------------------------------------------------------------------
  --// Log completing information                                                                 //--
  ----------------------------------------------------------------------------------------------------

  Logging:
  SET @EndMessage = 'Date and time: ' + CONVERT(nvarchar,GETDATE(),120)
  SET @EndMessage = REPLACE(@EndMessage,'%','%%')
  RAISERROR(@EndMessage,10,1) WITH NOWAIT

  IF @ReturnCode &lt;&gt; 0
  BEGIN
    RETURN @ReturnCode
  END

  ----------------------------------------------------------------------------------------------------

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[DatabaseIntegrityCheck]

@Databases nvarchar(max),
@CheckCommands nvarchar(max) = 'CHECKDB',
@PhysicalOnly nvarchar(max) = 'N',
@NoIndex nvarchar(max) = 'N',
@ExtendedLogicalChecks nvarchar(max) = 'N',
@TabLock nvarchar(max) = 'N',
@FileGroups nvarchar(max) = NULL,
@Objects nvarchar(max) = NULL,
@LockTimeout int = NULL,
@LogToTable nvarchar(max) = 'N',
@Execute nvarchar(max) = 'Y'

AS

BEGIN

  ----------------------------------------------------------------------------------------------------
  --// Source: http://ola.hallengren.com                                                          //--
  ----------------------------------------------------------------------------------------------------

  SET NOCOUNT ON

  DECLARE @StartMessage nvarchar(max)
  DECLARE @EndMessage nvarchar(max)
  DECLARE @DatabaseMessage nvarchar(max)
  DECLARE @ErrorMessage nvarchar(max)

  DECLARE @Version numeric(18,10)
  DECLARE @AmazonRDS bit

  DECLARE @Cluster nvarchar(max)

  DECLARE @CurrentDBID int
  DECLARE @CurrentDatabaseID int
  DECLARE @CurrentDatabaseName nvarchar(max)
  DECLARE @CurrentIsDatabaseAccessible bit
  DECLARE @CurrentAvailabilityGroup nvarchar(max)
  DECLARE @CurrentAvailabilityGroupRole nvarchar(max)
  DECLARE @CurrentDatabaseMirroringRole nvarchar(max)
  DECLARE @CurrentLogShippingRole nvarchar(max)

  DECLARE @CurrentFGID int
  DECLARE @CurrentFileGroupID int
  DECLARE @CurrentFileGroupName nvarchar(max)
  DECLARE @CurrentFileGroupExists bit

  DECLARE @CurrentOID int
  DECLARE @CurrentSchemaID int
  DECLARE @CurrentSchemaName nvarchar(max)
  DECLARE @CurrentObjectID int
  DECLARE @CurrentObjectName nvarchar(max)
  DECLARE @CurrentObjectType nvarchar(max)
  DECLARE @CurrentObjectExists bit

  DECLARE @CurrentCommand01 nvarchar(max)
  DECLARE @CurrentCommand02 nvarchar(max)
  DECLARE @CurrentCommand03 nvarchar(max)
  DECLARE @CurrentCommand04 nvarchar(max)
  DECLARE @CurrentCommand05 nvarchar(max)
  DECLARE @CurrentCommand06 nvarchar(max)
  DECLARE @CurrentCommand07 nvarchar(max)
  DECLARE @CurrentCommand08 nvarchar(max)
  DECLARE @CurrentCommand09 nvarchar(max)

  DECLARE @CurrentCommandOutput01 int
  DECLARE @CurrentCommandOutput04 int
  DECLARE @CurrentCommandOutput05 int
  DECLARE @CurrentCommandOutput08 int
  DECLARE @CurrentCommandOutput09 int

  DECLARE @CurrentCommandType01 nvarchar(max)
  DECLARE @CurrentCommandType04 nvarchar(max)
  DECLARE @CurrentCommandType05 nvarchar(max)
  DECLARE @CurrentCommandType08 nvarchar(max)
  DECLARE @CurrentCommandType09 nvarchar(max)

  DECLARE @tmpDatabases TABLE (ID int IDENTITY,
                               DatabaseName nvarchar(max),
                               DatabaseType nvarchar(max),
                               Selected bit,
                               Completed bit,
                               PRIMARY KEY(Selected, Completed, ID))

  DECLARE @tmpFileGroups TABLE (ID int IDENTITY,
                                FileGroupID int,
                                FileGroupName nvarchar(max),
                                Selected bit,
                                Completed bit,
                                PRIMARY KEY(Selected, Completed, ID))

  DECLARE @tmpObjects TABLE (ID int IDENTITY,
                             SchemaID int,
                             SchemaName nvarchar(max),
                             ObjectID int,
                             ObjectName nvarchar(max),
                             ObjectType nvarchar(max),
                             Selected bit,
                             Completed bit,
                             PRIMARY KEY(Selected, Completed, ID))

  DECLARE @SelectedDatabases TABLE (DatabaseName nvarchar(max),
                                    DatabaseType nvarchar(max),
                                    Selected bit)

  DECLARE @SelectedFileGroups TABLE (DatabaseName nvarchar(max),
                                     FileGroupName nvarchar(max),
                                     Selected bit)

  DECLARE @SelectedObjects TABLE (DatabaseName nvarchar(max),
                                  SchemaName nvarchar(max),
                                  ObjectName nvarchar(max),
                                  Selected bit)

  DECLARE @SelectedCheckCommands TABLE (CheckCommand nvarchar(max))

  DECLARE @Error int
  DECLARE @ReturnCode int

  SET @Error = 0
  SET @ReturnCode = 0

  SET @Version = CAST(LEFT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)),CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - 1) + '.' + REPLACE(RIGHT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)), LEN(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)))),'.','') AS numeric(18,10))

  SET @AmazonRDS = CASE WHEN DB_ID('rdsadmin') IS NOT NULL AND SUSER_SNAME(0x01) = 'rdsa' THEN 1 ELSE 0 END

  ----------------------------------------------------------------------------------------------------
  --// Log initial information                                                                    //--
  ----------------------------------------------------------------------------------------------------

  SET @StartMessage = 'Date and time: ' + CONVERT(nvarchar,GETDATE(),120) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Server: ' + CAST(SERVERPROPERTY('ServerName') AS nvarchar) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Version: ' + CAST(SERVERPROPERTY('ProductVersion') AS nvarchar) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Edition: ' + CAST(SERVERPROPERTY('Edition') AS nvarchar) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Procedure: ' + QUOTENAME(DB_NAME(DB_ID())) + '.' + (SELECT QUOTENAME(schemas.name) FROM sys.schemas schemas INNER JOIN sys.objects objects ON schemas.[schema_id] = objects.[schema_id] WHERE [object_id] = @@PROCID) + '.' + QUOTENAME(OBJECT_NAME(@@PROCID)) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Parameters: @Databases = ' + ISNULL('''' + REPLACE(@Databases,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @CheckCommands = ' + ISNULL('''' + REPLACE(@CheckCommands,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @PhysicalOnly = ' + ISNULL('''' + REPLACE(@PhysicalOnly,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @NoIndex = ' + ISNULL('''' + REPLACE(@NoIndex,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @ExtendedLogicalChecks = ' + ISNULL('''' + REPLACE(@ExtendedLogicalChecks,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @TabLock = ' + ISNULL('''' + REPLACE(@TabLock,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @FileGroups = ' + ISNULL('''' + REPLACE(@FileGroups,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @Objects = ' + ISNULL('''' + REPLACE(@Objects,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @LockTimeout = ' + ISNULL(CAST(@LockTimeout AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @LogToTable = ' + ISNULL('''' + REPLACE(@LogToTable,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @Execute = ' + ISNULL('''' + REPLACE(@Execute,'''','''''') + '''','NULL') + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Source: http://ola.hallengren.com' + CHAR(13) + CHAR(10)
  SET @StartMessage = REPLACE(@StartMessage,'%','%%') + ' '
  RAISERROR(@StartMessage,10,1) WITH NOWAIT

  ----------------------------------------------------------------------------------------------------
  --// Check core requirements                                                                    //--
  ----------------------------------------------------------------------------------------------------

  IF NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute')
  BEGIN
    SET @ErrorMessage = 'The stored procedure CommandExecute is missing. Download http://ola.hallengren.com/scripts/CommandExecute.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute' AND (OBJECT_DEFINITION(objects.[object_id]) NOT LIKE '%@LogToTable%' OR OBJECT_DEFINITION(objects.[object_id]) LIKE '%LOCK_TIMEOUT%'))
  BEGIN
    SET @ErrorMessage = 'The stored procedure CommandExecute needs to be updated. Download http://ola.hallengren.com/scripts/CommandExecute.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LogToTable = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandLog')
  BEGIN
    SET @ErrorMessage = 'The table CommandLog is missing. Download http://ola.hallengren.com/scripts/CommandLog.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Error &lt;&gt; 0
  BEGIN
    SET @ReturnCode = @Error
    GOTO Logging
  END

  ----------------------------------------------------------------------------------------------------
  --// Select databases                                                                           //--
  ----------------------------------------------------------------------------------------------------

  SET @Databases = REPLACE(@Databases, ', ', ',');

  WITH Databases1 (StartPosition, EndPosition, DatabaseItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Databases, 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, 1, ISNULL(NULLIF(CHARINDEX(',', @Databases, 1), 0), LEN(@Databases) + 1) - 1) AS DatabaseItem
  WHERE @Databases IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) - EndPosition - 1) AS DatabaseItem
  FROM Databases1
  WHERE EndPosition &lt; LEN(@Databases) + 1
  ),
  Databases2 (DatabaseItem, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem LIKE '-%' THEN RIGHT(DatabaseItem,LEN(DatabaseItem) - 1) ELSE DatabaseItem END AS DatabaseItem,
         CASE WHEN DatabaseItem LIKE '-%' THEN 0 ELSE 1 END AS Selected
  FROM Databases1
  ),
  Databases3 (DatabaseItem, DatabaseType, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem IN('ALL_DATABASES','SYSTEM_DATABASES','USER_DATABASES') THEN '%' ELSE DatabaseItem END AS DatabaseItem,
         CASE WHEN DatabaseItem = 'SYSTEM_DATABASES' THEN 'S' WHEN DatabaseItem = 'USER_DATABASES' THEN 'U' ELSE NULL END AS DatabaseType,
         Selected
  FROM Databases2
  ),
  Databases4 (DatabaseName, DatabaseType, Selected) AS
  (
  SELECT CASE WHEN LEFT(DatabaseItem,1) = '[' AND RIGHT(DatabaseItem,1) = ']' THEN PARSENAME(DatabaseItem,1) ELSE DatabaseItem END AS DatabaseItem,
         DatabaseType,
         Selected
  FROM Databases3
  )
  INSERT INTO @SelectedDatabases (DatabaseName, DatabaseType, Selected)
  SELECT DatabaseName,
         DatabaseType,
         Selected
  FROM Databases4
  OPTION (MAXRECURSION 0)

  INSERT INTO @tmpDatabases (DatabaseName, DatabaseType, Selected, Completed)
  SELECT [name] AS DatabaseName,
         CASE WHEN name IN('master','msdb','model') THEN 'S' ELSE 'U' END AS DatabaseType,
         0 AS Selected,
         0 AS Completed
  FROM sys.databases
  WHERE [name] &lt;&gt; 'tempdb'
  AND source_database_id IS NULL
  ORDER BY [name] ASC

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  WHERE SelectedDatabases.Selected = 1

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  WHERE SelectedDatabases.Selected = 0

  IF @Databases IS NULL OR NOT EXISTS(SELECT * FROM @SelectedDatabases) OR EXISTS(SELECT * FROM @SelectedDatabases WHERE DatabaseName IS NULL OR DatabaseName = '')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Databases is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  ----------------------------------------------------------------------------------------------------
  --// Select filegroups                                                                          //--
  ----------------------------------------------------------------------------------------------------

  SET @FileGroups = REPLACE(@FileGroups, ', ', ',');

  WITH FileGroups1 (StartPosition, EndPosition, FileGroupItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @FileGroups, 1), 0), LEN(@FileGroups) + 1) AS EndPosition,
         SUBSTRING(@FileGroups, 1, ISNULL(NULLIF(CHARINDEX(',', @FileGroups, 1), 0), LEN(@FileGroups) + 1) - 1) AS FileGroupItem
  WHERE @FileGroups IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @FileGroups, EndPosition + 1), 0), LEN(@FileGroups) + 1) AS EndPosition,
         SUBSTRING(@FileGroups, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @FileGroups, EndPosition + 1), 0), LEN(@FileGroups) + 1) - EndPosition - 1) AS FileGroupItem
  FROM FileGroups1
  WHERE EndPosition &lt; LEN(@FileGroups) + 1
  ),
  FileGroups2 (FileGroupItem, Selected) AS
  (
  SELECT CASE WHEN FileGroupItem LIKE '-%' THEN RIGHT(FileGroupItem,LEN(FileGroupItem) - 1) ELSE FileGroupItem END AS FileGroupItem,
         CASE WHEN FileGroupItem LIKE '-%' THEN 0 ELSE 1 END AS Selected
  FROM FileGroups1
  ),
  FileGroups3 (FileGroupItem, Selected) AS
  (
  SELECT CASE WHEN FileGroupItem = 'ALL_FILEGROUPS' THEN '%.%' ELSE FileGroupItem END AS FileGroupItem,
         Selected
  FROM FileGroups2
  ),
  FileGroups4 (DatabaseName, FileGroupName, Selected) AS
  (
  SELECT CASE WHEN PARSENAME(FileGroupItem,4) IS NULL AND PARSENAME(FileGroupItem,3) IS NULL THEN PARSENAME(FileGroupItem,2) ELSE NULL END AS DatabaseName,
         CASE WHEN PARSENAME(FileGroupItem,4) IS NULL AND PARSENAME(FileGroupItem,3) IS NULL THEN PARSENAME(FileGroupItem,1) ELSE NULL END AS FileGroupName,
         Selected
  FROM FileGroups3
  )
  INSERT INTO @SelectedFileGroups (DatabaseName, FileGroupName, Selected)
  SELECT DatabaseName, FileGroupName, Selected
  FROM FileGroups4
  OPTION (MAXRECURSION 0)

  ----------------------------------------------------------------------------------------------------
  --// Select objects                                                                             //--
  ----------------------------------------------------------------------------------------------------

  SET @Objects = REPLACE(@Objects, ', ', ',');

  WITH Objects1 (StartPosition, EndPosition, ObjectItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Objects, 1), 0), LEN(@Objects) + 1) AS EndPosition,
         SUBSTRING(@Objects, 1, ISNULL(NULLIF(CHARINDEX(',', @Objects, 1), 0), LEN(@Objects) + 1) - 1) AS ObjectItem
  WHERE @Objects IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Objects, EndPosition + 1), 0), LEN(@Objects) + 1) AS EndPosition,
         SUBSTRING(@Objects, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @Objects, EndPosition + 1), 0), LEN(@Objects) + 1) - EndPosition - 1) AS ObjectItem
  FROM Objects1
  WHERE EndPosition &lt; LEN(@Objects) + 1
  ),
  Objects2 (ObjectItem, Selected) AS
  (
  SELECT CASE WHEN ObjectItem LIKE '-%' THEN RIGHT(ObjectItem,LEN(ObjectItem) - 1) ELSE ObjectItem END AS ObjectItem,
         CASE WHEN ObjectItem LIKE '-%' THEN 0 ELSE 1 END AS Selected
  FROM Objects1
  ),
  Objects3 (ObjectItem, Selected) AS
  (
  SELECT CASE WHEN ObjectItem = 'ALL_OBJECTS' THEN '%.%.%' ELSE ObjectItem END AS ObjectItem,
         Selected
  FROM Objects2
  ),
  Objects4 (DatabaseName, SchemaName, ObjectName, Selected) AS
  (
  SELECT CASE WHEN PARSENAME(ObjectItem,4) IS NULL THEN PARSENAME(ObjectItem,3) ELSE NULL END AS DatabaseName,
         CASE WHEN PARSENAME(ObjectItem,4) IS NULL THEN PARSENAME(ObjectItem,2) ELSE NULL END AS SchemaName,
         CASE WHEN PARSENAME(ObjectItem,4) IS NULL THEN PARSENAME(ObjectItem,1) ELSE NULL END AS ObjectName,
         Selected
  FROM Objects3
  )
  INSERT INTO @SelectedObjects (DatabaseName, SchemaName, ObjectName, Selected)
  SELECT DatabaseName, SchemaName, ObjectName, Selected
  FROM Objects4
  OPTION (MAXRECURSION 0);

  ----------------------------------------------------------------------------------------------------
  --// Select check commands                                                                      //--
  ----------------------------------------------------------------------------------------------------

  WITH CheckCommands (StartPosition, EndPosition, CheckCommand) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @CheckCommands, 1), 0), LEN(@CheckCommands) + 1) AS EndPosition,
         SUBSTRING(@CheckCommands, 1, ISNULL(NULLIF(CHARINDEX(',', @CheckCommands, 1), 0), LEN(@CheckCommands) + 1) - 1) AS CheckCommand
  WHERE @CheckCommands IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @CheckCommands, EndPosition + 1), 0), LEN(@CheckCommands) + 1) AS EndPosition,
         SUBSTRING(@CheckCommands, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @CheckCommands, EndPosition + 1), 0), LEN(@CheckCommands) + 1) - EndPosition - 1) AS CheckCommand
  FROM CheckCommands
  WHERE EndPosition &lt; LEN(@CheckCommands) + 1
  )
  INSERT INTO @SelectedCheckCommands (CheckCommand)
  SELECT CheckCommand
  FROM CheckCommands
  OPTION (MAXRECURSION 0)

  ----------------------------------------------------------------------------------------------------
  --// Check input parameters                                                                     //--
  ----------------------------------------------------------------------------------------------------

  IF EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand NOT IN('CHECKDB','CHECKFILEGROUP','CHECKALLOC','CHECKTABLE','CHECKCATALOG')) OR EXISTS (SELECT * FROM @SelectedCheckCommands GROUP BY CheckCommand HAVING COUNT(*) &gt; 1) OR NOT EXISTS (SELECT * FROM @SelectedCheckCommands) OR (EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand IN('CHECKDB')) AND EXISTS (SELECT CheckCommand FROM @SelectedCheckCommands WHERE CheckCommand IN('CHECKFILEGROUP','CHECKALLOC','CHECKTABLE','CHECKCATALOG'))) OR (EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand IN('CHECKFILEGROUP')) AND EXISTS (SELECT CheckCommand FROM @SelectedCheckCommands WHERE CheckCommand IN('CHECKALLOC','CHECKTABLE')))
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @CheckCommands is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @PhysicalOnly NOT IN ('Y','N') OR @PhysicalOnly IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @PhysicalOnly is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @NoIndex NOT IN ('Y','N') OR @NoIndex IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @NoIndex is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @ExtendedLogicalChecks NOT IN ('Y','N') OR @ExtendedLogicalChecks IS NULL OR (@ExtendedLogicalChecks = 'Y' AND NOT @Version &gt;= 10) OR (@PhysicalOnly = 'Y' AND @ExtendedLogicalChecks = 'Y')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @ExtendedLogicalChecks is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @TabLock NOT IN ('Y','N') OR @TabLock IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @TabLock is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF EXISTS(SELECT * FROM @SelectedFileGroups WHERE DatabaseName IS NULL OR FileGroupName IS NULL) OR (@FileGroups IS NOT NULL AND NOT EXISTS(SELECT * FROM @SelectedFileGroups)) OR (@FileGroups IS NOT NULL AND NOT EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKFILEGROUP'))
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @FileGroups is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF EXISTS(SELECT * FROM @SelectedObjects WHERE DatabaseName IS NULL OR SchemaName IS NULL OR ObjectName IS NULL) OR (@Objects IS NOT NULL AND NOT EXISTS(SELECT * FROM @SelectedObjects)) OR (@Objects IS NOT NULL AND NOT EXISTS (SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKTABLE'))
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Objects is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LockTimeout &lt; 0
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @LockTimeout is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LogToTable NOT IN('Y','N') OR @LogToTable IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @LogToTable is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Execute NOT IN('Y','N') OR @Execute IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Execute is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Error &lt;&gt; 0
  BEGIN
    SET @ErrorMessage = 'The documentation is available at http://ola.hallengren.com/sql-server-integrity-check.html.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @ReturnCode = @Error
    GOTO Logging
  END

  ----------------------------------------------------------------------------------------------------
  --// Check Availability Group cluster name                                                      //--
  ----------------------------------------------------------------------------------------------------

  IF @Version &gt;= 11
  BEGIN
    SELECT @Cluster = cluster_name
    FROM sys.dm_hadr_cluster
  END

  ----------------------------------------------------------------------------------------------------
  --// Execute commands                                                                           //--
  ----------------------------------------------------------------------------------------------------

  WHILE EXISTS (SELECT * FROM @tmpDatabases WHERE Selected = 1 AND Completed = 0)
  BEGIN

    SELECT TOP 1 @CurrentDBID = ID,
                 @CurrentDatabaseName = DatabaseName
    FROM @tmpDatabases
    WHERE Selected = 1
    AND Completed = 0
    ORDER BY ID ASC

    SET @CurrentDatabaseID = DB_ID(@CurrentDatabaseName)

    IF DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') = 'ONLINE'
    BEGIN
      IF EXISTS (SELECT * FROM sys.database_recovery_status WHERE database_id = @CurrentDatabaseID AND database_guid IS NOT NULL)
      BEGIN
        SET @CurrentIsDatabaseAccessible = 1
      END
      ELSE
      BEGIN
        SET @CurrentIsDatabaseAccessible = 0
      END
    END
    ELSE
    BEGIN
      SET @CurrentIsDatabaseAccessible = 0
    END

    IF @Version &gt;= 11 AND @Cluster IS NOT NULL
    BEGIN
      SELECT @CurrentAvailabilityGroup = availability_groups.name,
             @CurrentAvailabilityGroupRole = dm_hadr_availability_replica_states.role_desc
      FROM sys.databases databases
      INNER JOIN sys.availability_databases_cluster availability_databases_cluster ON databases.group_database_id = availability_databases_cluster.group_database_id
      INNER JOIN sys.availability_groups availability_groups ON availability_databases_cluster.group_id = availability_groups.group_id
      INNER JOIN sys.dm_hadr_availability_replica_states dm_hadr_availability_replica_states ON availability_groups.group_id = dm_hadr_availability_replica_states.group_id AND databases.replica_id = dm_hadr_availability_replica_states.replica_id
      WHERE databases.name = @CurrentDatabaseName
    END

    SELECT @CurrentDatabaseMirroringRole = UPPER(mirroring_role_desc)
    FROM sys.database_mirroring
    WHERE database_id = @CurrentDatabaseID

    IF @AmazonRDS = 0
    BEGIN
      IF EXISTS (SELECT * FROM msdb.dbo.log_shipping_primary_databases WHERE primary_database = @CurrentDatabaseName)
      BEGIN
        SET @CurrentLogShippingRole = 'PRIMARY'
      END
      ELSE
      IF EXISTS (SELECT * FROM msdb.dbo.log_shipping_secondary_databases WHERE secondary_database = @CurrentDatabaseName)
      BEGIN
        SET @CurrentLogShippingRole = 'SECONDARY'
      END
    END

    -- Set database message
    SET @DatabaseMessage = 'Date and time: ' + CONVERT(nvarchar,GETDATE(),120) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Database: ' + QUOTENAME(@CurrentDatabaseName) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Status: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') AS nvarchar) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Standby: ' + CASE WHEN DATABASEPROPERTYEX(@CurrentDatabaseName,'IsInStandBy') = 1 THEN 'Yes' ELSE 'No' END + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Updateability: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'Updateability') AS nvarchar) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'User access: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'UserAccess') AS nvarchar) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Is accessible: ' + CASE WHEN @CurrentIsDatabaseAccessible = 1 THEN 'Yes' ELSE 'No' END + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Recovery model: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'Recovery') AS nvarchar) + CHAR(13) + CHAR(10)
    IF @CurrentAvailabilityGroup IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Availability group: ' + @CurrentAvailabilityGroup + CHAR(13) + CHAR(10)
    IF @CurrentAvailabilityGroup IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Availability group role: ' + @CurrentAvailabilityGroupRole + CHAR(13) + CHAR(10)
    IF @CurrentDatabaseMirroringRole IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Database mirroring role: ' + @CurrentDatabaseMirroringRole + CHAR(13) + CHAR(10)
    IF @CurrentLogShippingRole IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Log shipping role: ' + @CurrentLogShippingRole + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = REPLACE(@DatabaseMessage,'%','%%') + ' '
    RAISERROR(@DatabaseMessage,10,1) WITH NOWAIT

    IF DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') = 'ONLINE'
    AND NOT (DATABASEPROPERTYEX(@CurrentDatabaseName,'UserAccess') = 'SINGLE_USER' AND @CurrentIsDatabaseAccessible = 0)
    BEGIN

      -- Check database
      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKDB')
      BEGIN
        SET @CurrentCommandType01 = 'DBCC_CHECKDB'

        SET @CurrentCommand01 = ''
        IF @LockTimeout IS NOT NULL SET @CurrentCommand01 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
        SET @CurrentCommand01 = @CurrentCommand01 + 'DBCC CHECKDB (' + QUOTENAME(@CurrentDatabaseName)
        IF @NoIndex = 'Y' SET @CurrentCommand01 = @CurrentCommand01 + ', NOINDEX'
        SET @CurrentCommand01 = @CurrentCommand01 + ') WITH NO_INFOMSGS, ALL_ERRORMSGS'
        IF @PhysicalOnly = 'N' SET @CurrentCommand01 = @CurrentCommand01 + ', DATA_PURITY'
        IF @PhysicalOnly = 'Y' SET @CurrentCommand01 = @CurrentCommand01 + ', PHYSICAL_ONLY'
        IF @ExtendedLogicalChecks = 'Y' SET @CurrentCommand01 = @CurrentCommand01 + ', EXTENDED_LOGICAL_CHECKS'
        IF @TabLock = 'Y' SET @CurrentCommand01 = @CurrentCommand01 + ', TABLOCK'

        EXECUTE @CurrentCommandOutput01 = [dbo].[CommandExecute] @Command = @CurrentCommand01, @CommandType = @CurrentCommandType01, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute
        SET @Error = @@ERROR
        IF @Error &lt;&gt; 0 SET @CurrentCommandOutput01 = @Error
        IF @CurrentCommandOutput01 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput01
      END

      -- Check filegroups
      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKFILEGROUP')
      BEGIN
        SET @CurrentCommand02 = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SELECT data_space_id AS FileGroupID, name AS FileGroupName, 0 AS Selected, 0 AS Completed FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.filegroups filegroups ORDER BY CASE WHEN filegroups.name = ''PRIMARY'' THEN 1 ELSE 0 END DESC, filegroups.name ASC'

        INSERT INTO @tmpFileGroups (FileGroupID, FileGroupName, Selected, Completed)
        EXECUTE sp_executesql @statement = @CurrentCommand02
        SET @Error = @@ERROR
        IF @Error &lt;&gt; 0 SET @ReturnCode = @Error

        IF @FileGroups IS NULL
        BEGIN
          UPDATE tmpFileGroups
          SET tmpFileGroups.Selected = 1
          FROM @tmpFileGroups tmpFileGroups
        END
        ELSE
        BEGIN
          UPDATE tmpFileGroups
          SET tmpFileGroups.Selected = SelectedFileGroups.Selected
          FROM @tmpFileGroups tmpFileGroups
          INNER JOIN @SelectedFileGroups SelectedFileGroups
          ON @CurrentDatabaseName LIKE REPLACE(SelectedFileGroups.DatabaseName,'_','[_]') AND tmpFileGroups.FileGroupName LIKE REPLACE(SelectedFileGroups.FileGroupName,'_','[_]')
          WHERE SelectedFileGroups.Selected = 1

          UPDATE tmpFileGroups
          SET tmpFileGroups.Selected = SelectedFileGroups.Selected
          FROM @tmpFileGroups tmpFileGroups
          INNER JOIN @SelectedFileGroups SelectedFileGroups
          ON @CurrentDatabaseName LIKE REPLACE(SelectedFileGroups.DatabaseName,'_','[_]') AND tmpFileGroups.FileGroupName LIKE REPLACE(SelectedFileGroups.FileGroupName,'_','[_]')
          WHERE SelectedFileGroups.Selected = 0
        END

        WHILE EXISTS (SELECT * FROM @tmpFileGroups WHERE Selected = 1 AND Completed = 0)
        BEGIN
          SELECT TOP 1 @CurrentFGID = ID,
                       @CurrentFileGroupID = FileGroupID,
                       @CurrentFileGroupName = FileGroupName
          FROM @tmpFileGroups
          WHERE Selected = 1
          AND Completed = 0
          ORDER BY ID ASC

          -- Does the filegroup exist?
          SET @CurrentCommand03 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand03 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand03 = @CurrentCommand03 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.filegroups filegroups WHERE filegroups.data_space_id = @ParamFileGroupID AND filegroups.[name] = @ParamFileGroupName) BEGIN SET @ParamFileGroupExists = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand03, @params = N'@ParamFileGroupID int, @ParamFileGroupName sysname, @ParamFileGroupExists bit OUTPUT', @ParamFileGroupID = @CurrentFileGroupID, @ParamFileGroupName = @CurrentFileGroupName, @ParamFileGroupExists = @CurrentFileGroupExists OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentFileGroupExists IS NULL SET @CurrentFileGroupExists = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The file group ' + QUOTENAME(@CurrentFileGroupName) + ' in the database ' + QUOTENAME(@CurrentDatabaseName) + ' is locked. It could not be checked if the filegroup exists.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
          END

          IF @CurrentFileGroupExists = 1
          BEGIN
            SET @CurrentCommandType04 = 'DBCC_CHECKFILEGROUP'

            SET @CurrentCommand04 = ''
            IF @LockTimeout IS NOT NULL SET @CurrentCommand04 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
            SET @CurrentCommand04 = @CurrentCommand04 + 'USE ' + QUOTENAME(@CurrentDatabaseName) + '; DBCC CHECKFILEGROUP (' + QUOTENAME(@CurrentFileGroupName)
            IF @NoIndex = 'Y' SET @CurrentCommand04 = @CurrentCommand04 + ', NOINDEX'
            SET @CurrentCommand04 = @CurrentCommand04 + ') WITH NO_INFOMSGS, ALL_ERRORMSGS'
            IF @PhysicalOnly = 'Y' SET @CurrentCommand04 = @CurrentCommand04 + ', PHYSICAL_ONLY'
            IF @TabLock = 'Y' SET @CurrentCommand04 = @CurrentCommand04 + ', TABLOCK'

            EXECUTE @CurrentCommandOutput04 = [dbo].[CommandExecute] @Command = @CurrentCommand04, @CommandType = @CurrentCommandType04, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute
            SET @Error = @@ERROR
            IF @Error &lt;&gt; 0 SET @CurrentCommandOutput04 = @Error
            IF @CurrentCommandOutput04 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput04
          END

          UPDATE @tmpFileGroups
          SET Completed = 1
          WHERE Selected = 1
          AND Completed = 0
          AND ID = @CurrentFGID

          SET @CurrentFGID = NULL
          SET @CurrentFileGroupID = NULL
          SET @CurrentFileGroupName = NULL
          SET @CurrentFileGroupExists = NULL

          SET @CurrentCommand03 = NULL
          SET @CurrentCommand04 = NULL

          SET @CurrentCommandOutput04 = NULL

          SET @CurrentCommandType04 = NULL
        END
      END

      -- Check disk space allocation structures
      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKALLOC')
      BEGIN
        SET @CurrentCommandType05 = 'DBCC_CHECKALLOC'

        SET @CurrentCommand05 = ''
        IF @LockTimeout IS NOT NULL SET @CurrentCommand05 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
        SET @CurrentCommand05 = @CurrentCommand05 + 'DBCC CHECKALLOC (' + QUOTENAME(@CurrentDatabaseName)
        SET @CurrentCommand05 = @CurrentCommand05 + ') WITH NO_INFOMSGS, ALL_ERRORMSGS'
        IF @TabLock = 'Y' SET @CurrentCommand05 = @CurrentCommand05 + ', TABLOCK'

        EXECUTE @CurrentCommandOutput05 = [dbo].[CommandExecute] @Command = @CurrentCommand05, @CommandType = @CurrentCommandType05, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute
        SET @Error = @@ERROR
        IF @Error &lt;&gt; 0 SET @CurrentCommandOutput05 = @Error
        IF @CurrentCommandOutput05 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput05
      END

      -- Check objects
      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKTABLE')
      BEGIN
        SET @CurrentCommand06 = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SELECT schemas.[schema_id] AS SchemaID, schemas.[name] AS SchemaName, objects.[object_id] AS ObjectID, objects.[name] AS ObjectName, RTRIM(objects.[type]) AS ObjectType, 0 AS Selected, 0 AS Completed FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.objects objects INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.schemas schemas ON objects.schema_id = schemas.schema_id WHERE objects.[type] IN(''U'',''V'') AND EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes WHERE indexes.object_id = objects.object_id) ORDER BY schemas.name ASC, objects.name ASC'

        INSERT INTO @tmpObjects (SchemaID, SchemaName, ObjectID, ObjectName, ObjectType, Selected, Completed)
        EXECUTE sp_executesql @statement = @CurrentCommand06
        SET @Error = @@ERROR
        IF @Error &lt;&gt; 0 SET @ReturnCode = @Error

        IF @Objects IS NULL
        BEGIN
          UPDATE tmpObjects
          SET tmpObjects.Selected = 1
          FROM @tmpObjects tmpObjects
        END
        ELSE
        BEGIN
          UPDATE tmpObjects
          SET tmpObjects.Selected = SelectedObjects.Selected
          FROM @tmpObjects tmpObjects
          INNER JOIN @SelectedObjects SelectedObjects
          ON @CurrentDatabaseName LIKE REPLACE(SelectedObjects.DatabaseName,'_','[_]') AND tmpObjects.SchemaName LIKE REPLACE(SelectedObjects.SchemaName,'_','[_]') AND tmpObjects.ObjectName LIKE REPLACE(SelectedObjects.ObjectName,'_','[_]')
          WHERE SelectedObjects.Selected = 1

          UPDATE tmpObjects
          SET tmpObjects.Selected = SelectedObjects.Selected
          FROM @tmpObjects tmpObjects
          INNER JOIN @SelectedObjects SelectedObjects
          ON @CurrentDatabaseName LIKE REPLACE(SelectedObjects.DatabaseName,'_','[_]') AND tmpObjects.SchemaName LIKE REPLACE(SelectedObjects.SchemaName,'_','[_]') AND tmpObjects.ObjectName LIKE REPLACE(SelectedObjects.ObjectName,'_','[_]')
          WHERE SelectedObjects.Selected = 0
        END

        WHILE EXISTS (SELECT * FROM @tmpObjects WHERE Selected = 1 AND Completed = 0)
        BEGIN
          SELECT TOP 1 @CurrentOID = ID,
                       @CurrentSchemaID = SchemaID,
                       @CurrentSchemaName = SchemaName,
                       @CurrentObjectID = ObjectID,
                       @CurrentObjectName = ObjectName,
                       @CurrentObjectType = ObjectType
          FROM @tmpObjects
          WHERE Selected = 1
          AND Completed = 0
          ORDER BY ID ASC

          -- Does the object exist?
          SET @CurrentCommand07 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand07 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand07 = @CurrentCommand07 + 'IF EXISTS(SELECT schemas.[schema_id] AS SchemaID, schemas.[name] AS SchemaName, objects.[object_id] AS ObjectID, objects.[name] AS ObjectName, RTRIM(objects.[type]) AS ObjectType, 0 AS Selected, 0 AS Completed FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.objects objects INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.schemas schemas ON objects.schema_id = schemas.schema_id WHERE objects.[type] IN(''U'',''V'') AND EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes WHERE indexes.object_id = objects.object_id) AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType) BEGIN SET @ParamObjectExists = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand07, @params = N'@ParamSchemaID int, @ParamSchemaName sysname, @ParamObjectID int, @ParamObjectName sysname, @ParamObjectType sysname, @ParamObjectExists bit OUTPUT', @ParamSchemaID = @CurrentSchemaID, @ParamSchemaName = @CurrentSchemaName, @ParamObjectID = @CurrentObjectID, @ParamObjectName = @CurrentObjectName, @ParamObjectType = @CurrentObjectType, @ParamObjectExists = @CurrentObjectExists OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentObjectExists IS NULL SET @CurrentObjectExists = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the object exists.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
          END

          IF @CurrentObjectExists = 1
          BEGIN
            SET @CurrentCommandType08 = 'DBCC_CHECKTABLE'

            SET @CurrentCommand08 = ''
            IF @LockTimeout IS NOT NULL SET @CurrentCommand08 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
            SET @CurrentCommand08 = @CurrentCommand08 + 'DBCC CHECKTABLE (''' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ''''
            IF @NoIndex = 'Y' SET @CurrentCommand08 = @CurrentCommand08 + ', NOINDEX'
            SET @CurrentCommand08 = @CurrentCommand08 + ') WITH NO_INFOMSGS, ALL_ERRORMSGS'
            IF @PhysicalOnly = 'N' SET @CurrentCommand08 = @CurrentCommand08 + ', DATA_PURITY'
            IF @PhysicalOnly = 'Y' SET @CurrentCommand08 = @CurrentCommand08 + ', PHYSICAL_ONLY'
            IF @ExtendedLogicalChecks = 'Y' SET @CurrentCommand08 = @CurrentCommand08 + ', EXTENDED_LOGICAL_CHECKS'
            IF @TabLock = 'Y' SET @CurrentCommand08 = @CurrentCommand08 + ', TABLOCK'

            EXECUTE @CurrentCommandOutput08 = [dbo].[CommandExecute] @Command = @CurrentCommand08, @CommandType = @CurrentCommandType08, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @SchemaName = @CurrentSchemaName, @ObjectName = @CurrentObjectName, @ObjectType = @CurrentObjectType, @LogToTable = @LogToTable, @Execute = @Execute
            SET @Error = @@ERROR
            IF @Error &lt;&gt; 0 SET @CurrentCommandOutput08 = @Error
            IF @CurrentCommandOutput08 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput08
          END

          UPDATE @tmpObjects
          SET Completed = 1
          WHERE Selected = 1
          AND Completed = 0
          AND ID = @CurrentOID

          SET @CurrentOID = NULL
          SET @CurrentSchemaID = NULL
          SET @CurrentSchemaName = NULL
          SET @CurrentObjectID = NULL
          SET @CurrentObjectName = NULL
          SET @CurrentObjectType = NULL
          SET @CurrentObjectExists = NULL

          SET @CurrentCommand07 = NULL
          SET @CurrentCommand08 = NULL

          SET @CurrentCommandOutput08 = NULL

          SET @CurrentCommandType08 = NULL
        END
      END

      -- Check catalog
      IF EXISTS(SELECT * FROM @SelectedCheckCommands WHERE CheckCommand = 'CHECKCATALOG')
      BEGIN
        SET @CurrentCommandType09 = 'DBCC_CHECKCATALOG'

        SET @CurrentCommand09 = ''
        IF @LockTimeout IS NOT NULL SET @CurrentCommand09 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
        SET @CurrentCommand09 = @CurrentCommand09 + 'DBCC CHECKCATALOG (' + QUOTENAME(@CurrentDatabaseName)
        SET @CurrentCommand09 = @CurrentCommand09 + ') WITH NO_INFOMSGS'

        EXECUTE @CurrentCommandOutput09 = [dbo].[CommandExecute] @Command = @CurrentCommand09, @CommandType = @CurrentCommandType09, @Mode = 1, @DatabaseName = @CurrentDatabaseName, @LogToTable = @LogToTable, @Execute = @Execute
        SET @Error = @@ERROR
        IF @Error &lt;&gt; 0 SET @CurrentCommandOutput09 = @Error
        IF @CurrentCommandOutput09 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput09
      END

    END

    -- Update that the database is completed
    UPDATE @tmpDatabases
    SET Completed = 1
    WHERE Selected = 1
    AND Completed = 0
    AND ID = @CurrentDBID

    -- Clear variables
    SET @CurrentDBID = NULL
    SET @CurrentDatabaseID = NULL
    SET @CurrentDatabaseName = NULL
    SET @CurrentIsDatabaseAccessible = NULL
    SET @CurrentAvailabilityGroup = NULL
    SET @CurrentAvailabilityGroupRole = NULL
    SET @CurrentDatabaseMirroringRole = NULL
    SET @CurrentLogShippingRole = NULL

    SET @CurrentCommand01 = NULL
    SET @CurrentCommand02 = NULL
    SET @CurrentCommand05 = NULL
    SET @CurrentCommand06 = NULL
    SET @CurrentCommand09 = NULL

    SET @CurrentCommandOutput01 = NULL
    SET @CurrentCommandOutput05 = NULL
    SET @CurrentCommandOutput09 = NULL

    SET @CurrentCommandType01 = NULL
    SET @CurrentCommandType05 = NULL
    SET @CurrentCommandType09 = NULL

    DELETE FROM @tmpFileGroups
    DELETE FROM @tmpObjects

  END

  ----------------------------------------------------------------------------------------------------
  --// Log completing information                                                                 //--
  ----------------------------------------------------------------------------------------------------

  Logging:
  SET @EndMessage = 'Date and time: ' + CONVERT(nvarchar,GETDATE(),120)
  SET @EndMessage = REPLACE(@EndMessage,'%','%%')
  RAISERROR(@EndMessage,10,1) WITH NOWAIT

  IF @ReturnCode &lt;&gt; 0
  BEGIN
    RETURN @ReturnCode
  END

  ----------------------------------------------------------------------------------------------------

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[IndexOptimize]

@Databases nvarchar(max),
@FragmentationLow nvarchar(max) = NULL,
@FragmentationMedium nvarchar(max) = 'INDEX_REORGANIZE,INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE',
@FragmentationHigh nvarchar(max) = 'INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE',
@FragmentationLevel1 int = 5,
@FragmentationLevel2 int = 30,
@PageCountLevel int = 1000,
@SortInTempdb nvarchar(max) = 'N',
@MaxDOP int = NULL,
@FillFactor int = NULL,
@PadIndex nvarchar(max) = NULL,
@LOBCompaction nvarchar(max) = 'Y',
@UpdateStatistics nvarchar(max) = NULL,
@OnlyModifiedStatistics nvarchar(max) = 'N',
@StatisticsSample int = NULL,
@StatisticsResample nvarchar(max) = 'N',
@PartitionLevel nvarchar(max) = 'Y',
@MSShippedObjects nvarchar(max) = 'N',
@Indexes nvarchar(max) = NULL,
@TimeLimit int = NULL,
@Delay int = NULL,
@LockTimeout int = NULL,
@LogToTable nvarchar(max) = 'N',
@Execute nvarchar(max) = 'Y'

AS

BEGIN

  ----------------------------------------------------------------------------------------------------
  --// Source: http://ola.hallengren.com                                                          //--
  ----------------------------------------------------------------------------------------------------

  SET NOCOUNT ON

  SET ARITHABORT ON

  SET NUMERIC_ROUNDABORT OFF

  DECLARE @StartMessage nvarchar(max)
  DECLARE @EndMessage nvarchar(max)
  DECLARE @DatabaseMessage nvarchar(max)
  DECLARE @ErrorMessage nvarchar(max)

  DECLARE @Version numeric(18,10)
  DECLARE @AmazonRDS bit

  DECLARE @Cluster nvarchar(max)

  DECLARE @StartTime datetime

  DECLARE @CurrentDBID int
  DECLARE @CurrentDatabaseID int
  DECLARE @CurrentDatabaseName nvarchar(max)
  DECLARE @CurrentIsDatabaseAccessible bit
  DECLARE @CurrentAvailabilityGroup nvarchar(max)
  DECLARE @CurrentAvailabilityGroupRole nvarchar(max)
  DECLARE @CurrentDatabaseMirroringRole nvarchar(max)
  DECLARE @CurrentLogShippingRole nvarchar(max)

  DECLARE @CurrentCommand01 nvarchar(max)
  DECLARE @CurrentCommand02 nvarchar(max)
  DECLARE @CurrentCommand03 nvarchar(max)
  DECLARE @CurrentCommand04 nvarchar(max)
  DECLARE @CurrentCommand05 nvarchar(max)
  DECLARE @CurrentCommand06 nvarchar(max)
  DECLARE @CurrentCommand07 nvarchar(max)
  DECLARE @CurrentCommand08 nvarchar(max)
  DECLARE @CurrentCommand09 nvarchar(max)
  DECLARE @CurrentCommand10 nvarchar(max)
  DECLARE @CurrentCommand11 nvarchar(max)
  DECLARE @CurrentCommand12 nvarchar(max)
  DECLARE @CurrentCommand13 nvarchar(max)
  DECLARE @CurrentCommand14 nvarchar(max)

  DECLARE @CurrentCommandOutput13 int
  DECLARE @CurrentCommandOutput14 int

  DECLARE @CurrentCommandType13 nvarchar(max)
  DECLARE @CurrentCommandType14 nvarchar(max)

  DECLARE @CurrentIxID int
  DECLARE @CurrentSchemaID int
  DECLARE @CurrentSchemaName nvarchar(max)
  DECLARE @CurrentObjectID int
  DECLARE @CurrentObjectName nvarchar(max)
  DECLARE @CurrentObjectType nvarchar(max)
  DECLARE @CurrentIndexID int
  DECLARE @CurrentIndexName nvarchar(max)
  DECLARE @CurrentIndexType int
  DECLARE @CurrentStatisticsID int
  DECLARE @CurrentStatisticsName nvarchar(max)
  DECLARE @CurrentPartitionID bigint
  DECLARE @CurrentPartitionNumber int
  DECLARE @CurrentPartitionCount int
  DECLARE @CurrentIsPartition bit
  DECLARE @CurrentIndexExists bit
  DECLARE @CurrentStatisticsExists bit
  DECLARE @CurrentIsImageText bit
  DECLARE @CurrentIsNewLOB bit
  DECLARE @CurrentIsFileStream bit
  DECLARE @CurrentIsColumnStore bit
  DECLARE @CurrentAllowPageLocks bit
  DECLARE @CurrentNoRecompute bit
  DECLARE @CurrentStatisticsModified bit
  DECLARE @CurrentOnReadOnlyFileGroup bit
  DECLARE @CurrentFragmentationLevel float
  DECLARE @CurrentPageCount bigint
  DECLARE @CurrentFragmentationGroup nvarchar(max)
  DECLARE @CurrentAction nvarchar(max)
  DECLARE @CurrentMaxDOP int
  DECLARE @CurrentUpdateStatistics nvarchar(max)
  DECLARE @CurrentComment nvarchar(max)
  DECLARE @CurrentExtendedInfo xml
  DECLARE @CurrentDelay datetime

  DECLARE @tmpDatabases TABLE (ID int IDENTITY,
                               DatabaseName nvarchar(max),
                               DatabaseType nvarchar(max),
                               Selected bit,
                               Completed bit,
                               PRIMARY KEY(Selected, Completed, ID))

  DECLARE @tmpIndexesStatistics TABLE (ID int IDENTITY,
                                       SchemaID int,
                                       SchemaName nvarchar(max),
                                       ObjectID int,
                                       ObjectName nvarchar(max),
                                       ObjectType nvarchar(max),
                                       IndexID int,
                                       IndexName nvarchar(max),
                                       IndexType int,
                                       StatisticsID int,
                                       StatisticsName nvarchar(max),
                                       PartitionID bigint,
                                       PartitionNumber int,
                                       PartitionCount int,
                                       Selected bit,
                                       Completed bit,
                                       PRIMARY KEY(Selected, Completed, ID))

  DECLARE @SelectedDatabases TABLE (DatabaseName nvarchar(max),
                                    DatabaseType nvarchar(max),
                                    Selected bit)

  DECLARE @SelectedIndexes TABLE (DatabaseName nvarchar(max),
                                  SchemaName nvarchar(max),
                                  ObjectName nvarchar(max),
                                  IndexName nvarchar(max),
                                  Selected bit)

  DECLARE @Actions TABLE ([Action] nvarchar(max))

  INSERT INTO @Actions([Action]) VALUES('INDEX_REBUILD_ONLINE')
  INSERT INTO @Actions([Action]) VALUES('INDEX_REBUILD_OFFLINE')
  INSERT INTO @Actions([Action]) VALUES('INDEX_REORGANIZE')

  DECLARE @ActionsPreferred TABLE (FragmentationGroup nvarchar(max),
                                   [Priority] int,
                                   [Action] nvarchar(max))

  DECLARE @CurrentActionsAllowed TABLE ([Action] nvarchar(max))

  DECLARE @Error int
  DECLARE @ReturnCode int

  SET @Error = 0
  SET @ReturnCode = 0

  SET @Version = CAST(LEFT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)),CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - 1) + '.' + REPLACE(RIGHT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)), LEN(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)))),'.','') AS numeric(18,10))

  SET @AmazonRDS = CASE WHEN DB_ID('rdsadmin') IS NOT NULL AND SUSER_SNAME(0x01) = 'rdsa' THEN 1 ELSE 0 END

  ----------------------------------------------------------------------------------------------------
  --// Log initial information                                                                    //--
  ----------------------------------------------------------------------------------------------------

  SET @StartTime = CONVERT(datetime,CONVERT(nvarchar,GETDATE(),120),120)

  SET @StartMessage = 'Date and time: ' + CONVERT(nvarchar,@StartTime,120) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Server: ' + CAST(SERVERPROPERTY('ServerName') AS nvarchar) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Version: ' + CAST(SERVERPROPERTY('ProductVersion') AS nvarchar) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Edition: ' + CAST(SERVERPROPERTY('Edition') AS nvarchar) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Procedure: ' + QUOTENAME(DB_NAME(DB_ID())) + '.' + (SELECT QUOTENAME(schemas.name) FROM sys.schemas schemas INNER JOIN sys.objects objects ON schemas.[schema_id] = objects.[schema_id] WHERE [object_id] = @@PROCID) + '.' + QUOTENAME(OBJECT_NAME(@@PROCID)) + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Parameters: @Databases = ' + ISNULL('''' + REPLACE(@Databases,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @FragmentationLow = ' + ISNULL('''' + REPLACE(@FragmentationLow,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @FragmentationMedium = ' + ISNULL('''' + REPLACE(@FragmentationMedium,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @FragmentationHigh = ' + ISNULL('''' + REPLACE(@FragmentationHigh,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @FragmentationLevel1 = ' + ISNULL(CAST(@FragmentationLevel1 AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @FragmentationLevel2 = ' + ISNULL(CAST(@FragmentationLevel2 AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @PageCountLevel = ' + ISNULL(CAST(@PageCountLevel AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @SortInTempdb = ' + ISNULL('''' + REPLACE(@SortInTempdb,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @MaxDOP = ' + ISNULL(CAST(@MaxDOP AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @FillFactor = ' + ISNULL(CAST(@FillFactor AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @PadIndex = ' + ISNULL('''' + REPLACE(@PadIndex,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @LOBCompaction = ' + ISNULL('''' + REPLACE(@LOBCompaction,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @UpdateStatistics = ' + ISNULL('''' + REPLACE(@UpdateStatistics,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @OnlyModifiedStatistics = ' + ISNULL('''' + REPLACE(@OnlyModifiedStatistics,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @StatisticsSample = ' + ISNULL(CAST(@StatisticsSample AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @StatisticsResample = ' + ISNULL('''' + REPLACE(@StatisticsResample,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @PartitionLevel = ' + ISNULL('''' + REPLACE(@PartitionLevel,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @MSShippedObjects = ' + ISNULL('''' + REPLACE(@MSShippedObjects,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @Indexes = ' + ISNULL('''' + REPLACE(@Indexes,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @TimeLimit = ' + ISNULL(CAST(@TimeLimit AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @Delay = ' + ISNULL(CAST(@Delay AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @LockTimeout = ' + ISNULL(CAST(@LockTimeout AS nvarchar),'NULL')
  SET @StartMessage = @StartMessage + ', @LogToTable = ' + ISNULL('''' + REPLACE(@LogToTable,'''','''''') + '''','NULL')
  SET @StartMessage = @StartMessage + ', @Execute = ' + ISNULL('''' + REPLACE(@Execute,'''','''''') + '''','NULL') + CHAR(13) + CHAR(10)
  SET @StartMessage = @StartMessage + 'Source: http://ola.hallengren.com' + CHAR(13) + CHAR(10)
  SET @StartMessage = REPLACE(@StartMessage,'%','%%') + ' '
  RAISERROR(@StartMessage,10,1) WITH NOWAIT

  ----------------------------------------------------------------------------------------------------
  --// Check core requirements                                                                    //--
  ----------------------------------------------------------------------------------------------------

  IF NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute')
  BEGIN
    SET @ErrorMessage = 'The stored procedure CommandExecute is missing. Download http://ola.hallengren.com/scripts/CommandExecute.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute' AND (OBJECT_DEFINITION(objects.[object_id]) NOT LIKE '%@LogToTable%' OR OBJECT_DEFINITION(objects.[object_id]) LIKE '%LOCK_TIMEOUT%'))
  BEGIN
    SET @ErrorMessage = 'The stored procedure CommandExecute needs to be updated. Download http://ola.hallengren.com/scripts/CommandExecute.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LogToTable = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandLog')
  BEGIN
    SET @ErrorMessage = 'The table CommandLog is missing. Download http://ola.hallengren.com/scripts/CommandLog.sql.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Error &lt;&gt; 0
  BEGIN
    SET @ReturnCode = @Error
    GOTO Logging
  END

  ----------------------------------------------------------------------------------------------------
  --// Select databases                                                                           //--
  ----------------------------------------------------------------------------------------------------

  SET @Databases = REPLACE(@Databases, ', ', ',');

  WITH Databases1 (StartPosition, EndPosition, DatabaseItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Databases, 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, 1, ISNULL(NULLIF(CHARINDEX(',', @Databases, 1), 0), LEN(@Databases) + 1) - 1) AS DatabaseItem
  WHERE @Databases IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) - EndPosition - 1) AS DatabaseItem
  FROM Databases1
  WHERE EndPosition &lt; LEN(@Databases) + 1
  ),
  Databases2 (DatabaseItem, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem LIKE '-%' THEN RIGHT(DatabaseItem,LEN(DatabaseItem) - 1) ELSE DatabaseItem END AS DatabaseItem,
         CASE WHEN DatabaseItem LIKE '-%' THEN 0 ELSE 1 END AS Selected
  FROM Databases1
  ),
  Databases3 (DatabaseItem, DatabaseType, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem IN('ALL_DATABASES','SYSTEM_DATABASES','USER_DATABASES') THEN '%' ELSE DatabaseItem END AS DatabaseItem,
         CASE WHEN DatabaseItem = 'SYSTEM_DATABASES' THEN 'S' WHEN DatabaseItem = 'USER_DATABASES' THEN 'U' ELSE NULL END AS DatabaseType,
         Selected
  FROM Databases2
  ),
  Databases4 (DatabaseName, DatabaseType, Selected) AS
  (
  SELECT CASE WHEN LEFT(DatabaseItem,1) = '[' AND RIGHT(DatabaseItem,1) = ']' THEN PARSENAME(DatabaseItem,1) ELSE DatabaseItem END AS DatabaseItem,
         DatabaseType,
         Selected
  FROM Databases3
  )
  INSERT INTO @SelectedDatabases (DatabaseName, DatabaseType, Selected)
  SELECT DatabaseName,
         DatabaseType,
         Selected
  FROM Databases4
  OPTION (MAXRECURSION 0)

  INSERT INTO @tmpDatabases (DatabaseName, DatabaseType, Selected, Completed)
  SELECT [name] AS DatabaseName,
         CASE WHEN name IN('master','msdb','model') THEN 'S' ELSE 'U' END AS DatabaseType,
         0 AS Selected,
         0 AS Completed
  FROM sys.databases
  WHERE [name] &lt;&gt; 'tempdb'
  AND source_database_id IS NULL
  ORDER BY [name] ASC

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  WHERE SelectedDatabases.Selected = 1

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  WHERE SelectedDatabases.Selected = 0

  IF @Databases IS NULL OR NOT EXISTS(SELECT * FROM @SelectedDatabases) OR EXISTS(SELECT * FROM @SelectedDatabases WHERE DatabaseName IS NULL OR DatabaseName = '')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Databases is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  ----------------------------------------------------------------------------------------------------
  --// Select indexes                                                                             //--
  ----------------------------------------------------------------------------------------------------

  SET @Indexes = REPLACE(@Indexes, ', ', ',');

  WITH Indexes1 (StartPosition, EndPosition, IndexItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Indexes, 1), 0), LEN(@Indexes) + 1) AS EndPosition,
         SUBSTRING(@Indexes, 1, ISNULL(NULLIF(CHARINDEX(',', @Indexes, 1), 0), LEN(@Indexes) + 1) - 1) AS IndexItem
  WHERE @Indexes IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @Indexes, EndPosition + 1), 0), LEN(@Indexes) + 1) AS EndPosition,
         SUBSTRING(@Indexes, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @Indexes, EndPosition + 1), 0), LEN(@Indexes) + 1) - EndPosition - 1) AS IndexItem
  FROM Indexes1
  WHERE EndPosition &lt; LEN(@Indexes) + 1
  ),
  Indexes2 (IndexItem, Selected) AS
  (
  SELECT CASE WHEN IndexItem LIKE '-%' THEN RIGHT(IndexItem,LEN(IndexItem) - 1) ELSE IndexItem END AS IndexItem,
         CASE WHEN IndexItem LIKE '-%' THEN 0 ELSE 1 END AS Selected
  FROM Indexes1
  ),
  Indexes3 (IndexItem, Selected) AS
  (
  SELECT CASE WHEN IndexItem = 'ALL_INDEXES' THEN '%.%.%.%' ELSE IndexItem END AS IndexItem,
         Selected
  FROM Indexes2
  ),
  Indexes4 (DatabaseName, SchemaName, ObjectName, IndexName, Selected) AS
  (
  SELECT CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN PARSENAME(IndexItem,3) ELSE PARSENAME(IndexItem,4) END AS DatabaseName,
         CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN PARSENAME(IndexItem,2) ELSE PARSENAME(IndexItem,3) END AS SchemaName,
         CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN PARSENAME(IndexItem,1) ELSE PARSENAME(IndexItem,2) END AS ObjectName,
         CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN '%' ELSE PARSENAME(IndexItem,1) END AS IndexName,
         Selected
  FROM Indexes3
  )
  INSERT INTO @SelectedIndexes (DatabaseName, SchemaName, ObjectName, IndexName, Selected)
  SELECT DatabaseName, SchemaName, ObjectName, IndexName, Selected
  FROM Indexes4
  OPTION (MAXRECURSION 0);

  ----------------------------------------------------------------------------------------------------
  --// Select actions                                                                             //--
  ----------------------------------------------------------------------------------------------------

  WITH FragmentationLow (StartPosition, EndPosition, [Action]) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @FragmentationLow, 1), 0), LEN(@FragmentationLow) + 1) AS EndPosition,
         SUBSTRING(@FragmentationLow, 1, ISNULL(NULLIF(CHARINDEX(',', @FragmentationLow, 1), 0), LEN(@FragmentationLow) + 1) - 1) AS [Action]
  WHERE @FragmentationLow IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @FragmentationLow, EndPosition + 1), 0), LEN(@FragmentationLow) + 1) AS EndPosition,
         SUBSTRING(@FragmentationLow, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @FragmentationLow, EndPosition + 1), 0), LEN(@FragmentationLow) + 1) - EndPosition - 1) AS [Action]
  FROM FragmentationLow
  WHERE EndPosition &lt; LEN(@FragmentationLow) + 1
  )
  INSERT INTO @ActionsPreferred(FragmentationGroup, [Priority], [Action])
  SELECT 'Low' AS FragmentationGroup,
         ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS [Priority],
         [Action]
  FROM FragmentationLow
  OPTION (MAXRECURSION 0);

  WITH FragmentationMedium (StartPosition, EndPosition, [Action]) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @FragmentationMedium, 1), 0), LEN(@FragmentationMedium) + 1) AS EndPosition,
         SUBSTRING(@FragmentationMedium, 1, ISNULL(NULLIF(CHARINDEX(',', @FragmentationMedium, 1), 0), LEN(@FragmentationMedium) + 1) - 1) AS [Action]
  WHERE @FragmentationMedium IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @FragmentationMedium, EndPosition + 1), 0), LEN(@FragmentationMedium) + 1) AS EndPosition,
         SUBSTRING(@FragmentationMedium, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @FragmentationMedium, EndPosition + 1), 0), LEN(@FragmentationMedium) + 1) - EndPosition - 1) AS [Action]
  FROM FragmentationMedium
  WHERE EndPosition &lt; LEN(@FragmentationMedium) + 1
  )
  INSERT INTO @ActionsPreferred(FragmentationGroup, [Priority], [Action])
  SELECT 'Medium' AS FragmentationGroup,
         ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS [Priority],
         [Action]
  FROM FragmentationMedium
  OPTION (MAXRECURSION 0);

  WITH FragmentationHigh (StartPosition, EndPosition, [Action]) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @FragmentationHigh, 1), 0), LEN(@FragmentationHigh) + 1) AS EndPosition,
         SUBSTRING(@FragmentationHigh, 1, ISNULL(NULLIF(CHARINDEX(',', @FragmentationHigh, 1), 0), LEN(@FragmentationHigh) + 1) - 1) AS [Action]
  WHERE @FragmentationHigh IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(',', @FragmentationHigh, EndPosition + 1), 0), LEN(@FragmentationHigh) + 1) AS EndPosition,
         SUBSTRING(@FragmentationHigh, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(',', @FragmentationHigh, EndPosition + 1), 0), LEN(@FragmentationHigh) + 1) - EndPosition - 1) AS [Action]
  FROM FragmentationHigh
  WHERE EndPosition &lt; LEN(@FragmentationHigh) + 1
  )
  INSERT INTO @ActionsPreferred(FragmentationGroup, [Priority], [Action])
  SELECT 'High' AS FragmentationGroup,
         ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS [Priority],
         [Action]
  FROM FragmentationHigh
  OPTION (MAXRECURSION 0)

  ----------------------------------------------------------------------------------------------------
  --// Check input parameters                                                                     //--
  ----------------------------------------------------------------------------------------------------

  IF EXISTS (SELECT [Action] FROM @ActionsPreferred WHERE FragmentationGroup = 'Low' AND [Action] NOT IN(SELECT * FROM @Actions))
  OR EXISTS(SELECT * FROM @ActionsPreferred WHERE FragmentationGroup = 'Low' GROUP BY [Action] HAVING COUNT(*) &gt; 1)
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @FragmentationLow is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF EXISTS (SELECT [Action] FROM @ActionsPreferred WHERE FragmentationGroup = 'Medium' AND [Action] NOT IN(SELECT * FROM @Actions))
  OR EXISTS(SELECT * FROM @ActionsPreferred WHERE FragmentationGroup = 'Medium' GROUP BY [Action] HAVING COUNT(*) &gt; 1)
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @FragmentationMedium is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF EXISTS (SELECT [Action] FROM @ActionsPreferred WHERE FragmentationGroup = 'High' AND [Action] NOT IN(SELECT * FROM @Actions))
  OR EXISTS(SELECT * FROM @ActionsPreferred WHERE FragmentationGroup = 'High' GROUP BY [Action] HAVING COUNT(*) &gt; 1)
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @FragmentationHigh is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @FragmentationLevel1 &lt;= 0 OR @FragmentationLevel1 &gt;= 100 OR @FragmentationLevel1 &gt;= @FragmentationLevel2 OR @FragmentationLevel1 IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @FragmentationLevel1 is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @FragmentationLevel2 &lt;= 0 OR @FragmentationLevel2 &gt;= 100 OR @FragmentationLevel2 &lt;= @FragmentationLevel1 OR @FragmentationLevel2 IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @FragmentationLevel2 is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @PageCountLevel &lt; 0 OR @PageCountLevel IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @PageCountLevel is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @SortInTempdb NOT IN('Y','N') OR @SortInTempdb IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @SortInTempdb is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @MaxDOP &lt; 0 OR @MaxDOP &gt; 64 OR @MaxDOP &gt; (SELECT cpu_count FROM sys.dm_os_sys_info) OR (@MaxDOP &gt; 1 AND SERVERPROPERTY('EngineEdition') &lt;&gt; 3)
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @MaxDOP is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @FillFactor &lt;= 0 OR @FillFactor &gt; 100
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @FillFactor is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @PadIndex NOT IN('Y','N')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @PadIndex is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LOBCompaction NOT IN('Y','N') OR @LOBCompaction IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @LOBCompaction is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @UpdateStatistics NOT IN('ALL','COLUMNS','INDEX')
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @UpdateStatistics is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @OnlyModifiedStatistics NOT IN('Y','N') OR @OnlyModifiedStatistics IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @OnlyModifiedStatistics is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @StatisticsSample &lt;= 0 OR @StatisticsSample  &gt; 100
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @StatisticsSample is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @StatisticsResample NOT IN('Y','N') OR @StatisticsResample IS NULL OR (@StatisticsResample = 'Y' AND @StatisticsSample IS NOT NULL)
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @StatisticsResample is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @PartitionLevel NOT IN('Y','N') OR @PartitionLevel IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @PartitionLevel is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @MSShippedObjects NOT IN('Y','N') OR @MSShippedObjects IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @MSShippedObjects is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF EXISTS(SELECT * FROM @SelectedIndexes WHERE DatabaseName IS NULL OR SchemaName IS NULL OR ObjectName IS NULL OR IndexName IS NULL) OR (@Indexes IS NOT NULL AND NOT EXISTS(SELECT * FROM @SelectedIndexes))
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Indexes is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @TimeLimit &lt; 0
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @TimeLimit is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Delay &lt; 0
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Delay is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LockTimeout &lt; 0
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @LockTimeout is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @LogToTable NOT IN('Y','N') OR @LogToTable IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @LogToTable is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Execute NOT IN('Y','N') OR @Execute IS NULL
  BEGIN
    SET @ErrorMessage = 'The value for the parameter @Execute is not supported.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @Error = @@ERROR
  END

  IF @Error &lt;&gt; 0
  BEGIN
    SET @ErrorMessage = 'The documentation is available at http://ola.hallengren.com/sql-server-index-and-statistics-maintenance.html.' + CHAR(13) + CHAR(10) + ' '
    RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
    SET @ReturnCode = @Error
    GOTO Logging
  END

  ----------------------------------------------------------------------------------------------------
  --// Check Availability Group cluster name                                                      //--
  ----------------------------------------------------------------------------------------------------

  IF @Version &gt;= 11
  BEGIN
    SELECT @Cluster = cluster_name
    FROM sys.dm_hadr_cluster
  END

  ----------------------------------------------------------------------------------------------------
  --// Execute commands                                                                           //--
  ----------------------------------------------------------------------------------------------------

  WHILE EXISTS (SELECT * FROM @tmpDatabases WHERE Selected = 1 AND Completed = 0)
  BEGIN

    SELECT TOP 1 @CurrentDBID = ID,
                 @CurrentDatabaseName = DatabaseName
    FROM @tmpDatabases
    WHERE Selected = 1
    AND Completed = 0
    ORDER BY ID ASC

    SET @CurrentDatabaseID = DB_ID(@CurrentDatabaseName)

    IF DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') = 'ONLINE'
    BEGIN
      IF EXISTS (SELECT * FROM sys.database_recovery_status WHERE database_id = @CurrentDatabaseID AND database_guid IS NOT NULL)
      BEGIN
        SET @CurrentIsDatabaseAccessible = 1
      END
      ELSE
      BEGIN
        SET @CurrentIsDatabaseAccessible = 0
      END
    END
    ELSE
    BEGIN
      SET @CurrentIsDatabaseAccessible = 0
    END

    IF @Version &gt;= 11 AND @Cluster IS NOT NULL
    BEGIN
      SELECT @CurrentAvailabilityGroup = availability_groups.name,
             @CurrentAvailabilityGroupRole = dm_hadr_availability_replica_states.role_desc
      FROM sys.databases databases
      INNER JOIN sys.availability_databases_cluster availability_databases_cluster ON databases.group_database_id = availability_databases_cluster.group_database_id
      INNER JOIN sys.availability_groups availability_groups ON availability_databases_cluster.group_id = availability_groups.group_id
      INNER JOIN sys.dm_hadr_availability_replica_states dm_hadr_availability_replica_states ON availability_groups.group_id = dm_hadr_availability_replica_states.group_id AND databases.replica_id = dm_hadr_availability_replica_states.replica_id
      WHERE databases.name = @CurrentDatabaseName
    END

    SELECT @CurrentDatabaseMirroringRole = UPPER(mirroring_role_desc)
    FROM sys.database_mirroring
    WHERE database_id = @CurrentDatabaseID

    IF @AmazonRDS = 0
    BEGIN
      IF EXISTS (SELECT * FROM msdb.dbo.log_shipping_primary_databases WHERE primary_database = @CurrentDatabaseName)
      BEGIN
        SET @CurrentLogShippingRole = 'PRIMARY'
      END
      ELSE
      IF EXISTS (SELECT * FROM msdb.dbo.log_shipping_secondary_databases WHERE secondary_database = @CurrentDatabaseName)
      BEGIN
        SET @CurrentLogShippingRole = 'SECONDARY'
      END
    END

    -- Set database message
    SET @DatabaseMessage = 'Date and time: ' + CONVERT(nvarchar,GETDATE(),120) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Database: ' + QUOTENAME(@CurrentDatabaseName) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Status: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') AS nvarchar) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Standby: ' + CASE WHEN DATABASEPROPERTYEX(@CurrentDatabaseName,'IsInStandBy') = 1 THEN 'Yes' ELSE 'No' END + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Updateability: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'Updateability') AS nvarchar) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'User access: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'UserAccess') AS nvarchar) + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Is accessible: ' + CASE WHEN @CurrentIsDatabaseAccessible = 1 THEN 'Yes' ELSE 'No' END + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = @DatabaseMessage + 'Recovery model: ' + CAST(DATABASEPROPERTYEX(@CurrentDatabaseName,'Recovery') AS nvarchar) + CHAR(13) + CHAR(10)
    IF @CurrentAvailabilityGroup IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Availability group: ' + @CurrentAvailabilityGroup + CHAR(13) + CHAR(10)
    IF @CurrentAvailabilityGroup IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Availability group role: ' + @CurrentAvailabilityGroupRole + CHAR(13) + CHAR(10)
    IF @CurrentDatabaseMirroringRole IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Database mirroring role: ' + @CurrentDatabaseMirroringRole + CHAR(13) + CHAR(10)
    IF @CurrentLogShippingRole IS NOT NULL SET @DatabaseMessage = @DatabaseMessage + 'Log shipping role: ' + @CurrentLogShippingRole + CHAR(13) + CHAR(10)
    SET @DatabaseMessage = REPLACE(@DatabaseMessage,'%','%%') + ' '
    RAISERROR(@DatabaseMessage,10,1) WITH NOWAIT

    IF DATABASEPROPERTYEX(@CurrentDatabaseName,'Status') = 'ONLINE'
    AND NOT (DATABASEPROPERTYEX(@CurrentDatabaseName,'UserAccess') = 'SINGLE_USER' AND @CurrentIsDatabaseAccessible = 0)
    AND DATABASEPROPERTYEX(@CurrentDatabaseName,'Updateability') = 'READ_WRITE'
    BEGIN

      -- Select indexes in the current database
      IF (EXISTS(SELECT * FROM @ActionsPreferred) OR @UpdateStatistics IS NOT NULL) AND (GETDATE() &lt; DATEADD(ss,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
      BEGIN
        SET @CurrentCommand01 = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SELECT SchemaID, SchemaName, ObjectID, ObjectName, ObjectType, IndexID, IndexName, IndexType, StatisticsID, StatisticsName, PartitionID, PartitionNumber, PartitionCount, Selected, Completed FROM ('

        IF EXISTS(SELECT * FROM @ActionsPreferred) OR @UpdateStatistics IN('ALL','INDEX')
        BEGIN
          SET @CurrentCommand01 = @CurrentCommand01 + 'SELECT schemas.[schema_id] AS SchemaID, schemas.[name] AS SchemaName, objects.[object_id] AS ObjectID, objects.[name] AS ObjectName, RTRIM(objects.[type]) AS ObjectType, indexes.index_id AS IndexID, indexes.[name] AS IndexName, indexes.[type] AS IndexType, stats.stats_id AS StatisticsID, stats.name AS StatisticsName'
          IF @PartitionLevel = 'Y' SET @CurrentCommand01 = @CurrentCommand01 + ', partitions.partition_id AS PartitionID, partitions.partition_number AS PartitionNumber, IndexPartitions.partition_count AS PartitionCount'
          IF @PartitionLevel = 'N' SET @CurrentCommand01 = @CurrentCommand01 + ', NULL AS PartitionID, NULL AS PartitionNumber, NULL AS PartitionCount'
          SET @CurrentCommand01 = @CurrentCommand01 + ', 0 AS Selected, 0 AS Completed FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.objects objects ON indexes.[object_id] = objects.[object_id] INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] LEFT OUTER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.stats stats ON indexes.[object_id] = stats.[object_id] AND indexes.[index_id] = stats.[stats_id]'
          IF @PartitionLevel = 'Y' SET @CurrentCommand01 = @CurrentCommand01 + ' LEFT OUTER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.partitions partitions ON indexes.[object_id] = partitions.[object_id] AND indexes.index_id = partitions.index_id LEFT OUTER JOIN (SELECT partitions.[object_id], partitions.index_id, COUNT(*) AS partition_count FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.partitions partitions GROUP BY partitions.[object_id], partitions.index_id) IndexPartitions ON partitions.[object_id] = IndexPartitions.[object_id] AND partitions.[index_id] = IndexPartitions.[index_id]'
          IF @PartitionLevel = 'Y' SET @CurrentCommand01 = @CurrentCommand01 + ' LEFT OUTER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.dm_db_partition_stats dm_db_partition_stats ON indexes.[object_id] = dm_db_partition_stats.[object_id] AND indexes.[index_id] = dm_db_partition_stats.[index_id] AND partitions.partition_id = dm_db_partition_stats.partition_id'
          IF @PartitionLevel = 'N' SET @CurrentCommand01 = @CurrentCommand01 + ' LEFT OUTER JOIN (SELECT dm_db_partition_stats.[object_id], dm_db_partition_stats.[index_id], SUM(dm_db_partition_stats.in_row_data_page_count) AS in_row_data_page_count FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.dm_db_partition_stats dm_db_partition_stats GROUP BY dm_db_partition_stats.[object_id], dm_db_partition_stats.[index_id]) dm_db_partition_stats ON indexes.[object_id] = dm_db_partition_stats.[object_id] AND indexes.[index_id] = dm_db_partition_stats.[index_id]'
          SET @CurrentCommand01 = @CurrentCommand01 + ' WHERE objects.[type] IN(''U'',''V'')' + CASE WHEN @MSShippedObjects = 'N' THEN ' AND objects.is_ms_shipped = 0' ELSE '' END + ' AND indexes.[type] IN(1,2,3,4) AND indexes.is_disabled = 0 AND indexes.is_hypothetical = 0'
          IF (@UpdateStatistics NOT IN('ALL','INDEX') OR @UpdateStatistics IS NULL) AND @PageCountLevel &gt; 0 SET @CurrentCommand01 = @CurrentCommand01 + ' AND (dm_db_partition_stats.in_row_data_page_count &gt;= @ParamPageCountLevel OR dm_db_partition_stats.in_row_data_page_count IS NULL)'
          IF NOT EXISTS(SELECT * FROM @ActionsPreferred) SET @CurrentCommand01 = @CurrentCommand01 + ' AND stats.stats_id IS NOT NULL'
        END

        IF (EXISTS(SELECT * FROM @ActionsPreferred) AND @UpdateStatistics = 'COLUMNS') OR @UpdateStatistics = 'ALL' SET @CurrentCommand01 = @CurrentCommand01 + ' UNION '

        IF @UpdateStatistics IN('ALL','COLUMNS') SET @CurrentCommand01 = @CurrentCommand01 + 'SELECT schemas.[schema_id] AS SchemaID, schemas.[name] AS SchemaName, objects.[object_id] AS ObjectID, objects.[name] AS ObjectName, RTRIM(objects.[type]) AS ObjectType, NULL AS IndexID, NULL AS IndexName, NULL AS IndexType, stats.stats_id AS StatisticsID, stats.name AS StatisticsName, NULL AS PartitionID, NULL AS PartitionNumber, NULL AS PartitionCount, 0 AS Selected, 0 AS Completed FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.stats stats INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.objects objects ON stats.[object_id] = objects.[object_id] INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] IN(''U'',''V'')' + CASE WHEN @MSShippedObjects = 'N' THEN ' AND objects.is_ms_shipped = 0' ELSE '' END + ' AND NOT EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes WHERE indexes.[object_id] = stats.[object_id] AND indexes.index_id = stats.stats_id)'

        SET @CurrentCommand01 = @CurrentCommand01 + ') IndexesStatistics ORDER BY SchemaName ASC, ObjectName ASC'
        IF (EXISTS(SELECT * FROM @ActionsPreferred) AND @UpdateStatistics = 'COLUMNS') OR @UpdateStatistics = 'ALL' SET @CurrentCommand01 = @CurrentCommand01 + ', CASE WHEN IndexType IS NULL THEN 1 ELSE 0 END ASC'
        IF EXISTS(SELECT * FROM @ActionsPreferred) OR @UpdateStatistics IN('ALL','INDEX') SET @CurrentCommand01 = @CurrentCommand01 + ', IndexType ASC, IndexName ASC'
        IF @UpdateStatistics IN('ALL','COLUMNS') SET @CurrentCommand01 = @CurrentCommand01 + ', StatisticsName ASC'
        IF @PartitionLevel = 'Y' SET @CurrentCommand01 = @CurrentCommand01 + ', PartitionNumber ASC'

        INSERT INTO @tmpIndexesStatistics (SchemaID, SchemaName, ObjectID, ObjectName, ObjectType, IndexID, IndexName, IndexType, StatisticsID, StatisticsName, PartitionID, PartitionNumber, PartitionCount, Selected, Completed)
        EXECUTE sp_executesql @statement = @CurrentCommand01, @params = N'@ParamPageCountLevel int', @ParamPageCountLevel = @PageCountLevel
        SET @Error = @@ERROR
        IF @Error &lt;&gt; 0
        BEGIN
          SET @ReturnCode = @Error
        END
      END

      IF @Indexes IS NULL
      BEGIN
        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.Selected = 1
        FROM @tmpIndexesStatistics tmpIndexesStatistics
      END
      ELSE
      BEGIN
        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.Selected = SelectedIndexes.Selected
        FROM @tmpIndexesStatistics tmpIndexesStatistics
        INNER JOIN @SelectedIndexes SelectedIndexes
        ON @CurrentDatabaseName LIKE REPLACE(SelectedIndexes.DatabaseName,'_','[_]') AND tmpIndexesStatistics.SchemaName LIKE REPLACE(SelectedIndexes.SchemaName,'_','[_]') AND tmpIndexesStatistics.ObjectName LIKE REPLACE(SelectedIndexes.ObjectName,'_','[_]') AND COALESCE(tmpIndexesStatistics.IndexName,tmpIndexesStatistics.StatisticsName) LIKE REPLACE(SelectedIndexes.IndexName,'_','[_]')
        WHERE SelectedIndexes.Selected = 1

        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.Selected = SelectedIndexes.Selected
        FROM @tmpIndexesStatistics tmpIndexesStatistics
        INNER JOIN @SelectedIndexes SelectedIndexes
        ON @CurrentDatabaseName LIKE REPLACE(SelectedIndexes.DatabaseName,'_','[_]') AND tmpIndexesStatistics.SchemaName LIKE REPLACE(SelectedIndexes.SchemaName,'_','[_]') AND tmpIndexesStatistics.ObjectName LIKE REPLACE(SelectedIndexes.ObjectName,'_','[_]') AND COALESCE(tmpIndexesStatistics.IndexName,tmpIndexesStatistics.StatisticsName) LIKE REPLACE(SelectedIndexes.IndexName,'_','[_]')
        WHERE SelectedIndexes.Selected = 0
      END

      WHILE EXISTS (SELECT * FROM @tmpIndexesStatistics WHERE Selected = 1 AND Completed = 0 AND (GETDATE() &lt; DATEADD(ss,@TimeLimit,@StartTime) OR @TimeLimit IS NULL))
      BEGIN

        SELECT TOP 1 @CurrentIxID = ID,
                     @CurrentSchemaID = SchemaID,
                     @CurrentSchemaName = SchemaName,
                     @CurrentObjectID = ObjectID,
                     @CurrentObjectName = ObjectName,
                     @CurrentObjectType = ObjectType,
                     @CurrentIndexID = IndexID,
                     @CurrentIndexName = IndexName,
                     @CurrentIndexType = IndexType,
                     @CurrentStatisticsID = StatisticsID,
                     @CurrentStatisticsName = StatisticsName,
                     @CurrentPartitionID = PartitionID,
                     @CurrentPartitionNumber = PartitionNumber,
                     @CurrentPartitionCount = PartitionCount
        FROM @tmpIndexesStatistics
        WHERE Selected = 1
        AND Completed = 0
        ORDER BY ID ASC

        -- Is the index a partition?
        IF @CurrentPartitionNumber IS NULL OR @CurrentPartitionCount = 1 BEGIN SET @CurrentIsPartition = 0 END ELSE BEGIN SET @CurrentIsPartition = 1 END

        -- Does the index exist?
        IF @CurrentIndexID IS NOT NULL AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentCommand02 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand02 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          IF @CurrentIsPartition = 0 SET @CurrentCommand02 = @CurrentCommand02 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.objects objects ON indexes.[object_id] = objects.[object_id] INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] IN(''U'',''V'')' + CASE WHEN @MSShippedObjects = 'N' THEN ' AND objects.is_ms_shipped = 0' ELSE '' END + ' AND indexes.[type] IN(1,2,3,4) AND indexes.is_disabled = 0 AND indexes.is_hypothetical = 0 AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType AND indexes.index_id = @ParamIndexID AND indexes.[name] = @ParamIndexName AND indexes.[type] = @ParamIndexType) BEGIN SET @ParamIndexExists = 1 END'
          IF @CurrentIsPartition = 1 SET @CurrentCommand02 = @CurrentCommand02 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.objects objects ON indexes.[object_id] = objects.[object_id] INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.partitions partitions ON indexes.[object_id] = partitions.[object_id] AND indexes.index_id = partitions.index_id WHERE objects.[type] IN(''U'',''V'')' + CASE WHEN @MSShippedObjects = 'N' THEN ' AND objects.is_ms_shipped = 0' ELSE '' END + ' AND indexes.[type] IN(1,2,3,4) AND indexes.is_disabled = 0 AND indexes.is_hypothetical = 0 AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType AND indexes.index_id = @ParamIndexID AND indexes.[name] = @ParamIndexName AND indexes.[type] = @ParamIndexType AND partitions.partition_id = @ParamPartitionID AND partitions.partition_number = @ParamPartitionNumber) BEGIN SET @ParamIndexExists = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand02, @params = N'@ParamSchemaID int, @ParamSchemaName sysname, @ParamObjectID int, @ParamObjectName sysname, @ParamObjectType sysname, @ParamIndexID int, @ParamIndexName sysname, @ParamIndexType int, @ParamPartitionID bigint, @ParamPartitionNumber int, @ParamIndexExists bit OUTPUT', @ParamSchemaID = @CurrentSchemaID, @ParamSchemaName = @CurrentSchemaName, @ParamObjectID = @CurrentObjectID, @ParamObjectName = @CurrentObjectName, @ParamObjectType = @CurrentObjectType, @ParamIndexID = @CurrentIndexID, @ParamIndexName = @CurrentIndexName, @ParamIndexType = @CurrentIndexType, @ParamPartitionID = @CurrentPartitionID, @ParamPartitionNumber = @CurrentPartitionNumber, @ParamIndexExists = @CurrentIndexExists OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentIndexExists IS NULL SET @CurrentIndexExists = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the index exists.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
          IF @CurrentIndexExists = 0 GOTO NoAction
        END

        -- Does the statistics exist?
        IF @CurrentStatisticsID IS NOT NULL AND @UpdateStatistics IS NOT NULL
        BEGIN
          SET @CurrentCommand03 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand03 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand03 = @CurrentCommand03 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.stats stats INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.objects objects ON stats.[object_id] = objects.[object_id] INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] IN(''U'',''V'')' + CASE WHEN @MSShippedObjects = 'N' THEN ' AND objects.is_ms_shipped = 0' ELSE '' END + ' AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType AND stats.stats_id = @ParamStatisticsID AND stats.[name] = @ParamStatisticsName) BEGIN SET @ParamStatisticsExists = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand03, @params = N'@ParamSchemaID int, @ParamSchemaName sysname, @ParamObjectID int, @ParamObjectName sysname, @ParamObjectType sysname, @ParamStatisticsID int, @ParamStatisticsName sysname, @ParamStatisticsExists bit OUTPUT', @ParamSchemaID = @CurrentSchemaID, @ParamSchemaName = @CurrentSchemaName, @ParamObjectID = @CurrentObjectID, @ParamObjectName = @CurrentObjectName, @ParamObjectType = @CurrentObjectType, @ParamStatisticsID = @CurrentStatisticsID, @ParamStatisticsName = @CurrentStatisticsName, @ParamStatisticsExists = @CurrentStatisticsExists OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentStatisticsExists IS NULL SET @CurrentStatisticsExists = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The statistics ' + QUOTENAME(@CurrentStatisticsName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the statistics exists.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
          IF @CurrentStatisticsExists = 0 GOTO NoAction
        END

        -- Is one of the columns in the index an image, text or ntext data type?
        IF @CurrentIndexID IS NOT NULL AND @CurrentIndexType = 1 AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentCommand04 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand04 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand04 = @CurrentCommand04 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.columns columns INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.types types ON columns.system_type_id = types.user_type_id WHERE columns.[object_id] = @ParamObjectID AND types.name IN(''image'',''text'',''ntext'')) BEGIN SET @ParamIsImageText = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand04, @params = N'@ParamObjectID int, @ParamIndexID int, @ParamIsImageText bit OUTPUT', @ParamObjectID = @CurrentObjectID, @ParamIndexID = @CurrentIndexID, @ParamIsImageText = @CurrentIsImageText OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentIsImageText IS NULL SET @CurrentIsImageText = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the index contains any image, text, or ntext data types.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
        END

        -- Is one of the columns in the index an xml, varchar(max), nvarchar(max), varbinary(max) or large CLR data type?
        IF @CurrentIndexID IS NOT NULL AND @CurrentIndexType IN(1,2) AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentCommand05 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand05 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          IF @CurrentIndexType = 1 SET @CurrentCommand05 = @CurrentCommand05 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.columns columns INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.types types ON columns.system_type_id = types.user_type_id OR (columns.user_type_id = types.user_type_id AND types.is_assembly_type = 1) WHERE columns.[object_id] = @ParamObjectID AND (types.name IN(''xml'') OR (types.name IN(''varchar'',''nvarchar'',''varbinary'') AND columns.max_length = -1) OR (types.is_assembly_type = 1 AND columns.max_length = -1))) BEGIN SET @ParamIsNewLOB = 1 END'
          IF @CurrentIndexType = 2 SET @CurrentCommand05 = @CurrentCommand05 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.index_columns index_columns INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.columns columns ON index_columns.[object_id] = columns.[object_id] AND index_columns.column_id = columns.column_id INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.types types ON columns.system_type_id = types.user_type_id OR (columns.user_type_id = types.user_type_id AND types.is_assembly_type = 1) WHERE index_columns.[object_id] = @ParamObjectID AND index_columns.index_id = @ParamIndexID AND (types.[name] IN(''xml'') OR (types.[name] IN(''varchar'',''nvarchar'',''varbinary'') AND columns.max_length = -1) OR (types.is_assembly_type = 1 AND columns.max_length = -1))) BEGIN SET @ParamIsNewLOB = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand05, @params = N'@ParamObjectID int, @ParamIndexID int, @ParamIsNewLOB bit OUTPUT', @ParamObjectID = @CurrentObjectID, @ParamIndexID = @CurrentIndexID, @ParamIsNewLOB = @CurrentIsNewLOB OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentIsNewLOB IS NULL SET @CurrentIsNewLOB = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the index contains any xml, varchar(max), nvarchar(max), varbinary(max), or large CLR data types.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
        END

        -- Is one of the columns in the index a file stream column?
        IF @CurrentIndexID IS NOT NULL AND @CurrentIndexType = 1 AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentCommand06 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand06 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand06 = @CurrentCommand06 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.columns columns WHERE columns.[object_id] = @ParamObjectID  AND columns.is_filestream = 1) BEGIN SET @ParamIsFileStream = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand06, @params = N'@ParamObjectID int, @ParamIndexID int, @ParamIsFileStream bit OUTPUT', @ParamObjectID = @CurrentObjectID, @ParamIndexID = @CurrentIndexID, @ParamIsFileStream = @CurrentIsFileStream OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentIsFileStream IS NULL SET @CurrentIsFileStream = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the index contains any file stream columns.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
        END

        -- Is there a columnstore index on the table?
        IF @CurrentIndexID IS NOT NULL AND EXISTS(SELECT * FROM @ActionsPreferred) AND @Version &gt;= 11
        BEGIN
          SET @CurrentCommand07 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand07 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand07 = @CurrentCommand07 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes WHERE indexes.[object_id] = @ParamObjectID AND [type] = 6) BEGIN SET @ParamIsColumnStore = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand07, @params = N'@ParamObjectID int, @ParamIsColumnStore bit OUTPUT', @ParamObjectID = @CurrentObjectID, @ParamIsColumnStore = @CurrentIsColumnStore OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentIsColumnStore IS NULL SET @CurrentIsColumnStore = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if there is a columnstore index on the table.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
        END

        -- Is Allow_Page_Locks set to On?
        IF @CurrentIndexID IS NOT NULL AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentCommand08 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand08 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand08 = @CurrentCommand08 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes WHERE indexes.[object_id] = @ParamObjectID AND indexes.[index_id] = @ParamIndexID AND indexes.[allow_page_locks] = 1) BEGIN SET @ParamAllowPageLocks = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand08, @params = N'@ParamObjectID int, @ParamIndexID int, @ParamAllowPageLocks bit OUTPUT', @ParamObjectID = @CurrentObjectID, @ParamIndexID = @CurrentIndexID, @ParamAllowPageLocks = @CurrentAllowPageLocks OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentAllowPageLocks IS NULL SET @CurrentAllowPageLocks = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if page locking is enabled on the index.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
        END

        -- Is No_Recompute set to On?
        IF @CurrentStatisticsID IS NOT NULL AND @UpdateStatistics IS NOT NULL
        BEGIN
          SET @CurrentCommand09 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand09 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand09 = @CurrentCommand09 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.stats stats WHERE stats.[object_id] = @ParamObjectID AND stats.[stats_id] = @ParamStatisticsID AND stats.[no_recompute] = 1) BEGIN SET @ParamNoRecompute = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand09, @params = N'@ParamObjectID int, @ParamStatisticsID int, @ParamNoRecompute bit OUTPUT', @ParamObjectID = @CurrentObjectID, @ParamStatisticsID = @CurrentStatisticsID, @ParamNoRecompute = @CurrentNoRecompute OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentNoRecompute IS NULL SET @CurrentNoRecompute = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The statistics ' + QUOTENAME(@CurrentStatisticsName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if automatic statistics update is enabled.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
        END

        -- Has the data in the statistics been modified since the statistics was last updated?
        IF @CurrentStatisticsID IS NOT NULL AND @UpdateStatistics IS NOT NULL AND @OnlyModifiedStatistics = 'Y'
        BEGIN
          SET @CurrentCommand10 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand10 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          IF (@Version &gt;= 10.504000 AND @Version &lt; 11) OR @Version &gt;= 11.03000
          BEGIN
            SET @CurrentCommand10 = @CurrentCommand10 + 'USE ' + QUOTENAME(@CurrentDatabaseName) + '; IF EXISTS(SELECT * FROM sys.dm_db_stats_properties (@ParamObjectID, @ParamStatisticsID) WHERE modification_counter &gt; 0) BEGIN SET @ParamStatisticsModified = 1 END'
          END
          ELSE
          BEGIN
            SET @CurrentCommand10 = @CurrentCommand10 + 'IF EXISTS(SELECT * FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.sysindexes sysindexes WHERE sysindexes.[id] = @ParamObjectID AND sysindexes.[indid] = @ParamStatisticsID AND sysindexes.[rowmodctr] &lt;&gt; 0) BEGIN SET @ParamStatisticsModified = 1 END'
          END

          EXECUTE sp_executesql @statement = @CurrentCommand10, @params = N'@ParamObjectID int, @ParamStatisticsID int, @ParamStatisticsModified bit OUTPUT', @ParamObjectID = @CurrentObjectID, @ParamStatisticsID = @CurrentStatisticsID, @ParamStatisticsModified = @CurrentStatisticsModified OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentStatisticsModified IS NULL SET @CurrentStatisticsModified = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The statistics ' + QUOTENAME(@CurrentStatisticsName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if any rows has been modified since the most recent statistics update.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
        END

        -- Is the index on a read-only filegroup?
        IF @CurrentIndexID IS NOT NULL AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentCommand11 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand11 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand11 = @CurrentCommand11 + 'IF EXISTS(SELECT * FROM (SELECT filegroups.data_space_id FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.destination_data_spaces destination_data_spaces ON indexes.data_space_id = destination_data_spaces.partition_scheme_id INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.filegroups filegroups ON destination_data_spaces.data_space_id = filegroups.data_space_id WHERE filegroups.is_read_only = 1 AND indexes.[object_id] = @ParamObjectID AND indexes.[index_id] = @ParamIndexID'
          IF @CurrentIsPartition = 1 SET @CurrentCommand11 = @CurrentCommand11 + ' AND destination_data_spaces.destination_id = @ParamPartitionNumber'
          SET @CurrentCommand11 = @CurrentCommand11 + ' UNION SELECT filegroups.data_space_id FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.indexes indexes INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.filegroups filegroups ON indexes.data_space_id = filegroups.data_space_id WHERE filegroups.is_read_only = 1 AND indexes.[object_id] = @ParamObjectID AND indexes.[index_id] = @ParamIndexID'
          IF @CurrentIndexType = 1 SET @CurrentCommand11 = @CurrentCommand11 + ' UNION SELECT filegroups.data_space_id FROM ' + QUOTENAME(@CurrentDatabaseName) + '.sys.tables tables INNER JOIN ' + QUOTENAME(@CurrentDatabaseName) + '.sys.filegroups filegroups ON tables.lob_data_space_id = filegroups.data_space_id WHERE filegroups.is_read_only = 1 AND tables.[object_id] = @ParamObjectID'
          SET @CurrentCommand11 = @CurrentCommand11 + ') ReadOnlyFileGroups) BEGIN SET @ParamOnReadOnlyFileGroup = 1 END'

          EXECUTE sp_executesql @statement = @CurrentCommand11, @params = N'@ParamObjectID int, @ParamIndexID int, @ParamPartitionNumber int, @ParamOnReadOnlyFileGroup bit OUTPUT', @ParamObjectID = @CurrentObjectID, @ParamIndexID = @CurrentIndexID, @ParamPartitionNumber = @CurrentPartitionNumber, @ParamOnReadOnlyFileGroup = @CurrentOnReadOnlyFileGroup OUTPUT
          SET @Error = @@ERROR
          IF @Error = 0 AND @CurrentOnReadOnlyFileGroup IS NULL SET @CurrentOnReadOnlyFileGroup = 0
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the index is on a read-only filegroup.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
        END

        -- Is the index fragmented?
        IF @CurrentIndexID IS NOT NULL
        AND @CurrentOnReadOnlyFileGroup = 0
        AND EXISTS(SELECT * FROM @ActionsPreferred)
        AND (EXISTS(SELECT [Priority], [Action], COUNT(*) FROM @ActionsPreferred GROUP BY [Priority], [Action] HAVING COUNT(*) &lt;&gt; 3) OR @PageCountLevel &gt; 0)
        BEGIN
          SET @CurrentCommand12 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand12 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand12 = @CurrentCommand12 + 'SELECT @ParamFragmentationLevel = MAX(avg_fragmentation_in_percent), @ParamPageCount = SUM(page_count) FROM sys.dm_db_index_physical_stats(@ParamDatabaseID, @ParamObjectID, @ParamIndexID, @ParamPartitionNumber, ''LIMITED'') WHERE alloc_unit_type_desc = ''IN_ROW_DATA'' AND index_level = 0'

          EXECUTE sp_executesql @statement = @CurrentCommand12, @params = N'@ParamDatabaseID int, @ParamObjectID int, @ParamIndexID int, @ParamPartitionNumber int, @ParamFragmentationLevel float OUTPUT, @ParamPageCount bigint OUTPUT', @ParamDatabaseID = @CurrentDatabaseID, @ParamObjectID = @CurrentObjectID, @ParamIndexID = @CurrentIndexID, @ParamPartitionNumber = @CurrentPartitionNumber, @ParamFragmentationLevel = @CurrentFragmentationLevel OUTPUT, @ParamPageCount = @CurrentPageCount OUTPUT
          SET @Error = @@ERROR
          IF @Error = 1222
          BEGIN
            SET @ErrorMessage = 'The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. The size and fragmentation of the index could not be checked.' + CHAR(13) + CHAR(10) + ' '
            SET @ErrorMessage = REPLACE(@ErrorMessage,'%','%%')
            RAISERROR(@ErrorMessage,16,1) WITH NOWAIT
          END
          IF @Error &lt;&gt; 0
          BEGIN
            SET @ReturnCode = @Error
            GOTO NoAction
          END
        END

        -- Select fragmentation group
        IF @CurrentIndexID IS NOT NULL AND @CurrentOnReadOnlyFileGroup = 0 AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentFragmentationGroup = CASE
          WHEN @CurrentFragmentationLevel &gt;= @FragmentationLevel2 THEN 'High'
          WHEN @CurrentFragmentationLevel &gt;= @FragmentationLevel1 AND @CurrentFragmentationLevel &lt; @FragmentationLevel2 THEN 'Medium'
          WHEN @CurrentFragmentationLevel &lt; @FragmentationLevel1 THEN 'Low'
          END
        END

        -- Which actions are allowed?
        IF @CurrentIndexID IS NOT NULL AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          IF @CurrentOnReadOnlyFileGroup = 0 AND @CurrentAllowPageLocks = 1
          BEGIN
            INSERT INTO @CurrentActionsAllowed ([Action])
            VALUES ('INDEX_REORGANIZE')
          END
          IF @CurrentOnReadOnlyFileGroup = 0
          BEGIN
            INSERT INTO @CurrentActionsAllowed ([Action])
            VALUES ('INDEX_REBUILD_OFFLINE')
          END
          IF @CurrentOnReadOnlyFileGroup = 0
          AND (@CurrentIsPartition = 0 OR @Version &gt;= 12)
          AND ((@CurrentIndexType = 1 AND @CurrentIsImageText = 0 AND @CurrentIsNewLOB = 0)
          OR (@CurrentIndexType = 2 AND @CurrentIsNewLOB = 0)
          OR (@CurrentIndexType = 1 AND @CurrentIsImageText = 0 AND @CurrentIsFileStream = 0 AND @Version &gt;= 11)
          OR (@CurrentIndexType = 2 AND @Version &gt;= 11))
          AND (@CurrentIsColumnStore = 0 OR @Version &lt; 11)
          AND SERVERPROPERTY('EngineEdition') = 3
          BEGIN
            INSERT INTO @CurrentActionsAllowed ([Action])
            VALUES ('INDEX_REBUILD_ONLINE')
          END
        END

        -- Decide action
        IF @CurrentIndexID IS NOT NULL
        AND EXISTS(SELECT * FROM @ActionsPreferred)
        AND (@CurrentPageCount &gt;= @PageCountLevel OR @PageCountLevel = 0)
        BEGIN
          IF EXISTS(SELECT [Priority], [Action], COUNT(*) FROM @ActionsPreferred GROUP BY [Priority], [Action] HAVING COUNT(*) &lt;&gt; 3)
          BEGIN
            SELECT @CurrentAction = [Action]
            FROM @ActionsPreferred
            WHERE FragmentationGroup = @CurrentFragmentationGroup
            AND [Priority] = (SELECT MIN([Priority])
                              FROM @ActionsPreferred
                              WHERE FragmentationGroup = @CurrentFragmentationGroup
                              AND [Action] IN (SELECT [Action] FROM @CurrentActionsAllowed))
          END
          ELSE
          BEGIN
            SELECT @CurrentAction = [Action]
            FROM @ActionsPreferred
            WHERE [Priority] = (SELECT MIN([Priority])
                                FROM @ActionsPreferred
                                WHERE [Action] IN (SELECT [Action] FROM @CurrentActionsAllowed))
          END
        END

        -- Workaround for limitation in SQL Server, http://support.microsoft.com/kb/2292737
        IF @CurrentIndexID IS NOT NULL
        BEGIN
          SET @CurrentMaxDOP = @MaxDOP
          IF @CurrentAction = 'INDEX_REBUILD_ONLINE' AND @CurrentAllowPageLocks = 0
          BEGIN
            SET @CurrentMaxDOP = 1
          END
        END

        -- Update statistics?
        IF @CurrentStatisticsID IS NOT NULL
        AND (@UpdateStatistics = 'ALL' OR (@UpdateStatistics = 'INDEX' AND @CurrentIndexID IS NOT NULL) OR (@UpdateStatistics = 'COLUMNS' AND @CurrentIndexID IS NULL))
        AND (@CurrentStatisticsModified = 1 OR @OnlyModifiedStatistics = 'N')
        AND ((@CurrentIsPartition = 0 AND (@CurrentAction NOT IN('INDEX_REBUILD_ONLINE','INDEX_REBUILD_OFFLINE') OR @CurrentAction IS NULL)) OR (@CurrentIsPartition = 1 AND @CurrentPartitionNumber = @CurrentPartitionCount))
        BEGIN
          SET @CurrentUpdateStatistics = 'Y'
        END
        ELSE
        BEGIN
          SET @CurrentUpdateStatistics = 'N'
        END

        -- Create comment
        IF @CurrentIndexID IS NOT NULL
        BEGIN
          SET @CurrentComment = 'ObjectType: ' + CASE WHEN @CurrentObjectType = 'U' THEN 'Table' WHEN @CurrentObjectType = 'V' THEN 'View' ELSE 'N/A' END + ', '
          SET @CurrentComment = @CurrentComment + 'IndexType: ' + CASE WHEN @CurrentIndexType = 1 THEN 'Clustered' WHEN @CurrentIndexType = 2 THEN 'NonClustered' WHEN @CurrentIndexType = 3 THEN 'XML' WHEN @CurrentIndexType = 4 THEN 'Spatial' ELSE 'N/A' END + ', '
          SET @CurrentComment = @CurrentComment + 'ImageText: ' + CASE WHEN @CurrentIsImageText = 1 THEN 'Yes' WHEN @CurrentIsImageText = 0 THEN 'No' ELSE 'N/A' END + ', '
          SET @CurrentComment = @CurrentComment + 'NewLOB: ' + CASE WHEN @CurrentIsNewLOB = 1 THEN 'Yes' WHEN @CurrentIsNewLOB = 0 THEN 'No' ELSE 'N/A' END + ', '
          SET @CurrentComment = @CurrentComment + 'FileStream: ' + CASE WHEN @CurrentIsFileStream = 1 THEN 'Yes' WHEN @CurrentIsFileStream = 0 THEN 'No' ELSE 'N/A' END + ', '
          IF @Version &gt;= 11 SET @CurrentComment = @CurrentComment + 'ColumnStore: ' + CASE WHEN @CurrentIsColumnStore = 1 THEN 'Yes' WHEN @CurrentIsColumnStore = 0 THEN 'No' ELSE 'N/A' END + ', '
          SET @CurrentComment = @CurrentComment + 'AllowPageLocks: ' + CASE WHEN @CurrentAllowPageLocks = 1 THEN 'Yes' WHEN @CurrentAllowPageLocks = 0 THEN 'No' ELSE 'N/A' END + ', '
          SET @CurrentComment = @CurrentComment + 'PageCount: ' + ISNULL(CAST(@CurrentPageCount AS nvarchar),'N/A') + ', '
          SET @CurrentComment = @CurrentComment + 'Fragmentation: ' + ISNULL(CAST(@CurrentFragmentationLevel AS nvarchar),'N/A')
        END

        IF @CurrentIndexID IS NOT NULL AND (@CurrentPageCount IS NOT NULL OR @CurrentFragmentationLevel IS NOT NULL)
        BEGIN
        SET @CurrentExtendedInfo = (SELECT *
                                    FROM (SELECT CAST(@CurrentPageCount AS nvarchar) AS [PageCount],
                                                 CAST(@CurrentFragmentationLevel AS nvarchar) AS Fragmentation
                                    ) ExtendedInfo FOR XML AUTO, ELEMENTS)
        END

        IF @CurrentIndexID IS NOT NULL AND @CurrentAction IS NOT NULL AND (GETDATE() &lt; DATEADD(ss,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
        BEGIN
          SET @CurrentCommandType13 = 'ALTER_INDEX'

          SET @CurrentCommand13 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand13 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand13 = @CurrentCommand13 + 'ALTER INDEX ' + QUOTENAME(@CurrentIndexName) + ' ON ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName)

          IF @CurrentAction IN('INDEX_REBUILD_ONLINE','INDEX_REBUILD_OFFLINE')
          BEGIN
            SET @CurrentCommand13 = @CurrentCommand13 + ' REBUILD'
            IF @CurrentIsPartition = 1 SET @CurrentCommand13 = @CurrentCommand13 + ' PARTITION = ' + CAST(@CurrentPartitionNumber AS nvarchar)
            SET @CurrentCommand13 = @CurrentCommand13 + ' WITH ('
            IF @SortInTempdb = 'Y' SET @CurrentCommand13 = @CurrentCommand13 + 'SORT_IN_TEMPDB = ON'
            IF @SortInTempdb = 'N' SET @CurrentCommand13 = @CurrentCommand13 + 'SORT_IN_TEMPDB = OFF'
            IF @CurrentAction = 'INDEX_REBUILD_ONLINE' AND (@CurrentIsPartition = 0 OR @Version &gt;= 12) SET @CurrentCommand13 = @CurrentCommand13 + ', ONLINE = ON'
            IF @CurrentAction = 'INDEX_REBUILD_OFFLINE' AND (@CurrentIsPartition = 0 OR @Version &gt;= 12) SET @CurrentCommand13 = @CurrentCommand13 + ', ONLINE = OFF'
            IF @CurrentMaxDOP IS NOT NULL SET @CurrentCommand13 = @CurrentCommand13 + ', MAXDOP = ' + CAST(@CurrentMaxDOP AS nvarchar)
            IF @FillFactor IS NOT NULL AND @CurrentIsPartition = 0 SET @CurrentCommand13 = @CurrentCommand13 + ', FILLFACTOR = ' + CAST(@FillFactor AS nvarchar)
            IF @PadIndex = 'Y' AND @CurrentIsPartition = 0 SET @CurrentCommand13 = @CurrentCommand13 + ', PAD_INDEX = ON'
            IF @PadIndex = 'N' AND @CurrentIsPartition = 0 SET @CurrentCommand13 = @CurrentCommand13 + ', PAD_INDEX = OFF'
            SET @CurrentCommand13 = @CurrentCommand13 + ')'
          END

          IF @CurrentAction IN('INDEX_REORGANIZE')
          BEGIN
            SET @CurrentCommand13 = @CurrentCommand13 + ' REORGANIZE'
            IF @CurrentIsPartition = 1 SET @CurrentCommand13 = @CurrentCommand13 + ' PARTITION = ' + CAST(@CurrentPartitionNumber AS nvarchar)
            SET @CurrentCommand13 = @CurrentCommand13 + ' WITH ('
            IF @LOBCompaction = 'Y' SET @CurrentCommand13 = @CurrentCommand13 + 'LOB_COMPACTION = ON'
            IF @LOBCompaction = 'N' SET @CurrentCommand13 = @CurrentCommand13 + 'LOB_COMPACTION = OFF'
            SET @CurrentCommand13 = @CurrentCommand13 + ')'
          END

          EXECUTE @CurrentCommandOutput13 = [dbo].[CommandExecute] @Command = @CurrentCommand13, @CommandType = @CurrentCommandType13, @Mode = 2, @Comment = @CurrentComment, @DatabaseName = @CurrentDatabaseName, @SchemaName = @CurrentSchemaName, @ObjectName = @CurrentObjectName, @ObjectType = @CurrentObjectType, @IndexName = @CurrentIndexName, @IndexType = @CurrentIndexType, @PartitionNumber = @CurrentPartitionNumber, @ExtendedInfo = @CurrentExtendedInfo, @LogToTable = @LogToTable, @Execute = @Execute
          SET @Error = @@ERROR
          IF @Error &lt;&gt; 0 SET @CurrentCommandOutput13 = @Error
          IF @CurrentCommandOutput13 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput13

          IF @Delay &gt; 0
          BEGIN
            SET @CurrentDelay = DATEADD(ss,@Delay,'1900-01-01')
            WAITFOR DELAY @CurrentDelay
          END
        END

        IF @CurrentStatisticsID IS NOT NULL AND @CurrentUpdateStatistics = 'Y' AND (GETDATE() &lt; DATEADD(ss,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
        BEGIN
          SET @CurrentCommandType14 = 'UPDATE_STATISTICS'

          SET @CurrentCommand14 = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand14 = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand14 = @CurrentCommand14 + 'UPDATE STATISTICS ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' ' + QUOTENAME(@CurrentStatisticsName)
          IF @StatisticsSample IS NOT NULL OR @StatisticsResample = 'Y' OR @CurrentNoRecompute = 1 SET @CurrentCommand14 = @CurrentCommand14 + ' WITH'
          IF @StatisticsSample = 100 SET @CurrentCommand14 = @CurrentCommand14 + ' FULLSCAN'
          IF @StatisticsSample IS NOT NULL AND @StatisticsSample &lt;&gt; 100 SET @CurrentCommand14 = @CurrentCommand14 + ' SAMPLE ' + CAST(@StatisticsSample AS nvarchar) + ' PERCENT'
          IF @StatisticsResample = 'Y' SET @CurrentCommand14 = @CurrentCommand14 + ' RESAMPLE'
          IF (@StatisticsSample IS NOT NULL OR @StatisticsResample = 'Y') AND @CurrentNoRecompute = 1 SET @CurrentCommand14 = @CurrentCommand14 + ','
          IF @CurrentNoRecompute = 1 SET @CurrentCommand14 = @CurrentCommand14 + ' NORECOMPUTE'

          EXECUTE @CurrentCommandOutput14 = [dbo].[CommandExecute] @Command = @CurrentCommand14, @CommandType = @CurrentCommandType14, @Mode = 2, @DatabaseName = @CurrentDatabaseName, @SchemaName = @CurrentSchemaName, @ObjectName = @CurrentObjectName, @ObjectType = @CurrentObjectType, @IndexName = @CurrentIndexName, @IndexType = @CurrentIndexType, @StatisticsName = @CurrentStatisticsName, @LogToTable = @LogToTable, @Execute = @Execute
          SET @Error = @@ERROR
          IF @Error &lt;&gt; 0 SET @CurrentCommandOutput14 = @Error
          IF @CurrentCommandOutput14 &lt;&gt; 0 SET @ReturnCode = @CurrentCommandOutput14
        END

        NoAction:

        -- Update that the index is completed
        UPDATE @tmpIndexesStatistics
        SET Completed = 1
        WHERE Selected = 1
        AND Completed = 0
        AND ID = @CurrentIxID

        -- Clear variables
        SET @CurrentCommand02 = NULL
        SET @CurrentCommand03 = NULL
        SET @CurrentCommand04 = NULL
        SET @CurrentCommand05 = NULL
        SET @CurrentCommand06 = NULL
        SET @CurrentCommand07 = NULL
        SET @CurrentCommand08 = NULL
        SET @CurrentCommand09 = NULL
        SET @CurrentCommand10 = NULL
        SET @CurrentCommand11 = NULL
        SET @CurrentCommand12 = NULL
        SET @CurrentCommand13 = NULL
        SET @CurrentCommand14 = NULL

        SET @CurrentCommandOutput13 = NULL
        SET @CurrentCommandOutput14 = NULL

        SET @CurrentCommandType13 = NULL
        SET @CurrentCommandType14 = NULL

        SET @CurrentIxID = NULL
        SET @CurrentSchemaID = NULL
        SET @CurrentSchemaName = NULL
        SET @CurrentObjectID = NULL
        SET @CurrentObjectName = NULL
        SET @CurrentObjectType = NULL
        SET @CurrentIndexID = NULL
        SET @CurrentIndexName = NULL
        SET @CurrentIndexType = NULL
        SET @CurrentStatisticsID = NULL
        SET @CurrentStatisticsName = NULL
        SET @CurrentPartitionID = NULL
        SET @CurrentPartitionNumber = NULL
        SET @CurrentPartitionCount = NULL
        SET @CurrentIsPartition = NULL
        SET @CurrentIndexExists = NULL
        SET @CurrentStatisticsExists = NULL
        SET @CurrentIsImageText = NULL
        SET @CurrentIsNewLOB = NULL
        SET @CurrentIsFileStream = NULL
        SET @CurrentIsColumnStore = NULL
        SET @CurrentAllowPageLocks = NULL
        SET @CurrentNoRecompute = NULL
        SET @CurrentStatisticsModified = NULL
        SET @CurrentOnReadOnlyFileGroup = NULL
        SET @CurrentFragmentationLevel = NULL
        SET @CurrentPageCount = NULL
        SET @CurrentFragmentationGroup = NULL
        SET @CurrentAction = NULL
        SET @CurrentMaxDOP = NULL
        SET @CurrentUpdateStatistics = NULL
        SET @CurrentComment = NULL
        SET @CurrentExtendedInfo = NULL

        DELETE FROM @CurrentActionsAllowed

      END

    END

    -- Update that the database is completed
    UPDATE @tmpDatabases
    SET Completed = 1
    WHERE Selected = 1
    AND Completed = 0
    AND ID = @CurrentDBID

    -- Clear variables
    SET @CurrentDBID = NULL
    SET @CurrentDatabaseID = NULL
    SET @CurrentDatabaseName = NULL
    SET @CurrentIsDatabaseAccessible = NULL
    SET @CurrentAvailabilityGroup = NULL
    SET @CurrentAvailabilityGroupRole = NULL
    SET @CurrentDatabaseMirroringRole = NULL
    SET @CurrentLogShippingRole = NULL

    SET @CurrentCommand01 = NULL

    DELETE FROM @tmpIndexesStatistics

  END

  ----------------------------------------------------------------------------------------------------
  --// Log completing information                                                                 //--
  ----------------------------------------------------------------------------------------------------

  Logging:
  SET @EndMessage = 'Date and time: ' + CONVERT(nvarchar,GETDATE(),120)
  SET @EndMessage = REPLACE(@EndMessage,'%','%%')
  RAISERROR(@EndMessage,10,1) WITH NOWAIT

  IF @ReturnCode &lt;&gt; 0
  BEGIN
    RETURN @ReturnCode
  END

  ----------------------------------------------------------------------------------------------------

END
GO

IF (SELECT CAST([Value] AS int) FROM #Config WHERE Name = 'Error') = 0
AND (SELECT [Value] FROM #Config WHERE Name = 'CreateJobs') = 'Y'
AND SERVERPROPERTY('EngineEdition') &lt;&gt; 4
BEGIN

  DECLARE @BackupDirectory nvarchar(max)
  DECLARE @OutputFileDirectory nvarchar(max)
  DECLARE @LogToTable nvarchar(max)
  DECLARE @DatabaseName nvarchar(max)

  DECLARE @Version numeric(18,10)

  DECLARE @TokenServer nvarchar(max)
  DECLARE @TokenJobID nvarchar(max)
  DECLARE @TokenStepID nvarchar(max)
  DECLARE @TokenDate nvarchar(max)
  DECLARE @TokenTime nvarchar(max)

  DECLARE @JobDescription nvarchar(max)
  DECLARE @JobCategory nvarchar(max)
  DECLARE @JobOwner nvarchar(max)

  DECLARE @JobName01 nvarchar(max)
  DECLARE @JobName02 nvarchar(max)
  DECLARE @JobName03 nvarchar(max)
  DECLARE @JobName04 nvarchar(max)
  DECLARE @JobName05 nvarchar(max)
  DECLARE @JobName06 nvarchar(max)
  DECLARE @JobName07 nvarchar(max)
  DECLARE @JobName08 nvarchar(max)
  DECLARE @JobName09 nvarchar(max)
  DECLARE @JobName10 nvarchar(max)
  DECLARE @JobName11 nvarchar(max)

  DECLARE @JobCommand01 nvarchar(max)
  DECLARE @JobCommand02 nvarchar(max)
  DECLARE @JobCommand03 nvarchar(max)
  DECLARE @JobCommand04 nvarchar(max)
  DECLARE @JobCommand05 nvarchar(max)
  DECLARE @JobCommand06 nvarchar(max)
  DECLARE @JobCommand07 nvarchar(max)
  DECLARE @JobCommand08 nvarchar(max)
  DECLARE @JobCommand09 nvarchar(max)
  DECLARE @JobCommand10 nvarchar(max)
  DECLARE @JobCommand11 nvarchar(max)

  DECLARE @OutputFile01 nvarchar(max)
  DECLARE @OutputFile02 nvarchar(max)
  DECLARE @OutputFile03 nvarchar(max)
  DECLARE @OutputFile04 nvarchar(max)
  DECLARE @OutputFile05 nvarchar(max)
  DECLARE @OutputFile06 nvarchar(max)
  DECLARE @OutputFile07 nvarchar(max)
  DECLARE @OutputFile08 nvarchar(max)
  DECLARE @OutputFile09 nvarchar(max)
  DECLARE @OutputFile10 nvarchar(max)
  DECLARE @OutputFile11 nvarchar(max)

  SET @Version = CAST(LEFT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)),CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - 1) + '.' + REPLACE(RIGHT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)), LEN(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)))),'.','') AS numeric(18,10))

  IF @Version &gt;= 9.002047
  BEGIN
    SET @TokenServer = '$' + '(ESCAPE_SQUOTE(SRVR))'
    SET @TokenJobID = '$' + '(ESCAPE_SQUOTE(JOBID))'
    SET @TokenStepID = '$' + '(ESCAPE_SQUOTE(STEPID))'
    SET @TokenDate = '$' + '(ESCAPE_SQUOTE(STRTDT))'
    SET @TokenTime = '$' + '(ESCAPE_SQUOTE(STRTTM))'
  END
  ELSE
  BEGIN
    SET @TokenServer = '$' + '(SRVR)'
    SET @TokenJobID = '$' + '(JOBID)'
    SET @TokenStepID = '$' + '(STEPID)'
    SET @TokenDate = '$' + '(STRTDT)'
    SET @TokenTime = '$' + '(STRTTM)'
  END

  SELECT @BackupDirectory = Value
  FROM #Config
  WHERE [Name] = 'BackupDirectory'

  SELECT @OutputFileDirectory = Value
  FROM #Config
  WHERE [Name] = 'OutputFileDirectory'

  SELECT @LogToTable = Value
  FROM #Config
  WHERE [Name] = 'LogToTable'

  SELECT @DatabaseName = Value
  FROM #Config
  WHERE [Name] = 'DatabaseName'

  SET @JobDescription = 'Source: http://ola.hallengren.com'
  SET @JobCategory = 'Database Maintenance'
  SET @JobOwner = SUSER_SNAME(0x01)

  SET @JobName01 = 'DatabaseBackup - SYSTEM_DATABASES - FULL'
  SET @JobCommand01 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + @DatabaseName + ' -Q "EXECUTE [dbo].[DatabaseBackup] @Databases = ''SYSTEM_DATABASES'', @Directory = ' + ISNULL('N''' + REPLACE(@BackupDirectory,'''','''''') + '''','NULL') + ', @BackupType = ''FULL'', @Verify = ''Y'', @CleanupTime = 24, @CheckSum = ''Y''' + CASE WHEN @LogToTable = 'Y' THEN ', @LogToTable = ''Y''' ELSE '' END + '" -b'
  SET @OutputFile01 = @OutputFileDirectory + '\' + 'DatabaseBackup_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile01) &gt; 200 SET @OutputFile01 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile01) &gt; 200 SET @OutputFile01 = NULL

  SET @JobName02 = 'DatabaseBackup - USER_DATABASES - DIFF'
  SET @JobCommand02 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + @DatabaseName + ' -Q "EXECUTE [dbo].[DatabaseBackup] @Databases = ''USER_DATABASES'', @Directory = ' + ISNULL('N''' + REPLACE(@BackupDirectory,'''','''''') + '''','NULL') + ', @BackupType = ''DIFF'', @Verify = ''Y'', @CleanupTime = 24, @CheckSum = ''Y''' + CASE WHEN @LogToTable = 'Y' THEN ', @LogToTable = ''Y''' ELSE '' END + '" -b'
  SET @OutputFile02 = @OutputFileDirectory + '\' + 'DatabaseBackup_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile02) &gt; 200 SET @OutputFile02 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile02) &gt; 200 SET @OutputFile02 = NULL

  SET @JobName03 = 'DatabaseBackup - USER_DATABASES - FULL'
  SET @JobCommand03 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + @DatabaseName + ' -Q "EXECUTE [dbo].[DatabaseBackup] @Databases = ''USER_DATABASES'', @Directory = ' + ISNULL('N''' + REPLACE(@BackupDirectory,'''','''''') + '''','NULL') + ', @BackupType = ''FULL'', @Verify = ''Y'', @CleanupTime = 24, @CheckSum = ''Y''' + CASE WHEN @LogToTable = 'Y' THEN ', @LogToTable = ''Y''' ELSE '' END + '" -b'
  SET @OutputFile03 = @OutputFileDirectory + '\' + 'DatabaseBackup_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile03) &gt; 200 SET @OutputFile03 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile03) &gt; 200 SET @OutputFile03 = NULL

  SET @JobName04 = 'DatabaseBackup - USER_DATABASES - LOG'
  SET @JobCommand04 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + @DatabaseName + ' -Q "EXECUTE [dbo].[DatabaseBackup] @Databases = ''USER_DATABASES'', @Directory = ' + ISNULL('N''' + REPLACE(@BackupDirectory,'''','''''') + '''','NULL') + ', @BackupType = ''LOG'', @Verify = ''Y'', @CleanupTime = 24, @CheckSum = ''Y''' + CASE WHEN @LogToTable = 'Y' THEN ', @LogToTable = ''Y''' ELSE '' END + '" -b'
  SET @OutputFile04 = @OutputFileDirectory + '\' + 'DatabaseBackup_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile04) &gt; 200 SET @OutputFile04 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile04) &gt; 200 SET @OutputFile04 = NULL

  SET @JobName05 = 'DatabaseIntegrityCheck - SYSTEM_DATABASES'
  SET @JobCommand05 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + @DatabaseName + ' -Q "EXECUTE [dbo].[DatabaseIntegrityCheck] @Databases = ''SYSTEM_DATABASES''' + CASE WHEN @LogToTable = 'Y' THEN ', @LogToTable = ''Y''' ELSE '' END + '" -b'
  SET @OutputFile05 = @OutputFileDirectory + '\' + 'DatabaseIntegrityCheck_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile05) &gt; 200 SET @OutputFile05 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile05) &gt; 200 SET @OutputFile05 = NULL

  SET @JobName06 = 'DatabaseIntegrityCheck - USER_DATABASES'
  SET @JobCommand06 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + @DatabaseName + ' -Q "EXECUTE [dbo].[DatabaseIntegrityCheck] @Databases = ''USER_DATABASES''' + CASE WHEN @LogToTable = 'Y' THEN ', @LogToTable = ''Y''' ELSE '' END + '" -b'
  SET @OutputFile06 = @OutputFileDirectory + '\' + 'DatabaseIntegrityCheck_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile06) &gt; 200 SET @OutputFile06 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile06) &gt; 200 SET @OutputFile06 = NULL

  SET @JobName07 = 'IndexOptimize - USER_DATABASES'
  SET @JobCommand07 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + @DatabaseName + ' -Q "EXECUTE [dbo].[IndexOptimize] @Databases = ''USER_DATABASES''' + CASE WHEN @LogToTable = 'Y' THEN ', @LogToTable = ''Y''' ELSE '' END + '" -b'
  SET @OutputFile07 = @OutputFileDirectory + '\' + 'IndexOptimize_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile07) &gt; 200 SET @OutputFile07 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile07) &gt; 200 SET @OutputFile07 = NULL

  SET @JobName08 = 'sp_delete_backuphistory'
  SET @JobCommand08 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + 'msdb' + ' -Q "DECLARE @CleanupDate datetime SET @CleanupDate = DATEADD(dd,-30,GETDATE()) EXECUTE dbo.sp_delete_backuphistory @oldest_date = @CleanupDate" -b'
  SET @OutputFile08 = @OutputFileDirectory + '\' + 'sp_delete_backuphistory_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile08) &gt; 200 SET @OutputFile08 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile08) &gt; 200 SET @OutputFile08 = NULL

  SET @JobName09 = 'sp_purge_jobhistory'
  SET @JobCommand09 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + 'msdb' + ' -Q "DECLARE @CleanupDate datetime SET @CleanupDate = DATEADD(dd,-30,GETDATE()) EXECUTE dbo.sp_purge_jobhistory @oldest_date = @CleanupDate" -b'
  SET @OutputFile09 = @OutputFileDirectory + '\' + 'sp_purge_jobhistory_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile09) &gt; 200 SET @OutputFile09 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile09) &gt; 200 SET @OutputFile09 = NULL

  SET @JobName10 = 'Output File Cleanup'
  SET @JobCommand10 = 'cmd /q /c "For /F "tokens=1 delims=" %v In (''ForFiles /P "' + @OutputFileDirectory + '" /m *_*_*_*.txt /d -30 2^&gt;^&amp;1'') do if EXIST "' + @OutputFileDirectory + '"\%v echo del "' + @OutputFileDirectory + '"\%v&amp; del "' + @OutputFileDirectory + '"\%v"'
  SET @OutputFile10 = @OutputFileDirectory + '\' + 'OutputFileCleanup_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile10) &gt; 200 SET @OutputFile10 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile10) &gt; 200 SET @OutputFile10 = NULL

  SET @JobName11 = 'CommandLog Cleanup'
  SET @JobCommand11 = 'sqlcmd -E -S ' + @TokenServer + ' -d ' + @DatabaseName + ' -Q "DELETE FROM [dbo].[CommandLog] WHERE StartTime &lt; DATEADD(dd,-30,GETDATE())" -b'
  SET @OutputFile11 = @OutputFileDirectory + '\' + 'CommandLogCleanup_' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile11) &gt; 200 SET @OutputFile11 = @OutputFileDirectory + '\' + @TokenJobID + '_' + @TokenStepID + '_' + @TokenDate + '_' + @TokenTime + '.txt'
  IF LEN(@OutputFile11) &gt; 200 SET @OutputFile11 = NULL

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName01)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName01, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName01, @step_name = @JobName01, @subsystem = 'CMDEXEC', @command = @JobCommand01, @output_file_name = @OutputFile01
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName01
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName02)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName02, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName02, @step_name = @JobName02, @subsystem = 'CMDEXEC', @command = @JobCommand02, @output_file_name = @OutputFile02
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName02
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName03)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName03, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName03, @step_name = @JobName03, @subsystem = 'CMDEXEC', @command = @JobCommand03, @output_file_name = @OutputFile03
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName03
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName04)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName04, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName04, @step_name = @JobName04, @subsystem = 'CMDEXEC', @command = @JobCommand04, @output_file_name = @OutputFile04
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName04
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName05)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName05, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName05, @step_name = @JobName05, @subsystem = 'CMDEXEC', @command = @JobCommand05, @output_file_name = @OutputFile05
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName05
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName06)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName06, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName06, @step_name = @JobName06, @subsystem = 'CMDEXEC', @command = @JobCommand06, @output_file_name = @OutputFile06
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName06
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName07)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName07, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName07, @step_name = @JobName07, @subsystem = 'CMDEXEC', @command = @JobCommand07, @output_file_name = @OutputFile07
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName07
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName08)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName08, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName08, @step_name = @JobName08, @subsystem = 'CMDEXEC', @command = @JobCommand08, @output_file_name = @OutputFile08
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName08
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName09)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName09, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName09, @step_name = @JobName09, @subsystem = 'CMDEXEC', @command = @JobCommand09, @output_file_name = @OutputFile09
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName09
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName10)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName10, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName10, @step_name = @JobName10, @subsystem = 'CMDEXEC', @command = @JobCommand10, @output_file_name = @OutputFile10
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName10
  END

  IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE [name] = @JobName11)
  BEGIN
    EXECUTE msdb.dbo.sp_add_job @job_name = @JobName11, @description = @JobDescription, @category_name = @JobCategory, @owner_login_name = @JobOwner
    EXECUTE msdb.dbo.sp_add_jobstep @job_name = @JobName11, @step_name = @JobName11, @subsystem = 'CMDEXEC', @command = @JobCommand11, @output_file_name = @OutputFile11
    EXECUTE msdb.dbo.sp_add_jobserver @job_name = @JobName11
  END

END
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MARKOV_CHAIN</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>simulate_MarkovChain_with_SQL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MARKOV_CHAIN</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>simulate_MarkovChain_with_SQL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--simulate_MarkovChain_with_SQL

--OUTPUT
---------------
recno	a	b	pv
7	3	3	0.3300
8	3	2	0.6650
9	3	1	0.8325
10	3	0	0.9163
11	2	3	0.1650
12	2	2	0.4150
13	2	1	0.6238
14	2	0	0.7701

-------------------------------------
 --http://www.sqlserver-dba.com/2009/05/sql-and-markov-chains-in-tennis.html
--It is an example of simulating Markov Chain modelling with SQL Server 2000
IF OBJECT_ID('tempdb..#TtempNum') IS NOT NULL

	DROP TABLE #tempNum
    
GO
 
CREATE TABLE #tempNum (
 
[id] [int] NULL ,
 
[a] [int] NULL ,
 
[b] [int] NULL
 
) ON [PRIMARY]
 
GO
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(1,4,0)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(2,4,1)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(3,4,2)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(4,4,3)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(5,4,4)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(6,3,4)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(7,3,3)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(8,3,2)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(9,3,1)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(10,3,0)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(11,2,3)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(12,2,2)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(13,2,1)
 
INSERT INTO #tempNum ([id],[a],[b])VALUES(14,2,0)
 
 
 
GO
 
 
 
 
 
 
 
DECLARE @playerBReturn DECIMAL(10,4)
 
DECLARE @playerAserver DECIMAL(10,4)
 
SET @playerAserver = .50
 
SET @playerBReturn = 1-@playerAserver
 
 
 
begin
 
set nocount on
 
DECLARE @initCalc DECIMAL(10,8)
 
SET @initCalc = .33
 
 
 
create table #tmp (recno int identity, a int,b int,pv DECIMAL(10,4))
 
insert into #tmp (a,b,pv)
 
select a,b,1 from #tempNum  order by id ASC
 
declare @t int,@c int
 
DECLARE @tmpPV DECIMAL(10,8),@tmpPVUpdate DECIMAL(10,8)
 
DECLARE @tmpAplus INT, @tmpBplus INT  --+1
 
DECLARE @tmpA INT, @tmpB INT  --+1
 
set @t = (select count(*) from #tmp)
 
set @c = 1
 

 
while @c &lt;= @t
 
begin
 
IF @c &lt; 7
 
BEGIN
 
update #tmp
 
set pv = 1
 
where recno=@c
 
END
 
 
 
IF @c = 7
 
BEGIN
 
SET @tmpPV = @initCalc
 
END
 
ELSE IF @c &gt; 7
 
BEGIN
 
SET @tmpPV = (select pv from #tmp x where x.recno=@c-1)
 
END
 
 
 
 
 
IF @c = 7
 
BEGIN
 
update #tmp
 
set pv = @initCalc
 
where recno=@c
 
 
 
END
 
ELSE IF @c &gt; 7
 
BEGIN
 
--deal with 0
 
IF  ((SELECT b FROM #tmp x WHERE  x.recno=@c) IN (3)) SET @tmpPV =0
 
SET @tmpA = (SELECT a FROM #tmp x WHERE  x.recno=@c)
 
SET @tmpB = (SELECT b FROM #tmp x WHERE  x.recno=@c)
 
SET @tmpAplus = ((SELECT a FROM #tmp x WHERE  x.recno=@c) + 1)
 
SET @tmpBplus = ((SELECT b FROM #tmp x WHERE  x.recno=@c) + 1)
 
IF @tmpAplus = 3 AND @tmpBplus = 4  SET @tmpBplus=3
 
IF @tmpAplus = 2 AND @tmpBplus = 4  SET @tmpBplus=3
 
IF @tmpAplus = 1 AND @tmpBplus = 4  SET @tmpBplus=3
 
IF @tmpA = 2 AND @tmpB = 2  SET @tmpBplus = 2
 
IF @tmpA = 2 AND @tmpB = 1  SET @tmpBplus = 1
 
IF @tmpA = 2 AND @tmpB = 0  SET @tmpBplus = 0
 
IF @tmpA = 1 AND @tmpB = 2  SET @tmpBplus = 2
 
IF @tmpA = 1 AND @tmpB = 1  SET @tmpBplus = 1
 
IF @tmpA = 1 AND @tmpB = 0  SET @tmpBplus = 0
 
IF @tmpA = 0 AND @tmpB = 2  SET @tmpBplus = 2
 
IF @tmpA = 0 AND @tmpB = 1  SET @tmpBplus = 1
 
IF @tmpA = 0 AND @tmpB = 0  SET @tmpBplus = 0
 
SET @tmpPVUpdate = (SELECT pv FROM #tmp x WHERE  a = @tmpAplus  AND b = @tmpBplus)
 
update #tmp
 
set pv =  ((@playerAserver * @tmpPVUpdate) +  (@playerBReturn * @tmpPV))
 
where recno=@c
 
 
 
END
 
set @c = @c + 1
 
end


 
select recno,a,b,pv = pv from #tmp where a &lt;&gt; 4 AND b &lt;&gt; 4
 
 
 
DROP TABLE #tempNum
 
DROP TABLE #tmp
 
 
 
end
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>02_MERGE_from_BCC____prj_0010_001_CREATE_TABLE__T01__Employee.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>02_MERGE_from_BCC____prj_0010_001_CREATE_TABLE__T01__Employee.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0010_001_CREATE_TABLE__T01__Employee.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 2/18/2016
	By: glenn garson
	************************************************************************************
*/
USE [TRAIN]
GO

IF OBJECT_ID('dbo.T01__Employee') IS NOT NULL
    DROP TABLE dbo.T01__Employee

go

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

--Note: I tried to capitalize the fields that have matching definitions with Explorer
CREATE TABLE [dbo].[T01__Employee](
	[T01__Employee_PK] [int] IDENTITY(1,1) NOT NULL,
	[COMPANY] [char](3) NULL,
	[Employee_Explorer_RESOURCE_CODE] [char](20) NOT NULL,
	--[Employee_Name] [nvarchar](255) NULL,
	[Employee_Start_Date] [datetime] NULL,
	[Employee_Last_Worked_Date] [datetime] NULL,
	[Employee_Last_Job] [nvarchar](255) NULL,
	[Employee_Terminated_bool] [bit] NOT NULL,
	[Employee_PAY_TYPE] [char](2) NULL,
	[Employee_DIVISION] [char](9) NULL,
	[Employee_UNION_CODE] [char](9) NULL,
	[Employee_BASE_CLASS] [char](9) NULL,   
	[Employee_BASE_Position] [varchar](1024) NULL,		--&lt;============  varchar(1024) from Field1 in  [barriere].[dbo].[SCD_SYSTEMCODES]
	[Employee_EMPMASTER_Position] [varchar](50) NULL,	--&lt;============  varchar(50) from USER1 in EMPMASTER (PM and SM)
	[Employee_FIRST_NAME] [varchar](50) NULL,
	[Employee_Middle_Initial] [varchar](50) NULL, --&lt;====== from USER3 in SM_EMPMASTER 
	[Employee_LAST_NAME] [varchar](50) NULL,
	[Employee_Supervisor] [varchar](50) NULL,	-- From USER1 in HR_RESOURCEMASTER
	[EmployeeRecord_Inserted_Date] [datetime] NULL,
	[EmployeeRecord_Updated_Date] [datetime] NULL,
	[T01_RowVersion] [rowversion]
	,CONSTRAINT [T01$T01_PK] PRIMARY KEY NONCLUSTERED 
		(
			[T01__Employee_PK] ASC
		)
		WITH 
				(
					PAD_INDEX  = OFF, 
					STATISTICS_NORECOMPUTE  = OFF, 
					IGNORE_DUP_KEY = OFF, 
					ALLOW_ROW_LOCKS  = ON, 
					ALLOW_PAGE_LOCKS  = ON
				) ON [PRIMARY]
)
GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>02_MERGE_from_BCC____prj_0010_SP_213_MERGE_source_vw_0010_514__target__T01_Employee.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>02_MERGE_from_BCC____prj_0010_SP_213_MERGE_source_vw_0010_514__target__T01_Employee.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0010_SP_213_MERGE_source_vw_0010_514__target__T01_Employee.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 2/23/2016
	By: glenn garson
	************************************************************************************
*/

use TRAIN
go


alter Procedure prj_0010_SP_213_MERGE_source_vw_0010_514__target__T01_Employee
	as

MERGE 
		[TRAIN].[dbo].[T01__Employee] AS [Target]
		USING 
		[TRAIN].[dbo].[vw_0010_514_Source_For_T01] AS [Source]
		ON (Target.[Employee_Explorer_RESOURCE_CODE] = Source.[Employee_Explorer_RESOURCE_CODE] COLLATE DATABASE_DEFAULT)
		
WHEN MATCHED 
	AND
    (
      (Target.[COMPANY] &lt;&gt; Source.[COMPANY]  COLLATE DATABASE_DEFAULT)
      OR 
      (Target.[Employee_Explorer_RESOURCE_CODE]  &lt;&gt; Source.[Employee_Explorer_RESOURCE_CODE] COLLATE DATABASE_DEFAULT)
      OR 
      (Target.[Employee_Start_Date] &lt;&gt; Source.[Employee_Start_Date] )	--Simple test, b/c t appears to always be populated
      -- ==============================================================
      OR
      (
		(Target.[Employee_Last_Worked_Date] is NULL ) 
		AND
		(Source.[Employee_Last_Worked_Date] is NOT NULL) 
      ) 
      OR
      (
		(Target.[Employee_Last_Worked_Date] is NOT NULL) 
		AND
		(Source.[Employee_Last_Worked_Date] is NULL) 
      )       
       OR
      (
		(Target.[Employee_Last_Worked_Date] is NOT NULL) 
		AND
		(Source.[Employee_Last_Worked_Date] is NOT NULL) 
		AND
		(Target.[Employee_Last_Worked_Date] &lt;&gt; Source.[Employee_Last_Worked_Date] )
      )      
      -- ==============================================================      
      OR 
      (Target.[Employee_Last_Job]  &lt;&gt; Source.[Employee_Last_Job]   COLLATE DATABASE_DEFAULT)    
      OR
      (Target.[Employee_Terminated_bool] &lt;&gt; Source.[Employee_Terminated_bool]) --  COLLATE DATABASE_DEFAULT)      
       OR 
      (Target.[Employee_PAY_TYPE]  &lt;&gt; Source.[Employee_PAY_TYPE]  COLLATE DATABASE_DEFAULT)     
        OR 
      (Target.[Employee_DIVISION]  &lt;&gt; Source.[Employee_DIVISION]  COLLATE DATABASE_DEFAULT)      
         OR 
      (Target.[Employee_UNION_CODE]  &lt;&gt; Source.[Employee_UNION_CODE]  COLLATE DATABASE_DEFAULT)     
         OR 
      (Target.[Employee_BASE_CLASS]  &lt;&gt; Source.[Employee_BASE_CLASS]  COLLATE DATABASE_DEFAULT)        
          OR 
      (Target.[Employee_BASE_Position]  &lt;&gt; Source.[Employee_BASE_Position]  COLLATE DATABASE_DEFAULT)       
          OR 
      (Target.[Employee_EMPMASTER_Position]  &lt;&gt; Source.[Employee_EMPMASTER_Position]  COLLATE DATABASE_DEFAULT)  
           OR 
      (Target.[Employee_FIRST_NAME]  &lt;&gt; Source.[Employee_FIRST_NAME]  COLLATE DATABASE_DEFAULT)       
           OR 
      (Target.[Employee_Middle_Initial]  &lt;&gt; Source.[Employee_Middle_Initial]  COLLATE DATABASE_DEFAULT)       
           OR 
      (Target.[Employee_LAST_NAME]  &lt;&gt; Source.[Employee_LAST_NAME] COLLATE DATABASE_DEFAULT)         
           OR 
      (Target.[Employee_Supervisor]  &lt;&gt; Source.[Employee_Supervisor]  COLLATE DATABASE_DEFAULT)              
      
    )
    THEN UPDATE SET
       Target.[COMPANY] = Source.[COMPANY]
      ,Target.[Employee_Explorer_RESOURCE_CODE]  = Source.[Employee_Explorer_RESOURCE_CODE]
      ,Target.[Employee_Start_Date] = Source.[Employee_Start_Date]
      ,Target.[Employee_Last_Worked_Date] = Source.[Employee_Last_Worked_Date]
      ,Target.[Employee_Last_Job]  = Source.[Employee_Last_Job]
      ,Target.[Employee_Terminated_bool] = Source.[Employee_Terminated_bool]
      ,Target.[Employee_PAY_TYPE]  = Source.[Employee_PAY_TYPE]
      ,Target.[Employee_DIVISION]  = Source.[Employee_DIVISION]
      ,Target.[Employee_UNION_CODE]  = Source.[Employee_UNION_CODE]
      ,Target.[Employee_BASE_CLASS]  = Source.[Employee_BASE_CLASS]
      ,Target.[Employee_BASE_Position]  = Source.[Employee_BASE_Position]
      ,Target.[Employee_EMPMASTER_Position]  = Source.[Employee_EMPMASTER_Position]
      ,Target.[Employee_FIRST_NAME]  = Source.[Employee_FIRST_NAME]
      ,Target.[Employee_Middle_Initial]  = Source.[Employee_Middle_Initial]
      ,Target.[Employee_LAST_NAME]  = Source.[Employee_LAST_NAME]
      ,Target.[Employee_Supervisor]  = Source.[Employee_Supervisor]
      ,Target.[EmployeeRecord_Updated_Date]= GETDATE()
    
WHEN NOT MATCHED BY Target					--&lt;==  defaulting to ‘WHEN NOT MATCHED BY TARGET’
    THEN INSERT  (
				   [COMPANY]
				  ,[Employee_Explorer_RESOURCE_CODE]
				  ,[Employee_Start_Date]
				  ,[Employee_Last_Worked_Date]
				  ,[Employee_Last_Job]
				  ,[Employee_Terminated_bool]
				  ,[Employee_PAY_TYPE]
				  ,[Employee_DIVISION]
				  ,[Employee_UNION_CODE]
				  ,[Employee_BASE_CLASS]			--
				  ,[Employee_BASE_Position]			--
				  ,[Employee_EMPMASTER_Position]	--
				  ,[Employee_FIRST_NAME]
				  ,[Employee_Middle_Initial]
				  ,[Employee_LAST_NAME]
				  ,[Employee_Supervisor]
				  ,[EmployeeRecord_Inserted_Date]
				  ,[EmployeeRecord_Updated_Date]
			      ) 
      VALUES (
				Source.[COMPANY]
				,Source.[Employee_Explorer_RESOURCE_CODE]
				,Source.[Employee_Start_Date]
				,Source.[Employee_Last_Worked_Date]
				,Source.[Employee_Last_Job]
				,Source.[Employee_Terminated_bool]
				,Source.[Employee_PAY_TYPE]
				,Source.[Employee_DIVISION]
				,Source.[Employee_UNION_CODE]
				,Source.[Employee_BASE_CLASS]			--
				,Source.[Employee_BASE_Position]			--
				,Source.[Employee_EMPMASTER_Position]	--
				,Source.[Employee_FIRST_NAME]
				,Source.[Employee_Middle_Initial]
				,Source.[Employee_LAST_NAME]
				,Source.[Employee_Supervisor]
				,GETDATE()
				,GETDATE()
		      )

WHEN NOT MATCHED BY SOURCE
	AND (Target.[Employee_Terminated_bool] = 0 )
    THEN UPDATE SET
        Target.[Employee_Terminated_bool] = 1  
        ,Target.[EmployeeRecord_Updated_Date]= GETDATE();</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>02_MERGE_from_BCC____vw_0010_514_Source_For_T01.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>02_MERGE_from_BCC____vw_0010_514_Source_For_T01.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--vw_0010_514_Source_For_T01.sql

/*
	************************************************************************************
	NOTE: Use this view to initially INSERT INTO T01__Employee with 'prj_0010_301_INSERT_INTO_T01_from_SELECT.sql'
		  Then use it to determine what to modify or add to T01 in the future
	Uses: 
	Created: 2/22/2016
	MODIFIED: 
	By: glenn garson
	************************************************************************************
*/

use [TRAIN]
go

IF OBJECT_ID('vw_0010_514_Source_For_T01', 'V') IS NOT NULL
DROP view vw_0010_514_Source_For_T01
GO


create VIEW vw_0010_514_Source_For_T01 AS
--==============================================

SELECT 
	  L1.[COMPANY] 
      ,L1.[EMPLOYEE] as [Employee_Explorer_RESOURCE_CODE]
      ,(SELECT CAST(L1.[START_DATE] AS DATE)) as [Employee_Start_Date]
      ,(SELECT CAST(L1.[LAST_WORKED] AS DATE)) as [Employee_Last_Worked_Date]
      ,L1.[LAST_JOB] as [Employee_Last_Job]
      --,L1.[TERMINATED] as [Employee_Termination_Date]			--NULLS are causing a problem
  	  ,	(SELECT     'TheCalculation' = 
        		CASE 
            			WHEN ( ([TERMINATED] IS NULL ) OR ([TERMINATED] = '') )
            			THEN 0
        		 
				ELSE 1

        			END) as [Employee_Terminated_bool]      
      ,L1.[PAY_TYPE] as [Employee_PAY_TYPE]
      ,L1.[DIVISION] as [Employee_DIVISION]
      ,L1.[UNION_CODE] as [Employee_UNION_CODE]
      ,L1.[BASE_CLASS] as [Employee_BASE_CLASS]
      ,R2.Job_Position as [Employee_BASE_Position]				--&lt;==  varchar(1024) from Field1 in  [barriere].[dbo].[SCD_SYSTEMCODES]
      ,L1.Job_Position as [Employee_EMPMASTER_Position]			--&lt;==  varchar(50) from USER1 in EMPMASTER (PM and SM)      
      ,L1.[First_Name] as [Employee_FIRST_NAME]
      ,L1.[Middle_Initial] as [Employee_Middle_Initial]
      ,L1.[Last_Name] as [Employee_LAST_NAME]
      ,R1.USER1 AS [Employee_Supervisor]
      
      

  FROM
		( 
			[TRAIN].[dbo].[vw_0010_509_Combined_EMPMASTER] L1
			left outer join
			[TRAIN].[dbo].[vw_0010_506_barriere_vwHR_RESOURCEMASTER] R1
			on L1.EMPLOYEE = R1.RESOURCE_CODE
		)
		LEFT OUTER JOIN
		[TRAIN].[dbo].[vw_0010_513_PM_and_SM_Positions_LIST] R2		
		on L1.[BASE_CLASS] = R2.CODE
		
		
  WHERE TERMINATED is null	
	
--===============================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>1_EXAMPLE__CreateTables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>1_EXAMPLE__CreateTables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
/***********************************************************************
*
* Script to accompany the Frog-Blog post 
*           'Introduction to T-SQL Merge Basics'
*
* http://www.purplefrogsystems.com/blog/2011/12/introduction-to-t-sql-merge-basics
*
* Author: Alex Whittles
*         Purple Frog Systems
*         13th December 2011
*
* This information is provided "AS IS" with no warranties, confers no rights
*  and is used entirely at the users own risk.
*
***********************************************************************/

--Create the main Customer table
CREATE TABLE [dbo].[Customer](
	[CustomerID] [int] IDENTITY(1,1) NOT NULL,
	[FirstName] [varchar](50) NOT NULL,
	[LastName] [varchar](50) NOT NULL,
	[Title] [varchar](10) NOT NULL,
	[DoB] [date] NOT NULL,
	[Email] [varchar](100) NOT NULL,
	[IsActive] bit NOT NULL,
	[DTInserted] [datetime] NOT NULL,
	[DTUpdated] [datetime] NOT NULL,
 CONSTRAINT [PK_Customer] PRIMARY KEY CLUSTERED 
(
	[CustomerID] ASC
))


--Create a staging table to hold new/updated customers
CREATE TABLE [dbo].[StagingCustomer](
	[FirstName] [varchar](50) NOT NULL,
	[LastName] [varchar](50) NOT NULL,
	[Title] [varchar](10) NOT NULL,
	[DoB] [date] NOT NULL,
	[Email] [varchar](100) NOT NULL
)


--Populate Customer table with existing customers
INSERT INTO Customer
        ( FirstName
        ,LastName
        ,Title
        ,DoB
        ,Email
        ,IsActive
        ,DTInserted
        ,DTUpdated )
VALUES
        ( 'Dave',  'Robinson', 'Mr',   '1976-02-26', 'Dave@Robinson.com',    1, '2010-01-01 12:00', '2010-01-01 12:00')
       ,( 'Phil',  'Jones',    'Mr',   '1971-05-13', 'Phil@PhilJones.com',   1, '2010-01-01 12:00', '2010-01-01 12:00')
       ,( 'Sarah', 'Dawson',   'Mrs',  '1965-10-22', 'Sarah@TheDawsons.com', 1, '2010-01-01 12:00', '2010-01-01 12:00')
       ,( 'Andy',  'Powell',   'Dr',   '1948-03-01', 'Andy@emailme.com',     1, '2010-01-01 12:00', '2010-01-01 12:00')
       ,( 'Jane',  'Smith',    'Miss', '1984-07-19', 'Jane@emailme.com',     1, '2010-01-01 12:00', '2010-01-01 12:00')
    
    
--Populate the staging table with the new set of customers to be imported
INSERT INTO StagingCustomer
        ( FirstName
        ,LastName
        ,Title
        ,DoB
        ,Email)
VALUES
        ( 'Dave',  'Robinson', 'Mr',   '1976-02-26', 'Dave@Robinson.com')  --No change
       ,( 'Phil',  'Jones',    'Mr',   '1971-05-14', 'Phil@PhilJones.com') --Updated DoB
       ,( 'Jack',  'White',    'Mr',   '1979-01-05', 'Jack@JackWhite.com') --New customer
       ,( 'Jane',  'King',     'Mrs',  '1984-07-19', 'Jane@emailme.com')   --Updated Surname &amp; Title
       ,( 'Mary',  'Scott',    'Mrs',  '1981-02-20', 'Mary@ScottMail.com') --New customer



/*
MERGE Customer        AS [Target]
USING StagingCustomer AS [Source]
   ON Target.Email = Source.Email
WHEN MATCHED AND
    (
      Target.FirstName   &lt;&gt; Source.FirstName
      OR Target.LastName &lt;&gt; Source.LastName
      OR Target.Title    &lt;&gt; Source.Title
      OR Target.DoB      &lt;&gt; Source.DoB
    )
    THEN UPDATE SET
       FirstName = Source.FirstName
      ,LastName  = Source.LastName
      ,Title     = Source.Title
      ,DoB       = Source.DoB
      ,DTUpdated = GETDATE()
WHEN NOT MATCHED BY TARGET
    THEN INSERT (
        Email
       ,FirstName
       ,LastName
       ,Title
       ,DoB
       ,IsActive
       ,DTInserted
       ,DTUpdated
      ) VALUES (
        Source.Email
       ,Source.FirstName
       ,Source.LastName
       ,Source.Title
       ,Source.DoB
       ,1
       ,GETDATE()
       ,GETDATE()
      )
WHEN NOT MATCHED BY SOURCE
    THEN UPDATE SET
        IsActive = 0
      ;
*/     </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>1_EXAMPLE__MERGE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>1_EXAMPLE__MERGE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>/*
Firstly lets define the logic that we’re looking for.

Our new customer data doesn’t include the CustomerID, 
	so we can’t match on the primary key. 
	Instead we’ll use the email address as the key.

If the customer already exists then we want to check whether the fields are different, 
	if they are then update the customer record.

If the customer doesn’t exist then insert them as a new customer record.

The Customer table contains audit fields which must be maintained. 
DTInserted should contain the datetime when the record was first created. 
DTUpdated should be updated whenever any of the data in a row is changed.
This is all performed using the following statement

*/

MERGE Customer        AS [Target]
USING StagingCustomer AS [Source]
   ON Target.Email = Source.Email
WHEN MATCHED AND
    (
         Target.FirstName &lt;&gt; Source.FirstName
      OR Target.LastName  &lt;&gt; Source.LastName
      OR Target.Title     &lt;&gt; Source.Title
      OR Target.DoB       &lt;&gt; Source.DoB
    )
    THEN UPDATE SET
       FirstName = Source.FirstName
      ,LastName  = Source.LastName
      ,Title     = Source.Title
      ,DoB       = Source.DoB
      ,DTUpdated = GETDATE()		--&lt;==  DTUpdated should be updated whenever any of the data in a row is changed.
      
--NOTE: the field order, then the corresponding VALUES      
WHEN NOT MATCHED					--&lt;== If we look at the ‘WHEN NOT MATCHED’ line, what this is actually doing is defaulting to ‘WHEN NOT MATCHED BY TARGET’
    THEN INSERT  (
			        Email
			       ,FirstName
			       ,LastName
			       ,Title
			       ,DoB
			       ,DTInserted
			       ,DTUpdated
			      ) 
      VALUES (
		        Source.Email
		       ,Source.FirstName
		       ,Source.LastName
		       ,Source.Title
		       ,Source.DoB
		       ,GETDATE()
		       ,GETDATE()
		      );
      
--We can add:
--============================
--WHEN NOT MATCHED BY SOURCE
--    THEN DELETE
--============================
--Which will simply delete the row in the Customer table, 
--	or we could update the record and terminate it using something like this.

WHEN NOT MATCHED BY SOURCE
    THEN UPDATE SET
        IsActive = 0      </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>about_MERGE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>about_MERGE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_MERGE

--Locking problem at Barriere: Look into HOLDLOCK
--HOLDLOCK means SERALIZABLE and therefore allows SELECTS, but blocks UPDATE and DELETES of the rows selected by T1, 
--	as well as any INSERT in the range selected by T1 (which is the entire table, therefore any insert).
--HOLDLOCKS are used at table level it prevents the table from being updated by any other DML transactions like an insert or an update. 
--	HOLDLOCKS are preferable to use in situations where we need only COMMITTED READS.

--NOLOCKS are opposite of HOLDLOCKS and when they are issued at a table level, 
--	it allows the user to access/read the data from a table whilst some update/ insert operations are running at the back. 
--	NOLOCKS may produce UNCOMMITTED READS and are preferred to use at the Production Environments so that the real time update is not hindered.

/*
MERGE inserts and updates data at the same time
we need to provide a source table and a destination table. 
We then give it a method of matching rows between them, 
 usually the primary key or business/natural key (this can use multiple fields).
We can then specify a number of actions depending on whether a match is found or not.
If a match is found we may want to update the existing record.
If a match isn’t found then it’s likely that we’ll want to insert a new record.
	
This feature is very useful in a scenario where we want to synchronize the data in the target table with source table data. 
	In earlier versions of sql server to achieve this synchronization we would have scanned the source and target tables multiple times
	(i.e. ones for inserting the new records , 
	second time for updating the matching records and third time for deleting the records in the destination table 
	which are not present in the source table), 
	but with Merge statement we can achieve all this with single statement 
	and with only one time looking-up of the source and target tables.	
	
http://www.purplefrogsystems.com/blog/2011/12/introduction-to-t-sql-merge-basics/	

First we set the tables and the joining key(s)		*/

MERGE [Destination Table] AS Target
   USING [Source Table] AS Source
     ON Target.KeyField = Source.KeyField

--Then we define what we want to happen if we find a match (optional)

  WHEN MATCHED

--If you want you can specify other conditions, such as checking whether anything has changed

     AND  (
         Target.Field1 &lt;&gt; Source.Field1
         OR Target.Field2 &lt;&gt; Source.Field2
         )
         
--We can then perform an action. i.e. an update, delete, etc.

  THEN UPDATE SET
        Field1 = Source.Field1
      , Field2 = Source.Field2

--Then we define what we want to happen if we don’t find a matching record (optional)

   WHEN NOT MATCHED

--In this case, we want to insert the new record

      THEN INSERT (
             KeyField
           , Field1
           , Field2
        ) VALUES (
             Source.KeyField
           , Source.Field1
           , Source.Field2
      );</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Example_Merge_Match_UPDATE_INSERT_DELETE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Example_Merge_Match_UPDATE_INSERT_DELETE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


--1] First create a Source Table with Sample Data:

CREATE TABLE dbo.EmployeeSource(Id INT, Name VARCHAR(50))
GO
INSERT INTO dbo.EmployeeSource
VALUES(1,'Basavaraj Biradar') ,  
  (3,'Monty')
GO
SELECT * FROM dbo.EmployeeSource WITH(NOLOCK)
GO

/* 2] Source Table Data
Id Name
1  Basavaraj Biradar
3  Monty
Now create a Target Table with Sample Data:
*/

CREATE TABLE dbo.EmployeeTarget(Id INT, Name VARCHAR(50))
GO
INSERT INTO dbo.EmployeeTarget
VALUES(1,'Basavaraj') ,
  (2,'Shashank')
GO
SELECT * FROM dbo.EmployeeTarget WITH(NOLOCK)
GO

/*Target Table Data
Id Name
1  Basavaraj
2  Shashank

3] Now Syncronize the target table with source table data using the below Merge statement:
*/


MERGE dbo.EmployeeTarget AS T
USING dbo.EmployeeSource AS S
 ON T.Id = S.Id
WHEN MATCHED THEN -- Matching Employee record
  UPDATE SET T.NAME = S.NAME
WHEN NOT MATCHED BY TARGET THEN
-- Employee record presnet in Source but not in target
  INSERT (Id, Name)
  VALUES (S.Id, S.Name)
WHEN NOT MATCHED BY SOURCE THEN
-- Employee record present in destination but not in source
   DELETE;                                                     --&lt;=== MUST end in semicolon


--Target table data after executing the above Merge statement:

SELECT * FROM dbo.EmployeeTarget WITH(NOLOCK)
GO

/*Target Table Data
Id Name
1  Basavaraj Biradar
3  Monty
*/
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Insert_results_From_MERGE_into_another_table_via_TEMP_table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Insert_results_From_MERGE_into_another_table_via_TEMP_table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://stackoverflow.com/questions/8337304/using-merge-in-sql-server-to-update-a-third-table

-- Your table A, B and C
declare @A table(ID int, Col int)
declare @B table(ID int, Col int)
declare @C table(ID int, Col int)

-- Sample data
insert into @A values (1, 1),(2, 2)
insert into @B values (1, 0)
insert into @C values (1, 0),(2, 0)
/*
STARTS OUT AS:
@A	ID	Col
	1	1
	2	2
	
@B	ID	Col
	1	0

	
@T	ID	Col	Act
	.	.	.

@C	ID	Col
	1	0
	2	0			
	
*/
-- Table var to store ouput from merge
declare @T table(ID int, Col int, Act varchar(10))

-- Merge A -&gt; B
merge @B as B
using @A as A
on A.ID = B.ID
when not matched then insert (ID, Col) values(A.ID, A.Col)
when matched then update set Col = A.Col
output inserted.ID, inserted.Col, $action into @T;

-- Update C with rows that where updated by merge    
update C 
set Col = T.Col
from 
		@C as C
		inner join 
		@T as T
		on 
			(C.ID = T.ID) 
			and
			(T.Act = 'UPDATE')  -- just the ones that were updated, not the 'INSERT' records
       
SELECT * FROM @A    
SELECT * FROM @B  
SELECT * FROM @T
SELECT * FROM @C  
/*
ENDS AS:
@A	ID	Col
	1	1
	2	2
	
@B	ID	Col
	1	1
	2	2

	
@T	ID	Col	Act
	2	2	INSERT
	1	1	UPDATE

@C	ID	Col
	1	1		--&lt;== This one was UPDATEd, so this one was changed
	2	0		--&lt;== This one was not UPDATEd, so no change
	
*/   

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


use TRAIN
go


--CREATE Procedure prj_0010_SP_214_MERGE_source_vw_0010_501__target__T03_TRAINING_TYPE
--	as


declare @T table([Action] nvarchar(50), T03__TRAINING_TYPE_FK int, Sub_CLASS_NAME nvarchar(max), Sub_CLASS_Description nvarchar(max))	
	

MERGE 
		[TRAIN].[dbo].[T03__TRAINING_TYPE] AS [Target]
		USING 
		[TRAIN].[dbo].[vw_0010_515_Source_For_T03] AS [Source]
		ON (Target.[Explorer_TRAINING_TYPE] = Source.[Explorer_TRAINING_TYPE]) 
		
WHEN MATCHED 
	AND
	(
	  (Target.[Explorer_Description] &lt;&gt; Source.[Explorer_Description] )                   
	)
	THEN UPDATE SET
	   Target.[Explorer_Description] = Source.[Explorer_Description]
	  ,Target.[TRAINING_TYPE_Updated_Date]= GETDATE()

WHEN NOT MATCHED BY Target					--&lt;== 
	THEN INSERT  (
				   [Explorer_Description]
				  ,[Explorer_TRAINING_TYPE]
				  ,[Level_1_Grouping]
				  ,[TRAINING_TYPE_Inserted_Date]
				  ,[TRAINING_TYPE_Updated_Date]
				  ) 
	  VALUES (
				Source.[Explorer_Description]
				,Source.[Explorer_TRAINING_TYPE]
				,Source.[Level_1_Grouping]
				,GETDATE()
				,GETDATE()
			  )

WHEN NOT MATCHED BY SOURCE
	AND
	(
	  Target.[TRAINING_TYPE_is_Active_bool] = 1                    
	)
	THEN UPDATE SET
		Target.[TRAINING_TYPE_is_Active_bool] = 0  
		,Target.[TRAINING_TYPE_Updated_Date]= GETDATE()
OUTPUT 
	$action,
	Inserted.T03__TRAINING_TYPE_PK,
	CONVERT(nvarchar(255),Inserted.[Explorer_TRAINING_TYPE]) AS [Sub_CLASS_NAME],
	CONVERT(nvarchar(max),Inserted.[Explorer_Description]) AS [Sub_CLASS_Description]
into @T;

select * from @T

INSERT INTO [TRAIN].[dbo].[T03b_Sub_TRAINING_TYPE] (
														Sub_CLASS_LEVEL,
														T03__TRAINING_TYPE_FK,
														Sub_CLASS_NAME,
														Sub_CLASS_Description
														
													)
SELECT 
		0 as Sub_CLASS_LEVEL,								--&lt;== DATA Manipulation
		T03__TRAINING_TYPE_FK,
		(SELECT 'TheCalculation' = 'Suggested Class Name: ' + RTRIM(LTRIM(Sub_CLASS_NAME)) ) as Sub_CLASS_NAME,
		(SELECT 'TheCalculation' = 'Suggested Class Description: ' + Sub_CLASS_Description ) as Sub_CLASS_Description
FROM @T
WHERE [Action] = 'INSERT'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Inserting the results of the MERGE statement into another table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Inserting the results of the MERGE statement into another table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://technet.microsoft.com/en-us/library/bb510625.aspx#sectionToggle2
/*
The following example captures data returned from the OUTPUT clause of a MERGE statement 
	and inserts that data into another table. 
The MERGE statement updates the Quantity column of the ProductInventory table in the AdventureWorks2012 database, 
	based on orders that are processed in the SalesOrderDetail table. 
The example captures the rows that are updated and inserts them into another table that is used to track inventory changes.
*/

CREATE TABLE Production.UpdatedInventory
    (
	    ProductID INT NOT NULL, 
	    LocationID int, 
	    NewQty int, 
	    PreviousQty int,
    CONSTRAINT PK_Inventory 
    	PRIMARY KEY CLUSTERED (ProductID, LocationID));
GO

INSERT INTO Production.UpdatedInventory
SELECT 
		ProductID, 
		LocationID, 
		NewQty, 
		PreviousQty 
FROM
	(  -- The 'OUTPUT' from this merge is INSERT INTO the table above===========  
			MERGE Production.ProductInventory AS pi
			USING (
							SELECT 
									ProductID, 
									SUM(OrderQty) 
							FROM 
									Sales.SalesOrderDetail AS sod
									JOIN 
									Sales.SalesOrderHeader AS soh
									ON 
										(
											sod.SalesOrderID = soh.SalesOrderID
											AND 
											soh.OrderDate BETWEEN '20030701' AND '20030731'
										)
							GROUP BY ProductID
				) AS src (ProductID, OrderQty)
    
				ON (pi.ProductID = src.ProductID)
				WHEN MATCHED AND (pi.Quantity - src.OrderQty &gt;= 0) 
					THEN UPDATE SET 
									pi.Quantity = pi.Quantity - src.OrderQty
				WHEN MATCHED AND (pi.Quantity - src.OrderQty &lt;= 0) 
					THEN DELETE
				OUTPUT 
						$action, 
						Inserted.ProductID, 
						Inserted.LocationID, 
						Inserted.Quantity AS NewQty, 
						Deleted.Quantity AS PreviousQty
		-- =======================================================================
	)
 AS Changes (Action, ProductID, LocationID, NewQty, PreviousQty) WHERE Action = 'UPDATE';		--&lt;=== There is the semicolon
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>MERGE_OUTPUT_to_TableVariable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>MERGE_OUTPUT_to_TableVariable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.simple-talk.com/sql/learn-sql-server/the-merge-statement-in-sql-server-2008/
https://www.simple-talk.com/sql/learn-sql-server/implementing-the-output-clause-in-sql-server-2008/
/*
The OUTPUT clause returns a copy of the data that you’ve inserted into or deleted from your tables. 
When used with a MERGE statement, 
the clause provides you with a powerful tool for capturing the modified data for archiving, messaging, or application purposes.


*/

--You can also use the output like this:
-------------------------------------
OUTPUT $action, inserted.*, deleted.*
-------------------------------------

--Two EXAMPLES of this

FIRST
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IF OBJECT_ID ('Books', 'U') IS NOT NULL
DROP TABLE dbo.Books;
 
CREATE TABLE dbo.Books
(
  BookID int NOT NULL PRIMARY KEY,
  BookTitle nvarchar(50) NOT NULL,
  ModifiedDate datetime NOT NULL
);

-- declare @InsertOutput1 table variable
DECLARE @InsertOutput1 table
(
  BookID int,
  BookTitle nvarchar(50),
  ModifiedDate datetime
);
 
-- insert new row into Books table
INSERT INTO Books
OUTPUT INSERTED.*
  INTO @InsertOutput1
VALUES(101, 'One Hundred Years of Solitude', GETDATE());
 
-- view inserted row in Books table
SELECT * FROM Books;
 
-- view output row in @InsertOutput1 variable
SELECT * FROM @InsertOutput1;


-- create second table and populate
IF OBJECT_ID ('Books2', 'U') IS NOT NULL
DROP TABLE dbo.Books2;
 
CREATE TABLE dbo.Books2
(
  BookID int NOT NULL PRIMARY KEY,
  BookTitle nvarchar(50) NOT NULL,
  ModifiedDate datetime NOT NULL
);
 
INSERT INTO Books2
VALUES(101, '100 Years of Solitude', GETDATE());
 
INSERT INTO Books2
VALUES(102, 'Pride &amp; Prejudice', GETDATE());
            Once we’ve created the Books2 table, we can try a MERGE statement. In the following example, I declare the @MergeOutput1 variable, merge data from the Books table into the Books2 table, and view the results:
-- declare @MergeOutput1 table variable
DECLARE @MergeOutput1 table
(
  ActionType nvarchar(10),				--&lt;=== This stores the $action
  BookID int,
  OldBookTitle nvarchar(50),
  NewBookTitle nvarchar(50),
  ModifiedDate datetime
);
 
-- use MERGE statement to perform update on Book2
MERGE Books2 AS b2
USING Books AS b1
ON (b2.BookID = b1.BookID)
WHEN MATCHED
THEN UPDATE
SET b2.BookTitle = b1.BookTitle
OUTPUT
    $action,							--&lt;=======  This captures the action (INSERT, DELETE) nvarchar(10): INSERT, UPDATE, DELETE
    INSERTED.BookID,
    DELETED.BookTitle,
    INSERTED.BookTitle,
    INSERTED.ModifiedDate
  INTO @MergeOutput1;
 
-- view Books table
SELECT * FROM Books;
 
-- view updated rows in Books2 table
SELECT * FROM Books2;
 
-- view output rows in @MergeOutput1 variable
SELECT * FROM @MergeOutput1;

SECOND
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IF OBJECT_ID( 'tempdb..#CustomerChanges') IS NOT NULL DROP TABLE #CustomerChanges;
 
CREATE TABLE #CustomerChanges(
  ChangeType         NVARCHAR(10)
 ,CustomerNum        TINYINT NOT NULL
 ,NewCustomerName    VARCHAR(25) NULL
 ,PrevCustomerName   VARCHAR(25) NULL
 ,NewPlanet          VARCHAR(25) NULL
 ,PrevPlanet         VARCHAR(25) NULL
 ,UserName           NVARCHAR(100) NOT NULL
 ,DateTimeChanged    DateTime NOT NULL);
 
MERGE  #Customer_New AS Target
 USING #Customer_Orig AS Source
    ON Target.CustomerNum = Source.CustomerNum
WHEN MATCHED AND EXISTS
                    (SELECT Source.CustomerName, Source.Planet
                     EXCEPT
                     SELECT Target.CustomerName, Target.Planet)
THEN
   UPDATE SET
      Target.CustomerName = Source.CustomerName,
      Target.Planet = Source.Planet
WHEN NOT MATCHED BY TARGET
THEN
   INSERT (CustomerNum, CustomerName, Planet)
   VALUES (Source.CustomerNum, Source.CustomerName, Source.Planet)
WHEN NOT MATCHED BY SOURCE THEN DELETE
-------------------------------------
OUTPUT
   $ACTION ChangeType,
   coalesce (inserted.CustomerNum, deleted.CustomerNum) CustomerNum,
   inserted.CustomerName NewCustomerName,
   deleted.CustomerName PrevCustomerName,
   inserted.Planet NewPlanet,
   deleted.Planet PrevPlanet,
   SUSER_SNAME() UserName,
   Getdate () DateTimeChanged
    INTO #CustomerChanges
-------------------------------------
;
 
SELECT * FROM #CustomerChanges;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>MERGE_with_COLLATE_conflict</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>MERGE_with_COLLATE_conflict</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>MERGE dbo.[T_table] AS Target
USING myTable AS Source
ON (Target.a= Source.a COLLATE DATABASE_DEFAULT)	--&lt;===============
WHEN NOT MATCHED BY TARGET
THEN INSERT(a, b) VALUES(Source.a, Source.b)
WHEN MATCHED
THEN UPDATE SET Target.b= Source.b
WHEN NOT MATCHED BY SOURCE
THEN DELETE;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MERGE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SP_MERGE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MERGE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SP_MERGE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0010_SP_213_MERGE_source_vw_0010_514__target__T01_Employee.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 2/23/2016
	By: glenn garson
	************************************************************************************
*/

use TRAIN
go


alter Procedure prj_0010_SP_213_MERGE_source_vw_0010_514__target__T01_Employee
	as

MERGE 
		[TRAIN].[dbo].[T01__Employee] AS [Target]
		USING 
		[TRAIN].[dbo].[vw_0010_514_Source_For_T01] AS [Source]
		ON (Target.[Employee_Explorer_RESOURCE_CODE] = Source.[Employee_Explorer_RESOURCE_CODE] COLLATE DATABASE_DEFAULT)
		
WHEN MATCHED 
	AND
    (
      (Target.[COMPANY] &lt;&gt; Source.[COMPANY]  COLLATE DATABASE_DEFAULT)
      OR 
      (Target.[Employee_Explorer_RESOURCE_CODE]  &lt;&gt; Source.[Employee_Explorer_RESOURCE_CODE] COLLATE DATABASE_DEFAULT)
      OR 
      (Target.[Employee_Start_Date] &lt;&gt; Source.[Employee_Start_Date] )	--Simple test, b/c t appears to always be populated
      -- ==============================================================
      OR
      (
		(Target.[Employee_Last_Worked_Date] is NULL ) 
		AND
		(Source.[Employee_Last_Worked_Date] is NOT NULL) 
      ) 
      OR
      (
		(Target.[Employee_Last_Worked_Date] is NOT NULL) 
		AND
		(Source.[Employee_Last_Worked_Date] is NULL) 
      )       
       OR
      (
		(Target.[Employee_Last_Worked_Date] is NOT NULL) 
		AND
		(Source.[Employee_Last_Worked_Date] is NOT NULL) 
		AND
		(Target.[Employee_Last_Worked_Date] &lt;&gt; Source.[Employee_Last_Worked_Date] )
      )      
      -- ==============================================================      
      OR 
      (Target.[Employee_Last_Job]  &lt;&gt; Source.[Employee_Last_Job]   COLLATE DATABASE_DEFAULT)    
      OR
      (Target.[Employee_Terminated_bool] &lt;&gt; Source.[Employee_Terminated_bool]) --  COLLATE DATABASE_DEFAULT)      
       OR 
      (Target.[Employee_PAY_TYPE]  &lt;&gt; Source.[Employee_PAY_TYPE]  COLLATE DATABASE_DEFAULT)     
        OR 
      (Target.[Employee_DIVISION]  &lt;&gt; Source.[Employee_DIVISION]  COLLATE DATABASE_DEFAULT)      
         OR 
      (Target.[Employee_UNION_CODE]  &lt;&gt; Source.[Employee_UNION_CODE]  COLLATE DATABASE_DEFAULT)     
         OR 
      (Target.[Employee_BASE_CLASS]  &lt;&gt; Source.[Employee_BASE_CLASS]  COLLATE DATABASE_DEFAULT)        
          OR 
      (Target.[Employee_BASE_Position]  &lt;&gt; Source.[Employee_BASE_Position]  COLLATE DATABASE_DEFAULT)       
          OR 
      (Target.[Employee_EMPMASTER_Position]  &lt;&gt; Source.[Employee_EMPMASTER_Position]  COLLATE DATABASE_DEFAULT)  
           OR 
      (Target.[Employee_FIRST_NAME]  &lt;&gt; Source.[Employee_FIRST_NAME]  COLLATE DATABASE_DEFAULT)       
           OR 
      (Target.[Employee_Middle_Initial]  &lt;&gt; Source.[Employee_Middle_Initial]  COLLATE DATABASE_DEFAULT)       
           OR 
      (Target.[Employee_LAST_NAME]  &lt;&gt; Source.[Employee_LAST_NAME] COLLATE DATABASE_DEFAULT)         
           OR 
      (Target.[Employee_Supervisor]  &lt;&gt; Source.[Employee_Supervisor]  COLLATE DATABASE_DEFAULT)              
      
    )
    THEN UPDATE SET
       Target.[COMPANY] = Source.[COMPANY]
      ,Target.[Employee_Explorer_RESOURCE_CODE]  = Source.[Employee_Explorer_RESOURCE_CODE]
      ,Target.[Employee_Start_Date] = Source.[Employee_Start_Date]
      ,Target.[Employee_Last_Worked_Date] = Source.[Employee_Last_Worked_Date]
      ,Target.[Employee_Last_Job]  = Source.[Employee_Last_Job]
      ,Target.[Employee_Terminated_bool] = Source.[Employee_Terminated_bool]
      ,Target.[Employee_PAY_TYPE]  = Source.[Employee_PAY_TYPE]
      ,Target.[Employee_DIVISION]  = Source.[Employee_DIVISION]
      ,Target.[Employee_UNION_CODE]  = Source.[Employee_UNION_CODE]
      ,Target.[Employee_BASE_CLASS]  = Source.[Employee_BASE_CLASS]
      ,Target.[Employee_BASE_Position]  = Source.[Employee_BASE_Position]
      ,Target.[Employee_EMPMASTER_Position]  = Source.[Employee_EMPMASTER_Position]
      ,Target.[Employee_FIRST_NAME]  = Source.[Employee_FIRST_NAME]
      ,Target.[Employee_Middle_Initial]  = Source.[Employee_Middle_Initial]
      ,Target.[Employee_LAST_NAME]  = Source.[Employee_LAST_NAME]
      ,Target.[Employee_Supervisor]  = Source.[Employee_Supervisor]
      ,Target.[EmployeeRecord_Updated_Date]= GETDATE()
    
WHEN NOT MATCHED BY Target					--&lt;==  defaulting to ‘WHEN NOT MATCHED BY TARGET’
    THEN INSERT  (
				   [COMPANY]
				  ,[Employee_Explorer_RESOURCE_CODE]
				  ,[Employee_Start_Date]
				  ,[Employee_Last_Worked_Date]
				  ,[Employee_Last_Job]
				  ,[Employee_Terminated_bool]
				  ,[Employee_PAY_TYPE]
				  ,[Employee_DIVISION]
				  ,[Employee_UNION_CODE]
				  ,[Employee_BASE_CLASS]			--
				  ,[Employee_BASE_Position]			--
				  ,[Employee_EMPMASTER_Position]	--
				  ,[Employee_FIRST_NAME]
				  ,[Employee_Middle_Initial]
				  ,[Employee_LAST_NAME]
				  ,[Employee_Supervisor]
				  ,[EmployeeRecord_Inserted_Date]
				  ,[EmployeeRecord_Updated_Date]
			      ) 
      VALUES (
				Source.[COMPANY]
				,Source.[Employee_Explorer_RESOURCE_CODE]
				,Source.[Employee_Start_Date]
				,Source.[Employee_Last_Worked_Date]
				,Source.[Employee_Last_Job]
				,Source.[Employee_Terminated_bool]
				,Source.[Employee_PAY_TYPE]
				,Source.[Employee_DIVISION]
				,Source.[Employee_UNION_CODE]
				,Source.[Employee_BASE_CLASS]			--
				,Source.[Employee_BASE_Position]			--
				,Source.[Employee_EMPMASTER_Position]	--
				,Source.[Employee_FIRST_NAME]
				,Source.[Employee_Middle_Initial]
				,Source.[Employee_LAST_NAME]
				,Source.[Employee_Supervisor]
				,GETDATE()
				,GETDATE()
		      )

WHEN NOT MATCHED BY SOURCE
	AND (Target.[Employee_Terminated_bool] = 0 )
    THEN UPDATE SET
        Target.[Employee_Terminated_bool] = 1  
        ,Target.[EmployeeRecord_Updated_Date]= GETDATE();</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>apostrophe_Print</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>apostrophe_Print</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>DECLARE @my_table TABLE (
    [value] VARCHAR(200)
)

INSERT INTO @my_table VALUES ('hi, my name''s tim.')

SELECT * FROM @my_table
Results

value
==================
hi, my name's tim.

'======================================================================


-- you can use SET QUOTED_IDENTIFIER OFF before your query, then SET QUOTED_IDENTIFIER ON after your query.

--For example

SET QUOTED_IDENTIFIER OFF;

UPDATE TABLE SET NAME = REPLACE(NAME, "'S", "S");

SET QUOTED_IDENTIFIER ON;
-- set OFF then ON again

========================================================================
char(39)

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>BOTTOM_Select</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>BOTTOM_Select</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>DECLARE 
@bottom int,
@count int

SET @bottom = 1000 
SET @count = (select COUNT(*) from Employee)

select * from Employee emp where emp.EmployeeID not in 
(
SELECT TOP (@count-@bottom) Employee.EmployeeID FROM Employee
)

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
You can use an ORDER BY and just change the sort to DESC to get the same effect.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
--I've come up with a solution to this that doesn't require you to know the number of row returned.

--For example, if you want to get all the locations logged in a table, except the latest 1 (or 2, or 5, or 34)

SELECT * 
FROM
    (SELECT ROW_NUMBER() OVER (ORDER BY CreatedDate) AS Row, * 
    FROM Locations
    WHERE UserId = 12345) AS SubQuery
WHERE Row &gt; 1 -- or 2, or 5, or 34

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
declare @floor int --this is the offset from the bottom, the number of results to exclude
declare @resultLimit int --the number of results actually retrieved for use
declare @total int --just adds them up, the total number of results fetched initially

--following is for gathering top 60 results total, then getting rid of top 50. We only keep the last 10
set @floor = 50 
set @resultLimit = 10
set @total = @floor + @resultLimit

declare @tmp0 table(
    --table body
)

declare @tmp1 table(
    --table body
)

--this line will drop the wanted results from whatever table we're selecting from
insert into @tmp0
select Top @total --what to select (the where, from, etc)

--using floor, insert the part we don't want into the second tmp table
insert into @tmp1
select top @floor * from @tmp0

--using select except, exclude top x results from the query
select * from @tmp0
except 
select * from @tmp1</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CHECK_Constraint</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CHECK_Constraint</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--https://odetocode.com/articles/79.aspx


--The CHECK constraint is used to limit the value range that can be placed in a column. 
--If you define a CHECK constraint on a single column it allows only certain values for this column. 
--If you define a CHECK constraint on a table it can limit the values in certain columns based on values in other columns in the row.

--The CHECK constraint allows you to specify the values in a column that must satisfy a Boolean expression.

--Disable CHECK constraints for insert or update
--To disable a CHECK constraint for insert or update, you use the following statement:

ALTER TABLE table_name
NOCHECK CONSTRAINT constraint_name;

--The following statement disables the valid_price constraint:
ALTER TABLE test.products
NO CHECK CONSTRAINT valid_price;

-- it is possible to avoid the conformance test when adding a CHECK constraint using WITH NOCHECK syntax in SQL.
CREATE TABLE Employees_2
(
    EmployeeID int,
    Salary money
)

INSERT INTO Employees_2 VALUES(1, -1)

ALTER TABLE Employees_2 WITH NOCHECK 
    ADD CONSTRAINT CK_Salary CHECK(Salary &gt; 0)
    
--Manually Checking Constaints
--With the ability to disable and re-enable constraints, and the ability to add constraints to a table using the WITH NOCHECK option, 
--you can certainly run into a condition where the referential or domain integrity of your database is compromised. 

--Server provides a Database Console Command you can run from any query tool to check all enabled constraints in a database or table. 
--With CK_UnitsOnOrder re-enabled, we can use the following command to check for constraint violations in the Products table.

dbcc checkconstraints(Products)

--=========================================================================================== Untrusted contraints
--https://social.msdn.microsoft.com/Forums/sqlserver/en-US/398fde3d-b1ce-44b0-ac80-bdd55bbf80ae/drop-and-create-constraint-on-very-large-table?forum=transactsql
ALTER TABLE tbl ADD NOCHECK CONSTRAINT fk FOREIGN KEY ...

or

ALTER TABLE tbl CHECK CONSTRAINT fk

if you only had disabled them. The latter is devilish, because it actually means

ALTER TABLE tbl WITH NOCHECK CHECK CONSTRAINT fk

All the variations you have seen means that the constraint was enabled without checking existing data. Which is good in the sense that it's quick. But it's bad from two other perspectives:

1) If there were errors in the data, they go undetected.
2) SQL Server will not trust the constraint, which means that some queries will run slower than they need to.

--You can check whether you have any active non-trusted constraints with

SELECT * FROM sys.foreign_keys WHERE is_disabled = 0 and is_not_trusted = 1
SELECT * FROM sys.check_constraints WHERE is_disabled = 0 and is_not_trusted = 1

---------------------
--you had better do the 'WITH CHECK CHECK CONSTRAINT' because otherwise performance can be affected. 
--When a FOREIGN KEY or CHECK constraint is disabled, SQL Server will internally flag the constraint as not being "trustworthy". 
--This can cause the optimizer to not consider the constraint relationship when trying to generate the most optimal query plans.

--The following query might come in handy. 
--I admit, it is a slight variation on Erland's post. 
--Also, it might not be entirely right. I do not have SQL Server at home, so I type this at the top of my head. 
--I'm not really sure both tables have a column 'parent_object_id' referring to the table the constraint is defined on.

SELECT 'ALTER TABLE ' + OBJECT_NAME(parent_object_id) + ' WITH CHECK CHECK CONSTRAINT ' + name
FROM   sys.foreign_keys
WHERE  is_disabled = 0
AND    is_not_trusted = 1
  UNION ALL
SELECT 'ALTER TABLE ' + OBJECT_NAME(parent_object_id) + ' WITH CHECK CHECK CONSTRAINT ' + name
FROM   sys.check_constraints
WHERE  is_disabled = 0
AND    is_not_trusted = 1</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Export_to_File</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Export_to_File</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>INSERT INTO OPENROWSET ('Microsoft.Jet.OLEDB.4.0', 'Excel 8.0;Database=c:\Test.xls;','SELECT *')</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>NOLOCK_global__SET TRANSACTION ISOLATION LEVEL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>NOLOCK_global__SET TRANSACTION ISOLATION LEVEL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
[/cc]

The available options are:

READ UNCOMMITTED 
	--Allows dirty reads, meaning data can be read from a transaction that is not yet complete.
READ COMMITTED 
	--  Only reads data from transactions that have already been committed.  
	--	Current transactions must wait for transactions referencing common resources to finish.
REPEATABLE READ 
	-- Data that is being read is exclusively locked until the transaction completes.
SNAPSHOT – 
	--The default for Oracle.  
	--	This level allows all data to be read without using locks by maintaining a snapshot of all the data being modified in “versioning” tables.  This is the only isolation level not lock based.
SERIALIZABLE – 
	--Data that is being read is exclusive locked and inserts are prevented within this range until the transaction completes.
	
====================================================
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;  
GO  
BEGIN TRANSACTION;  
GO 
---------------------------------------------
SELECT *   
    FROM HumanResources.EmployeePayHistory;  
GO  
SELECT *   
    FROM HumanResources.Department;  
---------------------------------------------
GO  
COMMIT TRANSACTION;  
GO  	
	
====================================================
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;  
GO  
BEGIN TRANSACTION;  
GO  
SELECT *   
    FROM HumanResources.EmployeePayHistory;  
GO  
SELECT *   
    FROM HumanResources.Department;  
GO  
COMMIT TRANSACTION;  
GO  	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>NOLOCK</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>NOLOCK</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--USAGE:
SELECT * FROM Person.Contact WITH (NOLOCK) WHERE ContactID &lt; 20
---------------------------------
from 
		CBCustom.dbo.PaymentusCustomerDailyActivity CUS with (READUNCOMMITTED)
		left join 
		collect.dbo.M01 M01 with (READUNCOMMITTED)
		ON'000'+ CUS.ACCOUNT_NUMBER = M01.ACCOUNT
------------------------------

Lock Types
	MD - metadata lock
	DB - database lock
	TAB - table lock
	PAG - page lock
Mode
	S - Shared access
	Sch-S - Schema stability makes sure the schema is not changed while object is in use
	IS - Intent shared indicates intention to use S locks
	
===============================================================================================================================================		
https://www.sqlshack.com/understanding-the-impact-of-nolock-and-with-nolock-table-hints-in-sql-server/

The default behaviour in SQL Server is for every query to acquire its own shared lock prior to reading data from a given table. 
This behaviour ensures that you are only reading committed data. 
However, the NOLOCK table hint allows you to instruct the query optimiser to read a given table without obtaining an exclusive or shared lock.

 SELECT [Jersey Number]      
  FROM [SQLShack].[dbo].[2016_FIFABallonDOr] (NOLOCK)   --&lt;================ NOLOCK HINT {deprecated by Microsoft as of 2017}
  WHERE [Nominee] = 'Lionel Messi'

The benefits of querying data using the NOLOCK table hint is that it requires less memory and prevents deadlocks from occurring 
with any other queries that may be reading similar data. 
===============================================================================================================================================	
https://stackoverflow.com/questions/12608780/understanding-sql-server-locks-on-select-queries  ================================================================
	
A SELECT in SQL Server will place a shared lock on a table row - and a second SELECT would also require a shared lock, and those are compatible with one another.

So no - one SELECT cannot block another SELECT.

What the WITH (NOLOCK) query hint is used for is to be able to read data that's in the process of being inserted 
	(by another connection) and that hasn't been committed yet.

Without that query hint, 
	a SELECT might be blocked reading a table by an ongoing INSERT (or UPDATE) statement that places an exclusive lock on rows 
	(or possibly a whole table), until that operation's transaction has been committed (or rolled back).

Problem of the WITH (NOLOCK) hint is: you might be reading data rows that aren't going to be inserted at all, 
	in the end (if the INSERT transaction is rolled back) - 
	so your e.g. report might show data that's never really been committed to the database.

There's another query hint that might be useful - WITH (READPAST). 
	This instructs the SELECT command to just skip any rows that it attempts to read and that are locked exclusively. 
	The SELECT will not block, and it will not read any "dirty" un-committed data - 
	but it might skip some rows, e.g. not show all your rows in the table.
	
------------------------------------------------------------------------------------------------------
On performance you keep focusing on select.
Shared does not block reads.
Shared lock blocks update.
If you have hundreds of shared locks it is going to take an update a while to get an exclusive lock as it must wait for shared locks to clear.

By default a select (read) takes a shared lock.
Shared (S) locks allow concurrent transactions to read (SELECT) a resource.
A shared lock as no effect on other selects (1 or a 1000).	

The difference is how the nolock versus shared lock effects update or insert operation.

No other transactions can modify the data while shared (S) locks exist on the resource.

A shared lock blocks an update!
But nolock does not block an update.
==========================================	==========================================	==========================================	==========================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>RowCount_ForAllTables_2</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>RowCount_ForAllTables_2</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- Row Count, etc for all tables, desc by row count


set

nocount

on

select

'Database Name: ', db_name

()

if

exists(select name from tempdb..sysobjects where name='##tmp'

)

drop

table ##tmp

create

table ##tmp(TABLE_SCHEMA nvarchar(256),TABLE_NAME nvarchar(256), num_rows int, reserved_KB varchar(15),data_KB varchar(15),index_KB varchar(15),unsed_KB varchar(15

))

go

declare

@tbl_schema nvarchar(256

)

declare

@tbl_name nvarchar(256

)

declare

@schema_tbl_name nvarchar(256

)

declare

tblname CURSOR for

 
select

TABLE_SCHEMA
, 

TABLE_NAME

 
from INFORMATION_SCHEMA.TABLES

 
where TABLE_TYPE='BASE TABLE' 

open

tblname

Fetch

next from tblname INTO @tbl_schema,@tbl_name

WHILE

@@FETCH_STATUS = 0

BEGIN

 
set @schema_tbl_name=@tbl_schema+'.'+@tbl_name

 

 
insert into ##tmp(TABLE_NAME , num_rows , reserved_KB ,data_KB ,index_KB ,unsed_KB ) 

 
exec sp_spaceused @schema_tbl_name

 

 
update ##tmp set TABLE_SCHEMA =@tbl_schema

 
where TABLE_SCHEMA is NULL and TABLE_NAME=@tbl_name

 

 
FETCH NEXT FROM tblname INTO @tbl_schema,@tbl_name 

END

CLOSE

tblname

deallocate

tblname

go

select

*

from

##tmp

ORDER BY 3 DESC
 

drop

table ##tmp</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>RowCount_ForAllTables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>RowCount_ForAllTables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>use CCNCclaims

select 'Database Name: ', db_name()

set nocount on

if exists(select name from tempdb..sysobjects where name='##tmp')

drop table ##tmp

create table ##tmp(nam varchar(50), rows int, res varchar(15),data varchar(15),ind_sze varchar(15),unsed varchar(15))

go

declare @tblname varchar(50)

declare tblname CURSOR for select name from sysobjects where xtype='U'

open tblname

Fetch next from tblname into @tblname

WHILE @@FETCH_STATUS = 0

BEGIN

insert into ##tmp

exec sp_spaceused @tblname

  FETCH NEXT FROM tblname INTO @tblname

END

CLOSE tblname

deallocate tblname

go

select nam Table_Name,rows Total_Rows,res Total_Table_Size,data Data_size,ind_sze Index_Size,unsed Unused_Space from ##tmp

drop table ##tmp</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SCRIPT_an_SQL_Object_into_a_TEMP_TABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SCRIPT_an_SQL_Object_into_a_TEMP_TABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ --Here is the script

use barriere
go

SET NOCOUNT ON

Create TABLE #TEMP_2(TheCode nvarchar(max))

INSERT INTO #TEMP_1
exec sp_helptext 'dbo.trg_Astec_Internal_Job_Insert'			--&lt;== this is a TRIGGER in the db barriere

SELECT * FROM #TEMP_1


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ -- Output: 

TheCode
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/* Job: AG_ORDERHEADER */


	/* Internal */
CREATE TRIGGER [dbo].[trg_Astec_Internal_Job_Insert] ON [dbo].[AG_ORDERHEADER]
    FOR INSERT
AS
    DECLARE @InternalCustomer AS CHAR(9)
    DECLARE @TicketFormatName AS CHAR(15)
    DECLARE @TicketType AS CHAR(15)
    DECLARE @Plant620TicketFormatName AS CHAR(15)

--IF @@ROWCOUNT = 0 RETURN
    SET NOCOUNT ON

    SET @InternalCustomer = '11625'
    SET @TicketFormatName = 'BARR. OUTBOUND'
    SET @TicketType = 'SALES'
    SET @Plant620TicketFormatName = 'BARRIERE OUTBND'

    INSERT  INTO DigitalForces.dbo.JOB
            ( JOB ,
              CUSTOMER ,
              JOB_DESCRIPTION_1 ,
              JOB_DESCRIPTION_2 ,
              JOB_DESCRIPTION_3 ,
              STATE ,
              PROJECT ,
              TICKET_FORMAT_NAME ,
              TICKET_TYPE ,
              PLANT
            )
            SELECT  b.JOB ,
                    a.CUSTOMER ,
                    LEFT(b.[DESCRIPTION], 30) AS [Description] ,
                    LEFT(b.OWNER, 30) AS Owner ,
                    LEFT(b.CONTRACT, 30) AS Contract ,
                    b.PROV_STATE AS State ,
                    CONVERT(INT, a.ORDER_NUMBER) AS OrderNumber ,
                    CASE WHEN a.JOB = 'PLANT-620' THEN @Plant620TicketFormatName
                         ELSE @TicketFormatName
                    END ,
                    @TicketType ,
                    a.JOB
            FROM    inserted AS a
                    JOIN JC_HEADERMASTER AS b ON ( a.CHARGE_JOB = b.JOB )
            WHERE   a.CUSTOMER = @InternalCustomer
                    AND NOT EXISTS ( SELECT *
                                     FROM   DigitalForces.dbo.JOB AS c
                                     WHERE  ( c.CUSTOMER = @InternalCustomer )
                                            AND c.JOB = b.JOB COLLATE SQL_Latin1_General_CP1_CI_AS
                                            AND c.PLANT = a.JOB COLLATE SQL_Latin1_General_CP1_CI_AS
                                            AND c.CUSTOMER = a.CUSTOMER COLLATE SQL_Latin1_General_CP1_CI_AS )



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Select_Insert_ToCopyFromTo</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Select_Insert_ToCopyFromTo</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- ================================================

USE [DB1_Main]
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[prj_0002_sp_902_SelectInsert_From_T7_to_T8] 

AS
BEGIN

	INSERT [dbo].[T8_All_Hospitals_Daily_ARCHIVE_t] 
		(
			[Facility_Code] ,
			[Patient_Account_Number] ,
			[MEDICAID_ID] ,
			[SSN] ,		
			[Patient_Type] ,			
			[Admit_DATE] ,				
			[Discharge_DATE] ,				
			[LAST_NAME] ,
			[FIRST_NAME] ,
			[Middle_Init] ,
			[ADDR1] ,
			[ADDR2]
		)
	SELECT 
			[Facility_Code] ,
			[Patient_Account_Number] ,
			[MEDICAID_ID] ,
			[SSN] ,		
			[Patient_Type] ,			
			[Admit_DATE] ,				
			[Discharge_DATE] ,				
			[LAST_NAME] ,
			[FIRST_NAME] ,
			[Middle_Init] ,
			[ADDR1] ,
			[ADDR2]		
	FROM [dbo].[T7_All_Hospitals_Daily_t]

END
GO
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>send_EMAIL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>send_EMAIL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE [barriere]
GO

/****** Object:  Trigger [dbo].[trg_UserNotification_Insert]    Script Date: 02/26/2016 14:00:52 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		Dewey Hebert
-- Create date: 6/25/22010
-- Description:	Notify User when a new Job is added.
-- =============================================
CREATE TRIGGER [dbo].[trg_UserNotification_Insert] ON [dbo].[JC_HEADERMASTER]
    FOR INSERT
AS
    BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
        SET NOCOUNT ON ;

        DECLARE @Job AS CHAR(9)
        DECLARE @Description AS VARCHAR(50)
        DECLARE @Owner AS VARCHAR(50)
        DECLARE @Division AS CHAR(9)
        DECLARE @StartDate AS CHAR(8)
        DECLARE @MsgBody AS VARCHAR(1024)
    
    
        SELECT  @Job = JOB ,
                @Description = ISNULL(DESCRIPTION, ' ') ,
                @Owner = ISNULL(OWNER, ' ') ,
                @Division = ISNULL(DIVISION, ' ') ,
                @StartDate = ISNULL(START_DATE, ' ')
        FROM    INSERTED
    
        SET @MsgBody = 'New Job Added: ' + @Job + ', Description: '
            + @Description + ', Owner: ' + @Owner + ', Division: ' + @Division
            + ', Start Date: ' + @StartDate
	
        EXEC msdb.dbo.sp_send_dbmail @recipients = 'paulA@barriere.com', @body = @MsgBody,
            @subject = 'New Job Added to Job Master', @profile_name='SQLUSER'

    END


GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>MISC</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>sp_MSForEachDB</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>MISC</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>sp_MSForEachDB</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>






--sp_MSForEachDB:. This stored procedure 
--takes a query as input, with "?" as a variable mapping for the database name. 
--So, for example,
--[?]..sysusers 
--equates to 
--"each sysusers table in each database on the server". 



///// Example #1 /////////////////////////////////////

IF EXISTS ( SELECT  *
            FROM    tempdb.dbo.sysobjects
            WHERE   id = OBJECT_ID(N'[tempdb].[dbo].[SQL_DB_REP]') ) 
    DROP TABLE [tempdb].[dbo].[SQL_DB_REP] ; 
GO

CREATE TABLE [tempdb].[dbo].[SQL_DB_REP]
    (
      [Server] [varchar](100) NOT NULL,
      [DB_Name] [varchar](70) NOT NULL,
      [User_Name] [nvarchar](90) NULL,
      [Group_Name] [varchar](100) NULL,
      [Account_Type] [varchar](22) NULL,
      [Login_Name] [varchar](80) NULL,
      [Def_DB] [varchar](100) NULL
    )
ON  [PRIMARY]

INSERT  INTO [tempdb].[dbo].[SQL_DB_REP]
        Exec sp_MSForEachDB 'SELECT  CONVERT(varchar(100), SERVERPROPERTY(''Servername'')) AS Server, 
''?'' as DB_Name, 
usu.name u_name 
,CASE 
   WHEN (usg.uid is null) then ''public''
   ELSE usg.name
   END as Group_Name
,CASE 
   WHEN usu.isntuser=1 then ''Windows Domain Account''
   WHEN usu.isntgroup = 1 then ''Windows Group'' 
    WHEN usu.issqluser = 1 then ''SQL Account'' 
    WHEN usu.issqlrole = 1 then ''SQL Role'' 
    END as Account_Type
    ,lo.loginname
    ,lo.dbname as Def_DB

FROM
   [?]..sysusers usu LEFT OUTER JOIN
   ([?]..sysmembers mem INNER JOIN [?]..sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
    LEFT OUTER JOIN master.dbo.syslogins  lo on usu.sid = lo.sid

WHERE
   (usu.islogin = 1 and usu.isaliased = 0 and usu.hasdbaccess = 1) and
   (usg.issqlrole = 1 or usg.uid is null)'

SELECT  [Server],
        [DB_Name],
        [User_Name],
        [Group_Name],
        [Account_Type],
        [Login_Name],
        [Def_DB]
FROM    [tempdb].[dbo].[SQL_DB_REP]
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Numeric</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Decimal_and_Numeric</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Numeric</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Decimal_and_Numeric</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

/*
numeric is functionally equivalent to decimal.


decimal[ (p[ , s] )] and numeric[ (p[ , s] )]


p (precision)
	The maximum total number of decimal digits that will be stored, 
	both to the left and to the right of the decimal point. 
	The precision must be a value from 1 through the maximum precision of 38. 
	The default precision is 18.
s (scale)
	The number of decimal digits that will be stored to the right of the decimal point. 
	This number is substracted from p to determine the maximum number of digits to the left of the decimal point.
	 The maximum number of decimal digits that can be stored to the right of the decimal point.
	  Scale must be a value from 0 through p. 
	  Scale can be specified only if precision is specified. 
	  The default scale is 0; therefore, 0 &lt;= s &lt;= p. 
	  Maximum storage sizes vary, based on the precision.
*/

CREATE TABLE dbo.MyTable
(
  MyDecimalColumn decimal(5,2)
 ,MyNumericColumn numeric(10,5)

);

GO
INSERT INTO dbo.MyTable VALUES (123, 12345.12);
GO
SELECT MyDecimalColumn, MyNumericColumn
FROM dbo.MyTable;

--Here is the result set.

MyDecimalColumn                         MyNumericColumn
--------------------------------------- ---------------------------------------
123.00                                  12345.12000</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>OPENROWSET</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>about_OPENROWSET</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>OPENROWSET</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>about_OPENROWSET</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_OPENROWSET

--If you are getting any error, you need to enable ad hoc distributed queries by executing following query.

sp_configure 'Show Advanced Options', 1
GO
RECONFIGURE
GO
sp_configure 'Ad Hoc Distributed Queries', 1
GO
RECONFIGURE
GO


--Includes all connection information that is required to access remote data from an OLE DB data source. 
--This method is an alternative to accessing tables in a linked server and is a one-time, 
--	ad hoc method of connecting and accessing remote data by using OLE DB. 
--The OPENROWSET function can be referenced in the FROM clause of a query as if it were a table name. 
--The OPENROWSET function can also be referenced as the target table of an INSERT, UPDATE, or DELETE statement, 
--	subject to the capabilities of the OLE DB provider. 
--Although the query might return multiple result sets, OPENROWSET returns only the first on

-- OPENROWSET also supports bulk operations through a built-in 
--	BULK provider that enables data from a file to be read and returned as a rowset.

OPENROWSET   
( { 'provider_name' , { 'datasource' ; 'user_id' ; 'password'   
   | 'provider_string' }   
   , {   [ catalog. ] [ schema. ] object   
       | 'query'   
     }   
   | BULK 'data_file' ,   
       { FORMATFILE = 'format_file_path' [ &lt;bulk_options&gt; ]  
       | SINGLE_BLOB | SINGLE_CLOB | SINGLE_NCLOB }  
} )   
  
OPENROWSET can be used to access remote data from OLE DB data sources only when 
--the DisallowAdhocAccess registry option is explicitly set to 0 for the specified provider, 
--and the Ad Hoc Distributed Queries advanced configuration option is enabled. 
--When these options are not set, the default behavior does not allow for ad hoc access.
  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>OPENROWSET</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ExportToFile</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>OPENROWSET</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ExportToFile</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>INSERT INTO OPENROWSET ('Microsoft.Jet.OLEDB.4.0', 'Excel 8.0;Database=c:\Test.xls;','SELECT *')</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>OUTPUT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>OUTPUT_INTO_simple_INSERT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>OUTPUT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>OUTPUT_INTO_simple_INSERT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--The following example inserts a row into the ScrapReason table and uses the OUTPUT clause 
--	to return the results of the statement to the @MyTableVar table variable. 
--Because the ScrapReasonID column is defined with an IDENTITY property, 
--	a value is not specified in the INSERT statement for that column. 
--However, note that the value generated by the Database Engine for that column is 
--returned in the OUTPUT clause in the column INSERTED.ScrapReasonID.

USE AdventureWorks2008R2;
GO
DECLARE @MyTableVar table( ScrapReasonID smallint,							--&lt;== Table Variable Defined
                           Name varchar(50),
                           ModifiedDate datetime);
INSERT Production.ScrapReason
    OUTPUT INSERTED.ScrapReasonID, INSERTED.Name, INSERTED.ModifiedDate		--&lt;== OUTPUT {manages to get the PK value}
        INTO @MyTableVar													--&lt;== Table Variable recieves output
VALUES (N'Operator error', GETDATE());

--Display the result set of the table variable.
SELECT ScrapReasonID, Name, ModifiedDate FROM @MyTableVar;
--Display the result set of the table.
SELECT ScrapReasonID, Name, ModifiedDate 
FROM Production.ScrapReason;
GO
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>OUTPUT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>OUTPUT_INTO_with_UPDATE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>OUTPUT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>OUTPUT_INTO_with_UPDATE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>OUTPUT_INTO_with_UPDATE

--The following example updates the VacationHours column in the Employee table by 25 percent 
--	for the first 10 rows. 
--The OUTPUT clause returns the VacationHours value that exists 
--	before applying the UPDATE statement in the column DELETED.VacationHours, 
--	and the updated value in the column INSERTED.VacationHours to the @MyTableVar table variable. 
	
--Two SELECT statements follow that return the values in @MyTableVar 
--	and the results of the update operation in the Employee table. 
--Note the results in the INSERTED.ModifiedDate column are not the same as the values in 
--	the ModifiedDate column in the Employee table. 
--This is because an AFTER UPDATE trigger that updates the value of ModifiedDate to 
--	the current date is defined on the Employee table. 
--However, the columns returned from OUTPUT reflect the data before triggers are fired.

USE AdventureWorks2008R2;
GO
DECLARE @MyTableVar table(
    EmpID int NOT NULL,
    OldVacationHours int,
    NewVacationHours int,
    ModifiedDate datetime);
UPDATE TOP (10) HumanResources.Employee
SET VacationHours = VacationHours * 1.25 
OUTPUT INSERTED.BusinessEntityID,			--&lt;== INSERTED
       DELETED.VacationHours,,				--&lt;== DELETED
       INSERTED.VacationHours,
       INSERTED.ModifiedDate
INTO @MyTableVar;
--Display the result set of the table variable.
SELECT EmpID, OldVacationHours, NewVacationHours, ModifiedDate
FROM @MyTableVar;
GO
--Display the result set of the table.
--Note that ModifiedDate reflects the value generated by an
--AFTER UPDATE trigger.
SELECT TOP (10) BusinessEntityID, VacationHours, ModifiedDate
FROM HumanResources.Employee;
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>OUTPUT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Output_To_TableVariable_WhatWasDeleted_ThenPrintIt</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>OUTPUT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Output_To_TableVariable_WhatWasDeleted_ThenPrintIt</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE tempdb;
GO

CREATE TABLE dbo.table1
(
    id INT,
    employee VARCHAR(32)
)
go

INSERT INTO dbo.table1 VALUES 
      (1, 'Fred')
     ,(2, 'Tom')
     ,(3, 'Sally')
     ,(4, 'Alice');
GO

DECLARE @MyTableVar TABLE				--&lt;== Declare Table Varaible
(
    id INT,
    employee VARCHAR(32)
);

PRINT 'table1, before delete' 
SELECT * FROM dbo.table1;

DELETE FROM dbo.table1
OUTPUT DELETED.* INTO @MyTableVar		--&lt;== OUTPUT to TableVariable
WHERE id = 4 OR id = 2;

PRINT 'table1, after delete'
SELECT * FROM dbo.table1;

PRINT '@MyTableVar, after delete'		--&lt;== Print TableVariable
SELECT * FROM @MyTableVar;

DROP TABLE dbo.table1;

--Results
--table1, before delete
--id          employee
------------- ------------------------------
--1           Fred
--2           Tom
--3           Sally
--4           Alice
--
--table1, after delete
--id          employee
------------- ------------------------------
--1           Fred
--3           Sally
--@MyTableVar, after delete
--id          employee
------------- ------------------------------
--2           Tom
--4           Alice</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>OUTPUT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ReadMe_OUTPUT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>OUTPUT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ReadMe_OUTPUT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ReadMe_OUTPUT

GOOD REFEERENCE:
https://www.simple-talk.com/sql/learn-sql-server/implementing-the-output-clause-in-sql-server-2008/

--Returns information from, or expressions based on, each row affected by an 
--	INSERT, UPDATE, DELETE, or MERGE statement. 
--These results can be returned to the processing application for use in such things 
--	as confirmation messages, archiving, and other such application requirements. 
--The results can also be inserted into a table or table variable. 
--Additionally, you can capture the results of an OUTPUT clause in a nested 
--INSERT, UPDATE, DELETE, or MERGE statement, and insert those results into 
--	a target table or view

--An UPDATE, INSERT, or DELETE statement that has an OUTPUT clause will return 
--rows to the client even if the statement encounters errors and is rolled back. 
--The result should not be used if any error occurs when you run the statemen</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Permissions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Permissions_for_Roles_and_Users_in_database</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Permissions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Permissions_for_Roles_and_Users_in_database</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Permissions_for_Roles_and_Users_in_database

https://stackoverflow.com/questions/7048839/sql-server-query-to-find-all-permissions-access-for-all-users-in-a-database

------------------------------------------------------------------------------------------------------------------------

use RiskMngt
go

/*
Security Audit Report
1) List all access provisioned to a sql user or windows user/group directly 
2) List all access provisioned to a sql user or windows user/group through a database or application role
3) List all access provisioned to the public role

Columns Returned:
UserName        : SQL or Windows/Active Directory user account.  This could also be an Active Directory group.
UserType        : Value will be either 'SQL User' or 'Windows User'.  This reflects the type of user defined for the 
                  SQL Server user account.
DatabaseUserName: Name of the associated user as defined in the database user account.  The database user may not be the
                  same as the server user.
Role            : The role name.  This will be null if the associated permissions to the object are defined at directly
                  on the user account, otherwise this will be the name of the role that the user is a member of.
PermissionType  : Type of permissions the user/role has on an object. Examples could include CONNECT, EXECUTE, SELECT
                  DELETE, INSERT, ALTER, CONTROL, TAKE OWNERSHIP, VIEW DEFINITION, etc.
                  This value may not be populated for all roles.  Some built in roles have implicit permission
                  definitions.
PermissionState : Reflects the state of the permission type, examples could include GRANT, DENY, etc.
                  This value may not be populated for all roles.  Some built in roles have implicit permission
                  definitions.
ObjectType      : Type of object the user/role is assigned permissions on.  Examples could include USER_TABLE, 
                  SQL_SCALAR_FUNCTION, SQL_INLINE_TABLE_VALUED_FUNCTION, SQL_STORED_PROCEDURE, VIEW, etc.   
                  This value may not be populated for all roles.  Some built in roles have implicit permission
                  definitions.          
ObjectName      : Name of the object that the user/role is assigned permissions on.  
                  This value may not be populated for all roles.  Some built in roles have implicit permission
                  definitions.
ColumnName      : Name of the column of the object that the user/role is assigned permissions on. This value
                  is only populated if the object is a table, view or a table value function.                 
*/

--List all access provisioned to a sql user or windows user/group directly 
SELECT  
    [UserName] = CASE princ.[type] 
                    WHEN 'S' THEN princ.[name]
                    WHEN 'U' THEN ulogin.[name] COLLATE Latin1_General_CI_AI
                 END,
    [UserType] = CASE princ.[type]
                    WHEN 'S' THEN 'SQL User'
                    WHEN 'U' THEN 'Windows User'
                 END,  
    [DatabaseUserName] = princ.[name],       
    [Role] = null,      
    [PermissionType] = perm.[permission_name],       
    [PermissionState] = perm.[state_desc],       
    [ObjectType] = obj.type_desc,--perm.[class_desc],       
    [ObjectName] = OBJECT_NAME(perm.major_id),
    [ColumnName] = col.[name]
FROM    
    --database user
    sys.database_principals princ  
LEFT JOIN
    --Login accounts
    sys.login_token ulogin on princ.[sid] = ulogin.[sid]
LEFT JOIN        
    --Permissions
    sys.database_permissions perm ON perm.[grantee_principal_id] = princ.[principal_id]
LEFT JOIN
    --Table columns
    sys.columns col ON col.[object_id] = perm.major_id 
                    AND col.[column_id] = perm.[minor_id]
LEFT JOIN
    sys.objects obj ON perm.[major_id] = obj.[object_id]
WHERE 
    princ.[type] in ('S','U')
UNION
--List all access provisioned to a sql user or windows user/group through a database or application role
SELECT  
    [UserName] = CASE memberprinc.[type] 
                    WHEN 'S' THEN memberprinc.[name]
                    WHEN 'U' THEN ulogin.[name] COLLATE Latin1_General_CI_AI
                 END,
    [UserType] = CASE memberprinc.[type]
                    WHEN 'S' THEN 'SQL User'
                    WHEN 'U' THEN 'Windows User'
                 END, 
    [DatabaseUserName] = memberprinc.[name],   
    [Role] = roleprinc.[name],      
    [PermissionType] = perm.[permission_name],       
    [PermissionState] = perm.[state_desc],       
    [ObjectType] = obj.type_desc,--perm.[class_desc],   
    [ObjectName] = OBJECT_NAME(perm.major_id),
    [ColumnName] = col.[name]
FROM    
    --Role/member associations
    sys.database_role_members members
JOIN
    --Roles
    sys.database_principals roleprinc ON roleprinc.[principal_id] = members.[role_principal_id]
JOIN
    --Role members (database users)
    sys.database_principals memberprinc ON memberprinc.[principal_id] = members.[member_principal_id]
LEFT JOIN
    --Login accounts
    sys.login_token ulogin on memberprinc.[sid] = ulogin.[sid]
LEFT JOIN        
    --Permissions
    sys.database_permissions perm ON perm.[grantee_principal_id] = roleprinc.[principal_id]
LEFT JOIN
    --Table columns
    sys.columns col on col.[object_id] = perm.major_id 
                    AND col.[column_id] = perm.[minor_id]
LEFT JOIN
    sys.objects obj ON perm.[major_id] = obj.[object_id]
UNION
--List all access provisioned to the public role, which everyone gets by default
SELECT  
    [UserName] = '{All Users}',
    [UserType] = '{All Users}', 
    [DatabaseUserName] = '{All Users}',       
    [Role] = roleprinc.[name],      
    [PermissionType] = perm.[permission_name],       
    [PermissionState] = perm.[state_desc],       
    [ObjectType] = obj.type_desc,--perm.[class_desc],  
    [ObjectName] = OBJECT_NAME(perm.major_id),
    [ColumnName] = col.[name]
FROM    
    --Roles
    sys.database_principals roleprinc
LEFT JOIN        
    --Role permissions
    sys.database_permissions perm ON perm.[grantee_principal_id] = roleprinc.[principal_id]
LEFT JOIN
    --Table columns
    sys.columns col on col.[object_id] = perm.major_id 
                    AND col.[column_id] = perm.[minor_id]                   
JOIN 
    --All objects   
    sys.objects obj ON obj.[object_id] = perm.[major_id]
WHERE
    --Only roles
    roleprinc.[type] = 'R' AND
    --Only public role
    roleprinc.[name] = 'public' AND
    --Only objects of ours, not the MS objects
    obj.is_ms_shipped = 0
ORDER BY
    princ.[Name],
    OBJECT_NAME(perm.major_id),
    col.[name],
    perm.[permission_name],
    perm.[state_desc],
    obj.type_desc--perm.[class_desc] </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>PIVOT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Dynamic_Pivot</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PIVOT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Dynamic_Pivot</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- Table with orders
use RiskMngt
go


CREATE TABLE Orders (

  order_id INT NOT NULL PRIMARY KEY,

  order_date DATETIME NOT NULL

             DEFAULT CURRENT_TIMESTAMP,

  amount DECIMAL(8, 2) NOT NULL DEFAULT 0

         CHECK (amount &gt;= 0));

 

-- Sample data

INSERT INTO Orders 

(order_id, order_date, amount)

SELECT 1, '20070101', 10.50

UNION ALL

SELECT 2, '20070126', 12.50

UNION ALL

SELECT 3, '20070130', 12.00

UNION ALL

SELECT 4, '20070214', 13.75

UNION ALL

SELECT 5, '20070220', 10.00

UNION ALL

SELECT 6, '20070306', 15.00

UNION ALL

SELECT 7, '20070310', 17.50

UNION ALL

SELECT 8, '20070329', 20.00;

 SELECT * FROM Orders



-- Build list of column values to pivot

DECLARE @cols NVARCHAR(1000);

SELECT @cols =

STUFF((SELECT N'],[' + year_month

       FROM (SELECT DISTINCT CONVERT(NCHAR(7), order_date, 126)

             FROM Orders) AS O(year_month)

       ORDER BY year_month

       FOR XML PATH('')

      ), 1, 2, '') + N']';

 

-- Build dynamic SQL query for pivoting   

PRINT @cols


DECLARE @sql NVARCHAR(2000);

SET @sql =

N'SELECT order_year, ' + @cols +

N'FROM (SELECT DATEPART(yyyy, order_date) AS order_year, ' +

             N'CONVERT(NCHAR(7), order_date, 126) AS year_month, ' +

             N'amount ' +

      N'FROM Orders) AS O ' +

N'PIVOT ' +

N'(SUM(amount) FOR year_month IN (' + @cols + N')) AS P;';

 

EXEC(@sql);

 

/*

 

Results:

 

order_year  2007-01  2007-02  2007-03

----------- -------- -------- --------

2007        35.00    23.75    52.50

 

*/</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>PIVOT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Example_Simple_2</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PIVOT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Example_Simple_2</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--0000_General_SNIPPET_032_UNPIVOT.sql

use RiskMngt
go

IF OBJECT_ID('Reporting.junk') IS NOT NULL
    DROP TABLE Reporting.Reporting.junk
go

CREATE TABLE reporting.junk
(
  CustomerID INT PRIMARY KEY, -- FK
  Phone1 VARCHAR(32),
  Phone2 VARCHAR(32),
  Phone3 VARCHAR(32)
);
INSERT Reporting.junk
  (CustomerID, Phone1, Phone2, Phone3)
VALUES
  (1,'705-491-1111', '705-491-1110', NULL),
  (2,'613-492-2222', NULL, NULL),
  (3,'416-493-3333', '416-493-3330', '416-493-3339');
--=====================================================
select * from Reporting.junk;

--OUTPUT
-----------
--CustomerID	Phone1			Phone2			Phone3
--1			705-491-1111	705-491-1110	NULL
--2			613-492-2222	NULL			NULL
--3			416-493-3333	416-493-3330	416-493-3339
--======================================================


  SELECT CustomerID, Phone
FROM
(
  SELECT CustomerID, Phone1, Phone2, Phone3 
  FROM Reporting.junk
) AS cp
UNPIVOT 
(
  Phone FOR Phones IN (Phone1, Phone2, Phone3)
) AS up;

--OUTPUT
--------------------------------------
CustomerID	Phone
1	705-491-1111
1	705-491-1110
2	613-492-2222
3	416-493-3333
3	416-493-3330
3	416-493-3339
--------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>PIVOT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Example_Simple</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PIVOT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Example_Simple</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Example: 
--From: http://archive.msdn.microsoft.com/SQLExamples/Wiki/View.aspx?title=PIVOTData

--For example, from the following data:

orderid 	productname 	productqty
1 			Gift Card 		2
1 			Shipping 		1
2 			Gift Card 		2
2 			T-Shirt 		2
2 			Shipping 		2 

--The desired output is:

orderid 	Gift Card 	T-Shirt 	Shipping
1 			2 			NULL 		1
2 			2 			2 			2


--Create Sample Data

-- Suppress data loading messages
SET NOCOUNT ON
 
-- Create Sample Data using a Table Varable
DECLARE @OrderDetail TABLE
(orderid int,
 productname varchar(30),
 productqty int)
 
-- Load Sample Data
INSERT INTO @OrderDetail VALUES (1, 'Gift Card', 2)
INSERT INTO @OrderDetail VALUES (1, 'Shipping', 1)
INSERT INTO @OrderDetail VALUES (2, 'Gift Card', 2)
INSERT INTO @OrderDetail VALUES (2, 'T-Shirt', 2)
INSERT INTO @OrderDetail VALUES (2, 'Shipping', 2)
 
--SQL Server 2005 / SQL Server 2008 Solution

--Query to Retrieve Desired Data
SELECT orderid, [Gift Card], [T-Shirt], [Shipping]
FROM
(
	SELECT orderid, productname, productqty
	FROM @OrderDetail
) AS source
PIVOT
(
	SUM(ProductQty)
	FOR ProductName IN ([Gift Card], [T-Shirt], [Shipping])
) as pvt
 
 
-- Results---------------------------------------
orderid     Gift Card   T-Shirt     Shipping
----------- ----------- ----------- -----------
1           2           NULL        1
2           2           2           2
---------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>PIVOT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>PIVOT_to_get_the_Average</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PIVOT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>PIVOT_to_get_the_Average</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>use JUNK
go


create table DataTable_1(RowNames nvarchar(10), ColumnNames nvarchar(10), ValueToAverage int)

go

insert into DataTable_1 values ('Row_1', 'Col_5', 900)
insert into DataTable_1 values ('Row_1', 'Col_1', 500)
insert into DataTable_1 values ('Row_1', 'Col_6', 500)
insert into DataTable_1 values ('Row_1', 'Col_7', 400)
insert into DataTable_1 values ('Row_1', 'Col_4', 800)
insert into DataTable_1 values ('Row_1', 'Col_2', 200)
insert into DataTable_1 values ('Row_1', 'Col_2', 500)
insert into DataTable_1 values ('Row_1', 'Col_3', 500)
insert into DataTable_1 values ('Row_2', 'Col_5', 300)
insert into DataTable_1 values ('Row_2', 'Col_1', 300)
insert into DataTable_1 values ('Row_2', 'Col_6', 800)
insert into DataTable_1 values ('Row_2', 'Col_7', 600)
insert into DataTable_1 values ('Row_2', 'Col_4', 800)
insert into DataTable_1 values ('Row_2', 'Col_2', 600)
insert into DataTable_1 values ('Row_2', 'Col_3', 900)
insert into DataTable_1 values ('Row_3', 'Col_5', 100)
insert into DataTable_1 values ('Row_3', 'Col_5', 100)
insert into DataTable_1 values ('Row_3', 'Col_5', 300)
insert into DataTable_1 values ('Row_3', 'Col_5', 300)
insert into DataTable_1 values ('Row_3', 'Col_1', 300)
insert into DataTable_1 values ('Row_3', 'Col_1', 900)
insert into DataTable_1 values ('Row_3', 'Col_6', 100)
insert into DataTable_1 values ('Row_3', 'Col_7', 400)
insert into DataTable_1 values ('Row_3', 'Col_4', 300)
insert into DataTable_1 values ('Row_3', 'Col_2', 100)
insert into DataTable_1 values ('Row_3', 'Col_2', 200)
insert into DataTable_1 values ('Row_3', 'Col_3', 500)
insert into DataTable_1 values ('Row_3', 'Col_3', 500)
go

select * from DataTable_1

--RowNames	ColumnNames	ValueToAverage
--Row_1		Col_5	900
--Row_1		Col_1	500
--Row_1		Col_6	500
--Row_1		Col_7	400
--Row_1		Col_4	800
--Row_1		Col_2	200
--Row_1		Col_2	500
--Row_1		Col_3	500
--Row_2		Col_5	300
--Row_2		Col_1	300
--Row_2		Col_6	800
--Row_2		Col_7	600
--Row_2		Col_4	800
--Row_2		Col_2	600
--Row_2		Col_3	900
--Row_3		Col_5	100
--Row_3		Col_5	100
--Row_3		Col_5	300
--Row_3		Col_5	300
--Row_3		Col_1	300
--Row_3		Col_1	900
--Row_3		Col_6	100
--Row_3		Col_7	400
--Row_3		Col_4	300
--Row_3		Col_2	100
--Row_3		Col_2	200
--Row_3		Col_3	500
--Row_3		Col_3	500

--=================================================================================================================START
select * from DataTable_1    --&lt;== This is the table, and the '*' is the columns to pivot (RowNames, ColumNames, ValueToAggregate)

--NOTE: the RowNames is not mentioned!!!
pivot (avg (ValueToAverage) for ColumnNames in ([Col_1],[Col_2],[Col_3],[Col_4],[Col_5],[Col_6],[Col_7])) as AvgIncomePerDay
--=================================================================================================================END

--RowNames	Col_1	Col_2	Col_3	Col_4	Col_5	Col_6	Col_7
--Row_1		500		350		500		800		900		500		400
--Row_2		300		600		900		800		300		800		600
--Row_3		600		150		500		300		200		100		400</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>PIVOT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>unPivot_and_get_ColumnNames_asWellAs_Values</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>PIVOT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>unPivot_and_get_ColumnNames_asWellAs_Values</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--0000_General_SNIPPET_032_UNPIVOT.sql


--&lt;========================create the table for testing
use RiskMngt
go

IF OBJECT_ID('Reporting.junk') IS NOT NULL
    DROP TABLE Reporting.Reporting.junk
go

CREATE TABLE reporting.junk
(
  CustomerID INT PRIMARY KEY, -- FK
  Phone1 VARCHAR(32),
  Phone2 VARCHAR(32),
  Phone3 VARCHAR(32)
);
INSERT Reporting.junk
  (CustomerID, Phone1, Phone2, Phone3)
VALUES
  (1,'705-491-1111', '705-491-1110', NULL),
  (2,'613-492-2222', NULL, NULL),
  (3,'416-493-3333', '416-493-3330', '416-493-3339');
--================================================
select * from Reporting.junk;


--OUTPUT
-----------
CustomerID	Phone1			Phone2			Phone3
1			705-491-1111	705-491-1110	NULL
2			613-492-2222	NULL			NULL
3			416-493-3333	416-493-3330	416-493-3339

--================================================


  SELECT CustomerID, Phone, ROW_NUMBER() OVER(ORDER BY (SELECT 1)) AS rnJUNK
FROM
(
  SELECT CustomerID, Phone1, Phone2, Phone3 
  FROM Reporting.junk
) AS cp
UNPIVOT 
(
  Phone FOR Phones IN (Phone1, Phone2, Phone3)
) AS up;

--======================================================


  SELECT CustomerID, Phone, ROW_NUMBER() OVER(ORDER BY (SELECT 1)) AS rnJUNK
FROM
(
  SELECT CustomerID, Phone1 , Phone2, Phone3 
  FROM (SELECT CustomerID, (Phone1 + '_Phone1') as Phone1, (Phone2 + '_Phone2') as Phone2,(Phone3 + '_Phone3') as Phone3  FROM Reporting.junk) as x
) AS cp
UNPIVOT 
(
  Phone FOR Phones IN (Phone1, Phone2, Phone3)
) AS up;

--======================================================  THIS IS THE ONE --&lt;=====================
;WITH cte_UnPivot 
as
(
	  SELECT CustomerID, Phone, ROW_NUMBER() OVER(ORDER BY (SELECT 1)) AS rnJUNK
	FROM
	(
	  SELECT CustomerID, Phone1 , Phone2, Phone3 
	  FROM (
				SELECT 
					CustomerID,
					--USE CAST(xxx, nvarchar(255)) to avoid error: Column conflicts with the type of other columns in the unpivot list
					cast((Phone1 + '_Phone1') as nvarchar(255) as Phone1, 
					cast((Phone2 + '_Phone2') as nvarchar(255) as Phone2,
					cast((Phone3 + '_Phone3') as nvarchar(255) as Phone3,  
				FROM Reporting.junk) as x
	) AS cp
	UNPIVOT 
	(
	  Phone FOR Phones IN (Phone1, Phone2, Phone3)
	) AS up
)

SELECT *
	,(SELECT 'TheCalculation' =  SUBSTRING(  Phone, (CHARINDEX('_', Phone)   + 1 ), LEN(Phone)  ) ) AS [colSource] 
	,(SELECT 'TheCalculation' =  SUBSTRING(  Phone, 1, (LEN(PHONE) -LEN(SUBSTRING(  Phone, (CHARINDEX('_', Phone)   - 1 ), LEN(Phone)  )) )))  AS [thePhone] 
FROM cte_UnPivot

--OUTPUT:
CustomerID	Phone	rnJUNK	colSource	thePhone
1	705-491-1111_Phone1	1	Phone1	705-491-111
1	705-491-1110_Phone2	2	Phone2	705-491-111
2	613-492-2222_Phone1	3	Phone1	613-492-222
3	416-493-3333_Phone1	4	Phone1	416-493-333
3	416-493-3330_Phone2	5	Phone2	416-493-333
3	416-493-3339_Phone3	6	Phone3	416-493-333</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>RecursiveQuery</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>01_Example___CreateDataSet</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>RecursiveQuery</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>01_Example___CreateDataSet</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--01_Example___CreateDataSet



use test
go

-- ORG CHART example

create table [personnel (parented)]
(
employee int identity primary key,
name nvarchar(50),
[hourly rate] money,
boss int -- parent in personnel tree
);

--=====================================================================

set identity_insert dbo.[personnel (parented)] on;
insert into [personnel (parented)] (employee, name, [hourly rate], [boss])
values
(1, 'Big Boss', 1000.00, 1),
(2, 'Joe', 10.00, 1),
(8, 'Mary', 20.00, 1),
(14, 'Jack', 15.00, 1),
(3, 'Jane', 10.00, 2),
(5, 'Max', 35.00, 2),
(9, 'Lynn', 15.00, 8),
(10, 'Miles', 60.00, 8),
(12, 'Sue', 15.00, 8),
(15, 'June', 50.00, 14),
(18, 'Jim', 55.00, 14),
(19, 'Bob', 40.00, 14),
(4, 'Jayne', 35.00, 3),
(6, 'Ann', 45.00, 5),
(7, 'Art', 10.00, 5),
(11, 'Al', 70.00, 10),
(13, 'Mike', 50.00, 12),
(16, 'Marty', 55.00, 15),
(17, 'Barb', 60.00, 15),
(20, 'Bart', 1000.00, 19);
set identity_insert dbo.[personnel (parented)] off;

select * from [personnel (parented)]
order by boss

--=====================================================================
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>REGEX</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Generate_Data_for_Regex</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>REGEX</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Generate_Data_for_Regex</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


CREATE TABLE alphareg(
   Alphabetic VARCHAR(8000)
)
 
INSERT INTO alphareg 
VALUES ('Two plus two equals four.')
   , ('But in Rome we must toe the line of fashion, spending beyond our means, and often on borrowed credit.')
   , ('Most dogs sleep 21 hours a day.')
   , ('2')
   , ('We were going to work on the project together, but he had to leave for basic training early.')
   , ('This SENTENCE is NOT written weLl.') 
   , ('Or as Alexander Suvorov would say, "When the training is hard, the fighting is easy."')
   , ('1812! The year of invasions.  Let me tell ya''.') 
   , ('This SENTENCE is NOT written weLl.') 
   , ('A')
   , ('b')
   , ('oooh, this isn''t written WRIGHT in several ways')
   , ('BD')
   , ('As he said this, Cupid sneezed approval on the left as before on the right.')
   , ('I like adverbs.')
   , ('Five?')
   , ('I''m going to the store right now.')
   , ('TWO')
   , ('"Yes"')
   , ('willful waste makes woeful waste')
 
SELECT *
FROM alphareg 

--==========================================================================================================


with alphareg as
(
select  'Two plus two equals four.'  as Alphabetic 
 union select 'But in Rome we must toe the line of fashion, spending beyond our means, and often on borrowed credit.'
 union select 'Most dogs sleep 21 hours a day.'
 union select '2'
 union select 'We were going to work on the project together, but he had to leave for basic training early.'
 union select 'This SENTENCE is NOT written weLl.' 
 union select 'Or as Alexander Suvorov would say, "When the training is hard, the fighting is easy."'
 union select '1812! The year of invasions.  Let me tell ya''.' 
 union select 'This SENTENCE is NOT written weLl.' 
 union select 'A'
 union select 'b'
 union select 'oooh, this isn''t written WRIGHT in several ways'
 union select 'BD'
 union select 'As he said this, Cupid sneezed approval on the left as before on the right.'
 union select 'I like adverbs.'
 union select 'Five?'
 union select 'I''m going to the store right now.'
 union select 'TWO'
 union select '"Yes"'
)
select Alphabetic
from CTEOrders;



--========================================================================================================


CREATE TABLE alphanumreg(
   NumData DECIMAL(15,4),
   NumInt SMALLINT,
   AlphabeticNum VARCHAR(25)
)
 
INSERT INTO alphanumreg
VALUES (22,22,'22')
   , (21.4,21,'21.4')
   , (40.05,40,'40.05')
   , (67,67,'67')
   , (1,1,'1')
   , (1.00,1,'1.00')
   , (121.23,121,'e1213')
   , (33.2341,33,'33.2341')
   , (33.2341,33,'33.2341')
   , (-1.09,-1,'-1.09')
   , (NULL,NULL,'22-E1-9')
   , (NULL,NULL,'11-EA-0')
   , (NULL,NULL,'04-E2-9')
   , (NULL,NULL,'10-E1-7')
   , (NULL,NULL,'106-E1-700')
   , (NULL,NULL,'3-E6-9365')
   , (NULL,NULL,'31-A2-4')
   , (NULL,NULL,'3723812695735285')
   , (NULL,NULL,'IX7254017')
   , (NULL,NULL,'4019638561283650')
GO


--========================================================================================================

with alphanumreg as 
(
   SELECT 
		CONVERT(DECIMAL(15,4), 22) as NumData,
		CONVERT(SMALLINT, 22) as NumInt,
		CONVERT(VARCHAR(25),'22') as AlphabeticNum
   UNION SELECT  21.4,21,'21.4' 
   UNION SELECT  40.05,40,'40.05' 
   UNION SELECT  67,67,'67' 
   UNION SELECT  1,1,'1' 
   UNION SELECT  1.00,1,'1.00' 
   UNION SELECT  121.23,121,'e1213' 
   UNION SELECT  33.2341,33,'33.2341' 
   UNION SELECT  33.2341,33,'33.2341' 
   UNION SELECT  -1.09,-1,'-1.09' 
   UNION SELECT  NULL,NULL,'22-E1-9' 
   UNION SELECT  NULL,NULL,'11-EA-0' 
   UNION SELECT  NULL,NULL,'04-E2-9' 
   UNION SELECT  NULL,NULL,'10-E1-7' 
   UNION SELECT  NULL,NULL,'106-E1-700' 
   UNION SELECT  NULL,NULL,'3-E6-9365' 
   UNION SELECT  NULL,NULL,'31-A2-4' 
   UNION SELECT  NULL,NULL,'3723812695735285' 
   UNION SELECT  NULL,NULL,'IX7254017' 
   UNION SELECT  NULL,NULL,'4019638561283650' 
)

select * from alphanumreg


GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>RowVersion_TimeStamp</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Display_RowVersion_as_BigInt</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>RowVersion_TimeStamp</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Display_RowVersion_as_BigInt</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--from: http://stackoverflow.com/questions/4470807/sql-server-rowversion-timestamp-comparisons
--RowVersion converts nicely to bigint and thus one can display better readable output when debugging:

CREATE TABLE [dbo].[T1](
    [Id] [int] IDENTITY(1,1) NOT NULL,
    [Value] [nvarchar](50) NULL,
    [RowVer] [timestamp] NOT NULL
) 

insert into t1 ([value]) values ('a')
insert into t1 ([value]) values ('b')
insert into t1 ([value]) values ('c')
select Id, Value,CONVERT(bigint,rowver)as RowVer from t1
update t1 set [value] = 'x' where id = 3
select Id, Value,CONVERT(bigint,rowver)as RowVer from t1
update t1 set [value] = 'y' 
select Id, Value,CONVERT(bigint,rowver)as RowVer from t1

Id  Value   RowVer
1   a   2037
2   b   2038
3   c   2039

Id  Value   RowVer
1   a   2037
2   b   2038
3   x   2040

Id  Value   RowVer
1   y   2041
2   y   2042
3   y   2043</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>RowVersion_TimeStamp</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>RowVersion_PARM_As_NVARCHAR(128)</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>RowVersion_TimeStamp</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>RowVersion_PARM_As_NVARCHAR(128)</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
-- From: http://www.sqlservercentral.com/Forums/Topic1080271-391-1.aspx

--I have a problem related to to passing in and out a pair of ROWVERSION values from an Execute SQL Task in SSIS.

--I have build a Stored Procedure that when called with a "@lastrowversion binary(8)" parameter will internally 
--set "@activerowversion binary(8) OUTPUT" to MIN_ACTIVE_ROWVERSION() for the current database and return 
--a resultset containing changed rows from a specific table together with the current active row version for the database.


--The stored procedure works without any problems when called from SSMS (SQL Server Management Studio) 
--but when I try to perform the same query in an Execute SQL Task in SSIS I get errors.


////////////////////////This works for SSMS and SSIS////////////////////


CREATE PROCEDURE [dbo].[udsp_Export_Unica_KundeKontaktHist]
	@remotedbname [sysname],
	@lastrowversionhexstr [nvarchar](128),
	@activerowversionhexstr [nvarchar](128) OUTPUT
WITH EXECUTE AS CALLER
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	BEGIN TRY	-- Error handling
	
	---- Prepare and begin named transaction
	DECLARE @procName [sysname] = OBJECT_NAME(@@PROCID);

	BEGIN TRANSACTION @procName;

	--Convert recorded row version from hex string to binary(8)
	DECLARE @lastrowversion binary(8);
	DECLARE @sql_hextovarbin nvarchar(1024)= 'SET @rowid = CAST(CAST(' + @lastrowversionhexstr + ' as bigint) as binary(8))';
	DECLARE @parmdef_hextovarbin nvarchar(512) = '@rowid binary(8) OUTPUT';
	
	EXEC sp_executesql
		 @sql_hextovarbin
		,@parmdef_hextovarbin
		,@rowid = @lastrowversion OUTPUT
	;

	--It's important to capture min_active_rowversion() into a variable, because
	--it could change while the query is running, which could lead to lost
	--updates.
	DECLARE @activerowversion binary(8);
	DECLARE @sp_executesql nvarchar(1024) = @remotedbname + '.sys.sp_executesql';
	DECLARE @sql nvarchar(1024) = N'SELECT @rowid = MIN_ACTIVE_ROWVERSION()';	-- connect to Unica database to get active rowversion
	DECLARE @parmdefinition nvarchar(512) = '@rowid binary(8) OUTPUT';

	-- get current row version for Unica database - we use it to avoid concurrency issues for rows changed during snapshot
	EXEC @sp_executesql
		 @sql
		,@parmdefinition
		,@rowid = @activerowversion OUTPUT
	;
	
	SELECT
                 [CustomerID] 
                 ,[ContactDate]
                 ,[ContactType]
        FROM [ContactHistory]   -- view in local database with underlying tables in remote database
        WHERE
                (ContactTimestamp &gt;= @lastrowversion AND ContactTimestamp &lt; @activerowversion)   -- changed rows since last snapshot, but NOT during snapshot
        ORDER BY
                 [CustomerID]
                ,[ContactDate]
        ;
	
	-- convert captured active row version to hex string using undocumented fsystem function for easier parameter handling in SSIS
	SELECT @activerowversionhexstr = master.sys.fn_varbintohexstr(@activerowversion);
	
	COMMIT TRANSACTION @procName;

	END TRY
	BEGIN CATCH;
		-- On error rollback any changes
		IF @@TRANCOUNT &gt; 0
			ROLLBACK TRANSACTION @procName;

		DECLARE @ErrorMessage NVARCHAR(4000)
		DECLARE @ErrorSeverity INT
		DECLARE @ErrorState INT

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		-- Use RAISERROR inside the CATCH block to return error
		-- information about the original error that caused
		-- execution to jump to the CATCH block.
		RAISERROR (@ErrorMessage, -- Message text.
				@ErrorSeverity, -- Severity.
				@ErrorState -- State.
				);
	END CATCH;
END
GO











//////////////This works for SSMS////////////////////////

CREATE PROCEDURE [dbo].[udsp_Export_Unica_KundeResponsHist]
	@remotedbname [sysname],
	@lastrowversion [binary](8),
	@activerowversion [binary](8) OUTPUT
WITH EXECUTE AS CALLER
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	BEGIN TRY	-- Error handling
	
	-- Prepare and begin named transaction
	DECLARE @procName [sysname] = OBJECT_NAME(@@PROCID);

	BEGIN TRANSACTION @procName;

	--It's important to capture min_active_rowversion() into a variable, because
	--it could change while the query is running, which could lead to lost
	--updates.
	DECLARE @sql nvarchar(1024) = N'USE ' + @remotedbname + '; SELECT @rowid = MIN_ACTIVE_ROWVERSION()';	-- connect to Unica database to get active rowversion
	DECLARE @parmdefinition nvarchar(512) = '@rowid binary(8) OUTPUT';

	-- get current row version for remote database - we use it to avoid concurrency issues for rows changed during snapshot
	EXEC sp_executesql
		 @sql
		,@parmdefinition
		,@rowid = @activerowversion OUTPUT
	;

	SELECT
		 [CustomerID] 
		 ,[ContactDate]
		 ,[ContactType]
	FROM [ContactHistory]	-- view in local database with underlying tables in remote database
	WHERE
		ContactTimestamp &gt;= @lastrowversion AND ContactTimestamp &lt; @activerowversion)	-- changed rows since last snapshot, but NOT during snapshot
	ORDER BY
		 [CustomerID]
		,[ContactDate]
	;

	COMMIT TRANSACTION @procName;

	END TRY
	BEGIN CATCH;
		-- On error rollback any changes
		IF @@TRANCOUNT &gt; 0
			ROLLBACK TRANSACTION @procName;

		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		-- Use RAISERROR inside the CATCH block to return error
		-- information about the original error that caused
		-- execution to jump to the CATCH block.
		RAISERROR (@ErrorMessage, -- Message text.
				@ErrorSeverity, -- Severity.
				@ErrorState -- State.
				);
	END CATCH;
END
GO
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>R</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CreatePredictiveModel</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>R</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CreatePredictiveModel</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>CreatePredictiveModel

-- from: https://docs.microsoft.com/en-us/sql/advanced-analytics/tutorials/rtsql-create-a-predictive-model-r?view=sql-server-2017#create-a-table-for-storing-the-model
use junk
go

--=Many datasets, small and large, are included with the R runtime. 
--To get a list of datasets installed with R, type library(help="datasets") from an R command prompt.

CREATE TABLE CarSpeed ([speed] int not null, [distance] int not null)
INSERT INTO CarSpeed
EXEC sp_execute_external_script
        @language = N'R'
        , @script = N'car_speed &lt;- cars;'
        , @input_data_1 = N''
        , @output_data_1_name = N'car_speed'

--Create a regression model
-------------------------------
--describes the relationship between the dependent variable speed and the independent variable distance


--To actually build the model, you define the formula inside your R code, and pass the data as an input parameter.
DROP PROCEDURE IF EXISTS generate_linear_model;
GO
CREATE PROCEDURE generate_linear_model
AS
BEGIN
    EXEC sp_execute_external_script
    @language = N'R'
    , @script = N'lrmodel &lt;- rxLinMod(formula = distance ~ speed, data = CarsData);
        trained_model &lt;- data.frame(payload = as.raw(serialize(lrmodel, connection=NULL)));'
    , @input_data_1 = N'SELECT [speed], [distance] FROM CarSpeed'
    , @input_data_1_name = N'CarsData'
    , @output_data_1_name = N'trained_model'
    WITH RESULT SETS ((model varbinary(max)));
END;
GO

--The first argument to rxLinMod is the formula parameter, which defines distance as dependent on speed.
--The input data is stored in the variable CarsData, 
--	which is populated by the SQL query. 
--If you don't assign a specific name to your input data, the default variable name would be InputDataSet.

--Create a table for storing the model
----------------------------------------
--Next, store the model so you can retrain or use it for prediction. 
--The output of an R package that creates a model is usually a binary object. 
--Therefore, the table where you store the model must provide a column of varbinary type.

CREATE TABLE stopping_distance_models (
    model_name varchar(30) not null default('default model') primary key,
    model varbinary(max) not null);

--Save the model
----------------------
--To save the model, run the following Transact-SQL statement to call the stored procedure, generate the model, and save it to a table.

INSERT INTO stopping_distance_models (model)
EXEC generate_linear_model;

--Note that if you run this code a second time, you get this error:
--Violation of PRIMARY KEY constraint...Cannot insert duplicate key in object dbo.stopping_distance_models

--One option for avoiding this error is to update the name for each new model. 
--For example, you could change the name to something more descriptive, 
--	and include the model type, the day you created it, and so forth.

UPDATE stopping_distance_models
SET model_name = 'rxLinMod ' + format(getdate(), 'yyyy.MM.HH.mm', 'en-gb')
WHERE model_name = 'default model'

--suppose you want to train a model but immediately view a table of coefficients from the model. 
--You could create the table of coefficients as the main result set, and output the trained model in a SQL variable. 
--You could immediately re-use the model by calling the variable, or you could save the model to a table as shown here.

DECLARE @model varbinary(max), @modelname varchar(30)
EXEC sp_execute_external_script
    @language = N'R'
    , @script = N'
        speedmodel &lt;- rxLinMod(distance ~ speed, CarsData)
        modelbin &lt;- serialize(speedmodel, NULL)
        OutputDataSet &lt;- data.frame(coefficients(speedmodel));'
    , @input_data_1 = N'SELECT [speed], [distance] FROM CarSpeed'
    , @input_data_1_name = N'CarsData'
    , @params = N'@modelbin varbinary(max) OUTPUT'
    , @modelbin = @model OUTPUT
    WITH RESULT SETS (([Coefficient] float not null));

-- Save the generated model
INSERT INTO [dbo].[stopping_distance_models] (model_name, model)
VALUES ('latest model', @model)

--Remember these rules for working with SQL parameters and R variables in sp_execute_external_script:

--1] All SQL parameters mapped to R script must be listed by name in the @params argument.
--2] To output one of these parameters, add the OUTPUT keyword in the @params list.
--3] After listing the mapped parameters, provide the mapping, line by line, 
--	of SQL parameters to R variables, immediately after the @params list.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>R</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Input_from_SQL_and_Output_to_SQL</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>R</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Input_from_SQL_and_Output_to_SQL</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Input_from_SQL_and_Output_to_SQL 

https://docs.microsoft.com/en-us/sql/advanced-analytics/tutorials/rtsql-working-with-inputs-and-outputs?view=sql-server-2017
//////////////////////////////////////////////////////////////////////
--Remember these requirements!
--================================

--1] Variable names must follow the rules for valid SQL identifiers.
--2] The order of the parameters is important. 
--	You must specify the required parameters @input_data_1 and @output_data_1 first, 
--	in order to use the optional parameters @input_data_1_name and @output_data_1_name.
--3] Only one input dataset can be passed as a parameter, 
--		and you can return only one dataset. 
--	However, you can call other datasets from inside your R code 
--		and you can return outputs of other types in addition to the dataset. 
--	You can also add the OUTPUT keyword to any parameter to have it returned with the results. 

--4] The WITH RESULT SETS statement defines the schema for the data, 
--		for the benefit of SQL Server.	
--	You need to provide SQL compatible data types for each column you return from R. 
--	You can use the schema definition to provide new column names too; 
--	you need not use the column names from the R data.frame. 
--	In some cases, this clause is optional; try omitting it and see what happen  
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
--When you want to run R code in SQL Server, you must wrap R script in a stored procedure. 
--You can write one, or pass R script to sp_execute_external_script. 
--This system stored procedure is used to start the R runtime in the context of SQL Server, 
--	which passes data to R, manages R user sessions securely, and returns any results to the clien
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
--Create some simple test data
-------------------------------
CREATE TABLE RTestData ([col1] int not null) ON [PRIMARY]
INSERT INTO RTestData   VALUES (1);
INSERT INTO RTestData   VALUES (10);
INSERT INTO RTestData   VALUES (100) ;
GO


--Query the data
--------------
SELECT * FROM RTestData

--Get the same data using R script
------------------------------------

EXECUTE sp_execute_external_script
      @language = N'R'
    , @script = N' OutputDataSet &lt;- InputDataSet;'
    , @input_data_1 = N' SELECT *  FROM RTestData;'
    WITH RESULT SETS (([NewColName] int NOT NULL));
    
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

--The preceding example used the default input and output variable names, 
--	InputDataSet and OutputDataSet. 
--To define the input data associated with InputDatSet, 
--	you use the @input_data_1 variable.    

--In this example, 
--	the names of the output and input variables for the stored procedure have been changed to 
--	SQL_Out and SQL_I
//////////////////////////////////////////////////////////////////////
R is case-sensitive! -- Will get errors if case is not the same
-- EXECUTE statement failed because its WITH RESULT SETS clause specified 1 result set(s), 
--			but the statement only sent 0 result set(s) at run time


 -- We're showing you this error because you can expect to see it often when testing new R code. 
 -- It means that the R script ran successfully, 
	--but SQL Server received no data, or received wrong or unexpected da
//////////////////////////////////////////////////////////////////////

EXECUTE sp_execute_external_script
  @language = N'R'
  , @script = N' SQL_Out &lt;- SQL_In;'
  , @input_data_1 = N' SELECT 12 as Col;'
  , @input_data_1_name  = N'SQL_In'
  , @output_data_1_name =  N'SQL_Out'
  WITH RESULT SETS (([NewColName] int NOT NULL));
  

||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||Another example

USE AdventureWorksDW2016_EXT
GO

--Develop the select statement in SQL -----------------------------------------------
SELECT ReportingDate
		, CAST(ModelRegion as varchar(50)) as ProductSeries
		, Amount
FROM [AdventureWorksDW2016_EXT].[dbo].[vTimeSeries]
WHERE [ModelRegion] = 'M200 Europe'
ORDER BY ReportingDate ASC

--Then use the select statement as input to the R-----------------------------------
EXECUTE sp_execute_external_script
       @language = N'R'
      , @script = N' str(InputDataSet);
      OutputDataSet &lt;- InputDataSet;'
      , @input_data_1 = N'
							   SELECT ReportingDate
									 , CAST(ModelRegion as varchar(50)) as ProductSeries
									 , Amount
							   FROM [AdventureWorksDW2016_EXT].[dbo].[vTimeSeries]
							   WHERE [ModelRegion] = ''M200 Europe''					--&lt;== string with double single apostrophes
							   ORDER BY ReportingDate ASC ;'
--WITH RESULT SETS undefined;															--&lt;=== without specifying the output columns
 WITH RESULT SETS (([dateCol] date, [strCol] varchar(50), [numCol] numeric(18,2)  ));	--&lt;===  specifying the output columns	
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>R</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>NormalDistribution_for_PowerBi</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>R</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>NormalDistribution_for_PowerBi</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
1]-- SP to Generate the Normal Distribution using R

USE [JUNK]
GO

/****** Object:  StoredProcedure [dbo].[MyRNorm]    Script Date: 11/10/2018 1:43:58 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[MyRNorm] (@param1 int, @param2 int, @param3 int)
AS
    EXEC sp_execute_external_script
      @language = N'R'
    , @script = N'
         OutputDataSet &lt;- as.data.frame(rnorm(mynumbers, mymean, mysd));'
    , @input_data_1 = N'   ;'
    , @params = N' @mynumbers int, @mymean int, @mysd int'
    , @mynumbers = @param1
    , @mymean = @param2
    , @mysd = @param3
    WITH RESULT SETS (([Density] float NOT NULL));
GO
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
2]-- Use the SP to populate a Table

use junk
go
IF OBJECT_ID('dbo.JunkTable2') IS NOT NULL
    DROP TABLE dbo.JunkTable2

go
Create Table JunkTable2 ( [Density] DECIMAL(10,3) )
go
INSERT INTO JunkTable2
exec dbo.MyRNorm 1000,50,11

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
3] Create the BINs for the Graph in Power BI
with 
CTE_one as
(
SELECT [Density], Round([Density],0) as rndDensity, ( Round([Density],0) * RAND()*(1.5-.5)+.5  ) as whatever
  FROM [JUNK].[dbo].[JunkTable2]
)
, CTE_two as
(
Select rndDensity, count(rndDensity) as theCount
from cte_one
Group by rndDensity

)

Select rndDensity, theCount, ( Round([theCount],0) * RAND()*(1.5-.5)+.5  ) as whatever
from CTE_two</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>R</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>VectorMultiplication_MatrixOuput</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>R</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>VectorMultiplication_MatrixOuput</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
--Different Length Vectors =&gt; Matrix
CREATE TABLE RTestData ([col1] int not null) ON [PRIMARY]
INSERT INTO RTestData   VALUES (1);
INSERT INTO RTestData   VALUES (10);
INSERT INTO RTestData   VALUES (100) ;
GO


EXECUTE sp_execute_external_script
    @language = N'R'
    , @script = N'
        x &lt;- as.matrix(InputDataSet);
        y &lt;- array(12:15);
    OutputDataSet &lt;- as.data.frame(x %*% y);'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
    WITH RESULT SETS (([Col1] int, [Col2] int, [Col3] int, Col4 int));
    
--OUTPUT
------------------------------
--Col1	Col2	Col3	Col4
--12		13		14		15
--120		130		140		150
--1200	1300	1400	1500

--Under the covers, the column of three values is converted to a single-column matrix. 
--Because a matrix is just a special case of an array in R, 
--	the array y is implicitly coerced to a single-column matrix to make the two arguments conform.


--VECTORS of same length =&gt; inner product
execute sp_execute_external_script
   @language = N'R'
   , @script = N'
        x &lt;- as.matrix(InputDataSet);
        y &lt;- array(12:14);
   OutputDataSet &lt;- as.data.frame(y %*% x);'
   , @input_data_1 = N' SELECT [Col1]  from RTestData;'
   WITH RESULT SETS (([Col1] int ));

--OUTPUT
-----------------------
--Col1
--1542

--because the two arguments can be handled as vectors of the same length, 
--	R returns the inner product as a matrix. 
--This is the expected behavior according to the rules of linear algebra; 
--	however, it could cause problems if your downstream application expects the output schema to never change!
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Rule_Engine</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>v1_TrainingRequirements_Data_Generation_script</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Rule_Engine</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>v1_TrainingRequirements_Data_Generation_script</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--201_CreateTables_for_Training_Situation.sql

--==================================== T101_Rule_Component - START
USE TruthTable
GO


IF OBJECT_ID ('T101_Rule_Component', 'U') IS NOT NULL
DROP TABLE dbo.T101_Rule_Component;
 
CREATE TABLE dbo.T101_Rule_Component  -- target
(
  T101_Rule_Component_PK INT NOT NULL PRIMARY KEY
  ,T102_Rule_Group_FK int
  ,Requirement_Factor_Name nvarchar(50)
  ,Requirement_Factor_Value nvarchar(50) 
  ,Requirement_Factor_nflag int   
  
);

INSERT T101_Rule_Component VALUES

  (1, 5,'Base_Class','flagger',0),
  (2, 1,'Seniority','3',0),  
  (3, 1,'Base_Class','Supervisor',-1),
  (4, 3,'Base_Class','flagger',0),  
  (5, 2,'Base_Class','Supervisor',-1),
  (6, 5,'Seniority','2',0),
  (7, 4,'Base_Class','Administrator',0),
  (8, 6,'Seniority','2',0)

--==================================== T101_Rule_Component - END

--==================================== T102_Rule_Group - START

IF OBJECT_ID ('T102_Rule_Group', 'U') IS NOT NULL
DROP TABLE dbo.T102_Rule_Group;
 
CREATE TABLE dbo.T102_Rule_Group  -- target
(
  T102_Rule_Group_PK INT NOT NULL PRIMARY KEY
  ,Rule_Name nvarchar(100)
   
);

INSERT T102_Rule_Group VALUES
  (1, '1] Supervisors with [Seniority = 3] have to take Class_01'),
  (2, '2] Anyone who is NOT a Supervisor has to take Class_04'),
  (3, '3] All Flaggers have to take Class_01'),
  (4, '4] All Administrators have to take Class_03'),  
  (5, '5] Flaggers with [Seniority = 2] have to take Class_02'),
  (6, '6] Anyone with [Seniority = 2] has to take Class_05')  


--==================================== T102_Rule_Group - END


--==================================== T103_Training_Category_and_Class - START

IF OBJECT_ID ('T103_Training_Category_and_Class', 'U') IS NOT NULL
DROP TABLE dbo.T103_Training_Category_and_Class;
 
CREATE TABLE dbo.T103_Training_Category_and_Class  -- target
(
  T103_Training_Category_and_Class_PK INT NOT NULL PRIMARY KEY
  ,T102_Rule_Group_FK int  
  ,Training_Category nvarchar(10)  
  ,Training_Category_Code nvarchar(3)    
  ,Training_Cost_Code nvarchar(10)
  ,Hours int
  ,uom nvarchar(10)
  ,bubble int
   
);
GO
INSERT T103_Training_Category_and_Class VALUES
  (1,3,'Safety','ST','CLASS_01',1,'each',0),
  (2,2,'Equipment', 'EQ', 'CLASS_04',1,'each',0),
  (3,5,'Safety','ST','CLASS_02',1,'each',0),
  (4,4,'Quality', 'QT', 'CLASS_03',1,'each',0),  
  (5,1,'Other','OT', 'CLASS_05',1,'each',0),
  (6,6,'Other','OT', 'CLASS_05',1,'each',0)		--same class but required by another rule group

--==================================== T103_Training_Category_and_Class - END

--==================================== T104_EmployeeRecord - START

IF OBJECT_ID ('T104_EmployeeRecord', 'U') IS NOT NULL
DROP TABLE dbo.T104_EmployeeRecord;
 
CREATE TABLE dbo.T104_EmployeeRecord  -- target
(
  T104_EmployeeRecord_PK INT NOT NULL PRIMARY KEY
  ,Employee_Number nvarchar(9)
  ,Base_Class  nvarchar(50)
  ,Seniority  nvarchar(50)
   
);

INSERT T104_EmployeeRecord VALUES
  (1, '1','flagger', '2')  
  ,(2, '2','Administrator', '2')  

--==================================== T104_EmployeeRecord - END

SELECT * FROM T101_Rule_Component
	ORDER BY T102_Rule_Group_FK, Requirement_Factor_Name

SELECT * FROM T102_Rule_Group

SELECT * FROM T103_Training_Category_and_Class
	ORDER BY T102_Rule_Group_FK
	
SELECT * FROM T104_EmployeeRecord
	ORDER BY T104_EmployeeRecord_PK	
	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SCHEMA_Organization</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Schema_Logins_Users_Tables_Revert_</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SCHEMA_Organization</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Schema_Logins_Users_Tables_Revert_</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>	--You don't need to GRANT table creation permission to the logins if you don't want to,
	--you can instead just use a higher level account an do 
	--CREATE TABLE S1.Test(...). I just find it easier to do it this way so that 
	--I don't have to qualify everything all the time. After I create things then
	--I can just REVOKE the permission.



--//Make sure we're using the correct credentials, this undoes any calls to EXECUTE AS ...
REVERT
GO

--//Switch to the master database
USE MASTER
GO

--//Create our test database
CREATE DATABASE Tester
GO

--//Swtich to the test database
USE Tester
GO

--//CREATE two logins, T1 and T2
CREATE LOGIN T1 WITH PASSWORD = 'T1'
CREATE USER T1 WITH DEFAULT_SCHEMA = S1

CREATE LOGIN T2 WITH PASSWORD = 'T2'
CREATE USER T2 WITH DEFAULT_SCHEMA = S2
GO

--//Give them permission to create tables
GRANT CREATE TABLE to T1
GRANT CREATE TABLE to T2
GO

--//Create two schemas, S1 and S2
CREATE SCHEMA S1 AUTHORIZATION T1
GO
CREATE SCHEMA S2 AUTHORIZATION T2
GO

--//Switch context to the T1 user
EXECUTE AS USER = 'T1'
GO

--//Create our table
CREATE TABLE Test
(
Col1 varChar(255)
)
GO

--//Insert some data
INSERT INTO Test VALUES ('This is from schema 1')
GO

--//Displays schema 1
SELECT * FROM Test

--//Switch back to the currently logged in user
REVERT
GO

--//Switch context to the T2 user
EXECUTE AS USER = 'T2'
GO

--//Create our table
CREATE TABLE Test
(
Col1 varChar(255)
)
GO

--//Insert some data
INSERT INTO Test VALUES ('This is from schema 2')
GO

--//Displays schema 2
SELECT * FROM Test
GO

--//Switch back to the currently logged in user
REVERT
GO

--//As the main user now select from both tables by schema-prefix
SELECT * FROM S1.Test
UNION
SELECT * FROM S2.Test


--//Cleanup everything that we just made
DROP TABLE S1.Test
DROP TABLE S2.Test

DROP SCHEMA S1
DROP SCHEMA S2

DROP LOGIN T1
DROP LOGIN T2
GO

USE MASTER
GO

DROP DATABASE Tester
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SCHEMA_Security</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SCHEMA_ROLE_PERMISSIONS_Login_User</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SCHEMA_Security</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SCHEMA_ROLE_PERMISSIONS_Login_User</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--This object protection does not apply to users who are members of the sysadmin server role. 
--A member of the sysadmin server role has permission to undertake any activity within a SQL Server instanc


-- For example:
--The DESIGN TEAM wants to maintain the integrity of the database tables but allow the DEVELOPERS to create other database objects such 
--as stored procedures and views to suit the application.

--The database application tables (securables) are created in a schema. 
--This will allow access to the tables to be controlled by permissions. The schema could be the dbo schema or any other.

--A second schema is created—called, say, [Developer_Schema]. The Developer_Schema will be the schema in which the developers 
--will create all additional application related objects such as stored procedures, views, and functions.

--Lastly, a database role called something like [Developer_Role] is created. Security principals (developers) are added to Developer_Role. 
--Developer_Role is granted SELECT, REFERENCES, INSERT, UPDATE, DELETE, and (optionally) VIEW DEFINTION permissions on the dbo schema. 
--Developer_Role is not granted ALTER or CONTROL permissions on the dbo schema. Developer_Role is granted ALTER and CONTROL permissions on Developer_Schema. 
--This explicit set of permissions will allow the developer to perform any action on the database tables with the exception of altering or dropping the table in any way. 
--The developers (principals) are configured with a default schema of Developer_Schema, allowing them to create objects in the Developer_Schema by default.

--Lastly, the required permissions are assigned to Database_Role at a database level, 
--for example, CREATE TABLE or DROP TABLE permissions. This is done using the GRANT statement.



--create a test database
CREATE DATABASE [SecurityTest]
GO
USE SecurityTest
GO
CREATE TABLE [dbo].[table1](
       [pkcol] [int] IDENTITY(1,1) NOT NULL,
       [col1] [int] NULL,
PRIMARY KEY CLUSTERED ([pkcol])
)
GO
--create test user login
CREATE LOGIN [User1] WITH PASSWORD=N'p@55w0rd'
GO
--create user in test database
CREATE USER [User1] FOR LOGIN [User1] WITH DEFAULT_SCHEMA=[Developer_Schema]
GO
--create role
CREATE ROLE [Developer_Role] AUTHORIZATION [dbo]
GO
--create schema
CREATE SCHEMA [Developer_Schema] AUTHORIZATION [User1]
GO
--apply permissions to schemas
GRANT ALTER ON SCHEMA::[Developer_Schema] TO [Developer_Role]
GO
GRANT CONTROL ON SCHEMA::[Developer_Schema] TO [Developer_Role]
GO
GRANT SELECT ON SCHEMA::[Developer_Schema] TO [Developer_Role]
GO
GRANT DELETE ON SCHEMA::[dbo] TO [Developer_Role]
GO
GRANT INSERT ON SCHEMA::[dbo] TO [Developer_Role]
GO
GRANT SELECT ON SCHEMA::[dbo] TO [Developer_Role]
GO
GRANT UPDATE ON SCHEMA::[dbo] TO [Developer_Role]
GO
GRANT REFERENCES ON SCHEMA::[dbo] TO [Developer_Role]
GO
--ensure role membership is correct
EXEC sp_addrolemember N'Developer_Role ', N'User1'
GO
--allow users to create tables in Developer_Schema
GRANT CREATE TABLE TO [Developer_Role]
GO
--Allow user to connect to database
GRANT CONNECT TO [User1]</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SELECT_COMPLEX</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>complex</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SELECT_COMPLEX</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>complex</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>/* up_TimeSheet_ParmSel_ReadEmployeeAbsenceDetail.sql
-- Given the Employee_PK, YYYYMMDD_PK return the existing Absence Info for the 
--	employee on the given day 
--  Assumptions:
--	1] There is only one Option 6 event per employee_PK per YYYYMMDD_PK,
--	2] In fact there is only one of each of the options (1 through 7) per employee_PK per YYYYMMDD_PK
--	3] If there is no comment then the Comments_FK from the TimeSheet_DepartamentalAbsences_tbl is Zero (0)
	The previous assumptions allow me to use the sum of the records to get the one good value

--  Output:
--	1] The Sums are either of HoursMissing or 0/1 
--	2] The following fields use either 0 or 1:
--		a) Present
--		b) Comments
--		c) NoClock  
--
	
*/

use dept_intranet

GO
Alter PROCEDURE up_TimeSheet_ParmSel_ReadEmployeeAbsenceDetail(@YYYYMMDD_PK as int, @Employee_PK as int) 
	AS


/* ============= Indented Version =========================== */

Select YYYYMMDD, 
	EmployeeFK, 
	SumOfMissingHours,
	SumOfPresent,
	SumOfDocked,
	SumOfSick,
	SumOfVacation,
	SumOfExcused,
	SumOfComments,
	SumOfNoClock,
	TimeSheet_Comments.Comment
From (
			/* Start Insert of 2 */
			(

		Select YYYYMMDD, 
			EmployeeFK, 
			Sum(Present) as SumOfPresent,
			Sum(Docked) as SumOfDocked,
			Sum(Sick) as SumOfSick,
			Sum(Vacation) as SumOfVacation,
			Sum(Excused) as SumOfExcused,
			Sum(Comments) as SumOfComments,
			Sum(NoClock) as SumOfNoClock,
			Sum(HoursMissing) as SumOfMissingHours,
			Sum(Comments_FK) as SumOfComments_FK

		From ( 
					/* Begin Insert of First Select statement */
					SELECT TimeSheet_DepartamentalAbsences_tbl.YYYYMMDD_FK as YYYYMMDD,
					TimeSheet_DepartamentalAbsences_tbl.Employee_FK as EmployeeFK, 	 
					TimeSheet_DepartamentalAbsences_tbl.ListOfOptions_FK, 
					TimeSheet_DepartamentalAbsences_tbl.HoursMissing as HoursMissing, 
					TimeSheet_DepartamentalAbsences_tbl.Comments_FK, 
					TimeSheet_Comments.Comment, 
					TimeSheet_ListOfOptions_lst.OptionValue,
					(SELECT 'TheCalculation' =
						CASE
							WHEN (TimeSheet_DepartamentalAbsences_tbl.ListOfOptions_FK=1) THEN 1
							ELSE 0
						END) AS Present,
					(SELECT 'TheCalculation' =
						CASE
							WHEN (TimeSheet_DepartamentalAbsences_tbl.ListOfOptions_FK=2) THEN TimeSheet_DepartamentalAbsences_tbl.HoursMissing
							ELSE 0
						END) AS Docked,
					(SELECT 'TheCalculation' =
						CASE
							WHEN (TimeSheet_DepartamentalAbsences_tbl.ListOfOptions_FK=3) THEN TimeSheet_DepartamentalAbsences_tbl.HoursMissing
							ELSE 0
						END) AS Sick,
					(SELECT 'TheCalculation' =
						CASE
							WHEN (TimeSheet_DepartamentalAbsences_tbl.ListOfOptions_FK=4) THEN TimeSheet_DepartamentalAbsences_tbl.HoursMissing
							ELSE 0
						END) AS Vacation,
					(SELECT 'TheCalculation' =
						CASE
							WHEN (TimeSheet_DepartamentalAbsences_tbl.ListOfOptions_FK=5) THEN TimeSheet_DepartamentalAbsences_tbl.HoursMissing
							ELSE 0
						END) AS Excused,
					(SELECT 'TheCalculation' =
						CASE
							WHEN (TimeSheet_DepartamentalAbsences_tbl.ListOfOptions_FK=6) THEN 1
							ELSE 0
						END) AS Comments,
					(SELECT 'TheCalculation' =
						CASE
							WHEN (TimeSheet_DepartamentalAbsences_tbl.ListOfOptions_FK=7) THEN 1
							ELSE 0
						END) AS NoClock

				FROM 	(
						TimeSheet_DepartamentalAbsences_tbl 
						INNER JOIN 
						TimeSheet_ListOfOptions_lst 
						ON TimeSheet_DepartamentalAbsences_tbl.ListOfOptions_FK = TimeSheet_ListOfOptions_lst.ListOfOptions_PK
				     	) 
					LEFT JOIN 
					TimeSheet_Comments 
					ON TimeSheet_DepartamentalAbsences_tbl.Comments_FK = TimeSheet_Comments.Comments_PK

				WHERE (
					(
						TimeSheet_DepartamentalAbsences_tbl.YYYYMMDD_FK =
							(SELECT 'TheFirstCalculation' = 				
								Case
									/*
									When 	( @YYYYMMDD_PK = 20020203 ) THEN @YYYYMMDD_PK
									*/
									When	(Select Count(*) 
										From TimeSheet_DepartamentalAbsences_tbl 
										Where (
											(TimeSheet_DepartamentalAbsences_tbl.YYYYMMDD_FK = @YYYYMMDD_PK)
											AND
											(TimeSheet_DepartamentalAbsences_tbl.Employee_FK = @Employee_PK)
										      )
										) &gt;= 1
										THEN @YYYYMMDD_PK
										
									ELSE 0
									END
							) 

					)
						AND
					(
						TimeSheet_DepartamentalAbsences_tbl.Employee_FK = 

							(SELECT 'TheSecondCalculation' = 

								
								Case
									When 	(Select Count(*) 
										From TimeSheet_DepartamentalAbsences_tbl 
										Where (
											(TimeSheet_DepartamentalAbsences_tbl.YYYYMMDD_FK = @YYYYMMDD_PK)
											AND
											(TimeSheet_DepartamentalAbsences_tbl.Employee_FK = @Employee_PK)
										      )
										) &gt;= 1
										THEN @Employee_PK


										
									ELSE 0
									END
							) 	
				 
					)
				      )

					/* End Insert of First Select statement */

		      ) as DerivedTable

		Group By YYYYMMDD, EmployeeFK

			) As SecondDerivedTable 
		/* End Insert of 2 */
	
	INNER JOIN

	TimeSheet_Comments 
	ON TimeSheet_Comments.Comments_PK = SecondDerivedTable.SumOfComments_FK
	
      ) 

	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQL_SECURITY</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>01_Cannot execute as the database principal because the principal__about</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQL_SECURITY</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>01_Cannot execute as the database principal because the principal__about</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>/* 01_Cannot execute as the database principal because the principal__about

BACKGROUND
==========
https://kodingdiary.wordpress.com/2013/06/12/how-to-fix-error-cannot-execute-as-the-database-principal-because-the-principal-domain-account-does-not-exist/
--The problem
/*
Recently, I worked on a stored procedure that requires to be executed under SQL service account’s credential. 
When I tried to use EXECUTE AS USER = ‘[Window domain\user id]’ to allow a user execute SQL statement 
under another user’s credentials I ran into this error

Msg 15517, Level 16, State 1, Line 1
Cannot execute as the database principal because the principal “[SQL service account]” does not exist, 
this type of principal cannot be impersonated, or you do not have permission.

Below are the steps to fix this error
*/

USE [master]
GO
ALTER DATABASE master SET TRUSTWORTHY ON
GO
GRANT IMPERSONATE ON USER::[Window domain\user id] TO [SQL service account]
GO

/* 
EXAMPLE
=======

SQL-SERVER/PRODUCTION
---------------------
LOGIN: ACCESSIICAREWNC\smccarson
LOGIN: SQL-SERVER\InsufficientRights

DB2
-----
ROLE: DB2_DataGuardian
USER: DB2_USER04_smccarson 

DB4
----
USER: DB4_USER00_InsufficientRights


1] When user 'DB2_USER04_smccarson' runs 'prj_8011_SP_006_Add_Practice_To_T1_v7.sql' using DB2, the user needs 
	to insert a record into DB4, but I don't want to have to give permissions to the user in DB4, so the script
	uses this:			*/

 		BEGIN
			
				EXECUTE AS LOGIN='SQL-SERVER\InsufficientRights'
					-- This avoids the necessity of making these users DataGuardians in DB4
					INSERT INTO [DB4_DocumentManagement].dbo.[T03_Header_PracticeDocuments] (DB2_T1_FK) VALUES (@T1_FK)
				REVERT
			
			RETURN @T1_FK
			PRINT 'Returned the PK for the new record'
		END
/*
2] When the user runs the script from prj_8011 then get the error, or when I run the TEST script: 'prj_8011_SP_006_Add_Practice_To_T1_TEST.sql'
	with this line, it gets the error:			*/
	
		EXECUTE AS LOGIN='ACCESSIICAREWNC\smccarson'
			...
		REVERT
/*
3] So I have added this into the script 'prj_8011_001_SetUpDataGuardianRole_CreateLogin_CreateUser_AddUserToRole_DB2.sql' 
	that sets them up as a DataGuardian			*/

		USE [master]
		GO
		ALTER DATABASE master SET TRUSTWORTHY ON
		GO
		
		GRANT IMPERSONATE ON LOGIN::[SQL-SERVER\InsufficientRights] to [ACCESSIICAREWNC\smccarson];
		
		GO	

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQL_SECURITY</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Effective_Permissions_of_a_DomainUser_on_an_object_example_on_a_Table_and_its_Fields</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQL_SECURITY</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Effective_Permissions_of_a_DomainUser_on_an_object_example_on_a_Table_and_its_Fields</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
-- for a USER
EXECUTE AS USER = 'BCC\jenniferj';
SELECT * FROM fn_my_permissions('dbo.PM_EMPMASTER', 'OBJECT') 
    ORDER BY subentity_name, permission_name ;  
REVERT;
GO

-- for a Login
EXECUTE AS LOGIN = 'BCC\jenniferg';
SELECT * FROM fn_my_permissions('dbo.PM_EMPMASTER', 'OBJECT') 
    ORDER BY subentity_name, permission_name ;  
REVERT;
GO

--OUTPUT
entity_name				subentity_name	permission_name
dbo.PM_EMPMASTER						ALTER
dbo.PM_EMPMASTER						CONTROL
dbo.PM_EMPMASTER						DELETE
dbo.PM_EMPMASTER						EXECUTE
dbo.PM_EMPMASTER						INSERT
dbo.PM_EMPMASTER						RECEIVE
dbo.PM_EMPMASTER						REFERENCES
dbo.PM_EMPMASTER						SELECT
dbo.PM_EMPMASTER						TAKE OWNERSHIP
dbo.PM_EMPMASTER						UPDATE
dbo.PM_EMPMASTER						VIEW CHANGE TRACKING
dbo.PM_EMPMASTER						VIEW DEFINITION
dbo.PM_EMPMASTER		ACC_FREE_HRS	REFERENCES			--&lt;== starting with the fields
dbo.PM_EMPMASTER		ACC_FREE_HRS	SELECT
dbo.PM_EMPMASTER		ACC_FREE_HRS	UPDATE</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQL_SECURITY</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Execute_as_Owner</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQL_SECURITY</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Execute_as_Owner</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--from: http://clay.lenharts.net/blog/2008/01/24/sql-server-security-with-execute-as-owner/

/*
The general idea is to create your stored procedure with the EXECUTE AS OWNER modifier. 
Any user who has the permissions to execute the stored procedure,
	runs the stored procedure under the Database’s dbo user 
	(which means it can do anything in the database, 
		but nothing at the server-level nor on other databases). 
	If you only allow your Logins to execute stored procedures 
		(and not touch the tables directly), 
	then you’ve effectively limited the Logins to code you’ve written. 
	If you don’t write any DELETE statements, then Logins can’t delete anything.
	
This is better than Roles, 
	because Roles are very coarse in comparison.
With Roles, you may have to give a User INSERT permissions on table. 
Instead with EXECUTE AS OWNER you can write a stored procedure 
	that checks the data exactly the way you want in the body of the stored procedure. 
This is much more fine grained way of handling permissions.	

From beginning to end, this is what you do:

Create a Login:
*/
CREATE LOGIN [MyLogin] WITH PASSWORD=N'Password',
DEFAULT_DATABASE=[master], CHECK_EXPIRATION=OFF, CHECK_POLICY=ON;

--Create its User in the database:

CREATE USER [MyUser] FOR LOGIN [MyLogin];

--I prefer to use schemas to identify “public” stored procedures. So create a schema:

CREATE SCHEMA [public] AUTHORIZATION [dbo];

--Give your new user EXECUTE permissions on anything in the public schema: (We will put the new stored procedure in this schema):

GRANT EXECUTE ON SCHEMA::[public] TO [MyUser];

--Create your stored procedure:

CREATE PROCEDURE [public].[MyStoredProc]
(
@Param1 int
)
WITH EXECUTE AS OWNER   -- This "EXECUTE AS" modifier on the stored procedure is key!
AS
BEGIN
SET NOCOUNT ON;

-- do something

END

/*
When your stored procedure runs, it can do anything in the database, 
	including calling other stored procedures.
It is an easy way to segregate public stored procedures from private ones. 
This gives you encapsulation, which is a good thing (see section 5.3 in Code Complete about the benefits of encapsulation).
*/</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQL_SECURITY</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>FindConsequitve_Failed_Login_attempts</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQL_SECURITY</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>FindConsequitve_Failed_Login_attempts</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--It is possible to load and query every error log file by combining the two stored
--procedures with a bit of iterative code. 

--This script shows the custom code used to
--loop through each log file, store the data in a temp table, and subsequently query
--that data to find more than five consecutive failed login attempts, as well as the
--last good login attempt. 
--In order for this to work, you will need to enable security logging for both
--successful and failed logins, as most production servers should do. This can be
--configured via the Security tab of the Server Properties. Finally, note that this
--query will only work for SQL Server 2005 and 2008. 

-- Right click server in MSSMS =&gt; Properties =&gt; Security {left pane} =&gt;
--	(x)Both failed and successful logins

////////////////////////////////////////

DECLARE @TSQL  NVARCHAR(2000)
DECLARE @lC    INT

CREATE TABLE #TempLog (
      LogDate     DATETIME,
      ProcessInfo NVARCHAR(50),
      [Text] NVARCHAR(MAX))

CREATE TABLE #logF (
      ArchiveNumber     INT,
      LogDate           DATETIME,
      LogSize           INT
)

INSERT INTO #logF   
EXEC sp_enumerrorlogs
SELECT @lC = MIN(ArchiveNumber) FROM #logF

WHILE @lC IS NOT NULL
BEGIN
      INSERT INTO #TempLog
      EXEC sp_readerrorlog @lC
      SELECT @lC = MIN(ArchiveNumber) FROM #logF 
      WHERE ArchiveNumber &gt; @lC
END

--Failed login counts. Useful for security audits.
SELECT Text,COUNT(Text) Number_Of_Attempts
FROM #TempLog where 
 Text like '%failed%' and ProcessInfo = 'LOGON'
 Group by Text

--Find Last Successful login. Useful to know before deleting "obsolete" accounts.
SELECT Distinct MAX(logdate) last_login,Text 
FROM #TempLog 
where ProcessInfo = 'LOGON'and Text like '%SUCCEEDED%' 
and Text not like '%NT AUTHORITY%'
Group by Text

DROP TABLE #TempLog
DROP TABLE #logF 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQL_SECURITY</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>FindUsersWithElevatedPrivileges</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQL_SECURITY</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>FindUsersWithElevatedPrivileges</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Find SQL users at the database level 

--This  query from the security tacklebox dives into each database, looking for
--accounts and their access to said database. This query interrogates user
--information that is stored in the
--sysusers system tables, in each individual
--database, and so an iterative method is needed to plod through every database that
--we wish to investigate. The
--sys.users table is superseded by 
--sys.database_prinicapls in SQL Server but still works in all current versions.

--This solution uses Microsoft-provided stored procedure,
--sp_MSForEachDB, to do most of the work . This stored
--procedure takes a query as input, with "?" as a variable mapping for the database
--name. So, for example, [?]..sysusers equates to "each sysusers table in each
--database on the server". 

--This particular query does not deal so much with sysadmin privileges but more
--with high database level privileges. For example, it investigates membership of the 
--db_owner database role, which can perform all configuration and maintenance
--activities on a database. The DBA can also use it to investigate membership of
--other database roles that may have been created to serve a purpose, such as the
--execution of stored procedures. 
--The results of this query will instantly let the DBA know if any users have
--escalated privileges of which he or she was previously unaware. 

////////

--In addition to illuminating membership of the
--db_owner role, notice that there are
--also some potentially orphaned
--(Example:)HWC Development users in the (Example:) Custom_HW database, as indicated by the
--NULL value in the Login_Name field. This generally
--happens when you restore a database from one server to another server where the
--logins do not exist, and would warrant further investigation. 

--If it were determined that these are indeed orphaned users, or groups, then 
-- add the accounts to the target system and execute 
--sp_change_users_login for SQL logins, or add the Windows user or group
--account for non-SQL login accounts


////////////////////////////////////////////////////////////////////////////

IF EXISTS ( SELECT  *
            FROM    tempdb.dbo.sysobjects
            WHERE   id = OBJECT_ID(N'[tempdb].[dbo].[SQL_DB_REP]') ) 
    DROP TABLE [tempdb].[dbo].[SQL_DB_REP] ; 
GO

CREATE TABLE [tempdb].[dbo].[SQL_DB_REP]
    (
      [Server] [varchar](100) NOT NULL,
      [DB_Name] [varchar](70) NOT NULL,
      [User_Name] [nvarchar](90) NULL,
      [Group_Name] [varchar](100) NULL,
      [Account_Type] [varchar](22) NULL,
      [Login_Name] [varchar](80) NULL,
      [Def_DB] [varchar](100) NULL
    )
ON  [PRIMARY]

INSERT  INTO [tempdb].[dbo].[SQL_DB_REP]
        Exec sp_MSForEachDB 'SELECT  CONVERT(varchar(100), SERVERPROPERTY(''Servername'')) AS Server, 
''?'' as DB_Name, 
usu.name u_name 
,CASE 
   WHEN (usg.uid is null) then ''public''
   ELSE usg.name
   END as Group_Name
,CASE 
   WHEN usu.isntuser=1 then ''Windows Domain Account''
   WHEN usu.isntgroup = 1 then ''Windows Group'' 
    WHEN usu.issqluser = 1 then ''SQL Account'' 
    WHEN usu.issqlrole = 1 then ''SQL Role'' 
    END as Account_Type
    ,lo.loginname
    ,lo.dbname as Def_DB

FROM
   [?]..sysusers usu LEFT OUTER JOIN
   ([?]..sysmembers mem INNER JOIN [?]..sysusers usg ON mem.groupuid = usg.uid) ON usu.uid = mem.memberuid
    LEFT OUTER JOIN master.dbo.syslogins  lo on usu.sid = lo.sid

WHERE
   (usu.islogin = 1 and usu.isaliased = 0 and usu.hasdbaccess = 1) and
   (usg.issqlrole = 1 or usg.uid is null)'

SELECT  [Server],
        [DB_Name],
        [User_Name],
        [Group_Name],
        [Account_Type],
        [Login_Name],
        [Def_DB]
FROM    [tempdb].[dbo].[SQL_DB_REP]
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQL_SECURITY</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SQL Server query to find all permissions and access for all users in a database</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQL_SECURITY</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SQL Server query to find all permissions and access for all users in a database</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--http://stackoverflow.com/questions/7048839/sql-server-query-to-find-all-permissions-access-for-all-users-in-a-database

/*
Security Audit Report
1) List all access provisioned to a SQL user or Windows user/group directly
2) List all access provisioned to a SQL user or Windows user/group through a database or application role
3) List all access provisioned to the public role

Columns Returned:
UserType        : Value will be either 'SQL User', 'Windows User', or 'Windows Group'.
                  This reflects the type of user/group defined for the SQL Server account.
DatabaseUserName: Name of the associated user as defined in the database user account.  The database user may not be the
                  same as the server user.
LoginName       : SQL or Windows/Active Directory user account.  This could also be an Active Directory group.
Role            : The role name.  This will be null if the associated permissions to the object are defined at directly
                  on the user account, otherwise this will be the name of the role that the user is a member of.
PermissionType  : Type of permissions the user/role has on an object. Examples could include CONNECT, EXECUTE, SELECT
                  DELETE, INSERT, ALTER, CONTROL, TAKE OWNERSHIP, VIEW DEFINITION, etc.
                  This value may not be populated for all roles.  Some built in roles have implicit permission
                  definitions.
PermissionState : Reflects the state of the permission type, examples could include GRANT, DENY, etc.
                  This value may not be populated for all roles.  Some built in roles have implicit permission
                  definitions.
ObjectType      : Type of object the user/role is assigned permissions on.  Examples could include USER_TABLE,
                  SQL_SCALAR_FUNCTION, SQL_INLINE_TABLE_VALUED_FUNCTION, SQL_STORED_PROCEDURE, VIEW, etc.
                  This value may not be populated for all roles.  Some built in roles have implicit permission
                  definitions.
Schema          : Name of the schema the object is in.
ObjectName      : Name of the object that the user/role is assigned permissions on.
                  This value may not be populated for all roles.  Some built in roles have implicit permission
                  definitions.
ColumnName      : Name of the column of the object that the user/role is assigned permissions on. This value
                  is only populated if the object is a table, view or a table value function.
*/

WITH CTE_ONE (
				UserType,
				DatabaseUserName,
				LoginName,
				[Role],
				[Schema],
				ObjectName,
				ColumnName,
				PermissionType,
				PermissionState,
				ObjectType
			)
AS
(
			--======================================================================
				--1) List all access provisioned to a SQL user or Windows user/group directly
				SELECT
					[UserType] = CASE princ.[type]
									 WHEN 'S' THEN 'SQL User'
									 WHEN 'U' THEN 'Windows User'
									 WHEN 'G' THEN 'Windows Group'
								 END,
					[DatabaseUserName] = princ.[name],
					[LoginName]        = ulogin.[name],
					[Role]             = NULL,
					[PermissionType]   = perm.[permission_name],
					[PermissionState]  = perm.[state_desc],
					[ObjectType] = CASE perm.[class]
									   WHEN 1 THEN obj.[type_desc]        -- Schema-contained objects
									   ELSE perm.[class_desc]             -- Higher-level objects
								   END,
					[Schema] = objschem.[name],
					[ObjectName] = CASE perm.[class]
									   WHEN 3 THEN permschem.[name]       -- Schemas
									   WHEN 4 THEN imp.[name]             -- Impersonations
									   ELSE OBJECT_NAME(perm.[major_id])  -- General objects
								   END,
					[ColumnName] = col.[name]
				FROM
					--Database user
					sys.database_principals            AS princ
					--Login accounts
					LEFT JOIN sys.server_principals    AS ulogin    ON ulogin.[sid] = princ.[sid]
					--Permissions
					LEFT JOIN sys.database_permissions AS perm      ON perm.[grantee_principal_id] = princ.[principal_id]
					LEFT JOIN sys.schemas              AS permschem ON permschem.[schema_id] = perm.[major_id]
					LEFT JOIN sys.objects              AS obj       ON obj.[object_id] = perm.[major_id]
					LEFT JOIN sys.schemas              AS objschem  ON objschem.[schema_id] = obj.[schema_id]
					--Table columns
					LEFT JOIN sys.columns              AS col       ON col.[object_id] = perm.[major_id]
																	   AND col.[column_id] = perm.[minor_id]
					--Impersonations
					LEFT JOIN sys.database_principals  AS imp       ON imp.[principal_id] = perm.[major_id]
				WHERE
					princ.[type] IN ('S','U','G')
					-- No need for these system accounts
					AND princ.[name] NOT IN ('sys', 'INFORMATION_SCHEMA')

			UNION

				--2) List all access provisioned to a SQL user or Windows user/group through a database or application role
				SELECT
					[UserType] = CASE membprinc.[type]
									 WHEN 'S' THEN 'SQL User'
									 WHEN 'U' THEN 'Windows User'
									 WHEN 'G' THEN 'Windows Group'
								 END,
					[DatabaseUserName] = membprinc.[name],
					[LoginName]        = ulogin.[name],
					[Role]             = roleprinc.[name],
					[PermissionType]   = perm.[permission_name],
					[PermissionState]  = perm.[state_desc],
					[ObjectType] = CASE perm.[class]
									   WHEN 1 THEN obj.[type_desc]        -- Schema-contained objects
									   ELSE perm.[class_desc]             -- Higher-level objects
								   END,
					[Schema] = objschem.[name],
					[ObjectName] = CASE perm.[class]
									   WHEN 3 THEN permschem.[name]       -- Schemas
									   WHEN 4 THEN imp.[name]             -- Impersonations
									   ELSE OBJECT_NAME(perm.[major_id])  -- General objects
								   END,
					[ColumnName] = col.[name]
				FROM
					--Role/member associations
					sys.database_role_members          AS members
					--Roles
					JOIN      sys.database_principals  AS roleprinc ON roleprinc.[principal_id] = members.[role_principal_id]
					--Role members (database users)
					JOIN      sys.database_principals  AS membprinc ON membprinc.[principal_id] = members.[member_principal_id]
					--Login accounts
					LEFT JOIN sys.server_principals    AS ulogin    ON ulogin.[sid] = membprinc.[sid]
					--Permissions
					LEFT JOIN sys.database_permissions AS perm      ON perm.[grantee_principal_id] = roleprinc.[principal_id]
					LEFT JOIN sys.schemas              AS permschem ON permschem.[schema_id] = perm.[major_id]
					LEFT JOIN sys.objects              AS obj       ON obj.[object_id] = perm.[major_id]
					LEFT JOIN sys.schemas              AS objschem  ON objschem.[schema_id] = obj.[schema_id]
					--Table columns
					LEFT JOIN sys.columns              AS col       ON col.[object_id] = perm.[major_id]
																	   AND col.[column_id] = perm.[minor_id]
					--Impersonations
					LEFT JOIN sys.database_principals  AS imp       ON imp.[principal_id] = perm.[major_id]
				WHERE
					membprinc.[type] IN ('S','U','G')
					-- No need for these system accounts
					AND membprinc.[name] NOT IN ('sys', 'INFORMATION_SCHEMA')

			UNION

				--3) List all access provisioned to the public role, which everyone gets by default
				SELECT
					[UserType]         = '{All Users}',
					[DatabaseUserName] = '{All Users}',
					[LoginName]        = '{All Users}',
					[Role]             = roleprinc.[name],
					[PermissionType]   = perm.[permission_name],
					[PermissionState]  = perm.[state_desc],
					[ObjectType] = CASE perm.[class]
									   WHEN 1 THEN obj.[type_desc]        -- Schema-contained objects
									   ELSE perm.[class_desc]             -- Higher-level objects
								   END,
					[Schema] = objschem.[name],
					[ObjectName] = CASE perm.[class]
									   WHEN 3 THEN permschem.[name]       -- Schemas
									   WHEN 4 THEN imp.[name]             -- Impersonations
									   ELSE OBJECT_NAME(perm.[major_id])  -- General objects
								   END,
					[ColumnName] = col.[name]
				FROM
					--Roles
					sys.database_principals            AS roleprinc
					--Role permissions
					LEFT JOIN sys.database_permissions AS perm      ON perm.[grantee_principal_id] = roleprinc.[principal_id]
					LEFT JOIN sys.schemas              AS permschem ON permschem.[schema_id] = perm.[major_id]
					--All objects
					JOIN      sys.objects              AS obj       ON obj.[object_id] = perm.[major_id]
					LEFT JOIN sys.schemas              AS objschem  ON objschem.[schema_id] = obj.[schema_id]
					--Table columns
					LEFT JOIN sys.columns              AS col       ON col.[object_id] = perm.[major_id]
																	   AND col.[column_id] = perm.[minor_id]
					--Impersonations
					LEFT JOIN sys.database_principals  AS imp       ON imp.[principal_id] = perm.[major_id]
				WHERE
					roleprinc.[type] = 'R'
					AND roleprinc.[name] = 'public'
					AND obj.[is_ms_shipped] = 0


			--======================================================================
)

SELECT * 
FROM CTE_ONE
--WHERE [DatabaseUserName] Like '%SQL%'
ORDER BY
	[UserType],
	[DatabaseUserName],
	[LoginName],
	[Role],
	[Schema],
	[ObjectName],
	[ColumnName],
	[PermissionType],
	[PermissionState],
	[ObjectType]

--OUTPUT

--UserType		DatabaseUserName	LoginName			Role				Schema			ObjectName	ColumnName	PermissionType	PermissionState		ObjectType
--Windows Group	BCC\g_SQL_Level1	BCC\g_SQL_Level1	NULL				CONNECT			GRANT		DATABASE	NULL			NULL				NULL
--Windows Group	BCC\g_SQL_Level1	BCC\g_SQL_Level1	db_owner			NULL			NULL		NULL		NULL			NULL				NULL
--Windows Group	BCC\g_SQL_Level2	BCC\g_SQL_Level2	NULL				CONNECT			GRANT		DATABASE	NULL			NULL				NULL
--Windows Group	BCC\g_SQL_Level2	BCC\g_SQL_Level2	db_denydatawriter	NULL			NULL		NULL		NULL			NULL				NULL
--Windows Group	BCC\g_SQL_Level2	BCC\g_SQL_Level2	db_owner			NULL			NULL		NULL		NULL			NULL				NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		NULL				CONNECT			GRANT		DATABASE	NULL			NULL				NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		NULL				SELECT			GRANT		VIEW		dbo				vwPM_EMPMASTER_1	NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		NULL				SELECT			GRANT		VIEW		dbo				vw_PM_EMPMASTER		NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		NULL				VIEW DEFINITION	GRANT		VIEW		dbo				vwPM_EMPMASTER_1	NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		HR_Deny1			DELETE			DENY		USER_TABLE	dbo				HR_ACCIDENTLOG		NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		HR_Deny1			DELETE			DENY		USER_TABLE	dbo				HR_APPLICANTMASTER	NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		HR_Deny1			DELETE			DENY		USER_TABLE	dbo				HR_ATTENDANCELOG	NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		HR_Deny1			DELETE			DENY		USER_TABLE	dbo				HR_ATTENDANCEMASTER	NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		HR_Deny1			DELETE			DENY		USER_TABLE	dbo				HR_BENEFITLOG		NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		HR_Deny1			DELETE			DENY		USER_TABLE	dbo				HR_BENEFITRATES		NULL
--Windows Group	BCC\g_SQL_User1		BCC\g_SQL_User1		HR_Deny1			DELETE			DENY		USER_TABLE	dbo				HR_CLAIMCOSTLOG		NU			</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQL_SECURITY</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>View all securables for roles</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQL_SECURITY</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>View all securables for roles</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>SELECT --p.*
    OBJECT_NAME(major_id) as ObjectName, USER_NAME(grantee_principal_id) as UserName, permission_name
FROM
    sys.database_permissions p
WHERE
    p.class = 1 AND
    OBJECTPROPERTY(major_id, 'IsMSSHipped') = 0
ORDER BY
    OBJECT_NAME(major_id), USER_NAME(grantee_principal_id), permission_name
    
    
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 
    use barriere
go

SELECT 'GRANT ' + database_permissions.permission_name + ' ON ' +
    CASE database_permissions.class_desc
        WHEN 'SCHEMA' THEN schema_name(major_id)
        WHEN 'OBJECT_OR_COLUMN' THEN
            CASE WHEN minor_id = 0 THEN object_name(major_id) COLLATE Latin1_General_CI_AS_KS_WS
            ELSE (SELECT object_name(object_id) + ' ('+ name + ')'
                  FROM sys.columns 
                  WHERE object_id = database_permissions.major_id 
                  AND column_id = database_permissions.minor_id) end
        ELSE 'other' 
    END + 
    ' TO ' + database_principals.name COLLATE Latin1_General_CI_AS_KS_WS AS NEWDB
FROM sys.database_permissions
JOIN sys.database_principals
ON database_permissions.grantee_principal_id = database_principals.principal_id
LEFT JOIN sys.objects -- consider schemas
ON objects.object_id = database_permissions.major_id
WHERE database_permissions.major_id &gt; 0
AND permission_name in ('SELECT','INSERT','UPDATE','DELETE')</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQL_SECURITY</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>WhichServiceAccount_isBeingUsed_by_Services</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQL_SECURITY</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>WhichServiceAccount_isBeingUsed_by_Services</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--what service accounts are set up to run SQL Server, and
--other services such as Analysis Services and SQL Agent. Service credentials
--control access to various resources, like network shares. 

--It is important that you
--know whether you are running SQL Server as "local system", which will not have
--access to external resources, for example, or a valid Windows service account,
--which will have access to said resources. 

--this trick requires
--xp_cmdshell, the use of which is a habit I roundly
--condemn in others but tolerate in myself. 


--The first thing the script does is to check whether I am executing this query
--against a version of Microsoft SQL Server 2005 or higher: 
--IF  @@microsoftversion / power(2, 24) &gt;= 9 
--The reason for this is that xp_xmdshell has to explicitly be enabled in 2005 and
--beyond, whereas in SQL Server 2000 it is enabled by default, but one has to have
--the required privileges to execute it. 
--If the version is SQL Server 2005 or higher, the script uses
--sp_configure to
--enable
--advanced options followed by xp_cmdshell. I then create a temp table,
--selfishly called
--#MyTempTable, and fill it with the output from the Windows
--Management Instrumentation Command line utility (WMIC).  
--I pipe (what is this, UNIX?) the output to grep, sorry I mean the
--findstr
--command, searching for the value "SQL" in the result set. Next, I parse the long
--text string that is returned, called
--Big_String, into the temporary table.  
--The end result, shown in Table 7.4, is a useful list of all SQL services and the
--accounts that have been configured as login accounts for each service


IF  @@microsoftversion / power(2, 24) &gt;= 9
BEGIN
   EXEC sp_configure 'show advanced options', 1
   RECONFIGURE WITH OVERRIDE

   EXEC sp_configure 'xp_cmdshell', 1

   RECONFIGURE WITH OVERRIDE

END

IF EXISTS ( SELECT  Name
            FROM    tempdb..sysobjects
            WHERE   name LIKE '#MyTempTable%' ) 
    DROP TABLE #MyTempTable

Create Table #MyTempTable
    (
      Big_String nvarchar(500)
    )
Insert  Into #MyTempTable
        EXEC master..xp_cmdshell 'WMIC SERVICE GET Name,StartName | findstr /I SQL'

-- show service  accounts

Select  @@ServerName as ServerName,
        Rtrim(Left(Big_String, charindex('     ', Big_String))) as Service_Name,
        RTrim(LTrim(Rtrim(Substring(Big_String, charindex('     ', Big_String),
                                    len(Big_String))))) as Service_Account
from    #MyTempTable

IF  @@microsoftversion / power(2, 24) &gt;= 9		--Check whether SQL 2005 or higher

   EXEC sp_configure 'xp_cmdshell', 0

   RECONFIGURE WITH OVERRIDE

   EXEC sp_configure 'show advanced options', 0
   RECONFIGURE WITH OVERRIDE
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQLCMD</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Parameters_for_SQLCMD</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQLCMD</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Parameters_for_SQLCMD</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility?view=sql-server-2017
   -a packet_size  
   -A (dedicated administrator connection)  
   -b (terminate batch job if there is an error)  
   -c batch_terminator  
   -C (trust the server certificate)  
   -d db_name  
   -e (echo input)  
   -E (use trusted connection)  
   -f codepage | i:codepage[,o:codepage] | o:codepage[,i:codepage] 
   -g (enable column encryption) 
   -G (use Azure Active Directory for authentication)
   -h rows_per_header  
   -H workstation_name  
   -i input_file  
   -I (enable quoted identifiers)  --&lt;============== Need this for error: "INSERT failed because the following SET options have incorrect settings: 'QUOTED_IDENTIFIER'."
   -j (Print raw error messages)
   -k[1 | 2] (remove or replace control characters)  
   -K application_intent  
   -l login_timeout  								
   -L[c] (list servers, optional clean output)  
   -m error_level  
   -M multisubnet_failover  
   -N (encrypt connection)  
   -o output_file  
   -p[1] (print statistics, optional colon format)  
   -P password  
   -q "cmdline query"  
   -Q "cmdline query" (and exit)  
   -r[0 | 1] (msgs to stderr)  
   -R (use client regional settings)  
   -s col_separator  
   -S [protocol:]server[instance_name][,port]  
   -t query_timeout  
   -u (unicode output file)  
   -U login_id  
   -v var = "value"  
   -V error_severity_level  
   -w column_width  
   -W (remove trailing spaces)  
   -x (disable variable substitution)  
   -X[1] (disable commands, startup script, environment variables, optional exit)  
   -y variable_length_type_display_width  
   -Y fixed_length_type_display_width  
   -z new_password   
   -Z new_password (and exit)  
   -? (usage) </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SQLCMD</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Use_PATH_create_a_bunch_of_Triggers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SQLCMD</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Use_PATH_create_a_bunch_of_Triggers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--_SQLCMD.sql
 
:setvar path "P:\0006_Explorer_Eclipse_Database_UI_Conversion\SQL\6_Triggers\Original_Triggers_from_BCC-EXPLORERDB_2016_07_08\"
 
:r $(path)\prj_0006_TRIG_001_AG_ORDERHEADER_trg_Astec_Internal_Job_Insert.sql
:r $(path)\prj_0006_TRIG_002_AG_ORDERHEADER_trg_Astec_RetailJob_Insert.sql
:r $(path)\prj_0006_TRIG_003_AP_VENDORMASTER_trg_Astec_Vendor_Insert.sql
:r $(path)\prj_0006_TRIG_004_AP_VENDORMASTER_trg_B2W_Insert_SubContractor.sql
:r $(path)\prj_0006_TRIG_005_AP_VENDORMASTER_trg_B2W_Insert_Vendor.sql
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SSRS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>02___p_0000_FUNC_001_unSplit</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SSRS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>02___p_0000_FUNC_001_unSplit</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--p_0000_FUNC_001_unSplit.sql

use d1_IT
go


CREATE FUNCTION [dbo].[p_0000_FUNC_001_unSplit]
   (@RepParam nvarchar(max), @Delim char(1)= ',')       --&lt;=========== Here is the delimiter
RETURNS @Values TABLE (Item nvarchar(100))AS
-- based on John Sansoms StackOverflow answer:
-- http://stackoverflow.com/a/512300/22194

  BEGIN
  DECLARE @chrind INT
  DECLARE @Piece nvarchar(100)
  SELECT @chrind = 1 
  WHILE @chrind &gt; 0
    BEGIN
      SELECT @chrind = CHARINDEX(@Delim,@RepParam)
      IF @chrind  &gt; 0
        SELECT @Piece = LEFT(@RepParam,@chrind - 1)
      ELSE
        SELECT @Piece = @RepParam
      INSERT  @Values(Item) VALUES(@Piece)
      SELECT @RepParam = RIGHT(@RepParam,LEN(@RepParam) - @chrind)
      IF LEN(@RepParam) = 0 BREAK
    END
  RETURN
  END </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SSRS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>03_DrillThrough_02_OneWayAggregateFromDetails</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SSRS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>03_DrillThrough_02_OneWayAggregateFromDetails</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--03_DrillThrough_02_OneWayAggregateFromDetails
--========================================================

use RiskMngt
go

--P_0020_TASK_011_REP_02_SP_01_MAIN_MTDChargeOffs_byProduct_v3.sql
/*
	************************************************************************************
	SSRS Report: Aggregate By Production
	NOTE: 
	Uses: 
	Created: 06/11/2019
	By: glenn garson
	************************************************************************************
*/

alter Procedure [Reporting].[P_0020_TASK_011_REP_02_SP_01_MAIN_MTDChargeOffs_byProduct](
																					@LIST_ALLOCATION_MIN FLOAT
																					, @LIST_ALLOCATION_MAX FLOAT
																					, @ShowAllBetweenMinAndMaxLIST bit
																					)
	as

IF OBJECT_ID('tempdb..#Details01') IS NOT NULL
	DROP TABLE #Details01

CREATE TABLE #Details01
(
	[SHAW_Acct_Number] [varchar](20) NOT NULL,
	[SHAW_Cust_Number] [varchar](7) NULL,
	[Client_App_ID] [varchar](15) NULL,
	[Region] [varchar](20) NULL,
	[Branch] [varchar](50) NULL,
	[Loan_Officer] [varchar](101) NULL,
	[CO_Amount] [money] NULL,
	[NumberOfPaymentsMade] [int] NULL,
	[Contract_Date] [datetime] NULL,
	[Booked_Date] [datetime] NULL,
	[CO_date] [datetime] NOT NULL,
	[DPD_at_CO] [int] NULL,
	[DaysFromContractToChargeOff] [int] NULL,
	[LIST] [varchar](7) NULL,
	[List_Description] [varchar](30) NULL,
	[Customer_Name] [varchar](130) NULL,
	[Dealer_Name] [varchar](60) NULL,
	[ActiveDealer] [varchar](3) NOT NULL,
	[FBCO] [varchar](7) NOT NULL,
	[FBCO_Dollars] [money] NULL,
	[nonFBCO] [varchar](7) NOT NULL,
	[nonFBCO_Dollar] [money] NULL,
	[Sale_Proceeds] [decimal](15, 2) NULL,
	[InsuranceCheckPosted_Dollars] [decimal](15, 2) NULL,
	[Veh_Model_Year] [varchar](56) NULL,
	[Booked_LTV] [decimal](12, 4) NULL,
	[Product] [varchar](14) NOT NULL,
	[CO_Type] [varchar](18) NOT NULL,
	[Credit_Tier] [varchar](3) NULL,
	[theCount] [int] NULL,
	[countThisOne] [int] NOT NULL,  --&lt;========== changed 6/14/2019
	[parm_LIST_ALLOCATION_MIN] [float] NULL,
	[parm_LIST_ALLOCATION_MAX] [float] NULL,
	[parm_ShowAllBetweenMinAndMaxLIST] [bit] NULL,
	[parm_LIST] [float] NULL,
	[parm_Client_App_ID] [nvarchar](15) NULL,
	[parm_SHAW_CUSTOMER_NUMBER] [nvarchar](7) NULL,
	[parm_Product] [nvarchar](15) NULL,
	[parm_SHAW_Account_Number] [nvarchar](20) NULL,
	[parm_CO_Date] [date] NULL
)

--INSERT #Details01 EXEC	[RiskMngt].[Reporting].[P_0020_TASK_011_SP_01_MAIN_MTD_chargeOff_details]
--		@LIST_ALLOCATION_MIN = 1270,
--		@LIST_ALLOCATION_MAX = 1289,
--		@ShowAllBetweenMinAndMaxLIST = 1

INSERT #Details01 EXEC	[RiskMngt].[Reporting].[P_0020_TASK_011_SP_01_MAIN_MTD_chargeOff_details]
		@LIST_ALLOCATION_MIN = @LIST_ALLOCATION_MIN,
		@LIST_ALLOCATION_MAX = @LIST_ALLOCATION_MAX,
		@ShowAllBetweenMinAndMaxLIST = @ShowAllBetweenMinAndMaxLIST


--SELECT *
--FROM #Details01
--Order by CO_date

SELECT DISTINCT
	   Product
	   , SUM(CO_Amount) OVER(Partition by Product) as  CO_Amount__SUM_byProduct	
	   , AVG([DPD_at_CO]) OVER(Partition by Product) as  DPD_at_CO__AVG_byProduct	
	   --, COUNT(*) OVER(Partition by Product) as  COUNT_byProduct
	   ,SUM(countThisOne) OVER(Partition by Product) as  COUNT_byProduct   --&lt;========== changed 6/14/2019 per Dave
	   , SUM(CASE
				WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
				ELSE 0
				END
				) OVER(Partition by Product) as  FBCO__COUNT_byProduct
	   , SUM(CASE
				WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
				ELSE 0
				END
				) OVER(Partition by Product) as  nonFBCO__COUNT_byProduct

	   , SUM([FBCO_Dollars]) OVER(Partition by Product) as  FBCO_Dollars__SUM_byProduct
	   , SUM([nonFBCO_Dollar]) OVER(Partition by Product) as  nonFBCO_Dollars__SUM_byProduct

	   , (CASE
				WHEN	(	
							SUM(CASE
									WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
									ELSE 0
									END
									) OVER(Partition by Product) = 0 
						) 

					THEN 0
				ELSE	(
							SUM([FBCO_Dollars]) OVER(Partition by Product)
							/
							SUM(CASE
											WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
											ELSE 0
											END
											) OVER(Partition by Product)
						)
				END

		  ) as CO_Severity_FBCO__byProduct

	   , (CASE
				WHEN	(	
							SUM(CASE
									WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
									ELSE 0
									END
									) OVER(Partition by Product) = 0 
						)

					THEN 0
				ELSE	(
							SUM([nonFBCO_Dollar]) OVER(Partition by Product)
							/
							SUM(CASE
											WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
											ELSE 0
											END
											) OVER(Partition by Product)
						)
				END

		  ) as CO_Severity_nonFBCO__byProduct

	   , (CASE
				WHEN	(	
							SUM(CASE
									WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
									ELSE 0
									END
									)  OVER(Partition by Product)
							+
							SUM(CASE
									WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
									ELSE 0
									END
									) OVER(Partition by Product)
							= 0
						)

					THEN 0
				ELSE	(
							SUM([nonFBCO_Dollar] + [FBCO_Dollars]) OVER(Partition by Product)
							/
							(
								SUM(CASE
										WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
										ELSE 0
										END
										)  OVER(Partition by Product)
								+
								SUM(CASE
										WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
										ELSE 0
										END
										) OVER(Partition by Product)
							)
						)
				END

		  ) as CO_Severity_ALL__byProduct


FROM #Details01

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SSRS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>03_DrillThrough_03_TwoWayAggregateFromDetails</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SSRS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>03_DrillThrough_03_TwoWayAggregateFromDetails</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--03_DrillThrough_03_TwoWayAggregateFromDetails
--========================================================

use RiskMngt
go

--P_0020_TASK_011_REP_06_SP_01_MAIN_MTDChargeOffs_byProduct_CO_Date_v5.sql
/*
	************************************************************************************
	SSRS Report: Aggregate By Product &amp; Charge-Off Date
	NOTE: 
	Uses: 
	Created: 06/12/2019
	By: glenn garson
	************************************************************************************
*/


--=============================================DEBUG START
--DECLARE @LIST_ALLOCATION_MIN FLOAT  --(SELECT VALUE FROM RiskMngt.dbo.CRD_REPORT_VARIABLES WHERE REPORT = '60to89kpi' AND VARIABLE = 'LIST_ALLOCATION_MIN');
--DECLARE @LIST_ALLOCATION_MAX FLOAT  --(SELECT VALUE FROM RiskMngt.dbo.CRD_REPORT_VARIABLES WHERE REPORT = '60to89kpi' AND VARIABLE = 'LIST_ALLOCATION_MAX');

--DECLARE @ShowAllBetweenMinAndMaxLIST bit

--DECLARE @LIST as FLOAT
--DECLARE @Client_App_ID NVARCHAR(15) 
--DECLARE @SHAW_CUSTOMER_NUMBER NVARCHAR(7)		--i.e. F0019_CUSTOMER_NUMBER
--DECLARE @Product NVARCHAR(15)
--DECLARE @SHAW_Account_Number NVARCHAR(20)		--i.e. F0003_USER_KEY
--DECLARE @CO_Date Date
----===========================================================================default LIST parameters For MOST testing
--SELECT @LIST_ALLOCATION_MIN = 1
--SELECT @LIST_ALLOCATION_MAX = 5000
----SELECT @LIST_ALLOCATION_MIN = NULL			
----SELECT @LIST_ALLOCATION_MAX = NULL		

--SELECT @ShowAllBetweenMinAndMaxLIST = 1	
----===========================================================================Test values for non-list Parameters

--SELECT @LIST = NULL							--1277
--SELECT @Client_App_ID = ''				--'6646923'
--SELECT @SHAW_CUSTOMER_NUMBER = ''			--'3572534'
--SELECT @Product = 'CBT'						--'Indirect'
--SELECT @SHAW_Account_Number = ''			--'00000100135725340001'  ''
--SELECT @CO_Date = ''						--'2019-06-05'


--=============================================DEBUG END

alter Procedure [Reporting].[P_0020_TASK_011_REP_06_SP_01_MAIN_MTDChargeOffs_byProduct_CO_Date](
																					@LIST_ALLOCATION_MIN FLOAT
																					, @LIST_ALLOCATION_MAX FLOAT
																					, @ShowAllBetweenMinAndMaxLIST bit
																					)
	as

IF OBJECT_ID('tempdb..#Details01') IS NOT NULL
	DROP TABLE #Details01

CREATE TABLE #Details01
(
	[SHAW_Acct_Number] [varchar](20) NOT NULL,
	[SHAW_Cust_Number] [varchar](7) NULL,
	[Client_App_ID] [varchar](15) NULL,
	[Region] [varchar](20) NULL,
	[Branch] [varchar](50) NULL,
	[Loan_Officer] [varchar](101) NULL,
	[CO_Amount] [money] NULL,
	[NumberOfPaymentsMade] [int] NULL,
	[Contract_Date] [datetime] NULL,
	[Booked_Date] [datetime] NULL,
	[CO_date] [datetime] NOT NULL,
	[DPD_at_CO] [int] NULL,
	[DaysFromContractToChargeOff] [int] NULL,
	[LIST] [varchar](7) NULL,
	[List_Description] [varchar](30) NULL,
	[Customer_Name] [varchar](130) NULL,
	[Dealer_Name] [varchar](60) NULL,
	[ActiveDealer] [varchar](3) NOT NULL,
	[FBCO] [varchar](7) NOT NULL,
	[FBCO_Dollars] [money] NULL,
	[nonFBCO] [varchar](7) NOT NULL,
	[nonFBCO_Dollar] [money] NULL,
	[Sale_Proceeds] [decimal](15, 2) NULL,
	[InsuranceCheckPosted_Dollars] [decimal](15, 2) NULL,
	[Veh_Model_Year] [varchar](56) NULL,
	[Booked_LTV] [decimal](12, 4) NULL,
	[Product] [varchar](14) NOT NULL,
	[CO_Type] [varchar](18) NOT NULL,
	[Credit_Tier] [varchar](3) NULL,
	[theCount] [int] NULL,
	[countThisOne] [int] NOT NULL,  --&lt;========== changed 6/14/2019
	[parm_LIST_ALLOCATION_MIN] [float] NULL,
	[parm_LIST_ALLOCATION_MAX] [float] NULL,
	[parm_ShowAllBetweenMinAndMaxLIST] [bit] NULL,
	[parm_LIST] [float] NULL,
	[parm_Client_App_ID] [nvarchar](15) NULL,
	[parm_SHAW_CUSTOMER_NUMBER] [nvarchar](7) NULL,
	[parm_Product] [nvarchar](15) NULL,
	[parm_SHAW_Account_Number] [nvarchar](20) NULL,
	[parm_CO_Date] [date] NULL
)

INSERT #Details01 EXEC	[RiskMngt].[Reporting].[P_0020_TASK_011_SP_01_MAIN_MTD_chargeOff_details]
		@LIST_ALLOCATION_MIN = @LIST_ALLOCATION_MIN,
		@LIST_ALLOCATION_MAX = @LIST_ALLOCATION_MAX,
		@ShowAllBetweenMinAndMaxLIST = @ShowAllBetweenMinAndMaxLIST


--SELECT *
--FROM #Details01
--Order by CO_date

;WITH cte_Aggregates AS
(
			SELECT DISTINCT
				   Product, CO_date
				   , SUM(CO_Amount) OVER(Partition by Product, CO_date) as  CO_Amount__SUM_byProduct_CO_date	
				   , AVG([DPD_at_CO]) OVER(Partition by Product, CO_date) as  DPD_at_CO__AVG_byProduct_CO_date
				   , SUM(countThisOne ) OVER(Partition by Product, CO_date) as  COUNT_byProduct_CO_date	--&lt;========== changed 6/14/2019				   	
				   --, COUNT(*) OVER(Partition by Product, CO_date) as  COUNT_byProduct_CO_date
				   , SUM(CASE
							WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
							ELSE 0
							END
							) OVER(Partition by Product, CO_date) as  FBCO__COUNT_byProduct_CO_date
				   , SUM(CASE
							WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
							ELSE 0
							END
							) OVER(Partition by Product, CO_date) as  nonFBCO__COUNT_byProduct_CO_date

				   , SUM([FBCO_Dollars]) OVER(Partition by Product, CO_date) as  FBCO_Dollars__SUM_byProduct_CO_date
				   , SUM([nonFBCO_Dollar]) OVER(Partition by Product, CO_date) as  nonFBCO_Dollars__SUM_byProduct_CO_date

				   , (CASE
							WHEN	(	
										SUM(CASE
												WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
												ELSE 0
												END
												) OVER(Partition by Product, CO_date) = 0 
									) 

								THEN 0
							ELSE	(
										SUM([FBCO_Dollars]) OVER(Partition by Product, CO_date)
										/
										SUM(CASE
														WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
														ELSE 0
														END
														) OVER(Partition by Product, CO_date)
									)
							END

					  ) as CO_Severity_FBCO__byProduct_CO_date

				   , (CASE
							WHEN	(	
										SUM(CASE
												WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
												ELSE 0
												END
												) OVER(Partition by Product, CO_date) = 0 
									)

								THEN 0
							ELSE	(
										SUM([nonFBCO_Dollar]) OVER(Partition by Product, CO_date)
										/
										SUM(CASE
														WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
														ELSE 0
														END
														) OVER(Partition by Product, CO_date)
									)
							END

					  ) as CO_Severity_nonFBCO__byProduct_CO_date

				   , (CASE
							WHEN	(	
										SUM(CASE
												WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
												ELSE 0
												END
												)  OVER(Partition by Product, CO_date)
										+
										SUM(CASE
												WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
												ELSE 0
												END
												) OVER(Partition by Product, CO_date)
										= 0
									)

								THEN 0
							ELSE	(
										SUM([nonFBCO_Dollar] + [FBCO_Dollars]) OVER(Partition by Product, CO_date)
										/
										(
											SUM(CASE
													WHEN UPPER(LTRIM(RTRIM([FBCO]))) = 'YES' THEN 1
													ELSE 0
													END
													)  OVER(Partition by Product, CO_date)
											+
											SUM(CASE
													WHEN UPPER(LTRIM(RTRIM([nonFBCO]))) = 'YES' THEN 1
													ELSE 0
													END
													) OVER(Partition by Product, CO_date)
										)
									)
							END

					  ) as CO_Severity_ALL__byProduct_CO_date



			FROM #Details01
)

SELECT 
		 [Product]
		, [CO_date]
		, [CO_Amount__SUM_byProduct_CO_date]
		, [DPD_at_CO__AVG_byProduct_CO_date]
		, [COUNT_byProduct_CO_date]
		, [FBCO__COUNT_byProduct_CO_date]
		, [nonFBCO__COUNT_byProduct_CO_date]
		, [FBCO_Dollars__SUM_byProduct_CO_date]
		, [nonFBCO_Dollars__SUM_byProduct_CO_date]
		, [CO_Severity_FBCO__byProduct_CO_date]
		, [CO_Severity_nonFBCO__byProduct_CO_date]
		, [CO_Severity_ALL__byProduct_CO_date]
FROM cte_Aggregates</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>SSRS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SSRS_Table_info</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>SSRS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SSRS_Table_info</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
from: http://sornanara.blogspot.com/2011/05/ssrs-reportserver-database-tables.html 
Part I, II, II
/*
Let us take a look at below 3 tables.

                                              1. Catalog
                                              2. DataSource
                                              3. DataSets

Catalog

Stores the master data about all the objects related to SSRS listed below 
  
1 = Folder
2 = Report (.rdl)
3 = .XML 
4 = Link Report 
5 = Data Source (.rds) 
6 = Model 
8 = Shared Dataset
9 = Report Part 

This is the base master table where all the objects related to the SSRS is stored.

Some important fields
Parentid   - Under which object this object is present.
Type         - Type of the object as metioned above.
Content    - Has the report xml stored in varbinary format.
Properties - Has the XML with the properties of the object.
Parameter - Has the XML with parameters used in the reports.

  
DataSource
Stores the list of shared and embedded data sources available.

Some important fields
ItemId - Reference to the catalog table
Link     - Reference to the Report to which this datasource is linked.

  
DataSets
Stores the list of the shared datasets available. 

Some important fields
ItemId - Reference to the catalog table.
LinkId  - Reference to the Report to which this datasource is linked.
Name   - DataSet Name in the report.

Sample usage queries

1. To View the Report code in XML format from content field in Catalog Table
*/

SELECT  Name,Convert(XML,(Convert(VARBINARY(MAX),Content))) AS ReportXML
  FROM  ReportServer.dbo.Catalog
 WHERE  Content IS NOT NULL
   AND  [Type] = 2 -- For Report objects alone
   
--2. Get the Report's Created/Modified User and Created/Modified Dates.

SELECT Name
      ,CreatedBy = U.UserName
      ,CreationDate = C.CreationDate
      ,ModifiedBy = UM.UserName
      ,ModifiedDate
  FROM Reportserver.dbo.Catalog C
  JOIN Reportserver.dbo.Users U
    ON C.CreatedByID = U.UserID
  JOIN Reportserver.dbo.Users UM
    ON c.ModifiedByID = UM.UserID
 WHERE Name = 'ReportName'

--3. Get the List of Report Parameters for the given Report

SELECT  Name = Paravalue.value('Name[1]', 'VARCHAR(250)')
       ,Type = Paravalue.value('Type[1]', 'VARCHAR(250)')
       ,Nullable = Paravalue.value('Nullable[1]', 'VARCHAR(250)')
       ,AllowBlank = Paravalue.value('AllowBlank[1]', 'VARCHAR(250)')
       ,MultiValue = Paravalue.value('MultiValue[1]', 'VARCHAR(250)')
       ,UsedInQuery = Paravalue.value('UsedInQuery[1]', 'VARCHAR(250)')
       ,Prompt = Paravalue.value('Prompt[1]', 'VARCHAR(250)')
       ,DynamicPrompt = Paravalue.value('DynamicPrompt[1]', 'VARCHAR(250)')
       ,PromptUser = Paravalue.value('PromptUser[1]', 'VARCHAR(250)')
       ,State = Paravalue.value('State[1]', 'VARCHAR(250)')
 FROM (
     SELECT C.Name,CONVERT(XML,C.Parameter) AS ParameterXML
       FROM  ReportServer.dbo.Catalog C
      WHERE  C.Content is not null
        AND  C.Type  = 2
        AND  C.Name  =  'ReportName'
    ) a
CROSS APPLY ParameterXML.nodes('//Parameters/Parameter') p ( Paravalue )

--4. Get the Data Sources used in the Report
--Note : The XML Schema used here is for SQL 2011. You need to change it to make it work for other versions. To see the schema use the first query in the samples list.

WITH XMLNAMESPACES ( DEFAULT 'http://schemas.microsoft.com/sqlserver/reporting/2010/01/reportdefinition', 'http://schemas.microsoft.com/SQLServer/reporting/reportdesigner' AS rd )
SELECT  ReportName     = name
       ,DataSourceName   = x.value('(@Name)[1]', 'VARCHAR(250)')
       ,DataProvider   = x.value('(ConnectionProperties/DataProvider)[1]','VARCHAR(250)')
       ,ConnectionString = x.value('(ConnectionProperties/ConnectString)[1]','VARCHAR(250)')
  FROM (  SELECT C.Name,CONVERT(XML,CONVERT(VARBINARY(MAX),C.Content)) AS reportXML
           FROM  ReportServer.dbo.Catalog C
          WHERE  C.Content is not null
            AND  C.Type  = 2
      AND  C.Name  = 'ReportName'
        ) a
  CROSS APPLY reportXML.nodes('/Report/DataSources/DataSource') r ( x )
 ORDER BY name ;

--5. Get the Data Sets used in the Report.
--Note : The XML Schema used here is for SQL 2011. You need to change it to make it work for other versions. To see the schema use the first query in the samples list.

WITH XMLNAMESPACES ( DEFAULT 'http://schemas.microsoft.com/sqlserver/reporting/2010/01/reportdefinition', 'http://schemas.microsoft.com/SQLServer/reporting/reportdesigner' AS rd )
SELECT  ReportName    = name
       ,DataSetName    = x.value('(@Name)[1]', 'VARCHAR(250)')
       ,DataSourceName  = x.value('(Query/DataSourceName)[1]','VARCHAR(250)')
       ,CommandText    = x.value('(Query/CommandText)[1]','VARCHAR(250)')
       ,Fields      = df.value('(@Name)[1]','VARCHAR(250)')
       ,DataField    = df.value('(DataField)[1]','VARCHAR(250)')
       ,DataType    = df.value('(rd:TypeName)[1]','VARCHAR(250)')
  FROM (  SELECT C.Name,CONVERT(XML,CONVERT(VARBINARY(MAX),C.Content)) AS reportXML
           FROM  ReportServer.dbo.Catalog C
          WHERE  C.Content is not null
            AND  C.Type = 2
         AND  C.Name = 'ReportName'
     ) a
  CROSS APPLY reportXML.nodes('/Report/DataSets/DataSet') r ( x )
  CROSS APPLY x.nodes('Fields/Field') f(df)
ORDER BY name
--6. Get the list of Data Sources used by Reports using DataSources Table.

SELECT D.Name
       ,'Using Report '
      = CASE
        WHEN D.Name IS NOT NULL THEN  C.Name
        ELSE 'Shared Data Source'
        END
      ,'IsSharedDataSource' = CLink.Name
     FROM DataSource D
     JOIN Catalog C
     ON D.ItemID = C.ItemID
LEFT JOIN Catalog CLink
     ON Clink.ItemID = D.Link
  WHERE C.Name = 'ReportName'   

/*  
Today let us look into the below tables

1. Subscription
2. Schedule
3. ReportSchedule
4. ActiveSubscription
5. Notifications
6. Event
7. Batch

Subscription

This table stores the subscriptions created by the user.

Some important fields

Description           - Name or detail of the subscription
Laststatus             - Last status of message of the subscription
Eventype              - Event type which has used the subscription
Parameters           - XML value with the parameters used while running the subscription
DeliveryExtension - The extension to which the report is delivered

Schedule

Stores the details of the schedules like shared schedules , TimedSubscription , ReportHistorySchedule

Some important fields

Name                    - Schedule Name
StartDate              - Schedule StartDate
NextRunTime       - Next run time for the schedule
LastRunTime        - Last Run time of the schedule
Endate                 - The end date for the schedule
State                    - State of the Subscription. If state &gt; 2 , the subscription is expired i.e, endate has crossed.
RecurrenceType   - Stores the recurrencetype of the schedule
                              1 - Once
                              2 - Hourly 
                              4 - Daily / Weekly
                              6 - Monthly
EventType           - Stores the eventtype 
                              SharedSchedule - Shared schedule
                              TimedSubscription - Schedule created within the subscription
                              RefreshCache - Schedule created for refreshing the cache.

ReportSchedule

Stores the mapping between Schedule , Report &amp; Subscription.

ActiveSubscriptions

Stores the subscription notification consolidated results.

Notifications

Stores the notification sent by the subscriptions.

Event

Internal Table. When the scheduled time comes for a scheduler , the SQL Server Agent generates an event by executing the scheduled job. The job inserts a row in the Event table of the ReportServer database. This row serves as an event for the Scheduling and Delivery Processor. The event record will be deleted after the process.

Batch

Internal Table. One event will be assigned as batches and processed. The batch record also will be deleted after process.

Sample usage queries

1. Get the Schedule List with type and Recurrence	*/

SELECT Name
    ,StartDate
    ,EndDate
    ,NextRunTime
    ,LastRunTime
    ,LastRunStatus
    ,RecurrenceType = CASE RecurrenceType
            WHEN  1 THEN 'Once'
            WHEN  2 THEN 'Hourly '
            WHEN  4 THEN 'Daily / Weekly'
            WHEN  6 THEN 'Monthly'
            End
   ,EventType
FROM Schedule

--2. Query to get the list of Subscription and it's schedule for a given report

SELECT Reportname = c.Name
      ,SubscriptionDesc=su.Description
      ,Subscriptiontype=su.EventType
      ,su.LastStatus
      ,su.LastRunTime
      ,su.Parameters
      ,Schedulename=sch.Name
      ,sch.Type
      ,sch.EventType
  FROM Subscriptions su
  JOIN Catalog c
    ON su.Report_OID = c.ItemID
  JOIN ReportSchedule rsc
    ON rsc.ReportID = c.ItemID
   AND rsc.SubscriptionID = su.SubscriptionID
  JOIN Schedule Sch
    ON rsc.ScheduleID = sch.ScheduleID
 WHERE c.Name = '@ReportName'

--3. Query to get the notification details sent for the given report

SELECT C.Name
      ,S.Description
      ,N.NotificationEntered
      ,A.TotalNotifications
      ,A.TotalSuccesses
      ,A.TotalFailures
  FROM Notifications N
  JOIN ActiveSubscriptions A
    ON N.SubscriptionID = A.SubscriptionID
   AND N.ActivationID = A.ActiveID
  JOIN Catalog C
    ON C.ItemID = N.ReportID
  JOIN Subscriptions S
    ON S.SubscriptionID = N.SubscriptionID
 WHERE c.Name = '@ReportName'  
 
 /*
 SSRS - Reportserver Database Tables Explored - Part 3
Today let us take look into the security related below tables

1. Users
2. Policies
3. Roles
4. PolicyRole
5. CachePolicy
6. SecData
7. ModelItemPolicy 
  
Users 

Stores the list of users 

Some important fields
Usertype - Stores User type 
                 0 – system defined
                 1 – User Defined

Policies

Stores a one policy per userdefined object created. If policy flag is 1 , that is system defined policy for the system administrators.

The policyId created will be mapped to each userdefined object in catalog table.

Roles

Stores the Roles related to the Reports. Presently available roles are

Browser	May view folders, reports and subscribe to reports.
Content Manager	May manage content in the Report Server. This includes folders, reports and resources.
Model Item Browser	Allows users to view model items in a particular model.
My Reports	May publish reports and linked reports; manage folders, reports and resources in a users My Reports folder.
Publisher	May publish reports and linked reports to the Report Server.
Report
Builder	May view report definitions.
System Administrator	View and modify system role assignments, system role definitions, system properties,and shared schedules.
System User	View system properties, shared schedules, and allow use of Report Builder or other clients that execute report definitions.

PolicyRole

This stores the mapping between the User , Role and policy of a catalog object.

CachePolicy

Stores the cache details in processing options section of reports. If you select donot cache option no records will be inserted in this table.

SecData

Stores the total permission for the reports and other objects in XML format .

ModelItemPolicy

This table stores the data of the access provided at the modelitem level in ModelItemSecurity tab under the Manage model.

Sample usage queries

1. Get the users and their roles mapped for the reports	*/

SELECT c.name,
       u.username,
       u.authtype,
       r.rolename,
       r.DESCRIPTION
 FROM users u
 JOIN policyuserrole pur
   ON u.userid = pur.userid
 JOIN policies p
   ON p.policyid = pur.policyid
 JOIN roles r
   ON r.roleid = pur.roleid
 JOIN catalog c
   ON c.policyid = p.policyid
WHERE c.TYPE = 2 -- For Reports Only
ORDER BY name,username 

--2. Get the Cache Policy for the Reports

SELECT c.name,
       cp.cacheexpiration,
       cp.expirationflags
 FROM  cachepolicy cp
 JOIN  catalog c
   ON  c.itemid = cp.reportid

--3. Get the Security Details XML from SecData Table

 SELECT c.name,
       CONVERT(XML, sec.xmldescription)
  FROM catalog c
  JOIN secdata sec
    ON c.policyid = sec.policyid
 WHERE c.TYPE = 2 

--4. Get the Model Item's User and Role

SELECT c.name,
       mip.modelitemid,
       u.username,
       r.rolename
  FROM catalog c
  JOIN modelitempolicy mip
    ON c.itemid = mip.catalogitemid
  JOIN policies p
    ON p.policyid = mip.policyid
  JOIN policyuserrole pur
    ON p.policyid = pur.policyid
  JOIN users u
    ON u.userid = pur.userid
  JOIN roles r
    ON r.roleid = pur.roleid 
    
/*
SSRS - Reportserver Database Tables Explored - Part 4
In this post of this series let us take a look into the below tables

1.SnapshotData
2.History
3.ExecutionLogStorage
4.ModelDrill
5.ModelPerspective

SnapshotData

Stores the configuration of the snapshot for the report.

History

Has the history of snapshot of reports with the parameters and other details.

ExecutionLogStorage

Has the execution log for each and every report launched in the reporting server. This table data is help full for performance tuning the report.
Some Important Fields
Parameters	Parameters passed for the report
TimeStart	Start time
TimeEnd	End time
TimeDataRetrieval	Total Reporting time = Timeprocessing + TimeRendering
TimeProcessing	Time taken to retrieve the data from database
TimeRendering	Time taken for rendering the report
Status	Status success or failure

ModelDrill

Stores the details of the custom click through report configured for the model items. This can be set up on ModelsàManage à Click through.

ModelPerspective

Stores the name and the perspectives list created with in the model. A perspective can be created in BIDS by rightclick on Model àNew à Perspective. 

This is similar to SSAS perspective to group the attributes. 

Sample usage queries 
  
1. Get the details of the history pf the snapshot with report name and schedule used to create the snapshot */


SELECT c.name,
       h.snapshotdate,
       s.DESCRIPTION,
       s.effectiveparams,
       s.queryparams,
       sc.name,
       sc.nextruntime
  FROM history h
  JOIN snapshotdata s
    ON h.snapshotdataid = s.snapshotdataid
  JOIN catalog c
    ON c.itemid = h.reportid
  JOIN reportschedule rs
    ON rs.reportid = h.reportid
  JOIN schedule sc
    ON sc.scheduleid = rs.scheduleid
 WHERE rs.reportaction = 2 -- Create schedule

--2. Get the execution details of a given report with the details like User executing the report , Execution time etc

SELECT c.name,
       CASE e.requesttype
       WHEN 1 THEN 'Subscription'
       WHEN 0 THEN 'Report Launch'
       ELSE ''
       END,
       e.*
  FROM executionlog e
  JOIN catalog c
    ON e.reportid = c.itemid
 WHERE c.name = N'@Reportname'     
/*
SSRS - Reportserver Database Tables Explored - Part 5 (Final)
In this last post of this series let us look into the below tables.All the below tables are SSRS internal tables which used by the Report Server to stores values needed for it's execution and other operations 

1.ConfigurationInfo
2.RunningJobs
3.Keys
4.UpgradeInfo
5.ServerUpgradeHistory
6.DBUpgradeHistory
7.ChunkData
8.ChunkSegmentMapping
9.Segment
10.SegmentedChunk
11.ServerParametersInstance
12.SubscriptionsBeingDeleted

ConfigurationInfo

Has server level configuration info like “EnableRemoteErrors” . If this set to true it will give detailed error from SSRS. This table can be manually updated.

RunningJobs

Internal Table : This stores the jobs currently which is associated with scheduling , snapshot etc

Keys

Internal Table. Has the details about the installation , symmetric encryption key and scale out option keys.

UpgradeInfo

Internal Table. Has the items and status for the items to be taken care during the server upgrade.

ServerUpgradeHistory

Internal Table. Has the details of the previous server version and current server versions in case of upgrades.

DBUpgradeHistory

Internal Table. Has the Database upgrade history for the DB upgrade.

ChunkData

Internal Table : Used for storing the data while delivering the reports using Deliver extensions

ChunkSegmentMapping

Internal Table : Used for storing the data while delivering the reports using Deliver extensions

Segment

Internal Table : Used for storing the data while delivering the reports using Deliver extensions

SegmentedChunk

Internal Table : Used for storing the data while delivering the reports using Deliver extensions

ServerParametersInstance

Internal Table.

SubscriptionsBeingDeleted

Internal Table.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>1_DeleteRecord_With_Parm</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>1_DeleteRecord_With_Parm</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>/* gig_Tracking_Delete_record.sql
--	This inserts or adds a record into the TrackingWebSites table
*/

use MGM_Intranet
go
Create Procedure gig_Tracking_Delete_record(
				@ID int
				) AS

--                "DELETE FROM TrackingWebSites " &amp; _
--                "WHERE ID = " &amp; strID

DELETE TrackingWebSites 
WHERE ID = @ID


RETURN(@@ERROR)

-- @@ERROR should be 0 if everything is ok.
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ALL_select_checkBox_in_SSRS__SQL_FUNCTION</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ALL_select_checkBox_in_SSRS__SQL_FUNCTION</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--ALL_select_checkBox_in_SSRS__SQL_FUNCTION

--prj_0013_FN_401_unSplit.sql
USE B2W_Reports
go
CREATE FUNCTION [dbo].[prj_0013_FN_401_unSplit]
   (@RepParam nvarchar(max), @Delim char(1)= ',')       --&lt;=========== Here is the delimiter
RETURNS @Values TABLE (Item nvarchar(100))AS
-- based on John Sansoms StackOverflow answer:
-- http://stackoverflow.com/a/512300/22194

  BEGIN
  DECLARE @chrind INT
  DECLARE @Piece nvarchar(100)
  SELECT @chrind = 1 
  WHILE @chrind &gt; 0
    BEGIN
      SELECT @chrind = CHARINDEX(@Delim,@RepParam)
      IF @chrind  &gt; 0
        SELECT @Piece = LEFT(@RepParam,@chrind - 1)
      ELSE
        SELECT @Piece = @RepParam
      INSERT  @Values(Item) VALUES(@Piece)
      SELECT @RepParam = RIGHT(@RepParam,LEN(@RepParam) - @chrind)
      IF LEN(@RepParam) = 0 BREAK
    END
  RETURN
  END 

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Bulk_Insert_DoubleQoutes_DynamicSQL_SP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Bulk_Insert_DoubleQoutes_DynamicSQL_SP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- http://www.sqlteam.com/article/using-bulk-insert-to-load-a-text-file

-- This example combines dynamic SQL, BULK INSERT 
--		and the proper handling of double-quotes


-- To Execute the SP

EXEC ps_StudentList_Import 'c:\TxtFile1.txt',1, 1
EXEC ps_StudentList_Import 'c:\TxtFile2.txt',1, 2



-- Using BULK INSERT to Load a Text File


SET QUOTED_IDENTIFIER OFF
go
CREATE PROCEDURE ps_StudentList_Import
@PathFileName varchar(100),
@OrderID integer,
@FileType tinyint
AS

--Step 1: Build Valid BULK INSERT Statement
DECLARE @SQL varchar(2000)
IF @FileType = 1
 BEGIN
  -- Valid format: "John","Smith","john@smith.com"
  SET @SQL = "BULK INSERT TmpStList FROM '"+@PathFileName+"' WITH (FIELDTERMINATOR = '"",""') "
 END
ELSE
 BEGIN
  -- Valid format: John,Smith,john@smith.com
  SET @SQL = "BULK INSERT TmpStList FROM '"+@PathFileName+"' WITH (FIELDTERMINATOR = ',') "
 END

--Step 2: Execute BULK INSERT statement
EXEC (@SQL)

--Step 3: INSERT data into final table
INSERT StudentList (StFName,StLName,StEmail,OrderID)
SELECT  CASE WHEN @FileType = 1 THEN SUBSTRING(StFName,2,DATALENGTH(StFName)-1)
             ELSE StFName
        END,
        SUBSTRING(StLName,1,DATALENGTH(StLName)-0),
        CASE WHEN @FileType = 1 THEN SUBSTRING(StEmail,1,DATALENGTH(StEmail)-1)
             ELSE StEmail
        END,
        @OrderID
FROM tmpStList

--Step 4: Empty temporary table
TRUNCATE TABLE TmpStList
go




--==================DATA=============

FileType=1 (TxtFile1.txt)

"Kelly","Reynold","kelly@reynold.com"
"John","Smith","bill@smith.com"
"Sara","Parker","sara@parker.com"

 BULK INSERT TmpStList FROM 'c:\TxtFile1.txt' WITH (FIELDTERMINATOR = '","')

--================
FileType=2 (TxtFile2.txt)

Kelly,Reynold,kelly@reynold.com
John,Smith,bill@smith.com
Sara,Parker,sara@parker.com


BULK INSERT tmpStList FROM 'c:\TxtFile2.txt' WITH (FIELDTERMINATOR = ',')


----TABLES for the two ds:

CREATE TABLE StudentList
(
 StID int IDENTITY NOT NULL,
 StFName varchar(50) NOT NULL,
 StLName varchar(50) NOT NULL,
 StEmail varchar(100) NOT NULL,
 OrderID int NOT NULL
)
go
CREATE TABLE TmpStList
(
 stFName varchar (50) NOT NULL,
 stLName varchar (50) NOT NULL,
 stEmail varchar (100) NOT NULL
)
go</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>call_a_StoredProcedure_on_rows_of_a_TABLE_00_MyVersion_as_TRANSACTION</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>call_a_StoredProcedure_on_rows_of_a_TABLE_00_MyVersion_as_TRANSACTION</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--a) the SP for individual Record
--b) Batch Script to run the first SP

--prj_0006_SP_0008_Create_TagSecurityRecord_v3.sql
/*	This version has the RETURN statements working
	************************************************************************************
	NOTE: with Transaction, 
		  if return 99 then it failed in first part, i.e. Insert into table [SW_TAG_SECURITY] failed
		  if return 98 then it failed in first part, i.e. Insert into table [SW_GF_ACL] failed.	
		  Return 0 if Transaction committed	  
	Uses: 
	Created: 9/8/2016
	By: glenn garson
	************************************************************************************
*/



USE barriere		--_sandbox
GO

----================================================	
--DECLARE @NAME nvarchar(50)
--DECLARE @TagName as nvarchar(50)
--DECLARE @ISGROUP as BIT
--DECLARE @USERGROUP as nvarchar(125)
--DECLARE @PROJECT_ROLE as nvarchar(50)


--SET @NAME = N'DOCUMENT_TYPE'		--generally either DOCUMENT_TYPE or {rarely} DOCTYPE
--SET @TagName = N'Cost_Adjustments'	--Cost_Adjustments	-- then name of the tag
--SET @ISGROUP = 1					-- 1 {if it is a group}
--SET @USERGROUP = N'_ALL'			-- a document security group name
--SET @PROJECT_ROLE = N''				-- empty, but I guess it could be the name of a project role

----================================================

alter Procedure prj_0006_SP_0008_Create_TagSecurityRecord(
								@NAME  as nvarchar(50)
								,@TagName  as nvarchar(500)
								,@ISGROUP  as bit
								,@USERGROUP  as nvarchar(125)
								,@PROJECT_ROLE  as nvarchar(50)									
	)

as

DECLARE @iSW_TAG_SECURITY_PK INT

-- ********************************************************************************
-- Start a transaction, if any code fails then we back out everything
-- ********************************************************************************
		BEGIN TRANSACTION TRANS_Create_TagSecurityRecord


				--===============================================================================================================

				INSERT into [SW_TAG_SECURITY] (
										  [NAME]			--generally either DOCUMENT_TYPE or {rarely} DOCTYPE
										  ,[VALUE]			-- then name of the tag
										  ,[ISGROUP]		-- 1 {if it is a group}
										  ,[USERGROUP]		-- a document security group name
										  ,[PROJECT_ROLE]	-- empty, but I guess it could be the name of a project role
										)
				values(
												@NAME
												,@TagName
												,@ISGROUP
												,@USERGROUP
												,@PROJECT_ROLE	
						)
				
				
				IF @@ERROR &lt;&gt; 0
					BEGIN
					--
					-- Rollback the transaction and return to the caller
					--
					ROLLBACK TRANSACTION TRANS_Create_TagSecurityRecord
					RAISERROR('Insert into table [SW_TAG_SECURITY] failed.',18,1)
					RETURN 99											
					END
						
				--===============================================================================================================	
	
					SELECT @iSW_TAG_SECURITY_PK = @@IDENTITY
					PRINT 'The PK for the new Record is: ' + CAST(@iSW_TAG_SECURITY_PK as varchar(5))
					--RETURN @iSW_TAG_SECURITY_PK   --&lt;== This can not work b/c the PK could be 98 or 99 and that would conflict with my notes
				--===============================================================================================================			

				DECLARE @ACLTYPE int
				DECLARE @ITEMID int
				DECLARE @HIDDEN bit
				DECLARE @LIST bit
				DECLARE @READACC bit
				DECLARE @DELETEACC bit
				DECLARE @PERMISSIONS bit
				DECLARE @AUTHOR bit
				DECLARE @EDITOR bit
				DECLARE @MOVE bit

				SET @ACLTYPE=2
				SET @ITEMID=@iSW_TAG_SECURITY_PK
				SET @ISGROUP=1
				SET @HIDDEN=0
				SET @LIST=1
				SET @READACC=1
				SET @DELETEACC=1
				SET @PERMISSIONS=0
				SET @AUTHOR=1		--CREATE
				SET @EDITOR=1		--REVISE
				SET @MOVE=1
							
				INSERT INTO SW_GF_ACL 
				(
					ACLTYPE,
					ITEMID,
					ISGROUP,
					USERGROUP,
					HIDDEN,
					READACC,
					DELETEACC,
					PERMISSIONS,
					AUTHOR,
					EDITOR,
					CANSUBSCRIBE,
					FORCESUBSCRIBE,
					LIST,
					VIEWPERMS,
					HIDECHILD,
					SPARE1,
					SPARE2,
					SPARE3,
					SPARE4,
					APPID,
					EDITMENU,
					[MOVE]
				)
				VALUES
				(
					@ACLTYPE,
					@ITEMID,
					@ISGROUP,
					@USERGROUP,
					@HIDDEN,
					@READACC,
					@DELETEACC,
					@PERMISSIONS,
					@AUTHOR,
					@EDITOR,
					0,
					0,
					@LIST,
					0,
					0,
					0,
					0,
					0,
					0,
					'''',
					0,
					@MOVE
				)			
							
				IF @@ERROR &lt;&gt; 0
					BEGIN
					--
					-- Rollback the transaction and return to the caller
					--
					ROLLBACK TRANSACTION TRANS_Create_TagSecurityRecord
					RAISERROR('Insert into table [SW_GF_ACL] failed.',18,1)
					RETURN 98											
					END							
				--===============================================================================================================	


		
	-- ********************************************************************************
	-- We made it to the end so commit the transaction
	-- ********************************************************************************
	COMMIT TRANSACTION TRANS_Create_TagSecurityRecord
	
	-- Return to the caller with a successful return code
	--
	RETURN 0		
	
	
	\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	--prj_0006_315_BATCH_Create_Tag_Security_Records_v1.sql

use barriere
go


DECLARE @tmp table (
					 PK INT IDENTITY(1,1) PRIMARY KEY NOT NULL
					, [NAME] nvarchar(50)
					, [TagName]  nvarchar(50)
					, [ISGROUP]  BIT
					, [USERGROUP]  nvarchar(125)
					, [PROJECT_ROLE]  nvarchar(50)					 									 					 					 					 					 					 
					)
					
DECLARE @PK INT = 0					
					
DECLARE @NAME nvarchar(50) 
DECLARE @TagName nvarchar(50)
DECLARE @ISGROUP bit
DECLARE @USERGROUP nvarchar(125)
DECLARE @PROJECT_ROLE nvarchar(50)



;with CTE_WorkFlowParms as
(select 
		cast(N'DOCUMENT_TYPE' as [nvarchar](50)) as [NAME]
		, cast(N'MSA_COI' as [nvarchar](50)) as [TagName]
		, cast(1 as [bit]) as [ISGROUP]
		, cast(N'_ALL' as [nvarchar](125)) as [USERGROUP]
		, cast(N'' as [nvarchar](50)) as [PROJECT_ROLE]

union select N'DOCUMENT_TYPE',N'Certified Payroll Re',1,N'_ALL',N''
--union select N'DOCUMENT_TYPE',N'MSA_COI',1,N'_ALL',N''			--This is a duplicate
union select N'DOCUMENT_TYPE',N'Certified Payroll Re',1,N'_ALL',N''
union select N'DOCUMENT_TYPE',N'Certified Payroll Reports',1,N'_ALL',N''
union select N'DOCUMENT_TYPE',N'Change Orders',1,N'_ALL',N''
union select N'DOCUMENT_TYPE',N'Contract Documents',1,N'_ALL',N''
union select N'DOCUMENT_TYPE',N'Correspondence',1,N'_ALL',N''
union select N'DOCUMENT_TYPE',N'Cost_Adjustments',1,N'_ALL',N''
union select N'DOCUMENT_TYPE',N'Credit_Apps',1,N'_ALL',N''
union select N'DOCUMENT_TYPE',N'Equipment Sale Documents',1,N'_ALL',N''

)

--select TOP(2)
--		[NAME]
--		,[TagName]
--		,[ISGROUP]
--		,[USERGROUP]
--		,[PROJECT_ROLE]
--from CTE_WorkFlowParms;


INSERT INTO @tmp SELECT --TOP(3)
					  [NAME]
					, [TagName] 
					, [ISGROUP]  
					, [USERGROUP] 
					, [PROJECT_ROLE] 	
FROM CTE_WorkFlowParms

--SELECT * FROM @tmp

WHILE (1=1)
BEGIN
    SELECT 
			@PK = PK    
			,@NAME = NAME
			,@TagName = TagName
			,@ISGROUP = ISGROUP
			,@USERGROUP = USERGROUP
			,@PROJECT_ROLE = PROJECT_ROLE															
			
    FROM @tmp
    WHERE PK = @PK + 1
	--PRINT '============================================================PK = @PK + 1,   PK is: '  + CAST(@PK AS varchar(5))
	--PRINT '@APM_TYPE: ' + @APM_TYPE
	--PRINT '@APM_SUBTYPE: ' + @APM_SUBTYPE
	--PRINT '@RULE_DESC: ' + @RULE_DESC
	
	
		
    IF @@rowcount = 0 BREAK;
	PRINT '============================================================PK = @PK + 1,   PK is: '  + CAST(@PK AS varchar(5))
	PRINT '@NAME: ' + @NAME
	PRINT '@TagName: ' + @TagName
	PRINT '@USERGROUP: ' + @USERGROUP    
	PRINT '@@rowcount was not 0'
    -- call your sproc
    DECLARE @return_status int
    exec @return_status =  prj_0006_SP_0008_Create_TagSecurityRecord @NAME, @TagName, @ISGROUP, @USERGROUP, @PROJECT_ROLE
    IF @return_status = 99
		BEGIN
			PRINT 'SP Failed in the first part. Transaction did not commit'		
		END
     IF @return_status = 98
		BEGIN
			PRINT 'SP Failed in the second part. Transaction did not commit - DING, DING, DING'		
		END   
      IF @return_status = 0
		BEGIN
			PRINT 'SP succeeded. Transaction committed.'		
		END    
END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>call_a_StoredProcedure_on_rows_of_a_TABLE_00_MyVersion</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>call_a_StoredProcedure_on_rows_of_a_TABLE_00_MyVersion</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>call_a_StoredProcedure_on_rows_of_a_TABLE_00_MyVersion


//////////////--This was my version:


--prj_0006_RES_910_LIST_of_Triggers.sql

DECLARE @tmp table (Id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, Trigger_Name nvarchar(Max))
DECLARE @Trigger_Name nvarchar(max) 
DECLARE @Id INT = 0

;WITH CTE_Triggers(Trigger_Name)
AS
(
	SELECT 
		 sysobjects.name AS Trigger_Name 
	FROM sysobjects 
	WHERE sysobjects.type = 'TR'
)

INSERT INTO @tmp SELECT Trigger_Name FROM CTE_Triggers

Select * from @tmp


WHILE (1=1)
BEGIN
    SELECT @Trigger_Name = Trigger_Name, @Id = Id
    FROM @tmp
    WHERE Id = @Id + 1

    IF @@rowcount = 0 BREAK;

    -- call your sproc
    exec sp_helptext @Trigger_Name;				--&lt;=== Call the stored proc
END

///////////////////////////////////////////////////////////

--prj_0006_305_Create_Individual_INVREG_WorkFlows.sql

use barriere
go


DECLARE @tmp table (
					 PK INT IDENTITY(1,1) PRIMARY KEY NOT NULL
					 , [APM_TYPE] nvarchar(8)
					 , [APM_SUBTYPE] nvarchar(8)
					 , [RULE_DESC] nvarchar(30)
					 , [SELECTED] nvarchar(1)
					 , [FORM] nvarchar(4)
					 , [WORKFLOW_IND] nvarchar(1)					 					 					 					 					 					 
					)
					
DECLARE @PK INT = 0					
					
DECLARE @APM_TYPE nvarchar(8) 
DECLARE @APM_SUBTYPE nvarchar(8)
DECLARE @RULE_DESC nvarchar(30)
DECLARE @SELECTED nvarchar(1)
DECLARE @FORM nvarchar(4)
DECLARE @WORKFLOW_IND nvarchar(1)


;with CTE_WorkFlowParms as
(select 
		cast('INVREG' as [nvarchar](8)) as [APM_TYPE]
		, cast('JUNK' as [nvarchar](8)) as [APM_SUBTYPE]
		, cast('junk for testing' as [nvarchar](30)) as [RULE_DESC]
		, cast(N' ' as [nvarchar](1)) as [SELECTED]
		, cast(N' ' as [nvarchar](4)) as [FORM]
		, cast(N' ' as [nvarchar](1)) as [WORKFLOW_IND]
		
union select 'INVREG',N'invALO',N'inv to: Aaron Lofton',N' ',N' ',N' '
union select 'INVREG',N'invABG',N'inv to: Abbie Graffeo',N' ',N' ',N' '
union select 'INVREG',N'invAGO',N'inv to: Adriane Gonzalez',N' ',N' ',N' '
union select 'INVREG',N'invAR',N'inv to: Amber Reese',N' ',N' ',N' '
union select 'INVREG',N'invAW',N'inv to: Andrew Wilson',N' ',N' ',N' '
union select 'INVREG',N'invBT',N'inv to: Ben Tucker',N' ',N' ',N' '
union select 'INVREG',N'invBW',N'inv to: Bert Wilson',N' ',N' ',N' '

)
--select TOP(2)
--		[APM_TYPE]
--		,[APM_SUBTYPE]
--		,[RULE_DESC]
--		,[SELECTED]
--		,[FORM]
--		,[WORKFLOW_IND]
--from CTE_WorkFlowParms;


INSERT INTO @tmp SELECT --TOP(2)					--&lt;===  by doing this it adds the auto-number ID field
						[APM_TYPE] 
						,[APM_SUBTYPE]
						,[RULE_DESC]
						,[SELECTED]
						,[FORM]
						,[WORKFLOW_IND]
FROM CTE_WorkFlowParms


--SELECT * FROM @tmp


WHILE (1=1)
BEGIN
    SELECT 
			@PK = PK    
			,@APM_TYPE = APM_TYPE
			,@APM_SUBTYPE = APM_SUBTYPE
			,@RULE_DESC = RULE_DESC
			,@SELECTED = SELECTED
			,@FORM = FORM
			,@WORKFLOW_IND = WORKFLOW_IND										
			
			
			
    FROM @tmp
    WHERE PK = @PK + 1
	--PRINT '============================================================PK = @PK + 1,   PK is: '  + CAST(@PK AS varchar(5))
	--PRINT '@APM_TYPE: ' + @APM_TYPE
	--PRINT '@APM_SUBTYPE: ' + @APM_SUBTYPE
	--PRINT '@RULE_DESC: ' + @RULE_DESC
	
	
		
    IF @@rowcount = 0 BREAK;
	PRINT '============================================================PK = @PK + 1,   PK is: '  + CAST(@PK AS varchar(5))
	PRINT '@APM_TYPE: ' + @APM_TYPE
	PRINT '@APM_SUBTYPE: ' + @APM_SUBTYPE
	PRINT '@RULE_DESC: ' + @RULE_DESC    
	PRINT '@@rowcount was not 0'
    -- call your sproc
    exec prj_0006_SP_0001_CreateWorkFlow @APM_TYPE, @APM_SUBTYPE, @RULE_DESC, @SELECTED, @FORM, @WORKFLOW_IND
	PRINT 'SP ran'    
END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>call_a_StoredProcedure_on_rows_of_a_TABLE_01</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>call_a_StoredProcedure_on_rows_of_a_TABLE_01</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--call_a_StoredProcedure_on_rows_of_a_TABLE_01


http://stackoverflow.com/questions/1656804/sql-call-stored-procedure-for-each-row-without-using-a-cursor

//////////////--This was my version:


--prj_0006_RES_910_LIST_of_Triggers.sql

DECLARE @tmp table (Id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, Trigger_Name nvarchar(Max))
DECLARE @Trigger_Name nvarchar(max) 
DECLARE @Id INT = 0

;WITH CTE_Triggers(Trigger_Name)
AS
(
	SELECT 
		 sysobjects.name AS Trigger_Name 
	FROM sysobjects 
	WHERE sysobjects.type = 'TR'
)

INSERT INTO @tmp SELECT Trigger_Name FROM CTE_Triggers

Select * from @tmp


WHILE (1=1)
BEGIN
    SELECT @Trigger_Name = Trigger_Name, @Id = Id
    FROM @tmp
    WHERE Id = @Id + 1

    IF @@rowcount = 0 BREAK;

    -- call your sproc
    exec sp_helptext @Trigger_Name;				--&lt;=== Call the stored proc
END





////////////--variation that doesn't require ORDER BY, COUNT or MIN/MAX

--The only disadvantage with this approach is that you have to create a temp table to hold all the Ids 
--(the assumption is that you have gaps in your list of CustomerIDs).

DECLARE @tmp table (Id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, CustomerID INT NOT NULL)
DECLARE @CustomerId INT 
DECLARE @Id INT = 0

INSERT INTO @tmp SELECT CustomerId FROM Sales.Customer

WHILE (1=1)
BEGIN
    SELECT @CustomerId = CustomerId, @Id = Id
    FROM @tmp
    WHERE Id = @Id + 1

    IF @@rowcount = 0 BREAK;

    -- call your sproc
    EXEC dbo.YOURSPROC @CustomerId;
END


////////////////--Variation using ORDER BY


-- Declare &amp; init (2008 syntax)
DECLARE @CustomerID INT = 0

-- Iterate over all customers
WHILE (1 = 1) 
BEGIN  

  -- Get next customerId
  SELECT TOP 1 @CustomerID = CustomerID
  FROM Sales.Customer
  WHERE CustomerID &gt; @CustomerId 
  ORDER BY CustomerID

  -- Exit loop if no more customers
  IF @@ROWCOUNT = 0 BREAK;

  -- call your sproc
  EXEC dbo.YOURSPROC @CustomerId

END

/*
depending on your table and index structure it can be very poorly performing ( O(n^2) ) 
since you have to order and search your table every time you enumerate. 

	
This doesn't seem to work (break never exits loop for me - the work is done but the query spins in the loop). 
	Initializing the id and checking for null in the while condition exits the loop.
I concur for SQL Server 2008. 
	The value of @@ROWCOUNT seems to always equal 0 on each iteration. 
	With that value, one would think it would break each time, but it does not
@@ROWCOUNT can only be read once. Even IF/PRINT statements will set it to 0. 
	The test for @@ROWCOUNT must be done 'immediately' after the select. I would recheck your code/environment.
*/	
	
////////////--Variation using MIN() rather than ORDER BY

/*	
This is a variation of n3rds solution above. No sorting by using ORDER BY is needed, as MIN() is used.

Remember that CustomerID (or whatever other numerical column you use for progress) must have a unique constraint. 
Furthermore, to make it as fast as possible CustomerID must be indexed on.
*/
-- Declare &amp; init
DECLARE @CustomerID INT = (SELECT MIN(CustomerID) FROM Sales.Customer); -- First ID
DECLARE @Data1 VARCHAR(200);
DECLARE @Data2 VARCHAR(200);

-- Iterate over all customers
WHILE @CustomerID IS NOT NULL
BEGIN  

  -- Get data based on ID
  SELECT @Data1 = Data1, @Data2 = Data2
    FROM Sales.Customer
    WHERE [ID] = @CustomerID ;

  -- call your sproc
  EXEC dbo.YOURSPROC @Data1, @Data2

  -- Get next customerId
  SELECT @CustomerID = MIN(CustomerID)
    FROM Sales.Customer
    WHERE CustomerID &gt; @CustomerId 

END
I use this approach on some varchars I need to look over, by putting them in a temporary table first, to give them an ID.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>call_a_StoredProcedure_on_rows_of_a_TABLE_03</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>call_a_StoredProcedure_on_rows_of_a_TABLE_03</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--call_a_StoredProcedure_on_rows_of_a_TABLE_03

http://stackoverflow.com/questions/1656804/sql-call-stored-procedure-for-each-row-without-using-a-cursor
/*
This is better because it doesn't assume the value you're after is an integer or can be compared sensibly

another possibility is to use a table variable to hold a numbered set of values 
	(in this case just the ID field of a table)
	and loop through those by Row Number 
	with a JOIN to the table to retrieve whatever you need for the action within the loop.
*/

DECLARE @RowCnt int; SET @RowCnt = 0 -- Loop Counter

-- Use a table variable to hold numbered rows containg MyTable's ID values
DECLARE @tblLoop TABLE (RowNum int IDENTITY (1, 1) Primary key NOT NULL,
     ID INT )
INSERT INTO @tblLoop (ID)  SELECT ID FROM MyTable

  -- Vars to use within the loop
  DECLARE @Code NVarChar(10); DECLARE @Name NVarChar(100);

WHILE @RowCnt &lt; (SELECT COUNT(RowNum) FROM @tblLoop)
BEGIN
    SET @RowCnt = @RowCnt + 1
    -- Do what you want here with the data stored in tblLoop for the given RowNum
    SELECT @Code=Code, @Name=LongName
      FROM MyTable INNER JOIN @tblLoop tL on MyTable.ID=tL.ID
      WHERE tl.RowNum=@RowCnt
    PRINT Convert(NVarChar(10),@RowCnt) +' '+ @Code +' '+ @Name
END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Compare_LIST_of_SP_in_Two_Databases</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Compare_LIST_of_SP_in_Two_Databases</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0006_RES_914_Compare_LIST_of_SP_in_Pre_and_Post_conversion_database.sql


use BCC_2016_11_30
GO

DECLARE @tablevar_BCC_2016_11_30 TABLE(								-- FROM: https://msdn.microsoft.com/en-us/library/ms190504.aspx
						PROCEDURE_QUALIFIER sysname		--Procedure qualifier name. This column can be NULL.
						, PROCEDURE_OWNER sysname		--Procedure owner name. This column always returns a value.
						, PROCEDURE_NAME nvarchar(134)	--Procedure name. This column always returns a value.
						, NUM_INPUT_PARAMS int			--Reserved for future use.
						, NUM_OUTPUT_PARAMS int			--Reserved for future use.
						, NUM_RESULT_SETS int			--Reserved for future use.
						, REMARKS	varchar(254) 		--Description of the procedure. SQL Server does not return a value for this column.
						, PROCEDURE_TYPE smallint		--Procedure type. SQL Server always returns 2.0. This value can be one of the following:
														--0 = SQL_PT_UNKNOWN
														--1 = SQL_PT_PROCEDURE
														--2 = SQL_PT_FUNCTION
						)
Insert into @tablevar_BCC_2016_11_30 (
						PROCEDURE_QUALIFIER
						, PROCEDURE_OWNER
						, PROCEDURE_NAME
						, NUM_INPUT_PARAMS
						, NUM_OUTPUT_PARAMS
						, NUM_RESULT_SETS
						, REMARKS
						, PROCEDURE_TYPE	
						)	EXEC sp_stored_procedures;		--&lt;=== This is the system procedure that does the heavy lifting:
--select PROCEDURE_NAME 
--from @tablevar
--WHERE PROCEDURE_OWNER = 'dbo'

----------------=======================

use barriere


DECLARE @tablevar_barriere TABLE(								-- FROM: https://msdn.microsoft.com/en-us/library/ms190504.aspx
						PROCEDURE_QUALIFIER sysname		--Procedure qualifier name. This column can be NULL.
						, PROCEDURE_OWNER sysname		--Procedure owner name. This column always returns a value.
						, PROCEDURE_NAME nvarchar(134)	--Procedure name. This column always returns a value.
						, NUM_INPUT_PARAMS int			--Reserved for future use.
						, NUM_OUTPUT_PARAMS int			--Reserved for future use.
						, NUM_RESULT_SETS int			--Reserved for future use.
						, REMARKS	varchar(254) 		--Description of the procedure. SQL Server does not return a value for this column.
						, PROCEDURE_TYPE smallint		--Procedure type. SQL Server always returns 2.0. This value can be one of the following:
														--0 = SQL_PT_UNKNOWN
														--1 = SQL_PT_PROCEDURE
														--2 = SQL_PT_FUNCTION
						)
Insert into @tablevar_barriere (
						PROCEDURE_QUALIFIER
						, PROCEDURE_OWNER
						, PROCEDURE_NAME
						, NUM_INPUT_PARAMS
						, NUM_OUTPUT_PARAMS
						, NUM_RESULT_SETS
						, REMARKS
						, PROCEDURE_TYPE	
						)	EXEC sp_stored_procedures;		--&lt;=== This is the system procedure that does the heavy lifting:
--select PROCEDURE_NAME 
--from @tablevar
--WHERE PROCEDURE_OWNER = 'dbo'

--===================================================
;With CTE_BCC_2016_11_30
AS
(
	select PROCEDURE_NAME AS preName
	from @tablevar_BCC_2016_11_30
	WHERE PROCEDURE_OWNER = 'dbo'
),

--SELECT * FROM CTE_BCC_2016_11_30

CTE_barriere
AS
(
select PROCEDURE_NAME as postName
from @tablevar_barriere
WHERE PROCEDURE_OWNER = 'dbo'
)

--SELECT * FROM CTE_barriere

SELECT * 
FROM (
		CTE_BCC_2016_11_30 pre
		LEFT OUTER JOIN
		CTE_barriere post
		ON pre.preName = post.postName
	 )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>DELETE_CREATE_Table_Procedure</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>DELETE_CREATE_Table_Procedure</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Alter Procedure f1_b_DeleteCreateLogInHistoryTable_sp
/*
	(
		@parameter1 datatype = default value,
		@parameter2 datatype OUTPUT
	)
*/
As
	-- Use Maher

	-- 1]: Delete the table (that will store the info from the Activity_Log table) if it already exists
	-- -----------------------------------------------
	IF OBJECT_ID('dbo.LogInHistory_t') IS NOT NULL
    		DROP TABLE dbo.LogInHistory_t

 /*	IF OBJECT_ID('dbo.LogInHistory_sp_tmp') IS NOT NULL
    		DROP Procedure dbo.LogInHistory_sp_tmp
 */

	-- 2]: Recreate the table that will store the info from the Activity_Log table
	-- -----------------------------------------------

	create table LogInHistory_t
	(
	LogInHistory_PK_Id INT IDENTITY(1,1) CONSTRAINT PrimaryKeyConstraint PRIMARY KEY,
	Activity_Log_FK_ID numeric(18,0),
	Who_Logged_In nvarchar(75),
	The_Date char(10),
	The_Time char(10),
	User_IP nvarchar(20)
	)


	Insert LogInHistory_t Execute f1_a_LogInHistory_sp_tmp
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>EXEC_another_SP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>EXEC_another_SP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--The primary purpose of the stored procedure is to build intermediate results that are to be
-- loaded into a temporary table, which is then queried in a SELECT statement. INSERT...EXEC 
--statements can be written using table-valued functions. For example, consider the following sequence: 


INSERT #temp EXEC sp_getresults
SELECT ...
    FROM #temp, t1
    WHERE ...

--The sp_getresults stored procedure can be rewritten as a table-valued function, 
--for example fn_results(), which means the preceding statements can be rewritten as:

SELECT ...
    FROM fn_results(), t1
    WHERE ...
 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>IF_ELSE_END</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>IF_ELSE_END</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>DECLARE @CONTINUE BIT	
DECLARE @MessageFromSQL AS VARCHAR(255)
SELECT @CONTINUE = 1	
			
IF @Hold_UserName IS NULL OR @Hold_UserName = ''
	BEGIN
	SELECT @MessageFromSQL = 'Problem: @Hold_UserName not found, '
	PRINT '@Hold_UserName not found ' + @VoucherComments_PK
	SELECT @CONTINUE = 0				
	END
ELSE
	BEGIN
	PRINT '@Hold_UserName: ' 
	-- Test Comment_Done 		
									
		-- *************			
END

-------------------------------------------------------------------------------------------------------------------------------------------------------		
                                                               IF (@VoucherComments_PK IS NULL OR @VoucherComments_PK ='')
					BEGIN
					PRINT '(@VoucherComments_PK IS NULL OR @VoucherComments_PK ="") ' 
					--  **************************************************************************
					--  Insert the following: PublicVouchers_FK, PV_Bills_FK, HOLD_UserName, HOLD_Started_DateTime, 
					--  Return the following: VoucherComment_PK
					--  **************************************************************************		
								
						INSERT INTO PV_VoucherComments_sst
							(Public_Vouchers_FK, PV_Bills_FK, HOLD_UserName, HOLD_Started_DateTime)
						VALUES
							(@Public_Vouchers_PK, @PV_Bills_PK, @UserName, GETDATE() )
					--  **************************************************************************
					--  2-1] Then get the Comment's PK: @VoucherComments_PK
					--  **************************************************************************		
						SELECT @VoucherComments_PK = @@IDENTITY
						
						PRINT '@VoucherComments_PK: ' + @VoucherComments_PK	
						
						SELECT @MessageFromSQL = @MessageFromSQL + 'A new bill was created, and there were no problems'
						
					END
				ELSE
					BEGIN
					SELECT @MessageFromSQL = @MessageFromSQL + ',  A record on HOLD was used. '						
					END
		                               END
-----------------------------------------------------



	IF @@ERROR &lt;&gt; 0
		BEGIN
			RETURN 99
			PRINT 'Darn It! there was a problem Deleting/Creating table: [zzz_prj_0011_TEMP_001]'
		END
	ELSE
		BEGIN
			RETURN 0
			PRINT 'YEAH!, There were NO errors Deleting/Creating table: [zzz_prj_0011_TEMP_001]'
			
		END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>LIST_of_StoredProc_in_Database</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>LIST_of_StoredProc_in_Database</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://stackoverflow.com/questions/219434/query-to-list-all-stored-procedures

select * 
  from RiskMngt.information_schema.routines 
 where routine_type = 'PROCEDURE'
 
 /*
 If for some reason you had non-system stored procedures in the master database, 
 you could use the query (this will filter out MOST system stored procedures):
 */

select * 
  from master.information_schema.routines 
 where routine_type = 'PROCEDURE' 
   and Left(Routine_Name, 3) NOT IN ('sp_', 'xp_', 'ms_')
 
  --=============================================================================
   
SELECT name, type
FROM dbo.sysobjects
WHERE type IN (
    'P', -- stored procedures
    'FN', -- scalar functions 
    'IF', -- inline table-valued functions
    'TF' -- table-valued functions
)
ORDER BY type, name   

  --=============================================================================

--If you want to find the list of all SPs in all Databases you can use the below query :

    CREATE TABLE #ListOfSPs 
    (
        DBName varchar(100), 
        [OBJECT_ID] INT,
        SPName varchar(100)
    )

    EXEC sp_msforeachdb 'USE [?]; INSERT INTO #ListOfSPs Select ''?'', Object_Id, Name FROM sys.procedures'

    SELECT 
        * 
    FROM #ListOfSPs</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>LIST_of_StoredProcedures</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>LIST_of_StoredProcedures</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- list of Stored procedure and their creation dates
SELECT name, create_date, modify_date 
FROM sys.objects
WHERE type = 'P' 
order by create_date desc
//////////////////////////////////////////////////
--prj_0006_RES_904_ListOfStoredProcedures_for_a_database.sql
-- NOTE: this also lists the functions, in addition to the Stored Procedures
use barriere
GO

DECLARE @tablevar TABLE(								-- FROM: https://msdn.microsoft.com/en-us/library/ms190504.aspx
						PROCEDURE_QUALIFIER sysname		--Procedure qualifier name. This column can be NULL.
						, PROCEDURE_OWNER sysname		--Procedure owner name. This column always returns a value.
						, PROCEDURE_NAME nvarchar(134)	--Procedure name. This column always returns a value.
						, NUM_INPUT_PARAMS int			--Reserved for future use.
						, NUM_OUTPUT_PARAMS int			--Reserved for future use.
						, NUM_RESULT_SETS int			--Reserved for future use.
						, REMARKS	varchar(254) 		--Description of the procedure. SQL Server does not return a value for this column.
						, PROCEDURE_TYPE smallint		--Procedure type. SQL Server always returns 2.0. This value can be one of the following:
														--0 = SQL_PT_UNKNOWN
														--1 = SQL_PT_PROCEDURE
														--2 = SQL_PT_FUNCTION
						)
Insert into @tablevar (
						PROCEDURE_QUALIFIER
						, PROCEDURE_OWNER
						, PROCEDURE_NAME
						, NUM_INPUT_PARAMS
						, NUM_OUTPUT_PARAMS
						, NUM_RESULT_SETS
						, REMARKS
						, PROCEDURE_TYPE	
						)	EXEC sp_stored_procedures;		--&lt;=== This is the system procedure that does the heavy lifting:
select PROCEDURE_NAME 
from @tablevar
WHERE PROCEDURE_OWNER = 'dbo'

////////////////////////////////////////

Select Routine_name
From Information_schema.Routines
Where Routine_type = 'PROCEDURE' and Objectproperty 
(Object_id(Routine_name), 'IsMsShipped') = 0
Order by Routine_name

////////////////////////////////////////

--A. Returning all stored procedures in the current database
--The following example returns all stored procedures in the AdventureWorks2012 database.
USE AdventureWorks2012;  
GO  
EXEC sp_stored_procedures;  

--B. Returning a single stored procedure
--The following example returns a result set for the uspLogError stored procedure.
USE AdventureWorks2012;  
GO  
sp_stored_procedures N'uspLogError', N'dbo', N'AdventureWorks2012', 1;  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>POPULATE_a_TVP_or_TempTable_from_SP_Then_SELECT_from_That</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>POPULATE_a_TVP_or_TempTable_from_SP_Then_SELECT_from_That</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
--POPULATE_a_TVP_or_TempTable_from_SP_Then_SELECT_from_That
--EXEC_into_a_TableVariable_or_TempTable_Then_SELECT_from_That

--http://stackoverflow.com/questions/209383/select-columns-from-result-set-of-stored-procedure
--A stored procedure may only return text (print 'text'), or may return multiple tables, or may return no tables at all.
--So something like SELECT * FROM (exec sp_tables) Table1 will not work

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
--prj_01_SP_205i_EXPLORER_Vendor_MSA_Searchable_v2.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 12/30/2015
	Modified: 1/18/2015 - get rid of the files form MSA_COI folder
	By: glenn garson
	************************************************************************************
*/



USE [COI]
GO


alter Procedure prj_01_SP_205i_EXPLORER_Vendor_MSA_Searchable(
		@WindowInDays_IN as INT,		 
		@SearchString_IN as NVARCHAR(100)
	)

	as

	IF OBJECT_ID('tempdb..#mytemp') IS NOT NULL

		DROP TABLE #mytemp
	    
	
	
	CREATE TABLE #mytemp (
							IDNumber nvarchar(150)					
						  ,[DOCUMENT] nvarchar(150)			
						  ,[ATTACH_DATE] nvarchar(110)			
						  ,[USER_ID] nvarchar(110)
						  ,Window_BEGINS nvarchar(110)
							)
	
	INSERT #mytemp 
	EXEC prj_01_SP_205_EXPLORER_documents_Searchable 
														@WindowInDays = @WindowInDays_IN,
														@DOCUMENT_GROUP = 'Vendor',
														@DOCUMENT_TYPE = 'MSA',
														@SearchString = @SearchString_IN
  SELECT * 
  from #mytemp
  --where IDNumber like '%1  95090%'
  WHERE DOCUMENT  not like '%MSA_COI%'

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Declare @tablevar table(col1,..
insert into @tablevar(col1,..) exec MyStoredProc 'param1', 'param2'

SELECT col1, col2 FROM @tablevar


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


CREATE TABLE #Result
(
  ID int,  Name varchar(500), Revenue money
)
INSERT #Result EXEC RevenueByAdvertiser '1/1/10', '2/1/10'
SELECT * FROM #Result ORDER BY Name
DROP TABLE #Result


///////////////////////////////////////////////////////////////////////////
create table #test_table(
    col1 int,
    col2 int,
   .
   .
   .
    col80 int
)
Now execute procedure and put value in #test_table:

insert into #test_table
EXEC MyStoredProc 'param1', 'param2'
Now you fetch the value from #test_table:

select col1,col2....,col80 from #test_table</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>POPULATE_Table_from_StoredProcedure</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>POPULATE_Table_from_StoredProcedure</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- First create the table to which we want to push the SP result
CREATE TABLE #TempEmployees(EmpId int,EmpName Varchar(50))
GO
-- Insert result from the SP to temp table  --&lt;==============================================
INSERT INTO #TempEmployees
EXEC dbo.GetEmployees
GO
--Verify the Insert records
SELECT * FROM #TempEmployees
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SCRIPT_the_SP_that_meet_some_criteria_from_a_Database_FROM_DEWEY</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SCRIPT_the_SP_that_meet_some_criteria_from_a_Database_FROM_DEWEY</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--SCRIPT_the_SP_that_meet_some_criteria_from_a_Database_FROM_DEWEY

--This worked for Dewey: from new server to new server
-- It did NOT work for me when I went from the old server to the new server


USE barriere;

SET NOCOUNT ON;

DECLARE @StoredProcedure TABLE
    (
      procedure_name VARCHAR(8000) ,
      procedure_definition NVARCHAR(MAX) 
    );

INSERT  INTO @StoredProcedure
        ( procedure_name ,
          procedure_definition 
        )
        --SELECT  so.name ,
					   --a.definition
        --FROM    sys.objects AS so
        --        INNER JOIN sys.all_sql_modules a ON a.object_id = so.object_id
        --WHERE   so.type = 'P';

		SELECT SPECIFIC_NAME, ROUTINE_DEFINITION
		FROM barriere.INFORMATION_SCHEMA.ROUTINES
		WHERE 
				(
					(ROUTINE_TYPE = 'PROCEDURE')
					AND 
					(LEFT(ROUTINE_NAME,3) NOT IN ('dt_','sp_','xp_','ms_'))
					AND 
					(YEAR(LAST_ALTERED) IN (2015,2016))
					AND 
					(upper(SPECIFIC_NAME) LIKE '%PRJ_%')
				)
		ORDER  BY 1;

DECLARE @procName AS VARCHAR(8000);
DECLARE @procDefinition AS NVARCHAR(MAX);

DECLARE T1 CURSOR
FOR
    SELECT  *
    FROM    @StoredProcedure;
OPEN T1;

FETCH NEXT FROM T1 INTO @procName, @procDefinition
WHILE @@FETCH_STATUS = 0
    BEGIN
        PRINT 'IF OBJECT_ID(' + '''' + @procName + '''' + ') IS NOT NULL DROP PROCEDURE ' + @procName;
        PRINT 'GO';
        PRINT '';
        PRINT @procDefinition;
        PRINT 'GO';
        PRINT '';
        PRINT '';
        FETCH NEXT FROM T1 INTO @procName, @procDefinition
    END;

CLOSE T1;
DEALLOCATE T1;
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SCRIPT_the_SP_that_meet_some_criteria_from_a_Database</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SCRIPT_the_SP_that_meet_some_criteria_from_a_Database</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0006_RES_912_LIST_of_StoredProcedures_v0.sql
/*
	************************************************************************************
	NOTE: This will output a file for each SP on the database, and an SQLCMD file to run them 
			into a designated directory ON the Database Server
		  This script requires that the function 'prj_0000_SP_201_WriteLineToFile' exists in the database
		  See the documentation for that function for requirements on the server. i.e. enabling 'Ole Automation Procedures' 
		  NOTE: spaces in file names cause PROBLEMS
	Uses: 
	Created: 11/16/2016
	By: glenn garson
	************************************************************************************
*/
use barriere
go

DECLARE @tmp table (Id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, Stored_Procedure_Name nvarchar(Max))	--, Table_Name nvarchar(max))
DECLARE @Stored_Procedure_Name nvarchar(max) 
--DECLARE @Table_Name nvarchar(max)
DECLARE @Id INT = 0

----from SQLCMD
DECLARE @destinationpath NVARCHAR(1000)
SET @destinationpath = N'C:\JUNK' 
DECLARE @SQLCMD_Path_FileName NVARCHAR(1000) 	 
DECLARE @SQLCMD_First_Line NVARCHAR(1000) 	

SET @SQLCMD_Path_FileName =  @destinationpath + '\_SQLCMD.sql'
SET @SQLCMD_First_Line =  '--_SQLCMD.sql'
--xxx] Create a File to store the lines of code for the Stored_Procedure
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=@SQLCMD_First_Line   , @FileAction = 'CREATENEW'	
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=' '   , @FileAction = 'APPEND'	   
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=':setvar path "c:\xxx\"'   , @FileAction = 'APPEND'	 
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=' '   , @FileAction = 'APPEND'


;WITH CTE_Stored_Procedures(Stored_Procedure_Name)	--, Table_Name)
AS
(
	SELECT --TOP(3)			--&lt;============================================
		 sysobjects.name AS Stored_Procedure_Name		--,
		 --Object_name(parent_obj) as "Table_Name" 
	FROM sysobjects 
	WHERE (
			(sysobjects.type = 'P')
									-- P = Stored Procedure
									-- V = View
									-- TF = Table Function
									-- TR = Trigger					
			AND
			(upper(sysobjects.name) like '%PRJ_%')
		   )

)

--0] Add a Primary Key to each record

INSERT INTO @tmp 
SELECT Stored_Procedure_Name	--, Table_Name 
FROM CTE_Stored_Procedures
ORDER BY Stored_Procedure_Name	--Table_Name, 


Select * from @tmp

-- Iterate over all the Stored_Procedures in the database
WHILE (1=1)
BEGIN

	--1] Get the next Stored_Procedure name from the Table of Stored_Procedure Names
    SELECT @Stored_Procedure_Name = Stored_Procedure_Name, @Id = Id		--, @Table_Name = Table_Name
    FROM @tmp
    WHERE Id = @Id + 1

	----1b] Create the SQLCMD file


	

    IF @@rowcount = 0 BREAK;


        -- 2] Create a table consisting of the lines of code for that Stored_Procedure
    	BEGIN
			DECLARE @TTV_LinesOfCodeForStored_Procedure TABLE  (CodeID INT IDENTITY(1,1) PRIMARY KEY NOT NULL, LineOfCode nvarchar(Max)) 
			INSERT INTO @TTV_LinesOfCodeForStored_Procedure exec sp_helptext @Stored_Procedure_Name
			
			
			--SELECT * from @TTV_LinesOfCodeForStored_Procedure



			DECLARE @Stored_Procedure_filename NVARCHAR(1000) 
			DECLARE @FirstLineOfFile NVARCHAR(1000)  
			DECLARE @DropStored_ProcedureLine_1 NVARCHAR(1000)  
			DECLARE @DropStored_ProcedureLine_2 NVARCHAR(1000) 			
			
			
			
 			--SET @Stored_Procedure_filename = @destinationpath + '\prj_0006_TRIG_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' + @Table_Name  + '_' +  @Stored_Procedure_Name + N'.sql' 
			SET @Stored_Procedure_filename = @destinationpath + '\prj_0006_PRJ_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' +  @Stored_Procedure_Name + N'.sql' 
			--SET @FirstLineOfFile = '--' + '\prj_0006_TRIG_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' + @Table_Name  + '_' +  @Stored_Procedure_Name + N'.sql'
			SET @FirstLineOfFile = '--' + '\prj_0006_PRJ_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) +  '_' +  @Stored_Procedure_Name + N'.sql'			
			SET @DropStored_ProcedureLine_1 = 'IF OBJECT_ID(' + char(39) + @Stored_Procedure_Name + char(39) + ') IS NOT NULL DROP PROC ' + @Stored_Procedure_Name 
			SET @DropStored_ProcedureLine_2 = 'GO'
			
			DECLARE @CodeID INT = 0
			DECLARE @LineOfCode nvarchar(max) = ''
			DECLARE @LineForSQLCMDFile nvarchar(max) = ''
				
			
			--3b] APPEND a line to the SQLCMD file that calls the Create Stored_Procedure file	
			--SET @LineForSQLCMDFile = ':r $(path)\' + 'prj_0006_TRIG_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' + @Table_Name  + '_' +  @Stored_Procedure_Name + N'.sql'	
			SET @LineForSQLCMDFile = ':r $(path)\' + 'prj_0006_PRJ_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_'  +  @Stored_Procedure_Name + N'.sql'			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=@LineForSQLCMDFile   , @FileAction = 'APPEND'
			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@Stored_Procedure_filename  , @TextData=@FirstLineOfFile   , @FileAction = 'CREATENEW'		 			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@Stored_Procedure_filename  , @TextData=' '   , @FileAction = 'APPEND'	
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@Stored_Procedure_filename  , @TextData=@DropStored_ProcedureLine_1   , @FileAction = 'APPEND'			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@Stored_Procedure_filename  , @TextData=@DropStored_ProcedureLine_2   , @FileAction = 'APPEND'			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@Stored_Procedure_filename  , @TextData=' '   , @FileAction = 'APPEND'	
			
						
			-- 4] Iterate over all the lines of code in the output=============================================
			WHILE 2=2
			BEGIN
			 
				SELECT TOP(1) @CodeID = CodeID, @LineOfCode = LineOfCode
				FROM @TTV_LinesOfCodeForStored_Procedure
				WHERE CodeID &gt; @CodeID
				ORDER BY CodeID

				-- Exit loop if no more code
				IF @@ROWCOUNT = 0 BREAK;
							
			

				PRINT 'Line of Code: ' + @LineOfCode
				--5] Save the Line of Code to the file
				exec prj_0000_SP_201_WriteLineToFile  @FileName =@Stored_Procedure_filename  , @TextData=@LineOfCode   , @FileAction = 'APPEND'									
			END	-- end of writing codelines to file
			
			--6] Clear out the records, otherwise they accumulate from each Stored_Procedure
			DELETE FROM @TTV_LinesOfCodeForStored_Procedure	
			
			
  		END	-- end of list of Stored_Procedures
  		
  		

    
END
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>STANDARD_Add</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>STANDARD_Add</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_8011_SP_043_Add_New_Group_Record_To_T14.sql
-----------------------------------------

/* This SP will:

  		1] do not need to check to see if the Group is already assigned to the Security portal 
  			record b/c of constraint: [T14_UNIQUE_GroupName] 		
  				
  		2] Insert the new Group Record into T14, get the T14_PK for the new record
  				
  		3] Return the T14_PK for the new Group record, or zero (0) if there was a problem

	************************************************************************************
	NOTE: 
	Uses: 
	Created: 10/24/2012
	By: glenn garson
	************************************************************************************

*/

SET NOCOUNT ON
Use DB2_CRM
go



create PROCEDURE prj_8011_SP_043_Add_New_Group_Record_To_T14(
	@Group_Name AS nvarchar(255),
	@Group_Alternate_Name AS nvarchar(255),
	@Group_Focus AS  nvarchar(max),
	@Group_Notes AS  nvarchar(max),
	@Group_Duration AS nvarchar(255),
	@b_Active AS  bit,
	@CCWNC_Department_e14 as smallint
	)
	
	AS
	
-- START DEBUGGING SECTION -------------------	

			PRINT '1) Input @Group_Name: [' + coalesce(@Group_Name, '{NULL}')	 + ']' 
			PRINT '2) Input @Group_Alternate_Name: [' + coalesce(@Group_Alternate_Name, '{NULL}')	 + ']' 			
			PRINT '3) Input @Group_Focus: [' + coalesce(@Group_Focus, '{NULL}')	 + ']' 			
			PRINT '4) Input @Group_Notes: [' + coalesce(@Group_Notes, '{NULL}')	 + ']' 			
			PRINT '5) Input @Group_Duration: [' + coalesce(@Group_Duration, '{NULL}')	 + ']' 			
			PRINT '6) Input @b_Active: [' +  SUBSTRING('FalseTrue', @b_Active * 5 + 1, 5) + ']' 			
			PRINT '7) Input @CCWNC_Department_e14: [' + 	 CAST(@CCWNC_Department_e14 AS varchar(5)) + ']'			
																	
-- END DEBUGGING SECTION -------------------	


-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


	DECLARE @iTheNew_T14_PK INT

		
	

-- 111111111111111111111111111111111111111111111111111111111111111111111111111111222
INSERT INTO [T14_Group]
						(
						  [Group_Name]
						  ,[Group_Alternate_Name]
						  ,[Group_Focus]
						  ,[Group_Notes]
						  ,[Group_Duration]
						  ,[b_Active]
						  ,[CCWNC_Department_e14]
						)
VALUES
		(

			@Group_Name,
			@Group_Alternate_Name,
			@Group_Focus,
			@Group_Notes,
			@Group_Duration,
			@b_Active,
			@CCWNC_Department_e14
		);
		
		
	IF @@ERROR = 0
		BEGIN
			SELECT @iTheNew_T14_PK = @@IDENTITY
			PRINT 'The PK for the new Group Record is: ' + CAST(@iTheNew_T14_PK as varchar(5))
			RETURN @iTheNew_T14_PK
		END		
	ELSE	
		BEGIN
			PRINT 'Woops! There was an error while trying to insert the new Group.'	
			RETURN 0
		END				

-- 111111111111111111111111111111111111111111111111111111111111111111111111111111222


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>StoredProcedure_as_Input__Inline_and_MultiStatement_FUNCTIONS</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>StoredProcedure_as_Input__Inline_and_MultiStatement_FUNCTIONS</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>StoredProcedure_as_Input__Inline_and_MultiStatement_FUNCTIONS


How to Share Data between Stored Procedures
http://www.sommarskog.se/share_data.html  has an exhaustive overview of the problem


--Here is a example of an inline function adapted from Books Online for SQL 2000:

CREATE FUNCTION SalesByStore (@storeid varchar(30))
RETURNS TABLE AS
RETURN (SELECT t.title, s.qty
        FROM   sales s
        JOIN   titles t ON t.title_id = s.title_id
        WHERE  s.stor_id = @storeid)

--To use it, you simply say:
SELECT * FROM SalesByStore('6380')

/*
You can filter the data with WHERE or use it in a bigger query that includes other tables. 
That is, you use the function just like was a table or a view. 
You could say that an inline function is a parameterised view, 
	because the query optimizer expands the function as if it was a macro, 
	and generates the plan as if you had provided the expanded query. 
Thus, there is no performance cost for packaging a SELECT statement into an inline function. 
For this reason, when you want to reuse a stored procedure that consists of a single SELECT statement, 
	rewriting it into an inline UDF is without doubt the best choice. 
	(Or instead of rewriting it, move the SELECT into a UDF, and rewrite the existing procedure as a wrapper on the function, so that the client is unaffected.)
There are a couple of system functions you cannot use in a UDF, 
	because SQL Server thinks it matters that they are side-effecting. 
The most commonly used ones are newid(), and rand(). 
On SQL 2000 this restriction goes further and disallows all system functions that are nondeterministic, 
	that is, functions that do not return the same value for the same input parameters on each call. 
	A typical example is getdate().
	
--================================================================================================

A multi-statement function has a body that can have as many statements as you like. 
You need to declare a return table, and you insert the data to return into that table. 
Here is the function above as a multi-statement function:
*/

CREATE FUNCTION SalesByStore (@storeid varchar(30))
   RETURNS @t TABLE (title varchar(80) NOT NULL PRIMARY KEY,
                     qty   smallint    NOT NULL)  AS
BEGIN
   INSERT @t (title, qty)
      SELECT t.title, s.qty
      FROM   sales s
      JOIN   titles t ON t.title_id = s.title_id
      WHERE  s.stor_id = @storeid
   RETURN
END

/*
You use multi-statement functions in the same way as you use inline functions,
	 but in difference to inline functions, they are not expanded in place, 
	 	but instead it's like you would call a stored procedure in the middle of the query and return the data in a table variable. 
	 	This permits you to move the code of a more complex stored procedure into a function.

As you can see in the example, you can define a primary key for your return table. 
	I like to point out that this definitely best practice for two reasons:

	1]It states your assumptions of the data. 
		If your assumptions are incorrect, you will be told up front. 
		(Instead of spending time to understand why your application presents incorrect data.)
	2] This is information that is valuable to the optimizer when you use the function in a larger query.

It goes without saying, that this is only meaningful if you define a primary key on the columns you produce in the body of the UDF. 
	Adding an IDENTITY column to the return table only to get a primary key is pointless.

Compared to inline functions, multi-statement functions incur some overhead due to the return table. 
	More important, though, is that if you use the function in a query where you join with other tables, 
	the optimizer will have no idea of what the function returns, 
	and will make standard assumptions. 
This is far from always an issue, but the more rows the function returns, 
	the higher the risk that the optimizer will make incorrect estimates and produce an inefficient query plan. 
	One way to avoid this is to insert the results from the function into a temp table. 
	Since a temp table has statistics this helps the optimizer to make a better plan.

It follows from this, that there is not much reason to consider which sort of function to use. If you can express your problem in a single query, use an inline function. Only use a multi-statement function when an inline function is not possible.

User-defined functions are quite restricted in what they can do, because a UDF is not permitted to change the database state. The most important restrictions are:

You can only perform INSERT, UPDATE or DELETE statements on table variables local to the function.
You cannot call stored procedures (with the exception of extended stored procedures).
You cannot invoke dynamic SQL.
You cannot create tables, neither permanent tables nor temp tables. You can use table variables.
You cannot use RAISERROR, TRY-CATCH or BEGIN/COMMIT/ROLLBACK TRANSACTION.
You cannot use "side-effecting" system functions, such as newid() and rand().
On SQL 2000, you cannot use non-deterministic system functions.	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>StoredProcedure_as_Input__TempTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>StoredProcedure_as_Input__TempTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>How to Share Data between Stored Procedures
http://www.sommarskog.se/share_data.html  has an exhaustive overview of the problem

/*
Sharing a Temp Table
======================
Introduction
The method itself is as simple as this:	*/

CREATE PROCEDURE called_procedure @par1 int,
                                  @par2 bit,
                                  ... AS
   ...
   INSERT/UPDATE/DELETE #tmp
go
CREATE PROCEDURE caller AS
   DECLARE ...
   CREATE TABLE #mytemp (col1 int     NOT NULL,
                         col2 char(5) NULL,
                        ...)
   ...
   EXEC called_procedure @par1, @par2 ...
   SELECT * FROM #mytemp
go

/*
In this example, caller creates the temp table, and called_procedure fills it in, that is, the table is output-only. 
A different scenario is that caller fills the table with input data whereupon called_procedure performs some general computation, 
	and the caller uses the result from that computation for some purpose. 
That is, the table is used for both input and output. 
Yet a scenario is that the caller prepares the temp table with data,
	 and the callee first performs checks to verify that a number of business rules are not violated, 
	 and then goes on to update one or more tables. This would be an input-only scenario.

Changing Existing Code
Say that you have this procedure:
*/
CREATE PROCEDURE SalesByStore @storeid varchar(30) AS
   SELECT t.title, s.qty
   FROM   sales s
   JOIN   titles t ON t.title_id = s.title_id
   WHERE  s.stor_id = @storeid

--You want to reuse this result set in a second procedure that returns only titles that have sold above a certain quantity. 
--How would you achieve this by sharing a temp table without affect existing clients? 
--The solution is to move the meat of the procedure into a sub-procedure, and make the original procedure a wrapper on the original like this:

CREATE PROCEDURE SalesByStore_core @storeid varchar(30) AS
   INSERT #SalesByStore (title, qty)
      SELECT t.title, s.qty
      FROM   sales s
      JOIN   titles t ON t.title_id = s.title_id
      WHERE  s.stor_id = @storeid
go
CREATE PROCEDURE SalesByStore @storeid varchar(30) AS
   CREATE TABLE #SalesByStore(title varchar(80) NOT NULL PRIMARY KEY,
                              qty   smallint    NOT NULL)
   EXEC SalesByStore_core @storeid
   SELECT * FROM #SalesByStore
go
CREATE PROCEDURE BigSalesByStore @storeid varchar(30),
                                 @qty     smallint AS
   CREATE TABLE #SalesByStore(title varchar(80) NOT NULL PRIMARY KEY,
                              qty   smallint    NOT NULL)
   EXEC SalesByStore_core @storeid
   SELECT * FROM #SalesByStore WHERE qty &gt;= @qty
go
EXEC SalesByStore '7131'
EXEC BigSalesByStore '7131', 25
go
DROP PROCEDURE SalesByStore, BigSalesByStore, SalesByStore_core
/*
Just like in the example with the multi-statement function, I have defined a primary key for the temp table, 
	and exactly for the same reasons. 
Speaking of best practices, some readers may wonder about the use of SELECT * here. 
I think using SELECT * from a temp table created in the same procedure is OK,
	particularly if the purpose is to return all columns in the temp table. 
(In difference to using SELECT * from a table created elsewhere, 
	and which may be altered without your knowledge.)

While this solution is straightforward, 
	you may feel uneasy by the fact that the CREATE TABLE statement for the temp table appears in two places, 
	and there is a third procedure that depends on the definition. 
Here is a solution which is a little more convoluted that to some extent alleviates the situation:
*/
CREATE PROCEDURE SalesByStore_core @storeid       varchar(30),
                                   @wantresultset bit = 0 AS
   IF object_id('tempdb..#SalesByStore') IS  NULL 
   BEGIN
      CREATE TABLE #SalesByStore(title varchar(80) NOT NULL PRIMARY KEY,
                                 qty   smallint    NOT NULL)
   END

   INSERT #SalesByStore (title, qty)
      SELECT t.title, s.qty
      FROM   sales s
      JOIN   titles t ON t.title_id = s.title_id
      WHERE  s.stor_id = @storeid
      
   IF @wantresultset = 1
      SELECT * FROM #SalesByStore
go
CREATE PROCEDURE SalesByStore @storeid varchar(30) AS
   EXEC SalesByStore_core @storeid, 1
go

/*
I've moved the CREATE TABLE statement for the wrapper into the core procedure, 
	which only creates the temp table only if it does not already exist. 
The wrapper now consists of a single EXEC statement and passes the parameter @wantresultset as 1 
	to instruct the core procedure to produce the result set.
Since this parameter has a default of 0, BigSalesByStore can be left unaffected.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>StoredProcedure_as_Input__to_a_SELECT_statement</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>StoredProcedure_as_Input__to_a_SELECT_statement</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
--http://stackoverflow.com/questions/209383/select-columns-from-result-set-of-stored-procedure



Declare @tablevar table(col1 col1Type,..
insert into @tablevar(col1,..) exec MyStoredProc 'param1', 'param2'

SELECT col1, col2 FROM @tablevar</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>StoredProcedure_as_Input__using_OPENQUERY</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>StoredProcedure_as_Input__using_OPENQUERY</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--1] Need to enable DataAccess: http://sqlblogcasts.com/blogs/piotr_rodak/archive/2009/11/22/data-access-setting-on-local-server.aspx

--Test Beforehand
select server_id, name, is_data_access_enabled from sys.servers

use master

EXEC sp_serveroption 'BCC-EXPLORERDB', 'DATA ACCESS', TRUE

go

--Test afterwards
select server_id, name, is_data_access_enabled from sys.servers
--===============================================================================================================================
--2] Then you can use OpenQuery

use B2W_Reports
go
							
SELECT  * 
FROM    
OPENQUERY([BCC-EXPLORERDB], 'EXEC B2W_Reports.dbo.prj_0013_SP_226_sub_00C_Section_1ab ''04-01-2016'', ''04-30-2016'', ''0_ALL'', ''0_ALL''');  


--3] Use STORED PROC as input, AND create temp table from the input

use B2W_Reports
go
							
SELECT  * 
INTO tmpJUNK
FROM    
OPENQUERY([BCC-EXPLORERDB], 'EXEC B2W_Reports.dbo.prj_0013_SP_226_sub_00C_Section_1ab ''04-01-2016'', ''04-30-2016'', ''0_ALL'', ''0_ALL''');  




--=============================================================================================
--http://stackoverflow.com/questions/209383/select-columns-from-result-set-of-stored-procedure

--This works for me: (i.e. I only need 2 columns of the 30+ returned by sp_help_job)

SELECT name, current_execution_status 
FROM OPENQUERY (MYSERVER, 
  'EXEC msdb.dbo.sp_help_job @job_name = ''My Job'', @job_aspect = ''JOB''');  

--Before this would work, I needed to run this:

sp_serveroption 'MYSERVER', 'DATA ACCESS', TRUE;

--....to update the sys.servers table. (i.e. Using a self-reference within OPENQUERY seems to be disabled by default.)

--For my simple requirement, I ran into none of the problems described in the OPENQUERY section of Lance's excellent link.

--Rossini, if you need to dynamically set those input parameters, then use of OPENQUERY becomes a little more fiddly:

DECLARE @innerSql varchar(1000);
DECLARE @outerSql varchar(1000);

-- Set up the original stored proc definition.
SET @innerSql = 
'EXEC msdb.dbo.sp_help_job @job_name = '''+@param1+''', @job_aspect = N'''+@param2+'''' ;

-- Handle quotes.
SET @innerSql = REPLACE(@innerSql, '''', '''''');

-- Set up the OPENQUERY definition.
SET @outerSql = 
'SELECT name, current_execution_status 
FROM OPENQUERY (MYSERVER, ''' + @innerSql + ''');';

-- Execute.
EXEC (@outerSql);

/*
I'm not sure of the differences (if any) between using sp_serveroption 
	to update the existing sys.servers self-reference directly, vs. using sp_addlinkedserver (as described in Lance's link) 
	to create a duplicate/alias.

Note 1: I prefer OPENQUERY over OPENROWSET, given that OPENQUERY does not require the connection-string definition within the proc.

Note 2: Having said all this: normally I would just use INSERT ... EXEC :) Yes, it's 10 mins extra typing, but if I can help it, 
I prefer not to jigger around with:
(a) quotes within quotes within quotes, and
(b) sys tables, and/or sneaky self-referencing Linked Server setups (i.e. for these, I need to plead my case to our all-powerful DBAs :)

However in this instance, I couldn't use a INSERT ... EXEC construct, as sp_help_job is already using one. 
("An INSERT EXEC statement cannot be nested.")</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>TABLE_store_results_from_SP_into_a_table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>TABLE_store_results_from_SP_into_a_table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>TABLE_store_results_from_SP_into_a_table

--First let us create a stored stored procedure which returns result set:

CREATE DATABASE DEMOSQLHINTS
GO
USE DEMOSQLHINTS
GO
CREATE TABLE dbo.Employee(ID INT IDENTITY(1,1),Name VARCHAR(50))
 
INSERT INTO dbo.Employee(Name)
VALUES('BASAVARAJ BIRADAR'),
('SHREE BIRADAR')
GO
 
CREATE PROCEDURE dbo.GetEmployees
AS
	BEGIN
	SELECT * FROM dbo.Employee
	END
GO

EXEC dbo.GetEmployees
GO

--script shows how to move the result of the SP GetEmployees to a temporary table #TempEmployees

-- First create the table to which we want to push the SP result
CREATE TABLE #TempEmployees(EmpId int,EmpName Varchar(50))
GO
-- Insert result from the SP to temp table  --&lt;==============================================
INSERT INTO #TempEmployees
EXEC dbo.GetEmployees
GO
--Verify the Insert records
SELECT * FROM #TempEmployees


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

--example where we Insert result from a Stored Procedure with Parameter into a temporary table

--First create a stored procedure with parameter
CREATE PROCEDURE GetEmployeeDetails
(@id AS INT)
AS
BEGIN
SELECT * FROM dbo.Employee (NOLOCK)
WHERE Id = @id
END
GO
--Execute SP with parameter and dump the result into a temp table
INSERT INTO #TempEmployees
EXEC GetEmployeeDetails 2
 
GO
-- Verify the inserted records
SELECT * FROM #TempEmployees</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Stored_Procedure</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>TEMPLATE_complex_For_SP</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Stored_Procedure</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>TEMPLATE_complex_For_SP</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- gig_DMC_SaveNewClaim_CreateMilestoneSubRecord.sql


-- This SP will:

--		Accept a Full SSN, and the Claim_TEMP_PK
--		1] It will INSERT INTO / FROM  / SELECT
--			From: DMC_Claim_TEMP_t
--			To:	  DMC_Claim_t
--			and set ClaimNumberForThisSSN = 1, and the ClaimNote
--					
--			Return the Claim_PK

--		2] It will use the Claim_PK to Create a record in DMC_Claim_Milestone_t (as Claim_FK)
--			and set the CMS_1=4 {Completed} for the DMC_Claim_Milestone_t record
--			DateTimeCreated = CURRENT_TIMESTAMP, CreatedByUser = User Name

--		3] Copy all the bills that have Claim_TEMP_FK = Claim_PK into DMC_Bills_PK

--		4] Create the Milestone Records for the bills, and set BMS_1_a1=4, and BMS_1_a2=1
--			DateTimeCreated = CURRENT_TIMESTAMP, CreatedByUser = User Name
--		5] Delete the records from DMC_Claim_TEMP_t, 

--		6] Delete the records fromCMC_Bills_TEMP_t
--		

/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 5/8/2012
	By: glenn garson
	************************************************************************************
*/

SET NOCOUNT ON
Use DB2_CRM
go

	-- This setting may help performance and error reporting back to VBA.

ALTER PROCEDURE gig_DMC_SaveNewClaim_CreateMilestoneSubRecord(
	@SSN_Full AS NVARCHAR(9),
	@sClaim_TEMP_PK as NVARCHAR(25),
	@Hold_UserName AS nvarchar(255), 
	@ClaimNote AS NVARCHAR(1000), 
	@MessageFromSQL AS NVARCHAR(1000) OUTPUT
	)
	AS
	
	-- START DEBUGGING SECTION -------------------	
	
			PRINT 'Input @SSN_Full: ' + 	 @SSN_Full
			PRINT 'Input @sClaim_TEMP_PK: ' +  @sClaim_TEMP_PK
			PRINT 'Input @Hold_UserName: ' + 	 @Hold_UserName	
			PRINT 'Input @ClaimNote: ' + 	 @ClaimNote	

-- END DEBUGGING SECTION -------------------	
	

-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
   DECLARE @CONTINUE BIT	
   DECLARE @Claim_PK INT
   DECLARE @Claim_TEMP_PK INT
   
	SELECT @CONTINUE = 1	
	SELECT @Claim_PK = 0
	SELECT @MessageFromSQL = 'MessageFromSQL: '	
	SELECT @Claim_TEMP_PK =CAST(@sClaim_TEMP_PK as INT)
		
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 1] Append the Claim record, with the FULL SSN into the DMC_Claim_t table, from DMC_Claim_TEMP_t
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||



	BEGIN TRANSACTION DMC_Initialize_Claim_Bill_tr

		INSERT INTO DMC_Claim_t (Veteran_Name, 
									SSN_Original,
									Claim_No,
									Claim_Loc,
									Eligibility,
									SC_Eff_Date,
									FacilityName,
									FacilityNumber,
									DateReportWasRun,
									DateTimeUploaded,
									Pension_01,
									SC_01,
									SSN_Full,
									ClaimNumberForThisSSN,
									ClaimNote										
									)


		SELECT  Veteran_Name, 
									SSN_Original,
									Claim_No,
									Claim_Loc,
									Eligibility,
									SC_Eff_Date,
									FacilityName,
									FacilityNumber,
									DateReportWasRun,
									DateTimeUploaded,
									Pension_01,
									SC_01,
									@SSN_Full AS SSN_Full,
									1 AS ClaimNumberForThisSSN,
									@ClaimNote AS ClaimNote
									
		FROM DMC_Claim_TEMP_t
		WHERE Claim_TEMP_PK = @Claim_TEMP_PK
		
		--|||||||||||||||||||
		-- Check for errors
		-- ||||||||||||||||||
		IF (@@ERROR &lt;&gt; 0) 
			BEGIN
			--
			-- Rollback the transaction and return to the caller
			--
			SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: A new Claim was NOT created, Claim_PK: ' + @Claim_PK		
			ROLLBACK TRANSACTION DMC_Initialize_Claim_Bill_tr
			RETURN 1	-- Error in First Step
			END
		--||||||||||||||||||
		--||||||||||||||||||
			
		SELECT @Claim_PK = @@IDENTITY

		PRINT '@Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))

		SELECT @MessageFromSQL = @MessageFromSQL + '-- A new Claim was created, Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))

	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	-- 2] Use the Claim_PK to create a record in the DMC_Claim_Milestone_t table, and set the CMS_1 = 4
	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


		INSERT INTO DMC_Claim_MileStone_t(Claim_FK, CMS_1, CreatedByUser) VALUES (@Claim_PK, 4, @Hold_UserName);

		--|||||||||||||||||||
		-- Check for errors
		-- ||||||||||||||||||
		IF @@ERROR &lt;&gt; 0
			BEGIN
			--
			-- Rollback the transaction and return to the caller
			--
			SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: A record in DMC_Claim_MileStone_t was NOT created, Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))		
			ROLLBACK TRANSACTION DMC_Initialize_Claim_Bill_tr
			RETURN 2	-- Error in First Step
			END
		--||||||||||||||||||
		--||||||||||||||||||

		SELECT @MessageFromSQL = @MessageFromSQL + '-- A record in DMC_Claim_MileStone_t was created, Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))		


	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	-- 3] Copy the Bills that correspond to the Claim (@Claim_TEMP_PK) into the table: 
	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


		INSERT INTO DMC_Bills_t  ( 
					 [Claim_FK], 
					 [Bill_No] ,
					 [RX_Fill_Date], 
					 [Outpat_Visit_Date], 
					 [Discharge_Date], 
					 [STATUS_Pending_01], 
					 [VISTA_Bill_Status] ,
					 [DMC_Refer_Date], 
					 [MustValidate_01],
					 [RX_OUTPATIENT]
									)
		SELECT  
					 @Claim_PK AS Claim_FK, 
					 [Bill_No] ,
					 [RX_Fill_Date], 
					 [Outpat_Visit_Date], 
					 [Discharge_Date], 
					 [STATUS_Pending_01], 
					 [VISTA_Bill_Status] ,
					 [DMC_Refer_Date], 
					 [MustValidate_01],
					 [RX_OUTPATIENT]
				
		FROM DMC_Bills_TEMP_t
		WHERE DMC_Bills_TEMP_t.Claim_TEMP_FK = @Claim_TEMP_PK

		--|||||||||||||||||||
		-- Check for errors
		-- ||||||||||||||||||
		IF @@ERROR &lt;&gt; 0
			BEGIN
			--
			-- Rollback the transaction and return to the caller
			--
			SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: The Bills have NOT been Moved into DMC_Bills_t for Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))		
			ROLLBACK TRANSACTION DMC_Initialize_Claim_Bill_tr
			RETURN 3	-- Error in First Step
			END
		--||||||||||||||||||
		--||||||||||||||||||

		

		SELECT @MessageFromSQL = @MessageFromSQL + '-- The Bills have been Moved into DMC_Bills_t for Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))	

	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	-- 4] Create the corresponding records in DMC_Bills_MileStone_t for each of the bills that was just copied
	--		Use the Claim_FK (=@Claim_PK) in DMC_Bills_t to get the set of DMC_Bills_PK, and INSERT INTO 
	--		Set BMS_1_a1=4, and BMS_1_a2=1
	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


		INSERT INTO DMC_Bills_Milestone_t ( 
											 [Bills_FK], 
											 [BMS_1_a1] ,
											 [BMS_1_a2],
											 [CreatedByUser]
									)
		SELECT  
					 DMC_Bills_PK as Bills_FK, 
					 4 AS [BMS_1_a1] ,
					 1 AS [BMS_1_a2],
					 @Hold_UserName AS [CreatedByUser]
				
		FROM DMC_Bills_t
		WHERE DMC_Bills_t.Claim_FK = @Claim_PK

		--|||||||||||||||||||
		-- Check for errors
		-- ||||||||||||||||||
		IF @@ERROR &lt;&gt; 0
			BEGIN
			--
			-- Rollback the transaction and return to the caller
			--
			SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: The Milestones for the bills have NOT been created Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))		
			ROLLBACK TRANSACTION DMC_Initialize_Claim_Bill_tr
			RETURN 4	-- Error in First Step
			END
		--||||||||||||||||||
		--||||||||||||||||||

		

		SELECT @MessageFromSQL = @MessageFromSQL + '-- The Milestones for the bills have been created Claim_PK: ' + RTRIM(LTRIM(CAST(@Claim_PK AS NVARCHAR(25))))	

	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	-- 5] Delete the records from DMC_Claim_TEMP_t, WHERE the Claim_TEMP_PK = @Claim_TEMP_PK
	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

		DELETE DMC_Claim_TEMP_t 
		WHERE Claim_TEMP_PK = @Claim_TEMP_PK

		--|||||||||||||||||||
		-- Check for errors
		-- ||||||||||||||||||
		IF @@ERROR &lt;&gt; 0
			BEGIN
			--
			-- Rollback the transaction and return to the caller
			--
			SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: The TEMP Claim has NOT been deleted for @Claim_TEMP_PK: ' +   RTRIM(LTRIM(CAST(@Claim_TEMP_PK AS NVARCHAR(25))))		
			ROLLBACK TRANSACTION DMC_Initialize_Claim_Bill_tr
			RETURN 5	-- Error in First Step
			END
		--||||||||||||||||||
		--||||||||||||||||||

		SELECT @MessageFromSQL = @MessageFromSQL + '-- The TEMP Claim has been deleted for @Claim_TEMP_PK: ' + RTRIM(LTRIM(CAST(@Claim_TEMP_PK AS NVARCHAR(25))))	



	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	-- 6] Delete the records from DMC_Bills_TEMP_t, WHERE the DMC_Bills_TEMP_t.Claim_TEMP_FK = @Claim_TEMP_PK
	-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

		DELETE DMC_Bills_TEMP_t
		WHERE DMC_Bills_TEMP_t.Claim_TEMP_FK = @Claim_TEMP_PK


		--|||||||||||||||||||
		-- Check for errors
		-- ||||||||||||||||||
		IF @@ERROR &lt;&gt; 0
			BEGIN
			--
			-- Rollback the transaction and return to the caller
			--
			SELECT @MessageFromSQL = @MessageFromSQL + '-- ERROR: The TEMP Bills has NOT been deleted for @Claim_TEMP_PK: ' + RTRIM(LTRIM(CAST(@Claim_TEMP_PK AS NVARCHAR(25))))			
			ROLLBACK TRANSACTION DMC_Initialize_Claim_Bill_tr
			RETURN 6	-- Error in First Step
			END
		--||||||||||||||||||
		--||||||||||||||||||

		SELECT @MessageFromSQL = @MessageFromSQL + '-- The TEMP Bills has been deleted for @Claim_TEMP_PK: ' + RTRIM(LTRIM(CAST(@Claim_TEMP_PK AS NVARCHAR(25))))	


	COMMIT TRANSACTION DMC_Initialize_Claim_Bill_tr

	--**************************************************************************
		PRINT '-----------------------------------------------------------------'
  		PRINT  @MessageFromSQL 
	--**************************************************************************	



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>STRINGS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>concatenate_ValuesFromRowsOfOneColumn_intoOneString</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>STRINGS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>concatenate_ValuesFromRowsOfOneColumn_intoOneString</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--C:\DATA\TableColumnNamesAsString.sql
--https://stackoverflow.com/questions/194852/how-to-concatenate-text-from-multiple-rows-into-a-single-text-string-in-sql-serv
use RiskMngt
go


IF OBJECT_ID('Reporting.junk') IS NOT NULL
    DROP TABLE Reporting.junk
go

CREATE TABLE reporting.junk
(
  CustomerID INT PRIMARY KEY, -- FK
  Phone1 VARCHAR(32),
  Phone2 VARCHAR(32),
  Phone3 VARCHAR(32)
);
INSERT Reporting.junk
  (CustomerID, Phone1, Phone2, Phone3)
VALUES
  (1,'705-491-1111', '705-491-1110', NULL),
  (2,'613-492-2222', NULL, NULL),
  (3,'416-493-3333', '416-493-3330', '416-493-3339');
--================================================
select * from Reporting.junk;

--OUTPUT
--CustomerID		Phone1			Phone2		Phone3
--1					705-491-1111	705-491-1110	NULL
--2					613-492-2222	NULL			NULL
--3					416-493-3333	416-493-3330	416-493-33
--================================================



DECLARE @char VARCHAR(MAX);
With cte_One
as
(
	select *
	from information_schema.columns
	where 
			table_name = 'junk'
			and COLUMN_NAME not in ('CustomerID')
	--order by table_name, ordinal_position
)
--================================================ The 4th column is the Example  --&lt;======================
--OUTPUT
--TABLE_CATALOG	TABLE_SCHEMA	TABLE_NAME	COLUMN_NAME	ORDINAL_POSITION	COLUMN_DEFAULT	IS_NULLABLE	DATA_TYPE	CHARACTER_MAXIMUM_LENGTH	CHARACTER_OCTET_LENGTH	NUMERIC_PRECISION	NUMERIC_PRECISION_RADIX	NUMERIC_SCALE	DATETIME_PRECISION	CHARACTER_SET_CATALOG	CHARACTER_SET_SCHEMA	CHARACTER_SET_NAME	COLLATION_CATALOG	COLLATION_SCHEMA	COLLATION_NAME	DOMAIN_CATALOG	DOMAIN_SCHEMA	DOMAIN_NAME
--RiskMngt		Reporting		junk		Phone1			2				NULL	YES	varchar	32	32	NULL	NULL	NULL	NULL	NULL	NULL	iso_1	NULL	NULL	SQL_Latin1_General_CP1_CI_AS	NULL	NULL	NULL
--RiskMngt		Reporting		junk		Phone2			3				NULL	YES	varchar	32	32	NULL	NULL	NULL	NULL	NULL	NULL	iso_1	NULL	NULL	SQL_Latin1_General_CP1_CI_AS	NULL	NULL	NULL
--RiskMngt		Reporting		junk		Phone3			4				NULL	YES	varchar	32	32	NULL	NULL	NULL	NULL	NULL	NULL	iso_1	NULL	NULL	SQL_Latin1_General_CP1_CI_AS	NULL	NULL	NULL
--================================================

,cte_TWO 
AS
(
	SELECT 
	REPLACE(
			(select COLUMN_NAME AS 'data()'  from cte_One  for xml path(''))
			 , ' ', ', ') as abc
)

SELECT * from cte_TWO 
--OUTPUT
--abc
--Phone1, Phone2, Phone3




SELECT @char = (SELECT TOP(1) abc from cte_two) 
SELECT @char </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>STRINGS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>REPLACE_characters_in_a_variable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>STRINGS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>REPLACE_characters_in_a_variable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

/*
One useful trick in SQL is the ability use @var = function(...) to assign a value. 
If you have multiple records in your record set, your var is assigned multiple times with side-effects:
*/

declare @badStrings table (item varchar(50))

INSERT INTO @badStrings(item)
SELECT '&gt;' UNION ALL
SELECT '&lt;' UNION ALL
SELECT '(' UNION ALL
SELECT ')' UNION ALL
SELECT '!' UNION ALL
SELECT '?' UNION ALL
SELECT '@'

declare @testString varchar(100), @newString varchar(100)

set @teststring = 'Juliet ro&gt;&lt;0zs my s0x()rz!!?!one!@!@!@!'
set @newString = @testString

SELECT @newString = Replace(@newString, item, '') FROM @badStrings

select @newString -- returns 'Juliet ro0zs my s0xrzone'


--You can make the function more dynamic by passing in a comma-separated list of strings to replace, using a split function 
(sqlteam.com/forums/topic.asp?TOPIC_ID=50648)
--to convert the list into a table, then returning the replaced string.

\\\\\\\\\\\\\\\\\\\\\\CTE version:-- Uses a recursive CTE, and then recursive REPLACE of @teststring

DECLARE @badStrings VARCHAR(100)
DECLARE @teststring VARCHAR(100)

SET @badStrings = '&gt;&lt;()!?@'
SET @teststring = 'Juliet ro&gt;&lt;0zs my s0x()rz!!?!one!@!@!@!'

;WITH CTE AS
(
  SELECT SUBSTRING(@badStrings, 1, 1) AS [String], 1 AS [Start], 1 AS [Counter]
  UNION ALL
  SELECT SUBSTRING(@badStrings, [Start] + 1, 1) AS [String], [Start] + 1, [Counter] + 1 
  FROM CTE 
  WHERE [Counter] &lt; LEN(@badStrings)
)

SELECT @teststring = REPLACE(@teststring, CTE.[String], '') FROM CTE

SELECT @teststring
Juliet ro0zs my s0xrzone
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>STRINGS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>REPLACE_CLR_function</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>STRINGS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>REPLACE_CLR_function</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--Create a CLR function
--See following code:

public partial class UserDefinedFunctions 
{

[Microsoft.SqlServer.Server.SqlFunction]
public static SqlString Replace2(SqlString inputtext, SqlString filter,SqlString      replacewith)
{

    string str = inputtext.ToString();
    try
    {
        string pattern = (string)filter;
        string replacement = (string)replacewith;
        Regex rgx = new Regex(pattern);
        string result = rgx.Replace(str, replacement);
        return (SqlString)result;

    }
    catch (Exception s)
    {
        return (SqlString)s.Message;
    }
}
}


--Deploy your CLR function

--Now Test it

--See following code:

create table dbo.test(dummydata varchar(255))
Go
INSERT INTO dbo.test values('P@ssw1rd'),('This 12is @test')
Go
Update dbo.test
set dummydata=dbo.Replace2(dummydata,'[0-9@]','')

select * from dbo.test

dummydata, Psswrd, This is test booom!!!!!!!!!!!!!</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>STRINGS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>STUFF</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>STRINGS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>STUFF</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://stackoverflow.com/questions/21623593/what-is-the-meaning-of-select-for-xml-path-1-1


-- How does this example work
declare @t table
(
    Id int,
    Name varchar(10)
)
insert into @t
select 1,'a' union all
select 1,'b' union all
select 2,'c' union all
select 2,'d' 

--select * from @t

select ID,
stuff(
(
    select ','+ [Name] from @t where Id = t.Id for XML path('')
),1,1,'') 
from (select  ID from @t )t
--from (select distinct ID from @t )t

--OUTPUT from @t
Id	Name
1	a
1	b
2	c
2	d


--Final Output: without DISTINCT:
ID	(No column name)
1	a,b
1	a,b
2	c,d
2	c,d

--Final Output: DISTINCT
1	a,b
2	c,d


--The ('') in for xml path is used to remove wrapper node, that is being automatically created. 
--Otherwise it would look like:
 &lt;row&gt;,a,b,c,d&lt;/row&gt;.

SELECT ',' + ColumnName ... FOR XML PATH('')
--generates a set of comma separated values, based on combining multiple rows of data from the ColumnName column. 
--It will produce a value like ,abc,def,ghi,jkl.

STUFF(...,1,1,'')
--Is then used to remove the leading comma that the previous trick generated, see STUFF for details about its parameters.

--(Strangely, a lot of people tend to refer to this method of generating a comma separated set of values as "the STUFF method" 
--despite the STUFF only being responsible for a final bit of trimming)



--=======================================================================Question
https://stackoverflow.com/questions/31211506/how-stuff-and-for-xml-path-work-in-sql-server
-- I just need the explanation how it works or is there any other or short way to do this.
Table is:

+----+------+
| Id | Name |
+----+------+    
| 1  | aaa  |
| 1  | bbb  |
| 1  | ccc  |
| 1  | ddd  |
| 1  | eee  |
+----+------+
Required output:

+----+---------------------+
| Id |        abc          |
+----+---------------------+ 
|  1 | aaa,bbb,ccc,ddd,eee |
+----+---------------------+
Query:

SELECT ID, 
    abc = STUFF(
                 (SELECT ',' + name FROM temp1 FOR XML PATH ('')), 1, 1, ''
               ) 
FROM temp1 GROUP BY id

--=======================================================================answer 1

1. Get XML element string with FOR XML
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
--Adding FOR XML PATH to the end of a query allows you to output the results of the query as XML elements, 
--with the element name contained in the PATH argument. For example, if we were to run the following statement:

SELECT ',' + name 
              FROM temp1
              FOR XML PATH ('')
By passing in a blank string (FOR XML PATH('')), we get the following instead:

,aaa,bbb,ccc,ddd,eee

2. Remove leading comma with STUFF
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
--The STUFF statement literally "stuffs” one string into another, replacing characters within the first string. 
--We, however, are using it simply to remove the first character of the resultant list of values.

SELECT abc = STUFF((
            SELECT ',' + NAME
            FROM temp1
            FOR XML PATH('')
            ), 1, 1, '')
FROM temp1

The parameters of STUFF are:
..............................
-The string to be “stuffed” (in our case the full list of name with a leading comma)
-The location to start deleting and inserting characters (1, we’re stuffing into a blank string)
-The number of characters to delete (1, being the leading comma)

So we end up with:

aaa,bbb,ccc,ddd,eee

3. Join on id to get full list
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Next we just join this on the list of id in the temp table, to get a list of IDs with name:

SELECT ID,  abc = STUFF(
             (SELECT ',' + name 
              FROM temp1 t1
              WHERE t1.id = t2.id
              FOR XML PATH (''))
             , 1, 1, '') from temp1 t2
group by id;

--And we have our result:

-----------------------------------
| Id        | Name                |
|---------------------------------|
| 1         | aaa,bbb,ccc,ddd,eee |
-----------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table_Column</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ColumnsOfATable_int_a_string</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table_Column</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ColumnsOfATable_int_a_string</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--C:\DATA\TableColumnNamesAsString.sql
--https://stackoverflow.com/questions/194852/how-to-concatenate-text-from-multiple-rows-into-a-single-text-string-in-sql-serv
use RiskMngt
go

IF OBJECT_ID('Reporting.junk') IS NOT NULL
    DROP TABLE Reporting.junk
go

CREATE TABLE reporting.junk
(
  CustomerID INT PRIMARY KEY, -- FK
  Phone1 VARCHAR(32),
  Phone2 VARCHAR(32),
  Phone3 VARCHAR(32)
);
INSERT Reporting.junk
  (CustomerID, Phone1, Phone2, Phone3)
VALUES
  (1,'705-491-1111', '705-491-1110', NULL),
  (2,'613-492-2222', NULL, NULL),
  (3,'416-493-3333', '416-493-3330', '416-493-3339');
--================================================
select * from Reporting.junk;

--0OUTPUT:
CustomerID	Phone1	Phone2	Phone3
1	705-491-1111	705-491-1110	NULL
2	613-492-2222	NULL	NULL
3	416-493-3333	416-493-3330	416-493-3339
--================================================

--C:\DATA\TableColumnNamesAsString.sql
--https://stackoverflow.com/questions/194852/how-to-concatenate-text-from-multiple-rows-into-a-single-text-string-in-sql-serv
use RiskMngt
go

DECLARE @char VARCHAR(MAX);
With cte_One
as
(
	select *
	from information_schema.columns
	where 
			table_name = 'junk'
			and COLUMN_NAME not in ('CustomerID')
	--order by table_name, ordinal_position
)

,cte_TWO 
AS
(
	SELECT 
	REPLACE(
			(select COLUMN_NAME AS 'data()'  from cte_One  for xml path(''))
			--(select COLUMN_NAME + '_' + COLUMN_NAME  AS 'data()'  from cte_One  for xml path(''))
			 --, ' ', '_' + COLUMN_NAME + ', ') as abc
			 , ' ', ', ') as abc
	--from cte_One
)
--SELECT * from cte_TWO 
SELECT @char = (SELECT TOP(1) abc from cte_two) 
SELECT @char 

--OUTPUT:
(No column name)
Phone1, Phone2, Phone3
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table_Maintenance</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Insert_To_Archive_from_WorkingTable__repopulateWorkingTable_from_zzzTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table_Maintenance</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Insert_To_Archive_from_WorkingTable__repopulateWorkingTable_from_zzzTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Insert_To_Archive_from_WorkingTable__repopulateWorkingTable_from_zzzTable

--n_0004_Task_001_MAINT_001_PopulateTheReportTableAndArchvieTheOldData.sql
/*
	************************************************************************************

	CHANGE THE INPUT TABLE NAME AT THE BOTTOM OF THE SCRIPT  &lt;===== Do This!

	This script takes the data from this table:
		n_0004_Task_001_TABLE_01
	and inserts it into the Archive:
		n_0004_Task_001_TABLE_01__ARCHIVE

	Then it takes the new data from:
		zzz_n_0004_Task_001_ORACLE_004__mm_dd_yyyy_to_mm_dd_yyyy 
	and truncates, and then inserts the data into
		n_0004_Task_001_TABLE_01

    IF there is data in the ARCHIVE with the same value in the [Date Range] as 
		the data being inserted into the ARCHIVE, then the script deletes those records
		from the ARCHIVE first.


	Created: 02/08/2018
	By: glenn garson
	************************************************************************************
*/

USE [DIV_JeffCare]
GO


--====================================
--If there are already records for that date range then delete them
DELETE FROM n_0004_Task_001_TABLE_01__ARCHIVE
WHERE [Date Range] in (
				SELECT TOP (1) [Date Range] 
				FROM [DIV_JeffCare].[dbo].[n_0004_Task_001_TABLE_01]
			 )


--====================================	


INSERT  n_0004_Task_001_TABLE_01__ARCHIVE
		(
			[Date Range]
			,[Location]
			,[Service Type]
			,[Provider Name]
			,[# of Appts Sched]
			,[# of Appts Kept]
			,[# of No-Shows]
			,[# of Appts canc by PROVIDER]
			,[# of Appts canc by PATIENT]
			,[% of Appts KEPT]
			,[% No-Shows]
			,[@ of Appts canc by PROVIDER]
			,[% of Appts canc by PATIENT]
		)
SELECT 
			[Date Range]
			,[Location]
			,[Service Type]
			,[Provider Name]
			,[# of Appts Sched]
			,[# of Appts Kept]
			,[# of No-Shows]
			,[# of Appts canc by PROVIDER]
			,[# of Appts canc by PATIENT]
			,[% of Appts KEPT]
			,[% No-Shows]
			,[@ of Appts canc by PROVIDER]
			,[% of Appts canc by PATIENT]
FROM n_0004_Task_001_TABLE_01				

--===========================================
--Once the data has been archived, Remove the contents of the table [n_0004_Task_001_TABLE_01]
--	before re-populating it.
TRUNCATE TABLE [n_0004_Task_001_TABLE_01]

--===========================================


INSERT  [n_0004_Task_001_TABLE_01]
		(
			[Date Range]
			,[Location]
			,[Service Type]
			,[Provider Name]
			,[# of Appts Sched]
			,[# of Appts Kept]
			,[# of No-Shows]
			,[# of Appts canc by PROVIDER]
			,[# of Appts canc by PATIENT]
			,[% of Appts KEPT]
			,[% No-Shows]
			,[@ of Appts canc by PROVIDER]
			,[% of Appts canc by PATIENT]
		)
SELECT 
			[Date Range]
			,[Location]
			,[Service Type]
			,[Provider Name]
			,[# of Appts Sched]
			,[# of Appts Kept]
			,[# of No-Shows]
			,[# of Appts canc by PROVIDER]
			,[# of Appts canc by PATIENT]
			,[% of Appts KEPT]
			,[% No-Shows]
			,[@ of Appts canc by PROVIDER]
			,[% of Appts canc by PATIENT]
FROM zzz_n_0004_Task_001_ORACLE_004__04_01_2016_to_06_30_2017	----&lt;============== CHANGE THIS EACH TIME</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TABLE_Temporal</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>01_Create_Parent_Table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TABLE_Temporal</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>01_Create_Parent_Table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>01_Create_Parent_Table

--this one has create and update triggers


--p_0003_CREATE_TABLE_T004_IP_Inventory_v1.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 05/09/2017
	By: glenn garson
	************************************************************************************
*/
use JUNK
--USE [d1_IT]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF OBJECT_ID('dbo.T004_IP_Inventory') IS NOT NULL
    DROP TABLE dbo.T004_IP_Inventory

go

CREATE TABLE [dbo].[T004_IP_Inventory](

			[T004_IP_Inventory_PK] [int] IDENTITY(1,1) NOT NULL,

			[JPHSA_Tag] [nvarchar](25) NULL,
			[Monitor-1_FK] INT NULL,
			[Monitor-2_FK] INT NULL,
			[Monitor-3_FK] INT NULL,
			[Vendor_Service_Tag] [nvarchar](25) NULL,
			[Room_Number] [nvarchar](25) NULL,
			[User] [nvarchar](255) NULL,
			[Group] [nvarchar](255) NULL,
			[Location] [nvarchar](25) NULL,
			[DeviceType_T005_e1] int NOT NULL  CONSTRAINT DeviceType_T005_e1_Default_ZERO DEFAULT(0),
			[DeviceType_T005_e1_Description] [nvarchar](255) NULL,	--Use this while setting it up, then remove this field 
			[Model_Brand] [nvarchar](255) NULL,
			[Comment] [nvarchar](255) NULL,
			[Building_T005_e2] int NOT NULL  CONSTRAINT DeviceType_T005_e2_Default_ZERO DEFAULT(0),
			[Building_T005_e2_Description] [nvarchar](255) NULL,
			[Project] [nvarchar](255) NULL,
			[DeviceStatus_T005_e3] int NOT NULL  CONSTRAINT DeviceType_T005_e3_Default_ZERO DEFAULT(0),
			[DeviceStatus_T005_e3_Description] [nvarchar](255) NULL,


			CreateRecord_dateTime datetime,
			CreateRecord_name sysname,
			UpdateRecord_dateTime datetime,
			UpdateRecord_name sysname,
		
			--[DateTime_RecordCreated] [datetime] NOT NULL CONSTRAINT T004_TheDateTime_Default_GETDATE DEFAULT GETDATE(),

			[T004_RowVersion] [timestamp] NULL,
			CONSTRAINT [T004_IP_Inventory$T004_PK] PRIMARY KEY NONCLUSTERED 
				(
					[T004_IP_Inventory_PK] ASC
				)
				WITH 
						(
							PAD_INDEX  = OFF, 
							STATISTICS_NORECOMPUTE  = OFF, 
							IGNORE_DUP_KEY = OFF, 
							ALLOW_ROW_LOCKS  = ON, 
							ALLOW_PAGE_LOCKS  = ON
						) ON [PRIMARY]
		) ON [PRIMARY]
		GO

		SET ANSI_PADDING OFF
		GO


-- insert/update dates
alter table T004_IP_Inventory
    add constraint [T004_CreateRecord_dateTime] default (getdate()) for CreateRecord_dateTime;
alter table T004_IP_Inventory
    add constraint [T004_UpdateRecord_dateTime] default (getdate()) for UpdateRecord_dateTime;

-- insert/update names
alter table T004_IP_Inventory
    add constraint [T004_CreateRecord_name] default (coalesce(suser_sname(),'?')) for CreateRecord_name;

alter table T004_IP_Inventory
    add constraint [T004_UpdateRecord_name] default (coalesce(suser_sname(),'?')) for UpdateRecord_name;
go

--For updates, but the inserted and deleted tables exist. I choose to join on the inserted for the update.

-- create the update trigger
create trigger TRG_001_recordChanged_T004 on dbo.T004_IP_Inventory
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       UpdateRecord_dateTime = getdate(),
       UpdateRecord_name = (coalesce(suser_sname(),'?'))
    from
       T004_IP_Inventory d join inserted i 
    on 
       d.T004_IP_Inventory_PK = i.T004_IP_Inventory_PK;

end
go
--added constraint on 5/26/2017
ALTER TABLE [dbo].[T004_IP_Inventory]
  ADD CONSTRAINT uniqueValues$JPHSA_Tag_Value UNIQUE NONCLUSTERED ([JPHSA_Tag])

			


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table_Valued_Parameters</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Call_SP_with_TableValuedParm_from_SQL_and_from_C#</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table_Valued_Parameters</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Call_SP_with_TableValuedParm_from_SQL_and_from_C#</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Call_SP_with_TableValuedParm_From_C#

/*
1] Table-Valued User Defined Data Type
=======================================
First we need to Create a User Defined Table Type which can be reused in multiple stored procedures as input table parameter data type.
*/

CREATE TYPE dbo.CustomerTableType AS TABLE
( 
 [CustomerID] INT,
 [Name]  VARCHAR(50)
)
GO

/*
1a] EXECUTE Permission ON Table Type User Defined Type:
===================================================
Eventhough we have Execute permission on the Stored Procedure, 
	we still need to give Execute permission on the Table Type User Defined Type. 
	Below is the syntax for granting execute persmission on the Table Type User Defined Type
*/

GRANT EXECUTE ON TYPE::dbo.CustomerTableType TO UserName


/*
2] Stored Procedure with Table-Valued input Parameter
=====================================================
Now let us create a simple stored procedure which takes CustomerType User Definde Table Type which we have created previously
*/
CREATE PROCEDURE dbo.GetCustomerDetails
(
 @Customers AS dbo.CustomerTableType READONLY
)
AS
BEGIN
 SET NOCOUNT ON

 SELECT *
 FROM @Customers
END

/*
3] Using Stored Procedure With Table Valued Parameter in Sql Server
===================================================================
*/

Declare @CustomerDetails As dbo.CustomerTableType
Insert Into @CustomerDetails 
Values
		 (1,'Basavaraj'),
         (2,'Monty'),
         (3,'Shashank') 

Exec dbo.GetCustomerDetails @CustomerDetails
GO
/*
Result:
CustomerID   Name
----------- ------------
1           Basavaraj
2           Monty
3           Shashank

/*
4] Calling Stored Procedure with Table Valued Parameter from C# Code
=====================================================================
Below is a sample C# Code example 
	which calls the GetCustomerDetails Stored Procedure 
	with Table-Valued Parameter which is created in the previous section.

*/

using System;
using System.Data;
using System.Data.SqlClient;
namespace TableValuedParameter
{
    class Program
    {
        static void Main(string[] args)
        {
            //Create and open a connection object
            SqlConnection conn = new SqlConnection(
               "ENTER A VALID CONNECTION STRING");
            conn.Open();

            //Create a command object specify the stored procedure
            SqlCommand cmd = new SqlCommand("dbo.GetCustomerDetails", conn);
            cmd.CommandType = CommandType.StoredProcedure;
            //PrePare the rows of Data to be Passed to the Stored Procedure            
            DataTable dataTable = new DataTable("Customer");
            dataTable.Columns.Add("Id", typeof(Int32));
            dataTable.Columns.Add("Name", typeof(string));
            dataTable.Rows.Add(1, "Basavaraj");
            dataTable.Rows.Add(2, "Monty");
            dataTable.Rows.Add(3, "Shashank");
            //Add the Table-Valued Parameter value to the Command Object            
            SqlParameter param = new SqlParameter("@Customers", dataTable);
            param.SqlDbType = SqlDbType.Structured;           
            cmd.Parameters.Add(param);
            // Execute the command
            SqlDataReader rdr = cmd.ExecuteReader();
            // iterate through results, printing each record to the console
            while (rdr.Read())
            {
                Console.WriteLine("Employee ID: {0} Name: {1}"
                                            ,rdr["CustomerID"],rdr["Name"]);
            }
            conn.Close();
            rdr.Close();
            Console.ReadKey();
        }
    }
}

Result Seen on the console: 
Employee ID: 1 Name: Basavaraj
Employee ID: 2 Name: Monty
Employee ID: 3 Name: Shashank
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TABLE_VARIABLE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>about_TABLE_VARIABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TABLE_VARIABLE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>about_TABLE_VARIABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_TABLE_VARIABLE



//////////////////////////////////////////--INSERT INTO
DECLARE @userData TABLE(
    name varchar(30) NOT NULL,
    oldlocation varchar(30) NOT NULL
);

INSERT INTO @userData
SELECT name, location FROM myTable
INNER JOIN otherTable ON ...
WHERE age &gt; 30;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TABLE_VARIABLE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Create_TVP_TableVariable_from_Stored_Procedure</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TABLE_VARIABLE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Create_TVP_TableVariable_from_Stored_Procedure</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Create_TVP_TableVariable_from_Stored_Procedure

--=====================================================================
NOTE: The TVP (TableVariable) and the INSERT statement 
		must include all the fields from the Stored Procedure.
	  It is only in the 3rd step that you can cull some of the variables 
--=====================================================================



--prj_0013_SP_237_SubProj_00E_Audit_Scheduled_Days_v2.sql


/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 10/13/2016
	By: glenn garson
	************************************************************************************
*/
use B2W_Reports
go

--------------------------------DEBUG PARMS START
DECLARE @BeginDate date
SELECT @BeginDate = '09-01-2016'

DECLARE @EndDate date
SELECT @EndDate = '09-30-2016'

DECLARE @BU as nvarchar(max)
SELECT @BU ='0_ALL'	--'HCC'	--'SSA'

DECLARE @Mechanic as nvarchar(max)
SELECT @Mechanic ='0_ALL'

--------------------------------DEBUG PARMS END

--create Procedure prj_0013_SP_237_SubProj_00E_Audit_Scheduled_Days(
--		 @BeginDate as date,
--         @EndDate as date,	
--         @BU as nvarchar(max),
--         @Mechanic as nvarchar(max)                	
--	)

--	as

Declare	@CompletedWorkOrders_1ab TABLE					--WAS: @NumeratorTable_1ab TABLE 
(
		   [Equipment_No] nvarchar(100) NULL
		  ,[WO_ID] int NOT NULL
		  ,[MR_ID] int	NULL
		  ,[MR_Reason] nvarchar(100)
		  ,[MR_Created_Date] datetime
		  ,[WO_Created_Date] datetime
		  ,[WO_Due_Date] datetime
		  ,[WO_Start_Date] datetime						--&lt;== Use this the "WO Start Date"
		  ,[WO_End_Date] datetime
		  ,[MR_Completed_Date] datetime
		  ,[Mechanic] nvarchar(201)
		  ,[WO_Priority] nvarchar(100)
		  ,[WO_Problem_Description] nvarchar(200)
		  ,[WO_Problem_Code] nvarchar(50)
		  ,estimated_WO_Completed_Date datetime
		  ,COUNT_MR_ID int
		  ,COUNT_MR_Completed_Date int
		  ,WO_Completed_Date datetime					 --&lt;===
		  ,BackLog int
		  ,Schedule int
		  ,BU_Name nvarchar(100)
		  ,Days_to_Create_WO int
		  ,Days_from_Request int		
)



insert into @CompletedWorkOrders_1ab(
							   [Equipment_No]
							  ,[WO_ID]
							  ,[MR_ID]
							  ,[MR_Reason]
							  ,[MR_Created_Date]
							  ,[WO_Created_Date]
							  ,[WO_Due_Date]
							  ,[WO_Start_Date]
							  ,[WO_End_Date]
							  ,[MR_Completed_Date]
							  ,[Mechanic]
							  ,[WO_Priority]
							  ,[WO_Problem_Description]
							  ,[WO_Problem_Code]
							  ,estimated_WO_Completed_Date
							  ,COUNT_MR_ID
							  ,COUNT_MR_Completed_Date
							  ,WO_Completed_Date
							  ,BackLog
							  ,Schedule
							  ,BU_Name
							  ,Days_to_Create_WO
							  ,Days_from_Request
							) exec prj_0013_SP_226_sub_00C_Section_1ab @BeginDate, @EndDate, @BU, @Mechanic
							


;							
With CTE_CompletedWorkOrders_1ab
AS
(							
	select    --DISTINCT 
				   [Equipment_No]
				  ,[WO_ID]
				  ,[MR_ID]
				  --,[MR_Reason]
				  ,[MR_Created_Date]
				  ,[WO_Created_Date]
				  --,[WO_Due_Date]
				  ,[WO_Start_Date]
				  ,[WO_End_Date]
				  ,[MR_Completed_Date]
				  ,[Mechanic]
				  --,[WO_Priority]
				  --,[WO_Problem_Description]
				  --,[WO_Problem_Code]
				  ,estimated_WO_Completed_Date
				  --,COUNT_MR_ID
				  --,COUNT_MR_Completed_Date
				  ,WO_Completed_Date
				  --,BackLog
				  ,Schedule
				  ,BU_Name
				  --,Days_to_Create_WO
				  --,Days_from_Request
				  ,'1ab' as [Sub_Sub_Population]
				  ,'PM125' as [Sub_Population]
	from @CompletedWorkOrders_1ab 
)



--========================================================================

SELECT	--u.*
				   DATEDIFF( dd , [WO_Start_Date] , [WO_Completed_Date] ) as DaysScheduled_WO ,
					DATEDIFF( dd , [MR_Created_Date] , [MR_Completed_Date] ) as DaysScheduled_MR,	 --&lt;====				   
				   u.[Equipment_No]
				  ,u.[WO_ID]
				  ,u.[MR_ID]
				  --,u.[MR_Reason]
				  ,u.[MR_Created_Date]
				  ,u.[WO_Created_Date]
				  --,u.[WO_Due_Date]
				  ,u.[WO_Start_Date]
				  ,u.[WO_End_Date]
				  ,u.[MR_Completed_Date]
				  ,u.[Mechanic]
				  --,u.[WO_Priority]
				  --,u.[WO_Problem_Description]
				  --,u.[WO_Problem_Code]
				  ,estimated_WO_Completed_Date
				  --,COUNT_MR_ID
				  --,COUNT_MR_Completed_Date
				  ,WO_Completed_Date
				  --,BackLog
				  ,Schedule
				  ,BU_Name
				  --,Days_to_Create_WO
				  --,Days_from_Request
				  ,u.[Sub_Sub_Population]
				  ,u.[Sub_Population],	

		avgDaysScheduled_WO = avg(DATEDIFF( dd , [WO_Start_Date] , [WO_Completed_Date] ) ) OVER (PARTITION BY [Sub_Population],[year], [month], [WeekOfMonth], [WO_ID]),		
		avgDaysScheduled_MR = avg(DATEDIFF( dd , [MR_Created_Date] , [MR_Completed_Date] ) ) OVER (PARTITION BY [Sub_Population],[year], [month], [WeekOfMonth], [WO_ID])		
FROM
		(
			SELECT * from CTE_CompletedWorkOrders_1ab

		)  as u
		LEFT OUTER JOIN	
		[LIST_DateDimension] d
		on	Convert(date,u.WO_Completed_Date) = d.Date	
WHERE 
	(DATEDIFF( dd , [WO_Start_Date] , [WO_Completed_Date] )&lt;0)
	OR
	(DATEDIFF( dd , [MR_Created_Date] , [MR_Completed_Date] )&lt;0)
		
ORDER BY WO_ID, MR_ID
								
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TABLE_VARIABLE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>POPULATE_TVP_from_CTE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TABLE_VARIABLE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>POPULATE_TVP_from_CTE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>use B2W_Reports
go

----------------------------------DEBUG PARMS START


DECLARE @BU as nvarchar(max)
SELECT @BU ='0_ALL'	--'HCC'	--'SSA'

DECLARE @Mechanic as nvarchar(max)
SELECT @Mechanic ='0_ALL'

DECLARE @Week_1_Start date
SELECT @Week_1_Start = ' '

DECLARE @Week_1_USE bit
SELECT @Week_1_USE = 0

DECLARE @Week_2_Start date
SELECT @Week_2_Start = '09-05-2016'

DECLARE @Week_2_USE bit
SELECT @Week_2_USE = 1

DECLARE @Week_3_Start date
SELECT @Week_3_Start = '09-12-2016'

DECLARE @Week_3_USE bit
SELECT @Week_3_USE = 1

DECLARE @Week_4_Start date
SELECT @Week_4_Start = '09-19-2016'

DECLARE @Week_4_USE bit
SELECT @Week_4_USE = 1

DECLARE @Week_5_Start date
SELECT @Week_5_Start = '09-26-2016'

DECLARE @Week_5_USE bit
SELECT @Week_5_USE = 1

DECLARE @Week_6_Start date
SELECT @Week_6_Start = ' '

DECLARE @Week_6_USE bit
SELECT @Week_6_USE = 1

--------------------------------DEBUG PARMS END

--=====================================Internal Variables - START
DECLARE @BeginDate date

DECLARE @EndDate date

DECLARE @NoOfWeeks INT

DECLARE @BeginEndDate_TVP TABLE(                                                 --&lt;=== DEFINE THE TVP
    beginDate  date,
    endDate  date,
    NoOfWeeks INT
    
);
--=====================================Internal Variables - END


							
;	With CTE_Begin_End_Dates_ALL                                                 --&lt;=== POPULATE the CTE with some synthetic data
AS 
(
	SELECT 1 as TheWeek, @Week_1_Start as START_DATE, @Week_1_USE as USE_Week, DATEADD(dd, 6, @Week_1_Start) as END_DATE
	UNION 
	SELECT 2, @Week_2_Start, @Week_2_USE, DATEADD(dd, 6, @Week_2_Start)
	UNION 
	SELECT 3, @Week_3_Start, @Week_3_USE, DATEADD(dd, 6, @Week_3_Start)	
	UNION 
	SELECT 4, @Week_4_Start, @Week_4_USE, DATEADD(dd, 6, @Week_4_Start)	
	UNION 
	SELECT 5, @Week_5_Start, @Week_5_USE, DATEADD(dd, 6, @Week_5_Start)	
	UNION 
	SELECT 6, @Week_6_Start, @Week_6_USE, DATEADD(dd, 6, @Week_6_Start)		
)

	INSERT INTO @BeginEndDate_TVP                                                    --&lt;=== POPULATE the TVP     
	SELECT 
			MIN(START_DATE) as BeginDate,
			MAX(END_DATE) as EndDate,
			SUM(CAST(USE_Week as INT)) as NoOfWeeks
	FROM CTE_Begin_End_Dates_ALL
	WHERE (
			(USE_Week =1)
			AND
			(START_DATE &lt;&gt; '1900-01-01')
		   )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TABLE_VARIABLE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Populate_TVP_from_StoredProcedure_then_into_CTE_Then_into_tempTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TABLE_VARIABLE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Populate_TVP_from_StoredProcedure_then_into_CTE_Then_into_tempTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Populate_TVP_from_StoredProcedure_then_into_CTE_Then_into_tempTable



IF OBJECT_ID('tempdb..#prj_0013_SP_239') IS NOT NULL		--&lt;== Delete the tmp file before running

	DROP TABLE #prj_0013_SP_239



Declare	@CompletedWorkOrders_1ab TABLE					--&lt;=== Define the TVP 
(
		   [Equipment_No] nvarchar(100) NULL
		  ,[WO_ID] int NOT NULL
		  ,[MR_ID] int	NULL
		  ,[MR_Reason] nvarchar(100)
		  ,[MR_Created_Date] datetime
		  ,[WO_Created_Date] datetime
		  ,[WO_Due_Date] datetime
		  ,[WO_Start_Date] datetime						
		  ,[WO_End_Date] datetime
		  ,[MR_Completed_Date] datetime
		  ,[Mechanic] nvarchar(201)
		  ,[WO_Priority] nvarchar(100)
		  ,[WO_Problem_Description] nvarchar(200)
		  ,[WO_Problem_Code] nvarchar(50)
		  ,estimated_WO_Completed_Date datetime
		  ,COUNT_MR_ID int
		  ,COUNT_MR_Completed_Date int
		  ,WO_Completed_Date datetime					 
		  ,BackLog int
		  ,Schedule int
		  ,BU_Name nvarchar(100)
		  ,Days_to_Create_WO int
		  ,Days_from_Request int
		  ,estimated_WO_Create_Date	datetime	
)


insert into @CompletedWorkOrders_1ab(					--&lt;=== Populate the TVP from the Stored Procedure
							   [Equipment_No]
							  ,[WO_ID]
							  ,[MR_ID]
							  ,[MR_Reason]
							  ,[MR_Created_Date]
							  ,[WO_Created_Date]
							  ,[WO_Due_Date]
							  ,[WO_Start_Date]
							  ,[WO_End_Date]
							  ,[MR_Completed_Date]
							  ,[Mechanic]
							  ,[WO_Priority]
							  ,[WO_Problem_Description]
							  ,[WO_Problem_Code]
							  ,estimated_WO_Completed_Date
							  ,COUNT_MR_ID
							  ,COUNT_MR_Completed_Date
							  ,WO_Completed_Date
							  ,BackLog
							  ,Schedule
							  ,BU_Name
							  ,Days_to_Create_WO
							  ,Days_from_Request
							  ,estimated_WO_Create_Date
							) exec prj_0013_SP_226_sub_00C_Section_1ab @BeginDate, @EndDate, @BU, @Mechanic
							
;With CTE_CompletedWorkOrders_1ab                        --Populate a CTE from the TVP, and add,modify, or delete fields
AS
(							
	select    --DISTINCT 
				   [Equipment_No]
				  ,[WO_ID]
				  ,[MR_ID]
				  ,[MR_Created_Date]
				  ,[WO_Created_Date]
				  ,[WO_Due_Date]
				  ,[WO_Start_Date]
				  ,[WO_End_Date]
				  ,[MR_Completed_Date]
				  ,[Mechanic]
				  ,[WO_Priority]
				  ,[WO_Problem_Description]
				  ,[WO_Problem_Code]
				  ,estimated_WO_Completed_Date
				  ,WO_Completed_Date
				  ,BackLog
				  ,Schedule
				  ,BU_Name
				  ,'1ab' as [Sub_Sub_Population]
				  ,'PM125' as [Sub_Population]
				  ,estimated_WO_Create_Date				  
	from @CompletedWorkOrders_1ab 
)							
			
							
	SELECT  DISTINCT			--&lt;==  POPULATE the Temp Table from a CTE.  I am using a #temp table rather than a CTE so that I can reference it multiple times below
			Sub_Population
			,WeekOfMonth
			,Week_COUNT_WO_Completed_Sub_Population = Count([WO_ID]) OVER (PARTITION BY [Sub_Population], [WeekOfMonth]),			
			DaysScheduled_WO = avg([avgDaysScheduled_WO]) OVER (PARTITION BY [Sub_Population], [WeekOfMonth]),			
			DaysScheduled_MR = avg([avgDaysScheduled_MR]) OVER (PARTITION BY [Sub_Population], [WeekOfMonth])			
			, FirstDayOfWeek
			, LastDayOfWeek
	INTO #prj_0013_SP_239														 
	FROM CTE_Completed_WO_Stats                --&lt;=== This CTE is a product of the CTE above							
							</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TABLE_VARIABLE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Populate_with_OUTPUT_clause</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TABLE_VARIABLE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Populate_with_OUTPUT_clause</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--1] Create data for example =========================================

USE AdventureWorks2008
IF OBJECT_ID ('BookInventory', 'U') IS NOT NULL
DROP TABLE dbo.BookInventory;
 
CREATE TABLE dbo.BookInventory  -- target
(
  TitleID INT NOT NULL PRIMARY KEY,
  Title NVARCHAR(100) NOT NULL,
  Quantity INT NOT NULL
    CONSTRAINT Quantity_Default_1 DEFAULT 0
);
IF OBJECT_ID ('BookOrder', 'U') IS NOT NULL
DROP TABLE dbo.BookOrder;
 
CREATE TABLE dbo.BookOrder  -- source
(
  TitleID INT NOT NULL PRIMARY KEY,
  Title NVARCHAR(100) NOT NULL,
  Quantity INT NOT NULL
    CONSTRAINT Quantity_Default_2 DEFAULT 0
);
INSERT BookInventory VALUES
  (1, 'The Catcher in the Rye', 6),
  (2, 'Pride and Prejudice', 3),
  (3, 'The Great Gatsby', 0),
  (5, 'Jane Eyre', 0),
  (6, 'Catch 22', 0),
  (8, 'Slaughterhouse Five', 4);
INSERT BookOrder VALUES
  (1, 'The Catcher in the Rye', 3),
  (3, 'The Great Gatsby', 0),
  (4, 'Gone with the Wind', 4),
  (5, 'Jane Eyre', 5),
  (7, 'Age of Innocence', 8);
  
--2] OUTPUT Clause =&gt; Table Variable  

DECLARE @MergeOutput TABLE
(
  ActionType NVARCHAR(10),
  DelTitleID INT,
  InsTitleID INT,
  DelTitle NVARCHAR(50),
  InsTitle NVARCHAR(50),
  DelQuantity INT,
  InsQuantity INT
);
 
MERGE BookInventory bi
USING BookOrder bo
ON bi.TitleID = bo.TitleID
WHEN MATCHED AND
  bi.Quantity + bo.Quantity = 0 THEN
  DELETE
WHEN MATCHED THEN
  UPDATE
  SET bi.Quantity = bi.Quantity + bo.Quantity
WHEN NOT MATCHED BY TARGET THEN
  INSERT (TitleID, Title, Quantity)
  VALUES (bo.TitleID, bo.Title,bo.Quantity)
WHEN NOT MATCHED BY SOURCE
  AND bi.Quantity = 0 THEN
  DELETE
OUTPUT
    $action,
    DELETED.TitleID,
    INSERTED.TitleID,
    DELETED.Title,
    INSERTED.Title,
    DELETED.Quantity,
    INSERTED.Quantity
  INTO @MergeOutput;
 
SELECT * FROM BookInventory;
 
SELECT * FROM @MergeOutput;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ARCHIVE_Table____UpdateTrigger_CreateDateName_RowVersion</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ARCHIVE_Table____UpdateTrigger_CreateDateName_RowVersion</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--p_0048_CREATE__ARCHIVE_02_BHCS_EP.sql
/*
	************************************************************************************
	Use this Script to populate this Arcive: xxxx.sql
	use this table for Archiving 
				Input: 
					the aaa_yyyy_mm_dd_BHCS_AS tables
				INSERT_INTO:
					ARCHIVE_01_BHCS_AS
				
	Created: 1/30/2018
	By: glenn garson
	************************************************************************************
*/
USE [OBH_Data_Factory]
go

IF OBJECT_ID('dbo.ARCHIVE_01_BHCS_AS') IS NOT NULL
    DROP TABLE dbo.ARCHIVE_01_BHCS_AS

go

CREATE TABLE [dbo].[ARCHIVE_01_BHCS_AS](
	[ARCHIVE_01_PK] [int] IDENTITY(1,1) NOT NULL,
	---------------------------
	[ARRESTS] [float] NULL,
	[CP_ALCOHOL] [float] NULL,
	[CP_DRUGS] [float] NULL,
	...
	[DX_8] [nvarchar](255) NULL,
	----------------------------
	[fromTable] [nvarchar](255) NOT NULL,
	[CreateRecord_dateTime] [datetime] NULL,
	[CreateRecord_name] [sysname] NULL,
	[UpdateRecord_dateTime] [datetime] NULL,
	[UpdateRecord_name] [sysname] NULL,
	[ARCHIVE_01_RowVersion] [timestamp] NULL,
 CONSTRAINT [ARCHIVE_01_ALL_$_ARCHIVE_01_PK] PRIMARY KEY CLUSTERED 
(
	[ARCHIVE_01_PK] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
ALTER TABLE [dbo].[ARCHIVE_01_BHCS_AS] ADD  CONSTRAINT [df_ins_date]  DEFAULT (getdate()) FOR [CreateRecord_dateTime]
GO

ALTER TABLE [dbo].[ARCHIVE_01_BHCS_AS] ADD  CONSTRAINT [df_ins_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [CreateRecord_name]
GO

ALTER TABLE [dbo].[ARCHIVE_01_BHCS_AS] ADD  CONSTRAINT [df_upd_date]  DEFAULT (getdate()) FOR [UpdateRecord_dateTime]
GO

ALTER TABLE [dbo].[ARCHIVE_01_BHCS_AS] ADD  CONSTRAINT [df_upd_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [UpdateRecord_name]
GO

create trigger [dbo].[TRG_001_recordChanged_ARCHIVE_01] on [OBH_Data_Factory].[dbo].[ARCHIVE_01_BHCS_AS]
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       d.UpdateRecord_dateTime = getdate(),
       d.UpdateRecord_name = (coalesce(suser_sname(),'?'))
    from
       [OBH_Data_Factory].[dbo].ARCHIVE_01_BHCS_AS d join inserted i 
    on 
       d.ARCHIVE_01_PK = i.ARCHIVE_01_PK;

end

GO

ALTER TABLE [dbo].[ARCHIVE_01_BHCS_AS] ENABLE TRIGGER [TRG_001_recordChanged_ARCHIVE_01]
GO

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CHECK__WITH_CHECK__WITH_NOCHECK</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CHECK__WITH_CHECK__WITH_NOCHECK</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>CHECK__WITH_CHECK__WITH_NOCHECK


http://stackoverflow.com/questions/529941/with-check-add-constraint-followed-by-check-constraint-vs-add-constraint
--This syntax is generated by the SQL management studio when generating sql scripts -- I'm assuming it's some sort of extra redundancy, 
--possibly to ensure the constraint is enabled even if the default constraint behavior for a table is changed.

-- If you disable a constraint with ALTER TABLE foo NOCHECK CONSTRAINT fk_b 
--and then re-enable it with ALTER TABLE foo CHECK CONSTRAINT fk_b it doesn't verify the constraint. 
--ALTER TABLE foo WITH CHECK CHECK CONSTRAINT fk_b is necessary in order to have the data verified


CREATE TABLE T1 (ID INT NOT NULL, SomeVal CHAR(1));
ALTER TABLE T1 ADD CONSTRAINT [PK_ID] PRIMARY KEY CLUSTERED (ID);

CREATE TABLE T2 (FKID INT, SomeOtherVal CHAR(2));

INSERT T1 (ID, SomeVal) SELECT 1, 'A';
INSERT T1 (ID, SomeVal) SELECT 2, 'B';

INSERT T2 (FKID, SomeOtherVal) SELECT 1, 'A1';
INSERT T2 (FKID, SomeOtherVal) SELECT 1, 'A2';
INSERT T2 (FKID, SomeOtherVal) SELECT 2, 'B1';
INSERT T2 (FKID, SomeOtherVal) SELECT 2, 'B2';
INSERT T2 (FKID, SomeOtherVal) SELECT 3, 'C1';  --orphan
INSERT T2 (FKID, SomeOtherVal) SELECT 3, 'C2';  --orphan

--Add the FK CONSTRAINT will fail because of existing orphaned records
ALTER TABLE T2 ADD CONSTRAINT FK_T2_T1 FOREIGN KEY (FKID) REFERENCES T1 (ID);   --fails

--Same as ADD above, but explicitly states the intent to CHECK the FK values before creating the CONSTRAINT
ALTER TABLE T2 WITH CHECK ADD CONSTRAINT FK_T2_T1 FOREIGN KEY (FKID) REFERENCES T1 (ID);    --fails

--Add the CONSTRAINT without checking existing values
ALTER TABLE T2 WITH NOCHECK ADD CONSTRAINT FK_T2_T1 FOREIGN KEY (FKID) REFERENCES T1 (ID);  --succeeds
ALTER TABLE T2 CHECK CONSTRAINT FK_T2_T1;   --succeeds since the CONSTRAINT is attributed as NOCHECK

--Attempt to enable CONSTRAINT fails due to orphans
ALTER TABLE T2 WITH CHECK CHECK CONSTRAINT FK_T2_T1;    --fails

--Remove orphans
DELETE FROM T2 WHERE FKID NOT IN (SELECT ID FROM T1);

--Enabling the CONSTRAINT succeeds
ALTER TABLE T2 WITH CHECK CHECK CONSTRAINT FK_T2_T1;    --succeeds; orphans removed

--Clean up
DROP TABLE T2;
DROP TABLE T1;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CREATE_DELETE_with_UpdateCreateTriggers_ClusteredNonClustered_Indexes_CRESCENT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CREATE_DELETE_with_UpdateCreateTriggers_ClusteredNonClustered_Indexes_CRESCENT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>1] the CREATE TABLE script
2] the INSERT INTO script (below that)
--======================================

1] --=========================================================================================================CREATE TABLE 

USE [RiskMngt]
GO
--P_0020_TASK_013_CREATE_TABLE_T505_Collector_Queue_Mapping.sql

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

--IF OBJECT_ID('Reporting.T505_Collector_Queue_Mapping') IS NOT NULL
--    DROP TABLE Reporting.T505_Collector_Queue_Mapping

--go

CREATE TABLE [Reporting].[T505_Collector_Queue_Mapping](
	[T505_PK] [int] IDENTITY(1,1) NOT NULL,

	[month] [int] NULL,
	[queue] [int] NULL,
	[collector] [varchar](30) NULL,
	[shaw_id] [varchar](4) NULL,
	[shaw_name] [varchar](30) NULL,
	[supervisor] [varchar](30) NULL,
	[Active] BIT DEFAULT ((1)),
	[Date_Mapping_START] DATE NULL,
	[Date_Mapping_END] DATE NULL,
	-------------------------------------
	[CreateRecord_dateTime] [datetime]  NULL,
	[CreateRecord_name] [sysname] NULL,
	[UpdateRecord_dateTime] [datetime] NULL,
	[UpdateRecord_name] [sysname] NULL,
	[T505_RowVersion] [timestamp] NULL,
 CONSTRAINT [T505_Collector_Queue_Mapping_$_T505_PK] PRIMARY KEY CLUSTERED 
(
	[T505_PK] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO

------------------ Create Nonclustered Index (not Unique)
--CREATE NONCLUSTERED INDEX [IX_NonClustered_T505_shaw_id] ON [Reporting].[T505_Collector_Queue_Mapping]
--([shaw_id] ASC)
--GO
-----------------


ALTER TABLE [Reporting].[T505_Collector_Queue_Mapping] ADD  CONSTRAINT [T505_ins_date]  DEFAULT (getdate()) FOR [CreateRecord_dateTime]
GO

ALTER TABLE [Reporting].[T505_Collector_Queue_Mapping] ADD  CONSTRAINT [T505_ins_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [CreateRecord_name]
GO

ALTER TABLE [Reporting].[T505_Collector_Queue_Mapping] ADD  CONSTRAINT [T505_upd_date]  DEFAULT (getdate()) FOR [UpdateRecord_dateTime]
GO

ALTER TABLE [Reporting].[T505_Collector_Queue_Mapping] ADD  CONSTRAINT [T505_upd_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [UpdateRecord_name]
GO

create trigger [Reporting].[TRG_001_recordChanged_T505] on [RiskMngt].[Reporting].[T505_Collector_Queue_Mapping]
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       d.UpdateRecord_dateTime = getdate(),
       d.UpdateRecord_name = (coalesce(suser_sname(),'?'))
    from
       [RiskMngt].[Reporting].T505_Collector_Queue_Mapping d join inserted i 
    on 
       d.T505_PK = i.T505_PK;

end

GO

ALTER TABLE [Reporting].[T505_Collector_Queue_Mapping] ENABLE TRIGGER [TRG_001_recordChanged_T505]
GO

2] --=========================================================================================================INSERT INTO 

USE RiskMngt
go

--P_0020_TASK_013_MAINT_01_PopulateT505_v2.sql
--FROM:    P_0020_TASK_013_SQL_01_orig_Shantine_PART_2_A_v0.sql

--##################################
--##################################
--## START Part 2A
--##################################
--##################################


--This is the Queue Owners, and should be run after the Queue Re-assignments
--THIS MEANS: that if you try to analyze previous months, you will be using the wrong Queue assignments b/c they change around the 2nd business day of the month.

INSERT INTO [Reporting].[T505_Collector_Queue_Mapping](
	[month],
	[queue],
	[collector],
	[shaw_id],
	[shaw_name],
	[supervisor],
	[Active],
	[Date_Mapping_START],
	[Date_Mapping_END]
	)
select 
		year(getdate())*100+month(getdate()) as [month]
		, assigned_list as [queue]
		,collector_name as [collector]
		,collector_id as shaw_id
		, collector_name as [shaw_name]
		,supr_name as [supervisor]
		,1 as [Active]
		,GETDATE()as [Date_Mapping_START]
		,GETDATE() as [Date_Mapping_END]
--INTO	[Reporting].[T505_Collector_Queue_Mapping]	
from COLLECT_ETL.dbo.scfxroster
where left(assigned_list_desc,5) in ('30-59', '30- 5')
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CREATE_DELETE_with_UpdateCreateTriggers_notDBOschema_Crescent</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CREATE_DELETE_with_UpdateCreateTriggers_notDBOschema_Crescent</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--P_0028_TASK_003_CREATE_TABLE_T507_COLLECTOR_START_END_Date.sql

USE [RiskMngt]
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


IF OBJECT_ID('Reporting.T507_COLLECTOR_START_END_Date') IS NOT NULL  DROP TABLE Reporting.T507_COLLECTOR_START_END_Date
go

CREATE TABLE [Reporting].[T507_COLLECTOR_START_END_Date](
	[T507_PK] [int] IDENTITY(1,1) NOT NULL,
-------------------------------------------------------------
	[Collector_ShawID] [nvarchar](10) NULL,
	[Collector_Name] [nvarchar](255) NULL,
	[Supervisor_ShawID] [nvarchar](10) NULL,
	[Supervisor_Name] [nvarchar](255) NULL,
	[DepartmentManager_ShawID] [nvarchar](10) NULL,
	[DepartmentManager_Name] [nvarchar](255) NULL,
	[Start_Date] [date] NOT NULL CONSTRAINT T507_StartDate_Default_GETDATE DEFAULT DATEADD(dd, DATEDIFF(dd,0,GETDATE()), 0),	--default to today
	[End_Date] [date] NOT NULL CONSTRAINT T507_EndDate_Default_9999 DEFAULT '12-31-9999',	--default to 12/31/9999
	[T508_WorkGroup_FK] [int] NULL,
-------------------------------------------------------------
	[CreateRecord_dateTime] [datetime] NULL,
	[CreateRecord_name] [sysname] NULL,
	[UpdateRecord_dateTime] [datetime] NULL,
	[UpdateRecord_name] [sysname] NULL,
	[T507_RowVersion] [timestamp] NOT NULL,                             --&lt;==== this might need to be NOT NULL
 CONSTRAINT [T507_COLLECTOR_START_END_Date_$_T507_PK] PRIMARY KEY CLUSTERED 
(
	[T507_PK] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO


ALTER TABLE [Reporting].[T507_COLLECTOR_START_END_Date] ADD  CONSTRAINT [T507_df_ins_date]  DEFAULT (getdate()) FOR [CreateRecord_dateTime]
GO

ALTER TABLE [Reporting].[T507_COLLECTOR_START_END_Date] ADD  CONSTRAINT [T507_df_ins_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [CreateRecord_name]
GO

ALTER TABLE [Reporting].[T507_COLLECTOR_START_END_Date] ADD  CONSTRAINT [T507_df_upd_date]  DEFAULT (getdate()) FOR [UpdateRecord_dateTime]
GO

ALTER TABLE [Reporting].[T507_COLLECTOR_START_END_Date] ADD  CONSTRAINT [T507_df_upd_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [UpdateRecord_name]
GO

create trigger [Reporting].[TRG_001_recordChanged_T507] on [RiskMngt].[Reporting].[T507_COLLECTOR_START_END_Date]
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       d.UpdateRecord_dateTime = getdate(),
       d.UpdateRecord_name = (coalesce(suser_sname(),'?'))
    from
       [RiskMngt].[Reporting].T507_COLLECTOR_START_END_Date d join inserted i 
    on 
       d.T507_PK = i.T507_PK;

end

GO

ALTER TABLE [Reporting].[T507_COLLECTOR_START_END_Date] ENABLE TRIGGER TRG_001_recordChanged_T507
GO

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CREATE_Table_and_UpdateCreateTrigger_and_RowVersion</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CREATE_Table_and_UpdateCreateTrigger_and_RowVersion</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--CREATE_TABLE_T600_QA_Parms.sql


USE [RiskMngt]
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TABLE [Reporting].[T600_QA_Parms](
    [T600_Parms_PK] [int] IDENTITY(1,1) NOT NULL,
	----------------------------------------------
	[Parm_Name] [nvarchar](255) NULL,
	[Parm_Description] [nvarchar](255) NULL,
	[Parm_INT] [int] NULL,
	[Parm_FLOAT] [float] NULL,
	[Parm_NVARCHAR] [nvarchar](255) NULL,
	[Parm_DATE] date NULL,
	[Parm_DATETIME] datetime NULL,
	[Notes] [nvarchar](255) NULL,
	-----------------------------------------------
	[CreateRecord_dateTime] [datetime] NULL,
	[CreateRecord_name] [sysname] NULL,
	[UpdateRecord_dateTime] [datetime] NULL,
	[UpdateRecord_name] [sysname] NULL,
	[T600_RowVersion] [timestamp] NULL,                          
 CONSTRAINT [T600_QA_Parms_$_T600_Parms_PK] PRIMARY KEY CLUSTERED 
(
	[T600_Parms_PK] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO


ALTER TABLE [Reporting].[T600_QA_Parms] ADD  CONSTRAINT [T600_df_ins_date]  DEFAULT (getdate()) FOR [CreateRecord_dateTime]
GO

ALTER TABLE [Reporting].[T600_QA_Parms] ADD  CONSTRAINT [T600_df_ins_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [CreateRecord_name]
GO

ALTER TABLE [Reporting].[T600_QA_Parms] ADD  CONSTRAINT [T600_df_upd_date]  DEFAULT (getdate()) FOR [UpdateRecord_dateTime]
GO

ALTER TABLE [Reporting].[T600_QA_Parms] ADD  CONSTRAINT [T600_df_upd_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [UpdateRecord_name]
GO

create trigger [Reporting].[TRG_001_recordChanged_T600] on [RiskMngt].[Reporting].[T600_QA_Parms]
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       d.UpdateRecord_dateTime = getdate(),
       d.UpdateRecord_name = (coalesce(suser_sname(),'?'))
    from
       [RiskMngt].[Reporting].T600_QA_Parms d join inserted i 
    on 
       d.T600_Parms_PK = i.T600_Parms_PK;

end

GO

ALTER TABLE [Reporting].[T600_QA_Parms] ENABLE TRIGGER [TRG_001_recordChanged_T600]
GO

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CREATE_TABLE_Computed_Column__persisted</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CREATE_TABLE_Computed_Column__persisted</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--CREATE_TABLE_Computed_Column__persisted


CREATE TABLE [dbo].[T003_All_Monthly_Billable_Services_IDR]
(
		[T003_PK] [int] IDENTITY(1,1) NOT NULL,

		[CHECKMONTH] [nvarchar](25) NULL,
		[LOCation] AS 
							CASE 
								WHEN [Office Location]  = 'WB JeffCare'
										THEN 'WJ' 
								WHEN [Office Location]  = 'EB JeffCare'
										THEN 'EJ' 
								ELSE ''
							END	PERSISTED,
		[T003_RowVersion] [timestamp] NULL
	,CONSTRAINT [T003_All_Monthly_Billable_Services_IDR$T003_PK] PRIMARY KEY NONCLUSTERED 
		(
			[T003_PK] ASC
		)
		WITH 
				(
					PAD_INDEX  = OFF, 
					STATISTICS_NORECOMPUTE  = OFF, 
					IGNORE_DUP_KEY = OFF, 
					ALLOW_ROW_LOCKS  = ON, 
					ALLOW_PAGE_LOCKS  = ON
				) ON [PRIMARY]
--===========================================================
--https://www.mssqltips.com/sqlservertip/2481/getting-creative-with-computed-columns-in-sql-server/
-- Script# 1: Computed column with conditional formula
-- Use sample database
USE [AdventureWorks]
GO 
 
-- Create Table with computed column
IF OBJECT_ID('CCtest', 'U') IS NOT NULL
  DROP TABLE [dbo].[CCtest]
GO
 
CREATE TABLE [dbo].[CCtest]
  (
  [EmpNumb] INT NOT NULL,
  [Designation] VARCHAR(50) NOT NULL,
  [DOBirth] DATETIME NOT NULL,
  [DORetirement] AS 
    CASE WHEN designation = 'Manager' 
      THEN (DATEADD(YEAR,(65),[DOBirth]))
      ELSE (DATEADD(YEAR,(60),[DOBirth]))
    END
)
GO
 
--Insert sample data 
INSERT INTO CCTest (empNumb, Designation, DOBirth) 
SELECT 84, 'DBA', '1985-12-13' UNION ALL
SELECT 85, 'DBA', '1980-11-18' UNION ALL
SELECT 86, 'Manager', '1978-01-19' UNION ALL
SELECT 88, 'Manager', '1985-12-13' UNION ALL
SELECT 90, 'Developer', '1975-07-23' 
GO
 
-- Check the required functionality in result
SELECT Designation, datediff(yy,dobirth,doretirement ) AgeLimit, DOBirth, DORetirement 
FROM CCTest
GO

--===========================================================
--Creating a computed column based on a user-defined type column  

  CREATE TABLE UDTypeTable   
    ( 
    	u utf8string, 
    	ustr AS u.ToString() PERSISTED 
    ) ; 
--===========================================================
--http://stackoverflow.com/questions/711159/how-to-set-a-default-value-for-one-column-in-sql-based-on-another-column	
--If what you are looking for is to define a column definition based on another column you can do something like this:

create table testable 
(
    c1 int, 
    c2 datetime default getdate(), 
    c3 as year(c2)
);

insert into testable (c1) select 1

select * from testable;
--===========================================================


--Using an expression for a computed column

CREATE TABLE dbo.mytable   
    ( 
    	low int, 
    	high int, 
    	myavg AS (low + high)/2 
    ) ;  
    
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CREATE_TempTable_From_simulated_Data_with_fields_calculated_from_a_single_date_field</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CREATE_TempTable_From_simulated_Data_with_fields_calculated_from_a_single_date_field</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--xxx.sql

/*
	************************************************************************************
	NOTE: from: https://www.mssqltips.com/sqlservertip/4054/creating-a-date-dimension-or-calendar-table-in-sql-server/
	Uses: 
	Created: 10/12/2016
	By: glenn garson
	************************************************************************************
*/

use B2W_Reports
go

DECLARE @StartDate DATE = '20100101', @NumberOfYears INT = 2;

-- prevent set or regional settings from interfering with 
-- interpretation of dates / literals

SET DATEFIRST 1;			-- Set first day of week to Monday(1) 
SET DATEFORMAT mdy;			--Sets the order of the month, day, and year date parts for interpreting date, smalldatetime, datetime, datetime2 and datetimeoffset character strings
							--  this means that you need to enter the data parms as mm/dd/yyyy
SET LANGUAGE US_ENGLISH;

DECLARE @CutoffDate DATE = DATEADD(YEAR, @NumberOfYears, @StartDate);

-- this is just a holding table for intermediate calculations:

CREATE TABLE #dim    --&lt;========================================   All the fields besides the [date] are calculated from [date],  
(					 --												which comes from the SELECT statement in the INSERT statement below
  [date]       DATE PRIMARY KEY, 
  [day]        AS DATEPART(DAY,      [date]),
  [month]      AS DATEPART(MONTH,    [date]),
  FirstDayOfWeek AS CONVERT(DATE, DATEADD(WEEK, DATEDIFF(wk, 0, [date]), 0)), 
  FirstOfMonth AS CONVERT(DATE, DATEADD(MONTH, DATEDIFF(MONTH, 0, [date]), 0)),
  [MonthName]  AS DATENAME(MONTH,    [date]),
  [week]       AS DATEPART(WEEK,     [date]),
  [ISOweek]    AS DATEPART(ISO_WEEK, [date]),
  [DayOfWeek]  AS DATEPART(WEEKDAY,  [date]),
  [quarter]    AS DATEPART(QUARTER,  [date]),
  [year]       AS DATEPART(YEAR,     [date]),
  FirstOfYear  AS CONVERT(DATE, DATEADD(YEAR,  DATEDIFF(YEAR,  0, [date]), 0)),
  YYYYMMDD     AS CONVERT(CHAR(8),   [date], 112),
  MM_slash_DD_slash_YYYY     AS CONVERT(CHAR(10),  [date], 101),
  MM_hyphen_DD_hyphen_YYYY     AS CONVERT(CHAR(10),  [date], 110) 
);

-- use the catalog views to generate as many rows as we need

INSERT #dim([date]) 
SELECT d
FROM
(
  SELECT d = DATEADD(DAY, rn - 1, @StartDate)                  --&lt;========  The empty record is created in the FROM statement w/ just the rn (i.e. row number)
  FROM 
  (
    SELECT TOP (DATEDIFF(DAY, @StartDate, @CutoffDate)) 
      rn = ROW_NUMBER() OVER (ORDER BY s1.[object_id])          --&lt;========  This field is not in the output (i.e. not in #dim)
    FROM sys.all_objects AS s1	                                --&lt;========  Not sure why this here, I think it just servers as a place holder trick while 
    CROSS JOIN sys.all_objects AS s2							--&lt;========    it creates the records
    -- on my system this would support &gt; 5 million days
    ORDER BY s1.[object_id]
  ) AS x
) AS y;


Select * from #dim</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CreateTargetTableWithPKandRowVersion_FromUploadedTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CreateTargetTableWithPKandRowVersion_FromUploadedTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- prj_8010_001_Add_PrimaryKey_RowVersion_Create_T010_Current_Case_Manager_Status_t.sql
-----------------
-- BASICALLY This script Takes a table that was created when I uploaded data from Access (i.e. [0_RawData])
--		and Creates a New Table ( i.e. [T010_Current_Case_Manager_Status_t]) with a PK, 
--		and Rowversion and populates the [Date_Uploaded] field
-----------------
-- USES a Transaction to make sure that all the steps work successfully

-- This will Use the table: 0_RawData, created by Access Pgm: prj_8010_acc_01_v0.accdb
-- b/c originally when it was uploaded
-- The table did not have a primary Key, nor RowVersion field 
-- It uses a TRANSACTION to make sure that it does not delete the original table unless there were no errors

-- In this case I will populate the field [Date_Uploaded] with the day that I run this

--
-- glenn garson 1/12/2012
--=========================================================================
USE [DB1_Main]
go


BEGIN TRANSACTION  MoveDataAddPKandRowVersion

		--=========================================================================
		-- 1] Create the New Target Table to hold the data.
		--		In addition, give it a PK and Row Version Field
		--=========================================================================

		IF OBJECT_ID('dbo.T010_Current_Case_Manager_Status_t') IS NOT NULL
			DROP TABLE dbo.T010_Current_Case_Manager_Status_t

		SET QUOTED_IDENTIFIER ON
		GO

		SET ANSI_PADDING ON
		GO

		CREATE TABLE [dbo].[T010_Current_Case_Manager_Status_t](
			[T010_PK] [int] IDENTITY(1,1) NOT NULL,
			[Practice_Number] [nvarchar](10) NULL,
			[Practice_Name] [nvarchar](100) NULL,
			[Practice_County] [nvarchar](30) NULL,
			[Medicaid_ID] [nvarchar](15) NULL,
			[Full_Name] [nvarchar](150) NULL,
			[Date_of_Birth] [date] NULL,
			[Age] [smallint] NULL,
			[Dual] [bit] NULL,
			[ABD] [bit] NULL,
			[Case_Manager_Full_Name] [nvarchar](150) NULL,
			[Case_Management_Status] [nvarchar](15) NULL,
			[Deferral_Reason] [nvarchar](150) NULL,
			[Last_Task_Complete_Date] [date] NULL,
			[Last_CHA_Assessment_Date] [date] NULL,
			[Date_Uploaded] [DATE] NULL,                          --  &lt;======================  Make sure to populate when loading data
			[T010_RowVersion] [rowversion],

		 CONSTRAINT [T010_Current_Case_Manager_Status_t$T010_PK] PRIMARY KEY CLUSTERED 
		(
			[T010_PK] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
		) ON [PRIMARY]

		GO

		SET ANSI_PADDING OFF
		GO

		-- ================================================================
		-- Check for errors
		--
		IF @@ERROR &lt;&gt; 0
				BEGIN
				--
				-- Rollback the transaction
				--
				ROLLBACK TRANSACTION  MoveDataAddPKandRowVersion
				PRINT '1]	ERROR DURING: delete/Create of New Target Table. Transaction was not completed'
				END
			ELSE
				BEGIN
				PRINT '1]	SUCCESS DURING: delete/Create of New Target Table.'
				END
			
		--
		-- 
		-- ================================================================



		--=========================================================================
		-- 2] Move the data from 0_RawData into the New Target Table: T010
		--=========================================================================



		INSERT INTO [T010_Current_Case_Manager_Status_t] 
			(

				[Practice_Number] ,
				[Practice_Name] ,
				[Practice_County] ,
				[Medicaid_ID] ,
				[Full_Name] ,
				[Date_of_Birth] ,
				[Age] ,
				[Dual] ,
				[ABD] ,
				[Case_Manager_Full_Name] ,
				[Case_Management_Status] ,
				[Deferral_Reason] ,
				[Last_Task_Complete_Date] ,
				[Last_CHA_Assessment_Date] ,
				[Date_Uploaded]                           --  &lt;======================  Make sure to populate when loading data

			)
		SELECT 
				[Practice_Number] ,
				[Practice_Name] ,
				[Practice_County] ,
				[Medicaid_ID] ,
				[Full_Name] ,
				[Date_of_Birth] ,
				[Age] ,
				[Dual] ,
				[ABD] ,
				[Case_Manager_Full_Name] ,
				[Case_Management_Status] ,
				[Deferral_Reason] ,
				[Last_Task_Complete_Date] ,
				[Last_CHA_Assessment_Date] ,
				GETDATE() As [Date_Uploaded]                           --  &lt;======================  Make sure to populate when loading data

		FROM [0_RawData]

		go

		-- ================================================================
		-- Check for errors
		--
		IF @@ERROR &lt;&gt; 0
				BEGIN
				--
				-- Rollback the transaction
				--
				ROLLBACK TRANSACTION  MoveDataAddPKandRowVersion
				PRINT '2]	ERROR DURING:  INSERT INTO New Target Table. Transaction was not completed'
				END
			ELSE
				BEGIN
				PRINT '2]	SUCCESS DURING: delete/Create of New Target Table.'
				END
			
		--
		-- 
		-- ================================================================

		

COMMIT TRANSACTION  MoveDataAddPKandRowVersion</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>DELETE_CASCADE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>DELETE_CASCADE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--http://www.mssqltips.com/sqlservertip/2743/using-delete-cascade-option-for-foreign-keys/
/*

1] The 'FOREIGN KEY' constraint, with the 'DELETE CASCADE' clause, goes on the child/detail table
2] Then when you delete a Parent/Header record the children are deleted
3] It is a best practice to 'CREATE NONCLUSTERED INDEX' on the foreign key record in the child table


For this example we will create two sample tables that have a foreign key relationship between them. 
The parent table has 99,999 records in it 
and the corresponding child table has 19 records for each record in the parent. 
Here is the DDL code:
*/

- Table creation logic
--parent table
CREATE TABLE [dbo].[Order](
 [OrderID] [bigint] NOT NULL,
 [OrderData] [varchar](10) NOT NULL,
 CONSTRAINT [PK_Order_1] PRIMARY KEY CLUSTERED 
    ([OrderID] ASC)
)
GO
-- child table
CREATE TABLE [dbo].[OrderDetail](
 [OrderDetailID] [bigint] NOT NULL,
 [OrderID] [bigint] NULL,
 [OrderData] [varchar](10) NULL,
 CONSTRAINT [PK_OrderDetail] PRIMARY KEY CLUSTERED 
    ([OrderDetailID] ASC)
)
GO
-- foreign key constraint
ALTER TABLE [dbo].[OrderDetail]  WITH CHECK 
ADD CONSTRAINT [FK_OrderDetail_Order] FOREIGN KEY([OrderID])
REFERENCES [dbo].[Order] ([OrderID])
ON DELETE CASCADE						--&lt;=====  here is the Delete Cascade on the detail/child table
GO
-- data load
DECLARE @val BIGINT
DECLARE @val2 BIGINT
SELECT @val=1
WHILE @val &lt; 100000
BEGIN  
   INSERT INTO dbo.[Order] VALUES(@val,'TEST' + CAST(@val AS VARCHAR))
   
   SELECT @val2=1
   WHILE @val2 &lt; 20
   BEGIN  
      INSERT INTO dbo.[OrderDetail] VALUES ((@val*100000)+@val2,@val,'TEST' + CAST(@val AS VARCHAR))
      SELECT @val2=@val2+1
   END
   SELECT @val=@val+1
     
END
GO 

--let's remove a record from the [Order] table. i.e. from the parent/header table

DELETE FROM [Order] WHERE OrderID=24433
GO


--If you did not have the DELETE CASCADE in the detail/child table then you could do this
ALTER TABLE [dbo].[OrderDetail] DROP CONSTRAINT [FK_OrderDetail_Order]	--&lt;==== here it is dropping the original contraint, from above
GO
ALTER TABLE [dbo].[OrderDetail]  WITH CHECK 
ADD CONSTRAINT [FK_OrderDetail_Order] FOREIGN KEY([OrderID])	--&lt;== Then just adding back a foreign key constraint withOUT a DELETE CASCADE
REFERENCES [dbo].[Order] ([OrderID])
GO


--now to achieve the same affet you would have to do this, NOTE you have to delete from the child/detail table first b/c of the Foreign key constraint:
GO
DELETE FROM [OrderDetail] WHERE OrderID=24032
DELETE FROM [Order] WHERE OrderID=24032
GO


/*One of the SQL Server best practices I follow is to always index any foreign key columns 
	as they are always very heavily used both in WHERE clauses and to join tables. 
	
	i.e. index the foreign key column in the detail/child table
*/

CREATE NONCLUSTERED INDEX IX_OrderDetail_OrderID ON dbo.[OrderDetail] (OrderID)
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Identity(1,1)_CopyDataToAnotherTable_retainIdentityDataInNewTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Identity(1,1)_CopyDataToAnotherTable_retainIdentityDataInNewTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
/*
You can't alter the existing columns for identity.

 

You have 2 options,

1. Create a new table with identity &amp; drop the existing table

2. Create a new column with identity &amp; drop the existing column

 

But take spl care when these columns have any constraints / relations.

*/
            For already craeted table Names
            Drop table Names
            Create table Names
            (
                        ID int,
                        Name varchar(50)
            )
 
            Insert Into Names Values(1,'SQL Server')
            Insert Into Names Values(2,'ASP.NET')
            Insert Into Names Values(4,'C#')
/*

Code Snippet
--In this Approach you can retain the existing data values on the newly created identity column
*/
CREATE TABLE dbo.Tmp_Names
            (
            Id int NOT NULL IDENTITY (1, 1),
            Name varchar(50) NULL
            )  ON [PRIMARY]
 
go
SET IDENTITY_INSERT dbo.Tmp_Names ON
 
go
IF EXISTS(SELECT * FROM dbo.Names)
            INSERT INTO dbo.Tmp_Names (Id, Name)
                        SELECT Id, Name FROM dbo.Names TABLOCKX
 
go
SET IDENTITY_INSERT dbo.Tmp_Names OFF
 
go
DROP TABLE dbo.Names</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Identity_Property_REMOVE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Identity_Property_REMOVE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

	
--You should first set it to ON, and in the end to OFF. 
--With ON it signalizes that you are about to do manual inserts on identity column

SET IDENTITY_INSERT [TABLE] ON
--And then back on:

SET IDENTITY_INSERT [TABLE] OFF
--This will allow you to enter manual data in the identity column.



====================================================================

The easiest way would be:

Open SQL Server Management Studio.
Locate Server &gt; DataBase &gt; Table.
Right Click on the Table &gt; Select Design.
In the design window, Highlight the column you want to modify.
In the Column Properties Window browse to Identity Specification &gt; Is Identity And set to No.
Go to the toolbar menu &gt; Table Designer &gt; Select Generate Change Script...
Walla, you got the requested script.


====================================================================
/*
If you need to keep the data in that column then create a new column on the table which is of the same type (but a different name),
 copy the data from the column you want to get rid of to the new one,
  drop the old column and rename the new. Complete example:
  */

CREATE TABLE test(col1 INT IDENTITY (1,1) NOT NULL, col2 VARCHAR(10) NULL);

ALTER TABLE test ADD col3 INT NULL;

UPDATE test SET col3 = col1;

ALTER TABLE test DROP COLUMN col1;

EXEC sp_rename 'dbo.test.col3', 'col1', 'COLUMN';

=====================================================================

--Make a new column

alter table users add newusernum int;

--Copy values over

update users set newusernum=usernum;

--Drop the old column

alter table users drop column usernum;

--Rename the new column to the old column name

EXEC sp_RENAME 'users.newusernum' , 'usernum', 'COLUMN';</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Identity_removeProperty_butKeepTheData</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Identity_removeProperty_butKeepTheData</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--[1]========================================================================

--The new column did not create a new auto-increment field, rather the old field was still auto-increment
BEGIN TRAN
BEGIN TRY
    EXEC sp_rename '[SomeTable].[Id]', 'OldId';

    ALTER TABLE [SomeTable] ADD Id int NULL

    EXEC ('UPDATE [SomeTable] SET Id = OldId')

    ALTER TABLE [SomeTable] NOCHECK CONSTRAINT ALL

    ALTER TABLE [SomeTable] DROP CONSTRAINT [PK_constraintName];
    ALTER TABLE [SomeTable] DROP COLUMN OldId
    ALTER TABLE [SomeTable] ALTER COLUMN [Id] INTEGER NOT NULL
    ALTER TABLE [SomeTable] ADD CONSTRAINT PK_JobInfo PRIMARY KEY (Id)

    ALTER TABLE [SomeTable] CHECK CONSTRAINT ALL

    COMMIT TRAN
END TRY
BEGIN CATCH
    ROLLBACK TRAN   
    SELECT ERROR_MESSAGE ()
END CATCH


--[1]========================================================================
/*
DID NOT TRY THIS YET

Remove all foreign keys that point to this table
Script the table to be created; rename everything e.g. 'MyTable2', 'MyIndex2', etc. Remove the IDENTITY specification.
You should now have two "identical"-ish tables, one full, the other empty with no IDENTITY.
Run ALTER TABLE [Original] SWITCH TO [Original2]
Now your original table will be empty and the new one will have the data. You have switched the metadata for the two tables (instant).
Drop the original (now-empty table), exec sys.sp_rename to rename the various schema objects back to the original names, and then you can recreate your foreign keys.
*/

--For example, given:

CREATE TABLE Original
(
  Id INT IDENTITY PRIMARY KEY
, Value NVARCHAR(300)
);
CREATE NONCLUSTERED INDEX IX_Original_Value ON Original (Value);

INSERT INTO Original
SELECT 'abcd'
UNION ALL 
SELECT 'defg';
--You can do the following:

--create new table with no IDENTITY
CREATE TABLE Original2
(
  Id INT PRIMARY KEY
, Value NVARCHAR(300)
);
CREATE NONCLUSTERED INDEX IX_Original_Value2 ON Original2 (Value);

--data before switch
SELECT 'Original', *
FROM Original
UNION ALL
SELECT 'Original2', *
FROM Original2;

ALTER TABLE Original SWITCH TO Original2;		--&lt;=== NOTE this is for "partitioned" data tables ??????

--data after switch
SELECT 'Original', *
FROM Original
UNION ALL
SELECT 'Original2', *
FROM Original2;

--clean up
DROP TABLE Original;
EXEC sys.sp_rename 'Original2.IX_Original_Value2', 'IX_Original_Value', 'INDEX';
EXEC sys.sp_rename 'Original2', 'Original', 'OBJECT';


UPDATE Original
SET Id = Id + 1;

SELECT *
FROM Original;</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSERT_INTO</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSERT_INTO</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>INSERT INTO

----------------------------
SET IDENTITY_INSERT T14_NON_PCP_Institution ON
GO

INSERT INTO T1_Practice_TEMP ( 												--&lt;== Already existing table
								T14_PK, 
								NON_PCP_NameOfInstitution 
							  )
SELECT 
		T14_NON_PCP_Institution_ORIG.T14_PK, 
		T14_NON_PCP_Institution_ORIG.NON_PCP_NameOfInstitution
		
FROM T14_NON_PCP_Institution_ORIG;

SET IDENTITY_INSERT T14_NON_PCP_Institution off
GO
--------------------------
-- This worked cross DataBase:

use DB2_CRM
go


INSERT INTO [DB4_DocumentManagement].dbo.[T03_Header_PracticeDocuments] ( 			--&lt;== Already existing table
								DB2_T1_FK 
							  )
SELECT [T1_PK]
		
FROM [DB2_CRM].dbo.[T1_Practice];

--------------------------

INSERT INTO "table1" ("column1", "column2", ...)
SELECT "column3", "column4", ...
FROM "table2"


------

INSERT INTO Store_Information (store_name, Sales, Date)							--&lt;== Already existing table
SELECT store_name, Sales, Date
FROM Sales_Information
WHERE Year(Date) = 1998



------

INSERT INTO table																--&lt;== Already existing table
(column-1, column-2, ... column-n)
VALUES
(value-1, value-2, ... value-n);

//////////////////////////////////////

--prj_1027_403_InsertInto_EnumNameSpace_forAllocationTable.sql

use DB2_CRM
go

INSERT INTO [DB2_CRM].[dbo].[EnumNameSpace]
           (
				[EnumNameSpace]
				,[Notes]
			)
     VALUES
           ('Accounting_Effective_Change_e28','Hire, Terminate, Position_Change, Opening')
           ,('Accounting_ParentGroup_e29', 'Care_Managment, Support_Staff, Program_Coordination, Administration, Admin_Support_Staff, ADMIN_ASSIST/PHARM_TECH, Pharmacy, QI/Data, Contract Positions ')
           ,('Accounting_ChildGroup_e30', 'Care_Managers, Team_Leaders, Support_Staff, Program_Coordination, Administration, Admin_Support_Staff, ADMIN_ASSIST/PHARM_TECH, Pharmacy, QI/Data, Contract Positions ')

GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>LNK_LINK___bridgeTable_junctionTable_ManyToMany</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>LNK_LINK___bridgeTable_junctionTable_ManyToMany</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--LNK_LINK___bridgeTable_junctionTable_ManyToMany

1] LINK Table:  LNK01_T000_T004
2] T000
3] T004

USE [RiskMngt]
GO
--p_0015_CREATE_TABLE_LNK01_T000_T004__Tasks_v1.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 05/09/2017
	By: glenn garson
	************************************************************************************
*/



SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF OBJECT_ID('Reporting.LNK01_T000_T004') IS NOT NULL
    DROP TABLE Reporting.LNK01_T000_T004

go

CREATE TABLE [Reporting].[LNK01_T000_T004]
(
		[LNK01_PK] [int] IDENTITY(1,1) NOT NULL,		--You must specify both the seed and increment or neither. If neither is specified, the default is (1,1).
		[T000_FK] [int] NULL,
		[T004_FK] [int] NULL,
		[LNK01_T000_T004_RowVersion] [timestamp] NULL
	,CONSTRAINT [LNK01_T000_T004$LNK01_PK] PRIMARY KEY NONCLUSTERED 
		(
			[LNK01_PK] ASC
		)
		WITH 
				(
					PAD_INDEX  = OFF, 
					STATISTICS_NORECOMPUTE  = OFF, 
					IGNORE_DUP_KEY = OFF, 
					ALLOW_ROW_LOCKS  = ON, 
					ALLOW_PAGE_LOCKS  = ON
				) ON [PRIMARY]
	--,CONSTRAINT LNK01_T000_T004$T000_FK FOREIGN KEY (T000_FK) 
	--	REFERENCES  [Reporting].[T000_Projects] ([T000_PK])
	--	ON DELETE CASCADE
	--	ON UPDATE CASCADE
)

GO
ALTER TABLE [Reporting].[LNK01_T000_T004] 
ADD CONSTRAINT LNK01_T000_T004$T000_FK FOREIGN KEY (T000_FK) 
    REFERENCES [Reporting].[T000_Projects] ([T000_Projects_PK])
    ON DELETE CASCADE
    ON UPDATE CASCADE
;
GO

--ALTER TABLE [Reporting].[LNK01_T000_T004] DROP CONSTRAINT LNK01_T000_T004$T000_FK 

ALTER TABLE [Reporting].[LNK01_T000_T004] 
ADD CONSTRAINT LNK01_T000_T004$T004_FK FOREIGN KEY (T004_FK) 
    REFERENCES [Reporting].[T004_Tasks] ([T004_Tasks_PK])
    ON DELETE CASCADE
    ON UPDATE CASCADE
;
GO

--ALTER TABLE [Reporting].[LNK01_T000_T004] DROP CONSTRAINT LNK01_T000_T004$T004_FK 

ALTER TABLE [Reporting].[LNK01_T000_T004] 
  ADD CONSTRAINT LNK01_UniqueCodes_T000_T004 UNIQUE ([T000_FK], [T004_FK])

--ALTER TABLE [Reporting].[LNK01_T000_T004] DROP CONSTRAINT LNK01_UniqueCodes_T000_T004 


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

USE [RiskMngt]
GO
--p_0015_CREATE_TABLE_T000_Projects_v1.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 1/11/2019
	By: glenn garson
	************************************************************************************
*/
--use JUNK


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF OBJECT_ID('Reporting.T000_Projects') IS NOT NULL
    DROP TABLE Reporting.T000_Projects

go

CREATE TABLE [Reporting].[T000_Projects](

			[T000_Projects_PK] [int] IDENTITY(1,1) NOT NULL,
			[Description] [nvarchar](max) NULL,
			[ProjectName] [nvarchar](255) NULL,
			CreateRecord_dateTime datetime,
			CreateRecord_name sysname,
			UpdateRecord_dateTime datetime,
			UpdateRecord_name sysname,
		
			--[DateTime_RecordCreated] [datetime] NOT NULL CONSTRAINT T000_TheDateTime_Default_GETDATE DEFAULT GETDATE(),

			[T000_RowVersion] [timestamp] NULL,
			CONSTRAINT [T000_Projects$T000_PK] PRIMARY KEY NONCLUSTERED 
				(
					[T000_Projects_PK] ASC
				)
				WITH 
						(
							PAD_INDEX  = OFF, 
							STATISTICS_NORECOMPUTE  = OFF, 
							IGNORE_DUP_KEY = OFF, 
							ALLOW_ROW_LOCKS  = ON, 
							ALLOW_PAGE_LOCKS  = ON
						) ON [PRIMARY]
		) ON [PRIMARY]
		GO

		SET ANSI_PADDING OFF
		GO


-- insert/update dates
alter table [Reporting].[T000_Projects]
    add constraint [T000_CreateRecord_dateTime] default (getdate()) for CreateRecord_dateTime;
alter table [Reporting].[T000_Projects]
    add constraint [T000_UpdateRecord_dateTime] default (getdate()) for UpdateRecord_dateTime;

-- insert/update names
alter table [Reporting].[T000_Projects]
    add constraint [T000_CreateRecord_name] default (coalesce(suser_sname(),'?')) for CreateRecord_name;

alter table [Reporting].[T000_Projects]
    add constraint [T000_UpdateRecord_name] default (coalesce(suser_sname(),'?')) for UpdateRecord_name;
go

--For updates, but the inserted and deleted tables exist. I choose to join on the inserted for the update.

-- create the update trigger
create trigger TRG_001_recordChanged_T000 on Reporting.T000_Projects
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       UpdateRecord_dateTime = getdate(),
       UpdateRecord_name = (coalesce(suser_sname(),'?'))
    from
       T000_Projects d join inserted i 
    on 
       d.T000_Projects_PK = i.T000_Projects_PK;

end
go
--added constraint on 5/26/2017
ALTER TABLE [Reporting].[T000_Projects]
  ADD CONSTRAINT uniqueValues$ProjectName UNIQUE NONCLUSTERED (ProjectName)

	go		



\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

USE [RiskMngt]
GO
--p_0015_CREATE_TABLE_T004_Tasks_v1.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 05/09/2017
	By: glenn garson
	************************************************************************************
*/
--use JUNK


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF OBJECT_ID('Reporting.T004_Tasks') IS NOT NULL
    DROP TABLE Reporting.T004_Tasks

go

CREATE TABLE [Reporting].[T004_Tasks](

			[T004_Tasks_PK] [int] IDENTITY(1,1) NOT NULL,
			[T000_Projects_FK] [int] NULL,


			[T003_RequestedBy_FK] [int] NULL,
			--[RequestedBy] [nvarchar](255) NULL,
			[Requested_DateTime] datetime NULL,
			[Requested_Notes] [nvarchar](max) NULL,
			[Requirements] [nvarchar](max) NULL,
			[Description] [nvarchar](max) NULL,



			[TaskName] [nvarchar](255) NULL,

			[TaskStatus_T101_e2] int NOT NULL  CONSTRAINT ReportStatus_T101_e2_Default_ZERO DEFAULT(0),

			CreateRecord_dateTime datetime,
			CreateRecord_name sysname,
			UpdateRecord_dateTime datetime,
			UpdateRecord_name sysname,
		
			--[DateTime_RecordCreated] [datetime] NOT NULL CONSTRAINT T004_TheDateTime_Default_GETDATE DEFAULT GETDATE(),

			[T004_RowVersion] [timestamp] NULL,
			CONSTRAINT [T004_Tasks$T004_PK] PRIMARY KEY NONCLUSTERED 
				(
					[T004_Tasks_PK] ASC
				)
				WITH 
						(
							PAD_INDEX  = OFF, 
							STATISTICS_NORECOMPUTE  = OFF, 
							IGNORE_DUP_KEY = OFF, 
							ALLOW_ROW_LOCKS  = ON, 
							ALLOW_PAGE_LOCKS  = ON
						) ON [PRIMARY]
		) ON [PRIMARY]
		GO

		SET ANSI_PADDING OFF
		GO


-- insert/update dates
alter table [Reporting].[T004_Tasks]
    add constraint [T004_CreateRecord_dateTime] default (getdate()) for CreateRecord_dateTime;
alter table [Reporting].[T004_Tasks]
    add constraint [T004_UpdateRecord_dateTime] default (getdate()) for UpdateRecord_dateTime;

-- insert/update names
alter table [Reporting].[T004_Tasks]
    add constraint [T004_CreateRecord_name] default (coalesce(suser_sname(),'?')) for CreateRecord_name;

alter table [Reporting].[T004_Tasks]
    add constraint [T004_UpdateRecord_name] default (coalesce(suser_sname(),'?')) for UpdateRecord_name;
go

--For updates, but the inserted and deleted tables exist. I choose to join on the inserted for the update.

-- create the update trigger
create trigger TRG_001_recordChanged_T004 on Reporting.T004_Tasks
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       UpdateRecord_dateTime = getdate(),
       UpdateRecord_name = (coalesce(suser_sname(),'?'))
    from
       T004_Tasks d join inserted i 
    on 
       d.T004_Tasks_PK = i.T004_Tasks_PK;

end
go
--added constraint on 5/26/2017
ALTER TABLE [Reporting].[T004_Tasks]
  ADD CONSTRAINT uniqueValues$TaskName UNIQUE NONCLUSTERED (TaskName)

	go		


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ModifyAColumn_of_a_Table_With_Relationships</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ModifyAColumn_of_a_Table_With_Relationships</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ChangeAColumnInALinkedTable

--  Make a change to an SQL Table (e.g. T12_NotEmployees) that has relationships
--   This is a simple example, of changing the field "Notes" from ntext to nvarchar(max), I also changed the length of MI field
--    Otherwise it would require more extensive scripting

==============================================================
-- 1] Get list of tables linked to the target table
==============================================================
--		a) T8_Contacts_Details
--		b) T7_Contact_History
--		c) LNK02_T14_T12_T13
--		d) LNK01_T5_T12_T13
==============================================================
-- 2] Copy the Target table to a copy
==============================================================
==============================================================
	--	2a) Create the "COPY" table, without all the links
==============================================================
	--	   Change the PK, so it is not an Identity
	--	   Drop the "_RowVersion" field
	-- 	   If possible, implement the change to the COPY
	--	    	In this case Notes was: [Notes] [ntext] NULL,
	--			and I am changing it to: 	[Notes] [nvarchar](max) NULL,
==============================================================
-- TEMP_Create_T12_NotEmployees_COPY.sql


USE [DB2_CRM]
GO

/****** Object:  Table [dbo].[T12_NotEmployees]    Script Date: 05/07/2012 13:43:11 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TABLE [dbo].[T12_NotEmployees_COPY](
	[T12_PK] [int]  NOT NULL,		--IDENTITY(1,1)
	[LAST_NAME] [nvarchar](255) NULL,
	[FIRST_NAME] [nvarchar](255) NULL,
	[MI] [nvarchar](255) NULL,
	[Title] [nvarchar](255) NULL,
	[nickname] [nvarchar](255) NULL,
	[Position] [int] NULL,
	[Notes] [ntext] NULL,    --Could make this varchar(max) right here
	) ON [PRIMARY]
--				,
-- CONSTRAINT [T12_NotEmployees$T12_NotEmployees_PK] PRIMARY KEY NONCLUSTERED 
--(
--	[T12_PK] ASC
--)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
--) ON [PRIMARY]


--GO

--EXEC sys.sp_addextendedproperty @name=N'Position_RowSource', @value=N'SELECT vw_002__Enum., vw_002__Enum.
--FROM vw_002__Enum
--WHERE (((vw_002__Enum.)=''Practice_PositionInPractice''))
--ORDER BY vw_002__Enum.' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'T13_NotEmployees_Practice_Details', @level2type=N'COLUMN',@level2name=N'Position'
--GO

==============================================================

 	--	2b)Insert the original data into the COPY table

==============================================================

--TEMP_InsertFromT12_to_T12_NotEmployees_COPY.sql


SET IDENTITY_INSERT T12_NotEmployees_COPY ON
GO
use DB2_CRM
go
INSERT INTO T12_NotEmployees_COPY ( 
									[T12_PK],
									[LAST_NAME],
									[FIRST_NAME],
									[MI],
									[Title],
									[nickname],
									[Position],
									[Notes]
									)
SELECT 
									[T12_PK],
									[LAST_NAME],
									[FIRST_NAME],
									[MI] ,
									[Title],
									[nickname],
									[Position],
									[Notes]

FROM T12_NotEmployees;

SET IDENTITY_INSERT T12_NotEmployees_COPY off
GO

==============================================================

-- 3] Drop the constraints from each table to the Target Table
==============================================================

--TEMP_DropConstraints_For_T12.sql

USE [DB2_CRM]
GO

---- A] Contraints on first table: LNK01_T5_T12_T13
---------------------------------------------------

ALTER  TABLE [dbo].[LNK01_T5_T12_T13] DROP [LNK01_T5_T12_T13_FK_00]
GO

------------------------------------------------------------------------
---- This is the original statement that created the extended property:

----EXEC sys.sp_addextendedproperty 
----	@name=N'MS_SSMA_SOURCE', 
----	@value=N'prj_8011_v8c_PrimaryCareProvidorListy.[LNK01_T5_T12_T13].[T12_FK]' , 
----	@level0type=N'SCHEMA',
----	@level0name=N'dbo', 
----	@level1type=N'TABLE',
----	@level1name=N'LNK01_T5_T12_T13', 
----	@level2type=N'COLUMN',
----	@level2name=N'T12_FK'
------------------------------------------------------------------------

EXEC sp_dropextendedproperty 
	@name=N'MS_SSMA_SOURCE', 
	@level0type=N'SCHEMA',
	@level0name=N'dbo', 
	@level1type=N'TABLE',
	@level1name=N'LNK01_T5_T12_T13', 
	@level2type=N'COLUMN',
	@level2name=N'T12_FK'
 
  
GO

---- B] Contraints on second table: [LNK02_T14_T12_T13]
---------------------------------------------------
ALTER TABLE [dbo].[LNK02_T14_T12_T13]  DROP [LNK02_T14_T12_T13_FK_00]

GO

---- C] Contraints on second table: [LNK02_T14_T12_T13]
---------------------------------------------------
ALTER TABLE [dbo].[T7_Contact_History]  DROP [T7_Contact_History_FK_00] 

GO
---- D] Contraints on second table: [T8_Contacts_Details]
---------------------------------------------------
ALTER TABLE [dbo].[T8_Contacts_Details]  DROP [T8_Contacts_Details_FK_00] 

GO

==============================================================

-- For each of those tables get the script that created it, and has the link statements

==============================================================

-- 4] I used the GUI to delete the Target Table
==============================================================


==============================================================

-- 5] Recreate the Target Table
==============================================================


--prj_8011_CreateTable_T12_NotEmployees.sql

USE [DB2_CRM]
GO



IF OBJECT_ID('dbo.T12_NotEmployees') IS NOT NULL
    DROP TABLE dbo.T12_NotEmployees
    
    
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TABLE [dbo].[T12_NotEmployees](
	[T12_PK] [int] IDENTITY(1,1) NOT NULL,
	[LAST_NAME] [nvarchar](255) NULL,
	[FIRST_NAME] [nvarchar](255) NULL,
	[MI] [nvarchar](25) NULL,			-- 6/8/2012 changed from 255 to 25
	[Title] [nvarchar](255) NULL,
	[nickname] [nvarchar](255) NULL,
	[Position] [int] NULL,
	[Notes] [nvarchar] (max) NULL,			-- 6/8/2012 changed from [ntext] to [nvarchar] (max
	[T12_NotEmployees_RowVersion] [timestamp] NULL,
 CONSTRAINT [T12_NotEmployees$T12_NotEmployees_PK] PRIMARY KEY NONCLUSTERED 
(
	[T12_PK] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]


GO



==============================================================

-- 5] Insert from the COPY to the Target Table
==============================================================


SET IDENTITY_INSERT T12_NotEmployees ON
GO
use DB2_CRM
go
INSERT INTO T12_NotEmployees ( 
									[T12_PK],
									[LAST_NAME],
									[FIRST_NAME],
									[MI],
									[Title],
									[nickname],
									[Position],
									[Notes]
									)
SELECT 
									[T12_PK],
									[LAST_NAME],
									[FIRST_NAME],
									[MI] ,
									[Title],
									[nickname],
									[Position],
									[Notes]

FROM T12_NotEmployees_COPY;

SET IDENTITY_INSERT T12_NotEmployees off
GO


-- \\\\\\\\\\\\\\\\\NTEXT to VARCHAR conversion issue \\\\\\\\\

-- From: http://geekswithblogs.net/johnsPerfBlog/archive/2008/04/16/ntext-vs-nvarcharmax-in-sql-2005.aspx
-- need to fix ntext to varchar conversions

UPDATE T12_NotEmployees SET Notes = Notes

--This forces it to re-write the values and place them into the field correctly



-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

==============================================================
-- 6] rebuild the contraints : LNK01_T5_T12_T13
==============================================================

--prj_8011_CreateTable_LNK01_T5_T12_T13.sql

--USE [DB2_CRM]
--GO


--SET ANSI_NULLS ON
--GO

--SET QUOTED_IDENTIFIER ON
--GO

--CREATE TABLE [dbo].[LNK01_T5_T12_T13](
--	[LNK01_PK] [int] IDENTITY(1,1) NOT NULL,
--	[T5_FK] [int] NULL,
--	[T12_FK] [int] NULL,
--	[T13_FK] [int] NULL,
--	[LNK01_T5_T12_T13_RowVersion] [timestamp] NULL,
-- CONSTRAINT [LNK01_T5_T12_T13$LNK01_T5_T12_T13_PK] PRIMARY KEY NONCLUSTERED 
--(
--	[LNK01_PK] ASC
--)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
--) ON [PRIMARY]

--GO

--EXEC sys.sp_addextendedproperty @name=N'MS_SSMA_SOURCE', @value=N'prj_8011_v8c_PrimaryCareProvidorListy.[LNK01_T5_T12_T13].[LNK01_PK]' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'LNK01_T5_T12_T13', @level2type=N'COLUMN',@level2name=N'LNK01_PK'
--GO

--EXEC sys.sp_addextendedproperty @name=N'MS_SSMA_SOURCE', @value=N'prj_8011_v8c_PrimaryCareProvidorListy.[LNK01_T5_T12_T13].[T5_FK]' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'LNK01_T5_T12_T13', @level2type=N'COLUMN',@level2name=N'T5_FK'
--GO

EXEC sys.sp_addextendedproperty @name=N'MS_SSMA_SOURCE', @value=N'prj_8011_v8c_PrimaryCareProvidorListy.[LNK01_T5_T12_T13].[T12_FK]' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'LNK01_T5_T12_T13', @level2type=N'COLUMN',@level2name=N'T12_FK'
GO

--EXEC sys.sp_addextendedproperty @name=N'MS_SSMA_SOURCE', @value=N'prj_8011_v8c_PrimaryCareProvidorListy.[LNK01_T5_T12_T13].[T13_FK]' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'LNK01_T5_T12_T13', @level2type=N'COLUMN',@level2name=N'T13_FK'
--GO

--EXEC sys.sp_addextendedproperty @name=N'MS_SSMA_SOURCE', @value=N'prj_8011_v8c_PrimaryCareProvidorListy.[LNK01_T5_T12_T13]' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'LNK01_T5_T12_T13'
--GO

ALTER TABLE [dbo].[LNK01_T5_T12_T13]  WITH CHECK ADD  CONSTRAINT [LNK01_T5_T12_T13_FK_00] FOREIGN KEY([T12_FK])
REFERENCES [dbo].[T12_NotEmployees] ([T12_PK])
ON UPDATE CASCADE
ON DELETE CASCADE
GO

ALTER TABLE [dbo].[LNK01_T5_T12_T13] CHECK CONSTRAINT [LNK01_T5_T12_T13_FK_00]
GO

--ALTER TABLE [dbo].[LNK01_T5_T12_T13]  WITH CHECK ADD  CONSTRAINT [LNK01_T5_T12_T13_FK_02] FOREIGN KEY([T5_FK])
--REFERENCES [dbo].[T5_Practice_Branch] ([T5_PK])
--ON UPDATE CASCADE
--ON DELETE CASCADE
--GO

--ALTER TABLE [dbo].[LNK01_T5_T12_T13] CHECK CONSTRAINT [LNK01_T5_T12_T13_FK_02]
--GO

==============================================================
-- 7] rebuild the contraints : T8_Contacts_Details
==============================================================
--prj_8011_CreateTable_T8_Contacts_Details.sql
USE [DB2_CRM]
GO

--SET ANSI_NULLS ON
--GO

--SET QUOTED_IDENTIFIER ON
--GO

--CREATE TABLE [dbo].[T8_Contacts_Details](
--	[T8_PK] [int] IDENTITY(1,1) NOT NULL,
--	[T12_FK] [int] NULL,
--	[Contact_Detail] [nvarchar](255) NULL,
--	[Contact_Type] [int] NULL,
--	[Contact_Note] [ntext] NULL,
--	[T8_Contacts_Details_RowVersion] [timestamp] NULL,
-- CONSTRAINT [T8_Contacts_Details$T8_Contacts_Details_PK] PRIMARY KEY NONCLUSTERED 
--(
--	[T8_PK] ASC
--)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
--) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

--GO

ALTER TABLE [dbo].[T8_Contacts_Details]  WITH CHECK ADD  CONSTRAINT [T8_Contacts_Details_FK_00] FOREIGN KEY([T12_FK])
REFERENCES [dbo].[T12_NotEmployees] ([T12_PK])
ON UPDATE CASCADE
ON DELETE CASCADE
GO

ALTER TABLE [dbo].[T8_Contacts_Details] CHECK CONSTRAINT [T8_Contacts_Details_FK_00]
GO

==============================================================
-- 7] rebuild the contraints : LNK02_T14_T12_T13
==============================================================

--prj_8011_CreateTable_LNK02_T14_T12_T13.sql

USE [DB2_CRM]
GO


--SET ANSI_NULLS ON
--GO

--SET QUOTED_IDENTIFIER ON
--GO

--CREATE TABLE [dbo].[LNK02_T14_T12_T13](
--	[LNK02_PK] [int] IDENTITY(1,1) NOT NULL,
--	[T14_FK] [int] NULL,
--	[T12_FK] [int] NULL,
--	[T13_FK] [int] NULL,
--	[LNK02_T14_T12_T13_RowVersion] [timestamp] NULL,
-- CONSTRAINT [LNK02_T14_T12_T13$LNK02_T14_T12_T13_PK] PRIMARY KEY NONCLUSTERED 
--(
--	[LNK02_PK] ASC
--)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
--) ON [PRIMARY]

--GO

ALTER TABLE [dbo].[LNK02_T14_T12_T13]  WITH CHECK ADD  CONSTRAINT [LNK02_T14_T12_T13_FK_00] FOREIGN KEY([T12_FK])
REFERENCES [dbo].[T12_NotEmployees] ([T12_PK])
ON UPDATE CASCADE
ON DELETE CASCADE
GO

ALTER TABLE [dbo].[LNK02_T14_T12_T13] CHECK CONSTRAINT [LNK02_T14_T12_T13_FK_00]
GO

--ALTER TABLE [dbo].[LNK02_T14_T12_T13]  WITH CHECK ADD  CONSTRAINT [LNK02_T14_T12_T13_FK_02] FOREIGN KEY([T14_FK])
--REFERENCES [dbo].[T14_NotPractice] ([T14_PK])
--ON UPDATE CASCADE
--ON DELETE CASCADE
--GO

--ALTER TABLE [dbo].[LNK02_T14_T12_T13] CHECK CONSTRAINT [LNK02_T14_T12_T13_FK_02]
--GO


==============================================================
-- 8] rebuild the contraints : [T7_Contact_History]
==============================================================
--prj_8011_CreateTable_T7_Contact_History.sql

USE [DB2_CRM]
GO


--SET ANSI_NULLS ON
--GO

--SET QUOTED_IDENTIFIER ON
--GO

--CREATE TABLE [dbo].[T7_Contact_History](
--	[T7_PK] [int] IDENTITY(1,1) NOT NULL,
--	[T12_FK] [int] NULL,
--	[Note] [ntext] NULL,
--	[DateCreated] [datetime] NULL,
--	[T7_Contact_History_RowVersion] [timestamp] NULL,
-- CONSTRAINT [T7_Contact_History$T7_Contact_History_PK] PRIMARY KEY NONCLUSTERED 
--(
--	[T7_PK] ASC
--)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
--) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

--GO

ALTER TABLE [dbo].[T7_Contact_History]  WITH CHECK ADD  CONSTRAINT [T7_Contact_History_FK_00] FOREIGN KEY([T12_FK])
REFERENCES [dbo].[T12_NotEmployees] ([T12_PK])
ON UPDATE CASCADE
ON DELETE CASCADE
GO

ALTER TABLE [dbo].[T7_Contact_History] CHECK CONSTRAINT [T7_Contact_History_FK_00]
GO

--ALTER TABLE [dbo].[T7_Contact_History] ADD  DEFAULT (getdate()) FOR [DateCreated]
--GO



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Populate_Table_from_Stored_Procedure</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Populate_Table_from_Stored_Procedure</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Populate_Table_from_Stored_Procedure

TABLE_store_results_from_SP_into_a_table

--First let us create a stored stored procedure which returns result set:

CREATE DATABASE DEMOSQLHINTS
GO
USE DEMOSQLHINTS
GO
CREATE TABLE dbo.Employee(ID INT IDENTITY(1,1),Name VARCHAR(50))
 
INSERT INTO dbo.Employee(Name)
VALUES('BASAVARAJ BIRADAR'),
('SHREE BIRADAR')
GO
 
CREATE PROCEDURE dbo.GetEmployees
AS
	BEGIN
	SELECT * FROM dbo.Employee
	END
GO

EXEC dbo.GetEmployees
GO

--script shows how to move the result of the SP GetEmployees to a temporary table #TempEmployees

-- First create the table to which we want to push the SP result
CREATE TABLE #TempEmployees(EmpId int,EmpName Varchar(50))
GO
-- Insert result from the SP to temp table
INSERT INTO #TempEmployees
EXEC dbo.GetEmployees
GO
--Verify the Insert records
SELECT * FROM #TempEmployees


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

--example where we Insert result from a Stored Procedure with Parameter into a temporary table

--First create a stored procedure with parameter
CREATE PROCEDURE GetEmployeeDetails
(@id AS INT)
AS
BEGIN
SELECT * FROM dbo.Employee (NOLOCK)
WHERE Id = @id
END
GO
--Execute SP with parameter and dump the result into a temp table
INSERT INTO #TempEmployees
EXEC GetEmployeeDetails 2
 
GO
-- Verify the inserted records
SELECT * FROM #TempEmployees</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Simulate_CascadeUpdate_CascadeDelete</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Simulate_CascadeUpdate_CascadeDelete</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--This one adds the new record to the other table, but not the delete


--prj_8011_SP_011_Add_Employee_To_T9_v5.sql
-----------------------------------------
-- This SP will:
--		INSERT INTO T011 one record, and return the IDENT_CURRENT for the new record
--		INSERT INTO T15 the new T9_FK

/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 5/25/2012
	Modified: 1/31/2013: Now it will run prj_1021_SP_925_Add_T21PK_for_all_Trainings_and_T15FK_ForNewEmployee_Given_T9PK_To_T21
	Modified: 9/24/2012:  Now it will INSERT INTO T15 the T9_FK
	Modified: 8/29/2012: added 7 fields	
	Modified: 10/17/2012: removed three unused enum fields
	By: glenn garson
	************************************************************************************

*/

SET NOCOUNT ON
Use DB2_CRM
go



alter PROCEDURE SP_011_Add_Employee_To_T9(
	@Name AS  nvarchar(255),
	@Titles AS  nvarchar(255),
	@Position AS  int,
	@bCareManager AS  bit,
	@Notes AS  nvarchar(max),
	@bActiveEmployee as bit
	  , @EMPLOYEE_Language_e12 AS  smallint
      , @EMPLOYEE_OfficeLocation_e13 AS  smallint
      , @CCWNC_Department_e14 AS  smallint
      --, @CrossDepartment_Team_e15 AS  smallint
      --, @SameDepartment_Team_e16 AS  smallint
      --, @EmployeeSupport_Role_e17 AS  smallint
      , @Supervisor AS  int
	)
	
	
	AS
	
-- START DEBUGGING SECTION -------------------	
	
			PRINT '1) Input @Name: ' + 	 @Name
			PRINT '2)Input @Titles: ' +  @Titles
			PRINT '3)Input @Position: ' + 	 	CAST(@Position AS varchar(5))
			PRINT '4)Input @bCareManager: ' + CAST(@bCareManager AS varchar(2)) + ', ' + SUBSTRING('FalseTrue', @bCareManager * 5 + 1, 5)  --TRUE is converted to 1 and FALSE is converted to 0.
			PRINT '5)Input @Notes: ' + 	 @Notes	
			PRINT '6)Input @bCareManager: ' + CAST(@bActiveEmployee AS varchar(2)) + ', ' + SUBSTRING('FalseTrue', @bActiveEmployee * 5 + 1, 5)  --TRUE is converted to 1 and FALSE is converted to 0.

			PRINT '7)Input @EMPLOYEE_Language_e12: ' + CAST(@EMPLOYEE_Language_e12 AS varchar(10))
			PRINT '8)Input @EMPLOYEE_OfficeLocation_e13: ' + CAST(@EMPLOYEE_OfficeLocation_e13 AS varchar(10))
			PRINT '9)Input @CCWNC_Department_e14: ' + CAST(@CCWNC_Department_e14 AS varchar(10))
			--PRINT '10)Input @SameDepartment_Team_e16: ' + CAST(@SameDepartment_Team_e16 AS varchar(10))			
			--PRINT '11)Input @EmployeeSupport_Role_e17: ' + CAST(@EmployeeSupport_Role_e17 AS varchar(10))			
			PRINT '12)Input @Supervisor: ' + CAST(@Supervisor AS varchar(10))
												
-- END DEBUGGING SECTION -------------------	
	

-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

   DECLARE @T9_FK INT
   SELECT @T9_FK = NULL

-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 1] INSERT INTO
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


INSERT INTO T9_CCWNC_Employees
						(
							[Name]
							,[Titles]
							,[Position]
							,[bCareManager]
							,[Notes]
							,[bActiveEmployee]
							--
							,[EMPLOYEE_Language_e12]
							,[EMPLOYEE_OfficeLocation_e13]
							,[CCWNC_Department_e14]
							--,[CrossDepartment_Team_e15]
							--,[SameDepartment_Team_e16]
							--,[EmployeeSupport_Role_e17]
							,[Supervisor]
							--
						)
VALUES
		(
			@Name,
			@Titles,
			@Position,
			@bCareManager,
			@Notes,
			@bActiveEmployee
			--			
			, @EMPLOYEE_Language_e12
			, @EMPLOYEE_OfficeLocation_e13
			, @CCWNC_Department_e14
			--, @CrossDepartment_Team_e15
			--, @SameDepartment_Team_e16
			--, @EmployeeSupport_Role_e17
			, @Supervisor
			--				
		);
	
   SELECT @T9_FK = @@IDENTITY
	
		
		
	IF @@ERROR = 0
		BEGIN
		-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
			INSERT INTO T15_CCWNC_Employee_SecurityPortal (T9_FK) VALUES (@T9_FK)
			EXEC prj_1021_SP_925_Add_T21PK_for_all_Trainings_and_T15FK_ForNewEmployee_Given_T9PK_To_T21 @T9_FK
			IF @@ERROR = 0
				BEGIN
					RETURN @T9_FK
					PRINT 'Returned the PK for the new T9 record, and T9_FK was successfully inserted into T15'
				END
			ELSE
				BEGIN
					PRINT 'Woops! There was an error when the FK was inserted into T15 if it returns a zero (0)'
					RETURN 0					
				END	
		-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\					
		END
	ELSE
		BEGIN

			PRINT 'Woops! There was an error if it returns a zero (0)'
			RETURN 0			
		END
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>TEMP_Table_INSERT_INTO_and_UNION_of_Two_TEMP_tables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>TEMP_Table_INSERT_INTO_and_UNION_of_Two_TEMP_tables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0024_301_HYPERLINK_FORMs_Directory_Searchable_v2.sql

/*
	************************************************************************************
	NOTE: 
	Uses: 
	MODIFIED: 4/7/2015 - Now it manually brings in the MVC forms, using TEMP tables and UNION of manual and datbase sources
	Created: 4/11/2013
	By: glenn garson
	************************************************************************************
*/

use DB5_FORMs
go

alter Procedure prj_0024_301_HYPERLINK_FORMs_Directory_Searchable(
	@SearchString as NVARCHAR(25)
	)

	as
	
-- START DEBUGGING SECTION -------------------	

	PRINT '1] Input @SearchString: [' + @SearchString + ']'
	
	-- Get rid of any spaces the user may have left in there:
	select @SearchString = LTRIM(RTRIM(@SearchString))
	PRINT '2] Input @SearchString: [' + @SearchString + ']'
-- END DEBUGGING SECTION -------------------	

	
IF OBJECT_ID('tempdb..#T1_DataFromDB') IS NOT NULL

	DROP TABLE #T1_DataFromDB
IF OBJECT_ID('tempdb..#T2_ManualData') IS NOT NULL

	DROP TABLE #T2_ManualData  


--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SELECT 
	(SELECT 'TheCalculation' = '&lt;a href="file:///\\ccwnc01\Shared Documents\Common\Document_Library_ElectronicForms\' + Form_File_Name + '"&gt;CLICK&lt;/a&gt;') AS FORM,
	Form_Description, 
	Form_Alternate_Name
INTO #T1_DataFromDB
FROM  T0_FORMsDirectory						

--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++			
--Select * From #T1_DataFromDB
--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CREATE TABLE #T2_ManualData
  ( 
	FORM VARCHAR(max),
	Form_Description VARCHAR(max),
	Form_Alternate_Name VARCHAR(max)
  ) 


INSERT INTO #T2_ManualData
		  (FORM, Form_Description, Form_Alternate_Name)
	 VALUES
		   ('&lt;a href="http://10.0.0.14:54545/"&gt;CLICK&lt;/a&gt;','Database Project Requisition Form (Requires your Windows Login)', 'FORM_0010' )
 --+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 SELECT * 
 FROM (
		 SELECT * FROM #T1_DataFromDB
		 UNION
		 SELECT * FROM #T2_ManualData
	   ) As TheUnion
WHERE 

		(
				 ([Form_Description] like '%' +  @SearchString + '%')  
				OR ([Form_Alternate_Name] like '%' +  @SearchString + '%') 
		)	
						
go		

	
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>UseTemporaryTableToAdd_PrimaryKey_RowVersion_ThenDeleteAndReplaceTheOriginalTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>UseTemporaryTableToAdd_PrimaryKey_RowVersion_ThenDeleteAndReplaceTheOriginalTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- UseTemporaryTableToAdd_PrimaryKey_RowVersion_ThenDeleteAndReplaceTheOriginalTable

-- USES a Transaction to make sure that all the steps work successfully




-- prj_8004_001_Add_PrimaryKey_RowVersion_To_L1_t.sql
-- This will fix the table: L1
-- b/c originally when it was created by: prj_0000_105_CreateTable_L1_ChronicConditionCodes_t.sql
-- The table did not have a primary Key, nor RowVersion field
--	as a result it was difficult to work with from MS Access 
-- It uses a TRANSACTION to make sure that it does not delete the original table unless there were no errors
--
-- glenn garson 1/6/2012
--=========================================================================
USE [DB1_Main]
go


BEGIN TRANSACTION Add_PK_And_RowVersion

		--=========================================================================
		-- 1] Create the temporary table to hold the data.
		--		In addition, give it a PK and Row Version Field
		--=========================================================================

		IF OBJECT_ID('dbo.zzz_L1_ChronicConditionCodes_t') IS NOT NULL
			DROP TABLE dbo.zzz_L1_ChronicConditionCodes_t

		SET QUOTED_IDENTIFIER ON
		GO

		SET ANSI_PADDING ON
		GO

		CREATE TABLE [dbo].[zzz_L1_ChronicConditionCodes_t](
			[L1_PK] [int] IDENTITY(1,1) NOT NULL,
			[ListSource_Code] [varchar](2) NULL,
			[ListSource_ConditionCategory] [varchar](50) NULL,
			[Description] [varchar](100) NULL,
			[ICD_Code_Cleaned] [varchar](5) NULL,
			[ICD_Version] [varchar](5) NULL,
			[L1_RowVersion] [rowversion],

		 CONSTRAINT [zzz_L1_ChronicConditionCodes_t$L1_PK] PRIMARY KEY CLUSTERED 
		(
			[L1_PK] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
		) ON [PRIMARY]

		GO

		SET ANSI_PADDING OFF
		GO

		-- ================================================================
		-- Check for errors
		--
		IF @@ERROR &lt;&gt; 0
				BEGIN
				--
				-- Rollback the transaction
				--
				ROLLBACK TRANSACTION Add_PK_And_RowVersion
				PRINT '1]	ERROR DURING: delete/Create of temporary table. Transaction was not completed'
				END
			ELSE
				BEGIN
				PRINT '1]	SUCCESS DURING: delete/Create of temporary table.'
				END
			
		--
		-- 
		-- ================================================================



		--=========================================================================
		-- 2] Move the data from L1 into the temporary table: zzz_L1
		--=========================================================================



		INSERT INTO [zzz_L1_ChronicConditionCodes_t] 
			(
			   [ListSource_Code]
			  ,[ListSource_ConditionCategory]
			  ,[Description]
			  ,[ICD_Code_Cleaned]
			  ,[ICD_Version]
			)
		SELECT 
			   [ListSource_Code]
			  ,[ListSource_ConditionCategory]
			  ,[Description]
			  ,[ICD_Code_Cleaned]
			  ,[ICD_Version]
		FROM [L1_ChronicConditionCodes_t]

		go

		-- ================================================================
		-- Check for errors
		--
		IF @@ERROR &lt;&gt; 0
				BEGIN
				--
				-- Rollback the transaction
				--
				ROLLBACK TRANSACTION Add_PK_And_RowVersion
				PRINT '2]	ERROR DURING:  INSERT INTO temporary table. Transaction was not completed'
				END
			ELSE
				BEGIN
				PRINT '2]	SUCCESS DURING: delete/Create of temporary table.'
				END
			
		--
		-- 
		-- ================================================================


		--=========================================================================
		-- 3] DELETE/RECREATE the original table, but with a PK and RowVersion Field
		--=========================================================================

		IF OBJECT_ID('dbo.L1_ChronicConditionCodes_t') IS NOT NULL
			DROP TABLE dbo.L1_ChronicConditionCodes_t

		SET QUOTED_IDENTIFIER ON
		GO

		SET ANSI_PADDING ON
		GO

		CREATE TABLE [dbo].[L1_ChronicConditionCodes_t](
			[L1_PK] [int] IDENTITY(1,1) NOT NULL,
			[ListSource_Code] [varchar](2) NULL,
			[ListSource_ConditionCategory] [varchar](50) NULL,
			[Description] [varchar](100) NULL,
			[ICD_Code_Cleaned] [varchar](5) NULL,
			[ICD_Version] [varchar](5) NULL,
			[L1_RowVersion] [rowversion],

		 CONSTRAINT [L1_ChronicConditionCodes_t$L1_PK] PRIMARY KEY CLUSTERED 
		(
			[L1_PK] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
		) ON [PRIMARY]

		GO

		SET ANSI_PADDING OFF
		GO
		
		-- ================================================================
		-- Check for errors
		--
		IF @@ERROR &lt;&gt; 0
				BEGIN
				--
				-- Rollback the transaction
				--
				ROLLBACK TRANSACTION Add_PK_And_RowVersion
				PRINT '2]	ERROR DURING:  INSERT INTO Original table from the Temporary Table. Transaction was not completed'
				END
			ELSE
				BEGIN
				PRINT '2]	SUCCESS DURING:  INSERT INTO Original table from the Temporary Table..'
				END
			
		--
		-- 
		-- ================================================================
		
		
		
		
		
			--=========================================================================
		-- 4] Move the data back from the temporary table (zzz_L1) into the original table: L1
		--=========================================================================



		INSERT INTO [L1_ChronicConditionCodes_t] 
			(
			   [ListSource_Code]
			  ,[ListSource_ConditionCategory]
			  ,[Description]
			  ,[ICD_Code_Cleaned]
			  ,[ICD_Version]
			)
		SELECT 
			   [ListSource_Code]
			  ,[ListSource_ConditionCategory]
			  ,[Description]
			  ,[ICD_Code_Cleaned]
			  ,[ICD_Version]
		FROM [zzz_L1_ChronicConditionCodes_t]

		go

		-- ================================================================
		-- Check for errors
		--
		IF @@ERROR &lt;&gt; 0
				BEGIN
				--
				-- Rollback the transaction
				--
				ROLLBACK TRANSACTION Add_PK_And_RowVersion
				PRINT '4]	ERROR DURING:  INSERT INTO the Original Table from the temporary table. Transaction was not completed'
				END
			ELSE
				BEGIN
				PRINT '4]	SUCCESS DURING:  INSERT INTO the Original Table from the temporary table.'
				PRINT '5]	TRANSACTION COMPLETED, Do not forget to delete the temporary table: zzz... '
				END
			
		--
		-- 
		-- ================================================================

		
		-- This does not delete the temporary table, so I can do that by hand afterwards
		

COMMIT TRANSACTION Add_PK_And_RowVersion</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>UseTemporaryTableToAdd_PrimaryKey_RowVersion_ThenMoveItToAnother_SCHEMA</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>UseTemporaryTableToAdd_PrimaryKey_RowVersion_ThenMoveItToAnother_SCHEMA</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- UseTemporaryTableToAdd_PrimaryKey_RowVersion_ThenMoveItToAnother_SCHEMA



-- prj_8004_001_Add_PrimaryKey_RowVersion_To_L1_t.sql
-- This will fix the table: L1
-- b/c originally when it was created by: prj_0000_105_CreateTable_L1_ChronicConditionCodes_t.sql
-- The table did not have a primary Key, nor RowVersion field
--	as a result it was difficult to work with from MS Access 
--
-- glenn garson 1/6/2012
--=========================================================================
USE [DB1_Main]
go

--=========================================================================
-- 1] Create the temporary table to hold the data.
--		In addition, give it a PK and Row Version Field
--=========================================================================

IF OBJECT_ID('dbo.zzz_L1_ChronicConditionCodes_t') IS NOT NULL
    DROP TABLE dbo.zzz_L1_ChronicConditionCodes_t

SET QUOTED_IDENTIFIER ON
GO

SET ANSI_PADDING ON
GO

CREATE TABLE [dbo].[zzz_L1_ChronicConditionCodes_t](
	[L1_PK] [int] IDENTITY(1,1) NOT NULL,
	[ListSource_Code] [varchar](2) NULL,
	[ListSource_ConditionCategory] [varchar](50) NULL,
	[Description] [varchar](100) NULL,
	[ICD_Code_Cleaned] [varchar](5) NULL,
	[ICD_Version] [varchar](5) NULL,
	[L1_RowVersion] [rowversion],

 CONSTRAINT [zzz_L1_ChronicConditionCodes_t$L1_PK] PRIMARY KEY CLUSTERED 
(
	[L1_PK] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

GO

SET ANSI_PADDING OFF
GO

--=========================================================================
-- 2] Move the data from L1 into the temporary table: zzz_L1
--=========================================================================



INSERT INTO [zzz_L1_ChronicConditionCodes_t] 
	(
	   [ListSource_Code]
      ,[ListSource_ConditionCategory]
      ,[Description]
      ,[ICD_Code_Cleaned]
      ,[ICD_Version]
	)
SELECT 
	   [ListSource_Code]
      ,[ListSource_ConditionCategory]
      ,[Description]
      ,[ICD_Code_Cleaned]
      ,[ICD_Version]
FROM [L1_ChronicConditionCodes_t]

go

--=========================================================================
-- 3] Transfer the Temporary Table to the Schema: App_01
--=========================================================================

IF OBJECT_ID('App_001.zzz_L1_ChronicConditionCodes_t') IS NOT NULL
    DROP TABLE App_001.zzz_L1_ChronicConditionCodes_t


ALTER SCHEMA App_001 TRANSFER dbo.[zzz_L1_ChronicConditionCodes_t]

go
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Table</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>UsingSelect_ToInsertRecords_FromOneTableToAnother</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Table</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>UsingSelect_ToInsertRecords_FromOneTableToAnother</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>INSERT california_authors (au_id, au_lname, au_fname)
SELECT au_id, au_lname, au_fname
FROM authors
WHERE State = 'CA'</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CourseLinkStudent_createTablesAndData_RandomLink_Autonumber.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CourseLinkStudent_createTablesAndData_RandomLink_Autonumber.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--CourseLinkStudent_createTablesAndData_RandomLink_Autonumber.sql
--Create_Course_LNK_Student_Tables_With_ForeignKeys_in_The_LNK_table_and_Cascade_Delete_AUTO-NUMBER.sql


use Course_Link_Student
go



--Drop the Link Table first b/c it has the Foreign key constraints
IF OBJECT_ID('dbo.LNK02_T0_T1') IS NOT NULL
    DROP TABLE dbo.LNK02_T0_T1 

--Drop the Student after the LNK table
IF OBJECT_ID('dbo.T3_Student') IS NOT NULL
    DROP TABLE dbo.T3_Student 
    
--Then drop the Course
IF OBJECT_ID('dbo.T0_Course') IS NOT NULL
    DROP TABLE dbo.T0_Course
   
    
--Course table
CREATE TABLE [dbo].[T0_Course](
 [T0_Course_PK] [INT] IDENTITY(1,1) NOT NULL,
 [CourseData] [varchar](10) NOT NULL,
 CONSTRAINT [T0_Course$T0_Course_PK] PRIMARY KEY CLUSTERED 
    ([T0_Course_PK] ASC)
)
GO
-- Student table
CREATE TABLE [dbo].[T3_Student](
 [T3_Student_PK] [INT] IDENTITY(1,1) NOT NULL,
 --[T0_Course_FK] [INT] NULL,
 [StudentData] [varchar](10) NULL,
 CONSTRAINT [T3_Student$T3_Student_PK] PRIMARY KEY CLUSTERED 
    ([T3_Student_PK] ASC)
)
GO

-- Link table
CREATE TABLE [dbo].[LNK02_T0_T1](
 [LNK02_PK] [int] IDENTITY(1,1) NOT NULL,
 [T0_Course_FK] [INT] NULL,
 [T3_Student_FK] [INT] NULL, 
 --[StudentData] [varchar](10) NULL,
 CONSTRAINT [LNK02_T0_T1$LNK02_PK] PRIMARY KEY CLUSTERED 
    ([LNK02_PK] ASC)
)
GO
-- foreign key constraints
ALTER TABLE [dbo].[LNK02_T0_T1]  WITH CHECK 
	ADD CONSTRAINT [LNK02_T0_T1$T0_Course_FK] FOREIGN KEY([T0_Course_FK])
		REFERENCES [dbo].[T0_Course] ([T0_Course_PK])
		ON DELETE CASCADE						--&lt;=====  here is the Delete Cascade on the LNK table
GO
ALTER TABLE [dbo].[LNK02_T0_T1]  WITH CHECK 
	ADD CONSTRAINT [LNK02_T0_T1$T3_Student_FK] FOREIGN KEY([T3_Student_FK])
		REFERENCES [dbo].[T3_Student] ([T3_Student_PK])
		ON DELETE CASCADE						--&lt;=====  here is the Delete Cascade on the LNK table
GO


-- data load
DECLARE @val_CourseCounter INT
DECLARE @val_StudentCounter INT
SELECT @val_CourseCounter=1

-- Populate the Student : 2 columns:[T3_Student_PK], [StudentData] ------------------------------------------------------------------------
SELECT @val_StudentCounter=1
	   
WHILE @val_StudentCounter &lt; 6	--Number of Student records per Course
BEGIN  
	INSERT INTO dbo.[T3_Student](StudentData) VALUES ('STUDENT_' + CAST(@val_StudentCounter AS VARCHAR)   )
	SELECT @val_StudentCounter=@val_StudentCounter+1
END

WHILE @val_CourseCounter &lt; 10		-- Number of Course records
	BEGIN 
	
	 
		-- Populate the Course: 2 columns: [T0_Course_PK], [CourseData] ------------------------------------------------------------------------
	   INSERT INTO dbo.[T0_Course](CourseData) VALUES('COURSE_' + CAST(@val_CourseCounter AS VARCHAR))
	   
	   
	   -- Populate the Link Table: 2 columns: [T0_Course_FK], [T3_Student_FK] ------------------------------------------------------------------------
	   SELECT @val_StudentCounter=1
	   
	   WHILE @val_StudentCounter &lt; 6	--Number of Student records per Course

	   BEGIN  
		  IF  (CAST(ROUND(RAND(),0) AS BIT) = 1)
		  BEGIN
			INSERT INTO dbo.[LNK02_T0_T1] ([T0_Course_FK], [T3_Student_FK]) VALUES (@val_CourseCounter,  @val_StudentCounter)
		  END
		  SELECT @val_StudentCounter=@val_StudentCounter+1
	   END	   
	   
	   
	   
	   SELECT @val_CourseCounter=@val_CourseCounter+1
	     
	END
GO </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Create_data_to_a_Table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Create_data_to_a_Table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--1] Create data for example =========================================

USE AdventureWorks2008
IF OBJECT_ID ('BookInventory', 'U') IS NOT NULL
DROP TABLE dbo.BookInventory;
 
CREATE TABLE dbo.BookInventory  -- target
(
  TitleID INT NOT NULL PRIMARY KEY,
  Title NVARCHAR(100) NOT NULL,
  Quantity INT NOT NULL
    CONSTRAINT Quantity_Default_1 DEFAULT 0
);
IF OBJECT_ID ('BookOrder', 'U') IS NOT NULL
DROP TABLE dbo.BookOrder;
 
CREATE TABLE dbo.BookOrder  -- source
(
  TitleID INT NOT NULL PRIMARY KEY,
  Title NVARCHAR(100) NOT NULL,
  Quantity INT NOT NULL
    CONSTRAINT Quantity_Default_2 DEFAULT 0
);
INSERT BookInventory VALUES
  (1, 'The Catcher in the Rye', 6),
  (2, 'Pride and Prejudice', 3),
  (3, 'The Great Gatsby', 0),
  (5, 'Jane Eyre', 0),
  (6, 'Catch 22', 0),
  (8, 'Slaughterhouse Five', 4);
INSERT BookOrder VALUES
  (1, 'The Catcher in the Rye', 3),
  (3, 'The Great Gatsby', 0),
  (4, 'Gone with the Wind', 4),
  (5, 'Jane Eyre', 5),
  (7, 'Age of Innocence', 8);
  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Create_Parent_Child_Tables_With_ForeignKey_and_Cascade_Delete_AUTO-NUMBER.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Create_Parent_Child_Tables_With_ForeignKey_and_Cascade_Delete_AUTO-NUMBER.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Create_Parent_Child_Tables_With_ForeignKey_and_Cascade_Delete_AUTO-NUMBER.sql


use Parent_Child
go

--Drop the child first b/c it has the Foreign key constraint
IF OBJECT_ID('dbo.T3_child_detail') IS NOT NULL
    DROP TABLE dbo.T3_child_detail 

--Then drop the parent
IF OBJECT_ID('dbo.T0_Parent') IS NOT NULL
    DROP TABLE dbo.T0_Parent
   
    
--parent table
CREATE TABLE [dbo].[T0_Parent](
 [T0_Parent_PK]  [int] IDENTITY(1,1) NOT NULL,
 [ParentData] [varchar](10) NOT NULL,
 CONSTRAINT [T0_Parent$T0_Parent_PK] PRIMARY KEY CLUSTERED 
    ([T0_Parent_PK] ASC)
)
GO
-- child table
CREATE TABLE [dbo].[T3_child_detail](
 [T3_child_detail_PK]  [int] IDENTITY(1,1) NOT NULL,
 [T0_Parent_FK] [int] NULL,
 [ChildData] [varchar](10) NULL,
 CONSTRAINT [T3_child_detail$T3_child_detail_PK] PRIMARY KEY CLUSTERED 
    ([T3_child_detail_PK] ASC)
)
GO
-- foreign key constraint
ALTER TABLE [dbo].[T3_child_detail]  WITH CHECK 
ADD CONSTRAINT [T3_child_detail$T0_Parent_FK] FOREIGN KEY([T0_Parent_FK])
REFERENCES [dbo].[T0_Parent] ([T0_Parent_PK])
ON DELETE CASCADE						--&lt;=====  here is the Delete Cascade on the detail/child table
GO
-- data load
DECLARE @val_ParentCounter INT
DECLARE @val_ChildCounter INT
SELECT @val_ParentCounter=1
WHILE @val_ParentCounter &lt; 10		-- Number of parent records
	BEGIN  
	   INSERT INTO dbo.[T0_Parent] (ParentData) VALUES('TEST' + CAST(@val_ParentCounter AS VARCHAR))
   
	   SELECT @val_ChildCounter=1
	   WHILE @val_ChildCounter &lt; 3	--Number of child records per parent
	   BEGIN  
		  INSERT INTO dbo.[T3_child_detail] (T0_Parent_FK, ChildData) VALUES (@val_ParentCounter, 'TEST' + CAST(@val_ParentCounter AS VARCHAR))
		  SELECT @val_ChildCounter=@val_ChildCounter+1
	   END
	   SELECT @val_ParentCounter=@val_ParentCounter+1
     
	END
GO </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Create_Parent_Child_Tables_With_ForeignKey_and_Cascade_Delete</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Create_Parent_Child_Tables_With_ForeignKey_and_Cascade_Delete</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Create_Parent_Child_Tables_With_ForeignKey_and_Cascade_Delete.sql

use DB2_CRM
go

--Drop the child first b/c it has the Foreign key constraint
IF OBJECT_ID('dbo.T3_child_detail') IS NOT NULL
    DROP TABLE dbo.T3_child_detail 

--Then drop the parent
IF OBJECT_ID('dbo.T0_Parent') IS NOT NULL
    DROP TABLE dbo.T0_Parent
   
    
--parent table
CREATE TABLE [dbo].[T0_Parent](
 [T0_Parent_PK] [bigint] NOT NULL,
 [ParentData] [varchar](10) NOT NULL,
 CONSTRAINT [T0_Parent$T0_Parent_PK] PRIMARY KEY CLUSTERED 
    ([T0_Parent_PK] ASC)
)
GO
-- child table
CREATE TABLE [dbo].[T3_child_detail](
 [T3_child_detail_PK] [bigint] NOT NULL,
 [T0_Parent_FK] [bigint] NULL,
 [ChildData] [varchar](10) NULL,
 CONSTRAINT [T3_child_detail$T3_child_detail_PK] PRIMARY KEY CLUSTERED 
    ([T3_child_detail_PK] ASC)
)
GO
-- foreign key constraint
ALTER TABLE [dbo].[T3_child_detail]  WITH CHECK 
ADD CONSTRAINT [T3_child_detail$T0_Parent_FK] FOREIGN KEY([T0_Parent_FK])
REFERENCES [dbo].[T0_Parent] ([T0_Parent_PK])
ON DELETE CASCADE						--&lt;=====  here is the Delete Cascade on the detail/child table
GO
-- data load
DECLARE @val_ParentCounter BIGINT
DECLARE @val_ChildCounter BIGINT
SELECT @val_ParentCounter=1
WHILE @val_ParentCounter &lt; 10		-- Number of parent records
BEGIN  
   INSERT INTO dbo.[T0_Parent] VALUES(@val_ParentCounter,'TEST' + CAST(@val_ParentCounter AS VARCHAR))
   
   SELECT @val_ChildCounter=1
   WHILE @val_ChildCounter &lt; 3	--Number of child records per parent
   BEGIN  
      INSERT INTO dbo.[T3_child_detail] VALUES ((@val_ParentCounter*100000)+@val_ChildCounter,@val_ParentCounter,'TEST' + CAST(@val_ParentCounter AS VARCHAR))
      SELECT @val_ChildCounter=@val_ChildCounter+1
   END
   SELECT @val_ParentCounter=@val_ParentCounter+1
     
END
GO </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Create_Parent_LNK_Child_Tables_With_ForeignKeys_in_The_LNK_table_and_Cascade_Delete_AUTO-NUMBER.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Create_Parent_LNK_Child_Tables_With_ForeignKeys_in_The_LNK_table_and_Cascade_Delete_AUTO-NUMBER.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Create_Parent_LNK_Child_Tables_With_ForeignKeys_in_The_LNK_table_and_Cascade_Delete_AUTO-NUMBER.sql

--Create_Parent_LNK_Child_Tables_With_ForeignKeys_in_The_LNK_table_and_Cascade_Delete.sql

use Parent_Link_Child
go



--Drop the Link Table first b/c it has the Foreign key constraints
IF OBJECT_ID('dbo.LNK02_T0_T1') IS NOT NULL
    DROP TABLE dbo.LNK02_T0_T1 

--Drop the child after the LNK table
IF OBJECT_ID('dbo.T3_child_detail') IS NOT NULL
    DROP TABLE dbo.T3_child_detail 
    
--Then drop the parent
IF OBJECT_ID('dbo.T0_Parent') IS NOT NULL
    DROP TABLE dbo.T0_Parent
   
    
--parent table
CREATE TABLE [dbo].[T0_Parent](
 [T0_Parent_PK] [INT] IDENTITY(1,1) NOT NULL,
 [ParentData] [varchar](10) NOT NULL,
 CONSTRAINT [T0_Parent$T0_Parent_PK] PRIMARY KEY CLUSTERED 
    ([T0_Parent_PK] ASC)
)
GO
-- child table
CREATE TABLE [dbo].[T3_child_detail](
 [T3_child_detail_PK] [INT] IDENTITY(1,1) NOT NULL,
 --[T0_Parent_FK] [INT] NULL,
 [ChildData] [varchar](10) NULL,
 CONSTRAINT [T3_child_detail$T3_child_detail_PK] PRIMARY KEY CLUSTERED 
    ([T3_child_detail_PK] ASC)
)
GO

-- Link table
CREATE TABLE [dbo].[LNK02_T0_T1](
 [LNK02_PK] [int] IDENTITY(1,1) NOT NULL,
 [T0_Parent_FK] [INT] NULL,
 [T3_child_detail_FK] [INT] NULL, 
 --[ChildData] [varchar](10) NULL,
 CONSTRAINT [LNK02_T0_T1$LNK02_PK] PRIMARY KEY CLUSTERED 
    ([LNK02_PK] ASC)
)
GO
-- foreign key constraints
ALTER TABLE [dbo].[LNK02_T0_T1]  WITH CHECK 
	ADD CONSTRAINT [LNK02_T0_T1$T0_Parent_FK] FOREIGN KEY([T0_Parent_FK])
		REFERENCES [dbo].[T0_Parent] ([T0_Parent_PK])
		ON DELETE CASCADE						--&lt;=====  here is the Delete Cascade on the LNK table
GO
ALTER TABLE [dbo].[LNK02_T0_T1]  WITH CHECK 
	ADD CONSTRAINT [LNK02_T0_T1$T3_child_detail_FK] FOREIGN KEY([T3_child_detail_FK])
		REFERENCES [dbo].[T3_child_detail] ([T3_child_detail_PK])
		ON DELETE CASCADE						--&lt;=====  here is the Delete Cascade on the LNK table
GO


-- data load
DECLARE @val_ParentCounter INT
DECLARE @val_ChildCounter INT

SELECT @val_ParentCounter=1

WHILE @val_ParentCounter &lt; 10		-- Number of parent records
	BEGIN 
	
	 
		-- Populate the Parent: 2 columns: [T0_Parent_PK], [ParentData] ------------------------------------------------------------------------
	   INSERT INTO dbo.[T0_Parent](ParentData) VALUES('TEST' + CAST(@val_ParentCounter AS VARCHAR))
	   
	   
	   
	   
	   -- Populate the Child : 2 columns:[T3_child_detail_PK], [ChildData] ------------------------------------------------------------------------
	   SELECT @val_ChildCounter=1
	   
	   WHILE @val_ChildCounter &lt; 3	--Number of child records per parent
	   BEGIN  
		  INSERT INTO dbo.[T3_child_detail](ChildData) VALUES ('TEST' + CAST(@val_ParentCounter AS VARCHAR))
		  SELECT @val_ChildCounter=@val_ChildCounter+1
	   END
	   
	   
	   
	   
	   -- Populate the Link Table: 2 columns: [T0_Parent_FK], [T3_child_detail_FK] ------------------------------------------------------------------------
	   SELECT @val_ChildCounter=1
	   
	   WHILE @val_ChildCounter &lt; 3	--Number of child records per parent
	   BEGIN  
		  INSERT INTO dbo.[LNK02_T0_T1] ([T0_Parent_FK], [T3_child_detail_FK]) VALUES (@val_ParentCounter,  @val_ChildCounter + (@val_ParentCounter -1))
		  SELECT @val_ChildCounter=@val_ChildCounter+1
	   END	   
	   
	   
	   
	   SELECT @val_ParentCounter=@val_ParentCounter+1
	     
	END
GO </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Create_Parent_LNK_Child_Tables_With_ForeignKeys_in_The_LNK_table_and_Cascade_Delete</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Create_Parent_LNK_Child_Tables_With_ForeignKeys_in_The_LNK_table_and_Cascade_Delete</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Create_Parent_LNK_Child_Tables_With_ForeignKeys_in_The_LNK_table_and_Cascade_Delete.sql

use DB2_CRM
go



--Drop the Link Table first b/c it has the Foreign key constraints
IF OBJECT_ID('dbo.LNK02_T0_T1') IS NOT NULL
    DROP TABLE dbo.LNK02_T0_T1 

--Drop the child after the LNK table
IF OBJECT_ID('dbo.T3_child_detail') IS NOT NULL
    DROP TABLE dbo.T3_child_detail 
    
--Then drop the parent
IF OBJECT_ID('dbo.T0_Parent') IS NOT NULL
    DROP TABLE dbo.T0_Parent
   
    
--parent table
CREATE TABLE [dbo].[T0_Parent](
 [T0_Parent_PK] [bigint] NOT NULL,
 [ParentData] [varchar](10) NOT NULL,
 CONSTRAINT [T0_Parent$T0_Parent_PK] PRIMARY KEY CLUSTERED 
    ([T0_Parent_PK] ASC)
)
GO
-- child table
CREATE TABLE [dbo].[T3_child_detail](
 [T3_child_detail_PK] [bigint] NOT NULL,
 --[T0_Parent_FK] [bigint] NULL,
 [ChildData] [varchar](10) NULL,
 CONSTRAINT [T3_child_detail$T3_child_detail_PK] PRIMARY KEY CLUSTERED 
    ([T3_child_detail_PK] ASC)
)
GO

-- Link table
CREATE TABLE [dbo].[LNK02_T0_T1](
 [LNK02_PK] [int] IDENTITY(1,1) NOT NULL,
 [T0_Parent_FK] [bigint] NULL,
 [T3_child_detail_FK] [bigint] NULL, 
 --[ChildData] [varchar](10) NULL,
 CONSTRAINT [LNK02_T0_T1$LNK02_PK] PRIMARY KEY CLUSTERED 
    ([LNK02_PK] ASC)
)
GO
-- foreign key constraints
ALTER TABLE [dbo].[LNK02_T0_T1]  WITH CHECK 
	ADD CONSTRAINT [LNK02_T0_T1$T0_Parent_FK] FOREIGN KEY([T0_Parent_FK])
		REFERENCES [dbo].[T0_Parent] ([T0_Parent_PK])
		ON DELETE CASCADE						--&lt;=====  here is the Delete Cascade on the LNK table
GO
ALTER TABLE [dbo].[LNK02_T0_T1]  WITH CHECK 
	ADD CONSTRAINT [LNK02_T0_T1$T3_child_detail_FK] FOREIGN KEY([T3_child_detail_FK])
		REFERENCES [dbo].[T3_child_detail] ([T3_child_detail_PK])
		ON DELETE CASCADE						--&lt;=====  here is the Delete Cascade on the LNK table
GO


-- data load
DECLARE @val_ParentCounter BIGINT
DECLARE @val_ChildCounter BIGINT

SELECT @val_ParentCounter=1

WHILE @val_ParentCounter &lt; 10		-- Number of parent records
	BEGIN 
	
	 
		-- Populate the Parent: 2 columns: [T0_Parent_PK], [ParentData] ------------------------------------------------------------------------
	   INSERT INTO dbo.[T0_Parent] VALUES(@val_ParentCounter,'TEST' + CAST(@val_ParentCounter AS VARCHAR))
	   
	   
	   
	   
	   -- Populate the Child : 2 columns:[T3_child_detail_PK], [ChildData] ------------------------------------------------------------------------
	   SELECT @val_ChildCounter=1
	   
	   WHILE @val_ChildCounter &lt; 3	--Number of child records per parent
	   BEGIN  
		  INSERT INTO dbo.[T3_child_detail] VALUES ((@val_ParentCounter*100000)+@val_ChildCounter,  'TEST' + CAST(@val_ParentCounter AS VARCHAR))
		  SELECT @val_ChildCounter=@val_ChildCounter+1
	   END
	   
	   
	   
	   
	   -- Populate the Link Table: 2 columns: [T0_Parent_FK], [T3_child_detail_FK] ------------------------------------------------------------------------
	   SELECT @val_ChildCounter=1
	   
	   WHILE @val_ChildCounter &lt; 3	--Number of child records per parent
	   BEGIN  
		  INSERT INTO dbo.[LNK02_T0_T1] ([T0_Parent_FK], [T3_child_detail_FK]) VALUES (@val_ParentCounter,     (@val_ParentCounter*100000)+@val_ChildCounter   )
		  SELECT @val_ChildCounter=@val_ChildCounter+1
	   END	   
	   
	   
	   
	   SELECT @val_ParentCounter=@val_ParentCounter+1
	     
	END
GO </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CreateTable_UnionAllRecords_then_INSERT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CreateTable_UnionAllRecords_then_INSERT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- in vs exists from: https://weblogs.sqlteam.com/mladenp/archive/2007/05/18/60210.aspx
------------------------------------------------------------------
-- Prepare tables and data
------------------------------------------------------------------
CREATE TABLE t1 (id INT, title VARCHAR(20), someIntCol INT)
GO
CREATE TABLE t2 (id INT, t1Id INT, someData VARCHAR(20))
GO

INSERT INTO t1
SELECT 1, 'title 1', 5 UNION ALL
SELECT 2, 'title 2', 5 UNION ALL
SELECT 3, 'title 3', 5 UNION ALL
SELECT 4, 'title 4', 5 UNION ALL
SELECT null, 'title 5', 5 UNION ALL
SELECT null, 'title 6', 5

INSERT INTO t2
SELECT 1, 1, 'data 1' UNION ALL
SELECT 2, 1, 'data 2' UNION ALL
SELECT 3, 2, 'data 3' UNION ALL
SELECT 4, 3, 'data 4' UNION ALL
SELECT 5, 3, 'data 5' UNION ALL
SELECT 6, 3, 'data 6' UNION ALL
SELECT 7, 4, 'data 7' UNION ALL
SELECT 8, null, 'data 8' UNION ALL
SELECT 9, 6, 'data 9' UNION ALL
SELECT 10, 6, 'data 10' UNION ALL
SELECT 11, 8, 'data 11'

------------------------------------------------------------------
-- we want to get all data in t1 that has a child row in t2
------------------------------------------------------------------

-- join gives us more rows than we need, because it joins to every child row
SELECT    t1.* 
FROM    t1 
        JOIN t2 ON t1.id = t2.t1Id
-- distinct would solve that but it's not pretty nor efficient
SELECT    DISTINCT t1.* 
FROM    t1 
        JOIN t2 ON t1.id = t2.t1Id

-- now this is a weird part where someIntCol is a column in t1 
-- but the parser doesn't seem to mind that
SELECT    t1.* 
FROM    t1 
WHERE    t1.id IN (SELECT someIntCol FROM t2)

-- here in and exists both get correct results
SELECT    t1.* 
FROM    t1 
WHERE    t1.id IN (SELECT t1id FROM t2)

SELECT    t1.* 
FROM    t1 
WHERE    exists (SELECT * FROM t2 WHERE t1.id = t2.t1id)

------------------------------------------------------------------
-- we want to get all data in t1 that doesn't have a child row in t2
------------------------------------------------------------------

-- join gives us the correct result
SELECT    t1.* 
FROM    t1 
        LEFT JOIN t2 ON t1.id = t2.t1Id
WHERE    t2.id IS NULL

-- IN doesn't get correct results.
-- That's because of how IN treats NULLs and the Three-valued logic
-- NULL is treated as an unknown, so if there's a null in the t2.t1id 
-- NOT IN will return either NOT TRUE or NOT UNKNOWN. And neither can be TRUE.
-- when there's a NULL in the t1id column of the t2 table the NOT IN query will always return an empty set. 
SELECT    t1.* 
FROM    t1 
WHERE    t1.id NOT IN (SELECT t1id FROM t2)

-- NOT EXISTS gets correct results
SELECT    t1.* 
FROM    t1 
WHERE    NOT EXISTS (SELECT * FROM t2 WHERE t1.id = t2.t1id)
GO

DROP TABLE t2
DROP TABLE t1</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Loop_TempTableWithIdentityColumn</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Loop_TempTableWithIdentityColumn</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Loop_TempTableWithIdentityColumn
https://searchsqlserver.techtarget.com/tip/Avoid-cursors-in-SQL-Server-with-these-methods-to-loop-over-records
--we will use a temp table with an identity column added to allow for row-by-row selection. 
--If you're performing an INSERT/UPDATE/DELETE, be sure to use the explicit transactions. 
--This vastly reduces the load on your log file by committing per loop, 
--	and it prevents huge rollbacks in the case of failur

SET NOCOUNT ON

DECLARE @i INT --iterator
DECLARE @iRwCnt INT --rowcount
DECLARE @sValue VARCHAR(100)

SET @i = 1 --initialize

CREATE TABLE #tbl (
	ID INT identity(1, 1),
	Value VARCHAR(100)
	)

INSERT INTO #tbl (Value)
SELECT name
FROM master..sysdatabases(NOLOCK)

SET @iRwCnt = @@ROWCOUNT --SCOPE_IDENTITY() would also work

CREATE CLUSTERED INDEX idx_tmp ON #tbl (ID)
	WITH FILLFACTOR = 100

/*

Always do this after the insert, 
	since it's faster to add the index in bulk than to update the index as you write into the temp table. 
	Since you know the data in this column, you can set the fill factor to 100% to get the best read times.

*/
WHILE @i &lt;= @iRwCnt
BEGIN
	SELECT @sValue = Value
	FROM #tbl
	WHERE ID = @i

	--begin tran
	PRINT 'My Value is ' + @sValue --replace with your operations on this value
		--commit tran

	SET @i = @i + 1
END

DROP TABLE #tble.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Regex_Data_into_TABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Regex_Data_into_TABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>CREATE TABLE alphareg(
   Alphabetic VARCHAR(8000)
)
 
INSERT INTO alphareg 
VALUES ('Two plus two equals four.')
   , ('But in Rome we must toe the line of fashion, spending beyond our means, and often on borrowed credit.')
   , ('Most dogs sleep 21 hours a day.')
   , ('2')
   , ('We were going to work on the project together, but he had to leave for basic training early.')
   , ('This SENTENCE is NOT written weLl.') 
   , ('Or as Alexander Suvorov would say, "When the training is hard, the fighting is easy."')
   , ('1812! The year of invasions.  Let me tell ya''.') 
   , ('This SENTENCE is NOT written weLl.') 
   , ('A')
   , ('b')
   , ('oooh, this isn''t written WRIGHT in several ways')
   , ('BD')
   , ('As he said this, Cupid sneezed approval on the left as before on the right.')
   , ('I like adverbs.')
   , ('Five?')
   , ('I''m going to the store right now.')
   , ('TWO')
   , ('"Yes"')
   , ('willful waste makes woeful waste')
 
SELECT *
FROM alphareg </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Simulate_a_Join</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Simulate_a_Join</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--Create data for Join data
  -------------------------------------- 
USE OBH_DATA_REVIEW
IF OBJECT_ID ('Archive_1', 'U') IS NOT NULL
DROP TABLE dbo.Archive_1;
 
CREATE TABLE dbo.Archive_1  -- target
(
  Provider_ID_1 INT NOT NULL PRIMARY KEY,
  Provider_Name_1 NVARCHAR(100) NOT NULL,
  JUNK INT NOT NULL
);
IF OBJECT_ID ('Archive_2', 'U') IS NOT NULL
DROP TABLE dbo.Archive_2;
 
CREATE TABLE dbo.Archive_2  -- source
(
  Provider_ID_2 INT NOT NULL PRIMARY KEY,
  Provider_Name_2 NVARCHAR(100) NOT NULL,
  HoursWorked INT NOT NULL

);
INSERT Archive_1 VALUES
  (1, 'joie', 6),
  (2, 'gale', 3),
  (3, 'ann', 0),
  (5, 'Jane Eyre', 0),
  (6, 'sam', 0),
  (8, 'Slaughterhouse Five', 4);
INSERT Archive_2 VALUES
  (1, 'joie', 3),
  (3, 'ann', 0),
  (4, 'Gone with the Wind', 4),
  (5, 'Jane Eyre', 5),
  (7, 'josephene', 8);
  
  --------------------------------------  
--  TEst the join data
  -------------------------------------- 
With CTE_Main
AS
(
Select *
From
	Archive_1 L
	LEFT OUTER JOIN
	Archive_2 R
	ON L.Provider_ID_1 = R.Provider_ID_2
)

SELECT *
From CTE_Main
Where HoursWorked is null</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TEST_DATA_simulation</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>with_a_Table_Variable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TEST_DATA_simulation</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>with_a_Table_Variable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>declare @TestData table (ID int, sku char(6), product varchar(15))
insert into @TestData values (1 ,  'FOO-23'      ,'Orange')
insert into @TestData values (2 ,  'BAR-23'      ,'Orange')
insert into @TestData values (3 ,  'FOO-24'      ,'Apple')
insert into @TestData values (4 ,  'FOO-25'      ,'Orange')

--basically the same as @Aaron Alton's answer:
SELECT
    dt.ID, dt.SKU, dt.Product
    FROM (SELECT
              ID, SKU, Product, ROW_NUMBER() OVER (PARTITION BY PRODUCT ORDER BY ID) AS RowID
              FROM @TestData
              WHERE  SKU LIKE 'FOO-%'
         ) AS dt
    WHERE dt.RowID=1
    ORDER BY dt.ID</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TimeZone_DaylightSavingsTime_UTC_GMT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Create_DayLightSavingsCalendar_byYear</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TimeZone_DaylightSavingsTime_UTC_GMT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Create_DayLightSavingsCalendar_byYear</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Create_DayLightSavingsCalendar_byYear

https://stackoverflow.com/questions/33444328/t-sql-check-if-a-given-date-is-in-daylight-savings-or-not

https://www.mssqltips.com/sqlservertip/3173/handle-conversion-between-time-zones-in-sql-server--part-1/

--a calendar table with one row per year, where each year has a DST start and a DST end expressed
-- in both UTC and the local time (more on this below).

DST = Daylight Savings Time

--For the Eastern time zone, in the Spring, we move from 2 AM to 3 AM local time, at 7 AM UTC ("Spring forward"). 
--And in the Fall, we move from 2 AM to 1 AM local time, at 6 AM UTC ("Fall back"). 

use RiskMngt
go

Create Table [Reporting].[DayLightSavingsCalendar_byYear]
(
    Year            Int             Primary Key,
    UTC_DST_Start   SmallDateTime   Not Null,
    UTC_DST_End     SmallDateTime   Not Null,
    PT_DST_Start    As  Convert(SmallDateTime, DateAdd(Hour, -7, UTC_DST_Start)),
    PT_DST_End      As  Convert(SmallDateTime, DateAdd(Hour, -8, UTC_DST_End))
);
Go

Set DateFirst 7;
Go

;With Tally (Number) As
(
    Select  Row_Number() Over (Order By (Select Null)) - 1      Number
    From    (Values (0),(0),(0),(0),(0),(0),(0),(0),(0),(0))    a(n)
    Cross Join (Values (0),(0),(0),(0),(0),(0),(0),(0),(0),(0)) b(n)
    Cross Join (Values (0),(0),(0),(0),(0),(0),(0),(0),(0),(0)) c(n)
),Cte(d,p) As 
(
    Select  Top (Year(GetDate()) - 2000 + 51)
            DateAdd(Year, Number, '20000101'),
            Case When Number &lt; 7 Then 1 Else 0 End
    From    Tally 
    Order By Number
)
Insert  [Reporting].[DayLightSavingsCalendar_byYear]
        (Year, UTC_DST_Start, UTC_DST_End)
Select  Year(d),
        DateAdd(Hour, 7, DateAdd(Day, (7 - DatePart(WeekDay, DateAdd(Month, 2 + p, d)) + 1) % 7
            + (7 * Abs(p - 1)), DateAdd(Month, 2 + p, d))),
        DateAdd(Hour, 6, DateAdd(Day, (7 - DatePart(WeekDay, DateAdd(Month, 10, d)) + 1) % 7
            - (7 * p), DateAdd(Month, 10, d)))
From    Cte
Order By d;


--------------------------


Then check for a given date:

Select Case When Exists
(
    Select  *
    From    [Reporting].[DayLightSavingsCalendar_byYear]
    Where   @DateToCheck Between PT_DST_Start And PT_DST_End
)
Then 'Daylight Savings Time'
Else 'Standard Time'
End As IsDST</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TimeZone_DaylightSavingsTime_UTC_GMT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>cte_with_DaylightSavingsLookup</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TimeZone_DaylightSavingsTime_UTC_GMT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>cte_with_DaylightSavingsLookup</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>CTE and functios to use it
-----------------------------

CREATE TABLE dbo.TZCalendar
(
  [Year]        DATE PRIMARY KEY,
  UTC_DST_Start SMALLDATETIME NOT NULL,
  UTC_DST_End   SMALLDATETIME NOT NULL,
  ET_DST_Start  AS CONVERT(SMALLDATETIME,DATEADD(HOUR, -4, UTC_DST_Start)),
  ET_DST_End    AS CONVERT(SMALLDATETIME,DATEADD(HOUR, -5, UTC_DST_End))
);




use RiskMngt

SET DATEFIRST 7;
;WITH cte(d,p) AS 
(
  -- all the years from 2000 through 50 years after the current year:
  SELECT TOP (YEAR(GETDATE())-2000+51) DATEADD(YEAR,number,'20000101'),
    CASE WHEN number &lt; 7 THEN 1 ELSE 0 END -- year &lt; 2007 = 1, else 0
    FROM [master].dbo.spt_values WHERE [type] = N'P' ORDER BY number
)
--INSERT [RiskMngt][Reporting].[TZCalendar]([Year],UTC_DST_Start,UTC_DST_End)
SELECT d,
 -- First Sunday in April (&lt; 2007) or second Sunday in March (&gt;= 2007):
 DATEADD(HOUR, 7, DATEADD(DAY,(7-DATEPART(WEEKDAY,DATEADD(MONTH,2+p,d))+1)%7
    +(7*ABS(p-1)),DATEADD(MONTH,2+p,d))),
 -- Last Sunday in October (&lt; 2007) or first Sunday in November (&gt;= 2007):
 DATEADD(HOUR, 6, DATEADD(DAY,(7-DATEPART(WEEKDAY,DATEADD(MONTH,10,d))+1)%7
    -(7*p),DATEADD(MONTH,10,d)))
FROM cte
ORDER BY d;



--This creates a table with 65 rows that is a whopping 16 KB in size. 
--As long as there isn't something really strange going on in your system, 
--it should be in memory all of the time (and when it isn't, 
--pulling two pages from disk will be largely inconsequential anyway). The data looks like thi
Year        DTStart           DTEnd             ET_DST_Start      ET_DST_End
----------  ----------------  ----------------  ----------------  ----------------
2000-01-01  2000-04-02 07:00  2000-10-29 06:00  2000-04-02 03:00  2000-10-29 01:00
2001-01-01  2001-04-01 07:00  2001-10-28 06:00  2001-04-01 03:00  2001-10-28 01:00
2002-01-01  2002-04-07 07:00  2002-10-27 06:00  2002-04-07 03:00  2002-10-27 01:00
...
2013-01-01  2013-03-10 07:00  2013-11-03 06:00  2013-03-10 03:00  2013-11-03 01:00
2014-01-01  2014-03-09 07:00  2014-11-02 06:00  2014-03-09 03:00  2014-11-02 01:00
2015-01-01  2015-03-08 07:00  2015-11-01 06:00  2015-03-08 03:00  2012-11-01 01:00


--Now, how do we use this data? 
--We can create two simple functions; one that takes a date/time value in UTC, and converts it to Eastern time, 
--and another that takes a date/time value in Eastern time, 
--and converts it to UTC. There are two edge cases that you need to be aware of:

CREATE FUNCTION dbo.ConvertUTCToLocal
(
  @utc DATETIME
)
RETURNS TABLE
WITH SCHEMABINDING
AS
  RETURN 
  (
    SELECT UTCToLocal = DATEADD(HOUR, CASE 
 
      -- within Daylight Savings Time
      WHEN @utc &gt;= UTC_DST_Start AND @utc &lt; UTC_DST_End 
      THEN -4 
   
      -- within Standard Time
      ELSE -5 END, @utc)
      
    FROM dbo.TZCalendar 
    WHERE CONVERT(DATE,@utc) &gt;= [Year] 
      AND CONVERT(DATE,@utc) &lt; DATEADD(YEAR, 1, [Year])
  );
GO
CREATE FUNCTION dbo.ConvertLocalToUTC
(
  @local DATETIME
)
RETURNS TABLE
WITH SCHEMABINDING
AS
  RETURN 
  (
    SELECT LocalToUTC = DATEADD(HOUR, CASE
      -- account for the "skipped" hour that never happened
      WHEN @local &gt;= DATEADD(HOUR,-1,ET_DST_Start)
       AND @local &lt; ET_DST_Start THEN NULL
    
      -- within Daylight Saving Time
      WHEN @local &gt;= ET_DST_Start 
       AND @local &lt; ET_DST_End THEN 4 
   
      -- within Standard Time 
      ELSE 5 END, @local)
      
    FROM dbo.TZCalendar 
    WHERE CONVERT(DATE,DATEADD(HOUR, -5, @local)) &gt;= [Year] 
      AND CONVERT(DATE,DATEADD(HOUR, -5, @local)) &lt; DATEADD(YEAR, 1, [Year])
  );
GO


--And we can use these functions in the following way. 
--I've purposely used date values that brush against our edge cases in one direction or the other.

DECLARE @x TABLE(ID INT PRIMARY KEY, SourceDateTime DATETIME);
INSERT @x(ID, SourceDateTime) VALUES (1, '20131231 23:59'),
  (2, '20140101 00:01'),(3, '20140309 01:59'),(4, '20140309 02:00'),
  (5, '20140309 06:59'),(6, '20140309 07:00'),(7, '20140601 00:00'),
  (8, '20141102 01:59'),(9, '20141102 02:00'),(10,'20141102 02:30'),
  (11,'20141102 03:00'),(12,'20141102 05:59'),(13,'20141102 06:59'),
  (14,'20141102 07:00'),(15,'20141231 18:59'),(16,'20141231 19:01');
SELECT * FROM @x AS x 
CROSS APPLY dbo.ConvertUTCToLocal(x.SourceDateTime) AS l;

--Results of the conversion from UTC to local time:</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TimeZone_DaylightSavingsTime_UTC_GMT</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>function_ConvertUTCToLocal__ConvertLocalToUTC</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TimeZone_DaylightSavingsTime_UTC_GMT</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>function_ConvertUTCToLocal__ConvertLocalToUTC</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
https://www.mssqltips.com/sqlservertip/3173/handle-conversion-between-time-zones-in-sql-server--part-1/


use RiskMngt
go

Create Table [Reporting].[DayLightSavingsCalendar_byYear]
(
    Year            Int             Primary Key,
    UTC_DST_Start   SmallDateTime   Not Null,
    UTC_DST_End     SmallDateTime   Not Null,
    PT_DST_Start    As  Convert(SmallDateTime, DateAdd(Hour, -7, UTC_DST_Start)),
    PT_DST_End      As  Convert(SmallDateTime, DateAdd(Hour, -8, UTC_DST_End))
);
Go

Set DateFirst 7;
Go

;With Tally (Number) As
(
    Select  Row_Number() Over (Order By (Select Null)) - 1      Number
    From    (Values (0),(0),(0),(0),(0),(0),(0),(0),(0),(0))    a(n)
    Cross Join (Values (0),(0),(0),(0),(0),(0),(0),(0),(0),(0)) b(n)
    Cross Join (Values (0),(0),(0),(0),(0),(0),(0),(0),(0),(0)) c(n)
),Cte(d,p) As 
(
    Select  Top (Year(GetDate()) - 2000 + 51)
            DateAdd(Year, Number, '20000101'),
            Case When Number &lt; 7 Then 1 Else 0 End
    From    Tally 
    Order By Number
)
Insert  [Reporting].[DayLightSavingsCalendar_byYear]		--&lt;============================== Populate the table
        (Year, UTC_DST_Start, UTC_DST_End)
Select  Year(d),
        DateAdd(Hour, 7, DateAdd(Day, (7 - DatePart(WeekDay, DateAdd(Month, 2 + p, d)) + 1) % 7
            + (7 * Abs(p - 1)), DateAdd(Month, 2 + p, d))),
        DateAdd(Hour, 6, DateAdd(Day, (7 - DatePart(WeekDay, DateAdd(Month, 10, d)) + 1) % 7
            - (7 * p), DateAdd(Month, 10, d)))
From    Cte
Order By d;


--------------------------

CREATE FUNCTION Reporting.ConvertUTCToLocal
(
  @utc DATETIME
)
RETURNS TABLE
WITH SCHEMABINDING
AS
  RETURN 
  (
    SELECT UTCToLocal = DATEADD(HOUR, CASE 
 
      -- within Daylight Savings Time
      WHEN @utc &gt;= UTC_DST_Start AND @utc &lt; UTC_DST_End 
      THEN -4 
   
      -- within Standard Time
      ELSE -5 END, @utc)
      
    FROM [Reporting].[DayLightSavingsCalendar_byYear] 
    WHERE CONVERT(DATE,@utc) &gt;= [Year] 
      AND CONVERT(DATE,@utc) &lt; DATEADD(YEAR, 1, [Year])
  );
GO
CREATE FUNCTION Reporting.ConvertLocalToUTC
(
  @local DATETIME
)
RETURNS TABLE
WITH SCHEMABINDING
AS
  RETURN 
  (
    SELECT LocalToUTC = DATEADD(HOUR, CASE
      -- account for the "skipped" hour that never happened
      WHEN @local &gt;= DATEADD(HOUR,-1,ET_DST_Start)
       AND @local &lt; ET_DST_Start THEN NULL
    
      -- within Daylight Saving Time
      WHEN @local &gt;= ET_DST_Start 
       AND @local &lt; ET_DST_End THEN 4 
   
      -- within Standard Time 
      ELSE 5 END, @local)
      
    FROM [Reporting].[DayLightSavingsCalendar_byYear] 
    WHERE CONVERT(DATE,DATEADD(HOUR, -5, @local)) &gt;= [Year] 
      AND CONVERT(DATE,DATEADD(HOUR, -5, @local)) &lt; DATEADD(YEAR, 1, [Year])
  );
GO

-------------------------------------------------------------------------</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Trace</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CreateAndStart_a_Trace</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Trace</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CreateAndStart_a_Trace</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--The first script,
--usp_startTrace, is shown in Listing 7.11 and is used to initiate
--the customizable trace. This stored procedure handles all the tasks of setting up
--the tracing events, creating the trace file, setting up filters and starting the actual
--trace. The script is set up to look at five different trace events, and these happen
--to be the same default events that Profiler monitors, which are: 
--• Login Events
--• Logout Events
--• RPC Completion Events
--• SQL Batch Completion Events
--• SQL Batch Start Events 
--The script first looks to see if a trace with the name defined is already running.
--This is done by querying the central data storage server. This central storage is a
--linked server that has a database with the tables required to store and query this
--information. Again, the script files to create this database on your linked server are
--included in the code download to this book. 
--Once the trace name has been checked, the script sets up a trace that matches the
--parameters you have supplied. This includes the ability to filter any of the trace
--event data columns with a keyword. The most common filter use will be on the
--text data column, which holds the T-SQL code run by a user. 
--Finally, the script stores the trace information in the central auditing database for
--future use. 
///////////////////
--Remember that the structure of the
--trace_data table in version-dependent, and
--the one shown in Listing 7.11 is specific to SQL Server 2005 (the SQL 2000
--equivalent is in the download). The central storage database can house both 2000
--and 2005 data, but will use different tables depending on the version. The stored
--procedures are also version dependant and are respectively named. The reason for
--the slight difference is that the two versions handle trace data differently and have
--slightly differing schema
///////////////////

USE [msdb]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

/*
   Procedure Name : usp_startTrace
   -------------------------------
   Parameter 1 : traceName - Unique identifier of trace [Req]
   Parameter 2 : traceFile - Physical file to hold trace data
while running [Req]
   Parameter 3 : maxFileSize - Maximum size that traceFile can
grow to [Default: 5MB]
   Parameter 4 : filterColumn - Trace event data column to
filter results on [Default: 0]
   Parameter 5 : filterKeyword - Keyword used when filterColumn
is defined [Default: NULL]
*/
CREATE PROCEDURE [dbo].[usp_startTrace]
   @traceName      NVARCHAR(50),
   @traceFile      NVARCHAR(50),
   @maxFileSize   BIGINT = 5,
   @filterColumn   INT = 0,
   @filterKeyword   NVARCHAR(50) = NULL
AS

   SET NOCOUNT ON

   -- Test for trace existence in the Trace_IDs table, alert
user if trace is invalid
   -- Change linked server name here
   IF EXISTS (
      SELECT * FROM MYSERVER123.DBA_Info.dbo.Trace_IDs
      WHERE (TraceName = @traceName OR TraceFile = @traceFile)
        AND TraceServer = SERVERPROPERTY('ServerName')
   )
   BEGIN
      PRINT('Trace ' + @traceName + ' already exsists or the
file is in use, please choose another name/file')
      RETURN
   END

   /*
      Variable Declaration
      --------------------
      traceError - Will hold return code from sp_trace_create
to validate trace creation
      TraceID - Will hold the system ID of the newly created
trace
      on - Used byb sp_trace_setevent to turn on data columns
for particular events
   */
   DECLARE   @traceError   INT,
         @TraceID   INT,
         @on         BIT
      SET @on = 1

   -- Create the trace and store the output in traceError, then
test traceError for failure
   -- and alert the user if the trace cannot be started
   EXEC @traceError = sp_trace_create @TraceID output, 0,
@traceFile, @maxFileSize, NULL 
   
   IF @traceError &lt;&gt; 0
   BEGIN
      PRINT('Trace could not be started: ' + @traceError)
      RETURN
   END

   -- Add events that we want to collect data on for the trace
   -- Audit Login events (14)
   exec sp_trace_setevent @TraceID, 14, 1, @on
   exec sp_trace_setevent @TraceID, 14, 9, @on
   exec sp_trace_setevent @TraceID, 14, 6, @on
   exec sp_trace_setevent @TraceID, 14, 10, @on
   exec sp_trace_setevent @TraceID, 14, 14, @on
   exec sp_trace_setevent @TraceID, 14, 11, @on
   exec sp_trace_setevent @TraceID, 14, 12, @on
   -- Audit Logout events (15)
   exec sp_trace_setevent @TraceID, 15, 15, @on
   exec sp_trace_setevent @TraceID, 15, 16, @on
   exec sp_trace_setevent @TraceID, 15, 9, @on
   exec sp_trace_setevent @TraceID, 15, 13, @on
   exec sp_trace_setevent @TraceID, 15, 17, @on
   exec sp_trace_setevent @TraceID, 15, 6, @on
   exec sp_trace_setevent @TraceID, 15, 10, @on
   exec sp_trace_setevent @TraceID, 15, 14, @on
   exec sp_trace_setevent @TraceID, 15, 18, @on
   exec sp_trace_setevent @TraceID, 15, 11, @on
   exec sp_trace_setevent @TraceID, 15, 12, @on
   -- ExistingConnection events (17)
   exec sp_trace_setevent @TraceID, 17, 12, @on
   exec sp_trace_setevent @TraceID, 17, 1, @on
   exec sp_trace_setevent @TraceID, 17, 9, @on
   exec sp_trace_setevent @TraceID, 17, 6, @on
   exec sp_trace_setevent @TraceID, 17, 10, @on
   exec sp_trace_setevent @TraceID, 17, 14, @on
   exec sp_trace_setevent @TraceID, 17, 11, @on
   -- RPC:Completed events (10)
   exec sp_trace_setevent @TraceID, 10, 15, @on
   exec sp_trace_setevent @TraceID, 10, 16, @on
   exec sp_trace_setevent @TraceID, 10, 1, @on
   exec sp_trace_setevent @TraceID, 10, 9, @on
   exec sp_trace_setevent @TraceID, 10, 17, @on
   exec sp_trace_setevent @TraceID, 10, 10, @on
   exec sp_trace_setevent @TraceID, 10, 18, @on
   exec sp_trace_setevent @TraceID, 10, 11, @on
   exec sp_trace_setevent @TraceID, 10, 12, @on
   exec sp_trace_setevent @TraceID, 10, 13, @on
   exec sp_trace_setevent @TraceID, 10, 6, @on
   exec sp_trace_setevent @TraceID, 10, 14, @on
   -- SQL:BatchCompleted events (12)
   exec sp_trace_setevent @TraceID, 12, 15, @on
   exec sp_trace_setevent @TraceID, 12, 16, @on
   exec sp_trace_setevent @TraceID, 12, 1, @on
   exec sp_trace_setevent @TraceID, 12, 9, @on
   exec sp_trace_setevent @TraceID, 12, 17, @on
   exec sp_trace_setevent @TraceID, 12, 6, @on
   exec sp_trace_setevent @TraceID, 12, 10, @on
   exec sp_trace_setevent @TraceID, 12, 14, @on
   exec sp_trace_setevent @TraceID, 12, 18, @on
   exec sp_trace_setevent @TraceID, 12, 11, @on
   exec sp_trace_setevent @TraceID, 12, 12, @on
   exec sp_trace_setevent @TraceID, 12, 13, @on
   -- SQL:BatchStarting events (13)
   exec sp_trace_setevent @TraceID, 13, 12, @on
   exec sp_trace_setevent @TraceID, 13, 1, @on
   exec sp_trace_setevent @TraceID, 13, 9, @on
   exec sp_trace_setevent @TraceID, 13, 6, @on
   exec sp_trace_setevent @TraceID, 13, 10, @on
   exec sp_trace_setevent @TraceID, 13, 14, @on

   -- If a filter has been used, setup the filter column
   -- and the keyword using sp_trace_setfilter
   IF @filterColumn &gt; 0
   BEGIN
      EXEC sp_trace_setfilter @traceID, @filterColumn, 0, 6,
@filterKeyword
   END

   -- Set the trace to status 1, running
   EXEC sp_trace_setstatus @TraceID, 1

   -- Log all needed trace information in the Trace_IDs table using the linked repository server
   -- Change linked server name here
   INSERT INTO MYSERVER123.DBA_Info.dbo.Trace_IDs 
      ( TraceName, TraceID, TraceFile, TraceServer )
   VALUES
      ( @traceName, @TraceID, @traceFile,
CONVERT(nvarchar(128), SERVERPROPERTY('ServerName')) )
   -- Notify user of trace creation
   PRINT('Trace Started')
   SET NOCOUNT OFF
   
GO </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Trace</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Stop_and_SaveResultsFromExistingTrace</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Trace</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Stop_and_SaveResultsFromExistingTrace</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--The second script,
--usp_stopTrace, is shown in Listing 7.12 and uses the data
--stored about the trace to archive the data and to close the trace after completion. 

--The procedure takes only one parameter,
--traceName, which it uses to query the
--central server to retrieve all of the data that was stored by the
--usp_startTrace
--script. This information includes the name, trace id and trace file. Once the data
--has been received, the trace is stopped and the records from the
--trace_data
--table are archived into the
--trace_archive table. The new trace file is then
--pushed into the
--trace_data table. So, you can always find the newest trace data
--in the
--trace_data table and any older trace information in the trace_archive
--table. 
--The trace file is then deleted from the server, via
--xp_cmdshell, and the trace
--identity is removed from the central repository to free up the trace name and id
--for future use. 

USE [msdb]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

/*
   Procedure Name : usp_stopTrace
   -------------------------------
   Parameter 1 : traceName - Unique identifier of trace to be
stopped [Req]
*/
CREATE PROCEDURE [dbo].[usp_stopTrace]
   @traceName NVARCHAR(50)
AS

   SET NOCOUNT ON
   
   /*
      Variable Declaration
      --------------------
      traceID - Will hold the ID of the trace that will be
stopped and archived
      traceFile - The physical file to export data from
      command - Variable to hold the command to clean the
traceFile from the server
   */
   DECLARE @traceID INT,
         @traceFile NVARCHAR(100), 
         @command NVARCHAR(150)
   
   -- Test for the trace via name in the repository, if it
exsists proccess it, if not alert the user
   -- Change linked server name here
   IF EXISTS (
      SELECT * FROM MYSERVER123.DBA_Info.dbo.Trace_IDs
       WHERE TraceName = @traceName
         AND TraceServer = SERVERPROPERTY('ServerName')
   )
   BEGIN
      -- Gather the traceID and traceFile from the respository
      -- Change linked server name here      
      SET @traceID   = (SELECT TraceID FROM
MYSERVER123.DBA_Info.dbo.Trace_IDs WHERE TraceName = @traceName
AND TraceServer = SERVERPROPERTY('ServerName'))
      -- Change linked server name here
      SET @traceFile = (SELECT TraceFile FROM
MYSERVER123.DBA_Info.dbo.Trace_IDs WHERE TraceName = @traceName
AND TraceServer = SERVERPROPERTY('ServerName'))

      -- Set the status of the trace to inactive, then remove
the trace from the server
      EXEC sp_trace_setstatus @traceID, 0
      EXEC sp_trace_setstatus @traceID, 2

      -- Archive the older trace data and remove all records to
make room for the new trace data
      -- Change linked server name here
      INSERT INTO MYSERVER123.DBA_Info.dbo.trace_archive SELECT
* FROM MYSERVER123.DBA_Info.dbo.trace_table
      
      -- Change linked server name here
      DELETE FROM MYSERVER123.DBA_Info.dbo.trace_table
      
      -- Change linked server name here
      INSERT INTO MYSERVER123.DBA_Info.dbo.trace_table SELECT *
FROM ::fn_trace_gettable(@traceFile + '.trc', default)

      -- Remove the existing trace file for future use
      SET @command = 'DEL ' + @traceFile + '.trc'
      EXEC xp_cmdshell @command
      
      -- Delete the trace information from the repository
      -- Change linked server name here
      DELETE FROM MYSERVER123.DBA_Info.dbo.Trace_IDs WHERE
TraceName = @traceName AND TraceServer =
SERVERPROPERTY('ServerName')
      
      -- Alert the user that the trace has been stopped and
archived
      PRINT('Trace ' + @traceName + ' Stopped and Archived') 
      
      RETURN
   END
   
   -- Alert the user that the trace was not found in the
repository
   PRINT('Trace ' + @traceName + ' Not Found')
   
   SET NOCOUNT OFF

GO                 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Transaction</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name> StoredProcedure_With_Transaction</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Transaction</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name> StoredProcedure_With_Transaction</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--StoredProcedure_With_Transaction



CREATE PROCEDURE up_parmins_employer_information (
	@Current_Employer_ID INT,
	@Current_Employer_Name VARCHAR(30), 
	@Current_Employer_Area_Code SMALLINT, 
	@Current_Employer_Phone_Number INT, 
	@Years_At_Current_Employer TINYINT,
	@Job_Title VARCHAR(30), 
	@Previous_Employer_ID INT, 
	@Previous_Employer_Name VARCHAR(30), 
	@Previous_Employer_Area_Code SMALLINT,
	@Previous_Employer_Phone_Number INT, 
	@Years_At_Previous_Employer TINYINT,
	@Customer_Information_ID INT OUTPUT, 
	@Message VARCHAR(300) OUTPUT
	) 
	AS

-- ****************************************************************************************
-- Declare variables
-- ****************************************************************************************
DECLARE @Continue				BIT,
	@Name_Required				BIT,
	@Current_Employer_Phone_Number_ID	INT,
	@Previous_Employer_Phone_Number_ID	INT,

--
-- Turn on default value to continue
--
SELECT @Continue = 1

--
-- Set default values
--
SELECT @Customer_Information_ID = 0
SELECT @Message = ''

-- ****************************************************************************************
-- Validate Current Employer ID or Current Employer Name exists
-- ****************************************************************************************
--
-- Check Current Employer ID first
--
IF @Current_Employer_ID IS NULL OR @Current_Employer_ID = 0
	BEGIN
	--
	-- Current Employer Name is required
	--
	SELECT @Name_Required = 1
	END
ELSE
	BEGIN
	--
	-- Current employer name is not required
	--
	SELECT @Name_Required = 0
	END

--
-- If @Name_Required = 1 then the Current Employer Name is required
--
IF @Name_Required = 1
	BEGIN
	--
	-- Ensure Current Employer Name is not null or empty
	--
	IF @Current_Employer_Name IS NULL OR 
		DATALENGTH(LTRIM(@Current_Employer_Name)) = 0
		BEGIN
		SELECT @Message = 'Current Employer Name or ID is required. '
		SELECT @Continue = 0
		END
	END

-- ****************************************************************************************
-- Validate current employer area code and phone number
-- ****************************************************************************************
--
-- Validate area code is not null or zero
--
IF @Current_Employer_Area_Code IS NULL OR @Current_Employer_Area_Code = 0
	BEGIN
	SELECT @Message = @Message + 'Current employer area code is a required field. '
	SELECT @Continue = 0
	END
--
-- Validate area code is three digits (as US area codes are always 3 digits)
--
IF DATALENGTH(CAST(@Current_Employer_Area_Code AS VARCHAR(5))) &lt;&gt; 3
	BEGIN
	SELECT @Message = @Message + 'Current employer area code is not valid. '
	SELECT @Continue = 0
	END
--
-- Validate phone number is not null or zero
--
IF @Current_Employer_Phone_Number IS NULL OR @Current_Employer_Phone_Number = 0
	BEGIN
	SELECT @Message = @Message + 'Current employer phone number is a required field. 
'
	SELECT @Continue = 0
	END
--
-- Validate phone number is seven digits
--
IF DATALENGTH(CAST(@Current_Employer_Phone_Number AS VARCHAR(10))) &lt;&gt; 7
	BEGIN
	SELECT @Message = @Message + 'Current employer phone number is not valid. '
	SELECT @Continue = 0
	END

-- ****************************************************************************************
-- Validate current employer years of employment
-- ****************************************************************************************
--
-- Validate years is not null or zero
--
IF @Years_At_Current_Employer IS NULL OR @Years_At_Current_Employer = 0
	BEGIN 
	SELECT @Message = @Message + 'Years at current employer is required. '
	SELECT @Continue = 0
	END
--
-- Validate years is within an acceptable range
--
IF @Years_At_Current_Employer &gt; 50
	BEGIN
	SELECT @Message = @Message + 'Years at current employer is invalid. '
	SELECT @Continue = 0
	END

-- ****************************************************************************************
-- Validate job title
-- ****************************************************************************************
IF @Job_Title IS NULL OR DATALENGTH(LTRIM(@Job_Title)) = 0
	BEGIN
	SELECT @Message = @Message + 'Job title is required. '
	SELECT @Continue = 0
	END

-- ****************************************************************************************
-- Validate Previous Employer ID or Previous Employer Name exists
-- ****************************************************************************************
--
-- If either Previous Employer ID or name exists, perform the validations
--
IF @Previous_Employer_ID  &gt; 0 OR DATALENGTH(LTRIM(@Previous_Employer_Name)) &gt; 0

	BEGIN
	--
	-- Check Previous Employer ID first
	--
	IF @Previous_Employer_ID IS NULL OR @Previous_Employer_ID = 0
		BEGIN
		--
		-- Previous employer name is required
		--
		SELECT @Name_Required = 1
		END
	ELSE
		BEGIN
		--
		-- Previous employer name is not required
		--
		SELECT @Name_Required = 0
		END

	--
	-- If @Name_Required = 1 then the previous employer name is required
	--
	IF @Name_Required = 1
		BEGIN
		--
		-- Ensure previous employer name is not null or empty
		--
		IF @Previous_Employer_Name IS NULL OR 
			DATALENGTH(LTRIM(@Previous_Employer_Name)) = 0
			BEGIN
			SELECT @Message = @Message +
				'Previous employer name or ID has been specified but ' +
				'is not valid. '
			SELECT @Continue = 0
			END
		END
	
	-- ********************************************************************************
	-- Validate previous employer area code and phone number
	-- ********************************************************************************
	--
	-- Validate area code is not null or zero
	--
	IF @Previous_Employer_Area_Code IS NULL OR @Previous_Employer_Area_Code = 
0
		BEGIN
		SELECT @Message = @Message + 'Previous employer area code is a required ' 
+
			'field when a previous employer has been specified. '
		SELECT @Continue = 0
		END
	--
	-- Validate area code is three digits
	--
	IF DATALENGTH(CAST(@Previous_Employer_Area_Code AS VARCHAR(5))) &lt;&gt; 3
		BEGIN
		SELECT @Message = @Message + 'Previous employer area code is not valid. '
		SELECT @Continue = 0
		END
	--
	-- Validate phone number is not null or zero
	--
	IF @Previous_Employer_Phone_Number IS NULL OR 
@Previous_Employer_Phone_number = 0
		BEGIN
		SELECT @Message = @Message + 'Previous employer phone number is a ' +
			'required field when a previous employer has been specified. '
		SELECT @Continue = 0
		END
	--
	-- Validate phone number is seven digits
	--
	IF DATALENGTH(CAST(@Previous_Employer_Phone_Number AS VARCHAR(10))) &lt;&gt; 
7
		BEGIN
		SELECT @Message = @Message + 'Previous employer phone number is not 
valid. '
		SELECT @Continue = 0
		END
	
	-- ********************************************************************************
	-- Validate previous employer years of employment
	-- ********************************************************************************
	--
	-- Validate years is not null or zero
	--
	IF @Years_At_Previous_Employer IS NULL OR @Years_At_Previous_Employer = 0
		BEGIN 
		SELECT @Message = @Message + 'Years at previous employer is required ' +
			'when a previous employer has been specified. '
		SELECT @Continue = 0
		END
	--
	-- Validate years is within an acceptable range
	--
	IF @Years_At_Previous_Employer &gt; 50
		BEGIN
		SELECT @Message = @Message + 'Years at previous employer is invalid. '
		SELECT @Continue = 0
		END
	END

-- ****************************************************************************************
-- All data has been validated, either return to the caller with a bad return and messages
-- or continue on and insert the values
-- ****************************************************************************************
IF @Continue = 0
	BEGIN
	-- 
	-- Return to the caller with a bad return code
	-- the messages are in the @Message output parameter
	--
	RETURN 1
	END
ELSE
	BEGIN
	-- ********************************************************************************
	-- Start a transaction, if any code fails then we back out everything
	-- ********************************************************************************
	BEGIN TRANSACTION Employer_Information

	-- ********************************************************************************
	-- Determine if we are using an existing employer or inserting a new one
	-- ********************************************************************************
	IF @Current_Employer_ID IS NULL OR @Current_Employer_ID = 0
		BEGIN
		--
		-- We are inserting a new current employer
		--
		-- ************************************************************************
		-- Insert the current employer phone number
		-- ************************************************************************
		INSERT INTO Phone_Number_T
			(Area_Code_SI, Phone_Number_IN, Last_Update_DT)
			VALUES(@Current_Employer_Area_Code, 
@Current_Employer_Phone_Number,
				GETDATE())

		--
		-- Check for errors
		--
		IF @@ERROR &lt;&gt; 0
			BEGIN
			--
			-- Rollback the transaction and return to the caller
			--
			ROLLBACK TRANSACTION Employer_Information
			RAISERROR('Insert for current employer phone number failed.',18,1)
			RETURN 99
			END

		--
		-- Get the Phone Number ID just inserted
		--
		SELECT @Current_Employer_Phone_Number_ID = @@IDENTITY

		-- ************************************************************************
		-- Insert the current employer
		-- ************************************************************************
		INSERT INTO Employer_T
			(Phone_Number_ID, Company_Name_VC, Last_Update_DT)
			VALUES(@Current_Employer_Phone_Number_ID, 
@Current_Employer_Name,
				GETDATE())

		--
		-- Check for errors
		--
		IF @@ERROR &lt;&gt; 0
			BEGIN
			--
			-- Rollback the transaction and return to the caller
			--
			ROLLBACK TRANSACTION Employer_Information
			RAISERROR('Insert for current employer failed.',18,1)
			RETURN 99
			END

		--
		-- Get the Employer ID just inserted
		--
		SELECT @Current_Employer_ID = @@IDENTITY
		END

	-- ********************************************************************************
	-- Determine if previous employer information exists
	-- ********************************************************************************
	--
	-- If either Previous Employer ID is null or zero check the Previous Employer Name
	--
	IF @Previous_Employer_ID IS NULL OR @Previous_Employer_ID = 0

		BEGIN
		-- ************************************************************************
		-- Determine if data exists to insert a new employer
		-- ************************************************************************
		IF DATALENGTH(LTRIM(@Previous_Employer_Name)) &gt; 0
			BEGIN
			-- ****************************************************************
			-- Insert the previous employer phone number
			-- ****************************************************************
			INSERT INTO Phone_Number_T
				(Area_Code_SI, Phone_Number_IN, Last_Update_DT)
				VALUES(@Previous_Employer_Area_Code, 
					@Previous_Employer_Phone_Number, GETDATE())

			--
			-- Check for errors
			--
			IF @@ERROR &lt;&gt; 0
				BEGIN
				--
				-- Rollback the transaction and return to the caller
				--
				ROLLBACK TRANSACTION Employer_Information
				RAISERROR('Insert for previous employer phone number 
failed.',
					18,1)
				RETURN 99
				END

			--
			-- Get the Phone Number ID just inserted
			--
			SELECT @Previous_Employer_Phone_Number_ID = @@IDENTITY

			-- ****************************************************************
			-- Insert the previous employer
			-- ****************************************************************
			INSERT INTO Employer_T
				(Phone_Number_ID, Company_Name_VC, Last_Update_DT)
				VALUES(@Previous_Employer_Phone_Number_ID, 
					@Previous_Employer_Name, GETDATE())

			--
			-- Check for errors
			--
			IF @@ERROR &lt;&gt; 0
				BEGIN
				--
				-- Rollback the transaction and return to the caller
				--
				ROLLBACK TRANSACTION Employer_Information
				RAISERROR('Insert for previous employer failed.',18,1)
				RETURN 99
				END

			--
			-- Get the Employer ID just inserted
			--
			SELECT @Previous_Employer_ID = @@IDENTITY
			END

		ELSE

			BEGIN
			--
			-- No previous employment exists, ensure all values are null
			--
			SELECT @Previous_Employer_ID = NULL
			SELECT @Years_At_Previous_Employer = NULL
			END
		END

	-- ********************************************************************************
	-- Now insert the all employment data into the customer information table
	-- ********************************************************************************
	INSERT INTO Customer_Information_T
		(Employer_ID, Years_At_This_Employer_TI, Previous_Employer_ID, 
			Years_At_Previous_Employer_TI, Job_Title_VC, Last_Update_DT)
		VALUES(@Current_Employer_ID, @Years_At_Current_Employer, 
			@Previous_Employer_ID, @Years_At_Previous_Employer, @Job_Title, 
			GETDATE())

	--
	-- Check for errors
	--
	IF @@ERROR &lt;&gt; 0
		BEGIN
		--
		-- Rollback the transaction and return to the caller
		--
		ROLLBACK TRANSACTION Employer_Information
		RAISERROR('Insert of all employment information failed.',18,1)
		RETURN 99
		END

	--
	-- Get the Employer ID just inserted
	--
	SELECT @Customer_Information_ID = @@IDENTITY

	-- ********************************************************************************
	-- We made it to the end so commit the transaction
	-- ********************************************************************************
	COMMIT TRANSACTION Employer_Information

	--
	-- End If statement block
	--
	END

--
-- Return to the caller with a successful return code
--
RETURN 0
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Transaction</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>01_CreateTable_PopulateWithTransaction</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Transaction</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>01_CreateTable_PopulateWithTransaction</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>1] Create Table
2] Transaction to populate the table

////////////////////////////////////////////////////////////////////////////////////////////////////
--1] Create Table

--P_0025_TASK_06_CREATE_TABLE_T200_RiskManagement_TableList_Archive_v2.sql

USE [RiskMngt]
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF OBJECT_ID('Reporting.T200_RiskManagement_TableList_Archive') IS NOT NULL
    DROP TABLE Reporting.T200_RiskManagement_TableList_Archive

go

CREATE TABLE [Reporting].[T200_RiskManagement_TableList_Archive](
	[T200_PK] [int] IDENTITY(1,1) NOT NULL,

	[name] [sysname] NOT NULL,
	[DateScriptWasRun] [datetime] NULL,
	[type] [char](2) NULL,
	[type_description] [varchar](36) NOT NULL,
	[id] [int] NOT NULL,
	[crdate] [datetime] NOT NULL,
	[refdate] [datetime] NOT NULL,
	-------------------------------------
	[CreateRecord_dateTime] [datetime]  NULL,
	[CreateRecord_name] [sysname] NULL,
	[UpdateRecord_dateTime] [datetime] NULL,
	[UpdateRecord_name] [sysname] NULL,
	[T200_RowVersion] [timestamp] NULL,
 CONSTRAINT [T200_RiskManagement_TableList_Archive_$_T200_PK] PRIMARY KEY CLUSTERED 
(
	[T200_PK] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO

------------------ Create Nonclustered Index (not Unique)
--CREATE NONCLUSTERED INDEX [IX_NonClustered_T200_shaw_id] ON [Reporting].[T200_RiskManagement_TableList_Archive]
--([shaw_id] ASC)
--GO
-----------------


ALTER TABLE [Reporting].[T200_RiskManagement_TableList_Archive] ADD  CONSTRAINT [T200_ins_date]  DEFAULT (getdate()) FOR [CreateRecord_dateTime]
GO

ALTER TABLE [Reporting].[T200_RiskManagement_TableList_Archive] ADD  CONSTRAINT [T200_ins_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [CreateRecord_name]
GO

ALTER TABLE [Reporting].[T200_RiskManagement_TableList_Archive] ADD  CONSTRAINT [T200_upd_date]  DEFAULT (getdate()) FOR [UpdateRecord_dateTime]
GO

ALTER TABLE [Reporting].[T200_RiskManagement_TableList_Archive] ADD  CONSTRAINT [T200_upd_name]  DEFAULT (coalesce(suser_sname(),'?')) FOR [UpdateRecord_name]
GO

create trigger [Reporting].[TRG_001_recordChanged_T200] on [RiskMngt].[Reporting].[T200_RiskManagement_TableList_Archive]
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       d.UpdateRecord_dateTime = getdate(),
       d.UpdateRecord_name = (coalesce(suser_sname(),'?'))
    from
       [RiskMngt].[Reporting].T200_RiskManagement_TableList_Archive d join inserted i 
    on 
       d.T200_PK = i.T200_PK;

end

GO

ALTER TABLE [Reporting].[T200_RiskManagement_TableList_Archive] ENABLE TRIGGER [TRG_001_recordChanged_T200]
GO




////////////////////////////////////////////////////////////////////////////////////////////////////
--2] Transaction to populate the table

USE RiskMngt
go

--P_0020_TASK_013_MAINT_01_TableMaintenanceForPatric.sql
--FROM:    P_0020_TASK_013_SQL_01_orig_Shantine_PART_2_A_v0.sql
/*
	************************************************************************************
	NOTE: 
		Transaction:
			1] will set all the records to [Active]=0 in the table
			2] will set all unpopulated [EndDate] records to the date that it is run.
			3] Then append the most recent Mappings, When it appends the mapping it will populate the [StartDate]
	Uses: 
	Created: 04/10/2019
	By: glenn garson
	************************************************************************************
*/
BEGIN TRAN
	BEGIN TRY
		--==============================================================================
		--1] will set all the records to [Active]=0 in the table
		------------------------------------------------------------------------------
		UPDATE [RiskMngt].[dbo].[Txxx_Collector_Queue_Mapping]
		SET [Active] = 0

		--2] will set all unpopulated [EndDate] records to the date that it is run.
		------------------------------------------------------------------------------
		UPDATE [RiskMngt].[dbo].[Txxx_Collector_Queue_Mapping]
		SET [Date_Mapping_END] = getdate()
		WHERE [Date_Mapping_END] is NULL

		--3] Then append the most recent Mappings
		------------------------------------------------------------------------------
		INSERT INTO [dbo].[Txxx_Collector_Queue_Mapping](
			[month],
			[queue],
			[collector],
			[shaw_id],
			[shaw_name],
			[supervisor],
			[Active],
			[Date_Mapping_START]
			)
		select 
				year(getdate())*100+month(getdate()) as [month]
				, assigned_list as [queue]
				,collector_name as [collector]
				,collector_id as shaw_id
				, collector_name as [shaw_name]
				,supr_name as [supervisor]
				,1 as [Active]
				,GETDATE()as [Date_Mapping_START]

		from COLLECT_ETL.dbo.scfxroster
		where left(assigned_list_desc,5) in ('30-59', '30- 5')



		Commit TRAN
		--==============================================================================
END TRY
BEGIN CATCH
    ROLLBACK TRAN   
    SELECT ERROR_MESSAGE ()
END CATCH





////////////////////////////////////////////////////////////////////////////////////////////////////</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Transaction</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>A_Child_SP_with_Transaction</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Transaction</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>A_Child_SP_with_Transaction</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>////// I have not actually tested the failure of this transaction
////// This is the child SP with a transaction
////// 	If it succeeds it returns a 0, otherwise a 1

-- prj_1027_SP_025_Add_T22FK_for_all_Employees_and_T26FK_ForNewPayCheck_GivenT26PK_To_LNK04.sql

-----------------------------------------
/*
-- This SP:
	1] Should be executed in SP: prj_1027_SP_024_Add_PayCheck_To_T26_andCombinedWithEmployee_into_LNK04_v0.sql
	2] Will Get a list of all the T22_PK, corresponding to Employees (bActive=True) at the moment the PayCheck is added to the Database
		use prj_1027_vw_502 to get bActive
	4] Insert the T22_FK, and T26_FK, from the new PayCheck, into LNK04 
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 8/20/2013
	By: glenn garson
	************************************************************************************

*/
SET NOCOUNT ON
use DB2_CRM
go

alter PROCEDURE prj_1027_SP_025_Add_T22FK_for_all_Employees_and_T26FK_ForNewPayCheck_GivenT26PK_To_LNK04(
	@T26_PK_ForNewPayCheck INT
	)
	AS
	
	-- START DEBUGGING SECTION -------------------	
	
	PRINT 'Input @T26_PK_ForNewPayCheck: [' + 	 CAST(@T26_PK_ForNewPayCheck AS varchar(5)) + ']'	

-- END DEBUGGING SECTION -------------------	
	
		
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
--1] Get the T22_PK for all the employees in T22_CCWNC_Employee_AccountingPortal	
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	-- ********************************************************************************
	-- Start a transaction, if any code fails then we back out everything
	-- ********************************************************************************
	BEGIN TRANSACTION LoadEmployeesForNewPayrollDate	
	
;	
		WITH CTE_ONE_ActiveEmployees (T22_FK)
		AS
			(
				select DISTINCT
					T22_PK
				From prj_1027_vw_502_CCWNC_FundingAllocation
				Where bActiveEmployee=1
			),	
		CTE_TWO (T22_FK, T26_FK)
		AS
			(
				select 
					T22_FK,
					@T26_PK_ForNewPayCheck as T26_FK		
				From CTE_ONE_ActiveEmployees
			)	


		Insert [dbo].[LNK04_T22_T26_Employee_Payrolls]
			(
				T22_FK,
				T26_FK
			)
		SELECT
			T22_FK,
			T26_FK
		FROM CTE_TWO
		
	IF @@ERROR &lt;&gt; 0
		BEGIN
			--
			-- Rollback the transaction and return to the caller
			--
			ROLLBACK TRANSACTION LoadEmployeesForNewPayrollDate
			--RAISERROR('Loading employees for the new payroll date to LNK04 failed (prj_1027_SP_025)',18,1)
			RETURN 1 		-- let 0 = Continue, and 1 = Do Not Continue
		END
	ELSE
		BEGIN
			-- ********************************************************************************
			-- Finnish a transaction
			-- ********************************************************************************		
			COMMIT TRANSACTION LoadEmployeesForNewPayrollDate
			RETURN 0	-- let 0 = Continue, and 1 = Do Not Continue
		END
		
			</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Transaction</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>A_Parent_SP_with_Transaction</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Transaction</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>A_Parent_SP_with_Transaction</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>//////The parent has a transaction it in, if it fails it returns '0', otherwise it proceeds
//////Then it calls the child in an EXEC statement



--prj_1027_SP_024_Add_PayCheck_To_T26_andCombinedWithEmployee_into_LNK04_v0.sql
-----------------------------------------
-- This SP will:
--		INSERT INTO T26 one PayCheck record, and return the IDENT_CURRENT for the new record
--		It will also insert a record for every employee combined with this new PayCheck into LNK04
--		runs a SP to Populate LNK04: prj_1027_SP_025_Add_T22FK_for_all_Employees_and_T26FK_ForNewPayCheck_GivenT26PK_To_LNK04
/*
	************************************************************************************
	Created: 8/20/2013
	By: glenn garson
	************************************************************************************

*/

SET NOCOUNT ON
Use DB2_CRM
go

alter PROCEDURE prj_1027_SP_024_Add_PayCheck_To_T26_andCombinedWithEmployee_into_LNK04(
	@Date_Paycheck AS date,
	@Date_PayPeriod_START AS date,
	@Date_PayPeriod_END AS date,
	@Date_UserAccessToTimeCard_START AS date,
	@Date_UserAccessToTimeCard_END AS date,
	@T26_NOTE AS nvarchar(max)
	)
	
	
	AS
	
-- START DEBUGGING SECTION -------------------	
	
			--PRINT '1) Input @NameOfPayCheck: ' + 	 @NameOfPayCheck
			--PRINT '2)Input @T26_PayChecks_Notes: ' +  @T26_PayChecks_Notes
			--PRINT '3)Input @DefaultCompanyPolicy_e27: ' + 	 	CAST(@DefaultCompanyPolicy_e27 AS varchar(5))
															
-- END DEBUGGING SECTION -------------------	
	

-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 0] Declare variables used internally in the Stored Procedure, and set intial values:
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	DECLARE @Continue INT
	DECLARE @T26_FK INT
	SELECT @T26_FK = NULL
	SELECT @Continue = 1	-- let 0 = Continue, and 1 = Do Not Continue

-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 1] INSERT INTO
-- |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	-- ********************************************************************************
	-- Start a transaction, if any code fails then we back out everything
	-- ********************************************************************************
	BEGIN TRANSACTION NewPayrollDate

			INSERT INTO T26_Payroll_Dates
									(
										[Date_Paycheck],
										[Date_PayPeriod_START],
										[Date_PayPeriod_END],
										[Date_UserAccessToTimeCard_START],
										[Date_UserAccessToTimeCard_END],
										[T26_NOTE]											

									)
			VALUES
					(
						@Date_Paycheck,
						@Date_PayPeriod_START,
						@Date_PayPeriod_END,
						@Date_UserAccessToTimeCard_START,
						@Date_UserAccessToTimeCard_END,
						@T26_NOTE
					
					);

	-- ********************************************************************************
	-- Check for Errors
	-- ********************************************************************************
	IF @@ERROR &lt;&gt; 0
		BEGIN
		--
		-- Rollback the transaction and return to the caller
		--
		ROLLBACK TRANSACTION NewPayrollDate
		--RAISERROR('Insert for for Payroll dates to T26 failed (prj_1027_SP_024)',18,1)
		RETURN 0
		END
	ELSE
		BEGIN
			-- ********************************************************************************
			-- Finnish a transaction
			-- ********************************************************************************		
			COMMIT TRANSACTION NewPayrollDate
			SELECT @T26_FK = @@IDENTITY
		END
				
   
	
		

-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	-- let 0 = Continue, and 1 = Do Not Continue
	EXEC @Continue =  prj_1027_SP_025_Add_T22FK_for_all_Employees_and_T26FK_ForNewPayCheck_GivenT26PK_To_LNK04 @T26_FK
	
	IF (@@ERROR = 0) AND (@Continue=0)
		BEGIN
			RETURN @T26_FK
			PRINT 'Returned the PK for the new T26 record, and the new Traing/employees records were successfully inserted into LNK04'
		END
	ELSE
		BEGIN
			PRINT 'Woops! There was an error when the FK was inserted into T26 if it returns a zero (0)'
			RETURN 0					
		END	
-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\					

	
	

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Transaction</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>A_Parent_TEST</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Transaction</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>A_Parent_TEST</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_1027_SP_024_Add_PayCheck_To_T26_andCombinedWithEmployee_into_LNK04_TEST.sql

use DB2_CRM
go
						
							
use DB2_CRM
go

DECLARE @return_status int


exec @return_status = prj_1027_SP_024_Add_PayCheck_To_T26_andCombinedWithEmployee_into_LNK04
							@Date_Paycheck='2013-07-31',
							@Date_PayPeriod_START='2013-07-14',
							@Date_PayPeriod_END='2013-07-27',
							@Date_UserAccessToTimeCard_START='2013-07-29',
							@Date_UserAccessToTimeCard_END='2013-07-31',
							@T26_NOTE='Prior to Database Rollout'


SELECT 'Return Status' = @return_status
GO							


/////// This is what I see if I run it twice, and the unique contraint for the parent SP fails:


Msg 2627, Level 14, State 1, Procedure prj_1027_SP_024_Add_PayCheck_To_T26_andCombinedWithEmployee_into_LNK04, Line 41
Violation of UNIQUE KEY constraint 'UNIQUE_Payroll_Date'. Cannot insert duplicate key in object 'dbo.T26_Payroll_Dates'. The duplicate key value is (2013-07-31).
The statement has been terminated.

(1 row(s) affected)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Transaction</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>BEGIN_END__TRY_CATCH_rollback</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Transaction</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>BEGIN_END__TRY_CATCH_rollback</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--0012_TASK_001_Archive_Step_1_v2.sql

/*--
	************************************************************************************
	NOTE:
		First run this script. If it fails b/c of duplicates then run:

				0012_TASK_001_SQL_01_CheckForDuplicatesAfterUpload.sql
				0012_TASK_001_SQL_02_DeleteDuplicatesAfterUpload.sql

			The script runs as a Transaction, so if it doesn't throw an error 
				it will update the source file: [RiskMngt].[Reporting].[T503_QA_DL4_BookedLoanReview_Step_1]
				and SET [isArchived] = 1
		 
	Uses: 
	Created: 03/15/2019
	By: glenn garson
	************************************************************************************
*/
USE [RiskMngt]
GO
BEGIN TRAN
	BEGIN TRY
		--==============================================================================
		INSERT INTO [RiskMngt].[Reporting].[T503_QA_DL4_BookedLoanReview_Step_1_Archive]

			  (
				  [00____REVIEWER]
				  ,[00____APP_NBR]
				  ,[00____Funding_Owner]
				  ,[00____Change_Logging_Loan_Assistant_to]
				  ,[00____Contract_Funded_by]
				  ,[00____Change_Funding_Loan_Specialist_to]
				  ,[01_Contract_Info___Dealer_Name]
				  ,[02_Contract_Info___Dealer_Address]
				  ,[03_Contract_Info___Applicant_Name]
				  ,[04_Contract_Info___Applicant_Address_Physical]
				  ,[05_Contract_Info___Applicant_Address_Mailing]
				  ,[06_Contract_Info___Applicant_SSN]
				  ,[07_Contract_Info___Applicant_DOB]
				  ,[08_Contract_Info___Co_Applicant_Name]
				  ,[09_Contract_Info___Co_Applicant_Address_Physical]
				  ,[10_Contract_Info___Co_Applicant_Address_Mailing]
				  ,[11_Contract_Info___Co_Applicant_SSN]
				  ,[12_Contract_Info___Co_Applicant_DOB]
				  ,[13_Contract_Info___Contract_Form]
				  ,[14_Contract_Info___Reject]
				  ,[15_Contract_Info___Cure___GAP]
				  ,[16_Contract_Info___Cure___Warranty]
				  ,[17_Contract_Info___Cure___Rate_Mod]
				  ,[18_Contract_Info___Cure__TX_OCCC]
				  ,[19_Contract_Info___Date___Contract]
				  ,[20_Collateral___Collat___Invoice/Bookout_]
				  ,[21_Collateral___Collat___VIN]
				  ,[22_Collateral___Collat___Value]
				  ,[23_GAP___GAP_Collateral]
				  ,[24_GAP___GAP_Term]
				  ,[25_Employment/Income___Applicant_Employer]
				  ,[26_Employment/Income___Applicant_Income_Calculations]
				  ,[27_Employment/Income___Co_Applicant_Employer]
				  ,[28_Employment/Income___Co_Applicant_Income_Calculations]
				  ,[29_Title_Doc____Title_accurate]
				  ,[30_Drivers_License___Applicant_DL]
				  ,[31_Drivers_License___Co_Applicant_DL]
				  ,[32_Other___Stips]
				  ,[33_Dealer_Reserve___Deductions]
				  ,[34_Comments___Comments]
				  ,FundedDate
				  ,[fromExcelWorkBook]
			  )
		--============================================================================
		SELECT
			  [00____REVIEWER]
			  ,[00____APP_NBR]
			  ,[00____Funding_Owner]
			  ,[00____Change_Logging_Loan_Assistant_to]
			  ,[00____Contract_Funded_by]
			  ,[00____Change_Funding_Loan_Specialist_to]
			  ,[01_Contract_Info___Dealer_Name]
			  ,[02_Contract_Info___Dealer_Address]
			  ,[03_Contract_Info___Applicant_Name]
			  ,[04_Contract_Info___Applicant_Address_Physical]
			  ,[05_Contract_Info___Applicant_Address_Mailing]
			  ,[06_Contract_Info___Applicant_SSN]
			  ,[07_Contract_Info___Applicant_DOB]
			  ,[08_Contract_Info___Co_Applicant_Name]
			  ,[09_Contract_Info___Co_Applicant_Address_Physical]
			  ,[10_Contract_Info___Co_Applicant_Address_Mailing]
			  ,[11_Contract_Info___Co_Applicant_SSN]
			  ,[12_Contract_Info___Co_Applicant_DOB]
			  ,[13_Contract_Info___Contract_Form]
			  ,[14_Contract_Info___Reject]
			  ,[15_Contract_Info___Cure___GAP]
			  ,[16_Contract_Info___Cure___Warranty]
			  ,[17_Contract_Info___Cure___Rate_Mod]
			  ,[18_Contract_Info___Cure__TX_OCCC]
			  ,[19_Contract_Info___Date___Contract]
			  ,[20_Collateral___Collat___Invoice/Bookout_]
			  ,[21_Collateral___Collat___VIN]
			  ,[22_Collateral___Collat___Value]
			  ,[23_GAP___GAP_Collateral]
			  ,[24_GAP___GAP_Term]
			  ,[25_Employment/Income___Applicant_Employer]
			  ,[26_Employment/Income___Applicant_Income_Calculations]
			  ,[27_Employment/Income___Co_Applicant_Employer]
			  ,[28_Employment/Income___Co_Applicant_Income_Calculations]
			  ,[29_Title_Doc____Title_accurate]
			  ,[30_Drivers_License___Applicant_DL]
			  ,[31_Drivers_License___Co_Applicant_DL]
			  ,[32_Other___Stips]
			  ,[33_Dealer_Reserve___Deductions]
			  ,[34_Comments___Comments]
			  , dc.FundedDate as FundedDate
			  , [fromExcelWorkBook]
		FROM 
				[RiskMngt].[Reporting].[T503_QA_DL4_BookedLoanReview_Step_1] s1
				INNER JOIN
				[edwCrescent].[dbo].[DimContract] dc
				on s1.[00____APP_NBR] = dc.ClientAppID

		WHERE (
				[00____APP_NBR] &lt;&gt; '0' 
				AND
				isArchived = 0
			   ) 


		UPDATE [RiskMngt].[Reporting].[T503_QA_DL4_BookedLoanReview_Step_1]
		SET isArchived = 1



		Commit TRAN
		--==============================================================================
END TRY
BEGIN CATCH
    ROLLBACK TRAN   
    SELECT ERROR_MESSAGE ()
END CATCH</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Transaction</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Transaction_checks_conditions_has_messages_TryCatch</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Transaction</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Transaction_checks_conditions_has_messages_TryCatch</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--p_0021_SP_002_A_step_2_v0.sql

--===========================================================================
/* 	
 
	DESCIPTION: This checks for empty values in the three fields of zzz_p0021_3_Missing_Providers
					IF there are no missing data the transaction is committed.
					HOWEVER if there is missing data then
					Either delete the records with missing values, or populate the missing values
					

					If there are no missing values, then the 'Missing' providers and their correspoinding data
					are inserted into: [T001_Provider_Information_IDR]

					If you see any records in the results pane, you probably have a problem.
					If the results pane then check the Messages Pane for the message:
						'The transaction was Committed'
						In that case you can proceed to the subsequent steps.
	NOTE: 
			Create:  zzz_p0021_2_NonBillServices_for_IDR
			And generate the list of missing Providers then store in 
			zzz_p0021_3_Missing_Providers 
	Created: 3/17/2012
	By: glenn garson

*/
--===========================================================================

USE Success
GO






DECLARE @ThereAreNullValues BIT
SELECT @ThereAreNullValues = 0

BEGIN TRAN
	BEGIN TRY

		-- 1] ==========================================================================		
		SELECT *
		FROM zzz_p0021_3_Missing_Providers
		WHERE (
				([Providername] is NULL) 
				or 
				(rtrim(ltrim([Providername]))) = ''
			  )

		IF @@ROWCOUNT &lt;&gt; 0
			BEGIN
				PRINT '[Providername] has null, or missing values'
				SELECT @ThereAreNullValues = @ThereAreNullValues + 1
			END
		ELSE
			BEGIN
				PRINT '[Providername] does NOT have null, or missing values'
			END

		-- 2] ==========================================================================		
		SELECT *
		FROM zzz_p0021_3_Missing_Providers
		WHERE rtrim(ltrim([LOCATION])) = ''

		IF @@ROWCOUNT &lt;&gt; 0
			BEGIN
				PRINT '[LOCATION] has null values'
				SELECT @ThereAreNullValues = @ThereAreNullValues + 1
			END
		ELSE
			BEGIN
				PRINT '[LOCATION] does NOT have null values'
			END

		-- 3] ==========================================================================		
		SELECT *
		FROM zzz_p0021_3_Missing_Providers
		WHERE (rtrim(ltrim([Type])) = '')

		IF @@ROWCOUNT &lt;&gt; 0
			BEGIN
				PRINT '[Type] has null values'
				SELECT @ThereAreNullValues = @ThereAreNullValues + 1
			END
		ELSE
			BEGIN
				PRINT '[Type] does NOT have null values'
			END

		-- 4] ==========================================================================


		INSERT INTO T001_Provider_Information_IDR (
													[Providername],
													[LOCATION],
													[Type]
													)
		SELECT 
				[Providername],
				[LOCATION],
				[Type]

		FROM zzz_p0021_3_Missing_Providers

		-- ==========================================================================

		IF @ThereAreNullValues = 0
			BEGIN
				PRINT 'The transaction was Committed'
				COMMIT TRAN
			END
			ELSE
				BEGIN
					PRINT 'The transaction will not be Committed'
					RAISERROR (15600,-1,-1, 'Either delete the records with missing values, or populate the missing values');  
				END
		-- ==========================================================================
	END TRY
	BEGIN CATCH
		ROLLBACK TRAN   
		SELECT ERROR_MESSAGE ()
	END CATCH</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>about_TRIGGER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>about_TRIGGER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_TRIGGER


DDL Triggers:  
=============/*
DDL triggers, like regular triggers, fire stored procedures in response to an event. 
However, unlike DML triggers, they do NOT fire in response to: 
	UPDATE, 
	INSERT, 
	or DELETE statements on a table or view.
	 
Instead, they fire in response to a variety of Data Definition Language (DDL) events. 
These events primarily correspond to Transact-SQL statements that start with the keywords CREATE, ALTER, and DROP. 
Certain system stored procedures that perform DDL-like operations can also fire DDL triggers.

DDL triggers can be used for administrative tasks such as auditing and regulating database operations.
Use DDL triggers when you want to do the following:
You want to prevent certain changes to your database schema.
You want something to occur in the database in response to a change in your database schema.
You want to record changes or events in the database schema.
*/
DML Triggers
=============
--DML events include UPDATE, INSERT, or DELETE statements issued against a table or view. 

---------------------------
--Exit a trigger as soon as possible.
-- For almost every DML Trigger you can START out with:

if @@rowcount = 0
	Return
--which will abort further execution if no records were changed
-- if it is not the very first then it may well count records from the wrong event	
	
---------------------------
/*
Since you can have multiple 'After' triggers, break the logic up, 
	don't try and put it all in one procedure

---------------------------	

You can use PRINT and SELECT during debugging, but comment them out once you are in production.


Trigger for One-to-One tables:	*/
http://sqlblogcasts.com/blogs/tonyrogerson/archive/2010/01/23/how-to-create-a-one-to-one-relationship-in-sql-server-using-dri-triggers-and-views.aspx
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>AFTER_INSERT_based_on_record_count</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>AFTER_INSERT_based_on_record_count</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE [barriere]
GO

/****** Object:  Trigger [dbo].[trg_HCSS_Insert_Job]    Script Date: 02/26/2016 14:10:38 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		Dewey Hebert
-- Create date: 11/06/2009
-- Description:	Capture Inserted Data from Job Master for HCSS Replication
-- =============================================
CREATE TRIGGER [dbo].[trg_HCSS_Insert_Job] ON [dbo].[JC_HEADERMASTER]
    AFTER INSERT
AS
    BEGIN
        SET NOCOUNT ON;

        DECLARE @rc AS INT = ( SELECT   COUNT(*)		--&lt;===========
                               FROM     Inserted
                             );
        IF @rc = 0
            RETURN;

    -- Insert statements for trigger here
        INSERT  INTO BCC_HCSS_DISPATCH.dbo.BCC_JOB
                ( COMPANY ,
                  JOB ,
                  [DESCRIPTION] ,
                  START ,
                  FINISH ,
                  DIVISION ,
                  PROJECT_MANAGER ,
                  [ACTION] ,
                  BLOCK
	            )
                SELECT  ISNULL(ins.COMPANY,'') ,
                        ins.JOB ,
                        ISNULL(ins.[DESCRIPTION], '') ,
                        CONVERT(DATETIME, ISNULL(ins.[START_DATE], '1753-01-01'), 101) ,
                        CONVERT(DATETIME, ISNULL(ins.ENDING_DATE, '1753-01-01'), 101) ,
                        ISNULL(ins.DIVISION, '00') ,
                        LEFT(ISNULL(ins.USER1, ''), 5) ,
                        'I' ,
                        ''
                FROM    Inserted AS ins
                WHERE   ins.JOB_COMPLETE &lt;&gt; 'Y'
                        AND ins.JOB IS NOT NULL
                        
    END
GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>AFTER_INSERT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>AFTER_INSERT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE [barriere]
GO

/****** Object:  Trigger [dbo].[trg_eSafety_Insert_Project]    Script Date: 02/26/2016 13:58:33 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		Dewey Hebert
-- Create date: 2/16/2011
-- Description:	Insert data into eProject
-- =============================================
CREATE TRIGGER [dbo].[trg_eSafety_Insert_Project] ON [dbo].[JC_HEADERMASTER]
    AFTER INSERT
AS
    BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
        SET NOCOUNT ON ;

    -- Insert statements for trigger here
        INSERT  INTO eSafety_Container.dbo.eProject
                ( Job ,
                  [Description] ,
                  JobComplete ,
                  StartDate ,
                  EndDate ,
                  Division ,
                  [Action] ,
                  Block
	          )
                SELECT  ins.JOB ,
                        ISNULL(ins.[DESCRIPTION],'') ,
                        ISNULL(ins.JOB_COMPLETE,'N') ,
                        ISNULL(ins.[START_DATE],'17530101') ,
                        ISNULL(ins.ENDING_DATE,'17530101') ,
                        ISNULL(ins.DIVISION,'') ,
                        'I' ,
                        ''
                FROM    INSERTED AS ins
                WHERE   ins.[DESCRIPTION] NOT LIKE '%DO NOT%'
    END

GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>AFTER_UPDATE_ex_2</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>AFTER_UPDATE_ex_2</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE [barriere]
GO

/****** Object:  Trigger [dbo].[trg_eSafety_Update_Project]    Script Date: 02/26/2016 13:57:22 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		Dewey Hebert
-- Create date: 2/16/2011
-- Description:	Update data in eProject
-- =============================================
CREATE TRIGGER [dbo].[trg_eSafety_Update_Project] ON [dbo].[JC_HEADERMASTER]
    AFTER UPDATE
AS
    BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
        SET NOCOUNT ON ;

    -- Insert statements for trigger here
        IF UPDATE([DESCRIPTION])
            OR UPDATE(DIVISION)
            OR UPDATE(JOB_COMPLETE)
            OR UPDATE([START_DATE])
            OR UPDATE(ENDING_DATE) 
            BEGIN
                INSERT  INTO eSafety_Container.dbo.eProject
                        ( Job ,
                          [Description] ,
                          JobComplete ,
                          StartDate ,
                          EndDate ,
                          Division ,
                          [Action] ,
                          Block
			        
                        )
                        SELECT  ins.JOB ,
                                ISNULL(ins.[DESCRIPTION],'') ,
                                ISNULL(ins.JOB_COMPLETE,'N') ,
                                ISNULL(ins.[START_DATE],'17530101') ,
                                ISNULL(ins.ENDING_DATE,'17530101') ,
                                ISNULL(ins.DIVISION,'') ,
                                'U' ,
                                ''
                        FROM    INSERTED AS ins
                        WHERE   ins.[DESCRIPTION] NOT LIKE '%DO NOT%'
            END

    END

GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>AFTER_UPDATE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>AFTER_UPDATE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- EXAMPLE: So After an Update to table Categories, 
--	Check the 'Active' field in the table Categories
-- If it is Zero then update the Products Table and
--	set the active field in that table to Zero for the 
--	records where the CategoryID Match the ones in the 'temporary' table named: 'Inserted'
--	which is only accessible from within the trigger, and that is automatically created
--	by the server. The 'Inserted' table holds all the new information that is being
--	updated/inserted into the table: Categories


CREATE TRIGGER [dbo].[CategoryDeactivation]		--&lt;== Name of Trigger
ON [dbo].[Categories]		--&lt;== Table to respond to
AFTER UPDATE				--&lt;== Will only run AFTER an UPDATE statement
AS
BEGIN 
	DECLARE @isActive AS bit 

	SELECT @isActive = Active	-- Active is actually an INT, but if it is either Zero or One, so a it fits into the bit
	FROM Inserted

	IF (@isActive = 0)
		UPDATE Products
		SET Active = 0
		WHERE CategoryID IN (SELECT CategoryID FROM Inserted)

END


--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
--|||||BELOW HERE IS the Setup Script for the Trigger Example ||||||||||
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

CREATE TABLE [dbo].[Categories](
	[CategoryID] [int] NOT NULL,
	[CategoryName] [varchar](50) NULL,
	[Active] [int] NULL,
 CONSTRAINT [PK_Categories] PRIMARY KEY CLUSTERED 
(
	[CategoryID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO


---------------

INSERT INTO Categories VALUES (1, 'Shirts', 1);
INSERT INTO Categories VALUES (2, 'Pants', 1);
INSERT INTO Categories VALUES (3, 'Jackets', 1);
INSERT INTO Categories VALUES (4, 'Shoes', 1);

---------------------------------------------

CREATE TABLE [dbo].[Products](
	[ProductID] [int] NOT NULL,
	[ProductName] [varchar](50) NULL,
	[CategoryID] [int] NULL,
	[Active] [bit] NULL,
	[Qty] [int] NULL,
 CONSTRAINT [PK_Product] PRIMARY KEY CLUSTERED 
(
	[ProductID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO

--------------------------------------
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CURSOR_Send_Mail</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CURSOR_Send_Mail</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE [barriere]
GO

/****** Object:  Trigger [dbo].[SendNotification]    Script Date: 02/26/2016 14:57:05 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TRIGGER [dbo].[SendNotification]
ON [dbo].[BC_Notification] 
FOR INSERT
AS
Declare @Recipients as varchar(1024)
Declare @BlockMail as Char(1)

SET NOCOUNT ON
--if @@ROWCOUNT=0 Return
--EXEC [Master].[dbo].xp_Startmail 'SQLUSER','Barriere1'

Declare T1 CURSOR FOR Select * From Inserted
Declare @MsgType as char(2),
	@AppID as char(2),
	@Division as char(9),
	@Created as datetime,
	@Subject as varchar(128),
	@Message as varchar(1024)

OPEN T1

FETCH NEXT FROM T1 INTO @MsgType, @AppID, @Division, @Created, @Subject, @Message
WHILE (@@FETCH_STATUS &lt;&gt; -1)
   BEGIN
	if (@@FETCH_STATUS &lt;&gt; -2)
	   BEGIN
		Set @BlockMail = 'N'
		
		---Select @MsgType=MsgType, @Division=Division, @Message=Message, @Subject=Subject from Inserted
		
		Select @Recipients=Recipients From BC_Notification_Recipient_List Where MsgType=@MsgType and AppID=@AppID and Division=@Division
		if @@ROWCOUNT=0
		   begin
		      Set @Subject = 'Attention Notification Administrator, Invalid Division.  Original Subject is: ' + @Subject
		      Set @Message='Attention Notification Administrator: No Users Setup for Division ' + @Division + char(13) + char(13) + 'Attached Message is' + char(13) + @Message
		      Select @Recipients=Recipients From BC_Notification_Recipient_List Where MsgType=@MsgType and AppID='**' and Division = '**'
		      if @@ROWCOUNT=0 Set @BlockMail='Y'
		   end
		
		
		if @BlockMail='N'
		   begin
		      EXEC msdb.dbo.sp_send_dbmail @recipients=@Recipients,
			    			   @body=@Message,
						       @subject=@Subject,
						       @profile_name='SQLUSER'
		      INSERT INTO BC_Notification_Sent_Tracker(MsgType, AppID, Division, Created) VALUES(@MsgType, @AppID, @Division, @Created)
		   end
	END
	FETCH NEXT FROM T1 INTO @MsgType, @AppID, @Division, @Created, @Subject, @Message
   END

CLOSE T1
DEALLOCATE T1




GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Insert_Update_dateTime</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Insert_Update_dateTime</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--from: http://stackoverflow.com/questions/21493178/need-a-datetime-field-in-ms-sql-that-automatically-updates-when-the-record-is-mo

--Okay, I always like to keep track of not only when something happened but who did it!

--Lets create a test table in [tempdb] named [dwarfs]. At a prior job, a financial institution, we keep track of inserted (create) date and updated (modify) date.

-- just playing
use tempdb;
go

-- drop table
if object_id('dwarfs') &gt; 0
drop table dwarfs
go

-- create table
create table dwarfs
(
asigned_id int identity(1,1),
full_name varchar(16),
ins_date datetime,
ins_name sysname,
upd_date datetime,
upd_name sysname,
);
go

-- insert/update dates
alter table dwarfs
    add constraint [df_ins_date] default (getdate()) for ins_date;
alter table dwarfs
    add constraint [df_upd_date] default (getdate()) for upd_date;

-- insert/update names
alter table dwarfs
    add constraint [df_ins_name] default (coalesce(suser_sname(),'?')) for ins_name;

alter table dwarfs
    add constraint [df_upd_name] default (coalesce(suser_sname(),'?')) for upd_name;
go

--For updates, but the inserted and deleted tables exist. I choose to join on the inserted for the update.

-- create the update trigger
create trigger trg_changed_info on dbo.dwarfs
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       upd_date = getdate(),
       upd_name = (coalesce(suser_sname(),'?'))
    from
       dwarfs d join inserted i 
    on 
       d.asigned_id = i.asigned_id;

end
go

--Last but not least, lets test the code. Anyone can type a untested TSQL statement in. However, I always stress testing to my team!

-- remove data
truncate table dwarfs;
go

-- add data
insert into dwarfs (full_name) values
('bilbo baggins'),
('gandalf the grey');
go

-- show the data
select * from dwarfs;

-- update data
update dwarfs 
set full_name = 'gandalf'
where asigned_id = 2;

-- show the data
select * from dwarfs;


--The output. I only waited 10 seconds between the insert and the delete. Nice thing is that who and when are both captured.</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Insert_Update_Example</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Insert_Update_Example</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--P:\p_0020_PasswordsDB\SQL\0_CreateTable\Create_Table_T002_Passwords_ALL_v2.sql

USE [d1_IT]
GO

/****** Object:  Table [dbo].[T002_Passwords_ALL]    Script Date: 2/21/2017 1:42:22 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TABLE [dbo].[T002_Passwords_ALL](
	[Audience_Me_IT] [nvarchar](255) NULL,
	[Audience_e01] [int] NULL,
	[UserType_OS_SQL_Application] [nvarchar](255) NULL,
	[UserType_e02] [int] NULL,
	[UserName] [nvarchar](255) NULL,
	[password] [nvarchar](255) NULL,
	[Application] [nvarchar](255) NULL,
	[OS_user_type] [nvarchar](255) NULL,
	[OS_User_Type_e03] [int] NULL,
	[Computer_for_UserName] [nvarchar](255) NULL,
	[Notes] [nvarchar](255) NULL,
	[T002_PK] [int] IDENTITY(1,1) NOT NULL,
 CONSTRAINT [T002_Passwords_ALL_$_T002_PK] PRIMARY KEY CLUSTERED 
(
	[T002_PK] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO

ALTER TABLE [dbo].[T002_Passwords_ALL]  WITH CHECK ADD  CONSTRAINT [T002_Passwords_ALL_$_Audience_e01_$enum$_T002_enum_01_Value] FOREIGN KEY([Audience_e01])
REFERENCES [dbo].[T002_enum_01] ([T002_enum_01_Value])
GO

ALTER TABLE [dbo].[T002_Passwords_ALL] CHECK CONSTRAINT [T002_Passwords_ALL_$_Audience_e01_$enum$_T002_enum_01_Value]
GO

ALTER TABLE [dbo].[T002_Passwords_ALL]  WITH CHECK ADD  CONSTRAINT [T002_Passwords_ALL_$_OS_User_Type_e03_$enum$_T002_enum_03_Value] FOREIGN KEY([OS_User_Type_e03])
REFERENCES [dbo].[T002_enum_03] ([T002_enum_03_Value])
GO

ALTER TABLE [dbo].[T002_Passwords_ALL] CHECK CONSTRAINT [T002_Passwords_ALL_$_OS_User_Type_e03_$enum$_T002_enum_03_Value]
GO

ALTER TABLE [dbo].[T002_Passwords_ALL]  WITH CHECK ADD  CONSTRAINT [T002_Passwords_ALL_$_UserType_e02_$enum$_T002_enum_02_Value] FOREIGN KEY([UserType_e02])
REFERENCES [dbo].[T002_enum_02] ([T002_enum_02_Value])
GO

ALTER TABLE [dbo].[T002_Passwords_ALL] CHECK CONSTRAINT [T002_Passwords_ALL_$_UserType_e02_$enum$_T002_enum_02_Value]
GO

ALTER TABLE [dbo].[T002_Passwords_ALL] ADD  DEFAULT ((2)) FOR [Audience_e01]
GO

ALTER TABLE [dbo].[T002_Passwords_ALL] ADD  DEFAULT ((0)) FOR [UserType_e02]
GO

ALTER TABLE [dbo].[T002_Passwords_ALL] ADD  DEFAULT ((4)) FOR [OS_User_Type_e03]
GO


ALTER TABLE [d1_IT].[dbo].[T002_Passwords_ALL]
ADD  
			CreateRecord_dateTime datetime,
			CreateRecord_name sysname,
			UpdateRecord_dateTime datetime,
			UpdateRecord_name sysname;

create trigger TRG_001_recordChanged_T002 on [d1_IT].[dbo].T002_Passwords_ALL
for update
as
begin

    -- nothing to do?
    if (@@rowcount = 0)
      return;

    update d
    set 
       d.UpdateRecord_dateTime = getdate(),
       d.UpdateRecord_name = (coalesce(suser_sname(),'?'))
    from
       [d1_IT].[dbo].T002_Passwords_ALL d join inserted i 
    on 
       d.T002_PK = i.T002_PK;

end
go

-- insert/update dates
alter table [d1_IT].[dbo].[T002_Passwords_ALL]
    add constraint [df_ins_date] default (getdate()) for CreateRecord_dateTime;
alter table [d1_IT].[dbo].[T002_Passwords_ALL]
    add constraint [df_upd_date] default (getdate()) for UpdateRecord_dateTime;

 insert/update names
alter table [d1_IT].[dbo].[T002_Passwords_ALL]
    add constraint [df_ins_name] default (coalesce(suser_sname(),'?')) for CreateRecord_name;

alter table [d1_IT].[dbo].[T002_Passwords_ALL]
    add constraint [df_upd_name] default (coalesce(suser_sname(),'?')) for UpdateRecord_name;
go</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>INSTEAD_OF_DELETE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>INSTEAD_OF_DELETE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--EXAMPLE:
-- Enforce a Data Integrity rule: We can not delete a category, but rather mark it inactive
--								  So if user attempts to delete category, instead update it to zero


CREATE TRIGGER [dbo].[CategoryDelete]
ON [dbo].[Categories]
INSTEAD OF DELETE
AS
BEGIN 
		UPDATE Categories
		SET Active = 0
		WHERE CategoryID IN (SELECT CategoryID FROM Deleted) 
-- 'Deleted' is a temporary table, created by the trigger. It holds the data that would have been deleted.		
END



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
--|||||BELOW HERE IS the Setup Script for the Trigger Example ||||||||||
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

CREATE TABLE [dbo].[Categories](
	[CategoryID] [int] NOT NULL,
	[CategoryName] [varchar](50) NULL,
	[Active] [int] NULL,
 CONSTRAINT [PK_Categories] PRIMARY KEY CLUSTERED 
(
	[CategoryID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO


---------------

INSERT INTO Categories VALUES (1, 'Shirts', 1);
INSERT INTO Categories VALUES (2, 'Pants', 1);
INSERT INTO Categories VALUES (3, 'Jackets', 1);
INSERT INTO Categories VALUES (4, 'Shoes', 1);

---------------------------------------------

CREATE TABLE [dbo].[Products](
	[ProductID] [int] NOT NULL,
	[ProductName] [varchar](50) NULL,
	[CategoryID] [int] NULL,
	[Active] [bit] NULL,
	[Qty] [int] NULL,
 CONSTRAINT [PK_Product] PRIMARY KEY CLUSTERED 
(
	[ProductID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO

--------------------------------------
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>LIST_of_Triggers</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>LIST_of_Triggers</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>Select Object_name(so.parent_obj) as "Table name", so.[name] as "Trigger name"
From sysobjects so
Where Objectproperty(so.[id], 'IsTrigger')=1 and 
Objectproperty(so.[id], 'IsMSShipped')=0
Order by 1,2

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\



--1 means true, 0 means false obviously
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ -- THIS IS THE ONE I LIKE.

use xxx
go

SELECT 
     sysobjects.name AS trigger_name 
    ,USER_NAME(sysobjects.uid) AS trigger_owner 
    ,s.name AS table_schema 
    ,OBJECT_NAME(parent_obj) AS table_name 
    ,OBJECTPROPERTY( id, 'ExecIsUpdateTrigger') AS isupdate 
    ,OBJECTPROPERTY( id, 'ExecIsDeleteTrigger') AS isdelete 
    ,OBJECTPROPERTY( id, 'ExecIsInsertTrigger') AS isinsert 
    ,OBJECTPROPERTY( id, 'ExecIsAfterTrigger') AS isafter 
    ,OBJECTPROPERTY( id, 'ExecIsInsteadOfTrigger') AS isinsteadof 
    ,OBJECTPROPERTY(id, 'ExecIsTriggerDisabled') AS [disabled] 
FROM sysobjects 

INNER JOIN sysusers 
    ON sysobjects.uid = sysusers.uid 

INNER JOIN sys.tables t 
    ON sysobjects.parent_obj = t.object_id 

INNER JOIN sys.schemas s 
    ON t.schema_id = s.schema_id 

WHERE sysobjects.type = 'TR' 

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
select objectproperty(object_id('TriggerName'), 'ExecIsTriggerDisabled') 

//////////////////////////////////////

SELECT  
       TAB.name as Table_Name 
     , TRIG.name as Trigger_Name
     , TRIG.is_disabled  --or objectproperty(object_id('TriggerName'), 'ExecIsTriggerDisabled')
FROM [sys].[triggers] as TRIG 
inner join sys.tables as TAB 
on TRIG.parent_id = TAB.object_id 	
--or add it as a where clause.
where TRIG.is_disabled = 0 -- or 1 depends on what you want
	
/////////////////////////////////////	

SELECT

ServerName = @@servername,

DatabaseName = db_name(),

SchemaName = isnull( s.name, '' ),

TableName = isnull( o.name, 'DDL Trigger' ),

TriggerName = t.name,

Defininion = object_definition( t.object_id )

FROM sys.triggers t

LEFT JOIN sys.all_objects o

  ON t.parent_id = o.object_id

LEFT JOIN sys.schemas s

  ON s.schema_id = o.schema_id

ORDER BY

SchemaName,

TableName,

TriggerName

///////////////////////////////////////

    SELECT
    [so].[name] AS [trigger_name],
    USER_NAME([so].[uid]) AS [trigger_owner],
    USER_NAME([so2].[uid]) AS [table_schema],
    OBJECT_NAME([so].[parent_obj]) AS [table_name],
    OBJECTPROPERTY( [so].[id], 'ExecIsUpdateTrigger') AS [isupdate],
    OBJECTPROPERTY( [so].[id], 'ExecIsDeleteTrigger') AS [isdelete],
    OBJECTPROPERTY( [so].[id], 'ExecIsInsertTrigger') AS [isinsert],
    OBJECTPROPERTY( [so].[id], 'ExecIsAfterTrigger') AS [isafter],
    OBJECTPROPERTY( [so].[id], 'ExecIsInsteadOfTrigger') AS [isinsteadof],
    OBJECTPROPERTY([so].[id], 'ExecIsTriggerDisabled') AS [disabled] 
FROM sysobjects AS [so]
INNER JOIN sysobjects AS so2 ON so.parent_obj = so2.Id
WHERE [so].[type] = 'TR'

///////////////////////////////////////-- From Dewey, uses Cursor

USE barriere;


DECLARE P1 CURSOR
FOR
    SELECT  a.name ,
            b.name AS TableName ,
            CASE WHEN OBJECTPROPERTY(a.id, 'ExecIsTriggerDisabled') = 0 THEN ' '
                 ELSE 'Disabled'
            END AS TriggerStatus
    FROM    sysobjects AS a
            JOIN sysobjects AS b ON ( a.parent_obj = b.id )
    WHERE   a.xtype = 'TR'
    ORDER BY 2;

DECLARE @Name sysname ,
    @TableName sysname ,
    @TriggerStatus AS VARCHAR(8);

OPEN P1;

FETCH NEXT FROM P1 INTO @Name, @TableName, @TriggerStatus;

WHILE ( @@fetch_status &lt;&gt; -1 )
    BEGIN
        IF ( @@fetch_status &lt;&gt; -2 )
            BEGIN
                PRINT @Name + SPACE(40 - LEN(@Name)) + @TableName + SPACE(40 - LEN(@TableName)) + @TriggerStatus;
                                                                ---Print 'ALTER TABLE ' + @TableName + ' DISABLE TRIGGER ' + @Name
            END;
        FETCH NEXT FROM P1 INTO @Name, @TableName, @TriggerStatus;
    END;

CLOSE P1;
DEALLOCATE P1;
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ReadMe_TRIGGER</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ReadMe_TRIGGER</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>ReadMe_TRIGGER

-- 'after' Trigger:
--	executes after INSERT, UPDATE, or DELETE
--  allows statement to execute, then takes over</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SCRIPT_output_each_Trigger_to_a_file_AND_SQLCMD_file_to_run_them</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SCRIPT_output_each_Trigger_to_a_file_AND_SQLCMD_file_to_run_them</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--1] The Script to create the Trigger Scripts:							prj_0006_RES_910_LIST_of_Triggers_v3.sql
--2] The Stored Procedure used to output them to a file on the Server:	prj_0000_SP_201_WriteLineToFile.sql
--3] Commands to enable the function in the comments of the function

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\--1] 

--prj_0006_RES_910_LIST_of_Triggers_v3.sql
/*
	************************************************************************************
	NOTE: This will output a file for each trigger on the database, and an SQLCMD file to run them 
			into a designated directory on the Database Server
		  This script requires that the function 'prj_0000_SP_201_WriteLineToFile' exists in the database
		  See the documentation for that function for requirements on the server. i.e. enabling 'Ole Automation Procedures' 
	Uses: 
	Created: 7/7/2016
	By: glenn garson
	************************************************************************************
*/
use barriere
go

DECLARE @tmp table (Id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, Trigger_Name nvarchar(Max), Table_Name nvarchar(max))
DECLARE @Trigger_Name nvarchar(max) 
DECLARE @Table_Name nvarchar(max)
DECLARE @Id INT = 0

----from SQLCMD
DECLARE @destinationpath NVARCHAR(1000)
SET @destinationpath = N'C:\JUNK' 
DECLARE @SQLCMD_Path_FileName NVARCHAR(1000) 	 
DECLARE @SQLCMD_First_Line NVARCHAR(1000) 	

SET @SQLCMD_Path_FileName =  @destinationpath + '\_SQLCMD.sql'
SET @SQLCMD_First_Line =  '--_SQLCMD.sql'
--xxx] Create a File to store the lines of code for the Trigger
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=@SQLCMD_First_Line   , @FileAction = 'CREATENEW'	
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=' '   , @FileAction = 'APPEND'	   
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=':setvar path "c:\xxx\"'   , @FileAction = 'APPEND'	 
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=' '   , @FileAction = 'APPEND'


;WITH CTE_Triggers(Trigger_Name, Table_Name)
AS
(
	SELECT --TOP(3)			--&lt;============================================
		 sysobjects.name AS Trigger_Name,
		 Object_name(parent_obj) as "Table_Name" 
	FROM sysobjects 
	WHERE sysobjects.type = 'TR'
	-- P = Stored Procedure
	-- V = View
	-- TF = Table Function
	-- TR = Trigger	
)

--0] Add a Primary Key to each record

INSERT INTO @tmp 
SELECT Trigger_Name, Table_Name 
FROM CTE_Triggers
ORDER BY Table_Name, Trigger_Name


Select * from @tmp

-- Iterate over all the triggers in the database
WHILE (1=1)
BEGIN

	--1] Get the next Trigger name from the Table of Trigger Names
    SELECT @Trigger_Name = Trigger_Name, @Id = Id, @Table_Name = Table_Name
    FROM @tmp
    WHERE Id = @Id + 1

	----1b] Create the SQLCMD file


	

    IF @@rowcount = 0 BREAK;


        -- 2] Create a table consisting of the lines of code for that trigger
    	BEGIN
			DECLARE @TTV_LinesOfCodeForTrigger TABLE  (CodeID INT IDENTITY(1,1) PRIMARY KEY NOT NULL, LineOfCode nvarchar(Max)) 
			INSERT INTO @TTV_LinesOfCodeForTrigger exec sp_helptext @Trigger_Name
			
			
			--SELECT * from @TTV_LinesOfCodeForTrigger



			DECLARE @TRIGGER_filename NVARCHAR(1000) 
			DECLARE @FirstLineOfFile NVARCHAR(1000)  
			DECLARE @DropTriggerLine_1 NVARCHAR(1000)  
			DECLARE @DropTriggerLine_2 NVARCHAR(1000) 			
			
			
			
 
			SET @TRIGGER_filename = @destinationpath + '\prj_0006_TRIG_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' + @Table_Name  + '_' +  @Trigger_Name + N'.sql' 
			SET @FirstLineOfFile = '--' + '\prj_0006_TRIG_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' + @Table_Name  + '_' +  @Trigger_Name + N'.sql'
			SET @DropTriggerLine_1 = 'IF OBJECT_ID(' + char(39) + @Trigger_Name + char(39) + ') IS NOT NULL DROP TRIGGER ' + @Trigger_Name 
			SET @DropTriggerLine_2 = 'GO'
			
			DECLARE @CodeID INT = 0
			DECLARE @LineOfCode nvarchar(max) = ''
			DECLARE @LineForSQLCMDFile nvarchar(max) = ''
				
			
			--3b] APPEND a line to the SQLCMD file that calls the Create Trigger file	
			SET @LineForSQLCMDFile = ':r $(path)\' + 'prj_0006_TRIG_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' + @Table_Name  + '_' +  @Trigger_Name + N'.sql'	
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=@LineForSQLCMDFile   , @FileAction = 'APPEND'
			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@TRIGGER_filename  , @TextData=@FirstLineOfFile   , @FileAction = 'CREATENEW'		 			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@TRIGGER_filename  , @TextData=' '   , @FileAction = 'APPEND'	
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@TRIGGER_filename  , @TextData=@DropTriggerLine_1   , @FileAction = 'APPEND'			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@TRIGGER_filename  , @TextData=@DropTriggerLine_2   , @FileAction = 'APPEND'			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@TRIGGER_filename  , @TextData=' '   , @FileAction = 'APPEND'	
			
						
			-- 4] Iterate over all the lines of code in the output=============================================
			WHILE 2=2
			BEGIN
			 
				SELECT TOP(1) @CodeID = CodeID, @LineOfCode = LineOfCode
				FROM @TTV_LinesOfCodeForTrigger
				WHERE CodeID &gt; @CodeID
				ORDER BY CodeID

				-- Exit loop if no more code
				IF @@ROWCOUNT = 0 BREAK;
							
			

				PRINT 'Line of Code: ' + @LineOfCode
				--5] Save the Line of Code to the file
				exec prj_0000_SP_201_WriteLineToFile  @FileName =@TRIGGER_filename  , @TextData=@LineOfCode   , @FileAction = 'APPEND'									
			END	-- end of writing codelines to file
			
			--6] Clear out the records, otherwise they accumulate from each Trigger
			DELETE FROM @TTV_LinesOfCodeForTrigger	
			
			
  		END	-- end of list of triggers
  		
  		

    
END

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\--2]
--prj_0000_SP_201_WriteLineToFile.sql
/*
	************************************************************************************
	NOTE: 
	Uses: 
	Created: 10/24/2012
	By: glenn garson
	************************************************************************************
Must turn on Automation once before using this SP:
=====================================================
--Make sure OLE Automation is turned on:
sp_configure 'show advanced options', 1;
GO
RECONFIGURE;
GO
 
sp_configure 'Ole Automation Procedures', 1;
GO
RECONFIGURE;
GO

=====================================================
from: http://sqlsolace.blogspot.com/2009/01/ole-automation-write-text-file-from.html
-- Use the SP:
================================================================================
DECLARE @destinationpath NVARCHAR(1000)  
DECLARE @destinationfilename NVARCHAR(1000)  
SET @destinationpath = N'C:\SQL Scripts'   
SET @destinationfilename = @destinationpath + '\' + N'filename.txt'  
  
exec prj_0000_SP_201_WriteLineToFile  @FileName =@destinationfilename  
, @TextData ='blah! blah! blah!'  
, @FileAction = 'APPEND'							-- CREATENEW or APPEND (to allow appends if the file exists, both options create the file if it doesn't)
================================================================================
*/
use barriere
go


alter PROCEDURE [prj_0000_SP_201_WriteLineToFile] (
														@FileName varchar(1000), 
														@TextData NVARCHAR(MAX),
														@FileAction VARCHAR(12)		--CREATENEW or APPEND
													) 
AS  
  
BEGIN  
	DECLARE @OLEfilesytemobject INT  
	DECLARE @OLEResult INT  
	DECLARE @FileID INT  
	  
	EXECUTE @OLEResult = sp_OACreate 'Scripting.FileSystemObject', @OLEfilesytemobject OUT  

	PRINT '----------------------------------------START Filename: ' +  @FileName
	PRINT '--------TEXTDATA: ' +  @TextData	
	PRINT '--------FILEACTION: ' +  @FileAction		
	
	IF @OLEResult &lt;&gt; 0   PRINT 'Error: Scripting.FileSystemObject'  
	  
	-- check if file exists  
	EXEC sp_OAMethod @OLEfilesytemobject, 'FileExists', @OLEresult OUT, @FileName   
	-- if file esists  
	IF (@OLEresult=1 AND @FileAction = 'APPEND') OR (@OLEresult=0)   
	BEGIN     
	  
			IF (@FileAction = 'CREATENEW')  PRINT 'New file specified, creating...'
			IF (@OLEresult=1 AND @FileAction = 'APPEND')   PRINT 'File exists, appending...' 
			IF (@OLEresult=0 AND @FileAction = 'APPEND')  PRINT 'File doesnt exist, creating...' 
			  
			-- open file  
			EXECUTE @OLEResult = sp_OAMethod @OLEfilesytemobject, 'OpenTextFile', @FileID OUT, @FileName, 8, 1  
			
			IF @OLEResult &lt;&gt;0 PRINT 'Error: OpenTextFile'
			  
			-- write Text1 to the file  
			EXECUTE @OLEResult = sp_OAMethod @FileID, 'WriteLine', Null, @TextData  
			
			IF @OLEResult &lt;&gt; 0   
				PRINT 'Error : WriteLine ' 
			ELSE  
				PRINT 'Success'   
			END  
			IF (@OLEresult=1 AND @FileAction = 'CREATENEW')  
			
			PRINT 'File Exists, specify APPEND if this is the desired action'  
			  
			EXECUTE @OLEResult = sp_OADestroy @FileID  
			EXECUTE @OLEResult = sp_OADestroy @OLEfilesytemobject  
  
	END  
GO  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Send_email_for_INSERT</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Send_email_for_INSERT</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE [barriere]
GO

/****** Object:  Trigger [dbo].[trg_UserNotification_Insert]    Script Date: 02/26/2016 14:00:52 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		Dewey Hebert
-- Create date: 6/25/22010
-- Description:	Notify User when a new Job is added.
-- =============================================
CREATE TRIGGER [dbo].[trg_UserNotification_Insert] ON [dbo].[JC_HEADERMASTER]
    FOR INSERT
AS
    BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
        SET NOCOUNT ON ;

        DECLARE @Job AS CHAR(9)
        DECLARE @Description AS VARCHAR(50)
        DECLARE @Owner AS VARCHAR(50)
        DECLARE @Division AS CHAR(9)
        DECLARE @StartDate AS CHAR(8)
        DECLARE @MsgBody AS VARCHAR(1024)
    
    
        SELECT  @Job = JOB ,
                @Description = ISNULL(DESCRIPTION, ' ') ,
                @Owner = ISNULL(OWNER, ' ') ,
                @Division = ISNULL(DIVISION, ' ') ,
                @StartDate = ISNULL(START_DATE, ' ')
        FROM    INSERTED
    
        SET @MsgBody = 'New Job Added: ' + @Job + ', Description: '
            + @Description + ', Owner: ' + @Owner + ', Division: ' + @Division
            + ', Start Date: ' + @StartDate
	
        EXEC msdb.dbo.sp_send_dbmail @recipients = 'paulA@barriere.com', @body = @MsgBody,
            @subject = 'New Job Added to Job Master', @profile_name='SQLUSER'

    END


GO


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>TEST_example_for_Insert_Delete_and_Update</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>TEST_example_for_Insert_Delete_and_Update</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://www.mssqltips.com/sqlservertip/2342/understanding-sql-server-inserted-and-deleted-tables-for-dml-triggers/

/*
Operation				deleted Table													inserted Table
--------------			------------------------										--------------------
INSERT					(not used)														Contains the rows being inserted
DELETE					Contains the rows being deleted									(not used)
UPDATE					Contains the rows as they were before the UPDATE statement		Contains the rows as they were after the UPDATE statement

A conceptual way of thinking how the deleted and inserted tables are used in an UPDATE operation 
is that SQL Server first deletes the old rows,
populating the deleted table, and then inserts the new and modified rows, 
populating the inserted table. While this isn't what actually happens, 
it helps visualize what the tables contain and is useful in that sense. 
Let's see an example of the triggers in operation with these tables


*/
//////////////////--First, the setup:

USE MSSQLTips;
GO

CREATE TABLE dbo.SampleTable (
  SampleTableID INT NOT NULL IDENTITY(1,1),
  SampleTableInt INT NOT NULL,
  SampleTableChar CHAR(5) NOT NULL,
  SampleTableVarChar VARCHAR(30) NOT NULL,
  CONSTRAINT PK_SampleTable PRIMARY KEY CLUSTERED (SampleTableID)
);
GO

CREATE TABLE dbo.SampleTable_Audit (
  SampleTableID INT NOT NULL,
  SampleTableInt INT NOT NULL,
  SampleTableChar CHAR(5) NOT NULL,
  SampleTableVarChar VARCHAR(30) NOT NULL,
  Operation CHAR(1) NOT NULL,
  TriggerTable CHAR(1) NOT NULL,
  AuditDateTime smalldatetime NOT NULL DEFAULT GETDATE(),
);

CREATE INDEX IDX_SampleTable_Audit_AuditDateTime ON dbo.SampleTable_Audit (AuditDateTime DESC);
GO 

CREATE TRIGGER dbo.SampleTable_InsertTrigger
ON dbo.SampleTable
FOR INSERT
AS
BEGIN
   INSERT INTO dbo.SampleTable_Audit 
   (SampleTableID, SampleTableInt, SampleTableChar, SampleTableVarChar, Operation, TriggerTable)    
   SELECT SampleTableID, SampleTableInt, SampleTableChar, SampleTableVarChar, 'I', 'I'
   FROM inserted;
END;
GO

CREATE TRIGGER dbo.SampleTable_DeleteTrigger
ON dbo.SampleTable
FOR DELETE
AS
BEGIN
   INSERT INTO dbo.SampleTable_Audit 
   (SampleTableID, SampleTableInt, SampleTableChar, SampleTableVarChar, Operation, TriggerTable)    
   SELECT SampleTableID, SampleTableInt, SampleTableChar, SampleTableVarChar, 'D', 'D'
   FROM deleted;
END;
GO

CREATE TRIGGER dbo.SampleTable_UpdateTrigger
ON dbo.SampleTable
FOR UPDATE
AS
BEGIN
   INSERT INTO dbo.SampleTable_Audit 
   (SampleTableID, SampleTableInt, SampleTableChar, SampleTableVarChar, Operation, TriggerTable)    
   SELECT SampleTableID, SampleTableInt, SampleTableChar, SampleTableVarChar, 'U', 'D'
   FROM deleted;
   
   INSERT INTO dbo.SampleTable_Audit 
   (SampleTableID, SampleTableInt, SampleTableChar, SampleTableVarChar, Operation, TriggerTable)    
   SELECT SampleTableID, SampleTableInt, SampleTableChar, SampleTableVarChar, 'U', 'I'
   FROM inserted;
END;
GO

/////////////////////--Now let's test the triggers:

USE MSSQLTips;
GO 

-- First the inserts
INSERT INTO dbo.SampleTable
(SampleTableInt, SampleTableChar, SampleTableVarChar)
VALUES
(1, '11111', '1111111111');

INSERT INTO dbo.SampleTable
(SampleTableInt, SampleTableChar, SampleTableVarChar)
VALUES
(2, '22222', '222222222222222');

INSERT INTO dbo.SampleTable
(SampleTableInt, SampleTableChar, SampleTableVarChar)
VALUES
(3, 'AAAAA', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
GO 

-- Check the sample table
SELECT * FROM dbo.SampleTable;
GO 

-- Check the inserts
SELECT * FROM dbo.SampleTable_Audit;
GO 

-- Perform a delete operation
DELETE FROM dbo.SampleTable
WHERE SampleTableInt = 2;
GO 

-- Check the sample table
SELECT * FROM dbo.SampleTable;
GO 

-- Check the delete
SELECT * FROM dbo.SampleTable_Audit;
GO 

-- Perform an update operation
UPDATE dbo.SampleTable
SET SampleTableChar = '33333'
WHERE SampleTableInt = 3;
GO 

-- Check the sample table
SELECT * FROM dbo.SampleTable;
GO 

-- Check the update
SELECT * FROM dbo.SampleTable_Audit;
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TRIGGER</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Trigger_for_One-to-One_Table</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TRIGGER</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Trigger_for_One-to-One_Table</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://sqlblogcasts.com/blogs/tonyrogerson/archive/2010/01/23/how-to-create-a-one-to-one-relationship-in-sql-server-using-dri-triggers-and-views.aspx

-- Header Table:

CREATE TABLE [dbo].[Customers](
	[CustomerSurrogateID] [int] IDENTITY(1,1) NOT NULL,
	[CustomerID] [char](5) NOT NULL,
	[Name] [varchar](100) NULL,
 CONSTRAINT [pk_Customers] PRIMARY KEY CLUSTERED 
(
	[CustomerSurrogateID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY],
 CONSTRAINT [uk_Customer_CustomerID] UNIQUE NONCLUSTERED 
(
	[CustomerID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
       
-- Detail Table:
--We need to modify our “right” table and make all the columns except our key Nullable. 
--We also implement our CHECK constraints with slightly difference logic as you can see on the CustomersDetail table and the InitialOrderDate. 
--The CHECK CONSTRAINT must be a table level CHECK CONSTRAINT otherwise bets are off eg.
 
CREATE TABLE [dbo].[CustomersDetail](
	[CustomerSurrogateID] [int] NOT NULL,
	[DummyInsert] [char](1) NULL,
	[InitialOrderDate] [datetime] NULL,
	[SomeUniqueColReqd] [int] NULL,
 CONSTRAINT [pk_CustomersDetail] PRIMARY KEY CLUSTERED 
(
	[CustomerSurrogateID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]


-- Constraints for Header Table:



-- Constraints for Detail Table:

ALTER TABLE [dbo].[CustomersDetail]  WITH CHECK ADD  CONSTRAINT [fk_CustomersDetail_Customers] FOREIGN KEY([CustomerSurrogateID])
REFERENCES [dbo].[Customers] ([CustomerSurrogateID])
GO

ALTER TABLE [dbo].[CustomersDetail] CHECK CONSTRAINT [fk_CustomersDetail_Customers]
GO

ALTER TABLE [dbo].[CustomersDetail]  WITH CHECK ADD CHECK  ((isnull([DummyInsert],'N')='Y' OR [DummyInsert] IS NULL AND [InitialOrderDate] IS NOT NULL))
GO

ALTER TABLE [dbo].[CustomersDetail]  WITH CHECK ADD  CONSTRAINT [uk_CustomersDetail] CHECK  ((coalesce([DummyInsert],'N')='N' OR coalesce([DummyInsert],'N')='Y'))
GO

ALTER TABLE [dbo].[CustomersDetail] CHECK CONSTRAINT [uk_CustomersDetail]
GO

--we can model a view across the pair of them in the Physical Model, the view is below:


create view [dbo].[vw_CustomersCustomerDetails]
       with schemabinding
as
       select cCustomerID = c.CustomerID, cCustomerSurrogateID = c.CustomerSurrogateID, cName = c.Name, 
                 cdCUstomerSurrogateID = cd.CustomerSurrogateID, 
                 cdDummyInsert = cd.DummyInsert, 
                 cdInitialOrderDate = cd.InitialOrderDate, 
                 cdSomeUniqueColReqd = cd.SomeUniqueColReqd
       from dbo.Customers c 
              inner join dbo.CustomersDetail cd on cd.CustomerSurrogateID = c.CustomerSurrogateID

GO

--The following creates our INSTEAD OF trigger thus intercepting the INSERT on the view; we must do the “Insert” processing ourselves, 
--the rows inserted into the view are contained within the system generated “inserted” table.

create trigger [dbo].[trg_CustomersCustomerDetails_instof]
       on [dbo].[vw_CustomersCustomerDetails] instead of insert
as
begin

 
       --     First insert the Customer, the trigger on Customer
       --     will take care of inserting the CustomerDetail dummy record.
       insert Customers ( CustomerID, Name )
              select cCustomerID, cName
              from inserted
              
       --     Now update the dummy record with the CustomersDetail
       update CustomersDetail
              set DummyInsert = NULL,           --     we now have real data
                     InitialOrderDate = i.cdInitialOrderDate,
                     SomeUniqueColReqd = i.cdSomeUniqueColReqd
       from inserted i
              inner join Customers c on c.CustomerSurrogateID = i.cdCustomerSurrogateID

 
end


--The above is not enough for our solution to work properly; 
--inserting into the view is fine now but we need to have trigger logic on both the Customers and CustomersDetail tables.

 
create trigger trg_Customers_ins on Customers for insert
as
begin

 
       --     Make sure there is a row in the table we have a one to one with.
       --     It cannot contain data.
       insert CustomersDetail ( CustomerSurrogateID, DummyInsert )
              select CustomerSurrogateID, 'Y'
              from inserted

 
end
go

 
create trigger trg_CustomersDetail_del on CustomersDetail for delete
as
begin
       --     Need to remove the corresponding Customers row to keep consistency
       
       delete Customers
       where CustomerSurrogateID in ( select CustomerSurrogateID
                                      from deleted ) 

 
end
go

-- The solution basically inserts a dummy row into the CustomersDetail table – horrible I know, 
--but we incorporate a DummyInsert column that is set to Y whenever that row is a Dummy; 
--that then allows us to still use CHECK constraints; UNIQUE constraints are implemented using a unique filtered index such as below:



create unique index fltd_CustomersDetail_InitialOrderDate 
       on CustomersDetail( SomeUniqueColReqd )
       where DummyInsert IS NULL         --     Ignore dummy inserts because of one to one relationship
go</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>01_Blocked_Process_Report___about</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>01_Blocked_Process_Report___about</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
--By default in SQL Server, the deadlock detector wakes up every 5 seconds to check if your queries are in a “deadly embrace”. 
--You can turn on an option that asks SQL Server to use this resource to check for long term blocking, and issue a report.

--WARNING: You should only configure the blocked process report to be issued for values of five seconds or higher. 
--Microsoft warns that if you set this from 1-4, you could cause the deadlock detector to run continuously and kill your performance.

--To use the Blocked Process Report, you need to configure a trace that looks for the “Blocked Process Report”  
--event under “Errors and Warnings”. We recommend using a server side trace

--Step 1: Turn on the blocked process report. This will look for any blocking taking 20 seconds or longer.

--Make sure you don't have any pending changes
SELECT *
FROM sys.configurations
WHERE value &lt;&gt; value_in_use;
GO
exec sp_configure 'show advanced options', 1;
GO
RECONFIGURE
GO
exec sp_configure 'blocked process threshold (s)', 20;
GO
RECONFIGURE
GO

--To check on the settings:

exec sp_configure 'blocked process threshold (s)';

--Step 2: Set up a trace to capture the blocked process report. Run it as a server side trace.

--	It should contain one event: Errors and Warnings -&gt; Blocked Process Report.
--	It needs just two columns: Text, spid
--This sample server side trace will run for five minutes and automatically stop. You must change the path to a valid directory SQL Server has permission to write to.

-- I tried to set up a trace:
-------------------------------
--I picked the 'Blank' template from the New Trace Window =&gt; 
--	The 6th item down is "Errors and Warnings" =&gt;
--	Opened up that and picked "Blocked Process Report"


--This sample server side trace will run for five minutes and automatically stop. You must change the path to a valid directory SQL Server has permission to write to.
--NOTE: I had to give local account "NT Service\MSSQLSERVER" 'Modify' permission to the folder, otherwise it threw a 'denied access' error
--=================================================================================================
-- Created by: SQL Server 2012  Profiler
-- Create a Queue
declare @rc int
declare @TraceID int
declare @maxfilesize bigint
declare @DateTime datetime
---------Added a function here:
set @DateTime = DATEADD(mi,5,getdate());  /* Run for five minutes */
set @maxfilesize = 5
-- Please replace the text InsertFileNameHere, with an appropriate
-- filename prefixed by a path, e.g., c:\MyFolder\MyTrace. The .trc extension
-- will be appended to the filename automatically. If you are writing from
-- remote server to local drive, please use UNC path and make sure server has
-- write access to your network share
-----------Set my filename here:
exec @rc = sp_trace_create @TraceID output, 0, N'C:\JUNK\Trace001.trc', @maxfilesize, @Datetime
if (@rc != 0) goto error
-- Client side File and Table cannot be scripted
-- Set the events
declare @on bit
set @on = 1
exec sp_trace_setevent @TraceID, 137, 1, @on
exec sp_trace_setevent @TraceID, 137, 12, @on
-- Set the Filters
declare @intfilter int
declare @bigintfilter bigint
-- Set the trace status to start
exec sp_trace_setstatus @TraceID, 1
-- display trace id for future references
select TraceID=@TraceID
goto finish
error:
select ErrorCode=@rc
finish:
go
--=================================================================================================

-- Look at running traces and get the trace id:

SELECT * from sys.traces;
GO

--Stop a trace, if needed
--Plug in the correct traceid from the query above
EXEC sp_trace_setstatus @traceid =2, @status = 0;
GO
EXEC sp_trace_setstatus @traceid =2, @status = 2;
GO

--=================================================================================================
http://michaeljswart.com/2011/04/a-new-way-to-examine-blocked-process-reports/
-- Downloaded and saved the sp_blocked_process_report_viewer.sql script

--SYNTAX:
sp_blocked_process_report_viewer [@Trace = ] 'TraceFileOrTable'
    [ , [ @Type = ] 'TraceType' ]

--Arguments
--[@Trace = ] ‘TraceFileOrTable’

--Is the name of the trace table or trace file that holds the blocked process reports
--[@Trace = ] ‘TraceType’

--Is the type of file referenced by TraceFileOrTable. Values can be TABLE, FILE or XMLFILE. The default is FILE

--In this sample we use the free blocked process report viewer by Michael J Swart.

exec dbo.sp_blocked_process_report_viewer
  @Trace='C:\JUNK\Trace001.trc';
GO

--=================================================================================================
--CLEANUP
--Make sure your trace is gone
SELECT * from sys.traces;
GO
--Turn off the blocked process report when you're not using it.
--Make sure you don't have any pending changes
SELECT *
FROM sys.configurations
WHERE value &lt;&gt; value_in_use;
GO
exec sp_configure 'blocked process threshold (s)', 0;
GO
RECONFIGURE
GO
exec sp_configure 'blocked process threshold (s)';
GO

////////////////////////////--To Demonstrate a Blocked Process:
http://www.sqlpassion.at/archive/2011/12/01/the-blocked-process-report/

--To demonstrate the Blocked Process Report, 
--I’m just creating a new transaction inside the AdventureWorks2008R2 database through an UPDATE statement:


BEGIN TRANSACTION

UPDATE Person.Person
SET Title = 'Mr'
WHERE BusinessEntityID = 1

BEGIN TRANSACTION
 
--After the execution of this statement, 
--the query has now acquired an Exclusive Lock (X) on the record where the column BusinessEntityID is equal to 1. 
--In a second session I’m now trying to read the same record.
--During the reading SQL Server tries to acquire a Shared Lock (S) which leads to a blocking scenario:

SELECT * FROM Person.Person
WHERE BusinessEntityID = 1
GO
 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>01_Blocked_Process_Report___sp_blocked_process_report_viewer.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>01_Blocked_Process_Report___sp_blocked_process_report_viewer.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE master
GO

IF OBJECT_ID('sp_blocked_process_report_viewer') IS NULL
	EXEC ('
	CREATE PROCEDURE dbo.sp_blocked_process_report_viewer 
	AS 
	SELECT ''Replace Me''')
GO

ALTER PROCEDURE dbo.sp_blocked_process_report_viewer
(
	@Source nvarchar(max),
	@Type varchar(10) = 'FILE' 
)

AS

SET NOCOUNT ON

-- Validate @Type
IF (@Type NOT IN ('FILE', 'TABLE', 'XMLFILE', 'XESESSION'))
	RAISERROR ('The @Type parameter must be ''FILE'', ''TABLE'' or ''XMLFILE''', 11, 1)

IF (@Source LIKE '%.trc' AND @Type &lt;&gt; 'FILE')
	RAISERROR ('Warning: You specified a .trc trace. You should also specify @Type = ''FILE''', 10, 1)

IF (@Source LIKE '%.xml' AND @Type &lt;&gt; 'XMLFILE')
	RAISERROR ('Warning: You specified a .xml trace. You should also specify @Type = ''XMLFILE''', 10, 1)

IF (@Type = 'XESESSION' AND NOT EXISTS (
	SELECT * 
	FROM sys.server_event_sessions es
	JOIN sys.server_event_session_targets est
		ON es.event_session_id = est.event_session_id
	WHERE est.name in ('event_file', 'ring_buffer')
	  AND es.name = @Source ) 
)
	RAISERROR ('Warning: The extended event session you supplied does not exist or does not have an "event_file" or "ring_buffer" target.', 10, 1);
		

CREATE TABLE #ReportsXML
(
	monitorloop nvarchar(100) NOT NULL,
	endTime datetime NULL,
	blocking_spid INT NOT NULL,
	blocking_ecid INT NOT NULL,
	blocked_spid INT NOT NULL,
	blocked_ecid INT NOT NULL,
	blocked_hierarchy_string as CAST(blocked_spid as varchar(20)) + '.' + CAST(blocked_ecid as varchar(20)) + '/',
	blocking_hierarchy_string as CAST(blocking_spid as varchar(20)) + '.' + CAST(blocking_ecid as varchar(20)) + '/',
	bpReportXml xml not null,
	primary key clustered (monitorloop, blocked_spid, blocked_ecid),
	unique nonclustered (monitorloop, blocking_spid, blocking_ecid, blocked_spid, blocked_ecid)
)

DECLARE @SQL NVARCHAR(max);
DECLARE @TableSource nvarchar(max);

-- define source for table
IF (@Type = 'TABLE')
BEGIN
	-- everything input by users get quoted
	SET @TableSource = ISNULL(QUOTENAME(PARSENAME(@Source,4)) + N'.', '')
		+ ISNULL(QUOTENAME(PARSENAME(@Source,3)) + N'.', '')
		+ ISNULL(QUOTENAME(PARSENAME(@Source,2)) + N'.', '')
		+ QUOTENAME(PARSENAME(@Source,1));
END

-- define source for trc file
IF (@Type = 'FILE')
BEGIN	
	SET @TableSource = N'sys.fn_trace_gettable(N' + QUOTENAME(@Source, '''') + ', -1)';
END

-- load table or file
IF (@Type IN ('TABLE', 'FILE' ))
BEGIN
	SET @SQL = N'		
		INSERT #ReportsXML(blocked_ecid,blocked_spid,blocking_ecid,blocking_spid,
			monitorloop,bpReportXml,endTime)
		SELECT blocked_ecid,blocked_spid,blocking_ecid,blocking_spid,
			COALESCE(monitorloop, CONVERT(nvarchar(100), endTime, 120), cast(newid() as nvarchar(100))),
			bpReportXml,EndTime
		FROM ' + @TableSource + N'
		CROSS APPLY (
			SELECT CAST(TextData as xml)
			) AS bpReports(bpReportXml)
		CROSS APPLY (
			SELECT 
				monitorloop = bpReportXml.value(''(//@monitorLoop)[1]'', ''nvarchar(100)''),
				blocked_spid = bpReportXml.value(''(/blocked-process-report/blocked-process/process/@spid)[1]'', ''int''),
				blocked_ecid = bpReportXml.value(''(/blocked-process-report/blocked-process/process/@ecid)[1]'', ''int''),
				blocking_spid = bpReportXml.value(''(/blocked-process-report/blocking-process/process/@spid)[1]'', ''int''),
				blocking_ecid = bpReportXml.value(''(/blocked-process-report/blocking-process/process/@ecid)[1]'', ''int'')
			) AS bpShredded
		WHERE EventClass = 137
		  AND blocking_spid is not null
		  AND blocked_spid is not null';
		
	EXEC (@SQL);

END 


IF (@Type = 'XESESSION')
BEGIN
	DECLARE @SessionType sysname;
	DECLARE @SessionId int;
	DECLARE @SessionTargetId int;
	DECLARE @FilenamePattern sysname;

	SELECT TOP ( 1 ) 
		@SessionType = est.name,
		@SessionId = est.event_session_id,
		@SessionTargetId = est.target_id
	FROM sys.server_event_sessions es
	JOIN sys.server_event_session_targets est
		ON es.event_session_id = est.event_session_id
	WHERE est.name in ('event_file', 'ring_buffer')
		AND es.name = @Source;

	IF (@SessionType = 'event_file')
	BEGIN
		 
		SELECT @filenamePattern = REPLACE( CAST([value] AS sysname), '.xel', '*xel' )
		FROM sys.server_event_session_fields
		WHERE event_session_id = @SessionId
		  AND [object_id] = @SessionTargetId
		  AND name = 'filename'

		IF (@filenamePattern not like '%xel')
			set @filenamePattern += '*xel';

		INSERT #ReportsXML(blocked_ecid,blocked_spid,blocking_ecid,blocking_spid,
			monitorloop,bpReportXml,endTime)
		SELECT blocked_ecid,blocked_spid,blocking_ecid,blocking_spid,
			COALESCE(monitorloop, CONVERT(nvarchar(100), eventDate, 120), cast(newid() as nvarchar(100))),
			bpReportXml,eventDate
		FROM sys.fn_xe_file_target_read_file ( @filenamePattern, null, null, null) 
			as event_file_value
		CROSS APPLY ( SELECT CAST(event_file_value.[event_data] as xml) ) 
			as event_file_value_xml ([xml])
		CROSS APPLY (
			SELECT 
				event_file_value_xml.[xml].value('(event/@timestamp)[1]', 'datetime') as eventDate,
				event_file_value_xml.[xml].query('//event/data/value/blocked-process-report') as bpReportXml	
		) as bpReports
		CROSS APPLY (
			SELECT 
				monitorloop = bpReportXml.value('(//@monitorLoop)[1]', 'nvarchar(100)'),
				blocked_spid = bpReportXml.value('(/blocked-process-report/blocked-process/process/@spid)[1]', 'int'),
				blocked_ecid = bpReportXml.value('(/blocked-process-report/blocked-process/process/@ecid)[1]', 'int'),
				blocking_spid = bpReportXml.value('(/blocked-process-report/blocking-process/process/@spid)[1]', 'int'),
				blocking_ecid = bpReportXml.value('(/blocked-process-report/blocking-process/process/@ecid)[1]', 'int')
			) AS bpShredded
		WHERE blocking_spid is not null
		  AND blocked_spid is not null;

	END

	ELSE IF (@SessionType = 'ring_buffer')
	BEGIN
		-- get data from ring buffer
		INSERT #ReportsXML(blocked_ecid,blocked_spid,blocking_ecid,blocking_spid,
			monitorloop,bpReportXml,endTime)
		SELECT blocked_ecid,blocked_spid,blocking_ecid,blocking_spid,
			COALESCE(monitorloop, CONVERT(nvarchar(100), bpReportEndTime, 120), cast(newid() as nvarchar(100))),
			bpReportXml,bpReportEndTime
		FROM sys.dm_xe_session_targets st
		JOIN sys.dm_xe_sessions s 
			ON s.address = st.event_session_address
		CROSS APPLY 
			( SELECT CAST(st.target_data AS XML) ) 
			AS TargetData ([xml])
		CROSS APPLY 
			TargetData.[xml].nodes('/RingBufferTarget/event[@name="blocked_process_report"]') 
			AS bpNodes(bpNode)
		CROSS APPLY 
			bpNode.nodes('./data[@name="blocked_process"]/value/blocked-process-report')
			AS bpReportXMLNodes(bpReportXMLNode)
		CROSS APPLY
			(
			  SELECT 
				bpReportXml = CAST(bpReportXMLNode.query('.') as xml),
				bpReportEndTime = bpNode.value('(./@timestamp)[1]', 'datetime'),
				monitorloop = bpReportXMLNode.value('(//@monitorLoop)[1]', 'nvarchar(100)'),
				blocked_spid = bpReportXMLNode.value('(./blocked-process/process/@spid)[1]', 'int'),
				blocked_ecid = bpReportXMLNode.value('(./blocked-process/process/@ecid)[1]', 'int'),
				blocking_spid = bpReportXMLNode.value('(./blocking-process/process/@spid)[1]', 'int'),
				blocking_ecid = bpReportXMLNode.value('(./blocking-process/process/@ecid)[1]', 'int')
			) AS bpShredded
		WHERE s.name = @Source
		OPTION (MAXDOP 1);
	END

END



IF (@Type = 'XMLFILE')
BEGIN
	CREATE TABLE #TraceXML (
		id int identity primary key,
		ReportXML xml NOT NULL	
	)
	
	SET @SQL = N'
		INSERT #TraceXML(ReportXML)
		SELECT col FROM OPENROWSET (
				BULK ' + QUOTENAME(@Source, '''') + N', SINGLE_BLOB
			) as xmldata(col)';

	EXEC (@SQL);
	
	CREATE PRIMARY XML INDEX PXML_TraceXML ON #TraceXML(ReportXML);

	WITH XMLNAMESPACES 
	(
		'http://tempuri.org/TracePersistence.xsd' AS MY
	),
	ShreddedWheat AS 
	(
		SELECT
			bpShredded.blocked_ecid,
			bpShredded.blocked_spid,
			bpShredded.blocking_ecid,
			bpShredded.blocking_spid,
			bpShredded.monitorloop,
			bpReports.bpReportXml,
			bpReports.bpReportEndTime
		FROM #TraceXML
		CROSS APPLY 
			ReportXML.nodes('/MY:TraceData/MY:Events/MY:Event[@name="Blocked process report"]')
			AS eventNodes(eventNode)
		CROSS APPLY 
			eventNode.nodes('./MY:Column[@name="EndTime"]')
			AS endTimeNodes(endTimeNode)
		CROSS APPLY
			eventNode.nodes('./MY:Column[@name="TextData"]')
			AS bpNodes(bpNode)
		CROSS APPLY (
			SELECT CAST(bpNode.value('(./text())[1]', 'nvarchar(max)') as xml),
				CAST(LEFT(endTimeNode.value('(./text())[1]', 'varchar(max)'), 19) as datetime)
		) AS bpReports(bpReportXml, bpReportEndTime)
		CROSS APPLY (
			SELECT 
				monitorloop = bpReportXml.value('(//@monitorLoop)[1]', 'nvarchar(100)'),
				blocked_spid = bpReportXml.value('(/blocked-process-report/blocked-process/process/@spid)[1]', 'int'),
				blocked_ecid = bpReportXml.value('(/blocked-process-report/blocked-process/process/@ecid)[1]', 'int'),
				blocking_spid = bpReportXml.value('(/blocked-process-report/blocking-process/process/@spid)[1]', 'int'),
				blocking_ecid = bpReportXml.value('(/blocked-process-report/blocking-process/process/@ecid)[1]', 'int')
		) AS bpShredded
	)
	INSERT #ReportsXML(blocked_ecid,blocked_spid,blocking_ecid,blocking_spid,
		monitorloop,bpReportXml,endTime)
	SELECT blocked_ecid,blocked_spid,blocking_ecid,blocking_spid,
		COALESCE(monitorloop, CONVERT(nvarchar(100), bpReportEndTime, 120), 'unknown'),
		bpReportXml,bpReportEndTime
	FROM ShreddedWheat;
	
	DROP TABLE #TraceXML

END

-- Organize and select blocked process reports
;WITH Blockheads AS
(
	SELECT blocking_spid, blocking_ecid, monitorloop, blocking_hierarchy_string
	FROM #ReportsXML
	EXCEPT
	SELECT blocked_spid, blocked_ecid, monitorloop, blocked_hierarchy_string
	FROM #ReportsXML
), 
Hierarchy AS
(
	SELECT monitorloop, blocking_spid as spid, blocking_ecid as ecid, 
		cast('/' + blocking_hierarchy_string as varchar(max)) as chain,
		0 as level
	FROM Blockheads
	
	UNION ALL
	
	SELECT irx.monitorloop, irx.blocked_spid, irx.blocked_ecid,
		cast(h.chain + irx.blocked_hierarchy_string as varchar(max)),
		h.level+1
	FROM #ReportsXML irx
	JOIN Hierarchy h
		ON irx.monitorloop = h.monitorloop
		AND irx.blocking_spid = h.spid
		AND irx.blocking_ecid = h.ecid
)
SELECT 
	ISNULL(CONVERT(nvarchar(30), irx.endTime, 120), 
		'Lead') as traceTime,
	SPACE(4 * h.level) 
		+ CAST(h.spid as varchar(20)) 
		+ CASE h.ecid 
			WHEN 0 THEN ''
			ELSE '(' + CAST(h.ecid as varchar(20)) + ')' 
		END AS blockingTree,
	irx.bpReportXml
from Hierarchy h
left join #ReportsXML irx
	on irx.monitorloop = h.monitorloop
	and irx.blocked_spid = h.spid
	and irx.blocked_ecid = h.ecid
order by h.monitorloop, h.chain

DROP TABLE #ReportsXML

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>BlitzIndex.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>BlitzIndex.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_000_303_BlitzIndex.sql

SET ANSI_NULLS ON;
SET ANSI_PADDING ON;
SET ANSI_WARNINGS ON;
SET ARITHABORT ON;
SET CONCAT_NULL_YIELDS_NULL ON;
SET QUOTED_IDENTIFIER ON;
SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;
GO

USE master;
GO

IF OBJECT_ID('dbo.sp_BlitzIndex') IS NOT NULL 
	DROP PROCEDURE dbo.sp_BlitzIndex;
GO

CREATE PROCEDURE dbo.sp_BlitzIndex
	@DatabaseName NVARCHAR(128) = null, /*Defaults to current DB if not specified*/
	@Mode tinyint=0, /*0=diagnose, 1=Summarize, 2=Index Usage Detail, 3=Missing Index Detail*/
	@SchemaName NVARCHAR(128) = NULL, /*Requires table_name as well.*/
	@TableName NVARCHAR(128) = NULL,  /*Requires schema_name as well.*/
		/*Note:@Mode doesn't matter if you're specifying schema_name and @TableName.*/
	@Filter tinyint = 0 /* 0=no filter (default). 1=No low-usage warnings for objects with 0 reads. 2=Only warn for objects &gt;= 500MB */
		/*Note:@Filter doesn't do anything unless @Mode=0*/
/*
sp_BlitzIndex(TM) v2.02 - Jan 30, 2014

(C) 2014, Brent Ozar Unlimited(TM). 
See http://BrentOzar.com/go/eula for the End User Licensing Agreement.

For help and how-to info, visit http://www.BrentOzar.com/BlitzIndex

How to use:
--	Diagnose:
		EXEC dbo.sp_BlitzIndex @DatabaseName='AdventureWorks';
--	Return detail for a specific table:
		EXEC dbo.sp_BlitzIndex @DatabaseName='AdventureWorks', @SchemaName='Person', @TableName='Person';

Known limitations of this version:
 - Does not include FULLTEXT indexes. (A possibility in the future, let us know if you're interested.)
 - Index create statements are just to give you a rough idea of the syntax. It includes filters and fillfactor.
 --		Example 1: index creates use ONLINE=? instead of ONLINE=ON / ONLINE=OFF. This is because it's important for the user to understand if it's going to be offline and not just run a script.
 --		Example 2: they do not include all the options the index may have been created with (padding, compression filegroup/partition scheme etc.)
 --		(The compression and filegroup index create syntax isn't trivial because it's set at the partition level and isn't trivial to code. Two people have voted for wanting it so far.)
 - Doesn't advise you about data modeling for clustered indexes and primary keys (primarily looks for signs of insanity.)
 - Found something? Let us know at help@brentozar.com.

 Thanks for using sp_BlitzIndex(TM)!
 Sincerely,
 The Humans of Brent Ozar Unlimited(TM)

CHANGE LOG (last five versions):
	Jan 30, 2014 (v2.02)
		Standardized calling parameters with sp_AskBrent(TM) and sp_BlitzIndex(TM). (@DatabaseName instead of @database_name, etc)
		Added check_id 80 and 81-- what appear to be the most frequently used indexes (workaholics)
		Added index_operational_stats info to table level output -- recent scans vs lookups
		Broke index_usage_stats output into two categories, scans and lookups (also in table level output)
		Changed db name, table name, index name to 128 length
		Fixed findings_group column length in #BlitzIndexResults (fixed issues for users w/ longer db names)
		Fixed issue where identities nearing end of range were only detected if the check was run with a specific db context
			Fixed extra tab in @SchemaName= that made pasting into Excel awkward/wrong
		Added abnormal psychology check for clustered columnstore indexes (and general support for detecting them)
		Standardized underscores in create TSQL for missing indexes
		Better error message when running in table mode and the table isn't found.
		Added current timestamp to the header based on user request. (Didn't add startup time-- sorry! Too many things reset usage info, don't want to mislead anyone.)
		Added fillfactor to index create statements.
		Changed all index create statements to ONLINE=?, SORT_IN_TEMPDB=?. The user should decide at index create time what's right for them.
	May 26, 2013 (v2.01)
		Added check_id 28: Non-unqiue clustered indexes. (This should have been checked in for an earlier version, it slipped by).
	May 14, 2013 (v2.0) - Added data types and max length to all columns (keys, includes, secret columns)
		Set sp_blitz to default to current DB if database_name is not specified when called
		Added @Filter:  
			0=no filter (default)
			1=Don't throw low-usage warnings for objects with 0 reads (helpful for dev/non-production environments)
			2=Only report on objects &gt;= 250MB (helps focus on larger indexes). Still runs a few database-wide checks as well.
		Added list of all columns and types in table for runs using: @DatabaseName, @SchemaName, @TableName
		Added count of total number of indexes a column is part of.
		Added check_id 25: Addicted to nullable columns. (All or all but one column is nullable.)
		Added check_id 66 and 67 to flag tables/indexes created within 1 week or modified within 48 hours.
		Added check_id 26: Wide tables (35+ cols or &gt; 2000 non-LOB bytes).
		Added check_id 27: Addicted to strings. Looks for tables with 4 or more columns, of which all or all but one are string or LOB types.
		Added check_id 68: Identity columns within 30% of the end of range (tinyint, smallint, int) AND
			Negative identity seeds or identity increments &lt;&gt; 1
		Added check_id 69: Column collation does not match database collation
		Added check_id 70: Replicated columns. This identifies which columns are in at least one replication publication.
		Added check_id 71: Cascading updates or cascading deletes.
		Split check_id 40 into two checks: fillfactor on nonclustered indexes &lt; 80%, fillfactor on clustered indexes &lt; 90%
		Added check_id 33: Potential filtered indexes based on column names.
		Fixed bug where you couldn't see detailed view for indexed views. 
			(Ex: EXEC dbo.sp_BlitzIndex @DatabaseName='AdventureWorks', @SchemaName='Production', @TableName='vProductAndDescription';)
		Added four index usage columns to table detail output: last_user_seek, last_user_scan, last_user_lookup, last_user_update
		Modified check_id 24. This now looks for wide clustered indexes (&gt; 3 columns OR &gt; 16 bytes).
			Previously just simplistically looked for multiple column CX.
		Removed extra spacing (non-breaking) in more_info column.
		Fixed bug where create t-sql didn't include filter (for filtered indexes)
		Fixed formatting bug where "magic number" in table detail view didn't have commas
		Neatened up column names in result sets.
	April 8, 2013 (v1.5) - Fixed breaking bug for partitioned tables with &gt; 10(ish) partitions
		Added schema_name to suggested create statement for PKs
		Handled "magic_benefit_number" values for missing indexes &gt;= 922,337,203,685,477
		Added count of NC indexes to Index Hoarder: Multi-column clustered index finding
		Added link to EULA
		Simplified aggressive index checks (blocking). Multiple checks confused people more than it helped.
			Left only "Total lock wait time &gt; 5 minutes (row + page)".
		Added CheckId 25 for non-unique clustered indexes. 
		The "Create TSQL" column now shows a commented out drop command for disabled non-clustered indexes
		Updated query which joins to sys.dm_operational_stats DMV when running against 2012 for performance reasons
	December 20, 2012 (v1.4) - Fixed bugs for instances using a case-sensitive collation
		Added support to identify compressed indexes
		Added basic support for columnstore, XML, and spatial indexes
		Added "Abnormal Psychology" diagnosis to alert you to special index types in a database
		Removed hypothetical indexes and disabled indexes from "multiple personality disorders"
		Fixed bug where hypothetical indexes weren't showing up in "self-loathing indexes"
		Fixed bug where the partitioning key column was displayed in the key of aligned nonclustered indexes on partitioned tables
		Added set options to the script so procedure is created with required settings for its use of computed columns

*/
AS 

SET NOCOUNT ON;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;


DECLARE	@DatabaseID INT;
DECLARE @ObjectID INT;
DECLARE	@dsql NVARCHAR(MAX);
DECLARE @params NVARCHAR(MAX);
DECLARE	@msg NVARCHAR(4000);
DECLARE	@ErrorSeverity INT;
DECLARE	@ErrorState INT;
DECLARE	@Rowcount BIGINT;
DECLARE @SQLServerProductVersion NVARCHAR(128);
DECLARE @SQLServerEdition INT;
DECLARE @FilterMB INT;
DECLARE @collation NVARCHAR(256);


SELECT @SQLServerProductVersion = CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128));
SELECT @SQLServerEdition =CAST(SERVERPROPERTY('EngineEdition') AS INT); /* We default to online index creates where EngineEdition=3*/
SET @FilterMB=250;

IF @DatabaseName is null 
	SET @DatabaseName=DB_NAME();

SELECT	@DatabaseID = database_id
FROM	sys.databases
WHERE	[name] = @DatabaseName
	AND user_access_desc='MULTI_USER'
	AND state_desc = 'ONLINE';

----------------------------------------
--STEP 1: OBSERVE THE PATIENT
--This step puts index information into temp tables.
----------------------------------------
BEGIN TRY
	BEGIN

		--Validate SQL Server Verson

		IF (SELECT LEFT(@SQLServerProductVersion,
			  CHARINDEX('.',@SQLServerProductVersion,0)-1
			  )) &lt;= 8
		BEGIN
			SET @msg=N'sp_BlitzIndex is only supported on SQL Server 2005 and higher. The version of this instance is: ' + @SQLServerProductVersion;
			RAISERROR(@msg,16,1);
		END

		--Short circuit here if database name does not exist.
		IF @DatabaseName IS NULL OR @DatabaseID IS NULL
		BEGIN
			SET @msg='Database does not exist or is not online/multi-user: cannot proceed.'
			RAISERROR(@msg,16,1);
		END    

		--Validate parameters.
		IF (@Mode NOT IN (0,1,2,3))
		BEGIN
			SET @msg=N'Invalid @Mode parameter. 0=diagnose, 1=summarize, 2=index detail, 3=missing index detail';
			RAISERROR(@msg,16,1);
		END

		IF (@Mode &lt;&gt; 0 AND @TableName IS NOT NULL)
		BEGIN
			SET @msg=N'Setting the @Mode doesn''t change behavior if you supply @TableName. Use default @Mode=0 to see table detail.';
			RAISERROR(@msg,16,1);
		END

		IF ((@Mode &lt;&gt; 0 OR @TableName IS NOT NULL) and @Filter &lt;&gt; 0)
		BEGIN
			SET @msg=N'@Filter only appies when @Mode=0 and @TableName is not specified. Please try again.';
			RAISERROR(@msg,16,1);
		END

		IF (@SchemaName IS NOT NULL AND @TableName IS NULL) 
		BEGIN
			SET @msg='We can''t run against a whole schema! Specify a @TableName, or leave both NULL for diagnosis.'
			RAISERROR(@msg,16,1);
		END


		IF  (@TableName IS NOT NULL AND @SchemaName IS NULL)
		BEGIN
			SET @SchemaName=N'dbo'
			SET @msg='@SchemaName wasn''t specified-- assuming schema=dbo.'
			RAISERROR(@msg,1,1) WITH NOWAIT;
		END

		--If a table is specified, grab the object id.
		--Short circuit if it doesn't exist.
		IF @TableName IS NOT NULL
		BEGIN
			SET @dsql = N'
					SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
					SELECT	@ObjectID= OBJECT_ID
					FROM	' + QUOTENAME(@DatabaseName) + N'.sys.objects AS so
					JOIN	' + QUOTENAME(@DatabaseName) + N'.sys.schemas AS sc on 
						so.schema_id=sc.schema_id
					where so.type in (''U'', ''V'')
					and so.name=' + QUOTENAME(@TableName,'''')+ N'
					and sc.name=' + QUOTENAME(@SchemaName,'''')+ N'
					/*Has a row in sys.indexes. This lets us get indexed views.*/
					and exists (
						SELECT si.name
						FROM ' + QUOTENAME(@DatabaseName) + '.sys.indexes AS si 
						WHERE so.object_id=si.object_id)
					OPTION (RECOMPILE);';

			SET @params='@ObjectID INT OUTPUT'				

			IF @dsql IS NULL 
				RAISERROR('@dsql is null',16,1);

			EXEC sp_executesql @dsql, @params, @ObjectID=@ObjectID OUTPUT;
			
			IF @ObjectID IS NULL
					BEGIN
						SET @msg=N'Oh, this is awkward. I can''t find the table or indexed view you''re looking for in that database.' + CHAR(10) +
							N'Please check your parameters.'
						RAISERROR(@msg,1,1);
						RETURN;
					END
		END

		RAISERROR(N'Starting run. sp_BlitzIndex(TM) v2.02 - Jan 30, 2014', 0,1) WITH NOWAIT;

		IF OBJECT_ID('tempdb..#IndexSanity') IS NOT NULL 
			DROP TABLE #IndexSanity;

		IF OBJECT_ID('tempdb..#IndexPartitionSanity') IS NOT NULL 
			DROP TABLE #IndexPartitionSanity;

		IF OBJECT_ID('tempdb..#IndexSanitySize') IS NOT NULL 
			DROP TABLE #IndexSanitySize;

		IF OBJECT_ID('tempdb..#IndexColumns') IS NOT NULL 
			DROP TABLE #IndexColumns;

		IF OBJECT_ID('tempdb..#MissingIndexes') IS NOT NULL 
			DROP TABLE #MissingIndexes;

		IF OBJECT_ID('tempdb..#ForeignKeys') IS NOT NULL 
			DROP TABLE #ForeignKeys;

		IF OBJECT_ID('tempdb..#BlitzIndexResults') IS NOT NULL 
			DROP TABLE #BlitzIndexResults;
		
		IF OBJECT_ID('tempdb..#IndexCreateTsql') IS NOT NULL	
			DROP TABLE #IndexCreateTsql;

		RAISERROR (N'Create temp tables.',0,1) WITH NOWAIT;
		CREATE TABLE #BlitzIndexResults
			(
			  blitz_result_id INT IDENTITY PRIMARY KEY,
			  check_id INT NOT NULL,
			  index_sanity_id INT NULL,
			  findings_group VARCHAR(4000) NOT NULL,
			  finding VARCHAR(200) NOT NULL,
			  URL VARCHAR(200) NOT NULL,
			  details NVARCHAR(4000) NOT NULL,
			  index_definition NVARCHAR(MAX) NOT NULL,
			  secret_columns NVARCHAR(MAX) NULL,
			  index_usage_summary NVARCHAR(MAX) NULL,
			  index_size_summary NVARCHAR(MAX) NULL,
			  create_tsql NVARCHAR(MAX) NULL,
			  more_info NVARCHAR(MAX)NULL
			);

		CREATE TABLE #IndexSanity
			(
			  [index_sanity_id] INT IDENTITY PRIMARY KEY,
			  [database_id] SMALLINT NOT NULL ,
			  [object_id] INT NOT NULL ,
			  [index_id] INT NOT NULL ,
			  [index_type] TINYINT NOT NULL,
			  [database_name] NVARCHAR(128) NOT NULL ,
			  [schema_name] NVARCHAR(128) NOT NULL ,
			  [object_name] NVARCHAR(128) NOT NULL ,
			  index_name NVARCHAR(128) NULL ,
			  key_column_names NVARCHAR(MAX) NULL ,
			  key_column_names_with_sort_order NVARCHAR(MAX) NULL ,
			  key_column_names_with_sort_order_no_types NVARCHAR(MAX) NULL ,
			  count_key_columns INT NULL ,
			  include_column_names NVARCHAR(MAX) NULL ,
			  include_column_names_no_types NVARCHAR(MAX) NULL ,
			  count_included_columns INT NULL ,
			  partition_key_column_name NVARCHAR(MAX) NULL,
			  filter_definition NVARCHAR(MAX) NOT NULL ,
			  is_indexed_view BIT NOT NULL ,
			  is_unique BIT NOT NULL ,
			  is_primary_key BIT NOT NULL ,
			  is_XML BIT NOT NULL,
			  is_spatial BIT NOT NULL,
			  is_NC_columnstore BIT NOT NULL,
			  is_CX_columnstore BIT NOT NULL,
			  is_disabled BIT NOT NULL ,
			  is_hypothetical BIT NOT NULL ,
			  is_padded BIT NOT NULL ,
			  fill_factor SMALLINT NOT NULL ,
			  user_seeks BIGINT NOT NULL ,
			  user_scans BIGINT NOT NULL ,
			  user_lookups BIGINT NOT  NULL ,
			  user_updates BIGINT NULL ,
			  last_user_seek DATETIME NULL ,
			  last_user_scan DATETIME NULL ,
			  last_user_lookup DATETIME NULL ,
			  last_user_update DATETIME NULL ,
			  is_referenced_by_foreign_key BIT DEFAULT(0),
			  secret_columns NVARCHAR(MAX) NULL,
			  count_secret_columns INT NULL,
			  create_date DATETIME NOT NULL,
			  modify_date DATETIME NOT NULL
			);	

		CREATE TABLE #IndexPartitionSanity
			(
			  [index_partition_sanity_id] INT IDENTITY PRIMARY KEY ,
			  [index_sanity_id] INT NULL ,
			  [object_id] INT NOT NULL ,
			  [index_id] INT NOT NULL ,
			  [partition_number] INT NOT NULL ,
			  row_count BIGINT NOT NULL ,
			  reserved_MB NUMERIC(29,2) NOT NULL ,
			  reserved_LOB_MB NUMERIC(29,2) NOT NULL ,
			  reserved_row_overflow_MB NUMERIC(29,2) NOT NULL ,
			  leaf_insert_count BIGINT NULL ,
			  leaf_delete_count BIGINT NULL ,
			  leaf_update_count BIGINT NULL ,
			  range_scan_count BIGINT NULL ,
			  singleton_lookup_count BIGINT NULL , 
			  forwarded_fetch_count BIGINT NULL ,
			  lob_fetch_in_pages BIGINT NULL ,
			  lob_fetch_in_bytes BIGINT NULL ,
			  row_overflow_fetch_in_pages BIGINT NULL ,
			  row_overflow_fetch_in_bytes BIGINT NULL ,
			  row_lock_count BIGINT NULL ,
			  row_lock_wait_count BIGINT NULL ,
			  row_lock_wait_in_ms BIGINT NULL ,
			  page_lock_count BIGINT NULL ,
			  page_lock_wait_count BIGINT NULL ,
			  page_lock_wait_in_ms BIGINT NULL ,
			  index_lock_promotion_attempt_count BIGINT NULL ,
			  index_lock_promotion_count BIGINT NULL,
  			  data_compression_desc VARCHAR(60) NULL
			);

		CREATE TABLE #IndexSanitySize
			(
			  [index_sanity_size_id] INT IDENTITY NOT NULL ,
			  [index_sanity_id] INT NOT NULL ,
			  partition_count INT NOT NULL ,
			  total_rows BIGINT NOT NULL ,
			  total_reserved_MB NUMERIC(29,2) NOT NULL ,
			  total_reserved_LOB_MB NUMERIC(29,2) NOT NULL ,
			  total_reserved_row_overflow_MB NUMERIC(29,2) NOT NULL ,
			  total_leaf_delete_count BIGINT NULL,
			  total_leaf_update_count BIGINT NULL,
			  total_range_scan_count BIGINT NULL,
			  total_singleton_lookup_count BIGINT NULL,
			  total_forwarded_fetch_count BIGINT NULL,
			  total_row_lock_count BIGINT NULL ,
			  total_row_lock_wait_count BIGINT NULL ,
			  total_row_lock_wait_in_ms BIGINT NULL ,
			  avg_row_lock_wait_in_ms BIGINT NULL ,
			  total_page_lock_count BIGINT NULL ,
			  total_page_lock_wait_count BIGINT NULL ,
			  total_page_lock_wait_in_ms BIGINT NULL ,
			  avg_page_lock_wait_in_ms BIGINT NULL ,
 			  total_index_lock_promotion_attempt_count BIGINT NULL ,
			  total_index_lock_promotion_count BIGINT NULL ,
			  data_compression_desc VARCHAR(8000) NULL
			);

		CREATE TABLE #IndexColumns
			(
			  [object_id] INT NOT NULL ,
			  [index_id] INT NOT NULL ,
			  [key_ordinal] INT NULL ,
			  is_included_column BIT NULL ,
			  is_descending_key BIT NULL ,
			  [partition_ordinal] INT NULL ,
			  column_name NVARCHAR(256) NOT NULL ,
			  system_type_name NVARCHAR(256) NOT NULL,
			  max_length SMALLINT NOT NULL,
			  [precision] TINYINT NOT NULL,
			  [scale] TINYINT NOT NULL,
			  collation_name NVARCHAR(256) NULL,
			  is_nullable bit NULL,
			  is_identity bit NULL,
			  is_computed bit NULL,
			  is_replicated bit NULL,
			  is_sparse bit NULL,
			  is_filestream bit NULL,
			  seed_value BIGINT NULL,
			  increment_value INT NULL ,
			  last_value BIGINT NULL,
			  is_not_for_replication BIT NULL
			);

		CREATE TABLE #MissingIndexes
			([object_id] INT NOT NULL,
			[database_name] NVARCHAR(128) NOT NULL ,
			[schema_name] NVARCHAR(128) NOT NULL ,
			[table_name] NVARCHAR(128),
			[statement] NVARCHAR(512) NOT NULL,
			magic_benefit_number AS (( user_seeks + user_scans ) * avg_total_user_cost * avg_user_impact),
			avg_total_user_cost NUMERIC(29,1) NOT NULL,
			avg_user_impact NUMERIC(29,1) NOT NULL,
			user_seeks BIGINT NOT NULL,
			user_scans BIGINT NOT NULL,
			unique_compiles BIGINT NULL,
			equality_columns NVARCHAR(4000), 
			inequality_columns NVARCHAR(4000),
			included_columns NVARCHAR(4000)
			);

		CREATE TABLE #ForeignKeys (
			foreign_key_name NVARCHAR(256),
			parent_object_id INT,
			parent_object_name NVARCHAR(256),
			referenced_object_id INT,
			referenced_object_name NVARCHAR(256),
			is_disabled BIT,
			is_not_trusted BIT,
			is_not_for_replication BIT,
			parent_fk_columns NVARCHAR(MAX),
			referenced_fk_columns NVARCHAR(MAX),
			update_referential_action_desc NVARCHAR(16),
			delete_referential_action_desc NVARCHAR(60)
		)
		
		CREATE TABLE #IndexCreateTsql (
			index_sanity_id INT NOT NULL,
			create_tsql NVARCHAR(MAX) NOT NULL
		)

		--set @collation
		SELECT @collation=collation_name
		FROM sys.databases
		where database_id=@DatabaseID;

		--insert columns for clustered indexes and heaps
		--collect info on identity columns for this one
		SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
				SELECT	
					si.object_id, 
					si.index_id, 
					sc.key_ordinal, 
					sc.is_included_column, 
					sc.is_descending_key,
					sc.partition_ordinal,
					c.name as column_name, 
					st.name as system_type_name,
					c.max_length,
					c.[precision],
					c.[scale],
					c.collation_name,
					c.is_nullable,
					c.is_identity,
					c.is_computed,
					c.is_replicated,
					' + case when @SQLServerProductVersion not like '9%' THEN N'c.is_sparse' else N'NULL as is_sparse' END + N',
					' + case when @SQLServerProductVersion not like '9%' THEN N'c.is_filestream' else N'NULL as is_filestream' END + N',
					CAST(ic.seed_value AS BIGINT),
					CAST(ic.increment_value AS INT),
					CAST(ic.last_value AS BIGINT),
					ic.is_not_for_replication
				FROM	' + QUOTENAME(@DatabaseName) + N'.sys.indexes si
				JOIN	' + QUOTENAME(@DatabaseName) + N'.sys.columns c ON
					si.object_id=c.object_id
				LEFT JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.index_columns sc ON 
					sc.object_id = si.object_id
					and sc.index_id=si.index_id
					AND sc.column_id=c.column_id
				LEFT JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.identity_columns ic ON
					c.object_id=ic.object_id and
					c.column_id=ic.column_id
				JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.types st ON 
					c.system_type_id=st.system_type_id
					AND c.user_type_id=st.user_type_id
				WHERE si.index_id in (0,1) ' 
					+ CASE WHEN @ObjectID IS NOT NULL 
						THEN N' AND si.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) 
					ELSE N'' END 
				+ N';';

		IF @dsql IS NULL 
			RAISERROR('@dsql is null',16,1);

		RAISERROR (N'Inserting data into #IndexColumns for clustered indexes and heaps',0,1) WITH NOWAIT;
		INSERT	#IndexColumns ( object_id, index_id, key_ordinal, is_included_column, is_descending_key, partition_ordinal,
			column_name, system_type_name, max_length, precision, scale, collation_name, is_nullable, is_identity, is_computed,
			is_replicated, is_sparse, is_filestream, seed_value, increment_value, last_value, is_not_for_replication )
				EXEC sp_executesql @dsql;

		--insert columns for nonclustered indexes
		--this uses a full join to sys.index_columns
		--We don't collect info on identity columns here. They may be in NC indexes, but we just analyze identities in the base table.
		SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
				SELECT	
					si.object_id, 
					si.index_id, 
					sc.key_ordinal, 
					sc.is_included_column, 
					sc.is_descending_key,
					sc.partition_ordinal,
					c.name as column_name, 
					st.name as system_type_name,
					c.max_length,
					c.[precision],
					c.[scale],
					c.collation_name,
					c.is_nullable,
					c.is_identity,
					c.is_computed,
					c.is_replicated,
					' + case when @SQLServerProductVersion not like '9%' THEN N'c.is_sparse' else N'NULL AS is_sparse' END + N',
					' + case when @SQLServerProductVersion not like '9%' THEN N'c.is_filestream' else N'NULL AS is_filestream' END + N'				
				FROM	' + QUOTENAME(@DatabaseName) + N'.sys.indexes AS si
				JOIN	' + QUOTENAME(@DatabaseName) + N'.sys.columns AS c ON
					si.object_id=c.object_id
				JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.index_columns AS sc ON 
					sc.object_id = si.object_id
					and sc.index_id=si.index_id
					AND sc.column_id=c.column_id
				JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.types AS st ON 
					c.system_type_id=st.system_type_id
					AND c.user_type_id=st.user_type_id
				WHERE si.index_id not in (0,1) ' 
					+ CASE WHEN @ObjectID IS NOT NULL 
						THEN N' AND si.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) 
					ELSE N'' END 
				+ N';';

		IF @dsql IS NULL 
			RAISERROR('@dsql is null',16,1);

		RAISERROR (N'Inserting data into #IndexColumns for nonclustered indexes',0,1) WITH NOWAIT;
		INSERT	#IndexColumns ( object_id, index_id, key_ordinal, is_included_column, is_descending_key, partition_ordinal,
			column_name, system_type_name, max_length, precision, scale, collation_name, is_nullable, is_identity, is_computed,
			is_replicated, is_sparse, is_filestream )
				EXEC sp_executesql @dsql;
					
		SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
				SELECT	' + CAST(@DatabaseID AS NVARCHAR(10)) + ' AS database_id, 
						so.object_id, 
						si.index_id, 
						si.type,
						' + QUOTENAME(@DatabaseName, '''') + ' AS database_name, 
						sc.NAME AS [schema_name],
						so.name AS [object_name], 
						si.name AS [index_name],
						CASE	WHEN so.[type] = CAST(''V'' AS CHAR(2)) THEN 1 ELSE 0 END, 
						si.is_unique, 
						si.is_primary_key, 
						CASE when si.type = 3 THEN 1 ELSE 0 END AS is_XML,
						CASE when si.type = 4 THEN 1 ELSE 0 END AS is_spatial,
						CASE when si.type = 6 THEN 1 ELSE 0 END AS is_NC_columnstore,
						CASE when si.type = 5 then 1 else 0 end as is_CX_columnstore,
						si.is_disabled,
						si.is_hypothetical, 
						si.is_padded, 
						si.fill_factor,'
						+ case when @SQLServerProductVersion not like '9%' THEN '
						CASE WHEN si.filter_definition IS NOT NULL THEN si.filter_definition
							 ELSE ''''
						END AS filter_definition' ELSE ''''' AS filter_definition' END + '
						, ISNULL(us.user_seeks, 0), ISNULL(us.user_scans, 0),
						ISNULL(us.user_lookups, 0), ISNULL(us.user_updates, 0), us.last_user_seek, us.last_user_scan,
						us.last_user_lookup, us.last_user_update,
						so.create_date, so.modify_date
				FROM	' + QUOTENAME(@DatabaseName) + '.sys.indexes AS si WITH (NOLOCK)
						JOIN ' + QUOTENAME(@DatabaseName) + '.sys.objects AS so WITH (NOLOCK) ON si.object_id = so.object_id
											   AND so.is_ms_shipped = 0 /*Exclude objects shipped by Microsoft*/
											   AND so.type &lt;&gt; ''TF'' /*Exclude table valued functions*/
						JOIN ' + QUOTENAME(@DatabaseName) + '.sys.schemas sc ON so.schema_id = sc.schema_id
						LEFT JOIN sys.dm_db_index_usage_stats AS us WITH (NOLOCK) ON si.[object_id] = us.[object_id]
																	   AND si.index_id = us.index_id
																	   AND us.database_id = '+ CAST(@DatabaseID AS NVARCHAR(10)) + '
				WHERE	si.[type] IN ( 0, 1, 2, 3, 4, 5, 6 ) 
				/* Heaps, clustered, nonclustered, XML, spatial, Cluster Columnstore, NC Columnstore */ ' +
				CASE WHEN @TableName IS NOT NULL THEN ' and so.name=' + QUOTENAME(@TableName,'''') + ' ' ELSE '' END + 
		'OPTION	( RECOMPILE );
		';
		IF @dsql IS NULL 
			RAISERROR('@dsql is null',16,1);

		RAISERROR (N'Inserting data into #IndexSanity',0,1) WITH NOWAIT;
		INSERT	#IndexSanity ( [database_id], [object_id], [index_id], [index_type], [database_name], [schema_name], [object_name],
								index_name, is_indexed_view, is_unique, is_primary_key, is_XML, is_spatial, is_NC_columnstore, is_CX_columnstore,
								is_disabled, is_hypothetical, is_padded, fill_factor, filter_definition, user_seeks, user_scans, 
								user_lookups, user_updates, last_user_seek, last_user_scan, last_user_lookup, last_user_update,
								create_date, modify_date )
				EXEC sp_executesql @dsql;

		RAISERROR (N'Updating #IndexSanity.key_column_names',0,1) WITH NOWAIT;
		UPDATE	#IndexSanity
		SET		key_column_names = D1.key_column_names
		FROM	#IndexSanity si
				CROSS APPLY ( SELECT	RTRIM(STUFF( (SELECT	N', ' + c.column_name 
									+ N' {' + system_type_name + N' ' + CAST(max_length AS NVARCHAR(50)) +  N'}'
										AS col_definition
									FROM	#IndexColumns c
									WHERE	c.object_id = si.object_id
											AND c.index_id = si.index_id
											AND c.is_included_column = 0 /*Just Keys*/
											AND c.key_ordinal &gt; 0 /*Ignore non-key columns, such as partitioning keys*/
									ORDER BY c.object_id, c.index_id, c.key_ordinal	
							FOR	  XML PATH('') ,TYPE).value('.', 'varchar(max)'), 1, 1, ''))
										) D1 ( key_column_names )

		RAISERROR (N'Updating #IndexSanity.partition_key_column_name',0,1) WITH NOWAIT;
		UPDATE	#IndexSanity
		SET		partition_key_column_name = D1.partition_key_column_name
		FROM	#IndexSanity si
				CROSS APPLY ( SELECT	RTRIM(STUFF( (SELECT	N', ' + c.column_name AS col_definition
									FROM	#IndexColumns c
									WHERE	c.object_id = si.object_id
											AND c.index_id = si.index_id
											AND c.partition_ordinal &lt;&gt; 0 /*Just Partitioned Keys*/
									ORDER BY c.object_id, c.index_id, c.key_ordinal	
							FOR	  XML PATH('') , TYPE).value('.', 'varchar(max)'), 1, 1,''))) D1 
										( partition_key_column_name )

		RAISERROR (N'Updating #IndexSanity.key_column_names_with_sort_order',0,1) WITH NOWAIT;
		UPDATE	#IndexSanity
		SET		key_column_names_with_sort_order = D2.key_column_names_with_sort_order
		FROM	#IndexSanity si
				CROSS APPLY ( SELECT	RTRIM(STUFF( (SELECT	N', ' + c.column_name + CASE c.is_descending_key
									WHEN 1 THEN N' DESC'
									ELSE N''
								+ N' {' + system_type_name + N' ' + CAST(max_length AS NVARCHAR(50)) +  N'}'
								END AS col_definition
							FROM	#IndexColumns c
							WHERE	c.object_id = si.object_id
									AND c.index_id = si.index_id
									AND c.is_included_column = 0 /*Just Keys*/
									AND c.key_ordinal &gt; 0 /*Ignore non-key columns, such as partitioning keys*/
							ORDER BY c.object_id, c.index_id, c.key_ordinal	
					FOR	  XML PATH('') , TYPE).value('.', 'varchar(max)'), 1, 1, ''))
					) D2 ( key_column_names_with_sort_order )

		RAISERROR (N'Updating #IndexSanity.key_column_names_with_sort_order_no_types (for create tsql)',0,1) WITH NOWAIT;
		UPDATE	#IndexSanity
		SET		key_column_names_with_sort_order_no_types = D2.key_column_names_with_sort_order_no_types
		FROM	#IndexSanity si
				CROSS APPLY ( SELECT	RTRIM(STUFF( (SELECT	N', ' + QUOTENAME(c.column_name) + CASE c.is_descending_key
									WHEN 1 THEN N' [DESC]'
									ELSE N''
								END AS col_definition
							FROM	#IndexColumns c
							WHERE	c.object_id = si.object_id
									AND c.index_id = si.index_id
									AND c.is_included_column = 0 /*Just Keys*/
									AND c.key_ordinal &gt; 0 /*Ignore non-key columns, such as partitioning keys*/
							ORDER BY c.object_id, c.index_id, c.key_ordinal	
					FOR	  XML PATH('') , TYPE).value('.', 'varchar(max)'), 1, 1, ''))
					) D2 ( key_column_names_with_sort_order_no_types )

		RAISERROR (N'Updating #IndexSanity.include_column_names',0,1) WITH NOWAIT;
		UPDATE	#IndexSanity
		SET		include_column_names = D3.include_column_names
		FROM	#IndexSanity si
				CROSS APPLY ( SELECT	RTRIM(STUFF( (SELECT	N', ' + c.column_name
								+ N' {' + system_type_name + N' ' + CAST(max_length AS NVARCHAR(50)) +  N'}'
								FROM	#IndexColumns c
								WHERE	c.object_id = si.object_id
										AND c.index_id = si.index_id
										AND c.is_included_column = 1 /*Just includes*/
								ORDER BY c.column_name /*Order doesn't matter in includes, 
										this is here to make rows easy to compare.*/ 
						FOR	  XML PATH('') ,  TYPE).value('.', 'varchar(max)'), 1, 1, ''))
						) D3 ( include_column_names );

		RAISERROR (N'Updating #IndexSanity.include_column_names_no_types (for create tsql)',0,1) WITH NOWAIT;
		UPDATE	#IndexSanity
		SET		include_column_names_no_types = D3.include_column_names_no_types
		FROM	#IndexSanity si
				CROSS APPLY ( SELECT	RTRIM(STUFF( (SELECT	N', ' + QUOTENAME(c.column_name)
								FROM	#IndexColumns c
								WHERE	c.object_id = si.object_id
										AND c.index_id = si.index_id
										AND c.is_included_column = 1 /*Just includes*/
								ORDER BY c.column_name /*Order doesn't matter in includes, 
										this is here to make rows easy to compare.*/ 
						FOR	  XML PATH('') ,  TYPE).value('.', 'varchar(max)'), 1, 1, ''))
						) D3 ( include_column_names_no_types );

		RAISERROR (N'Updating #IndexSanity.count_key_columns and count_include_columns',0,1) WITH NOWAIT;
		UPDATE	#IndexSanity
		SET		count_included_columns = D4.count_included_columns,
				count_key_columns = D4.count_key_columns
		FROM	#IndexSanity si
				CROSS APPLY ( SELECT	SUM(CASE WHEN is_included_column = 'true' THEN 1
												 ELSE 0
											END) AS count_included_columns,
										SUM(CASE WHEN is_included_column = 'false' AND c.key_ordinal &gt; 0 THEN 1
												 ELSE 0
											END) AS count_key_columns
							  FROM		#IndexColumns c
							  WHERE		c.object_id = si.object_id
										AND c.index_id = si.index_id 
										) AS D4 ( count_included_columns, count_key_columns );

		IF (SELECT LEFT(@SQLServerProductVersion,
			  CHARINDEX('.',@SQLServerProductVersion,0)-1
			  )) &lt;&gt; 11 --Anything other than 2012
		BEGIN

			RAISERROR (N'Using non-2012 syntax to query sys.dm_db_index_operational_stats',0,1) WITH NOWAIT;

			--NOTE: we're joining to sys.dm_db_index_operational_stats differently than you might think (not using a cross apply)
			--This is because of quirks prior to SQL Server 2012 and in 2014 with this DMV.
			SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
						SELECT	ps.object_id, 
								ps.index_id, 
								ps.partition_number, 
								ps.row_count,
								ps.reserved_page_count * 8. / 1024. AS reserved_MB,
								ps.lob_reserved_page_count * 8. / 1024. AS reserved_LOB_MB,
								ps.row_overflow_reserved_page_count * 8. / 1024. AS reserved_row_overflow_MB,
								os.leaf_insert_count, 
								os.leaf_delete_count, 
								os.leaf_update_count, 
								os.range_scan_count, 
								os.singleton_lookup_count,  
								os.forwarded_fetch_count,
								os.lob_fetch_in_pages, 
								os.lob_fetch_in_bytes, 
								os.row_overflow_fetch_in_pages,
								os.row_overflow_fetch_in_bytes, 
								os.row_lock_count, 
								os.row_lock_wait_count,
								os.row_lock_wait_in_ms, 
								os.page_lock_count, 
								os.page_lock_wait_count, 
								os.page_lock_wait_in_ms,
								os.index_lock_promotion_attempt_count, 
								os.index_lock_promotion_count, 
							' + case when @SQLServerProductVersion not like '9%' THEN 'par.data_compression_desc ' ELSE 'null as data_compression_desc' END + '
					FROM	' + QUOTENAME(@DatabaseName) + '.sys.dm_db_partition_stats AS ps  
					JOIN ' + QUOTENAME(@DatabaseName) + '.sys.partitions AS par on ps.partition_id=par.partition_id
					JOIN ' + QUOTENAME(@DatabaseName) + '.sys.objects AS so ON ps.object_id = so.object_id
							   AND so.is_ms_shipped = 0 /*Exclude objects shipped by Microsoft*/
							   AND so.type &lt;&gt; ''TF'' /*Exclude table valued functions*/
					LEFT JOIN ' + QUOTENAME(@DatabaseName) + '.sys.dm_db_index_operational_stats('
				+ CAST(@DatabaseID AS NVARCHAR(10)) + ', NULL, NULL,NULL) AS os ON
					ps.object_id=os.object_id and ps.index_id=os.index_id and ps.partition_number=os.partition_number 
					WHERE 1=1 
					' + CASE WHEN @ObjectID IS NOT NULL THEN N'AND so.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) + N' ' ELSE N' ' END + '
					' + CASE WHEN @Filter = 2 THEN N'AND ps.reserved_page_count * 8./1024. &gt; ' + CAST(@FilterMB AS NVARCHAR(5)) + N' ' ELSE N' ' END + '
			ORDER BY ps.object_id,  ps.index_id, ps.partition_number
			OPTION	( RECOMPILE );
			';
		END
		ELSE /* Otherwise use this syntax which takes advantage of OUTER APPLY on the os_partitions DMV. 
		This performs better on 2012 tables using 1000+ partitions. */
		BEGIN
		RAISERROR (N'Using 2012 syntax to query sys.dm_db_index_operational_stats',0,1) WITH NOWAIT;

 		SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
						SELECT	ps.object_id, 
								ps.index_id, 
								ps.partition_number, 
								ps.row_count,
								ps.reserved_page_count * 8. / 1024. AS reserved_MB,
								ps.lob_reserved_page_count * 8. / 1024. AS reserved_LOB_MB,
								ps.row_overflow_reserved_page_count * 8. / 1024. AS reserved_row_overflow_MB,
								os.leaf_insert_count, 
								os.leaf_delete_count, 
								os.leaf_update_count, 
								os.range_scan_count, 
								os.singleton_lookup_count,  
								os.forwarded_fetch_count,
								os.lob_fetch_in_pages, 
								os.lob_fetch_in_bytes, 
								os.row_overflow_fetch_in_pages,
								os.row_overflow_fetch_in_bytes, 
								os.row_lock_count, 
								os.row_lock_wait_count,
								os.row_lock_wait_in_ms, 
								os.page_lock_count, 
								os.page_lock_wait_count, 
								os.page_lock_wait_in_ms,
								os.index_lock_promotion_attempt_count, 
								os.index_lock_promotion_count, 
								' + case when @SQLServerProductVersion not like '9%' THEN N'par.data_compression_desc ' ELSE N'null as data_compression_desc' END + N'
						FROM	' + QUOTENAME(@DatabaseName) + N'.sys.dm_db_partition_stats AS ps  
						JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.partitions AS par on ps.partition_id=par.partition_id
						JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects AS so ON ps.object_id = so.object_id
								   AND so.is_ms_shipped = 0 /*Exclude objects shipped by Microsoft*/
								   AND so.type &lt;&gt; ''TF'' /*Exclude table valued functions*/
						OUTER APPLY ' + QUOTENAME(@DatabaseName) + N'.sys.dm_db_index_operational_stats('
					+ CAST(@DatabaseID AS NVARCHAR(10)) + N', ps.object_id, ps.index_id,ps.partition_number) AS os
						WHERE 1=1 
						' + CASE WHEN @ObjectID IS NOT NULL THEN N'AND so.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) + N' ' ELSE N' ' END + N'
						' + CASE WHEN @Filter = 2 THEN N'AND ps.reserved_page_count * 8./1024. &gt; ' + CAST(@FilterMB AS NVARCHAR(5)) + N' ' ELSE N' ' END + '
				ORDER BY ps.object_id,  ps.index_id, ps.partition_number
				OPTION	( RECOMPILE );
				';
 
		END       

		IF @dsql IS NULL 
			RAISERROR('@dsql is null',16,1);

		RAISERROR (N'Inserting data into #IndexPartitionSanity',0,1) WITH NOWAIT;
		insert	#IndexPartitionSanity ( 
											[object_id], 
											index_id, 
											partition_number, 
											row_count, 
											reserved_MB,
										  reserved_LOB_MB, 
										  reserved_row_overflow_MB, 
										  leaf_insert_count,
										  leaf_delete_count, 
										  leaf_update_count, 
										  range_scan_count,
										  singleton_lookup_count,
										  forwarded_fetch_count, 
										  lob_fetch_in_pages, 
										  lob_fetch_in_bytes, 
										  row_overflow_fetch_in_pages,
										  row_overflow_fetch_in_bytes, 
										  row_lock_count, 
										  row_lock_wait_count,
										  row_lock_wait_in_ms, 
										  page_lock_count, 
										  page_lock_wait_count,
										  page_lock_wait_in_ms, 
										  index_lock_promotion_attempt_count,
										  index_lock_promotion_count, 
										  data_compression_desc )
				EXEC sp_executesql @dsql;


		RAISERROR (N'Updating index_sanity_id on #IndexPartitionSanity',0,1) WITH NOWAIT;
		UPDATE	#IndexPartitionSanity
		SET		index_sanity_id = i.index_sanity_id
		FROM #IndexPartitionSanity ps
				JOIN #IndexSanity i ON ps.[object_id] = i.[object_id]
										AND ps.index_id = i.index_id


		RAISERROR (N'Inserting data into #IndexSanitySize',0,1) WITH NOWAIT;
		INSERT	#IndexSanitySize ( [index_sanity_id], partition_count, total_rows, total_reserved_MB,
									 total_reserved_LOB_MB, total_reserved_row_overflow_MB, total_range_scan_count,
									 total_singleton_lookup_count, total_leaf_delete_count, total_leaf_update_count, 
									 total_forwarded_fetch_count,total_row_lock_count,
									 total_row_lock_wait_count, total_row_lock_wait_in_ms, avg_row_lock_wait_in_ms,
									 total_page_lock_count, total_page_lock_wait_count, total_page_lock_wait_in_ms,
									 avg_page_lock_wait_in_ms, total_index_lock_promotion_attempt_count, 
									 total_index_lock_promotion_count, data_compression_desc )
				SELECT	index_sanity_id, COUNT(*), SUM(row_count), SUM(reserved_MB), SUM(reserved_LOB_MB),
						SUM(reserved_row_overflow_MB), 
						SUM(range_scan_count),
						SUM(singleton_lookup_count),
						SUM(leaf_delete_count), 
						SUM(leaf_update_count),
						SUM(forwarded_fetch_count),
						SUM(row_lock_count), 
						SUM(row_lock_wait_count),
						SUM(row_lock_wait_in_ms), 
						CASE WHEN SUM(row_lock_wait_in_ms) &gt; 0 THEN
							SUM(row_lock_wait_in_ms)/(1.*SUM(row_lock_wait_count))
						ELSE 0 END AS avg_row_lock_wait_in_ms,           
						SUM(page_lock_count), 
						SUM(page_lock_wait_count),
						SUM(page_lock_wait_in_ms), 
						CASE WHEN SUM(page_lock_wait_in_ms) &gt; 0 THEN
							SUM(page_lock_wait_in_ms)/(1.*SUM(page_lock_wait_count))
						ELSE 0 END AS avg_page_lock_wait_in_ms,           
						SUM(index_lock_promotion_attempt_count),
						SUM(index_lock_promotion_count),
						LEFT(MAX(data_compression_info.data_compression_rollup),8000)
				FROM #IndexPartitionSanity ipp
				/* individual partitions can have distinct compression settings, just roll them into a list here*/
				OUTER APPLY (SELECT STUFF((
					SELECT	N', ' + data_compression_desc
					FROM #IndexPartitionSanity ipp2
					WHERE ipp.[object_id]=ipp2.[object_id]
						AND ipp.[index_id]=ipp2.[index_id]
					ORDER BY ipp2.partition_number
					FOR	  XML PATH(''),TYPE).value('.', 'varchar(max)'), 1, 1, '')) 
						data_compression_info(data_compression_rollup)
				GROUP BY index_sanity_id
				ORDER BY index_sanity_id 
		OPTION	( RECOMPILE );

		RAISERROR (N'Adding UQ index on #IndexSanity (object_id,index_id)',0,1) WITH NOWAIT;
		CREATE UNIQUE INDEX uq_object_id_index_id ON #IndexSanity (object_id,index_id);

		RAISERROR (N'Inserting data into #MissingIndexes',0,1) WITH NOWAIT;
		SET @dsql=N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
				SELECT	id.object_id, ' + QUOTENAME(@DatabaseName,'''') + N', sc.[name], so.[name], id.statement , gs.avg_total_user_cost, 
						gs.avg_user_impact, gs.user_seeks, gs.user_scans, gs.unique_compiles,id.equality_columns, 
						id.inequality_columns,id.included_columns
				FROM	sys.dm_db_missing_index_groups ig
						JOIN sys.dm_db_missing_index_details id ON ig.index_handle = id.index_handle
						JOIN sys.dm_db_missing_index_group_stats gs ON ig.index_group_handle = gs.group_handle
						JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects so on 
							id.object_id=so.object_id
						JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.schemas sc on 
							so.schema_id=sc.schema_id
				WHERE	id.database_id = ' + CAST(@DatabaseID AS NVARCHAR(30)) + '
				' + CASE WHEN @ObjectID IS NULL THEN N'' 
					ELSE N'and id.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) 
				END +
		N';'

		IF @dsql IS NULL 
			RAISERROR('@dsql is null',16,1);
		INSERT	#MissingIndexes ( [object_id], [database_name], [schema_name], [table_name], [statement], avg_total_user_cost, 
									avg_user_impact, user_seeks, user_scans, unique_compiles, equality_columns, 
									inequality_columns,included_columns)
		EXEC sp_executesql @dsql;

		SET @dsql = N'
			SELECT 
				fk_object.name AS foreign_key_name,
				parent_object.[object_id] AS parent_object_id,
				parent_object.name AS parent_object_name,
				referenced_object.[object_id] AS referenced_object_id,
				referenced_object.name AS referenced_object_name,
				fk.is_disabled,
				fk.is_not_trusted,
				fk.is_not_for_replication,
				parent.fk_columns,
				referenced.fk_columns,
				[update_referential_action_desc],
				[delete_referential_action_desc]
			FROM ' + QUOTENAME(@DatabaseName) + N'.sys.foreign_keys fk
			JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects fk_object ON fk.object_id=fk_object.object_id
			JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects parent_object ON fk.parent_object_id=parent_object.object_id
			JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects referenced_object ON fk.referenced_object_id=referenced_object.object_id
			CROSS APPLY ( SELECT	STUFF( (SELECT	N'', '' + c_parent.name AS fk_columns
											FROM	' + QUOTENAME(@DatabaseName) + N'.sys.foreign_key_columns fkc 
											JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.columns c_parent ON fkc.parent_object_id=c_parent.[object_id]
												AND fkc.parent_column_id=c_parent.column_id
											WHERE	fk.parent_object_id=fkc.parent_object_id
												AND fk.[object_id]=fkc.constraint_object_id
											ORDER BY fkc.constraint_column_id 
									FOR	  XML PATH('''') ,
											  TYPE).value(''.'', ''varchar(max)''), 1, 1, '''')/*This is how we remove the first comma*/ ) parent ( fk_columns )
			CROSS APPLY ( SELECT	STUFF( (SELECT	N'', '' + c_referenced.name AS fk_columns
											FROM	' + QUOTENAME(@DatabaseName) + N'.sys.	foreign_key_columns fkc 
											JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.columns c_referenced ON fkc.referenced_object_id=c_referenced.[object_id]
												AND fkc.referenced_column_id=c_referenced.column_id
											WHERE	fk.referenced_object_id=fkc.referenced_object_id
												and fk.[object_id]=fkc.constraint_object_id
											ORDER BY fkc.constraint_column_id  /*order by col name, we don''t have anything better*/
									FOR	  XML PATH('''') ,
											  TYPE).value(''.'', ''varchar(max)''), 1, 1, '''') ) referenced ( fk_columns )
			' + CASE WHEN @ObjectID IS NOT NULL THEN 
					'WHERE fk.parent_object_id=' + CAST(@ObjectID AS NVARCHAR(30)) + N' OR fk.referenced_object_id=' + CAST(@ObjectID AS NVARCHAR(30)) + N' ' 
					ELSE N' ' END + '
			ORDER BY parent_object_name, foreign_key_name;
		';
		IF @dsql IS NULL 
			RAISERROR('@dsql is null',16,1);

        RAISERROR (N'Inserting data into #ForeignKeys',0,1) WITH NOWAIT;
        INSERT  #ForeignKeys ( foreign_key_name, parent_object_id,parent_object_name, referenced_object_id, referenced_object_name,
                                is_disabled, is_not_trusted, is_not_for_replication, parent_fk_columns, referenced_fk_columns,
								[update_referential_action_desc], [delete_referential_action_desc] )
                EXEC sp_executesql @dsql;

        RAISERROR (N'Updating #IndexSanity.referenced_by_foreign_key',0,1) WITH NOWAIT;
		UPDATE #IndexSanity
			SET is_referenced_by_foreign_key=1
		FROM #IndexSanity s
		JOIN #ForeignKeys fk ON 
			s.object_id=fk.referenced_object_id
			AND LEFT(s.key_column_names,LEN(fk.referenced_fk_columns)) = fk.referenced_fk_columns

		RAISERROR (N'Add computed columns to #IndexSanity to simplify queries.',0,1) WITH NOWAIT;
		ALTER TABLE #IndexSanity ADD 
		[schema_object_name] AS [schema_name] + '.' + [object_name]  ,
		[schema_object_indexid] AS [schema_name] + '.' + [object_name]
			+ CASE WHEN [index_name] IS NOT NULL THEN '.' + index_name
			ELSE ''
			END + ' (' + CAST(index_id AS NVARCHAR(20)) + ')' ,
		first_key_column_name AS CASE	WHEN count_key_columns &gt; 1
			THEN LEFT(key_column_names, CHARINDEX(',', key_column_names, 0) - 1)
			ELSE key_column_names
			END ,
		index_definition AS 
		CASE WHEN partition_key_column_name IS NOT NULL 
			THEN N'[PARTITIONED BY:' + partition_key_column_name +  N']' 
			ELSE '' 
			END +
			CASE index_id
				WHEN 0 THEN N'[HEAP] '
				WHEN 1 THEN N'[CX] '
				ELSE N'' END + CASE WHEN is_indexed_view = 1 THEN '[VIEW] '
				ELSE N'' END + CASE WHEN is_primary_key = 1 THEN N'[PK] '
				ELSE N'' END + CASE WHEN is_XML = 1 THEN N'[XML] '
				ELSE N'' END + CASE WHEN is_spatial = 1 THEN N'[SPATIAL] '
				ELSE N'' END + CASE WHEN is_NC_columnstore = 1 THEN N'[COLUMNSTORE] '
				ELSE N'' END + CASE WHEN is_disabled = 1 THEN N'[DISABLED] '
				ELSE N'' END + CASE WHEN is_hypothetical = 1 THEN N'[HYPOTHETICAL] '
				ELSE N'' END + CASE WHEN is_unique = 1 AND is_primary_key = 0 THEN N'[UNIQUE] '
				ELSE N'' END + CASE WHEN count_key_columns &gt; 0 THEN 
					N'[' + CAST(count_key_columns AS VARCHAR(10)) + N' KEY' 
						+ CASE WHEN count_key_columns &gt; 1 then  N'S' ELSE N'' END
						+ N'] ' + LTRIM(key_column_names_with_sort_order)
				ELSE N'' END + CASE WHEN count_included_columns &gt; 0 THEN 
					N' [' + CAST(count_included_columns AS VARCHAR(10))  + N' INCLUDE' + 
						+ CASE WHEN count_included_columns &gt; 1 then  N'S' ELSE N'' END					
						+ N'] ' + include_column_names
				ELSE N'' END + CASE WHEN filter_definition &lt;&gt; N'' THEN N' [FILTER] ' + filter_definition
				ELSE N'' END ,
		[total_reads] AS user_seeks + user_scans + user_lookups,
		[reads_per_write] AS CAST(CASE WHEN user_updates &gt; 0
			THEN ( user_seeks + user_scans + user_lookups )  / (1.0 * user_updates)
			ELSE 0 END AS MONEY) ,
		[index_usage_summary] AS N'Reads: ' + 
			REPLACE(CONVERT(NVARCHAR(30),CAST((user_seeks + user_scans + user_lookups) AS money), 1), '.00', '')
			+ case when user_seeks + user_scans + user_lookups &gt; 0 then
				N' (' 
					+ RTRIM(
					CASE WHEN user_seeks &gt; 0 then REPLACE(CONVERT(NVARCHAR(30),CAST((user_seeks) AS money), 1), '.00', '') + N' seek ' ELSE N'' END
					+ CASE WHEN user_scans &gt; 0 then REPLACE(CONVERT(NVARCHAR(30),CAST((user_scans) AS money), 1), '.00', '') + N' scan '  ELSE N'' END
					+ CASE WHEN user_lookups &gt; 0 then  REPLACE(CONVERT(NVARCHAR(30),CAST((user_lookups) AS money), 1), '.00', '') + N' lookup' ELSE N'' END
					)
					+ N') '
				else N' ' end 
			+ N'Writes:' + 
			REPLACE(CONVERT(NVARCHAR(30),CAST(user_updates AS money), 1), '.00', ''),
		[more_info] AS N'EXEC dbo.sp_BlitzIndex @DatabaseName=' + QUOTENAME([database_name],'''') + 
			N', @SchemaName=' + QUOTENAME([schema_name],'''') + N', @TableName=' + QUOTENAME([object_name],'''') + N';'

		RAISERROR (N'Update index_secret on #IndexSanity for NC indexes.',0,1) WITH NOWAIT;
		UPDATE nc 
		SET secret_columns=
			N'[' + 
			CASE tb.count_key_columns WHEN 0 THEN '1' ELSE CAST(tb.count_key_columns AS VARCHAR(10)) END +
			CASE nc.is_unique WHEN 1 THEN N' INCLUDE' ELSE N' KEY' END +
			CASE WHEN tb.count_key_columns &gt; 1 then  N'S] ' ELSE N'] ' END +
			CASE tb.index_id WHEN 0 THEN '[RID]' ELSE LTRIM(tb.key_column_names) +
				/* Uniquifiers only needed on non-unique clustereds-- not heaps */
				CASE tb.is_unique WHEN 0 THEN ' [UNIQUIFIER]' ELSE N'' END
			END
			, count_secret_columns=
			CASE tb.index_id WHEN 0 THEN 1 ELSE 
				tb.count_key_columns +
					CASE tb.is_unique WHEN 0 THEN 1 ELSE 0 END
			END
		FROM #IndexSanity AS nc
		JOIN #IndexSanity AS tb ON nc.object_id=tb.object_id
			and tb.index_id in (0,1) 
		WHERE nc.index_id &gt; 1;

		RAISERROR (N'Update index_secret on #IndexSanity for heaps and non-unique clustered.',0,1) WITH NOWAIT;
		UPDATE tb
		SET secret_columns=	CASE tb.index_id WHEN 0 THEN '[RID]' ELSE '[UNIQUIFIER]' END
			, count_secret_columns = 1
		FROM #IndexSanity AS tb
		WHERE tb.index_id = 0 /*Heaps-- these have the RID */
			or (tb.index_id=1 and tb.is_unique=0); /* Non-unique CX: has uniquifer (when needed) */

		RAISERROR (N'Add computed columns to #IndexSanitySize to simplify queries.',0,1) WITH NOWAIT;
		ALTER TABLE #IndexSanitySize ADD 
			  index_size_summary AS ISNULL(
				CASE WHEN partition_count &gt; 1
						THEN N'[' + CAST(partition_count AS NVARCHAR(10)) + N' PARTITIONS] '
						ELSE N''
				END + REPLACE(CONVERT(NVARCHAR(30),CAST([total_rows] AS money), 1), N'.00', N'') + N' rows; '
				+ CASE WHEN total_reserved_MB &gt; 1024 THEN 
					CAST(CAST(total_reserved_MB/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'GB'
				ELSE 
					CAST(CAST(total_reserved_MB AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'MB'
				END
				+ CASE WHEN total_reserved_LOB_MB &gt; 1024 THEN 
					N'; ' + CAST(CAST(total_reserved_LOB_MB/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'GB LOB'
				WHEN total_reserved_LOB_MB &gt; 0 THEN
					N'; ' + CAST(CAST(total_reserved_LOB_MB AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'MB LOB'
				ELSE ''
				END
				 + CASE WHEN total_reserved_row_overflow_MB &gt; 1024 THEN
					N'; ' + CAST(CAST(total_reserved_row_overflow_MB/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'GB Row Overflow'
				WHEN total_reserved_row_overflow_MB &gt; 0 THEN
					N'; ' + CAST(CAST(total_reserved_row_overflow_MB AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'MB Row Overflow'
				ELSE ''
				END ,
					N'Error- NULL in computed column'),
			index_op_stats AS ISNULL(
				(
					REPLACE(CONVERT(NVARCHAR(30),CAST(total_singleton_lookup_count AS MONEY), 1),N'.00',N'') + N' singleton lookups; '
					+ REPLACE(CONVERT(NVARCHAR(30),CAST(total_range_scan_count AS MONEY), 1),N'.00',N'') + N' scans/seeks; '
					+ REPLACE(CONVERT(NVARCHAR(30),CAST(total_leaf_delete_count AS MONEY), 1),N'.00',N'') + N' deletes; '
					+ REPLACE(CONVERT(NVARCHAR(30),CAST(total_leaf_update_count AS MONEY), 1),N'.00',N'') + N' updates; '
					+ CASE WHEN ISNULL(total_forwarded_fetch_count,0) &gt;0 THEN
						REPLACE(CONVERT(NVARCHAR(30),CAST(total_forwarded_fetch_count AS MONEY), 1),N'.00',N'') + N' forward records fetched; '
					ELSE N'' END

					/* rows will only be in this dmv when data is in memory for the table */
				), N'Table metadata not in memory'),
			index_lock_wait_summary AS ISNULL(
				CASE WHEN total_row_lock_wait_count = 0 and  total_page_lock_wait_count = 0 and
					total_index_lock_promotion_attempt_count = 0 THEN N'0 lock waits.'
				ELSE
					CASE WHEN total_row_lock_wait_count &gt; 0 THEN
						N'Row lock waits: ' + REPLACE(CONVERT(NVARCHAR(30),CAST(total_row_lock_wait_count AS money), 1), N'.00', N'')
						+ N'; total duration: ' + 
							CASE WHEN total_row_lock_wait_in_ms &gt;= 60000 THEN /*More than 1 min*/
								REPLACE(CONVERT(NVARCHAR(30),CAST((total_row_lock_wait_in_ms/60000) AS money), 1), N'.00', N'') + N' minutes; '
							ELSE                         
								REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(total_row_lock_wait_in_ms/1000,0) AS money), 1), N'.00', N'') + N' seconds; '
							END
						+ N'avg duration: ' + 
							CASE WHEN avg_row_lock_wait_in_ms &gt;= 60000 THEN /*More than 1 min*/
								REPLACE(CONVERT(NVARCHAR(30),CAST((avg_row_lock_wait_in_ms/60000) AS money), 1), N'.00', N'') + N' minutes; '
							ELSE                         
								REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(avg_row_lock_wait_in_ms/1000,0) AS money), 1), N'.00', N'') + N' seconds; '
							END
					ELSE N''
					END +
					CASE WHEN total_page_lock_wait_count &gt; 0 THEN
						N'Page lock waits: ' + REPLACE(CONVERT(NVARCHAR(30),CAST(total_page_lock_wait_count AS money), 1), N'.00', N'')
						+ N'; total duration: ' + 
							CASE WHEN total_page_lock_wait_in_ms &gt;= 60000 THEN /*More than 1 min*/
								REPLACE(CONVERT(NVARCHAR(30),CAST((total_page_lock_wait_in_ms/60000) AS money), 1), N'.00', N'') + N' minutes; '
							ELSE                         
								REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(total_page_lock_wait_in_ms/1000,0) AS money), 1), N'.00', N'') + N' seconds; '
							END
						+ N'avg duration: ' + 
							CASE WHEN avg_page_lock_wait_in_ms &gt;= 60000 THEN /*More than 1 min*/
								REPLACE(CONVERT(NVARCHAR(30),CAST((avg_page_lock_wait_in_ms/60000) AS money), 1), N'.00', N'') + N' minutes; '
							ELSE                         
								REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(avg_page_lock_wait_in_ms/1000,0) AS money), 1), N'.00', N'') + N' seconds; '
							END
					ELSE N''
					END +
					CASE WHEN total_index_lock_promotion_attempt_count &gt; 0 THEN
						N'Lock escalation attempts: ' + REPLACE(CONVERT(NVARCHAR(30),CAST(total_index_lock_promotion_attempt_count AS money), 1), N'.00', N'')
						+ N'; Actual Escalations: ' + REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(total_index_lock_promotion_count,0) AS money), 1), N'.00', N'') + N'.'
					ELSE N''
					END
				END                  
					,'Error- NULL in computed column')


		RAISERROR (N'Add computed columns to #missing_index to simplify queries.',0,1) WITH NOWAIT;
		ALTER TABLE #MissingIndexes ADD 
				[index_estimated_impact] AS 
					CAST(user_seeks + user_scans AS NVARCHAR(30)) + N' use' 
						+ CASE WHEN (user_seeks + user_scans) &gt; 1 THEN N's' ELSE N'' END
						 +N'; Impact: ' + CAST(avg_user_impact AS NVARCHAR(30))
						+ N'%; Avg query cost: '
						+ CAST(avg_total_user_cost AS NVARCHAR(30)),
				[missing_index_details] AS
					CASE WHEN equality_columns IS NOT NULL THEN N'EQUALITY: ' + equality_columns + N' '
						 ELSE N''
					END + CASE WHEN inequality_columns IS NOT NULL THEN N'INEQUALITY: ' + inequality_columns + N' '
					   ELSE N''
					END + CASE WHEN included_columns IS NOT NULL THEN N'INCLUDES: ' + included_columns + N' '
						ELSE N''
					END,
				[create_tsql] AS N'CREATE INDEX [ix_' + table_name + N'_' 
					+ REPLACE(REPLACE(REPLACE(REPLACE(
						ISNULL(equality_columns,N'')+ 
						CASE when equality_columns is not null and inequality_columns is not null then N'_' else N'' END
						+ ISNULL(inequality_columns,''),',','')
						,'[',''),']',''),' ','_') 
					+ CASE WHEN included_columns IS NOT NULL THEN N'_includes' ELSE N'' END + N'] ON ' 
					+ [statement] + N' (' + ISNULL(equality_columns,N'')
					+ CASE WHEN equality_columns IS NOT NULL AND inequality_columns IS NOT NULL THEN N', ' ELSE N'' END
					+ CASE WHEN inequality_columns IS NOT NULL THEN inequality_columns ELSE N'' END + 
					') ' + CASE WHEN included_columns IS NOT NULL THEN N' INCLUDE (' + included_columns + N')' ELSE N'' END
					+ N' WITH (' 
						+ N'FILLFACTOR=100, ONLINE=?, SORT_IN_TEMPDB=?' 
					+ N')'
					+ N';'
					,
				[more_info] AS N'EXEC dbo.sp_BlitzIndex @DatabaseName=' + QUOTENAME([database_name],'''') + 
					N', @SchemaName=' + QUOTENAME([schema_name],'''') + N', @TableName=' + QUOTENAME([table_name],'''') + N';'
				;


		RAISERROR (N'Populate #IndexCreateTsql.',0,1) WITH NOWAIT;
		INSERT #IndexCreateTsql (index_sanity_id, create_tsql)
		SELECT
			index_sanity_id,
			ISNULL (
			/* Script drops for disabled non-clustered indexes*/
			CASE WHEN is_disabled = 1 AND index_id &lt;&gt; 1
				THEN N'--DROP INDEX ' + QUOTENAME([index_name]) + N' ON '
				 + QUOTENAME([schema_name]) + N'.' + QUOTENAME([object_name]) 
			ELSE
				CASE index_id WHEN 0 THEN N'--I''m a Heap!' 
				ELSE 
					CASE WHEN is_XML = 1 OR is_spatial=1 THEN N'' /* Not even trying for these just yet...*/
					ELSE 
						CASE WHEN is_primary_key=1 THEN
							N'ALTER TABLE ' + QUOTENAME([schema_name]) +
								N'.' + QUOTENAME([object_name]) + 
								N' ADD CONSTRAINT [' +
								index_name + 
								N'] PRIMARY KEY ' + 
								CASE WHEN index_id=1 THEN N'CLUSTERED (' ELSE N'(' END +
								key_column_names_with_sort_order_no_types + N' )' 
							WHEN is_CX_columnstore= 1 THEN
								 N'CREATE CLUSTERED COLUMNSTORE INDEX ' + QUOTENAME(index_name) + N' on ' + QUOTENAME([schema_name]) + '.' + QUOTENAME([object_name])
						ELSE /*Else not a PK or cx columnstore */ 
							N'CREATE ' + 
							CASE WHEN is_unique=1 THEN N'UNIQUE ' ELSE N'' END +
							CASE WHEN index_id=1 THEN N'CLUSTERED ' ELSE N'' END +
							CASE WHEN is_NC_columnstore=1 THEN N'NONCLUSTERED COLUMNSTORE ' 
							ELSE N'' END +
							N'INDEX ['
								 + index_name + N'] ON ' + 
								QUOTENAME([schema_name]) + '.' + QUOTENAME([object_name]) + 
									CASE WHEN is_NC_columnstore=1 THEN 
										N' (' + ISNULL(include_column_names_no_types,'') +  N' )' 
									ELSE /*Else not colunnstore */ 
										N' (' + ISNULL(key_column_names_with_sort_order_no_types,'') +  N' )' 
										+ CASE WHEN include_column_names_no_types IS NOT NULL THEN 
											N' INCLUDE (' + include_column_names_no_types + N')' 
											ELSE N'' 
										END
									END /*End non-colunnstore case */ 
								+ CASE WHEN filter_definition &lt;&gt; N'' THEN N' WHERE ' + filter_definition ELSE N'' END
							END /*End Non-PK index CASE */ 
						+ CASE WHEN is_NC_columnstore=0 and is_CX_columnstore=0 then
							N' WITH (' 
								+ N'FILLFACTOR=' + CASE fill_factor when 0 then N'100' else CAST(fill_factor AS NVARCHAR(5)) END + ', '
								+ N'ONLINE=?, SORT_IN_TEMPDB=?'
							+ N')'
						else N'' end
						+ N';'
  					END /*End non-spatial and non-xml CASE */ 
				END
			END, '[Unknown Error]')
				AS create_tsql
		FROM #IndexSanity;
					
	END
END TRY
BEGIN CATCH
		RAISERROR (N'Failure populating temp tables.', 0,1) WITH NOWAIT;

		IF @dsql IS NOT NULL
		BEGIN
			SET @msg= 'Last @dsql: ' + @dsql;
			RAISERROR(@msg, 0, 1) WITH NOWAIT;
		END

		SELECT	@msg = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE();
		RAISERROR (@msg,@ErrorSeverity, @ErrorState )WITH NOWAIT;
		
		
		WHILE @@trancount &gt; 0 
			ROLLBACK;

		RETURN;
END CATCH;

----------------------------------------
--STEP 2: DIAGNOSE THE PATIENT
--EVERY QUERY AFTER THIS GOES AGAINST TEMP TABLES ONLY.
----------------------------------------
BEGIN TRY
----------------------------------------
--If @TableName is specified, just return information for that table.
--The @Mode parameter doesn't matter if you're looking at a specific table.
----------------------------------------
IF @TableName IS NOT NULL
BEGIN
	RAISERROR(N'@TableName specified, giving detail only on that table.', 0,1) WITH NOWAIT;

	--We do a left join here in case this is a disabled NC.
	--In that case, it won't have any size info/pages allocated.
	WITH table_mode_cte AS (
		SELECT 
			s.schema_object_indexid, 
			s.key_column_names,
			s.index_definition, 
			ISNULL(s.secret_columns,N'') AS secret_columns,
			s.fill_factor,
			s.index_usage_summary, 
			sz.index_op_stats,
			ISNULL(sz.index_size_summary,'') /*disabled NCs will be null*/ AS index_size_summary,
			ISNULL(sz.index_lock_wait_summary,'') AS index_lock_wait_summary,
			s.is_referenced_by_foreign_key,
			(SELECT COUNT(*)
				FROM #ForeignKeys fk WHERE fk.parent_object_id=s.object_id
				AND PATINDEX (fk.parent_fk_columns, s.key_column_names)=1) AS FKs_covered_by_index,
			s.last_user_seek,
			s.last_user_scan,
			s.last_user_lookup,
			s.last_user_update,
			s.create_date,
			s.modify_date,
			ct.create_tsql,
			1 as display_order
		FROM #IndexSanity s
		LEFT JOIN #IndexSanitySize sz ON 
			s.index_sanity_id=sz.index_sanity_id
		LEFT JOIN #IndexCreateTsql ct ON 
			s.index_sanity_id=ct.index_sanity_id
		WHERE s.[object_id]=@ObjectID
		UNION ALL
		SELECT 	N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + convert(nvarchar(16),getdate(),121) + 			
				N' (sp_BlitzIndex(TM) v2.02 - Jan 30, 2014)' ,   
				N'From Brent Ozar Unlimited(TM)' ,   
				N'http://BrentOzar.com/BlitzIndex' ,
				N'Thanks from the Brent Ozar Unlimited(TM) team.  We hope you found this tool useful, and if you need help relieving your SQL Server pains, email us at Help@BrentOzar.com.',
				NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
				0 as display_order
	)
	SELECT 
			schema_object_indexid AS [Details: schema.table.index(indexid)], 
			index_definition AS [Definition: [Property]] ColumnName {datatype maxbytes}], 
			secret_columns AS [Secret Columns],
			fill_factor AS [Fillfactor],
			index_usage_summary AS [Usage Stats], 
			index_op_stats as [Op Stats],
			index_size_summary AS [Size],
			index_lock_wait_summary AS [Lock Waits],
			is_referenced_by_foreign_key AS [Referenced by FK?],
			FKs_covered_by_index AS [FK Covered by Index?],
			last_user_seek AS [Last User Seek],
			last_user_scan AS [Last User Scan],
			last_user_lookup AS [Last User Lookup],
			last_user_update as [Last User Write],
			create_date AS [Created],
			modify_date AS [Last Modified],
			create_tsql AS [Create TSQL]
	FROM table_mode_cte
	ORDER BY display_order ASC, key_column_names ASC
	OPTION	( RECOMPILE );						

	IF (SELECT TOP 1 [object_id] FROM    #MissingIndexes mi) IS NOT NULL
	BEGIN  
		SELECT  N'Missing index.' AS Finding ,
				N'http://BrentOzar.com/go/Indexaphobia' AS URL ,
				mi.[statement] + ' Est Benefit: '
					+ CASE WHEN magic_benefit_number &gt;= 922337203685477 THEN '&gt;= 922,337,203,685,477'
					ELSE REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(magic_benefit_number AS BIGINT) AS money), 1), '.00', '')
					END AS [Estimated Benefit],
				missing_index_details AS [Missing Index Request] ,
				index_estimated_impact AS [Estimated Impact],
				create_tsql AS [Create TSQL]
		FROM    #MissingIndexes mi
		WHERE   [object_id] = @ObjectID
		ORDER BY magic_benefit_number DESC
		OPTION	( RECOMPILE );
	END       
	ELSE     
	SELECT 'No missing indexes.' AS finding;

	SELECT 	
		column_name AS [Column Name],
		(SELECT COUNT(*)  
			FROM #IndexColumns c2 
			WHERE c2.column_name=c.column_name
			and c2.key_ordinal is not null)
		+ CASE WHEN c.index_id = 1 and c.key_ordinal is not null THEN
			-1+ (SELECT COUNT(DISTINCT index_id)
			from #IndexColumns c3
			where c3.index_id not in (0,1))
			ELSE 0 END
				AS [Found In],
		system_type_name + 
			CASE max_length WHEN -1 THEN N' (max)' ELSE
				CASE  
					WHEN system_type_name in (N'char',N'nchar',N'binary',N'varbinary') THEN N' (' + CAST(max_length as NVARCHAR(20)) + N')' 
					WHEN system_type_name in (N'varchar',N'nvarchar') THEN N' (' + CAST(max_length/2 as NVARCHAR(20)) + N')' 
					ELSE '' 
				END
			END
			AS [Type],
		CASE is_computed WHEN 1 THEN 'yes' ELSE '' END AS [Computed?],
		max_length AS [Length (max bytes)],
		[precision] AS [Prec],
		[scale] AS [Scale],
		CASE is_nullable WHEN 1 THEN 'yes' ELSE '' END AS [Nullable?],
		CASE is_identity WHEN 1 THEN 'yes' ELSE '' END AS [Identity?],
		CASE is_replicated WHEN 1 THEN 'yes' ELSE '' END AS [Replicated?],
		CASE is_sparse WHEN 1 THEN 'yes' ELSE '' END AS [Sparse?],
		CASE is_filestream WHEN 1 THEN 'yes' ELSE '' END AS [Filestream?],
		collation_name AS [Collation]
	FROM #IndexColumns AS c
	where index_id in (0,1);

	IF (SELECT TOP 1 parent_object_id FROM #ForeignKeys) IS NOT NULL
	BEGIN
		SELECT parent_object_name + N': ' + foreign_key_name AS [Foreign Key],
			parent_fk_columns AS [Foreign Key Columns],
			referenced_object_name AS [Referenced Table],
			referenced_fk_columns AS [Referenced Table Columns],
			is_disabled AS [Is Disabled?],
			is_not_trusted as [Not Trusted?],
			is_not_for_replication [Not for Replication?],
			[update_referential_action_desc] as [Cascading Updates?],
			[delete_referential_action_desc] as [Cascading Deletes?]
		FROM #ForeignKeys
		ORDER BY [Foreign Key]
		OPTION	( RECOMPILE );
	END
	ELSE
	SELECT 'No foreign keys.' AS finding;
END 

--If @TableName is NOT specified...
--Act based on the @Mode and @Filter. (@Filter applies only when @Mode=0 "diagnose")
ELSE
BEGIN;
	IF @Mode=0 /* DIAGNOSE*/
	BEGIN;
		RAISERROR(N'@Mode=0, we are diagnosing.', 0,1) WITH NOWAIT;

		RAISERROR(N'Insert a row to help people find help', 0,1) WITH NOWAIT;
		INSERT	#BlitzIndexResults ( check_id, findings_group, finding, URL, details, index_definition,
										index_usage_summary, index_size_summary )
		VALUES  ( 0 , 
				N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + convert(nvarchar(16),getdate(),121), 
				N'sp_BlitzIndex(TM) v2.02 - Jan 30, 2014' ,
				N'From Brent Ozar Unlimited(TM)' ,   N'http://BrentOzar.com/BlitzIndex' ,
				N'Thanks from the Brent Ozar Unlimited(TM) team.  We hope you found this tool useful, and if you need help relieving your SQL Server pains, email us at Help@BrentOzar.com.'
				, N'',N''
				);

		----------------------------------------
		--Multiple Index Personalities: Check_id 0-10
		----------------------------------------
		BEGIN;
		RAISERROR('check_id 1: Duplicate keys', 0,1) WITH NOWAIT;
			WITH	duplicate_indexes
					  AS ( SELECT	[object_id], key_column_names
						   FROM		#IndexSanity
						   WHERE  index_type IN (1,2) /* Clustered, NC only*/
								AND is_hypothetical = 0
								AND is_disabled = 0
						   GROUP BY	[object_id], key_column_names
						   HAVING	COUNT(*) &gt; 1)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	1 AS check_id, 
								ip.index_sanity_id,
								'Multiple Index Personalities' AS findings_group,
								'Duplicate keys' AS finding,
								N'http://BrentOzar.com/go/duplicateindex' AS URL,
								ip.schema_object_indexid AS details,
								ip.index_definition, 
								ip.secret_columns, 
								ip.index_usage_summary,
								ips.index_size_summary
						FROM	duplicate_indexes di
								JOIN #IndexSanity ip ON di.[object_id] = ip.[object_id]
														 AND ip.key_column_names = di.key_column_names
								JOIN #IndexSanitySize ips ON ip.index_sanity_id = ips.index_sanity_id
						ORDER BY ip.object_id, ip.key_column_names_with_sort_order	
				OPTION	( RECOMPILE );

		RAISERROR('check_id 2: Keys w/ identical leading columns.', 0,1) WITH NOWAIT;
			WITH	borderline_duplicate_indexes
					  AS ( SELECT DISTINCT [object_id], first_key_column_name, key_column_names,
									COUNT([object_id]) OVER ( PARTITION BY [object_id], first_key_column_name ) AS number_dupes
						   FROM		#IndexSanity
						   WHERE index_type IN (1,2) /* Clustered, NC only*/
							AND is_hypothetical=0
							AND is_disabled=0)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id,  findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	2 AS check_id, 
								ip.index_sanity_id,
								'Multiple Index Personalities' AS findings_group,
								'Borderline duplicate keys' AS finding,
								N'http://BrentOzar.com/go/duplicateindex' AS URL,
								ip.schema_object_indexid AS details, 
								ip.index_definition, 
								ip.secret_columns,
								ip.index_usage_summary,
								ips.index_size_summary
						FROM	#IndexSanity AS ip 
						JOIN #IndexSanitySize ips ON ip.index_sanity_id = ips.index_sanity_id
						WHERE EXISTS (
							SELECT di.[object_id]
							FROM borderline_duplicate_indexes AS di
							WHERE di.[object_id] = ip.[object_id] AND
								di.first_key_column_name = ip.first_key_column_name AND
								di.key_column_names &lt;&gt; ip.key_column_names AND
								di.number_dupes &gt; 1	
						)
						ORDER BY ip.[schema_name], ip.[object_name], ip.key_column_names, ip.include_column_names
			OPTION	( RECOMPILE );

		END
		----------------------------------------
		--Aggressive Indexes: Check_id 10-19
		----------------------------------------
		BEGIN;

		RAISERROR(N'check_id 11: Total lock wait time &gt; 5 minutes (row + page)', 0,1) WITH NOWAIT;
		INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										secret_columns, index_usage_summary, index_size_summary )
				SELECT	11 AS check_id, 
						i.index_sanity_id,
						N'Aggressive Indexes' AS findings_group,
						N'Total lock wait time &gt; 5 minutes (row + page)' AS finding, 
						N'http://BrentOzar.com/go/AggressiveIndexes' AS URL,
						i.schema_object_indexid + N': ' +
							sz.index_lock_wait_summary AS details, 
						i.index_definition,
						i.secret_columns,
						i.index_usage_summary,
						sz.index_size_summary
				FROM	#IndexSanity AS i
				JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
				WHERE	(total_row_lock_wait_in_ms + total_page_lock_wait_in_ms) &gt; 300000
				OPTION	( RECOMPILE );
		END

		---------------------------------------- 
		--Index Hoarder: Check_id 20-29
		----------------------------------------
		BEGIN
			RAISERROR(N'check_id 20: &gt;=7 NC indexes on any given table. Yes, 7 is an arbitrary number.', 0,1) WITH NOWAIT;
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	20 AS check_id, 
								MAX(i.index_sanity_id) AS index_sanity_id, 
								'Index Hoarder' AS findings_group,
								'Many NC indexes on a single table' AS finding,
								N'http://BrentOzar.com/go/IndexHoarder' AS URL,
								CAST (COUNT(*) AS NVARCHAR(30)) + ' NC indexes on ' + i.schema_object_name AS details,
								i.schema_object_name + ' (' + CAST (COUNT(*) AS NVARCHAR(30)) + ' indexes)' AS index_definition,
								'' AS secret_columns,
								REPLACE(CONVERT(NVARCHAR(30),CAST(SUM(total_reads) AS money), 1), N'.00', N'') + N' reads (ALL); '
									+ REPLACE(CONVERT(NVARCHAR(30),CAST(SUM(user_updates) AS money), 1), N'.00', N'') + N' writes (ALL); ',
								REPLACE(CONVERT(NVARCHAR(30),CAST(MAX(total_rows) AS money), 1), N'.00', N'') + N' rows (MAX)'
									+ CASE WHEN SUM(total_reserved_MB) &gt; 1024 THEN 
										N'; ' + CAST(CAST(SUM(total_reserved_MB)/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + 'GB (ALL)'
									WHEN SUM(total_reserved_MB) &gt; 0 THEN
										N'; ' + CAST(CAST(SUM(total_reserved_MB) AS NUMERIC(29,1)) AS NVARCHAR(30)) + 'MB (ALL)'
									ELSE ''
									END AS index_size_summary
						FROM	#IndexSanity i
						JOIN #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						WHERE	index_id NOT IN ( 0, 1 )
						GROUP BY schema_object_name
						HAVING	COUNT(*) &gt;= 7
						ORDER BY i.schema_object_name DESC  OPTION	( RECOMPILE );

			if @Filter = 1 /*@Filter=1 is "ignore unusued" */
			BEGIN
				RAISERROR(N'Skipping checks on unused indexes (21 and 22) because @Filter=1', 0,1) WITH NOWAIT;
			END
			ELSE /*Otherwise, go ahead and do the checks*/
			BEGIN
				RAISERROR(N'check_id 21: &gt;=5 percent of indexes are unused. Yes, 5 is an arbitrary number.', 0,1) WITH NOWAIT;
					DECLARE @percent_NC_indexes_unused NUMERIC(29,1);
					DECLARE @NC_indexes_unused_reserved_MB NUMERIC(29,1);

					SELECT	@percent_NC_indexes_unused =( 100.00 * SUM(CASE	WHEN total_reads = 0 THEN 1
												ELSE 0
										   END) ) / COUNT(*) ,
							@NC_indexes_unused_reserved_MB = SUM(CASE WHEN total_reads = 0 THEN sz.total_reserved_MB
									 ELSE 0
								END) 
					FROM	#IndexSanity i
					JOIN	#IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE	index_id NOT IN ( 0, 1 ) 
							and i.is_unique = 0
					OPTION	( RECOMPILE );

				IF @percent_NC_indexes_unused &gt;= 5 
					INSERT	#BlitzIndexResults ( check_id, index_sanity_id,  findings_group, finding, URL, details, index_definition,
												   secret_columns, index_usage_summary, index_size_summary )
							SELECT	21 AS check_id, 
									MAX(i.index_sanity_id) AS index_sanity_id, 
									N'Index Hoarder' AS findings_group,
									N'More than 5 percent NC indexes are unused' AS finding,
									N'http://BrentOzar.com/go/IndexHoarder' AS URL,
									CAST (@percent_NC_indexes_unused AS NVARCHAR(30)) + N' percent NC indexes (' + CAST(COUNT(*) AS NVARCHAR(10)) + N') unused. ' +
									N'These take up ' + CAST (@NC_indexes_unused_reserved_MB AS NVARCHAR(30)) + N'MB of space.' AS details,
									i.database_name + ' (' + CAST (COUNT(*) AS NVARCHAR(30)) + N' indexes)' AS index_definition,
									'' AS secret_columns, 
									CAST(SUM(total_reads) AS NVARCHAR(256)) + N' reads (ALL); '
										+ CAST(SUM([user_updates]) AS NVARCHAR(256)) + N' writes (ALL)' AS index_usage_summary,
								
									REPLACE(CONVERT(NVARCHAR(30),CAST(MAX([total_rows]) AS money), 1), '.00', '') + N' rows (MAX)'
										+ CASE WHEN SUM(total_reserved_MB) &gt; 1024 THEN 
											N'; ' + CAST(CAST(SUM(total_reserved_MB)/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + 'GB (ALL)'
										WHEN SUM(total_reserved_MB) &gt; 0 THEN
											N'; ' + CAST(CAST(SUM(total_reserved_MB) AS NUMERIC(29,1)) AS NVARCHAR(30)) + 'MB (ALL)'
										ELSE ''
										END AS index_size_summary
							FROM	#IndexSanity i
							JOIN	#IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
							WHERE	index_id NOT IN ( 0, 1 )
									AND i.is_unique = 0
									AND total_reads = 0
							GROUP BY i.database_name 
					OPTION	( RECOMPILE );

				RAISERROR(N'check_id 22: NC indexes with 0 reads. (Borderline)', 0,1) WITH NOWAIT;
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	22 AS check_id, 
								i.index_sanity_id,
								N'Index Hoarder' AS findings_group,
								N'Unused NC index' AS finding, 
								N'http://BrentOzar.com/go/IndexHoarder' AS URL,
								N'0 reads: ' + i.schema_object_indexid AS details, 
								i.index_definition, 
								i.secret_columns, 
								i.index_usage_summary,
								sz.index_size_summary
						FROM	#IndexSanity AS i
						JOIN	#IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
						WHERE	i.total_reads=0
								AND i.index_id NOT IN (0,1) /*NCs only*/
								and i.is_unique = 0
						ORDER BY i.schema_object_indexid
						OPTION	( RECOMPILE );
			END /*end checks only run when @Filter &lt;&gt; 1*/

			RAISERROR(N'check_id 23: Indexes with 7 or more columns. (Borderline)', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	23 AS check_id, 
							i.index_sanity_id, 
							N'Index Hoarder' AS findings_group,
							N'Borderline: Wide indexes (7 or more columns)' AS finding, 
							N'http://BrentOzar.com/go/IndexHoarder' AS URL,
							CAST(count_key_columns + count_included_columns AS NVARCHAR(10)) + ' columns on '
							+ i.schema_object_indexid AS details, i.index_definition, 
							i.secret_columns, 
							i.index_usage_summary,
							sz.index_size_summary
					FROM	#IndexSanity AS i
					JOIN	#IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE	( count_key_columns + count_included_columns ) &gt;= 7
					OPTION	( RECOMPILE );

			RAISERROR(N'check_id 24: Wide clustered indexes (&gt; 3 columns or &gt; 16 bytes).', 0,1) WITH NOWAIT;
				WITH count_columns AS (
							SELECT [object_id],
								SUM(CASE max_length when -1 THEN 0 ELSE max_length END) AS sum_max_length
							FROM #IndexColumns ic
							WHERE index_id in (1,0) /*Heap or clustered only*/
							and key_ordinal &gt; 0
							GROUP BY object_id
							)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	24 AS check_id, 
								i.index_sanity_id, 
								N'Index Hoarder' AS findings_group,
								N'Wide clustered index (&gt; 3 columns OR &gt; 16 bytes)' AS finding,
								N'http://BrentOzar.com/go/IndexHoarder' AS URL,
								CAST (i.count_key_columns AS NVARCHAR(10)) + N' columns with potential size of '
									+ CAST(cc.sum_max_length AS NVARCHAR(10))
									+ N' bytes in clustered index:' + i.schema_object_name 
									+ N'. ' + 
										(SELECT CAST(COUNT(*) AS NVARCHAR(23)) FROM #IndexSanity i2 
										WHERE i2.[object_id]=i.[object_id] AND i2.index_id &lt;&gt; 1
										AND i2.is_disabled=0 AND i2.is_hypothetical=0)
										+ N' NC indexes on the table.'
									AS details,
								i.index_definition,
								secret_columns, 
								i.index_usage_summary,
								ip.index_size_summary
						FROM	#IndexSanity i
						JOIN	#IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						JOIN	count_columns AS cc ON i.[object_id]=cc.[object_id]	
						WHERE	index_id = 1 /* clustered only */
								AND 
									(count_key_columns &gt; 3 /*More than three key columns.*/
									OR cc.sum_max_length &gt; 15 /*More than 16 bytes in key */)
						ORDER BY i.schema_object_name DESC OPTION	( RECOMPILE );

			RAISERROR(N'check_id 25: Addicted to nullable columns.', 0,1) WITH NOWAIT;
				WITH count_columns AS (
							SELECT [object_id],
								SUM(CASE is_nullable WHEN 1 THEN 0 ELSE 1 END) as non_nullable_columns,
								COUNT(*) as total_columns
							FROM #IndexColumns ic
							WHERE index_id in (1,0) /*Heap or clustered only*/
							GROUP BY object_id
							)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	25 AS check_id, 
								i.index_sanity_id, 
								N'Index Hoarder' AS findings_group,
								N'Addicted to nulls' AS finding,
								N'http://BrentOzar.com/go/IndexHoarder' AS URL,
								i.schema_object_name 
									+ N' allows null in ' + CAST((total_columns-non_nullable_columns) as NVARCHAR(10))
									+ N' of ' + CAST(total_columns as NVARCHAR(10))
									+ N' columns.' AS details,
								i.index_definition,
								secret_columns, 
								ISNULL(i.index_usage_summary,''),
								ISNULL(ip.index_size_summary,'')
						FROM	#IndexSanity i
						JOIN	#IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						JOIN	count_columns AS cc ON i.[object_id]=cc.[object_id]
						WHERE	i.index_id in (1,0)
							AND cc.non_nullable_columns &lt; 2
							and cc.total_columns &gt; 3
						ORDER BY i.schema_object_name DESC OPTION	( RECOMPILE );

			RAISERROR(N'check_id 26: Wide tables (35+ cols or &gt; 2000 non-LOB bytes).', 0,1) WITH NOWAIT;
				WITH count_columns AS (
							SELECT [object_id],
								SUM(CASE max_length when -1 THEN 1 ELSE 0 END) AS count_lob_columns,
								SUM(CASE max_length when -1 THEN 0 ELSE max_length END) AS sum_max_length,
								COUNT(*) as total_columns
							FROM #IndexColumns ic
							WHERE index_id in (1,0) /*Heap or clustered only*/
							GROUP BY object_id
							)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	26 AS check_id, 
								i.index_sanity_id, 
								N'Index Hoarder' AS findings_group,
								N'Wide tables: 35+ cols or &gt; 2000 non-LOB bytes' AS finding,
								N'http://BrentOzar.com/go/IndexHoarder' AS URL,
								i.schema_object_name 
									+ N' has ' + CAST((total_columns) as NVARCHAR(10))
									+ N' total columns with a max possible width of ' + CAST(sum_max_length as NVARCHAR(10))
									+ N' bytes.' +
									CASE WHEN count_lob_columns &gt; 0 THEN CAST((count_lob_columns) as NVARCHAR(10))
										+ ' columns are LOB types.' ELSE ''
									END
										AS details,
								i.index_definition,
								secret_columns, 
								ISNULL(i.index_usage_summary,''),
								ISNULL(ip.index_size_summary,'')
						FROM	#IndexSanity i
						JOIN	#IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						JOIN	count_columns AS cc ON i.[object_id]=cc.[object_id]
						WHERE	i.index_id in (1,0)
							and 
							(cc.total_columns &gt;= 35 OR
							cc.sum_max_length &gt;= 2000)
						ORDER BY i.schema_object_name DESC OPTION	( RECOMPILE );
					
			RAISERROR(N'check_id 27: Addicted to strings.', 0,1) WITH NOWAIT;
				WITH count_columns AS (
							SELECT [object_id],
								SUM(CASE WHEN system_type_name in ('varchar','nvarchar','char') or max_length=-1 THEN 1 ELSE 0 END) as string_or_LOB_columns,
								COUNT(*) as total_columns
							FROM #IndexColumns ic
							WHERE index_id in (1,0) /*Heap or clustered only*/
							GROUP BY object_id
							)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	27 AS check_id, 
								i.index_sanity_id, 
								N'Index Hoarder' AS findings_group,
								N'Addicted to strings' AS finding,
								N'http://BrentOzar.com/go/IndexHoarder' AS URL,
								i.schema_object_name 
									+ N' uses string or LOB types for ' + CAST((string_or_LOB_columns) as NVARCHAR(10))
									+ N' of ' + CAST(total_columns as NVARCHAR(10))
									+ N' columns. Check if data types are valid.' AS details,
								i.index_definition,
								secret_columns, 
								ISNULL(i.index_usage_summary,''),
								ISNULL(ip.index_size_summary,'')
						FROM	#IndexSanity i
						JOIN	#IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						JOIN	count_columns AS cc ON i.[object_id]=cc.[object_id]
						CROSS APPLY (SELECT cc.total_columns - string_or_LOB_columns AS non_string_or_lob_columns) AS calc1
						WHERE	i.index_id in (1,0)
							AND calc1.non_string_or_lob_columns &lt;= 1
							AND cc.total_columns &gt; 3
						ORDER BY i.schema_object_name DESC OPTION	( RECOMPILE );

			RAISERROR(N'check_id 28: Non-unique clustered index.', 0,1) WITH NOWAIT;
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	28 AS check_id, 
								i.index_sanity_id, 
								N'Index Hoarder' AS findings_group,
								N'Non-Unique clustered index' AS finding,
								N'http://BrentOzar.com/go/IndexHoarder' AS URL,
								N'Uniquifiers will be required! Clustered index: ' + i.schema_object_name 
									+ N' and all NC indexes. ' + 
										(SELECT CAST(COUNT(*) AS NVARCHAR(23)) FROM #IndexSanity i2 
										WHERE i2.[object_id]=i.[object_id] AND i2.index_id &lt;&gt; 1
										AND i2.is_disabled=0 AND i2.is_hypothetical=0)
										+ N' NC indexes on the table.'
									AS details,
								i.index_definition,
								secret_columns, 
								i.index_usage_summary,
								ip.index_size_summary
						FROM	#IndexSanity i
						JOIN	#IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						WHERE	index_id = 1 /* clustered only */
								AND is_unique=0 /* not unique */
								AND is_CX_columnstore=0 /* not a clustered columnstore-- no unique option on those */
						ORDER BY i.schema_object_name DESC OPTION	( RECOMPILE );


		END
		 ----------------------------------------
		--Feature-Phobic Indexes: Check_id 30-39
		---------------------------------------- 
		BEGIN
			RAISERROR(N'check_id 30: No indexes with includes', 0,1) WITH NOWAIT;

			DECLARE	@number_indexes_with_includes INT;
			DECLARE	@percent_indexes_with_includes NUMERIC(10, 1);

			SELECT	@number_indexes_with_includes = SUM(CASE WHEN count_included_columns &gt; 0 THEN 1 ELSE 0	END),
					@percent_indexes_with_includes = 100.* 
						SUM(CASE WHEN count_included_columns &gt; 0 THEN 1 ELSE 0 END) / ( 1.0 * COUNT(*) )
			FROM	#IndexSanity;

			IF @number_indexes_with_includes = 0 
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	30 AS check_id, 
								NULL AS index_sanity_id, 
								N'Feature-Phobic Indexes' AS findings_group,
								N'No indexes use includes' AS finding, 'http://BrentOzar.com/go/IndexFeatures' AS URL,
								N'No indexes use includes' AS details,
								N'Entire database' AS index_definition, 
								N'' AS secret_columns, 
								N'N/A' AS index_usage_summary, 
								N'N/A' AS index_size_summary OPTION	( RECOMPILE );

			RAISERROR(N'check_id 31: &lt; 3 percent of indexes have includes', 0,1) WITH NOWAIT;
			IF @percent_indexes_with_includes &lt;= 3 AND @number_indexes_with_includes &gt; 0 
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	31 AS check_id,
								NULL AS index_sanity_id, 
								N'Feature-Phobic Indexes' AS findings_group,
								N'Borderline: Includes are used in &lt; 3% of indexes' AS findings,
								N'http://BrentOzar.com/go/IndexFeatures' AS URL,
								N'Only ' + CAST(@percent_indexes_with_includes AS NVARCHAR(10)) + '% of indexes have includes' AS details, 
								N'Entire database' AS index_definition, 
								N'' AS secret_columns,
								N'N/A' AS index_usage_summary, 
								N'N/A' AS index_size_summary OPTION	( RECOMPILE );

			RAISERROR(N'check_id 32: filtered indexes and indexed views', 0,1) WITH NOWAIT;
			DECLARE @count_filtered_indexes INT;
			DECLARE @count_indexed_views INT;

				SELECT	@count_filtered_indexes=COUNT(*)
				FROM	#IndexSanity
				WHERE	filter_definition &lt;&gt; '' OPTION	( RECOMPILE );

				SELECT	@count_indexed_views=COUNT(*)
				FROM	#IndexSanity AS i
						JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
				WHERE	is_indexed_view = 1 OPTION	( RECOMPILE );

			IF @count_filtered_indexes = 0 AND @count_indexed_views=0
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	32 AS check_id, 
								NULL AS index_sanity_id,
								N'Feature-Phobic Indexes' AS findings_group,
								N'Borderline: No filtered indexes or indexed views exist' AS finding, 
								N'http://BrentOzar.com/go/IndexFeatures' AS URL,
								N'These are NOT always needed-- but do you know when you would use them?' AS details,
								N'Entire database' AS index_definition, 
								N'' AS secret_columns,
								N'N/A' AS index_usage_summary, 
								N'N/A' AS index_size_summary OPTION	( RECOMPILE );
		END;

		RAISERROR(N'check_id 33: Potential filtered indexes based on column names.', 0,1) WITH NOWAIT;

		INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										secret_columns, index_usage_summary, index_size_summary )
		SELECT	33 AS check_id, 
				i.index_sanity_id AS index_sanity_id,
				N'Feature-Phobic Indexes' AS findings_group,
				N'Potential filtered index (based on column name)' AS finding, 
				N'http://BrentOzar.com/go/IndexFeatures' AS URL,
				N'A column name in this index suggests it might be a candidate for filtering (is%, %archive%, %active%, %flag%)' AS details,
				i.index_definition, 
				i.secret_columns,
				i.index_usage_summary, 
				sz.index_size_summary
		FROM #IndexColumns ic 
		join #IndexSanity i on 
			ic.[object_id]=i.[object_id] and
			ic.[index_id]=i.[index_id] and
			i.[index_id] &gt; 1 /* non-clustered index */
		JOIN	#IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
		WHERE column_name like 'is%'
			or column_name like '%archive%'
			or column_name like '%active%'
			or column_name like '%flag%'
		OPTION	( RECOMPILE );

		 ----------------------------------------
		--Self Loathing Indexes : Check_id 40-49
		----------------------------------------
		BEGIN

			RAISERROR(N'check_id 40: Fillfactor in nonclustered 80 percent or less', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	40 AS check_id, 
							i.index_sanity_id,
							N'Self Loathing Indexes' AS findings_group,
							N'Low Fill Factor: nonclustered index' AS finding, 
							N'http://BrentOzar.com/go/SelfLoathing' AS URL,
							N'Fill factor on ' + schema_object_indexid + N' is ' + CAST(fill_factor AS NVARCHAR(10)) + N'%. '+
								CASE WHEN (last_user_update is null OR user_updates &lt; 1)
								THEN N'No writes have been made.'
								ELSE
									N'Last write was ' +  CONVERT(NVARCHAR(16),last_user_update,121) + N' and ' + 
									CAST(user_updates as NVARCHAR(25)) + N' updates have been made.'
								END
								AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							sz.index_size_summary
					FROM	#IndexSanity AS i
					JOIN	#IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE	index_id &gt; 1
					and	fill_factor BETWEEN 1 AND 80 OPTION	( RECOMPILE );

			RAISERROR(N'check_id 40: Fillfactor in clustered 90 percent or less', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	40 AS check_id, 
							i.index_sanity_id,
							N'Self Loathing Indexes' AS findings_group,
							N'Low Fill Factor: clustered index' AS finding, 
							N'http://BrentOzar.com/go/SelfLoathing' AS URL,
							N'Fill factor on ' + schema_object_indexid + N' is ' + CAST(fill_factor AS NVARCHAR(10)) + N'%. '+
								CASE WHEN (last_user_update is null OR user_updates &lt; 1)
								THEN N'No writes have been made.'
								ELSE
									N'Last write was ' +  CONVERT(NVARCHAR(16),last_user_update,121) + N' and ' + 
									CAST(user_updates as NVARCHAR(25)) + N' updates have been made.'
								END
								AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							sz.index_size_summary
					FROM	#IndexSanity AS i
					JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE	index_id = 1
					and fill_factor BETWEEN 1 AND 90 OPTION	( RECOMPILE );


			RAISERROR(N'check_id 41: Hypothetical indexes ', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	41 AS check_id, 
							N'Self Loathing Indexes' AS findings_group,
							N'Hypothetical Index' AS finding, 'http://BrentOzar.com/go/SelfLoathing' AS URL,
							N'Hypothetical Index: ' + schema_object_indexid AS details, 
							i.index_definition,
							i.secret_columns,
							N'' AS index_usage_summary, 
							N'' AS index_size_summary
					FROM	#IndexSanity AS i
					WHERE	is_hypothetical = 1 OPTION	( RECOMPILE );


			RAISERROR(N'check_id 42: Disabled indexes', 0,1) WITH NOWAIT;
			--Note: disabled NC indexes will have O rows in #IndexSanitySize!
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	42 AS check_id, 
							index_sanity_id,
							N'Self Loathing Indexes' AS findings_group,
							N'Disabled Index' AS finding, 
							N'http://BrentOzar.com/go/SelfLoathing' AS URL,
							N'Disabled Index:' + schema_object_indexid AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							'DISABLED' AS index_size_summary
					FROM	#IndexSanity AS i
					WHERE	is_disabled = 1 OPTION	( RECOMPILE );

			RAISERROR(N'check_id 43: Heaps with forwarded records or deletes', 0,1) WITH NOWAIT;
			WITH	heaps_cte
					  AS ( SELECT	[object_id], 
									SUM(forwarded_fetch_count) AS forwarded_fetch_count,
									SUM(leaf_delete_count) AS leaf_delete_count
						   FROM		#IndexPartitionSanity
						   GROUP BY	[object_id]
						   HAVING	SUM(forwarded_fetch_count) &gt; 0
									OR SUM(leaf_delete_count) &gt; 0)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	43 AS check_id, 
								i.index_sanity_id,
								N'Self Loathing Indexes' AS findings_group,
								N'Heaps with forwarded records or deletes' AS finding, 
								N'http://BrentOzar.com/go/SelfLoathing' AS URL,
								CAST(h.forwarded_fetch_count AS NVARCHAR(256)) + ' forwarded fetches, '
								+ CAST(h.leaf_delete_count AS NVARCHAR(256)) + ' deletes against heap:'
								+ schema_object_indexid AS details, 
								i.index_definition, 
								i.secret_columns,
								i.index_usage_summary,
								sz.index_size_summary
						FROM	#IndexSanity i
						JOIN heaps_cte h ON i.[object_id] = h.[object_id]
						JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
						WHERE	i.index_id = 0 
				OPTION	( RECOMPILE );

			RAISERROR(N'check_id 44: Heaps with reads or writes.', 0,1) WITH NOWAIT;
			WITH	heaps_cte
					  AS ( SELECT	[object_id], SUM(forwarded_fetch_count) AS forwarded_fetch_count,
									SUM(leaf_delete_count) AS leaf_delete_count
						   FROM		#IndexPartitionSanity
						   GROUP BY	[object_id]
						   HAVING	SUM(forwarded_fetch_count) &gt; 0
									OR SUM(leaf_delete_count) &gt; 0)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	44 AS check_id, 
								i.index_sanity_id,
								N'Self Loathing Indexes' AS findings_group,
								N'Active heap' AS finding, 
								N'http://BrentOzar.com/go/SelfLoathing' AS URL,
								N'Should this table be a heap? ' + schema_object_indexid AS details, 
								i.index_definition, 
								'N/A' AS secret_columns,
								i.index_usage_summary,
								sz.index_size_summary
						FROM	#IndexSanity i
						LEFT JOIN heaps_cte h ON i.[object_id] = h.[object_id]
						JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
						WHERE	i.index_id = 0 
								AND 
									(i.total_reads &gt; 0 OR i.user_updates &gt; 0)
								AND h.[object_id] IS NULL /*don't duplicate the prior check.*/
				OPTION	( RECOMPILE );


			END;
		----------------------------------------
		--Indexaphobia
		--Missing indexes with value &gt;= 5 million: : Check_id 50-59
		----------------------------------------
		BEGIN
			RAISERROR(N'check_id 50: Indexaphobia.', 0,1) WITH NOWAIT;
			WITH	index_size_cte
					  AS ( SELECT	i.[object_id], 
									MAX(i.index_sanity_id) AS index_sanity_id,
								ISNULL (
									CAST(SUM(CASE WHEN index_id NOT IN (0,1) THEN 1 ELSE 0 END)
										 AS NVARCHAR(30))+ N' NC indexes exist (' + 
									CASE WHEN SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END) &gt; 1024
										THEN CAST(CAST(SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END )/1024. 
											AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'GB); ' 
										ELSE CAST(SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END) 
											AS NVARCHAR(30)) + N'MB); '
									END + 
										CASE WHEN MAX(sz.[total_rows]) &gt;= 922337203685477 THEN '&gt;= 922,337,203,685,477'
										ELSE REPLACE(CONVERT(NVARCHAR(30),CAST(MAX(sz.[total_rows]) AS money), 1), '.00', '') 
										END +
									+ N' Estimated Rows;' 
								,N'') AS index_size_summary
							FROM	#IndexSanity AS i
							LEFT	JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
						   GROUP BY	i.[object_id])
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   index_usage_summary, index_size_summary, create_tsql, more_info )
						SELECT	50 AS check_id, 
								sz.index_sanity_id,
								N'Indexaphobia' AS findings_group,
								N'High value missing index' AS finding, 
								N'http://BrentOzar.com/go/Indexaphobia' AS URL,
								mi.[statement] + ' estimated benefit: ' + 
									CASE WHEN magic_benefit_number &gt;= 922337203685477 THEN '&gt;= 922,337,203,685,477'
									ELSE REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(magic_benefit_number AS BIGINT) AS money), 1), '.00', '') 
									END AS details,
								missing_index_details AS [definition],
								index_estimated_impact,
								sz.index_size_summary,
								mi.create_tsql,
								mi.more_info
				FROM	#MissingIndexes mi
						LEFT JOIN index_size_cte sz ON mi.[object_id] = sz.object_id
				WHERE magic_benefit_number &gt; 500000
				ORDER BY magic_benefit_number DESC;

	END
		 ----------------------------------------
		--Abnormal Psychology : Check_id 60-79
		----------------------------------------
	BEGIN
			RAISERROR(N'check_id 60: XML indexes', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	60 AS check_id, 
							i.index_sanity_id,
							N'Abnormal Psychology' AS findings_group,
							N'XML Indexes' AS finding, 
							N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
							i.schema_object_indexid AS details, 
							i.index_definition,
							i.secret_columns,
							N'' AS index_usage_summary,
							ISNULL(sz.index_size_summary,'') AS index_size_summary
					FROM	#IndexSanity AS i
					JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE i.is_XML = 1 OPTION	( RECOMPILE );

			RAISERROR(N'check_id 61: Columnstore indexes', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	61 AS check_id, 
							i.index_sanity_id,
							N'Abnormal Psychology' AS findings_group,
							CASE WHEN i.is_NC_columnstore=1
								THEN N'NC Columnstore Index' 
								ELSE N'Clustered Columnstore Index' 
								END AS finding, 
							N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
							i.schema_object_indexid AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							ISNULL(sz.index_size_summary,'') AS index_size_summary
					FROM	#IndexSanity AS i
					JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE i.is_NC_columnstore = 1 OR i.is_CX_columnstore=1
					OPTION	( RECOMPILE );


			RAISERROR(N'check_id 62: Spatial indexes', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	62 AS check_id, 
							i.index_sanity_id,
							N'Abnormal Psychology' AS findings_group,
							N'Spatial indexes' AS finding, 
							N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
							i.schema_object_indexid AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							ISNULL(sz.index_size_summary,'') AS index_size_summary
					FROM	#IndexSanity AS i
					JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE i.is_spatial = 1 OPTION	( RECOMPILE );

			RAISERROR(N'check_id 63: Compressed indexes', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	63 AS check_id, 
							i.index_sanity_id,
							N'Abnormal Psychology' AS findings_group,
							N'Compressed indexes' AS finding, 
							N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
							i.schema_object_indexid  + N'. COMPRESSION: ' + sz.data_compression_desc AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							ISNULL(sz.index_size_summary,'') AS index_size_summary
					FROM	#IndexSanity AS i
					JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE sz.data_compression_desc LIKE '%PAGE%' OR sz.data_compression_desc LIKE '%ROW%' OPTION	( RECOMPILE );

			RAISERROR(N'check_id 64: Partitioned', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	64 AS check_id, 
							i.index_sanity_id,
							N'Abnormal Psychology' AS findings_group,
							N'Partitioned indexes' AS finding, 
							N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
							i.schema_object_indexid AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							ISNULL(sz.index_size_summary,'') AS index_size_summary
					FROM	#IndexSanity AS i
					JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE i.partition_key_column_name IS NOT NULL OPTION	( RECOMPILE );

			RAISERROR(N'check_id 65: Non-Aligned Partitioned', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	65 AS check_id, 
							i.index_sanity_id,
							N'Abnormal Psychology' AS findings_group,
							N'Non-Aligned index on a partitioned table' AS finding, 
							N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
							i.schema_object_indexid AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							ISNULL(sz.index_size_summary,'') AS index_size_summary
					FROM	#IndexSanity AS i
					JOIN #IndexSanity AS iParent ON
						i.[object_id]=iParent.[object_id]
						AND iParent.index_id IN (0,1) /* could be a partitioned heap or clustered table */
						AND iParent.partition_key_column_name IS NOT NULL /* parent is partitioned*/         
					JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE i.partition_key_column_name IS NULL 
						OPTION	( RECOMPILE );

			RAISERROR(N'check_id 66: Recently created tables/indexes (1 week)', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	66 AS check_id, 
							i.index_sanity_id,
							N'Abnormal Psychology' AS findings_group,
							N'Recently created tables/indexes (1 week)' AS finding, 
							N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
							i.schema_object_indexid + N' was created on ' + 
								CONVERT(NVARCHAR(16),i.create_date,121) + 
								N'. Tables/indexes which are dropped/created regularly require special methods for index tuning.'
									 AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							ISNULL(sz.index_size_summary,'') AS index_size_summary
					FROM	#IndexSanity AS i
					JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE i.create_date &gt;= DATEADD(dd,-7,GETDATE()) 
						OPTION	( RECOMPILE );

			RAISERROR(N'check_id 67: Recently modified tables/indexes (2 days)', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
										   secret_columns, index_usage_summary, index_size_summary )
					SELECT	67 AS check_id, 
							i.index_sanity_id,
							N'Abnormal Psychology' AS findings_group,
							N'Recently modified tables/indexes (2 days)' AS finding, 
							N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
							i.schema_object_indexid + N' was modified on ' + 
								CONVERT(NVARCHAR(16),i.modify_date,121) + 
								N'. A large amount of recently modified indexes may mean a lot of rebuilds are occurring each night.'
									 AS details, 
							i.index_definition,
							i.secret_columns,
							i.index_usage_summary,
							ISNULL(sz.index_size_summary,'') AS index_size_summary
					FROM	#IndexSanity AS i
					JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
					WHERE i.modify_date &gt; DATEADD(dd,-2,GETDATE()) 
					and /*Exclude recently created tables unless they've been modified after being created.*/
					(i.create_date &lt; DATEADD(dd,-7,GETDATE()) or i.create_date &lt;&gt; i.modify_date)
						OPTION	( RECOMPILE );

			RAISERROR(N'check_id 68: Identity columns within 30 percent of the end of range', 0,1) WITH NOWAIT;
			-- Allowed Ranges: 
				--int -2,147,483,648 to 2,147,483,647
				--smallint -32,768 to 32,768
				--tinyint 0 to 255

				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	68 AS check_id, 
								i.index_sanity_id, 
								N'Abnormal Psychology' AS findings_group,
								N'Identity column within ' + 									
									CAST (calc1.percent_remaining as nvarchar(256))
									+ N' percent  end of range' AS finding,
								N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
								i.schema_object_name + N'.' +  QUOTENAME(ic.column_name)
									+ N' is an identity with type ' + ic.system_type_name 
									+ N', last value of ' 
										+ ISNULL(REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(ic.last_value AS BIGINT) AS money), 1), '.00', ''),N'NULL')
									+ N', seed of '
										+ ISNULL(REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(ic.seed_value AS BIGINT) AS money), 1), '.00', ''),N'NULL')
									+ N', increment of ' + CAST(ic.increment_value AS NVARCHAR(256)) 
									+ N', and range of ' +
										CASE ic.system_type_name WHEN 'int' THEN N'+/- 2,147,483,647'
											WHEN 'smallint' THEN N'+/- 32,768'
											WHEN 'tinyint' THEN N'0 to 255'
										END
										AS details,
								i.index_definition,
								secret_columns, 
								ISNULL(i.index_usage_summary,''),
								ISNULL(ip.index_size_summary,'')
						FROM	#IndexSanity i
						JOIN	#IndexColumns ic on
							i.object_id=ic.object_id
							and i.index_id in (0,1) /* heaps and cx only */
							and ic.is_identity=1
							and ic.system_type_name in ('tinyint', 'smallint', 'int')
						JOIN	#IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						CROSS APPLY (
							SELECT CAST(CASE WHEN ic.increment_value &gt;= 0
									THEN
										CASE ic.system_type_name 
											WHEN 'int' then (2147483647 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 2147483647.*100
											WHEN 'smallint' then (32768 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 32768.*100
											WHEN 'tinyint' then ( 255 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 255.*100
											ELSE 999
										END
								ELSE --ic.increment_value is negative
										CASE ic.system_type_name 
											WHEN 'int' then ABS(-2147483647 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 2147483647.*100
											WHEN 'smallint' then ABS(-32768 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 32768.*100
											WHEN 'tinyint' then ABS( 0 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 255.*100
											ELSE -1
										END 
								END AS NUMERIC(5,1)) AS percent_remaining
								) as calc1
						WHERE	i.index_id in (1,0)
							and calc1.percent_remaining &lt;= 30
						UNION ALL
						SELECT	68 AS check_id, 
								i.index_sanity_id, 
								N'Abnormal Psychology' AS findings_group,
								N'Identity column using a negative seed or increment other than 1' AS finding,
								N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
								i.schema_object_name + N'.' +  QUOTENAME(ic.column_name)
									+ N' is an identity with type ' + ic.system_type_name 
									+ N', last value of ' 
										+ ISNULL(REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(ic.last_value AS BIGINT) AS money), 1), '.00', ''),N'NULL')
									+ N', seed of '
										+ ISNULL(REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(ic.seed_value AS BIGINT) AS money), 1), '.00', ''),N'NULL')
									+ N', increment of ' + CAST(ic.increment_value AS NVARCHAR(256)) 
									+ N', and range of ' +
										CASE ic.system_type_name WHEN 'int' THEN N'+/- 2,147,483,647'
											WHEN 'smallint' THEN N'+/- 32,768'
											WHEN 'tinyint' THEN N'0 to 255'
										END
										AS details,
								i.index_definition,
								secret_columns, 
								ISNULL(i.index_usage_summary,''),
								ISNULL(ip.index_size_summary,'')
						FROM	#IndexSanity i
						JOIN	#IndexColumns ic on
							i.object_id=ic.object_id
							and i.index_id in (0,1) /* heaps and cx only */
							and ic.is_identity=1
							and ic.system_type_name in ('tinyint', 'smallint', 'int')
						JOIN	#IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						WHERE	i.index_id in (1,0)
							and (ic.seed_value &lt; 0 or ic.increment_value &lt;&gt; 1)
						ORDER BY finding, details DESC OPTION	( RECOMPILE );

			RAISERROR(N'check_id 69: Column collation does not match database collation', 0,1) WITH NOWAIT;
				WITH count_columns AS (
							SELECT [object_id],
								COUNT(*) as column_count
							FROM #IndexColumns ic
							WHERE index_id in (1,0) /*Heap or clustered only*/
								and collation_name &lt;&gt; @collation
							GROUP BY object_id
							)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	69 AS check_id, 
								i.index_sanity_id, 
								N'Abnormal Psychology' AS findings_group,
								N'Column collation does not match database collation' AS finding,
								N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
								i.schema_object_name 
									+ N' has ' + CAST(column_count AS NVARCHAR(20))
									+ N' column' + CASE WHEN column_count &gt; 1 THEN 's' ELSE '' END
									+ N' with a different collation than the db collation of '
									+ @collation	AS details,
								i.index_definition,
								secret_columns, 
								ISNULL(i.index_usage_summary,''),
								ISNULL(ip.index_size_summary,'')
						FROM	#IndexSanity i
						JOIN	#IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						JOIN	count_columns AS cc ON i.[object_id]=cc.[object_id]
						WHERE	i.index_id in (1,0)
						ORDER BY i.schema_object_name DESC OPTION	( RECOMPILE );

			RAISERROR(N'check_id 70: Replicated columns', 0,1) WITH NOWAIT;
				WITH count_columns AS (
							SELECT [object_id],
								COUNT(*) as column_count,
								SUM(CASE is_replicated WHEN 1 THEN 1 ELSE 0 END) as replicated_column_count
							FROM #IndexColumns ic
							WHERE index_id in (1,0) /*Heap or clustered only*/
							GROUP BY object_id
							)
				INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
											   secret_columns, index_usage_summary, index_size_summary )
						SELECT	70 AS check_id, 
								i.index_sanity_id, 
								N'Abnormal Psychology' AS findings_group,
								N'Replicated columns' AS finding,
								N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
								i.schema_object_name 
									+ N' has ' + CAST(replicated_column_count AS NVARCHAR(20))
									+ N' out of ' + CAST(column_count AS NVARCHAR(20))
									+ N' column' + CASE WHEN column_count &gt; 1 THEN 's' ELSE '' END
									+ N' in one or more publications.'
										AS details,
								i.index_definition,
								secret_columns, 
								ISNULL(i.index_usage_summary,''),
								ISNULL(ip.index_size_summary,'')
						FROM	#IndexSanity i
						JOIN	#IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
						JOIN	count_columns AS cc ON i.[object_id]=cc.[object_id]
						WHERE	i.index_id in (1,0)
							and replicated_column_count &gt; 0
						ORDER BY i.schema_object_name DESC OPTION	( RECOMPILE );

			RAISERROR(N'check_id 71: Cascading updates or cascading deletes.', 0,1) WITH NOWAIT;
			INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
								   secret_columns, index_usage_summary, index_size_summary, more_info )
			SELECT	71 AS check_id, 
					null as index_sanity_id,
					N'Abnormal Psychology' AS findings_group,
					N'Cascading Updates or Deletes' AS finding, 
					N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
					N'Foreign Key ' + foreign_key_name +
					N' on ' + QUOTENAME(parent_object_name)  + N'(' + LTRIM(parent_fk_columns) + N')'
						+ N' referencing ' + QUOTENAME(referenced_object_name) + N'(' + LTRIM(referenced_fk_columns) + N')'
						+ N' has settings:'
						+ CASE [delete_referential_action_desc] WHEN N'NO_ACTION' THEN N'' ELSE N' ON DELETE ' +[delete_referential_action_desc] END
						+ CASE [update_referential_action_desc] WHEN N'NO_ACTION' THEN N'' ELSE N' ON UPDATE ' + [update_referential_action_desc] END
							AS details, 
					N'N/A' 
							AS index_definition, 
					N'N/A' AS secret_columns,
					N'N/A' AS index_usage_summary,
					N'N/A' AS index_size_summary,
					(SELECT TOP 1 more_info from #IndexSanity i where i.object_id=fk.parent_object_id)
						AS more_info
			from #ForeignKeys fk
			where [delete_referential_action_desc] &lt;&gt; N'NO_ACTION'
			OR [update_referential_action_desc] &lt;&gt; N'NO_ACTION'

	END

		 ----------------------------------------
		--Workaholics: Check_id 80-89
		----------------------------------------
	BEGIN

		RAISERROR(N'check_id 80: Most scanned indexes (index_usage_stats)', 0,1) WITH NOWAIT;
		INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
							   secret_columns, index_usage_summary, index_size_summary )

		--Workaholics according to index_usage_stats
		--This isn't perfect: it mentions the number of scans present in a plan
		--A "scan" isn't necessarily a full scan, but hey, we gotta do the best with what we've got.
		--in the case of things like indexed views, the operator might be in the plan but never executed
		SELECT TOP 5 
			80 AS check_id,
			i.index_sanity_id as index_sanity_id,
			N'Workaholics' as findings_group,
			N'Scan-a-lots (index_usage_stats)' as finding,
			N'http://BrentOzar.com/go/Workaholics' AS URL,
			REPLACE(CONVERT( NVARCHAR(50),CAST(i.user_scans AS MONEY),1),'.00','')
				+ N' scans against ' + i.schema_object_indexid
				+ N'. Latest scan: ' + ISNULL(cast(i.last_user_scan as nvarchar(128)),'?') + N'. ' 
				+ N'ScanFactor=' + cast(((i.user_scans * iss.total_reserved_MB)/1000000.) as NVARCHAR(256)) as details,
			isnull(i.key_column_names_with_sort_order,'N/A') as index_definition,
			isnull(i.secret_columns,'') as secret_columns,
			i.index_usage_summary as index_usage_summary,
			iss.index_size_summary as index_size_summary
		FROM #IndexSanity i
		JOIN #IndexSanitySize iss on i.index_sanity_id=iss.index_sanity_id
		WHERE isnull(i.user_scans,0) &gt; 0
		ORDER BY  i.user_scans * iss.total_reserved_MB DESC;

		RAISERROR(N'check_id 81: Top recent accesses (op stats)', 0,1) WITH NOWAIT;
		INSERT	#BlitzIndexResults ( check_id, index_sanity_id, findings_group, finding, URL, details, index_definition,
							   secret_columns, index_usage_summary, index_size_summary )
		--Workaholics according to index_operational_stats
		--This isn't perfect either: range_scan_count contains full scans, partial scans, even seeks in nested loop ops
		--But this can help bubble up some most-accessed tables 
		SELECT TOP 5 
			81 as check_id,
			i.index_sanity_id as index_sanity_id,
			N'Workaholics' as findings_group,
			N'Top recent accesses (index_op_stats)' as finding,
			N'http://BrentOzar.com/go/Workaholics' AS URL,
			ISNULL(REPLACE(
					CONVERT(NVARCHAR(50),cast((iss.total_range_scan_count + iss.total_singleton_lookup_count) AS MONEY),1),
					N'.00',N'') 
				+ N' uses of ' + i.schema_object_indexid + N'. '
				+ REPLACE(CONVERT(NVARCHAR(50), CAST(iss.total_range_scan_count AS MONEY),1),N'.00',N'') + N' scans or seeks. '
				+ REPLACE(CONVERT(NVARCHAR(50), CAST(iss.total_singleton_lookup_count AS MONEY), 1),N'.00',N'') + N' singleton lookups. '
				+ N'OpStatsFactor=' + cast(((((iss.total_range_scan_count + iss.total_singleton_lookup_count) * iss.total_reserved_MB))/1000000.) as varchar(256)),'') as details,
			isnull(i.key_column_names_with_sort_order,'N/A') as index_definition,
			isnull(i.secret_columns,'') as secret_columns,
			i.index_usage_summary as index_usage_summary,
			iss.index_size_summary as index_size_summary
		FROM #IndexSanity i
		JOIN #IndexSanitySize iss on i.index_sanity_id=iss.index_sanity_id
		WHERE isnull(iss.total_range_scan_count,0)  &gt; 0 or isnull(iss.total_singleton_lookup_count,0) &gt; 0
		ORDER BY ((iss.total_range_scan_count + iss.total_singleton_lookup_count) * iss.total_reserved_MB) DESC;


	END

		 ----------------------------------------
		--FINISHING UP
		----------------------------------------
	BEGIN
				INSERT	#BlitzIndexResults ( check_id, findings_group, finding, URL, details, index_definition,secret_columns,
											   index_usage_summary, index_size_summary )
				VALUES  ( 1000 , N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + convert(nvarchar(16),getdate(),121)	,
						N'' ,   N'http://www.BrentOzar.com/BlitzIndex' ,
						N'Thanks from the Brent Ozar Unlimited(TM), LLC team.',
						N'We hope you found this tool useful.',
						N'If you need help relieving your SQL Server pains, email us at Help@BrentOzar.com.'
						, N'',N''
						);


	END
		RAISERROR(N'Returning results.', 0,1) WITH NOWAIT;
			
		/*Return results.*/
		SELECT isnull(br.findings_group,N'') + 
				CASE WHEN ISNULL(br.finding,N'') &lt;&gt; N'' THEN N': ' ELSE N'' END
				+ br.finding AS [Finding], 
			br.URL, 
			br.details AS [Details: schema.table.index(indexid)], 
			br.index_definition AS [Definition: [Property]] ColumnName {datatype maxbytes}], 
			ISNULL(br.secret_columns,'') AS [Secret Columns],          
			br.index_usage_summary AS [Usage], 
			br.index_size_summary AS [Size],
			COALESCE(br.more_info,sn.more_info,'') AS [More Info],
			COALESCE(br.create_tsql,ts.create_tsql,'') AS [Create TSQL]
		FROM #BlitzIndexResults br
		LEFT JOIN #IndexSanity sn ON 
			br.index_sanity_id=sn.index_sanity_id
		LEFT JOIN #IndexCreateTsql ts ON 
			br.index_sanity_id=ts.index_sanity_id
		ORDER BY [check_id] ASC, blitz_result_id ASC, findings_group;

	END; /* End @Mode=0 (diagnose)*/
	ELSE IF @Mode=1 /*Summarize*/
	BEGIN
	--This mode is to give some overall stats on the database.
		RAISERROR(N'@Mode=1, we are summarizing.', 0,1) WITH NOWAIT;

		SELECT 
			CAST((COUNT(*)) AS NVARCHAR(256)) AS [Number Objects],
			CAST(CAST(SUM(sz.total_reserved_MB)/
				1024. AS numeric(29,1)) AS NVARCHAR(500)) AS [All GB],
			CAST(CAST(SUM(sz.total_reserved_LOB_MB)/
				1024. AS numeric(29,1)) AS NVARCHAR(500)) AS [LOB GB],
			CAST(CAST(SUM(sz.total_reserved_row_overflow_MB)/
				1024. AS numeric(29,1)) AS NVARCHAR(500)) AS [Row Overflow GB],
			CAST(SUM(CASE WHEN index_id=1 THEN 1 ELSE 0 END)AS NVARCHAR(50)) AS [Clustered Tables],
			CAST(SUM(CASE WHEN index_id=1 THEN sz.total_reserved_MB ELSE 0 END)
				/1024. AS numeric(29,1)) AS [Clustered Tables GB],
			SUM(CASE WHEN index_id NOT IN (0,1) THEN 1 ELSE 0 END) AS [NC Indexes],
			CAST(SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)
				/1024. AS numeric(29,1)) AS [NC Indexes GB],
			CASE WHEN SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)  &gt; 0 THEN
				CAST(SUM(CASE WHEN index_id IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)
					/ SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END) AS NUMERIC(29,1)) 
				ELSE 0 END AS [ratio table: NC Indexes],
			SUM(CASE WHEN index_id=0 THEN 1 ELSE 0 END) AS [Heaps],
			CAST(SUM(CASE WHEN index_id=0 THEN sz.total_reserved_MB ELSE 0 END)
				/1024. AS numeric(29,1)) AS [Heaps GB],
			SUM(CASE WHEN index_id IN (0,1) AND partition_key_column_name IS NOT NULL THEN 1 ELSE 0 END) AS [Partitioned Tables],
			SUM(CASE WHEN index_id NOT IN (0,1) AND  partition_key_column_name IS NOT NULL THEN 1 ELSE 0 END) AS [Partitioned NCs],
			CAST(SUM(CASE WHEN partition_key_column_name IS NOT NULL THEN sz.total_reserved_MB ELSE 0 END)/1024. AS numeric(29,1)) AS [Partitioned GB],
			SUM(CASE WHEN filter_definition &lt;&gt; '' THEN 1 ELSE 0 END) AS [Filtered Indexes],
			SUM(CASE WHEN is_indexed_view=1 THEN 1 ELSE 0 END) AS [Indexed Views],
			MAX(total_rows) AS [Max Row Count],
			CAST(MAX(CASE WHEN index_id IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)
				/1024. AS numeric(29,1)) AS [Max Table GB],
			CAST(MAX(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)
				/1024. AS numeric(29,1)) AS [Max NC Index GB],
			SUM(CASE WHEN index_id IN (0,1) AND sz.total_reserved_MB &gt; 1024 THEN 1 ELSE 0 END) AS [Count Tables &gt; 1GB],
			SUM(CASE WHEN index_id IN (0,1) AND sz.total_reserved_MB &gt; 10240 THEN 1 ELSE 0 END) AS [Count Tables &gt; 10GB],
			SUM(CASE WHEN index_id IN (0,1) AND sz.total_reserved_MB &gt; 102400 THEN 1 ELSE 0 END) AS [Count Tables &gt; 100GB],	
			SUM(CASE WHEN index_id NOT IN (0,1) AND sz.total_reserved_MB &gt; 1024 THEN 1 ELSE 0 END) AS [Count NCs &gt; 1GB],
			SUM(CASE WHEN index_id NOT IN (0,1) AND sz.total_reserved_MB &gt; 10240 THEN 1 ELSE 0 END) AS [Count NCs &gt; 10GB],
			SUM(CASE WHEN index_id NOT IN (0,1) AND sz.total_reserved_MB &gt; 102400 THEN 1 ELSE 0 END) AS [Count NCs &gt; 100GB],
			MIN(create_date) AS [Oldest Create Date],
			MAX(create_date) AS [Most Recent Create Date],
			MAX(modify_date) as [Most Recent Modify Date],
			1 as [Display Order]
		FROM #IndexSanity AS i
		--left join here so we don't lose disabled nc indexes
		LEFT JOIN #IndexSanitySize AS sz 
			ON i.index_sanity_id=sz.index_sanity_id 
		UNION ALL
		SELECT	N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + convert(nvarchar(16),getdate(),121)	,		
				N'sp_BlitzIndex(TM) v2.02 - Jan 30, 2014' ,   
				N'From Brent Ozar Unlimited(TM)' ,   
				N'http://BrentOzar.com/BlitzIndex' ,
				N'Thanks from the Brent Ozar Unlimited(TM) team.  We hope you found this tool useful, and if you need help relieving your SQL Server pains, email us at Help@BrentOzar.com.',
				NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
				NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
				NULL,0 as display_order
		ORDER BY [Display Order] ASC
		OPTION (RECOMPILE);
	   	
	END /* End @Mode=1 (summarize)*/
	ELSE IF @Mode=2 /*Index Detail*/
	BEGIN
		--This mode just spits out all the detail without filters.
		--This supports slicing AND dicing in Excel
		RAISERROR(N'@Mode=2, here''s the details on existing indexes.', 0,1) WITH NOWAIT;

		SELECT	database_name AS [Database Name], 
				[schema_name] AS [Schema Name], 
				[object_name] AS [Object Name], 
				ISNULL(index_name, '') AS [Index Name], 
				cast(index_id as VARCHAR(10))AS [Index ID],
				schema_object_indexid AS [Details: schema.table.index(indexid)], 
				CASE	WHEN index_id IN ( 1, 0 ) THEN 'TABLE'
					ELSE 'NonClustered'
					END AS [Object Type], 
				index_definition AS [Definition: [Property]] ColumnName {datatype maxbytes}],
				ISNULL(LTRIM(key_column_names_with_sort_order), '') AS [Key Column Names With Sort],
				ISNULL(count_key_columns, 0) AS [Count Key Columns],
				ISNULL(include_column_names, '') AS [Include Column Names], 
				ISNULL(count_included_columns,0) AS [Count Included Columns],
				ISNULL(secret_columns,'') AS [Secret Column Names], 
				ISNULL(count_secret_columns,0) AS [Count Secret Columns],
				ISNULL(partition_key_column_name, '') AS [Partition Key Column Name],
				ISNULL(filter_definition, '') AS [Filter Definition], 
				is_indexed_view AS [Is Indexed View], 
				is_primary_key AS [Is Primary Key],
				is_XML AS [Is XML],
				is_spatial AS [Is Spatial],
				is_NC_columnstore AS [Is NC Columnstore],
				is_CX_columnstore AS [Is CX Columnstore],
				is_disabled AS [Is Disabled], 
				is_hypothetical AS [Is Hypothetical],
				is_padded AS [Is Padded], 
				fill_factor AS [Fill Factor], 
				is_referenced_by_foreign_key AS [Is Reference by Foreign Key], 
				last_user_seek AS [Last User Seek], 
				last_user_scan AS [Last User Scan], 
				last_user_lookup AS [Last User Lookup],
				last_user_update AS [Last User Update], 
				total_reads AS [Total Reads], 
				user_updates AS [User Updates], 
				reads_per_write AS [Reads Per Write], 
				index_usage_summary AS [Index Usage], 
				sz.partition_count AS [Partition Count],
				sz.total_rows AS [Rows], 
				sz.total_reserved_MB AS [Reserved MB], 
				sz.total_reserved_LOB_MB AS [Reserved LOB MB], 
				sz.total_reserved_row_overflow_MB AS [Reserved Row Overflow MB],
				sz.index_size_summary AS [Index Size], 
				sz.total_row_lock_count AS [Row Lock Count],
				sz.total_row_lock_wait_count AS [Row Lock Wait Count],
				sz.total_row_lock_wait_in_ms AS [Row Lock Wait ms],
				sz.avg_row_lock_wait_in_ms AS [Avg Row Lock Wait ms],
				sz.total_page_lock_count AS [Page Lock Count],
				sz.total_page_lock_wait_count AS [Page Lock Wait Count],
				sz.total_page_lock_wait_in_ms AS [Page Lock Wait ms],
				sz.avg_page_lock_wait_in_ms AS [Avg Page Lock Wait ms],
				sz.total_index_lock_promotion_attempt_count AS [Lock Escalation Attempts],
				sz.total_index_lock_promotion_count AS [Lock Escalations],
				sz.data_compression_desc AS [Data Compression],
				i.create_date AS [Create Date],
				i.modify_date as [Modify Date],
				more_info AS [More Info],
				1 as [Display Order]
		FROM	#IndexSanity AS i --left join here so we don't lose disabled nc indexes
				LEFT JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
		UNION ALL
		SELECT 	N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + convert(nvarchar(16),getdate(),121)			
				N'sp_BlitzIndex(TM) v2.02 - Jan 30, 2014' ,   
				N'From Brent Ozar Unlimited(TM)' ,   
				N'http://BrentOzar.com/BlitzIndex' ,
				N'Thanks from the Brent Ozar Unlimited(TM) team.  We hope you found this tool useful, and if you need help relieving your SQL Server pains, email us at Help@BrentOzar.com.',
				NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
				NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
				NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
				NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
				NULL,NULL,NULL, NULL,NULL, NULL, NULL, NULL, NULL,NULL,NULL,
				0 as [Display Order]
		ORDER BY [Display Order] ASC, [Reserved MB] DESC
		OPTION (RECOMPILE);

	END /* End @Mode=2 (index detail)*/
	ELSE IF @Mode=3 /*Missing index Detail*/
	BEGIN
		SELECT 
			database_name AS [Database], 
			[schema_name] AS [Schema], 
			table_name AS [Table], 
			CAST(magic_benefit_number AS BIGINT)
				AS [Magic Benefit Number], 
			missing_index_details AS [Missing Index Details], 
			avg_total_user_cost AS [Avg Query Cost], 
			avg_user_impact AS [Est Index Improvement], 
			user_seeks AS [Seeks], 
			user_scans AS [Scans],
			unique_compiles AS [Compiles], 
			equality_columns AS [Equality Columns], 
			inequality_columns AS [Inequality Columns], 
			included_columns AS [Included Columns], 
			index_estimated_impact AS [Estimated Impact], 
			create_tsql AS [Create TSQL], 
			more_info AS [More Info],
			1 as [Display Order]
		FROM #MissingIndexes
		UNION ALL
		SELECT 				
			N'sp_BlitzIndex(TM) v2.02 - Jan 30, 2014' ,   
			N'From Brent Ozar Unlimited(TM)' ,   
			N'http://BrentOzar.com/BlitzIndex' ,
			100000000000,
			N'Thanks from the Brent Ozar Unlimited(TM) team. We hope you found this tool useful, and if you need help relieving your SQL Server pains, email us at Help@BrentOzar.com.',
			NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
			NULL, 0 as display_order
		ORDER BY [Display Order] ASC, [Magic Benefit Number] DESC

	END /* End @Mode=3 (index detail)*/
END
END TRY
BEGIN CATCH
		RAISERROR (N'Failure analyzing temp tables.', 0,1) WITH NOWAIT;

		SELECT	@msg = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE();

		RAISERROR (@msg, 
               @ErrorSeverity, 
               @ErrorState 
               );
		
		WHILE @@trancount &gt; 0 
			ROLLBACK;

		RETURN;
	END CATCH;
GO

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>DATA_and_LOG_file_Size</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>DATA_and_LOG_file_Size</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

-- Good to spot Log files that are growing to much

/////////////////////////////////////////////////////////////
Set NoCount On
--Check to see the temp table exists
IF EXISTS ( SELECT  Name
            FROM    tempdb..sysobjects
            Where   name like '#HoldforEachDB%' )
--If So Drop it
    DROP TABLE #HoldforEachDB_size
--Recreate it
CREATE TABLE #HoldforEachDB_size
    (
      [DatabaseName] [nvarchar](75) COLLATE SQL_Latin1_General_CP1_CI_AS
                                    NOT NULL,
      [Size] [decimal] NOT NULL,
      [Name] [nvarchar](75) COLLATE SQL_Latin1_General_CP1_CI_AS
                            NOT NULL,
      [Filename] [nvarchar](255) COLLATE SQL_Latin1_General_CP1_CI_AS
                                NOT NULL,

    )
ON  [PRIMARY]

IF EXISTS ( SELECT  name
            FROM    tempdb..sysobjects
            Where   name like '#fixed_drives%' )
--If So Drop it
    DROP TABLE #fixed_drives
--Recreate it
CREATE TABLE #fixed_drives
    (
      [Drive] [char](1) COLLATE SQL_Latin1_General_CP1_CI_AS
                        NOT NULL,
      [MBFree] [decimal] NOT NULL
    )
ON  [PRIMARY]
--Insert rows from sp_MSForEachDB into temp table
INSERT  INTO #HoldforEachDB_size
        EXEC sp_MSforeachdb 'Select ''?'' as DatabaseName, Case When [?]..sysfiles.size * 8 / 1024 = 0 Then 1 Else [?]..sysfiles.size * 8 / 1024 End
AS size,[?]..sysfiles.name,
[?]..sysfiles.filename From [?]..sysfiles'
--Select all rows from temp table (the temp table will auto delete when the connection is gone.

INSERT  INTO #fixed_drives
        EXEC xp_fixeddrives


Select  @@Servername
print '' ;
Select  rtrim(Cast(DatabaseName as varchar(75))) as DatabaseName,
        Drive,
        Filename,
        Cast(Size as int) AS Size,
        Cast(MBFree as varchar(10)) as MB_Free
from    #HoldforEachDB_size
        INNER JOIN #fixed_drives ON LEFT(#HoldforEachDB_size.Filename, 1) = #fixed_drives.Drive
GROUP BY DatabaseName,
        Drive,
        MBFree,
        Filename,
        Cast(Size as int)
ORDER BY Drive,
        Size Desc
print '' ;
Select  Drive as [Total Data Space Used |],
        Cast(Sum(Size) as varchar(10)) as [Total Size],
        Cast(MBFree as varchar(10)) as MB_Free
from    #HoldforEachDB_size
        INNER JOIN #fixed_drives ON LEFT(#HoldforEachDB_size.Filename, 1) = #fixed_drives.Drive
Group by Drive,
        MBFree
print '' ;
Select  count(Distinct rtrim(Cast(DatabaseName as varchar(75)))) as Database_Count
from    #HoldforEachDB_size 
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Find_Report_BlockingProcesses_and_numberOfLocksThatTheyAreHolding</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Find_Report_BlockingProcesses_and_numberOfLocksThatTheyAreHolding</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0000_214_UTILITY_ShowNumberOfBlockingProcesses_NumberOfLocksThatTheyAreHolding.sql

-- Look for High Lock Count in first column as a clue


--FROM: https://www.simple-talk.com/sql/database-administration/the-dba-as-detective-troubleshooting-locking-and-blocking/

--Some common lock types are:

--    RID – single row lock
--    KEY – a range of keys in an index
--    PAG – data or index page lock
--    EXT – Extent Lock
--    TAB – Table Lock
--    DB – Database Loc

--In addition to lock types that refer to resources or objects that can be locked, SQL Server has common lock modes:

--    S – Shared lock
--    U – Update Lock
--    X – Exclusive lock
--    IS – Intent shared
--    IU – Intent Update
--    IX – Intent Exclusive
--    BU – Bulk updat

use DB2_CRM
go


SET NOCOUNT ON

GO

 

-- Count the locks

 

IF EXISTS ( SELECT  Name

            FROM    tempdb..sysobjects

            WHERE   name LIKE '#Hold_sp_lock%' )

--If So Drop it

    DROP TABLE #Hold_sp_lock

GO

CREATE TABLE #Hold_sp_lock

    (

      spid INT,

      dbid INT,

      ObjId INT,

      IndId SMALLINT,

      Type VARCHAR(20),

      Resource VARCHAR(50),

      Mode VARCHAR(20),

      Status VARCHAR(20)

    )

INSERT  INTO #Hold_sp_lock

        EXEC sp_lock

SELECT  COUNT(spid) AS lock_count,

        SPID,

        Type,

        Cast(DB_NAME(DBID) as varchar(30)) as DBName,

        mode

FROM    #Hold_sp_lock

GROUP BY SPID,

        Type,

        DB_NAME(DBID),

        MODE

Order by lock_count desc,

        DBName,

        SPID,

        MODE

 

--Show any blocked or blocking processes

 

IF EXISTS ( SELECT  Name

            FROM    tempdb..sysobjects

            Where   name like '#Catch_SPID%' )

--If So Drop it

    DROP TABLE #Catch_SPID

GO

Create Table #Catch_SPID

    (

      bSPID int,

      BLK_Status char(10)

    )

GO

Insert  into #Catch_SPID

        Select Distinct

                SPID,

                'BLOCKED'

        from    master..sysprocesses

        where   blocked &lt;&gt; 0

        UNION

        Select Distinct

                blocked,

                'BLOCKING'

        from    master..sysprocesses

        where   blocked &lt;&gt; 0

 

DECLARE @tSPID int

DECLARE @blkst char(10)

SELECT TOP 1

        @tSPID = bSPID,

        @blkst = BLK_Status

from    #Catch_SPID

 

WHILE( @@ROWCOUNT &gt; 0 )

    BEGIN

 

        PRINT 'DBCC Results for SPID ' + Cast(@tSPID as varchar(5)) + '( '

            + rtrim(@blkst) + ' )'

        PRINT '-----------------------------------'

        PRINT ''

        DBCC INPUTBUFFER(@tSPID)

 

 

        SELECT TOP 1

                @tSPID = bSPID,

                @blkst = BLK_Status

        from    #Catch_SPID

        WHERE   bSPID &gt; @tSPID

        Order by bSPID

 

    END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>LIST_of_StoredProc_in_Database</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>LIST_of_StoredProc_in_Database</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://stackoverflow.com/questions/219434/query-to-list-all-stored-procedures

select * 
  from RiskMngt.information_schema.routines 
 where routine_type = 'PROCEDURE'
 
 /*
 If for some reason you had non-system stored procedures in the master database, 
 you could use the query (this will filter out MOST system stored procedures):
 */

select * 
  from master.information_schema.routines 
 where routine_type = 'PROCEDURE' 
   and Left(Routine_Name, 3) NOT IN ('sp_', 'xp_', 'ms_')
 
  --=============================================================================
   
SELECT name, type
FROM dbo.sysobjects
WHERE type IN (
    'P', -- stored procedures
    'FN', -- scalar functions 
    'IF', -- inline table-valued functions
    'TF' -- table-valued functions
)
ORDER BY type, name   

  --=============================================================================

--If you want to find the list of all SPs in all Databases you can use the below query :

    CREATE TABLE #ListOfSPs 
    (
        DBName varchar(100), 
        [OBJECT_ID] INT,
        SPName varchar(100)
    )

    EXEC sp_msforeachdb 'USE [?]; INSERT INTO #ListOfSPs Select ''?'', Object_Id, Name FROM sys.procedures'

    SELECT 
        * 
    FROM #ListOfSPs</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>sp_Blitz____script</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>sp_Blitz____script</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>IF OBJECT_ID('dbo.sp_Blitz') IS NULL
  EXEC ('CREATE PROCEDURE dbo.sp_Blitz AS RETURN 0;')
GO

ALTER PROCEDURE [dbo].[sp_Blitz]
    @Help TINYINT = 0 ,
    @CheckUserDatabaseObjects TINYINT = 1 ,
    @CheckProcedureCache TINYINT = 0 ,
    @OutputType VARCHAR(20) = 'TABLE' ,
    @OutputProcedureCache TINYINT = 0 ,
    @CheckProcedureCacheFilter VARCHAR(10) = NULL ,
    @CheckServerInfo TINYINT = 0 ,
    @SkipChecksServer NVARCHAR(256) = NULL ,
    @SkipChecksDatabase NVARCHAR(256) = NULL ,
    @SkipChecksSchema NVARCHAR(256) = NULL ,
    @SkipChecksTable NVARCHAR(256) = NULL ,
    @IgnorePrioritiesBelow INT = NULL ,
    @IgnorePrioritiesAbove INT = NULL ,
    @OutputServerName NVARCHAR(256) = NULL ,
    @OutputDatabaseName NVARCHAR(256) = NULL ,
    @OutputSchemaName NVARCHAR(256) = NULL ,
    @OutputTableName NVARCHAR(256) = NULL ,
    @OutputXMLasNVARCHAR TINYINT = 0 ,
    @EmailRecipients VARCHAR(MAX) = NULL ,
    @EmailProfile sysname = NULL ,
    @SummaryMode TINYINT = 0 ,
    @BringThePain TINYINT = 0 ,
    @VersionDate DATETIME = NULL OUTPUT
AS
    SET NOCOUNT ON;
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET @VersionDate = '20161210';
	SET @OutputType = UPPER(@OutputType);

	IF @Help = 1 PRINT '
	/*
	sp_Blitz from http://FirstResponderKit.org
	
	This script checks the health of your SQL Server and gives you a prioritized
	to-do list of the most urgent things you should consider fixing.

	To learn more, visit http://FirstResponderKit.org where you can download new
	versions for free, watch training videos on how it works, get more info on
	the findings, contribute your own code, and more.

	Known limitations of this version:
	 - Only Microsoft-supported versions of SQL Server. Sorry, 2005 and 2000.
	 - If a database name has a question mark in it, some tests will fail. Gotta
	   love that unsupported sp_MSforeachdb.
	 - If you have offline databases, sp_Blitz fails the first time you run it,
	   but does work the second time. (Hoo, boy, this will be fun to debug.)
      - @OutputServerName will output QueryPlans as NVARCHAR(MAX) since Microsoft
	    has refused to support XML columns in Linked Server queries. The bug is now
		16 years old! *~ \o/ ~*

	Unknown limitations of this version:
	 - None.  (If we knew them, they would be known. Duh.)

     Changes - for the full list of improvements and fixes in this version, see:
     https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/


	Parameter explanations:

	@CheckUserDatabaseObjects	1=review user databases for triggers, heaps, etc. Takes more time for more databases and objects.
	@CheckServerInfo			1=show server info like CPUs, memory, virtualization
	@CheckProcedureCache		1=top 20-50 resource-intensive cache plans and analyze them for common performance issues.
	@OutputProcedureCache		1=output the top 20-50 resource-intensive plans even if they did not trigger an alarm
	@CheckProcedureCacheFilter	''CPU'' | ''Reads'' | ''Duration'' | ''ExecCount''
	@OutputType					''TABLE''=table | ''COUNT''=row with number found | ''MARKDOWN''=bulleted list | ''SCHEMA''=version and field list | ''NONE'' = none
	@IgnorePrioritiesBelow		50=ignore priorities below 50
	@IgnorePrioritiesAbove		50=ignore priorities above 50
	For the rest of the parameters, see http://www.brentozar.com/blitz/documentation for details.

    MIT License

	Copyright (c) 2016 Brent Ozar Unlimited

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.


	*/'
	ELSE IF @OutputType = 'SCHEMA'
	BEGIN
		SELECT FieldList = '[Priority] TINYINT, [FindingsGroup] VARCHAR(50), [Finding] VARCHAR(200), [DatabaseName] NVARCHAR(128), [URL] VARCHAR(200), [Details] NVARCHAR(4000), [QueryPlan] NVARCHAR(MAX), [QueryPlanFiltered] NVARCHAR(MAX), [CheckID] INT'

	END
	ELSE /* IF @OutputType = 'SCHEMA' */
	BEGIN

		/*
		We start by creating #BlitzResults. It's a temp table that will store all of
		the results from our checks. Throughout the rest of this stored procedure,
		we're running a series of checks looking for dangerous things inside the SQL
		Server. When we find a problem, we insert rows into #BlitzResults. At the
		end, we return these results to the end user.

		#BlitzResults has a CheckID field, but there's no Check table. As we do
		checks, we insert data into this table, and we manually put in the CheckID.
		For a list of checks, visit http://FirstResponderKit.org.
		*/
		DECLARE @StringToExecute NVARCHAR(4000)
			,@curr_tracefilename NVARCHAR(500)
			,@base_tracefilename NVARCHAR(500)
			,@indx int
			,@query_result_separator CHAR(1)
			,@EmailSubject NVARCHAR(255)
			,@EmailBody NVARCHAR(MAX)
			,@EmailAttachmentFilename NVARCHAR(255)
			,@ProductVersion NVARCHAR(128)
			,@ProductVersionMajor DECIMAL(10,2)
			,@ProductVersionMinor DECIMAL(10,2)
			,@CurrentName NVARCHAR(128)
			,@CurrentDefaultValue NVARCHAR(200)
			,@CurrentCheckID INT
			,@CurrentPriority INT
			,@CurrentFinding VARCHAR(200)
			,@CurrentURL VARCHAR(200)
			,@CurrentDetails NVARCHAR(4000)
			,@MsSinceWaitsCleared DECIMAL(38,0)
			,@CpuMsSinceWaitsCleared DECIMAL(38,0)
			,@ResultText NVARCHAR(MAX)
			,@crlf NVARCHAR(2)
			,@Processors int
			,@NUMANodes int
			,@MinServerMemory bigint
			,@MaxServerMemory bigint
			,@ColumnStoreIndexesInUse bit;


		SET @crlf = NCHAR(13) + NCHAR(10);
		SET @ResultText = 'sp_Blitz Results: ' + @crlf;
		
		IF OBJECT_ID('tempdb..#BlitzResults') IS NOT NULL
			DROP TABLE #BlitzResults;
		CREATE TABLE #BlitzResults
			(
			  ID INT IDENTITY(1, 1) ,
			  CheckID INT ,
			  DatabaseName NVARCHAR(128) ,
			  Priority TINYINT ,
			  FindingsGroup VARCHAR(50) ,
			  Finding VARCHAR(200) ,
			  URL VARCHAR(200) ,
			  Details NVARCHAR(4000) ,
			  QueryPlan [XML] NULL ,
			  QueryPlanFiltered [NVARCHAR](MAX) NULL
			);

		IF OBJECT_ID('tempdb..#TemporaryDatabaseResults') IS NOT NULL
			DROP TABLE #TemporaryDatabaseResults;
		CREATE TABLE #TemporaryDatabaseResults
			(
			  DatabaseName NVARCHAR(128) ,
			  Finding NVARCHAR(128)
			);

		/*
		You can build your own table with a list of checks to skip. For example, you
		might have some databases that you don't care about, or some checks you don't
		want to run. Then, when you run sp_Blitz, you can specify these parameters:
		@SkipChecksDatabase = 'DBAtools',
		@SkipChecksSchema = 'dbo',
		@SkipChecksTable = 'BlitzChecksToSkip'
		Pass in the database, schema, and table that contains the list of checks you
		want to skip. This part of the code checks those parameters, gets the list,
		and then saves those in a temp table. As we run each check, we'll see if we
		need to skip it.

		Really anal-retentive users will note that the @SkipChecksServer parameter is
		not used. YET. We added that parameter in so that we could avoid changing the
		stored proc's surface area (interface) later.
		*/
		IF OBJECT_ID('tempdb..#SkipChecks') IS NOT NULL
			DROP TABLE #SkipChecks;
		CREATE TABLE #SkipChecks
			(
			  DatabaseName NVARCHAR(128) ,
			  CheckID INT ,
			  ServerName NVARCHAR(128)
			);
		CREATE CLUSTERED INDEX IX_CheckID_DatabaseName ON #SkipChecks(CheckID, DatabaseName);

		IF @SkipChecksTable IS NOT NULL
			AND @SkipChecksSchema IS NOT NULL
			AND @SkipChecksDatabase IS NOT NULL
			BEGIN
				SET @StringToExecute = 'INSERT INTO #SkipChecks(DatabaseName, CheckID, ServerName )
				SELECT DISTINCT DatabaseName, CheckID, ServerName
				FROM ' + QUOTENAME(@SkipChecksDatabase) + '.' + QUOTENAME(@SkipChecksSchema) + '.' + QUOTENAME(@SkipChecksTable)
					+ ' WHERE ServerName IS NULL OR ServerName = SERVERPROPERTY(''ServerName'');'
				EXEC(@StringToExecute)
			END

		IF NOT EXISTS ( SELECT  1
							FROM    #SkipChecks
							WHERE   DatabaseName IS NULL AND CheckID = 106 )
							AND (select convert(int,value_in_use) from sys.configurations where name = 'default trace enabled' ) = 1
			BEGIN
					select @curr_tracefilename = [path] from sys.traces where is_default = 1 ;
					set @curr_tracefilename = reverse(@curr_tracefilename);
					select @indx = patindex('%\%', @curr_tracefilename) ;
					set @curr_tracefilename = reverse(@curr_tracefilename) ;
					set @base_tracefilename = left( @curr_tracefilename,len(@curr_tracefilename) - @indx) + '\log.trc' ;
			END

		/* If the server has any databases on Antiques Roadshow, skip the checks that would break due to CTEs. */
		IF @CheckUserDatabaseObjects = 1 AND EXISTS(SELECT * FROM sys.databases WHERE compatibility_level &lt; 90)
		BEGIN
			SET @CheckUserDatabaseObjects = 0;
			PRINT 'Databases with compatibility level &lt; 90 found, so setting @CheckUserDatabaseObjects = 0.';
			PRINT 'The database-level checks rely on CTEs, which are not supported in SQL 2000 compat level databases.';
			PRINT 'Get with the cool kids and switch to a current compatibility level, Grandpa. To find the problems, run:';
			PRINT 'SELECT * FROM sys.databases WHERE compatibility_level &lt; 90;';
		END


			/* If the server is Amazon RDS, skip checks that it doesn't allow */
		IF LEFT(CAST(SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS VARCHAR(8000)), 8) = 'EC2AMAZ-'
		   AND LEFT(CAST(SERVERPROPERTY('MachineName') AS VARCHAR(8000)), 8) = 'EC2AMAZ-'
		   AND LEFT(CAST(SERVERPROPERTY('ServerName') AS VARCHAR(8000)), 8) = 'EC2AMAZ-'
			BEGIN
						INSERT INTO #SkipChecks (CheckID) VALUES (6);
						INSERT INTO #SkipChecks (CheckID) VALUES (29);
						INSERT INTO #SkipChecks (CheckID) VALUES (30);
						INSERT INTO #SkipChecks (CheckID) VALUES (31);
						INSERT INTO #SkipChecks (CheckID) VALUES (40); /* TempDB only has one data file */
						INSERT INTO #SkipChecks (CheckID) VALUES (57);
						INSERT INTO #SkipChecks (CheckID) VALUES (59);
						INSERT INTO #SkipChecks (CheckID) VALUES (61);
						INSERT INTO #SkipChecks (CheckID) VALUES (62);
						INSERT INTO #SkipChecks (CheckID) VALUES (68);
						INSERT INTO #SkipChecks (CheckID) VALUES (69);
						INSERT INTO #SkipChecks (CheckID) VALUES (73);
						INSERT INTO #SkipChecks (CheckID) VALUES (79);
						INSERT INTO #SkipChecks (CheckID) VALUES (92);
						INSERT INTO #SkipChecks (CheckID) VALUES (94);
						INSERT INTO #SkipChecks (CheckID) VALUES (96);
						INSERT INTO #SkipChecks (CheckID) VALUES (98);
						INSERT INTO #SkipChecks (CheckID) VALUES (100); /* Remote DAC disabled */
						INSERT INTO #SkipChecks (CheckID) VALUES (123);
						INSERT INTO #SkipChecks (CheckID) VALUES (177);
						INSERT INTO #SkipChecks (CheckID) VALUES (180); /* 180/181 are maintenance plans */
						INSERT INTO #SkipChecks (CheckID) VALUES (181);
			END /* Amazon RDS skipped checks */



		/*
		That's the end of the SkipChecks stuff.
		The next several tables are used by various checks later.
		*/
		IF OBJECT_ID('tempdb..#ConfigurationDefaults') IS NOT NULL
			DROP TABLE #ConfigurationDefaults;
		CREATE TABLE #ConfigurationDefaults
			(
			  name NVARCHAR(128) ,
			  DefaultValue BIGINT,
			  CheckID INT
			);

        IF OBJECT_ID ('tempdb..#Recompile') IS NOT NULL 
            DROP TABLE #Recompile; 
        CREATE TABLE #Recompile( 
            DBName varchar(200), 
            ProcName varchar(300), 
            RecompileFlag varchar(1),
            SPSchema varchar(50)
        );

		IF OBJECT_ID('tempdb..#DatabaseDefaults') IS NOT NULL
			DROP TABLE #DatabaseDefaults;
		CREATE TABLE #DatabaseDefaults
			(
				name NVARCHAR(128) ,
				DefaultValue NVARCHAR(200),
				CheckID INT,
		        Priority INT,
		        Finding VARCHAR(200),
		        URL VARCHAR(200),
		        Details NVARCHAR(4000)
			);

		IF OBJECT_ID('tempdb..#DatabaseScopedConfigurationDefaults') IS NOT NULL
			DROP TABLE #DatabaseScopedConfigurationDefaults;
		CREATE TABLE #DatabaseScopedConfigurationDefaults
			(ID INT IDENTITY(1,1), configuration_id INT, [name] NVARCHAR(60), default_value sql_variant, default_value_for_secondary sql_variant, CheckID INT, );



		IF OBJECT_ID('tempdb..#DBCCs') IS NOT NULL
			DROP TABLE #DBCCs;
		CREATE TABLE #DBCCs
			(
			  ID INT IDENTITY(1, 1)
					 PRIMARY KEY ,
			  ParentObject VARCHAR(255) ,
			  Object VARCHAR(255) ,
			  Field VARCHAR(255) ,
			  Value VARCHAR(255) ,
			  DbName NVARCHAR(128) NULL
			)


		IF OBJECT_ID('tempdb..#LogInfo2012') IS NOT NULL
			DROP TABLE #LogInfo2012;
		CREATE TABLE #LogInfo2012
			(
			  recoveryunitid INT ,
			  FileID SMALLINT ,
			  FileSize BIGINT ,
			  StartOffset BIGINT ,
			  FSeqNo BIGINT ,
			  [Status] TINYINT ,
			  Parity TINYINT ,
			  CreateLSN NUMERIC(38)
			);

		IF OBJECT_ID('tempdb..#LogInfo') IS NOT NULL
			DROP TABLE #LogInfo;
		CREATE TABLE #LogInfo
			(
			  FileID SMALLINT ,
			  FileSize BIGINT ,
			  StartOffset BIGINT ,
			  FSeqNo BIGINT ,
			  [Status] TINYINT ,
			  Parity TINYINT ,
			  CreateLSN NUMERIC(38)
			);

		IF OBJECT_ID('tempdb..#partdb') IS NOT NULL
			DROP TABLE #partdb;
		CREATE TABLE #partdb
			(
			  dbname NVARCHAR(128) ,
			  objectname NVARCHAR(200) ,
			  type_desc NVARCHAR(128)
			)

		IF OBJECT_ID('tempdb..#TraceStatus') IS NOT NULL
			DROP TABLE #TraceStatus;
		CREATE TABLE #TraceStatus
			(
			  TraceFlag VARCHAR(10) ,
			  status BIT ,
			  Global BIT ,
			  Session BIT
			);

		IF OBJECT_ID('tempdb..#driveInfo') IS NOT NULL
			DROP TABLE #driveInfo;
		CREATE TABLE #driveInfo
			(
			  drive NVARCHAR ,
			  SIZE DECIMAL(18, 2)
			)


		IF OBJECT_ID('tempdb..#dm_exec_query_stats') IS NOT NULL
			DROP TABLE #dm_exec_query_stats;
		CREATE TABLE #dm_exec_query_stats
			(
			  [id] [int] NOT NULL
						 IDENTITY(1, 1) ,
			  [sql_handle] [varbinary](64) NOT NULL ,
			  [statement_start_offset] [int] NOT NULL ,
			  [statement_end_offset] [int] NOT NULL ,
			  [plan_generation_num] [bigint] NOT NULL ,
			  [plan_handle] [varbinary](64) NOT NULL ,
			  [creation_time] [datetime] NOT NULL ,
			  [last_execution_time] [datetime] NOT NULL ,
			  [execution_count] [bigint] NOT NULL ,
			  [total_worker_time] [bigint] NOT NULL ,
			  [last_worker_time] [bigint] NOT NULL ,
			  [min_worker_time] [bigint] NOT NULL ,
			  [max_worker_time] [bigint] NOT NULL ,
			  [total_physical_reads] [bigint] NOT NULL ,
			  [last_physical_reads] [bigint] NOT NULL ,
			  [min_physical_reads] [bigint] NOT NULL ,
			  [max_physical_reads] [bigint] NOT NULL ,
			  [total_logical_writes] [bigint] NOT NULL ,
			  [last_logical_writes] [bigint] NOT NULL ,
			  [min_logical_writes] [bigint] NOT NULL ,
			  [max_logical_writes] [bigint] NOT NULL ,
			  [total_logical_reads] [bigint] NOT NULL ,
			  [last_logical_reads] [bigint] NOT NULL ,
			  [min_logical_reads] [bigint] NOT NULL ,
			  [max_logical_reads] [bigint] NOT NULL ,
			  [total_clr_time] [bigint] NOT NULL ,
			  [last_clr_time] [bigint] NOT NULL ,
			  [min_clr_time] [bigint] NOT NULL ,
			  [max_clr_time] [bigint] NOT NULL ,
			  [total_elapsed_time] [bigint] NOT NULL ,
			  [last_elapsed_time] [bigint] NOT NULL ,
			  [min_elapsed_time] [bigint] NOT NULL ,
			  [max_elapsed_time] [bigint] NOT NULL ,
			  [query_hash] [binary](8) NULL ,
			  [query_plan_hash] [binary](8) NULL ,
			  [query_plan] [xml] NULL ,
			  [query_plan_filtered] [nvarchar](MAX) NULL ,
			  [text] [nvarchar](MAX) COLLATE SQL_Latin1_General_CP1_CI_AS
									 NULL ,
			  [text_filtered] [nvarchar](MAX) COLLATE SQL_Latin1_General_CP1_CI_AS
											  NULL
			)

		IF OBJECT_ID('tempdb..#ErrorLog') IS NOT NULL
			DROP TABLE #ErrorLog;
		CREATE TABLE #ErrorLog
			(
			  LogDate DATETIME ,
			  ProcessInfo NVARCHAR(20) ,
			  [Text] NVARCHAR(1000) 
			);

		IF OBJECT_ID('tempdb..#IgnorableWaits') IS NOT NULL
			DROP TABLE #IgnorableWaits;
		CREATE TABLE #IgnorableWaits (wait_type NVARCHAR(60));
		INSERT INTO #IgnorableWaits VALUES ('BROKER_EVENTHANDLER');
		INSERT INTO #IgnorableWaits VALUES ('BROKER_RECEIVE_WAITFOR');
		INSERT INTO #IgnorableWaits VALUES ('BROKER_TASK_STOP');
		INSERT INTO #IgnorableWaits VALUES ('BROKER_TO_FLUSH');
		INSERT INTO #IgnorableWaits VALUES ('BROKER_TRANSMITTER');
		INSERT INTO #IgnorableWaits VALUES ('CHECKPOINT_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('CLR_AUTO_EVENT');
		INSERT INTO #IgnorableWaits VALUES ('CLR_MANUAL_EVENT');
		INSERT INTO #IgnorableWaits VALUES ('CLR_SEMAPHORE');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRROR_DBM_EVENT');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRROR_DBM_MUTEX');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRROR_EVENTS_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRROR_WORKER_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('DBMIRRORING_CMD');
		INSERT INTO #IgnorableWaits VALUES ('DIRTY_PAGE_POLL');
		INSERT INTO #IgnorableWaits VALUES ('DISPATCHER_QUEUE_SEMAPHORE');
		INSERT INTO #IgnorableWaits VALUES ('FT_IFTS_SCHEDULER_IDLE_WAIT');
		INSERT INTO #IgnorableWaits VALUES ('FT_IFTSHC_MUTEX');
		INSERT INTO #IgnorableWaits VALUES ('HADR_CLUSAPI_CALL');
		INSERT INTO #IgnorableWaits VALUES ('HADR_FILESTREAM_IOMGR_IOCOMPLETION');
		INSERT INTO #IgnorableWaits VALUES ('HADR_LOGCAPTURE_WAIT');
		INSERT INTO #IgnorableWaits VALUES ('HADR_NOTIFICATION_DEQUEUE');
		INSERT INTO #IgnorableWaits VALUES ('HADR_TIMER_TASK');
		INSERT INTO #IgnorableWaits VALUES ('HADR_WORK_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('LAZYWRITER_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('LOGMGR_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('ONDEMAND_TASK_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('PREEMPTIVE_HADR_LEASE_MECHANISM');
		INSERT INTO #IgnorableWaits VALUES ('PREEMPTIVE_SP_SERVER_DIAGNOSTICS');
		INSERT INTO #IgnorableWaits VALUES ('QDS_ASYNC_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('QDS_PERSIST_TASK_MAIN_LOOP_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('QDS_SHUTDOWN_QUEUE');
		INSERT INTO #IgnorableWaits VALUES ('REDO_THREAD_PENDING_WORK');
		INSERT INTO #IgnorableWaits VALUES ('REQUEST_FOR_DEADLOCK_SEARCH');
		INSERT INTO #IgnorableWaits VALUES ('SLEEP_SYSTEMTASK');
		INSERT INTO #IgnorableWaits VALUES ('SLEEP_TASK');
		INSERT INTO #IgnorableWaits VALUES ('SP_SERVER_DIAGNOSTICS_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('SQLTRACE_BUFFER_FLUSH');
		INSERT INTO #IgnorableWaits VALUES ('SQLTRACE_INCREMENTAL_FLUSH_SLEEP');
		INSERT INTO #IgnorableWaits VALUES ('UCS_SESSION_REGISTRATION');
		INSERT INTO #IgnorableWaits VALUES ('WAIT_XTP_OFFLINE_CKPT_NEW_LOG');
		INSERT INTO #IgnorableWaits VALUES ('WAITFOR');
		INSERT INTO #IgnorableWaits VALUES ('XE_DISPATCHER_WAIT');
		INSERT INTO #IgnorableWaits VALUES ('XE_LIVE_TARGET_TVF');
		INSERT INTO #IgnorableWaits VALUES ('XE_TIMER_EVENT');


        /* Used for the default trace checks. */
        DECLARE @TracePath NVARCHAR(256);
        SELECT @TracePath=CAST(value as NVARCHAR(256))
            FROM sys.fn_trace_getinfo(1)
            WHERE traceid=1 AND property=2;
        
        SELECT @MsSinceWaitsCleared = DATEDIFF(MINUTE, create_date, CURRENT_TIMESTAMP) * 60000.0
            FROM    sys.databases
            WHERE   name='tempdb';

		/* Have they cleared wait stats? Using a 10% fudge factor */
		IF @MsSinceWaitsCleared * .9 &gt; (SELECT wait_time_ms FROM sys.dm_os_wait_stats WHERE wait_type = 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP')
			BEGIN
				SET @MsSinceWaitsCleared = (SELECT wait_time_ms FROM sys.dm_os_wait_stats WHERE wait_type = 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP')
				INSERT  INTO #BlitzResults
						( CheckID ,
							Priority ,
							FindingsGroup ,
							Finding ,
							URL ,
							Details
						)
					VALUES( 185,
								240,
								'Wait Stats',
								'Wait Stats Have Been Cleared',
								'http://BrentOzar.com/go/waits',
								'Someone ran DBCC SQLPERF to clear sys.dm_os_wait_stats at approximately: ' + CONVERT(NVARCHAR(100), DATEADD(ms, (-1 * @MsSinceWaitsCleared), GETDATE()), 120))
			END

		/* @CpuMsSinceWaitsCleared is used for waits stats calculations */
		SELECT @CpuMsSinceWaitsCleared = @MsSinceWaitsCleared * scheduler_count
			FROM sys.dm_os_sys_info;


		/* If we're outputting CSV or Markdown, don't bother checking the plan cache because we cannot export plans. */
		IF @OutputType = 'CSV' OR @OutputType = 'MARKDOWN'
			SET @CheckProcedureCache = 0;

		/* If we're posting a question on Stack, include background info on the server */
		IF @OutputType = 'MARKDOWN'
			SET @CheckServerInfo = 1;


		/* Only run CheckUserDatabaseObjects if there are less than 50 databases. */
		IF @BringThePain = 0 AND 50 &lt;= (SELECT COUNT(*) FROM sys.databases) AND @CheckUserDatabaseObjects = 1
			BEGIN
			SET @CheckUserDatabaseObjects = 0;
			PRINT 'Running sp_Blitz @CheckUserDatabaseObjects = 1 on a server with 50+ databases may cause temporary insanity for the server and/or user.';
			PRINT 'If you''re sure you want to do this, run again with the parameter @BringThePain = 1.';
			END

		/* Sanitize our inputs */
		SELECT
			@OutputServerName = QUOTENAME(@OutputServerName),
			@OutputDatabaseName = QUOTENAME(@OutputDatabaseName),
			@OutputSchemaName = QUOTENAME(@OutputSchemaName),
			@OutputTableName = QUOTENAME(@OutputTableName)

		/* Get the major and minor build numbers */
		SET @ProductVersion = CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128));
		SELECT @ProductVersionMajor = SUBSTRING(@ProductVersion, 1,CHARINDEX('.', @ProductVersion) + 1 ),
			@ProductVersionMinor = PARSENAME(CONVERT(varchar(32), @ProductVersion), 2)
		
		/*
		Whew! we're finally done with the setup, and we can start doing checks.
		First, let's make sure we're actually supposed to do checks on this server.
		The user could have passed in a SkipChecks table that specified to skip ALL
		checks on this server, so let's check for that:
		*/
		IF ( ( SERVERPROPERTY('ServerName') NOT IN ( SELECT ServerName
													 FROM   #SkipChecks
													 WHERE  DatabaseName IS NULL
															AND CheckID IS NULL ) )
			 OR ( @SkipChecksTable IS NULL )
		   )
			BEGIN

				/*
				Our very first check! We'll put more comments in this one just to
				explain exactly how it works. First, we check to see if we're
				supposed to skip CheckID 1 (that's the check we're working on.)
				*/
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 1 )
					BEGIN

						/*
						Below, we check master.sys.databases looking for databases
						that haven't had a backup in the last week. If we find any,
						we insert them into #BlitzResults, the temp table that
						tracks our server's problems. Note that if the check does
						NOT find any problems, we don't save that. We're only
						saving the problems, not the successful checks.
						*/
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  1 AS CheckID ,
										d.[name] AS DatabaseName ,
										1 AS Priority ,
										'Backup' AS FindingsGroup ,
										'Backups Not Performed Recently' AS Finding ,
										'http://BrentOzar.com/go/nobak' AS URL ,
										'Last backed up: '
										+ COALESCE(CAST(MAX(b.backup_finish_date) AS VARCHAR(25)),'never') AS Details
								FROM    master.sys.databases d
										LEFT OUTER JOIN msdb.dbo.backupset b ON d.name COLLATE SQL_Latin1_General_CP1_CI_AS = b.database_name COLLATE SQL_Latin1_General_CP1_CI_AS
																  AND b.type = 'D'
																  AND b.server_name = SERVERPROPERTY('ServerName') /*Backupset ran on current server */
								WHERE   d.database_id &lt;&gt; 2  /* Bonus points if you know what that means */
										AND d.state NOT IN(1, 6, 10) /* Not currently offline or restoring, like log shipping databases */
										AND d.is_in_standby = 0 /* Not a log shipping target database */
										AND d.source_database_id IS NULL /* Excludes database snapshots */
										AND d.name NOT IN ( SELECT DISTINCT
																  DatabaseName
															FROM  #SkipChecks
															WHERE CheckID IS NULL )
										/*
										The above NOT IN filters out the databases we're not supposed to check.
										*/
								GROUP BY d.name
								HAVING  MAX(b.backup_finish_date) &lt;= DATEADD(dd,
																  -7, GETDATE())
                                        OR MAX(b.backup_finish_date) IS NULL;
						/*
						And there you have it. The rest of this stored procedure works the same
						way: it asks:
						- Should I skip this check?
						- If not, do I find problems?
						- Insert the results into #BlitzResults
						*/

					END

				/*
				And that's the end of CheckID #1.

				CheckID #2 is a little simpler because it only involves one query, and it's
				more typical for queries that people contribute. But keep reading, because
				the next check gets more complex again.
				*/

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 2 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
										SELECT DISTINCT
										2 AS CheckID ,
										d.name AS DatabaseName ,
										1 AS Priority ,
										'Backup' AS FindingsGroup ,
										'Full Recovery Mode w/o Log Backups' AS Finding ,
										'http://BrentOzar.com/go/biglogs' AS URL ,
										( 'The ' + CAST(CAST((SELECT ((SUM([mf].[size]) * 8.) / 1024.) FROM sys.[master_files] AS [mf] WHERE [mf].[database_id] = d.[database_id] AND [mf].[type_desc] = 'LOG') AS DECIMAL(18,2)) AS VARCHAR) + 'MB log file has not been backed up in the last week.' ) AS Details
								FROM    master.sys.databases d
								WHERE   d.recovery_model IN ( 1, 2 )
										AND d.database_id NOT IN ( 2, 3 )
										AND d.source_database_id IS NULL
										AND d.state NOT IN(1, 6, 10) /* Not currently offline or restoring, like log shipping databases */
										AND d.is_in_standby = 0 /* Not a log shipping target database */
										AND d.source_database_id IS NULL /* Excludes database snapshots */
										AND d.name NOT IN ( SELECT DISTINCT
																  DatabaseName
															FROM  #SkipChecks
															WHERE CheckID IS NULL )
										AND NOT EXISTS ( SELECT *
														 FROM   msdb.dbo.backupset b
														 WHERE  d.name COLLATE SQL_Latin1_General_CP1_CI_AS = b.database_name COLLATE SQL_Latin1_General_CP1_CI_AS
																AND b.type = 'L'
																AND b.backup_finish_date &gt;= DATEADD(dd,
																  -7, GETDATE()) ); 
					END


				/*
				Next up, we've got CheckID 8. (These don't have to go in order.) This one
				won't work on SQL Server 2005 because it relies on a new DMV that didn't
				exist prior to SQL Server 2008. This means we have to check the SQL Server
				version first, then build a dynamic string with the query we want to run:
				*/

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 8 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID, Priority,
							FindingsGroup,
							Finding, URL,
							Details)
					  SELECT 8 AS CheckID,
					  230 AS Priority,
					  ''Security'' AS FindingsGroup,
					  ''Server Audits Running'' AS Finding,
					  ''http://BrentOzar.com/go/audits'' AS URL,
					  (''SQL Server built-in audit functionality is being used by server audit: '' + [name]) AS Details FROM sys.dm_server_audit_status'
								EXECUTE(@StringToExecute)
							END;
					END

				/*
				But what if you need to run a query in every individual database?
				Hop down to the @CheckUserDatabaseObjects section.
                
				And that's the basic idea! You can read through the rest of the
				checks if you like - some more exciting stuff happens closer to the
				end of the stored proc, where we start doing things like checking
				the plan cache, but those aren't as cleanly commented.

				If you'd like to contribute your own check, use one of the check
				formats shown above and email it to Help@BrentOzar.com. You don't
				have to pick a CheckID or a link - we'll take care of that when we
				test and publish the code. Thanks!
				*/


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 93 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT
										93 AS CheckID ,
										1 AS Priority ,
										'Backup' AS FindingsGroup ,
										'Backing Up to Same Drive Where Databases Reside' AS Finding ,
										'http://BrentOzar.com/go/backup' AS URL ,
										CAST(COUNT(1) AS VARCHAR(50)) + ' backups done on drive '
										+ UPPER(LEFT(bmf.physical_device_name, 3))
										+ ' in the last two weeks, where database files also live. This represents a serious risk if that array fails.' Details
								FROM    msdb.dbo.backupmediafamily AS bmf
										INNER JOIN msdb.dbo.backupset AS bs ON bmf.media_set_id = bs.media_set_id
																  AND bs.backup_start_date &gt;= ( DATEADD(dd,
																  -14, GETDATE()) )
										/* Filter out databases that were recently restored: */
										LEFT OUTER JOIN msdb.dbo.restorehistory rh ON bs.database_name = rh.destination_database_name AND rh.restore_date &gt; DATEADD(dd, -14, GETDATE())
								WHERE   UPPER(LEFT(bmf.physical_device_name COLLATE SQL_Latin1_General_CP1_CI_AS, 3)) IN (
										SELECT DISTINCT
												UPPER(LEFT(mf.physical_name COLLATE SQL_Latin1_General_CP1_CI_AS, 3))
										FROM    sys.master_files AS mf )
										AND rh.destination_database_name IS NULL
								GROUP BY UPPER(LEFT(bmf.physical_device_name, 3))
					END


					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 119 )
						AND EXISTS ( SELECT *
									 FROM   sys.all_objects o
									 WHERE  o.name = 'dm_database_encryption_keys' )
						BEGIN
							SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, DatabaseName, URL, Details)
								SELECT 119 AS CheckID,
								1 AS Priority,
								''Backup'' AS FindingsGroup,
								''TDE Certificate Not Backed Up Recently'' AS Finding,
								db_name(dek.database_id) AS DatabaseName,
								''http://BrentOzar.com/go/tde'' AS URL,
								''The certificate '' + c.name + '' is used to encrypt database '' + db_name(dek.database_id) + ''. Last backup date: '' + COALESCE(CAST(c.pvt_key_last_backup_date AS VARCHAR(100)), ''Never'') AS Details
								FROM sys.certificates c INNER JOIN sys.dm_database_encryption_keys dek ON c.thumbprint = dek.encryptor_thumbprint
								WHERE pvt_key_last_backup_date IS NULL OR pvt_key_last_backup_date &lt;= DATEADD(dd, -30, GETDATE())';
							EXECUTE(@StringToExecute);
						END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 3 )
					BEGIN
						IF DATEADD(dd, -60, GETDATE()) &gt; (SELECT TOP 1 backup_start_date FROM msdb.dbo.backupset ORDER BY 1)
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT TOP 1
										3 AS CheckID ,
										'msdb' ,
										200 AS Priority ,
										'Backup' AS FindingsGroup ,
										'MSDB Backup History Not Purged' AS Finding ,
										'http://BrentOzar.com/go/history' AS URL ,
										( 'Database backup history retained back to '
										  + CAST(bs.backup_start_date AS VARCHAR(20)) ) AS Details
								FROM    msdb.dbo.backupset bs
								ORDER BY backup_set_id ASC;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 186 )
					BEGIN
						IF DATEADD(dd, -2, GETDATE()) &lt; (SELECT TOP 1 backup_start_date FROM msdb.dbo.backupset ORDER BY 1)
							INSERT  INTO #BlitzResults
									( CheckID ,
									  DatabaseName ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT TOP 1
											186 AS CheckID ,
											'msdb' ,
											200 AS Priority ,
											'Backup' AS FindingsGroup ,
											'MSDB Backup History Purged Too Frequently' AS Finding ,
											'http://BrentOzar.com/go/history' AS URL ,
											( 'Database backup history only retained back to '
											  + CAST(bs.backup_start_date AS VARCHAR(20)) ) AS Details
									FROM    msdb.dbo.backupset bs
									ORDER BY backup_set_id ASC;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 178 )
					AND EXISTS (SELECT *
									FROM msdb.dbo.backupset bs
									WHERE bs.type = 'D'
									AND bs.backup_size &gt;= 50000000000 /* At least 50GB */
									AND DATEDIFF(SECOND, bs.backup_start_date, bs.backup_finish_date) &lt;= 60 /* Backup took less than 60 seconds */
									AND bs.backup_finish_date &gt;= DATEADD(DAY, -14, GETDATE()) /* In the last 2 weeks */)
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT 178 AS CheckID ,
										200 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Snapshot Backups Occurring' AS Finding ,
										'http://BrentOzar.com/go/snaps' AS URL ,
										( CAST(COUNT(*) AS VARCHAR(20)) + ' snapshot-looking backups have occurred in the last two weeks, indicating that IO may be freezing up.') AS Details
								FROM msdb.dbo.backupset bs
								WHERE bs.type = 'D'
								AND bs.backup_size &gt;= 50000000000 /* At least 50GB */
								AND DATEDIFF(SECOND, bs.backup_start_date, bs.backup_finish_date) &lt;= 60 /* Backup took less than 60 seconds */
								AND bs.backup_finish_date &gt;= DATEADD(DAY, -14, GETDATE()) /* In the last 2 weeks */
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 4 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  4 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Sysadmins' AS Finding ,
										'http://BrentOzar.com/go/sa' AS URL ,
										( 'Login [' + l.name
										  + '] is a sysadmin - meaning they can do absolutely anything in SQL Server, including dropping databases or hiding their tracks.' ) AS Details
								FROM    master.sys.syslogins l
								WHERE   l.sysadmin = 1
										AND l.name &lt;&gt; SUSER_SNAME(0x01)
										AND l.denylogin = 0
										AND l.name NOT LIKE 'NT SERVICE\%'
										AND l.name &lt;&gt; 'l_certSignSmDetach'; /* Added in SQL 2016 */
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 5 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  5 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Security Admins' AS Finding ,
										'http://BrentOzar.com/go/sa' AS URL ,
										( 'Login [' + l.name
										  + '] is a security admin - meaning they can give themselves permission to do absolutely anything in SQL Server, including dropping databases or hiding their tracks.' ) AS Details
								FROM    master.sys.syslogins l
								WHERE   l.securityadmin = 1
										AND l.name &lt;&gt; SUSER_SNAME(0x01)
										AND l.denylogin = 0;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 104 )
					BEGIN
						INSERT  INTO #BlitzResults
								( [CheckID] ,
								  [Priority] ,
								  [FindingsGroup] ,
								  [Finding] ,
								  [URL] ,
								  [Details]
								)
								SELECT  104 AS [CheckID] ,
										230 AS [Priority] ,
										'Security' AS [FindingsGroup] ,
										'Login Can Control Server' AS [Finding] ,
										'http://BrentOzar.com/go/sa' AS [URL] ,
										'Login [' + pri.[name]
										+ '] has the CONTROL SERVER permission - meaning they can do absolutely anything in SQL Server, including dropping databases or hiding their tracks.' AS [Details]
								FROM    sys.server_principals AS pri
								WHERE   pri.[principal_id] IN (
										SELECT  p.[grantee_principal_id]
										FROM    sys.server_permissions AS p
										WHERE   p.[state] IN ( 'G', 'W' )
												AND p.[class] = 100
												AND p.[type] = 'CL' )
										AND pri.[name] NOT LIKE '##%##'
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 6 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  6 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Jobs Owned By Users' AS Finding ,
										'http://BrentOzar.com/go/owners' AS URL ,
										( 'Job [' + j.name + '] is owned by ['
										  + SUSER_SNAME(j.owner_sid)
										  + '] - meaning if their login is disabled or not available due to Active Directory problems, the job will stop working.' ) AS Details
								FROM    msdb.dbo.sysjobs j
								WHERE   j.enabled = 1
										AND SUSER_SNAME(j.owner_sid) &lt;&gt; SUSER_SNAME(0x01);
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 7 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  7 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Stored Procedure Runs at Startup' AS Finding ,
										'http://BrentOzar.com/go/startup' AS URL ,
										( 'Stored procedure [master].['
										  + r.SPECIFIC_SCHEMA + '].['
										  + r.SPECIFIC_NAME
										  + '] runs automatically when SQL Server starts up.  Make sure you know exactly what this stored procedure is doing, because it could pose a security risk.' ) AS Details
								FROM    master.INFORMATION_SCHEMA.ROUTINES r
								WHERE   OBJECTPROPERTY(OBJECT_ID(ROUTINE_NAME),
													   'ExecIsStartup') = 1;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 10 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 10 AS CheckID,
					  100 AS Priority,
					  ''Performance'' AS FindingsGroup,
					  ''Resource Governor Enabled'' AS Finding,
					  ''http://BrentOzar.com/go/rg'' AS URL,
					  (''Resource Governor is enabled.  Queries may be throttled.  Make sure you understand how the Classifier Function is configured.'') AS Details FROM sys.resource_governor_configuration WHERE is_enabled = 1'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 11 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 11 AS CheckID,
					  100 AS Priority,
					  ''Performance'' AS FindingsGroup,
					  ''Server Triggers Enabled'' AS Finding,
					  ''http://BrentOzar.com/go/logontriggers/'' AS URL,
					  (''Server Trigger ['' + [name] ++ ''] is enabled.  Make sure you understand what that trigger is doing - the less work it does, the better.'') AS Details FROM sys.server_triggers WHERE is_disabled = 0 AND is_ms_shipped = 0'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 12 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  12 AS CheckID ,
										[name] AS DatabaseName ,
										10 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Auto-Close Enabled' AS Finding ,
										'http://BrentOzar.com/go/autoclose' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-close enabled.  This setting can dramatically decrease performance.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_close_on = 1
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 13 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  13 AS CheckID ,
										[name] AS DatabaseName ,
										10 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Auto-Shrink Enabled' AS Finding ,
										'http://BrentOzar.com/go/autoshrink' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-shrink enabled.  This setting can dramatically decrease performance.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_shrink_on = 1
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL);
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 14 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID,
							DatabaseName,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 14 AS CheckID,
					  [name] as DatabaseName,
					  50 AS Priority,
					  ''Reliability'' AS FindingsGroup,
					  ''Page Verification Not Optimal'' AS Finding,
					  ''http://BrentOzar.com/go/torn'' AS URL,
					  (''Database ['' + [name] + ''] has '' + [page_verify_option_desc] + '' for page verification.  SQL Server may have a harder time recognizing and recovering from storage corruption.  Consider using CHECKSUM instead.'') COLLATE database_default AS Details
					  FROM sys.databases
					  WHERE page_verify_option &lt; 2
					  AND name &lt;&gt; ''tempdb''
					  and name not in (select distinct DatabaseName from #SkipChecks)'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 15 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  15 AS CheckID ,
										[name] AS DatabaseName ,
										110 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Auto-Create Stats Disabled' AS Finding ,
										'http://BrentOzar.com/go/acs' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-create-stats disabled.  SQL Server uses statistics to build better execution plans, and without the ability to automatically create more, performance may suffer.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_create_stats_on = 0
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 16 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  16 AS CheckID ,
										[name] AS DatabaseName ,
										110 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Auto-Update Stats Disabled' AS Finding ,
										'http://BrentOzar.com/go/aus' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-update-stats disabled.  SQL Server uses statistics to build better execution plans, and without the ability to automatically update them, performance may suffer.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_update_stats_on = 0
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 17 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  17 AS CheckID ,
										[name] AS DatabaseName ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Stats Updated Asynchronously' AS Finding ,
										'http://BrentOzar.com/go/asyncstats' AS URL ,
										( 'Database [' + [name]
										  + '] has auto-update-stats-async enabled.  When SQL Server gets a query for a table with out-of-date statistics, it will run the query with the stats it has - while updating stats to make later queries better. The initial run of the query may suffer, though.' ) AS Details
								FROM    sys.databases
								WHERE   is_auto_update_stats_async_on = 1
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 18 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  18 AS CheckID ,
										[name] AS DatabaseName ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Forced Parameterization On' AS Finding ,
										'http://BrentOzar.com/go/forced' AS URL ,
										( 'Database [' + [name]
										  + '] has forced parameterization enabled.  SQL Server will aggressively reuse query execution plans even if the applications do not parameterize their queries.  This can be a performance booster with some programming languages, or it may use universally bad execution plans when better alternatives are available for certain parameters.' ) AS Details
								FROM    sys.databases
								WHERE   is_parameterization_forced = 1
										AND name NOT IN ( SELECT  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 20 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  20 AS CheckID ,
										[name] AS DatabaseName ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Date Correlation On' AS Finding ,
										'http://BrentOzar.com/go/corr' AS URL ,
										( 'Database [' + [name]
										  + '] has date correlation enabled.  This is not a default setting, and it has some performance overhead.  It tells SQL Server that date fields in two tables are related, and SQL Server maintains statistics showing that relation.' ) AS Details
								FROM    sys.databases
								WHERE   is_date_correlation_on = 1
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 21 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
							(CheckID,
							DatabaseName,
							Priority,
							FindingsGroup,
							Finding,
							URL,
							Details)
					  SELECT 21 AS CheckID,
					  [name] as DatabaseName,
					  200 AS Priority,
					  ''Informational'' AS FindingsGroup,
					  ''Database Encrypted'' AS Finding,
					  ''http://BrentOzar.com/go/tde'' AS URL,
					  (''Database ['' + [name] + ''] has Transparent Data Encryption enabled.  Make absolutely sure you have backed up the certificate and private key, or else you will not be able to restore this database.'') AS Details
					  FROM sys.databases
					  WHERE is_encrypted = 1
					  and name not in (select distinct DatabaseName from #SkipChecks)'
								EXECUTE(@StringToExecute)
							END;
					END

				/*
				Believe it or not, SQL Server doesn't track the default values
				for sp_configure options! We'll make our own list here.
				*/
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'access check cache bucket count', 0, 1001 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'access check cache quota', 0, 1002 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Ad Hoc Distributed Queries', 0, 1003 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'affinity I/O mask', 0, 1004 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'affinity mask', 0, 1005 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'affinity64 mask', 0, 1066 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'affinity64 I/O mask', 0, 1067 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Agent XPs', 0, 1071 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'allow updates', 0, 1007 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'awe enabled', 0, 1008 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'backup checksum default', 0, 1070 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'backup compression default', 0, 1073 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'blocked process threshold', 0, 1009 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'blocked process threshold (s)', 0, 1009 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'c2 audit mode', 0, 1010 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'clr enabled', 0, 1011 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'common criteria compliance enabled', 0, 1074 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'contained database authentication', 0, 1068 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'cost threshold for parallelism', 5, 1012 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'cross db ownership chaining', 0, 1013 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'cursor threshold', -1, 1014 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Database Mail XPs', 0, 1072 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'default full-text language', 1033, 1016 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'default language', 0, 1017 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'default trace enabled', 1, 1018 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'disallow results from triggers', 0, 1019 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'EKM provider enabled', 0, 1075 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'filestream access level', 0, 1076 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'fill factor (%)', 0, 1020 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'ft crawl bandwidth (max)', 100, 1021 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'ft crawl bandwidth (min)', 0, 1022 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'ft notify bandwidth (max)', 100, 1023 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'ft notify bandwidth (min)', 0, 1024 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'index create memory (KB)', 0, 1025 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'in-doubt xact resolution', 0, 1026 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'lightweight pooling', 0, 1027 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'locks', 0, 1028 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max degree of parallelism', 0, 1029 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max full-text crawl range', 4, 1030 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max server memory (MB)', 2147483647, 1031 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max text repl size (B)', 65536, 1032 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'max worker threads', 0, 1033 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'media retention', 0, 1034 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'min memory per query (KB)', 1024, 1035 );
				/* Accepting both 0 and 16 below because both have been seen in the wild as defaults. */
				IF EXISTS ( SELECT  *
							FROM    sys.configurations
							WHERE   name = 'min server memory (MB)'
									AND value_in_use IN ( 0, 16 ) )
					INSERT  INTO #ConfigurationDefaults
							SELECT  'min server memory (MB)' ,
									CAST(value_in_use AS BIGINT), 1036
							FROM    sys.configurations
							WHERE   name = 'min server memory (MB)'
				ELSE
					INSERT  INTO #ConfigurationDefaults
					VALUES  ( 'min server memory (MB)', 0, 1036 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'nested triggers', 1, 1037 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'network packet size (B)', 4096, 1038 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Ole Automation Procedures', 0, 1039 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'open objects', 0, 1040 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'optimize for ad hoc workloads', 0, 1041 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'PH timeout (s)', 60, 1042 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'precompute rank', 0, 1043 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'priority boost', 0, 1044 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'query governor cost limit', 0, 1045 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'query wait (s)', -1, 1046 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'recovery interval (min)', 0, 1047 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'remote access', 1, 1048 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'remote admin connections', 0, 1049 );
				/* SQL Server 2012 changes a configuration default */
				IF @@VERSION LIKE '%Microsoft SQL Server 2005%'
					OR @@VERSION LIKE '%Microsoft SQL Server 2008%'
					BEGIN
						INSERT  INTO #ConfigurationDefaults
						VALUES  ( 'remote login timeout (s)', 20, 1069 );
					END
				ELSE
					BEGIN
						INSERT  INTO #ConfigurationDefaults
						VALUES  ( 'remote login timeout (s)', 10, 1069 );
					END
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'remote proc trans', 0, 1050 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'remote query timeout (s)', 600, 1051 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Replication XPs', 0, 1052 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'RPC parameter data validation', 0, 1053 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'scan for startup procs', 0, 1054 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'server trigger recursion', 1, 1055 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'set working set size', 0, 1056 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'show advanced options', 0, 1057 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'SMO and DMO XPs', 1, 1058 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'SQL Mail XPs', 0, 1059 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'transform noise words', 0, 1060 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'two digit year cutoff', 2049, 1061 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'user connections', 0, 1062 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'user options', 0, 1063 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'Web Assistant Procedures', 0, 1064 );
				INSERT  INTO #ConfigurationDefaults
				VALUES  ( 'xp_cmdshell', 0, 1065 );


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 22 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  cd.CheckID ,
										200 AS Priority ,
										'Non-Default Server Config' AS FindingsGroup ,
										cr.name AS Finding ,
										'http://BrentOzar.com/go/conf' AS URL ,
										( 'This sp_configure option has been changed.  Its default value is '
										  + COALESCE(CAST(cd.[DefaultValue] AS VARCHAR(100)),
													 '(unknown)')
										  + ' and it has been set to '
										  + CAST(cr.value_in_use AS VARCHAR(100))
										  + '.' ) AS Details
								FROM    sys.configurations cr
										INNER JOIN #ConfigurationDefaults cd ON cd.name = cr.name
										LEFT OUTER JOIN #ConfigurationDefaults cdUsed ON cdUsed.name = cr.name
																  AND cdUsed.DefaultValue = cr.value_in_use
								WHERE   cdUsed.name IS NULL;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 190 )
					BEGIN
						SELECT @MinServerMemory = CAST(value_in_use as BIGINT) FROM sys.configurations WHERE name = 'min server memory (MB)'
						SELECT @MaxServerMemory = CAST(value_in_use as BIGINT) FROM sys.configurations WHERE name = 'max server memory (MB)'
						
						IF (@MinServerMemory = @MaxServerMemory)
						BEGIN
						INSERT INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								VALUES  
									(	190,
										200,
										'Performance',
										'Non-Dynamic Memory',
										'http://BrentOzar.com/go/memory',
										'Minimum Server Memory setting is the same as the Maximum (both set to ' + CAST(@MinServerMemory AS NVARCHAR(50)) + '). This will not allow dynamic memory. Please revise memory settings'
									)
						END
					END
					
					IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 188 )
					BEGIN

						/* Let's set variables so that our query is still SARGable */
						SET @Processors = (SELECT cpu_count FROM sys.dm_os_sys_info)
						SET @NUMANodes = (SELECT COUNT(1)
											FROM sys.dm_os_performance_counters pc
											WHERE pc.object_name LIKE '%Buffer Node%'
												AND counter_name = 'Page life expectancy')
						/* If Cost Threshold for Parallelism is default then flag as a potential issue */
						/* If MAXDOP is default and processors &gt; 8 or NUMA nodes &gt; 1 then flag as potential issue */
						INSERT INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  188 AS CheckID ,
										200 AS Priority ,
										'Performance' AS FindingsGroup ,
										cr.name AS Finding ,
										'http://BrentOzar.com/go/cxpacket' AS URL ,
										( 'Set to ' + CAST(cr.value_in_use AS NVARCHAR(50)) + ', its default value. Changing this sp_configure setting may reduce CXPACKET waits.')
								FROM    sys.configurations cr
										INNER JOIN #ConfigurationDefaults cd ON cd.name = cr.name
											AND cr.value_in_use = cd.DefaultValue
								WHERE   cr.name = 'cost threshold for parallelism'
									OR (cr.name = 'max degree of parallelism' AND (@NUMANodes &gt; 1 OR @Processors &gt; 8));
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 24 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										24 AS CheckID ,
										DB_NAME(database_id) AS DatabaseName ,
										170 AS Priority ,
										'File Configuration' AS FindingsGroup ,
										'System Database on C Drive' AS Finding ,
										'http://BrentOzar.com/go/cdrive' AS URL ,
										( 'The ' + DB_NAME(database_id)
										  + ' database has a file on the C drive.  Putting system databases on the C drive runs the risk of crashing the server when it runs out of space.' ) AS Details
								FROM    sys.master_files
								WHERE   UPPER(LEFT(physical_name, 1)) = 'C'
										AND DB_NAME(database_id) IN ( 'master',
																  'model', 'msdb' );
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 25 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT TOP 1
										25 AS CheckID ,
										'tempdb' ,
										20 AS Priority ,
										'File Configuration' AS FindingsGroup ,
										'TempDB on C Drive' AS Finding ,
										'http://BrentOzar.com/go/cdrive' AS URL ,
										CASE WHEN growth &gt; 0
											 THEN ( 'The tempdb database has files on the C drive.  TempDB frequently grows unpredictably, putting your server at risk of running out of C drive space and crashing hard.  C is also often much slower than other drives, so performance may be suffering.' )
											 ELSE ( 'The tempdb database has files on the C drive.  TempDB is not set to Autogrow, hopefully it is big enough.  C is also often much slower than other drives, so performance may be suffering.' )
										END AS Details
								FROM    sys.master_files
								WHERE   UPPER(LEFT(physical_name, 1)) = 'C'
										AND DB_NAME(database_id) = 'tempdb';
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 26 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										26 AS CheckID ,
										DB_NAME(database_id) AS DatabaseName ,
										20 AS Priority ,
										'Reliability' AS FindingsGroup ,
										'User Databases on C Drive' AS Finding ,
										'http://BrentOzar.com/go/cdrive' AS URL ,
										( 'The ' + DB_NAME(database_id)
										  + ' database has a file on the C drive.  Putting databases on the C drive runs the risk of crashing the server when it runs out of space.' ) AS Details
								FROM    sys.master_files
								WHERE   UPPER(LEFT(physical_name, 1)) = 'C'
										AND DB_NAME(database_id) NOT IN ( 'master',
																  'model', 'msdb',
																  'tempdb' )
										AND DB_NAME(database_id) NOT IN (
										SELECT DISTINCT
												DatabaseName
										FROM    #SkipChecks )
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 27 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  27 AS CheckID ,
										'master' AS DatabaseName ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Tables in the Master Database' AS Finding ,
										'http://BrentOzar.com/go/mastuser' AS URL ,
										( 'The ' + name
										  + ' table in the master database was created by end users on '
										  + CAST(create_date AS VARCHAR(20))
										  + '. Tables in the master database may not be restored in the event of a disaster.' ) AS Details
								FROM    master.sys.tables
								WHERE   is_ms_shipped = 0;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 28 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  28 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Tables in the MSDB Database' AS Finding ,
										'http://BrentOzar.com/go/msdbuser' AS URL ,
										( 'The ' + name
										  + ' table in the msdb database was created by end users on '
										  + CAST(create_date AS VARCHAR(20))
										  + '. Tables in the msdb database may not be restored in the event of a disaster.' ) AS Details
								FROM    msdb.sys.tables
								WHERE   is_ms_shipped = 0 AND name NOT LIKE '%DTA_%';
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 29 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  29 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Tables in the Model Database' AS Finding ,
										'http://BrentOzar.com/go/model' AS URL ,
										( 'The ' + name
										  + ' table in the model database was created by end users on '
										  + CAST(create_date AS VARCHAR(20))
										  + '. Tables in the model database are automatically copied into all new databases.' ) AS Details
								FROM    model.sys.tables
								WHERE   is_ms_shipped = 0;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 30 )
					BEGIN
						IF ( SELECT COUNT(*)
							 FROM   msdb.dbo.sysalerts
							 WHERE  severity BETWEEN 19 AND 25
						   ) &lt; 7
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  30 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'Not All Alerts Configured' AS Finding ,
											'http://BrentOzar.com/go/alert' AS URL ,
											( 'Not all SQL Server Agent alerts have been configured.  This is a free, easy way to get notified of corruption, job failures, or major outages even before monitoring systems pick it up.' ) AS Details;
					END



				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 59 )
					BEGIN
						IF EXISTS ( SELECT  *
									FROM    msdb.dbo.sysalerts
									WHERE   enabled = 1
											AND COALESCE(has_notification, 0) = 0
											AND (job_id IS NULL OR job_id = 0x))
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  59 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'Alerts Configured without Follow Up' AS Finding ,
											'http://BrentOzar.com/go/alert' AS URL ,
											( 'SQL Server Agent alerts have been configured but they either do not notify anyone or else they do not take any action.  This is a free, easy way to get notified of corruption, job failures, or major outages even before monitoring systems pick it up.' ) AS Details;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 96 )
					BEGIN
						IF NOT EXISTS ( SELECT  *
										FROM    msdb.dbo.sysalerts
										WHERE   message_id IN ( 823, 824, 825 ) )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  96 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'No Alerts for Corruption' AS Finding ,
											'http://BrentOzar.com/go/alert' AS URL ,
											( 'SQL Server Agent alerts do not exist for errors 823, 824, and 825.  These three errors can give you notification about early hardware failure. Enabling them can prevent you a lot of heartbreak.' ) AS Details;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 61 )
					BEGIN
						IF NOT EXISTS ( SELECT  *
										FROM    msdb.dbo.sysalerts
										WHERE   severity BETWEEN 19 AND 25 )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  61 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'No Alerts for Sev 19-25' AS Finding ,
											'http://BrentOzar.com/go/alert' AS URL ,
											( 'SQL Server Agent alerts do not exist for severity levels 19 through 25.  These are some very severe SQL Server errors. Knowing that these are happening may let you recover from errors faster.' ) AS Details;
					END

		--check for disabled alerts
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 98 )
					BEGIN
						IF EXISTS ( SELECT  name
									FROM    msdb.dbo.sysalerts
									WHERE   enabled = 0 )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  98 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'Alerts Disabled' AS Finding ,
											'http://www.BrentOzar.com/go/alerts/' AS URL ,
											( 'The following Alert is disabled, please review and enable if desired: '
											  + name ) AS Details
									FROM    msdb.dbo.sysalerts
									WHERE   enabled = 0
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 31 )
					BEGIN
						IF NOT EXISTS ( SELECT  *
										FROM    msdb.dbo.sysoperators
										WHERE   enabled = 1 )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  31 AS CheckID ,
											200 AS Priority ,
											'Monitoring' AS FindingsGroup ,
											'No Operators Configured/Enabled' AS Finding ,
											'http://BrentOzar.com/go/op' AS URL ,
											( 'No SQL Server Agent operators (emails) have been configured.  This is a free, easy way to get notified of corruption, job failures, or major outages even before monitoring systems pick it up.' ) AS Details;
					END



				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 34 )
					BEGIN
						IF EXISTS ( SELECT  *
									FROM    sys.all_objects
									WHERE   name = 'dm_db_mirroring_auto_page_repair' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT
		  34 AS CheckID ,
		  db.name ,
		  1 AS Priority ,
		  ''Corruption'' AS FindingsGroup ,
		  ''Database Corruption Detected'' AS Finding ,
		  ''http://BrentOzar.com/go/repair'' AS URL ,
		  ( ''Database mirroring has automatically repaired at least one corrupt page in the last 30 days. For more information, query the DMV sys.dm_db_mirroring_auto_page_repair.'' ) AS Details
		  FROM (SELECT rp2.database_id, rp2.modification_time 
			FROM sys.dm_db_mirroring_auto_page_repair rp2 
			WHERE rp2.[database_id] not in (
			SELECT db2.[database_id] 
			FROM sys.databases as db2 
			WHERE db2.[state] = 1
			) ) as rp 
		  INNER JOIN master.sys.databases db ON rp.database_id = db.database_id
		  WHERE   rp.modification_time &gt;= DATEADD(dd, -30, GETDATE()) ;'
								EXECUTE(@StringToExecute)
							END;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 89 )
					BEGIN
						IF EXISTS ( SELECT  *
									FROM    sys.all_objects
									WHERE   name = 'dm_hadr_auto_page_repair' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT
		  89 AS CheckID ,
		  db.name ,
		  1 AS Priority ,
		  ''Corruption'' AS FindingsGroup ,
		  ''Database Corruption Detected'' AS Finding ,
		  ''http://BrentOzar.com/go/repair'' AS URL ,
		  ( ''AlwaysOn has automatically repaired at least one corrupt page in the last 30 days. For more information, query the DMV sys.dm_hadr_auto_page_repair.'' ) AS Details
		  FROM    sys.dm_hadr_auto_page_repair rp
		  INNER JOIN master.sys.databases db ON rp.database_id = db.database_id
		  WHERE   rp.modification_time &gt;= DATEADD(dd, -30, GETDATE()) ;'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 90 )
					BEGIN
						IF EXISTS ( SELECT  *
									FROM    msdb.sys.all_objects
									WHERE   name = 'suspect_pages' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT
		  90 AS CheckID ,
		  db.name ,
		  1 AS Priority ,
		  ''Corruption'' AS FindingsGroup ,
		  ''Database Corruption Detected'' AS Finding ,
		  ''http://BrentOzar.com/go/repair'' AS URL ,
		  ( ''SQL Server has detected at least one corrupt page in the last 30 days. For more information, query the system table msdb.dbo.suspect_pages.'' ) AS Details
		  FROM    msdb.dbo.suspect_pages sp
		  INNER JOIN master.sys.databases db ON sp.database_id = db.database_id
		  WHERE   sp.last_update_date &gt;= DATEADD(dd, -30, GETDATE()) ;'
								EXECUTE(@StringToExecute)
							END;
					END


				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 36 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										36 AS CheckID ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Slow Storage Reads on Drive '
										+ UPPER(LEFT(mf.physical_name, 1)) AS Finding ,
										'http://BrentOzar.com/go/slow' AS URL ,
										'Reads are averaging longer than 200ms for at least one database on this drive.  For specific database file speeds, run the query from the information link.' AS Details
								FROM    sys.dm_io_virtual_file_stats(NULL, NULL)
										AS fs
										INNER JOIN sys.master_files AS mf ON fs.database_id = mf.database_id
																  AND fs.[file_id] = mf.[file_id]
								WHERE   ( io_stall_read_ms / ( 1.0 + num_of_reads ) ) &gt; 200
								AND num_of_reads &gt; 100000;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 37 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										37 AS CheckID ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Slow Storage Writes on Drive '
										+ UPPER(LEFT(mf.physical_name, 1)) AS Finding ,
										'http://BrentOzar.com/go/slow' AS URL ,
										'Writes are averaging longer than 100ms for at least one database on this drive.  For specific database file speeds, run the query from the information link.' AS Details
								FROM    sys.dm_io_virtual_file_stats(NULL, NULL)
										AS fs
										INNER JOIN sys.master_files AS mf ON fs.database_id = mf.database_id
																  AND fs.[file_id] = mf.[file_id]
								WHERE   ( io_stall_write_ms / ( 1.0
																+ num_of_writes ) ) &gt; 100
																AND num_of_writes &gt; 100000;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 40 )
					BEGIN
						IF ( SELECT COUNT(*)
							 FROM   tempdb.sys.database_files
							 WHERE  type_desc = 'ROWS'
						   ) = 1
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  DatabaseName ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
								VALUES  ( 40 ,
										  'tempdb' ,
										  170 ,
										  'File Configuration' ,
										  'TempDB Only Has 1 Data File' ,
										  'http://BrentOzar.com/go/tempdb' ,
										  'TempDB is only configured with one data file.  More data files are usually required to alleviate SGAM contention.'
										);
							END;
					END

						IF ( SELECT COUNT (distinct [size])
							FROM   tempdb.sys.database_files
							WHERE  type_desc = 'ROWS'
							) &lt;&gt; 1
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  DatabaseName ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
								VALUES  ( 183 ,
										  'tempdb' ,
										  170 ,
										  'File Configuration' ,
										  'TempDB Unevenly Sized Data Files' ,
										  'http://BrentOzar.com/go/tempdb' ,
										  'TempDB data files are not configured with the same size.  Unevenly sized tempdb data files will result in unevenly sized workloads.'
										);
							END;

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 44 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  44 AS CheckID ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Queries Forcing Order Hints' AS Finding ,
										'http://BrentOzar.com/go/hints' AS URL ,
										CAST(occurrence AS VARCHAR(10))
										+ ' instances of order hinting have been recorded since restart.  This means queries are bossing the SQL Server optimizer around, and if they don''t know what they''re doing, this can cause more harm than good.  This can also explain why DBA tuning efforts aren''t working.' AS Details
								FROM    sys.dm_exec_query_optimizer_info
								WHERE   counter = 'order hint'
										AND occurrence &gt; 1000
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 45 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  45 AS CheckID ,
										150 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Queries Forcing Join Hints' AS Finding ,
										'http://BrentOzar.com/go/hints' AS URL ,
										CAST(occurrence AS VARCHAR(10))
										+ ' instances of join hinting have been recorded since restart.  This means queries are bossing the SQL Server optimizer around, and if they don''t know what they''re doing, this can cause more harm than good.  This can also explain why DBA tuning efforts aren''t working.' AS Details
								FROM    sys.dm_exec_query_optimizer_info
								WHERE   counter = 'join hint'
										AND occurrence &gt; 1000
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 49 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT DISTINCT
										49 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Linked Server Configured' AS Finding ,
										'http://BrentOzar.com/go/link' AS URL ,
										+CASE WHEN l.remote_name = 'sa'
											  THEN s.data_source
												   + ' is configured as a linked server. Check its security configuration as it is connecting with sa, because any user who queries it will get admin-level permissions.'
											  ELSE s.data_source
												   + ' is configured as a linked server. Check its security configuration to make sure it isn''t connecting with SA or some other bone-headed administrative login, because any user who queries it might get admin-level permissions.'
										 END AS Details
								FROM    sys.servers s
										INNER JOIN sys.linked_logins l ON s.server_id = l.server_id
								WHERE   s.is_linked = 1
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 50 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
		  SELECT  50 AS CheckID ,
		  100 AS Priority ,
		  ''Performance'' AS FindingsGroup ,
		  ''Max Memory Set Too High'' AS Finding ,
		  ''http://BrentOzar.com/go/max'' AS URL ,
		  ''SQL Server max memory is set to ''
			+ CAST(c.value_in_use AS VARCHAR(20))
			+ '' megabytes, but the server only has ''
			+ CAST(( CAST(m.total_physical_memory_kb AS BIGINT) / 1024 ) AS VARCHAR(20))
			+ '' megabytes.  SQL Server may drain the system dry of memory, and under certain conditions, this can cause Windows to swap to disk.'' AS Details
		  FROM    sys.dm_os_sys_memory m
		  INNER JOIN sys.configurations c ON c.name = ''max server memory (MB)''
		  WHERE   CAST(m.total_physical_memory_kb AS BIGINT) &lt; ( CAST(c.value_in_use AS BIGINT) * 1024 )'
								EXECUTE(@StringToExecute)
							END;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 51 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
		  SELECT  51 AS CheckID ,
		  1 AS Priority ,
		  ''Performance'' AS FindingsGroup ,
		  ''Memory Dangerously Low'' AS Finding ,
		  ''http://BrentOzar.com/go/max'' AS URL ,
		  ''The server has '' + CAST(( CAST(m.total_physical_memory_kb AS BIGINT) / 1024 ) AS VARCHAR(20)) + '' megabytes of physical memory, but only '' + CAST(( CAST(m.available_physical_memory_kb AS BIGINT) / 1024 ) AS VARCHAR(20))
			+ '' megabytes are available.  As the server runs out of memory, there is danger of swapping to disk, which will kill performance.'' AS Details
		  FROM    sys.dm_os_sys_memory m
		  WHERE   CAST(m.available_physical_memory_kb AS BIGINT) &lt; 262144'
								EXECUTE(@StringToExecute)
							END;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 159 )
					BEGIN
						IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
		  SELECT DISTINCT 159 AS CheckID ,
		  1 AS Priority ,
		  ''Performance'' AS FindingsGroup ,
		  ''Memory Dangerously Low in NUMA Nodes'' AS Finding ,
		  ''http://BrentOzar.com/go/max'' AS URL ,
		  ''At least one NUMA node is reporting THREAD_RESOURCES_LOW in sys.dm_os_nodes and can no longer create threads.'' AS Details
		  FROM    sys.dm_os_nodes m
		  WHERE   node_state_desc LIKE ''%THREAD_RESOURCES_LOW%'''
								EXECUTE(@StringToExecute)
							END;
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 53 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT TOP 1
										53 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Cluster Node' AS Finding ,
										'http://BrentOzar.com/go/node' AS URL ,
										'This is a node in a cluster.' AS Details
								FROM    sys.dm_os_cluster_nodes
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 55 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  55 AS CheckID ,
										[name] AS DatabaseName ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'Database Owner &lt;&gt; SA' AS Finding ,
										'http://BrentOzar.com/go/owndb' AS URL ,
										( 'Database name: ' + [name] + '   '
										  + 'Owner name: ' + SUSER_SNAME(owner_sid) ) AS Details
								FROM    sys.databases
								WHERE   SUSER_SNAME(owner_sid) &lt;&gt; SUSER_SNAME(0x01)
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL);
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 57 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  57 AS CheckID ,
										230 AS Priority ,
										'Security' AS FindingsGroup ,
										'SQL Agent Job Runs at Startup' AS Finding ,
										'http://BrentOzar.com/go/startup' AS URL ,
										( 'Job [' + j.name
										  + '] runs automatically when SQL Server Agent starts up.  Make sure you know exactly what this job is doing, because it could pose a security risk.' ) AS Details
								FROM    msdb.dbo.sysschedules sched
										JOIN msdb.dbo.sysjobschedules jsched ON sched.schedule_id = jsched.schedule_id
										JOIN msdb.dbo.sysjobs j ON jsched.job_id = j.job_id
								WHERE   sched.freq_type = 64
								        AND sched.enabled = 1;
					END



				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 97 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  97 AS CheckID ,
										100 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Unusual SQL Server Edition' AS Finding ,
										'http://BrentOzar.com/go/workgroup' AS URL ,
										( 'This server is using '
										  + CAST(SERVERPROPERTY('edition') AS VARCHAR(100))
										  + ', which is capped at low amounts of CPU and memory.' ) AS Details
								WHERE   CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Standard%'
										AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Enterprise%'
										AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Data Center%'
										AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Developer%'
										AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Business Intelligence%'
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 154 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  154 AS CheckID ,
										10 AS Priority ,
										'Performance' AS FindingsGroup ,
										'32-bit SQL Server Installed' AS Finding ,
										'http://BrentOzar.com/go/32bit' AS URL ,
										( 'This server uses the 32-bit x86 binaries for SQL Server instead of the 64-bit x64 binaries. The amount of memory available for query workspace and execution plans is heavily limited.' ) AS Details
								WHERE   CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%64%'
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 62 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  62 AS CheckID ,
										[name] AS DatabaseName ,
										200 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Old Compatibility Level' AS Finding ,
										'http://BrentOzar.com/go/compatlevel' AS URL ,
										( 'Database ' + [name]
										  + ' is compatibility level '
										  + CAST(compatibility_level AS VARCHAR(20))
										  + ', which may cause unwanted results when trying to run queries that have newer T-SQL features.' ) AS Details
								FROM    sys.databases
								WHERE   name NOT IN ( SELECT DISTINCT
																DatabaseName
													  FROM      #SkipChecks 
													  WHERE CheckID IS NULL)
										AND compatibility_level &lt;= 90
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 94 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  94 AS CheckID ,
										200 AS [Priority] ,
										'Monitoring' AS FindingsGroup ,
										'Agent Jobs Without Failure Emails' AS Finding ,
										'http://BrentOzar.com/go/alerts' AS URL ,
										'The job ' + [name]
										+ ' has not been set up to notify an operator if it fails.' AS Details
								FROM    msdb.[dbo].[sysjobs] j
										INNER JOIN ( SELECT DISTINCT
															[job_id]
													 FROM   [msdb].[dbo].[sysjobschedules]
													 WHERE  next_run_date &gt; 0
												   ) s ON j.job_id = s.job_id
								WHERE   j.enabled = 1
										AND j.notify_email_operator_id = 0
										AND j.notify_netsend_operator_id = 0
										AND j.notify_page_operator_id = 0
										AND j.category_id &lt;&gt; 100 /* Exclude SSRS category */
					END


				IF EXISTS ( SELECT  1
							FROM    sys.configurations
							WHERE   name = 'remote admin connections'
									AND value_in_use = 0 )
					AND NOT EXISTS ( SELECT 1
									 FROM   #SkipChecks
									 WHERE  DatabaseName IS NULL AND CheckID = 100 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  100 AS CheckID ,
										50 AS Priority ,
										'Reliability' AS FindingGroup ,
										'Remote DAC Disabled' AS Finding ,
										'http://BrentOzar.com/go/dac' AS URL ,
										'Remote access to the Dedicated Admin Connection (DAC) is not enabled. The DAC can make remote troubleshooting much easier when SQL Server is unresponsive.'
					END


				IF EXISTS ( SELECT  *
							FROM    sys.dm_os_schedulers
							WHERE   is_online = 0 )
					AND NOT EXISTS ( SELECT 1
									 FROM   #SkipChecks
									 WHERE  DatabaseName IS NULL AND CheckID = 101 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  101 AS CheckID ,
										50 AS Priority ,
										'Performance' AS FindingGroup ,
										'CPU Schedulers Offline' AS Finding ,
										'http://BrentOzar.com/go/schedulers' AS URL ,
										'Some CPU cores are not accessible to SQL Server due to affinity masking or licensing problems.'
					END


					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 110 )
								AND EXISTS (SELECT * FROM master.sys.all_objects WHERE name = 'dm_os_memory_nodes')
						BEGIN
							SET @StringToExecute = 'IF EXISTS (SELECT  *
												FROM sys.dm_os_nodes n
												INNER JOIN sys.dm_os_memory_nodes m ON n.memory_node_id = m.memory_node_id
												WHERE n.node_state_desc = ''OFFLINE'')
												INSERT  INTO #BlitzResults
														( CheckID ,
														  Priority ,
														  FindingsGroup ,
														  Finding ,
														  URL ,
														  Details
														)
														SELECT  110 AS CheckID ,
																50 AS Priority ,
																''Performance'' AS FindingGroup ,
																''Memory Nodes Offline'' AS Finding ,
																''http://BrentOzar.com/go/schedulers'' AS URL ,
																''Due to affinity masking or licensing problems, some of the memory may not be available.''';
									EXECUTE(@StringToExecute);
						END


				IF EXISTS ( SELECT  *
							FROM    sys.databases
							WHERE   state &gt; 1 )
					AND NOT EXISTS ( SELECT 1
									 FROM   #SkipChecks
									 WHERE  DatabaseName IS NULL AND CheckID = 102 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  102 AS CheckID ,
										[name] ,
										20 AS Priority ,
										'Reliability' AS FindingGroup ,
										'Unusual Database State: ' + [state_desc] AS Finding ,
										'http://BrentOzar.com/go/repair' AS URL ,
										'This database may not be online.'
								FROM    sys.databases
								WHERE   state &gt; 1
					END

				IF EXISTS ( SELECT  *
							FROM    master.sys.extended_procedures )
					AND NOT EXISTS ( SELECT 1
									 FROM   #SkipChecks
									 WHERE  DatabaseName IS NULL AND CheckID = 105 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  105 AS CheckID ,
										'master' ,
										200 AS Priority ,
										'Reliability' AS FindingGroup ,
										'Extended Stored Procedures in Master' AS Finding ,
										'http://BrentOzar.com/go/clr' AS URL ,
										'The [' + name
										+ '] extended stored procedure is in the master database. CLR may be in use, and the master database now needs to be part of your backup/recovery planning.'
								FROM    master.sys.extended_procedures
					END



					IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 107 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  107 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: THREADPOOL'  AS Finding ,
											'http://BrentOzar.com/go/poison' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of this wait have been recorded. This wait often indicates killer performance problems.'
									FROM sys.[dm_os_wait_stats]
									WHERE wait_type = 'THREADPOOL'
									GROUP BY wait_type
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000
						END

					IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 108 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  108 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: RESOURCE_SEMAPHORE'  AS Finding ,
											'http://BrentOzar.com/go/poison' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of this wait have been recorded. This wait often indicates killer performance problems.'
									FROM sys.[dm_os_wait_stats]
									WHERE wait_type = 'RESOURCE_SEMAPHORE'
									GROUP BY wait_type
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000
						END


					IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 109 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  109 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: RESOURCE_SEMAPHORE_QUERY_COMPILE'  AS Finding ,
											'http://BrentOzar.com/go/poison' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of this wait have been recorded. This wait often indicates killer performance problems.'
									FROM sys.[dm_os_wait_stats]
									WHERE wait_type = 'RESOURCE_SEMAPHORE_QUERY_COMPILE'
									GROUP BY wait_type
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000
						END


					IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 121 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  121 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: Serializable Locking'  AS Finding ,
											'http://BrentOzar.com/go/serializable' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of LCK_M_R% waits have been recorded. This wait often indicates killer performance problems.'
									FROM sys.[dm_os_wait_stats]
									WHERE wait_type IN ('LCK_M_RS_S', 'LCK_M_RS_U', 'LCK_M_RIn_NL','LCK_M_RIn_S', 'LCK_M_RIn_U','LCK_M_RIn_X', 'LCK_M_RX_S', 'LCK_M_RX_U','LCK_M_RX_X')
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000
						END




					IF @ProductVersionMajor &gt;= 11 AND NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 162 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  162 AS CheckID ,
											50 AS Priority ,
											'Performance' AS FindingGroup ,
											'Poison Wait Detected: CMEMTHREAD &amp; NUMA'  AS Finding ,
											'http://BrentOzar.com/go/poison' AS URL ,
											CONVERT(VARCHAR(10), (SUM([wait_time_ms]) / 1000) / 86400) + ':' + CONVERT(VARCHAR(20), DATEADD(s, (SUM([wait_time_ms]) / 1000), 0), 108) + ' of this wait have been recorded. In servers with over 8 cores per NUMA node, when CMEMTHREAD waits are a bottleneck, trace flag 8048 may be needed.'
									FROM sys.dm_os_nodes n 
									INNER JOIN sys.[dm_os_wait_stats] w ON w.wait_type = 'CMEMTHREAD'
									WHERE n.node_id = 0 AND n.online_scheduler_count &gt;= 8
									GROUP BY w.wait_type
								    HAVING SUM([wait_time_ms]) &gt; (SELECT 5000 * datediff(HH,create_date,CURRENT_TIMESTAMP) AS hours_since_startup FROM sys.databases WHERE name='tempdb')
									AND SUM([wait_time_ms]) &gt; 60000;
						END




						IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 111 )
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  DatabaseName ,
									  URL ,
									  Details
									)
									SELECT  111 AS CheckID ,
											50 AS Priority ,
											'Reliability' AS FindingGroup ,
											'Possibly Broken Log Shipping'  AS Finding ,
											d.[name] ,
											'http://BrentOzar.com/go/shipping' AS URL ,
											d.[name] + ' is in a restoring state, but has not had a backup applied in the last two days. This is a possible indication of a broken transaction log shipping setup.'
											FROM [master].sys.databases d
											INNER JOIN [master].sys.database_mirroring dm ON d.database_id = dm.database_id
												AND dm.mirroring_role IS NULL
											WHERE ( d.[state] = 1
											OR (d.[state] = 0 AND d.[is_in_standby] = 1) )
											AND NOT EXISTS(SELECT * FROM msdb.dbo.restorehistory rh
											INNER JOIN msdb.dbo.backupset bs ON rh.backup_set_id = bs.backup_set_id
											WHERE d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = rh.destination_database_name COLLATE SQL_Latin1_General_CP1_CI_AS
											AND rh.restore_date &gt;= DATEADD(dd, -2, GETDATE()))

						END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 112 )
									AND EXISTS (SELECT * FROM master.sys.all_objects WHERE name = 'change_tracking_databases')
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
							  SELECT 112 AS CheckID,
							  100 AS Priority,
							  ''Performance'' AS FindingsGroup,
							  ''Change Tracking Enabled'' AS Finding,
							  ''http://BrentOzar.com/go/tracking'' AS URL,
							  ( d.[name] + '' has change tracking enabled. This is not a default setting, and it has some performance overhead. It keeps track of changes to rows in tables that have change tracking turned on.'' ) AS Details FROM sys.change_tracking_databases AS ctd INNER JOIN sys.databases AS d ON ctd.database_id = d.database_id';
										EXECUTE(@StringToExecute);
							END


						IF NOT EXISTS ( SELECT 1
										 FROM   #SkipChecks
										 WHERE  DatabaseName IS NULL AND CheckID = 116 )
									AND EXISTS (SELECT * FROM msdb.sys.all_columns WHERE name = 'compressed_backup_size')
						BEGIN
							SET @StringToExecute = 'INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  116 AS CheckID ,
											200 AS Priority ,
											''Informational'' AS FindingGroup ,
											''Backup Compression Default Off''  AS Finding ,
											''http://BrentOzar.com/go/backup'' AS URL ,
											''Uncompressed full backups have happened recently, and backup compression is not turned on at the server level. Backup compression is included with SQL Server 2008R2 &amp; newer, even in Standard Edition. We recommend turning backup compression on by default so that ad-hoc backups will get compressed.''
											FROM sys.configurations
											WHERE configuration_id = 1579 AND CAST(value_in_use AS INT) = 0
                                            AND EXISTS (SELECT * FROM msdb.dbo.backupset WHERE backup_size = compressed_backup_size AND type = ''D'' AND backup_finish_date &gt;= DATEADD(DD, -14, GETDATE()));'
										EXECUTE(@StringToExecute);
						END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 117 )
									AND EXISTS (SELECT * FROM master.sys.all_objects WHERE name = 'dm_exec_query_resource_semaphores')
							BEGIN
								SET @StringToExecute = 'IF 0 &lt; (SELECT SUM([forced_grant_count]) FROM sys.dm_exec_query_resource_semaphores WHERE [forced_grant_count] IS NOT NULL)
								INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
							  SELECT 117 AS CheckID,
							  100 AS Priority,
							  ''Performance'' AS FindingsGroup,
							  ''Memory Pressure Affecting Queries'' AS Finding,
							  ''http://BrentOzar.com/go/grants'' AS URL,
							  CAST(SUM(forced_grant_count) AS NVARCHAR(100)) + '' forced grants reported in the DMV sys.dm_exec_query_resource_semaphores, indicating memory pressure has affected query runtimes.''
							  FROM sys.dm_exec_query_resource_semaphores WHERE [forced_grant_count] IS NOT NULL;'
										EXECUTE(@StringToExecute);
							END



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 124 )
							BEGIN
								INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
								SELECT 124, 150, 'Performance', 'Deadlocks Happening Daily', 'http://BrentOzar.com/go/deadlocks',
									CAST(p.cntr_value AS NVARCHAR(100)) + ' deadlocks have been recorded since startup.' AS Details
								FROM sys.dm_os_performance_counters p
									INNER JOIN sys.databases d ON d.name = 'tempdb'
								WHERE RTRIM(p.counter_name) = 'Number of Deadlocks/sec'
									AND RTRIM(p.instance_name) = '_Total'
									AND p.cntr_value &gt; 0
									AND (1.0 * p.cntr_value / NULLIF(datediff(DD,create_date,CURRENT_TIMESTAMP),0)) &gt; 10;
							END


						IF DATEADD(mi, -15, GETDATE()) &lt; (SELECT TOP 1 creation_time FROM sys.dm_exec_query_stats ORDER BY creation_time)
						BEGIN
							INSERT INTO #BlitzResults
								(CheckID,
								Priority,
								FindingsGroup,
								Finding,
								URL,
								Details)
							SELECT TOP 1 125, 10, 'Performance', 'Plan Cache Erased Recently', 'http://BrentOzar.com/askbrent/plan-cache-erased-recently/',
								'The oldest query in the plan cache was created at ' + CAST(creation_time AS NVARCHAR(50)) + '. Someone ran DBCC FREEPROCCACHE, restarted SQL Server, or it is under horrific memory pressure.'
							FROM sys.dm_exec_query_stats WITH (NOLOCK)
							ORDER BY creation_time	
						END;

						IF EXISTS (SELECT * FROM sys.configurations WHERE name = 'priority boost' AND (value = 1 OR value_in_use = 1))
						BEGIN
							INSERT INTO #BlitzResults
								(CheckID,
								Priority,
								FindingsGroup,
								Finding,
								URL,
								Details)
							VALUES(126, 5, 'Reliability', 'Priority Boost Enabled', 'http://BrentOzar.com/go/priorityboost/',
								'Priority Boost sounds awesome, but it can actually cause your SQL Server to crash.')
						END;

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 128 )
							BEGIN

							IF (@ProductVersionMajor = 12 AND @ProductVersionMinor &lt; 2000) OR
							   (@ProductVersionMajor = 11 AND @ProductVersionMinor &lt; 3000) OR
							   (@ProductVersionMajor = 10.5 AND @ProductVersionMinor &lt; 6000) OR
							   (@ProductVersionMajor = 10 AND @ProductVersionMinor &lt; 6000) OR
							   (@ProductVersionMajor = 9 /*AND @ProductVersionMinor &lt;= 5000*/)
								BEGIN
								INSERT INTO #BlitzResults(CheckID, Priority, FindingsGroup, Finding, URL, Details)
									VALUES(128, 20, 'Reliability', 'Unsupported Build of SQL Server', 'http://BrentOzar.com/go/unsupported',
										'Version ' + CAST(@ProductVersionMajor AS VARCHAR(100)) + '.' + 
										CASE WHEN @ProductVersionMajor &gt; 9 THEN
										CAST(@ProductVersionMinor AS VARCHAR(100)) + ' is no longer supported by Microsoft. You need to apply a service pack.'
										ELSE ' is no longer support by Microsoft. You should be making plans to upgrade to a modern version of SQL Server.' END);
								END;

							END;
							
						/* Reliability - Dangerous Build of SQL Server (Corruption) */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 129 )
							BEGIN
							IF (@ProductVersionMajor = 11 AND @ProductVersionMinor &gt;= 3000 AND @ProductVersionMinor &lt;= 3436) OR
							   (@ProductVersionMajor = 11 AND @ProductVersionMinor = 5058) OR
							   (@ProductVersionMajor = 12 AND @ProductVersionMinor &gt;= 2000 AND @ProductVersionMinor &lt;= 2342)
								BEGIN
								INSERT INTO #BlitzResults(CheckID, Priority, FindingsGroup, Finding, URL, Details)
									VALUES(129, 20, 'Reliability', 'Dangerous Build of SQL Server (Corruption)', 'http://sqlperformance.com/2014/06/sql-indexes/hotfix-sql-2012-rebuilds',
										'There are dangerous known bugs with version ' + CAST(@ProductVersionMajor AS VARCHAR(100)) + '.' + CAST(@ProductVersionMinor AS VARCHAR(100)) + '. Check the URL for details and apply the right service pack or hotfix.');
								END;

							END;

						/* Reliability - Dangerous Build of SQL Server (Security) */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 157 )
							BEGIN
							IF (@ProductVersionMajor = 10 AND @ProductVersionMinor &gt;= 5500 AND @ProductVersionMinor &lt;= 5512) OR
							   (@ProductVersionMajor = 10 AND @ProductVersionMinor &gt;= 5750 AND @ProductVersionMinor &lt;= 5867) OR
							   (@ProductVersionMajor = 10.5 AND @ProductVersionMinor &gt;= 4000 AND @ProductVersionMinor &lt;= 4017) OR
							   (@ProductVersionMajor = 10.5 AND @ProductVersionMinor &gt;= 4251 AND @ProductVersionMinor &lt;= 4319) OR
							   (@ProductVersionMajor = 11 AND @ProductVersionMinor &gt;= 3000 AND @ProductVersionMinor &lt;= 3129) OR
							   (@ProductVersionMajor = 11 AND @ProductVersionMinor &gt;= 3300 AND @ProductVersionMinor &lt;= 3447) OR
							   (@ProductVersionMajor = 12 AND @ProductVersionMinor &gt;= 2000 AND @ProductVersionMinor &lt;= 2253) OR
							   (@ProductVersionMajor = 12 AND @ProductVersionMinor &gt;= 2300 AND @ProductVersionMinor &lt;= 2370)
								BEGIN
								INSERT INTO #BlitzResults(CheckID, Priority, FindingsGroup, Finding, URL, Details)
									VALUES(157, 20, 'Reliability', 'Dangerous Build of SQL Server (Security)', 'https://technet.microsoft.com/en-us/library/security/MS14-044',
										'There are dangerous known bugs with version ' + CAST(@ProductVersionMajor AS VARCHAR(100)) + '.' + CAST(@ProductVersionMinor AS VARCHAR(100)) + '. Check the URL for details and apply the right service pack or hotfix.');
								END;

							END;
						
						/* Check if SQL 2016 Standard Edition but not SP1 */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 189 )
							BEGIN
							IF (@ProductVersionMajor = 13 AND @ProductVersionMinor &lt; 4001 AND @@VERSION LIKE '%Standard Edition%') 
								BEGIN
								INSERT INTO #BlitzResults(CheckID, Priority, FindingsGroup, Finding, URL, Details)
									VALUES(189, 100, 'Features', 'Missing Features', 'https://blogs.msdn.microsoft.com/sqlreleaseservices/sql-server-2016-service-pack-1-sp1-released/',
										'SQL 2016 Standard Edition is being used but not Service Pack 1. Check the URL for a list of Enterprise Features that are included in Standard Edition as of SP1.');
								END;

							END;						

                        /* Performance - High Memory Use for In-Memory OLTP (Hekaton) */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 145 )
	                        AND EXISTS ( SELECT *
					                        FROM   sys.all_objects o
					                        WHERE  o.name = 'dm_db_xtp_table_memory_stats' )
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT 145 AS CheckID,
			                        10 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''High Memory Use for In-Memory OLTP (Hekaton)'' AS Finding,
			                        ''http://BrentOzar.com/go/hekaton'' AS URL,
			                        CAST(CAST((SUM(mem.pages_kb / 1024.0) / CAST(value_in_use AS INT) * 100) AS INT) AS NVARCHAR(100)) + ''% of your '' + CAST(CAST((CAST(value_in_use AS DECIMAL(38,1)) / 1024) AS MONEY) AS NVARCHAR(100)) + ''GB of your max server memory is being used for in-memory OLTP tables (Hekaton). Microsoft recommends having 2X your Hekaton table space available in memory just for Hekaton, with a max of 250GB of in-memory data regardless of your server memory capacity.'' AS Details
			                        FROM sys.configurations c INNER JOIN sys.dm_os_memory_clerks mem ON mem.type = ''MEMORYCLERK_XTP''
                                    WHERE c.name = ''max server memory (MB)''
                                    GROUP BY c.value_in_use
                                    HAVING CAST(value_in_use AS DECIMAL(38,2)) * .25 &lt; SUM(mem.pages_kb / 1024.0)
                                      OR SUM(mem.pages_kb / 1024.0) &gt; 250000';
		                        EXECUTE(@StringToExecute);
	                        END


                        /* Performance - In-Memory OLTP (Hekaton) In Use */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 146 )
	                        AND EXISTS ( SELECT *
					                        FROM   sys.all_objects o
					                        WHERE  o.name = 'dm_db_xtp_table_memory_stats' )
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT 146 AS CheckID,
			                        200 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''In-Memory OLTP (Hekaton) In Use'' AS Finding,
			                        ''http://BrentOzar.com/go/hekaton'' AS URL,
			                        CAST(CAST((SUM(mem.pages_kb / 1024.0) / CAST(value_in_use AS INT) * 100) AS INT) AS NVARCHAR(100)) + ''% of your '' + CAST(CAST((CAST(value_in_use AS DECIMAL(38,1)) / 1024) AS MONEY) AS NVARCHAR(100)) + ''GB of your max server memory is being used for in-memory OLTP tables (Hekaton).'' AS Details
			                        FROM sys.configurations c INNER JOIN sys.dm_os_memory_clerks mem ON mem.type = ''MEMORYCLERK_XTP''
                                    WHERE c.name = ''max server memory (MB)''
                                    GROUP BY c.value_in_use
                                    HAVING SUM(mem.pages_kb / 1024.0) &gt; 10';
		                        EXECUTE(@StringToExecute);
	                        END

                        /* In-Memory OLTP (Hekaton) - Transaction Errors */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 147 )
	                        AND EXISTS ( SELECT *
					                        FROM   sys.all_objects o
					                        WHERE  o.name = 'dm_xtp_transaction_stats' )
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT 147 AS CheckID,
			                        100 AS Priority,
			                        ''In-Memory OLTP (Hekaton)'' AS FindingsGroup,
			                        ''Transaction Errors'' AS Finding,
			                        ''http://BrentOzar.com/go/hekaton'' AS URL,
			                        ''Since restart: '' + CAST(validation_failures AS NVARCHAR(100)) + '' validation failures, '' + CAST(dependencies_failed AS NVARCHAR(100)) + '' dependency failures, '' + CAST(write_conflicts AS NVARCHAR(100)) + '' write conflicts, '' + CAST(unique_constraint_violations AS NVARCHAR(100)) + '' unique constraint violations.'' AS Details
			                        FROM sys.dm_xtp_transaction_stats
                                    WHERE validation_failures &lt;&gt; 0
                                            OR dependencies_failed &lt;&gt; 0
                                            OR write_conflicts &lt;&gt; 0
                                            OR unique_constraint_violations &lt;&gt; 0;'
		                        EXECUTE(@StringToExecute);
	                        END



                        /* Reliability - Database Files on Network File Shares */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 148 )
	                        BEGIN
		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        DatabaseName ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT DISTINCT 148 AS CheckID ,
						                        d.[name] AS DatabaseName ,
						                        170 AS Priority ,
						                        'Reliability' AS FindingsGroup ,
						                        'Database Files on Network File Shares' AS Finding ,
						                        'http://BrentOzar.com/go/nas' AS URL ,
						                        ( 'Files for this database are on: ' + LEFT(mf.physical_name, 30)) AS Details
				                        FROM    sys.databases d
                                          INNER JOIN sys.master_files mf ON d.database_id = mf.database_id
				                        WHERE mf.physical_name LIKE '\\%'
						                        AND d.name NOT IN ( SELECT DISTINCT
													                        DatabaseName
											                        FROM    #SkipChecks 
																	WHERE CheckID IS NULL)
	                        END

                        /* Reliability - Database Files Stored in Azure */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 149 )
	                        BEGIN
		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        DatabaseName ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT DISTINCT 149 AS CheckID ,
						                        d.[name] AS DatabaseName ,
						                        170 AS Priority ,
						                        'Reliability' AS FindingsGroup ,
						                        'Database Files Stored in Azure' AS Finding ,
						                        'http://BrentOzar.com/go/azurefiles' AS URL ,
						                        ( 'Files for this database are on: ' + LEFT(mf.physical_name, 30)) AS Details
				                        FROM    sys.databases d
                                          INNER JOIN sys.master_files mf ON d.database_id = mf.database_id
				                        WHERE mf.physical_name LIKE 'http://%'
						                        AND d.name NOT IN ( SELECT DISTINCT
													                        DatabaseName
											                        FROM    #SkipChecks 
																	WHERE CheckID IS NULL)
	                        END


                        /* Reliability - Errors Logged Recently in the Default Trace */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 150 )
                            AND @TracePath IS NOT NULL
	                        BEGIN

		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        DatabaseName ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT DISTINCT 150 AS CheckID ,
					                            t.DatabaseName,
						                        50 AS Priority ,
						                        'Reliability' AS FindingsGroup ,
						                        'Errors Logged Recently in the Default Trace' AS Finding ,
						                        'http://BrentOzar.com/go/defaulttrace' AS URL ,
						                         CAST(t.TextData AS NVARCHAR(4000)) AS Details
                                        FROM    sys.fn_trace_gettable(@TracePath, DEFAULT) t
                                        WHERE t.EventClass = 22
                                          AND t.Severity &gt;= 17
                                          AND t.StartTime &gt; DATEADD(dd, -30, GETDATE())
	                        END


                        /* Performance - Log File Growths Slow */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 151 )
                            AND @TracePath IS NOT NULL
	                        BEGIN
		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        DatabaseName ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT DISTINCT 151 AS CheckID ,
					                            t.DatabaseName,
						                        50 AS Priority ,
						                        'Performance' AS FindingsGroup ,
						                        'Log File Growths Slow' AS Finding ,
						                        'http://BrentOzar.com/go/filegrowth' AS URL ,
						                        CAST(COUNT(*) AS NVARCHAR(100)) + ' growths took more than 15 seconds each. Consider setting log file autogrowth to a smaller increment.' AS Details
                                        FROM    sys.fn_trace_gettable(@TracePath, DEFAULT) t
                                        WHERE t.EventClass = 93
                                          AND t.StartTime &gt; DATEADD(dd, -30, GETDATE())
                                          AND t.Duration &gt; 15000000
                                        GROUP BY t.DatabaseName
                                        HAVING COUNT(*) &gt; 1
	                        END


                        /* Performance - Many Plans for One Query */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 160 )
                            AND EXISTS (SELECT * FROM sys.all_columns WHERE name = 'query_hash')
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT TOP 1 160 AS CheckID,
			                        100 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''Many Plans for One Query'' AS Finding,
			                        ''http://BrentOzar.com/go/parameterization'' AS URL,
			                        CAST(COUNT(DISTINCT plan_handle) AS NVARCHAR(50)) + '' plans are present for a single query in the plan cache - meaning we probably have parameterization issues.'' AS Details
			                        FROM sys.dm_exec_query_stats qs
                                    CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) pa
                                    WHERE pa.attribute = ''dbid''
                                    GROUP BY qs.query_hash, pa.value
                                    HAVING COUNT(DISTINCT plan_handle) &gt; 50
									ORDER BY COUNT(DISTINCT plan_handle) DESC;';
		                        EXECUTE(@StringToExecute);
	                        END


                        /* Performance - High Number of Cached Plans */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 161 )
	                        BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        SELECT TOP 1 161 AS CheckID,
			                        100 AS Priority,
			                        ''Performance'' AS FindingsGroup,
			                        ''High Number of Cached Plans'' AS Finding,
			                        ''http://BrentOzar.com/go/planlimits'' AS URL,
			                        ''Your server configuration is limited to '' + CAST(ht.buckets_count * 4 AS VARCHAR(20)) + '' '' + ht.name + '', and you are currently caching '' + CAST(cc.entries_count AS VARCHAR(20)) + ''.'' AS Details
			                        FROM sys.dm_os_memory_cache_hash_tables ht
			                        INNER JOIN sys.dm_os_memory_cache_counters cc ON ht.name = cc.name AND ht.type = cc.type
			                        where ht.name IN ( ''SQL Plans'' , ''Object Plans'' , ''Bound Trees'' )
			                        AND cc.entries_count &gt;= (3 * ht.buckets_count)';
		                        EXECUTE(@StringToExecute);
	                        END


						/* Performance - Too Much Free Memory */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 165 )
							BEGIN
								INSERT INTO #BlitzResults
									(CheckID,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
								SELECT 165, 50, 'Performance', 'Too Much Free Memory', 'http://BrentOzar.com/go/freememory',
									CAST((CAST(cFree.cntr_value AS BIGINT) / 1024 / 1024 ) AS NVARCHAR(100)) + N'GB of free memory inside SQL Server''s buffer pool, which is ' + CAST((CAST(cTotal.cntr_value AS BIGINT) / 1024 / 1024) AS NVARCHAR(100)) + N'GB. You would think lots of free memory would be good, but check out the URL for more information.' AS Details
								FROM sys.dm_os_performance_counters cFree
								INNER JOIN sys.dm_os_performance_counters cTotal ON cTotal.object_name LIKE N'%Memory Manager%'
									AND cTotal.counter_name = N'Total Server Memory (KB)                                                                                                        '
								WHERE cFree.object_name LIKE N'%Memory Manager%'
									AND cFree.counter_name = N'Free Memory (KB)                                                                                                                '
									AND CAST(cTotal.cntr_value AS BIGINT) &gt; 4000
									AND CAST(cTotal.cntr_value AS BIGINT) * .3 &lt;= CAST(cFree.cntr_value AS BIGINT)
                                    AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Standard%'

							END


                        /* Outdated sp_Blitz - sp_Blitz is Over 6 Months Old */
                        IF NOT EXISTS ( SELECT  1
				                        FROM    #SkipChecks
				                        WHERE   DatabaseName IS NULL AND CheckID = 155 )
				           AND DATEDIFF(MM, @VersionDate, GETDATE()) &gt; 6
	                        BEGIN
		                        INSERT  INTO #BlitzResults
				                        ( CheckID ,
					                        Priority ,
					                        FindingsGroup ,
					                        Finding ,
					                        URL ,
					                        Details
				                        )
				                        SELECT 155 AS CheckID ,
						                        0 AS Priority ,
						                        'Outdated sp_Blitz' AS FindingsGroup ,
						                        'sp_Blitz is Over 6 Months Old' AS Finding ,
						                        'http://FirstResponderKit.org/' AS URL ,
						                        'Some things get better with age, like fine wine and your T-SQL. However, sp_Blitz is not one of those things - time to go download the current one.' AS Details
	                        END


						/* Populate a list of database defaults. I'm doing this kind of oddly -
						    it reads like a lot of work, but this way it compiles &amp; runs on all
						    versions of SQL Server.
						*/
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_supplemental_logging_enabled', 0, 131, 210, 'Supplemental Logging Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_supplemental_logging_enabled' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'snapshot_isolation_state', 0, 132, 210, 'Snapshot Isolation Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'snapshot_isolation_state' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_read_committed_snapshot_on', 0, 133, 210, 'Read Committed Snapshot Isolation Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_read_committed_snapshot_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_auto_create_stats_incremental_on', 0, 134, 210, 'Auto Create Stats Incremental Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_auto_create_stats_incremental_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_ansi_null_default_on', 0, 135, 210, 'ANSI NULL Default Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_ansi_null_default_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_recursive_triggers_on', 0, 136, 210, 'Recursive Triggers Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_recursive_triggers_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_trustworthy_on', 0, 137, 210, 'Trustworthy Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_trustworthy_on' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_parameterization_forced', 0, 138, 210, 'Forced Parameterization Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_parameterization_forced' AND object_id = OBJECT_ID('sys.databases');
						/* Not alerting for this since we actually want it and we have a separate check for it:
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_query_store_on', 0, 139, 210, 'Query Store Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_query_store_on' AND object_id = OBJECT_ID('sys.databases');
						*/
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_cdc_enabled', 0, 140, 210, 'Change Data Capture Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_cdc_enabled' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'containment', 0, 141, 210, 'Containment Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'containment' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'target_recovery_time_in_seconds', 0, 142, 210, 'Target Recovery Time Changed', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'target_recovery_time_in_seconds' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'delayed_durability', 0, 143, 210, 'Delayed Durability Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'delayed_durability' AND object_id = OBJECT_ID('sys.databases');
						INSERT INTO #DatabaseDefaults
						  SELECT 'is_memory_optimized_elevate_to_snapshot_on', 0, 144, 210, 'Memory Optimized Enabled', 'http://BrentOzar.com/go/dbdefaults', NULL
						  FROM sys.all_columns 
						  WHERE name = 'is_memory_optimized_elevate_to_snapshot_on' AND object_id = OBJECT_ID('sys.databases');

						DECLARE DatabaseDefaultsLoop CURSOR FOR
						  SELECT name, DefaultValue, CheckID, Priority, Finding, URL, Details
						  FROM #DatabaseDefaults

						OPEN DatabaseDefaultsLoop
						FETCH NEXT FROM DatabaseDefaultsLoop into @CurrentName, @CurrentDefaultValue, @CurrentCheckID, @CurrentPriority, @CurrentFinding, @CurrentURL, @CurrentDetails
						WHILE @@FETCH_STATUS = 0
						BEGIN 

							/* Target Recovery Time (142) can be either 0 or 60 due to a number of bugs */
						    IF @CurrentCheckID = 142
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
								   SELECT ' + CAST(@CurrentCheckID AS NVARCHAR(200)) + ', d.[name], ' + CAST(@CurrentPriority AS NVARCHAR(200)) + ', ''Non-Default Database Config'', ''' + @CurrentFinding + ''',''' + @CurrentURL + ''',''' + COALESCE(@CurrentDetails, 'This database setting is not the default.') + '''
									FROM sys.databases d
									WHERE d.database_id &gt; 4 AND (d.[' + @CurrentName + '] NOT IN (0, 60) OR d.[' + @CurrentName + '] IS NULL);';
							ELSE
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details)
								   SELECT ' + CAST(@CurrentCheckID AS NVARCHAR(200)) + ', d.[name], ' + CAST(@CurrentPriority AS NVARCHAR(200)) + ', ''Non-Default Database Config'', ''' + @CurrentFinding + ''',''' + @CurrentURL + ''',''' + COALESCE(@CurrentDetails, 'This database setting is not the default.') + '''
									FROM sys.databases d
									WHERE d.database_id &gt; 4 AND (d.[' + @CurrentName + '] &lt;&gt; ' + @CurrentDefaultValue + ' OR d.[' + @CurrentName + '] IS NULL);';
						    EXEC (@StringToExecute);

						FETCH NEXT FROM DatabaseDefaultsLoop into @CurrentName, @CurrentDefaultValue, @CurrentCheckID, @CurrentPriority, @CurrentFinding, @CurrentURL, @CurrentDetails 
						END

						CLOSE DatabaseDefaultsLoop
						DEALLOCATE DatabaseDefaultsLoop;
							

/*This checks to see if Agent is Offline*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 167 )
					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
									BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							167 AS [CheckID] ,
							250 AS [Priority] ,
							'Server Info' AS [FindingsGroup] ,
							'Agent is Currently Offline' AS [Finding] ,
							'' AS [URL] ,
							( 'Oops! It looks like the ' + [servicename] + ' service is ' + [status_desc] + '. The startup type is ' + [startup_type_desc] + '.'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_services]
						  WHERE [status_desc] &lt;&gt; 'Running'
						  AND [servicename] LIKE 'SQL Server Agent%'
						  AND CAST(SERVERPROPERTY('Edition') AS VARCHAR(1000)) NOT LIKE '%xpress%'

					END; 
				END;

/*This checks to see if the Full Text thingy is offline*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 168 )
					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							168 AS [CheckID] ,
							250 AS [Priority] ,
							'Server Info' AS [FindingsGroup] ,
							'Full-text Filter Daemon Launcher is Currently Offline' AS [Finding] ,
							'' AS [URL] ,
							( 'Oops! It looks like the ' + [servicename] + ' service is ' + [status_desc] + '. The startup type is ' + [startup_type_desc] + '.'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_services]
						  WHERE [status_desc] &lt;&gt; 'Running'
						  AND [servicename] LIKE 'SQL Full-text Filter Daemon Launcher%'

					END;
					END; 

/*This checks which service account SQL Server is running as.*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 169 )

					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							169 AS [CheckID] ,
							250 AS [Priority] ,
							'Informational' AS [FindingsGroup] ,
							'SQL Server is running under an NT Service account' AS [Finding] ,
							'http://BrentOzar.com/go/setup' AS [URL] ,
							( 'I''m running as ' + [service_account] + '. I wish I had an Active Directory service account instead.'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_services]
						  WHERE [service_account] LIKE 'NT Service%'
						  AND [servicename] LIKE 'SQL Server%'
						  AND [servicename] NOT LIKE 'SQL Server Agent%'

					END;
					END;

/*This checks which service account SQL Agent is running as.*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 170 )

					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							170 AS [CheckID] ,
							250 AS [Priority] ,
							'Informational' AS [FindingsGroup] ,
							'SQL Server Agent is running under an NT Service account' AS [Finding] ,
							'http://BrentOzar.com/go/setup' AS [URL] ,
							( 'I''m running as ' + [service_account] + '. I wish I had an Active Directory service account instead.'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_services]
						  WHERE [service_account] LIKE 'NT Service%'
						  AND [servicename] LIKE 'SQL Server Agent%'

					END; 
					END;

/*This counts memory dumps and gives min and max date of in view*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 171 )
					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_server_memory_dumps' )
					BEGIN
						IF 5 &lt;= (SELECT COUNT(*) FROM [sys].[dm_server_memory_dumps] WHERE [creation_time] &gt;= DATEADD(year, -1, GETDATE()))
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							171 AS [CheckID] ,
							20 AS [Priority] ,
							'Reliability' AS [FindingsGroup] ,
							'Memory Dumps Have Occurred' AS [Finding] ,
							'http://BrentOzar.com/go/dump' AS [URL] ,
							( 'That ain''t good. I''ve had ' + 
								CAST(COUNT(*) AS VARCHAR(100)) + ' memory dumps between ' + 
								CAST(CAST(MIN([creation_time]) AS DATETIME) AS VARCHAR(100)) +
								' and ' +
								CAST(CAST(MAX([creation_time]) AS DATETIME) AS VARCHAR(100)) +
								'!'
							   ) AS [Details]
						  FROM
							[sys].[dm_server_memory_dumps]
						  WHERE [creation_time] &gt;= DATEADD(year, -1, GETDATE());

					END; 
					END;

/*Checks to see if you're on Developer or Evaluation*/
					IF	NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 173 )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							173 AS [CheckID] ,
							200 AS [Priority] ,
							'Licensing' AS [FindingsGroup] ,
							'Non-Production License' AS [Finding] ,
							'http://BrentOzar.com/go/licensing' AS [URL] ,
							( 'We''re not the licensing police, but if this is supposed to be a production server, and you''re running ' + 
							CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) +
							' the good folks at Microsoft might get upset with you. Better start counting those cores.'
							   ) AS [Details]
							WHERE CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) LIKE '%Developer%'
							OR CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) LIKE '%Evaluation%'

					END

/*Checks to see if Buffer Pool Extensions are in use*/
			IF @ProductVersionMajor &gt;= 12  
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 174 )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							174 AS [CheckID] ,
							200 AS [Priority] ,
							'Performance' AS [FindingsGroup] ,
							'Buffer Pool Extensions Enabled' AS [Finding] ,
							'http://BrentOzar.com/go/bpe' AS [URL] ,
							( 'You have Buffer Pool Extensions enabled, and one lives here: ' + 
								[path] +
								'. It''s currently ' +
								CASE WHEN [current_size_in_kb] / 1024. / 1024. &gt; 0
																	 THEN CAST([current_size_in_kb] / 1024. / 1024. AS VARCHAR(100))
																		  + ' GB'
																	 ELSE CAST([current_size_in_kb] / 1024. AS VARCHAR(100))
																		  + ' MB'
								END +
								'. Did you know that BPEs only provide single threaded access 8 bytes at a time?'	
							   ) AS [Details]
							 FROM sys.dm_os_buffer_pool_extension_configuration
							 WHERE [state_description] &lt;&gt; 'BUFFER POOL EXTENSION DISABLED'

					END

/*Check for too many tempdb files*/
			IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 175 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
										SELECT DISTINCT
										175 AS CheckID ,
										'TempDB' AS DatabaseName ,
										170 AS Priority ,
										'File Configuration' AS FindingsGroup ,
										'TempDB Has &gt;16 Data Files' AS Finding ,
										'http://BrentOzar.com/go/tempdb' AS URL ,
										'Woah, Nelly! TempDB has ' + CAST(COUNT_BIG(*) AS VARCHAR) + '. Did you forget to terminate a loop somewhere?' AS Details
								  FROM sys.[master_files] AS [mf] 
								  WHERE [mf].[database_id] = 2 AND [mf].[type] = 0
								  HAVING COUNT_BIG(*) &gt; 16; 
					END	

			IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 176 )
			IF EXISTS ( SELECT  1
														FROM    sys.all_objects
														WHERE   name = 'dm_xe_sessions' )
								BEGIN
								BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  DatabaseName ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
													SELECT DISTINCT
													176 AS CheckID ,
													'' AS DatabaseName ,
													200 AS Priority ,
													'Monitoring' AS FindingsGroup ,
													'Extended Events Hyperextension' AS Finding ,
													'http://BrentOzar.com/go/xe' AS URL ,
													'Hey big spender, you have ' + CAST(COUNT_BIG(*) AS VARCHAR) + ' Extended Events sessions running. You sure you meant to do that?' AS Details
											    FROM sys.dm_xe_sessions
												WHERE [name] NOT IN
												('system_health', 'sp_server_diagnostics session', 'hkenginexesession', 'telemetry_xevents')
												AND name NOT LIKE '%$A%'
											  HAVING COUNT_BIG(*) &gt;= 2; 
								END	
								END
			
			/*Harmful startup parameter*/
			IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 177 )
								BEGIN
								IF EXISTS ( SELECT  1
														FROM    sys.all_objects
														WHERE   name = 'dm_server_registry' )
			
								BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  DatabaseName ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
													SELECT DISTINCT
													177 AS CheckID ,
													'' AS DatabaseName ,
													5 AS Priority ,
													'Monitoring' AS FindingsGroup ,
													'Disabled Internal Monitoring Features' AS Finding ,
													'https://msdn.microsoft.com/en-us/library/ms190737.aspx' AS URL ,
													'You have -x as a startup parameter. You should head to the URL and read more about what it does to your system.' AS Details
													FROM
													[sys].[dm_server_registry] AS [dsr]
													WHERE
													[dsr].[registry_key] LIKE N'%MSSQLServer\Parameters'
													AND [dsr].[value_data] = '-x';; 
								END		
								END
			
			
			/* Reliability - Dangerous Third Party Modules - 179 */
			IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 179 )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							179 AS [CheckID] ,
							5 AS [Priority] ,
							'Reliability' AS [FindingsGroup] ,
							'Dangerous Third Party Modules' AS [Finding] ,
							'https://support.microsoft.com/en-us/kb/2033238' AS [URL] ,
							( COALESCE(company, '') + ' - ' + COALESCE(description, '') + ' - ' + COALESCE(name, '') + ' - suspected dangerous third party module is installed.') AS [Details]
							FROM sys.dm_os_loaded_modules 
							WHERE UPPER(name) LIKE UPPER('%\ENTAPI.DLL') /* McAfee VirusScan Enterprise */
							OR UPPER(name) LIKE UPPER('%\HIPI.DLL') OR UPPER(name) LIKE UPPER('%\HcSQL.dll') OR UPPER(name) LIKE UPPER('%\HcApi.dll') OR UPPER(name) LIKE UPPER('%\HcThe.dll') /* McAfee Host Intrusion */
							OR UPPER(name) LIKE UPPER('%\SOPHOS_DETOURED.DLL') OR UPPER(name) LIKE UPPER('%\SOPHOS_DETOURED_x64.DLL') OR UPPER(name) LIKE UPPER('%\SWI_IFSLSP_64.dll') /* Sophos AV */
							OR UPPER(name) LIKE UPPER('%\PIOLEDB.DLL') OR UPPER(name) LIKE UPPER('%\PISDK.DLL') /* OSISoft PI data access */

					END

			/*Find shrink database tasks*/

			IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 180 )
							AND CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) LIKE '1%' /* Only run on 2008+ */
					BEGIN
						;
						WITH XMLNAMESPACES ('www.microsoft.com/SqlServer/Dts' AS [dts])
						,[maintenance_plan_steps] AS (
							SELECT [name]
								, CAST(CAST([packagedata] AS VARBINARY(MAX)) AS XML) AS [maintenance_plan_xml]
							FROM [msdb].[dbo].[sysssispackages]
							WHERE [packagetype] = 6
						   )
							INSERT    INTO [#BlitzResults]
									( [CheckID] ,
										[Priority] ,
										[FindingsGroup] ,
										[Finding] ,
										[URL] ,
										[Details] )									  
						SELECT
						180 AS [CheckID] ,
						100 AS [Priority] ,
						'Performance' AS [FindingsGroup] ,
						'Shrink Database Step In Maintenance Plan' AS [Finding] ,
						'http://BrentOzar.com/go/autoshrink' AS [URL] ,									  
						'The maintenance plan ' + [mps].[name] + ' has a step to shrink databases in it. Shrinking databases is as outdated as maintenance plans.' AS [Details] 
						FROM [maintenance_plan_steps] [mps]
							CROSS APPLY [maintenance_plan_xml].[nodes]('//dts:Executables/dts:Executable') [t]([c])
						WHERE [c].[value]('(@dts:ObjectName)', 'VARCHAR(128)') = 'Shrink Database Task'

						END


		/*Find repetitive maintenance tasks*/
		IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 181 )
						AND CONVERT(VARCHAR(128), SERVERPROPERTY ('productversion')) LIKE '1%' /* Only run on 2008+ */
				BEGIN
						;
						WITH XMLNAMESPACES ('www.microsoft.com/SqlServer/Dts' AS [dts])
						,[maintenance_plan_steps] AS (
							SELECT [name]
								, CAST(CAST([packagedata] AS VARBINARY(MAX)) AS XML) AS [maintenance_plan_xml]
							FROM [msdb].[dbo].[sysssispackages]
							WHERE [packagetype] = 6
							), [maintenance_plan_table] AS (
						SELECT [mps].[name]
							,[c].[value]('(@dts:ObjectName)', 'NVARCHAR(128)') AS [step_name]
						FROM [maintenance_plan_steps] [mps]
							CROSS APPLY [maintenance_plan_xml].[nodes]('//dts:Executables/dts:Executable') [t]([c])
						), [mp_steps_pretty] AS (SELECT DISTINCT [m1].[name] ,
								STUFF((SELECT N', ' + [m2].[step_name]  FROM [maintenance_plan_table] AS [m2] WHERE [m1].[name] = [m2].[name] 
								FOR XML PATH(N'')), 1, 2, N'') AS [maintenance_plan_steps]
						FROM [maintenance_plan_table] AS [m1])
						
							INSERT    INTO [#BlitzResults]
									( [CheckID] ,
										[Priority] ,
										[FindingsGroup] ,
										[Finding] ,
										[URL] ,
										[Details] )						
						
						SELECT
						181 AS [CheckID] ,
						100 AS [Priority] ,
						'Performance' AS [FindingsGroup] ,
						'Repetitive Steps In Maintenance Plans' AS [Finding] ,
						'https://ola.hallengren.com/' AS [URL] , 
						'The maintenance plan ' + [m].[name] + ' is doing repetitive work on indexes and statistics. Perhaps it''s time to try something more modern?' AS [Details]
						FROM [mp_steps_pretty] m
						WHERE m.[maintenance_plan_steps] LIKE '%Rebuild%Reorganize%'
						OR m.[maintenance_plan_steps] LIKE '%Rebuild%Update%'

						END
			

			/* Reliability - No Failover Cluster Nodes Available - 184 */
			IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 184 )
				AND CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)) NOT LIKE '10%'
				AND CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)) NOT LIKE '9%'
					BEGIN
		                        SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			                        							SELECT TOP 1
							  184 AS CheckID ,
							  20 AS Priority ,
							  ''Reliability'' AS FindingsGroup ,
							  ''No Failover Cluster Nodes Available'' AS Finding ,
							  ''http://BrentOzar.com/go/node'' AS URL ,
							  ''There are no failover cluster nodes available if the active node fails'' AS Details
							FROM (
							  SELECT SUM(CASE WHEN [status] = 0 AND [is_current_owner] = 0 THEN 1 ELSE 0 END) AS [available_nodes]
							  FROM sys.dm_os_cluster_nodes
							) a
							WHERE [available_nodes] &lt; 1';
		                        EXECUTE(@StringToExecute);
					END

		/* Reliability - TempDB File Error */
		IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 191 )
			AND (SELECT COUNT(*) FROM sys.master_files WHERE database_id = 2) &lt;&gt; (SELECT COUNT(*) FROM tempdb.sys.database_files)
				BEGIN
					INSERT    INTO [#BlitzResults]
							( [CheckID] ,
								[Priority] ,
								[FindingsGroup] ,
								[Finding] ,
								[URL] ,
								[Details] )						
						
						SELECT
						191 AS [CheckID] ,
						50 AS [Priority] ,
						'Reliability' AS [FindingsGroup] ,
						'TempDB File Error' AS [Finding] ,
						'http://BrentOzar.com/go/tempdboops' AS [URL] , 
						'Mismatch between the number of TempDB files in sys.master_files versus tempdb.sys.database_files' AS [Details]
				END


				IF @CheckUserDatabaseObjects = 1
					BEGIN

                        /*
                        But what if you need to run a query in every individual database?
				        Check out CheckID 99 below. Yes, it uses sp_MSforeachdb, and no,
				        we're not happy about that. sp_MSforeachdb is known to have a lot
				        of issues, like skipping databases sometimes. However, this is the
				        only built-in option that we have. If you're writing your own code
				        for database maintenance, consider Aaron Bertrand's alternative:
				        http://www.mssqltips.com/sqlservertip/2201/making-a-more-reliable-and-flexible-spmsforeachdb/
				        We don't include that as part of sp_Blitz, of course, because
				        copying and distributing copyrighted code from others without their
				        written permission isn't a good idea.
				        */
				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 99 )
					        BEGIN
						        EXEC dbo.sp_MSforeachdb 'USE [?];  IF EXISTS (SELECT * FROM  sys.tables WITH (NOLOCK) WHERE name = ''sysmergepublications'' ) IF EXISTS ( SELECT * FROM sysmergepublications WITH (NOLOCK) WHERE retention = 0)   INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) SELECT DISTINCT 99, DB_NAME(), 110, ''Performance'', ''Infinite merge replication metadata retention period'', ''http://BrentOzar.com/go/merge'', (''The ['' + DB_NAME() + ''] database has merge replication metadata retention period set to infinite - this can be the case of significant performance issues.'')';
					        END
				        /*
				        Note that by using sp_MSforeachdb, we're running the query in all
				        databases. We're not checking #SkipChecks here for each database to
				        see if we should run the check in this database. That means we may
				        still run a skipped check if it involves sp_MSforeachdb. We just
				        don't output those results in the last step.
                        */


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 163 )
                            AND EXISTS(SELECT * FROM sys.all_objects WHERE name = 'database_query_store_options')
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			                            INSERT INTO #BlitzResults
			                            (CheckID,
			                            DatabaseName,
			                            Priority,
			                            FindingsGroup,
			                            Finding,
			                            URL,
			                            Details)
		                              SELECT TOP 1 163,
		                              ''?'',
		                              10,
		                              ''Performance'',
		                              ''Query Store Disabled'',
		                              ''http://BrentOzar.com/go/querystore'',
		                              (''The new SQL Server 2016 Query Store feature has not been enabled on this database.'')
		                              FROM [?].sys.database_query_store_options WHERE desired_state = 0 AND ''?'' NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''DWConfiguration'', ''DWDiagnostics'', ''DWQueue'', ''ReportServer'', ''ReportServerTempDB'')';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 182 )
                            AND EXISTS(SELECT * FROM sys.all_objects WHERE name = 'database_query_store_options')
							AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Enterprise%'
							AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) NOT LIKE '%Developer%'
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			                            INSERT INTO #BlitzResults
			                            (CheckID,
			                            DatabaseName,
			                            Priority,
			                            FindingsGroup,
			                            Finding,
			                            URL,
			                            Details)
		                              SELECT TOP 1 182,
		                              ''?'',
		                              20,
		                              ''Reliability'',
		                              ''Query Store Cleanup Disabled'',
		                              ''http://BrentOzar.com/go/cleanup'',
		                              (''SQL 2016 RTM has a bug involving dumps that happen every time Query Store cleanup jobs run.'')
		                              FROM [?].sys.database_query_store_options WHERE desired_state &lt;&gt; 0 AND ''?'' NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''DWConfiguration'', ''DWDiagnostics'', ''DWQueue'', ''ReportServer'', ''ReportServerTempDB'')';
							END


				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 41 )
					        BEGIN
						        EXEC dbo.sp_MSforeachdb 'use [?];
		                              INSERT INTO #BlitzResults
		                              (CheckID,
		                              DatabaseName,
		                              Priority,
		                              FindingsGroup,
		                              Finding,
		                              URL,
		                              Details)
		                              SELECT 41,
		                              ''?'',
		                              170,
		                              ''File Configuration'',
		                              ''Multiple Log Files on One Drive'',
		                              ''http://BrentOzar.com/go/manylogs'',
		                              (''The ['' + DB_NAME() + ''] database has multiple log files on the '' + LEFT(physical_name, 1) + '' drive. This is not a performance booster because log file access is sequential, not parallel.'')
		                              FROM [?].sys.database_files WHERE type_desc = ''LOG''
			                            AND ''?'' &lt;&gt; ''[tempdb]''
		                              GROUP BY LEFT(physical_name, 1)
		                              HAVING COUNT(*) &gt; 1';
					        END

				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 42 )
					        BEGIN
						        EXEC dbo.sp_MSforeachdb 'use [?];
			                            INSERT INTO #BlitzResults
			                            (CheckID,
			                            DatabaseName,
			                            Priority,
			                            FindingsGroup,
			                            Finding,
			                            URL,
			                            Details)
			                            SELECT DISTINCT 42,
			                            ''?'',
			                            170,
			                            ''File Configuration'',
			                            ''Uneven File Growth Settings in One Filegroup'',
			                            ''http://BrentOzar.com/go/grow'',
			                            (''The ['' + DB_NAME() + ''] database has multiple data files in one filegroup, but they are not all set up to grow in identical amounts.  This can lead to uneven file activity inside the filegroup.'')
			                            FROM [?].sys.database_files
			                            WHERE type_desc = ''ROWS''
			                            GROUP BY data_space_id
			                            HAVING COUNT(DISTINCT growth) &gt; 1 OR COUNT(DISTINCT is_percent_growth) &gt; 1';
					        END


				            IF NOT EXISTS ( SELECT  1
								            FROM    #SkipChecks
								            WHERE   DatabaseName IS NULL AND CheckID = 82 )
					            BEGIN
						            EXEC sp_MSforeachdb 'use [?];
		                                INSERT INTO #BlitzResults
		                                (CheckID,
		                                DatabaseName,
		                                Priority,
		                                FindingsGroup,
		                                Finding,
		                                URL, Details)
		                                SELECT  DISTINCT 82 AS CheckID,
		                                ''?'' as DatabaseName,
		                                170 AS Priority,
		                                ''File Configuration'' AS FindingsGroup,
		                                ''File growth set to percent'',
		                                ''http://brentozar.com/go/percentgrowth'' AS URL,
		                                ''The ['' + DB_NAME() + ''] database file '' + f.physical_name + '' has grown to '' + CAST((f.size * 8 / 1000000) AS NVARCHAR(10)) + '' GB, and is using percent filegrowth settings. This can lead to slow performance during growths if Instant File Initialization is not enabled.''
		                                FROM    [?].sys.database_files f
		                                WHERE   is_percent_growth = 1 and size &gt; 128000 ';
					            END



                            /* addition by Henrik Staun Poulsen, Stovi Software */
				            IF NOT EXISTS ( SELECT  1
								            FROM    #SkipChecks
								            WHERE   DatabaseName IS NULL AND CheckID = 158 )
					            BEGIN
						            EXEC sp_MSforeachdb 'use [?];
		                                INSERT INTO #BlitzResults
		                                (CheckID,
		                                DatabaseName,
		                                Priority,
		                                FindingsGroup,
		                                Finding,
		                                URL, Details)
		                                SELECT  DISTINCT 158 AS CheckID,
		                                ''?'' as DatabaseName,
		                                170 AS Priority,
		                                ''File Configuration'' AS FindingsGroup,
		                                ''File growth set to 1MB'',
		                                ''http://brentozar.com/go/percentgrowth'' AS URL,
		                                ''The ['' + DB_NAME() + ''] database file '' + f.physical_name + '' is using 1MB filegrowth settings, but it has grown to '' + CAST((f.size * 8 / 1000000) AS NVARCHAR(10)) + '' GB. Time to up the growth amount.''
		                                FROM    [?].sys.database_files f
                                        WHERE is_percent_growth = 0 and growth=128 and size &gt; 128000 ';
					            END



				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 33 )
					        BEGIN
						        IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
							        AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
							        BEGIN
								        EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults
					                                (CheckID,
					                                DatabaseName,
					                                Priority,
					                                FindingsGroup,
					                                Finding,
					                                URL,
					                                Details)
		                                  SELECT DISTINCT 33,
		                                  db_name(),
		                                  200,
		                                  ''Licensing'',
		                                  ''Enterprise Edition Features In Use'',
		                                  ''http://BrentOzar.com/go/ee'',
		                                  (''The ['' + DB_NAME() + ''] database is using '' + feature_name + ''.  If this database is restored onto a Standard Edition server, the restore will fail.'')
		                                  FROM [?].sys.dm_db_persisted_sku_features';
							        END;
					        END


				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 19 )
					        BEGIN
						        /* Method 1: Check sys.databases parameters */
						        INSERT  INTO #BlitzResults
								        ( CheckID ,
								          DatabaseName ,
								          Priority ,
								          FindingsGroup ,
								          Finding ,
								          URL ,
								          Details
								        )

								        SELECT  19 AS CheckID ,
										        [name] AS DatabaseName ,
										        200 AS Priority ,
										        'Informational' AS FindingsGroup ,
										        'Replication In Use' AS Finding ,
										        'http://BrentOzar.com/go/repl' AS URL ,
										        ( 'Database [' + [name]
										          + '] is a replication publisher, subscriber, or distributor.' ) AS Details
								        FROM    sys.databases
								        WHERE   name NOT IN ( SELECT DISTINCT
																        DatabaseName
													          FROM      #SkipChecks 
													          WHERE CheckID IS NULL)
										        AND is_published = 1
										        OR is_subscribed = 1
										        OR is_merge_published = 1
										        OR is_distributor = 1;

						        /* Method B: check subscribers for MSreplication_objects tables */
						        EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults
										        (CheckID,
										        DatabaseName,
										        Priority,
										        FindingsGroup,
										        Finding,
										        URL,
										        Details)
							          SELECT DISTINCT 19,
							          db_name(),
							          200,
							          ''Informational'',
							          ''Replication In Use'',
							          ''http://BrentOzar.com/go/repl'',
							          (''['' + DB_NAME() + ''] has MSreplication_objects tables in it, indicating it is a replication subscriber.'')
							          FROM [?].sys.tables
							          WHERE name = ''dbo.MSreplication_objects'' AND ''?'' &lt;&gt; ''master''';

					        END



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 32 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
			SELECT 32,
			''?'',
			150,
			''Performance'',
			''Triggers on Tables'',
			''http://BrentOzar.com/go/trig'',
			(''The ['' + DB_NAME() + ''] database has '' + CAST(SUM(1) AS NVARCHAR(50)) + '' triggers.'')
			FROM [?].sys.triggers t INNER JOIN [?].sys.objects o ON t.parent_id = o.object_id
			INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id WHERE t.is_ms_shipped = 0 AND DB_NAME() != ''ReportServer''
			HAVING SUM(1) &gt; 0';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 38 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
		  SELECT DISTINCT 38,
		  ''?'',
		  110,
		  ''Performance'',
		  ''Active Tables Without Clustered Indexes'',
		  ''http://BrentOzar.com/go/heaps'',
		  (''The ['' + DB_NAME() + ''] database has heaps - tables without a clustered index - that are being actively queried.'')
		  FROM [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id
		  INNER JOIN [?].sys.partitions p ON i.object_id = p.object_id AND i.index_id = p.index_id
		  INNER JOIN sys.databases sd ON sd.name = ''?''
		  LEFT OUTER JOIN [?].sys.dm_db_index_usage_stats ius ON i.object_id = ius.object_id AND i.index_id = ius.index_id AND ius.database_id = sd.database_id
		  WHERE i.type_desc = ''HEAP'' AND COALESCE(ius.user_seeks, ius.user_scans, ius.user_lookups, ius.user_updates) IS NOT NULL
		  AND sd.name &lt;&gt; ''tempdb'' AND sd.name &lt;&gt; ''DWDiagnostics'' AND o.is_ms_shipped = 0 AND o.type &lt;&gt; ''S''';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 164 )
                            AND EXISTS(SELECT * FROM sys.all_objects WHERE name = 'fn_validate_plan_guide')
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
		  SELECT DISTINCT 164,
		  ''?'',
		  20,
		  ''Reliability'',
		  ''Plan Guides Failing'',
		  ''http://BrentOzar.com/go/misguided'',
		  (''The ['' + DB_NAME() + ''] database has plan guides that are no longer valid, so the queries involved may be failing silently.'')
		  FROM [?].sys.plan_guides g CROSS APPLY fn_validate_plan_guide(g.plan_guide_id)';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 39 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
			(CheckID,
			DatabaseName,
			Priority,
			FindingsGroup,
			Finding,
			URL,
			Details)
		  SELECT DISTINCT 39,
		  ''?'',
		  150,
		  ''Performance'',
		  ''Inactive Tables Without Clustered Indexes'',
		  ''http://BrentOzar.com/go/heaps'',
		  (''The ['' + DB_NAME() + ''] database has heaps - tables without a clustered index - that have not been queried since the last restart.  These may be backup tables carelessly left behind.'')
		  FROM [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id
		  INNER JOIN [?].sys.partitions p ON i.object_id = p.object_id AND i.index_id = p.index_id
		  INNER JOIN sys.databases sd ON sd.name = ''?''
		  LEFT OUTER JOIN [?].sys.dm_db_index_usage_stats ius ON i.object_id = ius.object_id AND i.index_id = ius.index_id AND ius.database_id = sd.database_id
		  WHERE i.type_desc = ''HEAP'' AND COALESCE(ius.user_seeks, ius.user_scans, ius.user_lookups, ius.user_updates) IS NULL
		  AND sd.name &lt;&gt; ''tempdb'' AND sd.name &lt;&gt; ''DWDiagnostics'' AND o.is_ms_shipped = 0 AND o.type &lt;&gt; ''S''';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 46 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 46,
		  ''?'',
		  150,
		  ''Performance'',
		  ''Leftover Fake Indexes From Wizards'',
		  ''http://BrentOzar.com/go/hypo'',
		  (''The index ['' + DB_NAME() + ''].['' + s.name + ''].['' + o.name + ''].['' + i.name + ''] is a leftover hypothetical index from the Index Tuning Wizard or Database Tuning Advisor.  This index is not actually helping performance and should be removed.'')
		  from [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_hypothetical = 1';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 47 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 47,
		  ''?'',
		  100,
		  ''Performance'',
		  ''Indexes Disabled'',
		  ''http://BrentOzar.com/go/ixoff'',
		  (''The index ['' + DB_NAME() + ''].['' + s.name + ''].['' + o.name + ''].['' + i.name + ''] is disabled.  This index is not actually helping performance and should either be enabled or removed.'')
		  from [?].sys.indexes i INNER JOIN [?].sys.objects o ON i.object_id = o.object_id INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_disabled = 1';
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 48 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT DISTINCT 48,
		  ''?'',
		  150,
		  ''Performance'',
		  ''Foreign Keys Not Trusted'',
		  ''http://BrentOzar.com/go/trust'',
		  (''The ['' + DB_NAME() + ''] database has foreign keys that were probably disabled, data was changed, and then the key was enabled again.  Simply enabling the key is not enough for the optimizer to use this key - we have to alter the table using the WITH CHECK CHECK CONSTRAINT parameter.'')
		  from [?].sys.foreign_keys i INNER JOIN [?].sys.objects o ON i.parent_object_id = o.object_id INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_not_trusted = 1 AND i.is_not_for_replication = 0 AND i.is_disabled = 0 AND ''?'' NOT IN (''master'', ''model'', ''msdb'', ''ReportServer'', ''ReportServerTempDB'')';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 56 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 56,
		  ''?'',
		  150,
		  ''Performance'',
		  ''Check Constraint Not Trusted'',
		  ''http://BrentOzar.com/go/trust'',
		  (''The check constraint ['' + DB_NAME() + ''].['' + s.name + ''].['' + o.name + ''].['' + i.name + ''] is not trusted - meaning, it was disabled, data was changed, and then the constraint was enabled again.  Simply enabling the constraint is not enough for the optimizer to use this constraint - we have to alter the table using the WITH CHECK CHECK CONSTRAINT parameter.'')
		  from [?].sys.check_constraints i INNER JOIN [?].sys.objects o ON i.parent_object_id = o.object_id
		  INNER JOIN [?].sys.schemas s ON o.schema_id = s.schema_id
		  WHERE i.is_not_trusted = 1 AND i.is_not_for_replication = 0 AND i.is_disabled = 0';
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 95 )
							BEGIN
								IF @@VERSION NOT LIKE '%Microsoft SQL Server 2000%'
									AND @@VERSION NOT LIKE '%Microsoft SQL Server 2005%'
									BEGIN
										EXEC dbo.sp_MSforeachdb 'USE [?];
			INSERT INTO #BlitzResults
				  (CheckID,
				  DatabaseName,
				  Priority,
				  FindingsGroup,
				  Finding,
				  URL,
				  Details)
			SELECT TOP 1 95 AS CheckID,
			''?'' as DatabaseName,
			110 AS Priority,
			''Performance'' AS FindingsGroup,
			''Plan Guides Enabled'' AS Finding,
			''http://BrentOzar.com/go/guides'' AS URL,
			(''Database ['' + DB_NAME() + ''] has query plan guides so a query will always get a specific execution plan. If you are having trouble getting query performance to improve, it might be due to a frozen plan. Review the DMV sys.plan_guides to learn more about the plan guides in place on this server.'') AS Details
			FROM [?].sys.plan_guides WHERE is_disabled = 0'
									END;
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 60 )
							BEGIN
								EXEC sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT  DISTINCT 60 AS CheckID,
		  ''?'' as DatabaseName,
		  100 AS Priority,
		  ''Performance'' AS FindingsGroup,
		  ''Fill Factor Changed'',
		  ''http://brentozar.com/go/fillfactor'' AS URL,
		  ''The ['' + DB_NAME() + ''] database has objects with fill factor &lt; 80%. This can cause memory and storage performance problems, but may also prevent page splits.''
		  FROM    [?].sys.indexes
		  WHERE   fill_factor &lt;&gt; 0 AND fill_factor &lt; 80 AND is_disabled = 0 AND is_hypothetical = 0';
							END



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 78 )
							BEGIN
                                EXECUTE master.sys.sp_MSforeachdb 'USE [?]; 
                                    INSERT INTO #Recompile 
                                    SELECT DBName = DB_Name(), SPName = SO.name, SM.is_recompiled, ISR.SPECIFIC_SCHEMA 
                                    FROM sys.sql_modules AS SM 
                                    LEFT OUTER JOIN master.sys.databases AS sDB ON SM.object_id = DB_id() 
                                    LEFT OUTER JOIN dbo.sysobjects AS SO ON SM.object_id = SO.id and type = ''P'' 
                                    LEFT OUTER JOIN INFORMATION_SCHEMA.ROUTINES AS ISR on ISR.Routine_Name = SO.name AND ISR.SPECIFIC_CATALOG = DB_Name()
                                    WHERE SM.is_recompiled=1 
                                    ' 
                                INSERT INTO #BlitzResults
													(Priority,
													FindingsGroup,
                                                    Finding,
                                                    DatabaseName,
                                                    URL,
                                                    Details,
                                                    CheckID)
                                SELECT [Priority] = '100', 
                                    FindingsGroup = 'Performance', 
                                    Finding = 'Stored Procedure WITH RECOMPILE',
                                    DatabaseName = DBName,
                                    URL = 'http://BrentOzar.com/go/recompile',
                                    Details = '[' + DBName + '].[' + SPSchema + '].[' + ProcName + '] has WITH RECOMPILE in the stored procedure code, which may cause increased CPU usage due to constant recompiles of the code.',
                                    CheckID = '78'
                                FROM #Recompile AS TR WHERE ProcName NOT LIKE 'sp_AskBrent%' AND ProcName NOT LIKE 'sp_Blitz%' 
                                DROP TABLE #Recompile;
                            END



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 86 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) SELECT DISTINCT 86, DB_NAME(), 230, ''Security'', ''Elevated Permissions on a Database'', ''http://BrentOzar.com/go/elevated'', (''In ['' + DB_NAME() + ''], user ['' + u.name + '']  has the role ['' + g.name + ''].  This user can perform tasks beyond just reading and writing data.'') FROM [?].dbo.sysmembers m inner join [?].dbo.sysusers u on m.memberuid = u.uid inner join sysusers g on m.groupuid = g.uid where u.name &lt;&gt; ''dbo'' and g.name in (''db_owner'' , ''db_accessadmin'' , ''db_securityadmin'' , ''db_ddladmin'')';
							END


							/*Check for non-aligned indexes in partioned databases*/

										IF NOT EXISTS ( SELECT  1
														FROM    #SkipChecks
														WHERE   DatabaseName IS NULL AND CheckID = 72 )
											BEGIN
												EXEC dbo.sp_MSforeachdb 'USE [?];
								insert into #partdb(dbname, objectname, type_desc)
								SELECT distinct db_name(DB_ID()) as DBName,o.name Object_Name,ds.type_desc
								FROM sys.objects AS o JOIN sys.indexes AS i ON o.object_id = i.object_id
								JOIN sys.data_spaces ds on ds.data_space_id = i.data_space_id
								LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s ON i.object_id = s.object_id AND i.index_id = s.index_id AND s.database_id = DB_ID()
								WHERE  o.type = ''u''
								 -- Clustered and Non-Clustered indexes
								AND i.type IN (1, 2)
								AND o.object_id in
								  (
									SELECT a.object_id from
									  (SELECT ob.object_id, ds.type_desc from sys.objects ob JOIN sys.indexes ind on ind.object_id = ob.object_id join sys.data_spaces ds on ds.data_space_id = ind.data_space_id
									  GROUP BY ob.object_id, ds.type_desc ) a group by a.object_id having COUNT (*) &gt; 1
								  )'
												INSERT  INTO #BlitzResults
														( CheckID ,
														  DatabaseName ,
														  Priority ,
														  FindingsGroup ,
														  Finding ,
														  URL ,
														  Details
														)
														SELECT DISTINCT
																72 AS CheckID ,
																dbname AS DatabaseName ,
																100 AS Priority ,
																'Performance' AS FindingsGroup ,
																'The partitioned database ' + dbname
																+ ' may have non-aligned indexes' AS Finding ,
																'http://BrentOzar.com/go/aligned' AS URL ,
																'Having non-aligned indexes on partitioned tables may cause inefficient query plans and CPU pressure' AS Details
														FROM    #partdb
														WHERE   dbname IS NOT NULL
																AND dbname NOT IN ( SELECT DISTINCT
																						  DatabaseName
																					FROM  #SkipChecks 
																					WHERE CheckID IS NULL)
												DROP TABLE #partdb
											END


					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 113 )
									BEGIN
							  EXEC dbo.sp_MSforeachdb 'USE [?];
							  INSERT INTO #BlitzResults
									(CheckID,
									DatabaseName,
									Priority,
									FindingsGroup,
									Finding,
									URL,
									Details)
							  SELECT DISTINCT 113,
							  ''?'',
							  50,
							  ''Reliability'',
							  ''Full Text Indexes Not Updating'',
							  ''http://BrentOzar.com/go/fulltext'',
							  (''At least one full text index in this database has not been crawled in the last week.'')
							  from [?].sys.fulltext_indexes i WHERE change_tracking_state_desc &lt;&gt; ''AUTO'' AND i.is_enabled = 1 AND i.crawl_end_date &lt; DATEADD(dd, -7, GETDATE())';
												END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 115 )
							BEGIN
								EXEC dbo.sp_MSforeachdb 'USE [?];
		  INSERT INTO #BlitzResults
				(CheckID,
				DatabaseName,
				Priority,
				FindingsGroup,
				Finding,
				URL,
				Details)
		  SELECT 115,
		  ''?'',
		  110,
		  ''Performance'',
		  ''Parallelism Rocket Surgery'',
		  ''http://BrentOzar.com/go/makeparallel'',
		  (''['' + DB_NAME() + ''] has a make_parallel function, indicating that an advanced developer may be manhandling SQL Server into forcing queries to go parallel.'')
		  from [?].INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = ''make_parallel'' AND ROUTINE_TYPE = ''FUNCTION''';
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 122 )
							BEGIN
								/* SQL Server 2012 and newer uses temporary stats for AlwaysOn Availability Groups, and those show up as user-created */
								IF EXISTS (SELECT *
									  FROM sys.all_columns c
									  INNER JOIN sys.all_objects o ON c.object_id = o.object_id
									  WHERE c.name = 'is_temporary' AND o.name = 'stats')

										EXEC dbo.sp_MSforeachdb 'USE [?];
												INSERT INTO #BlitzResults
													(CheckID,
													DatabaseName,
													Priority,
													FindingsGroup,
													Finding,
													URL,
													Details)
												SELECT TOP 1 122,
												''?'',
												200,
												''Performance'',
												''User-Created Statistics In Place'',
												''http://BrentOzar.com/go/userstats'',
												(''['' + DB_NAME() + ''] has '' + CAST(SUM(1) AS NVARCHAR(10)) + '' user-created statistics. This indicates that someone is being a rocket scientist with the stats, and might actually be slowing things down, especially during stats updates.'')
												from [?].sys.stats WHERE user_created = 1 AND is_temporary = 0
                                                HAVING SUM(1) &gt; 0;';

									ELSE
										EXEC dbo.sp_MSforeachdb 'USE [?];
												INSERT INTO #BlitzResults
													(CheckID,
													DatabaseName,
													Priority,
													FindingsGroup,
													Finding,
													URL,
													Details)
												SELECT 122,
												''?'',
												200,
												''Performance'',
												''User-Created Statistics In Place'',
												''http://BrentOzar.com/go/userstats'',
												(''['' + DB_NAME() + ''] has '' + CAST(SUM(1) AS NVARCHAR(10)) + '' user-created statistics. This indicates that someone is being a rocket scientist with the stats, and might actually be slowing things down, especially during stats updates.'')
												from [?].sys.stats WHERE user_created = 1
                                                HAVING SUM(1) &gt; 0;';


							END /* IF NOT EXISTS ( SELECT  1 */


		        /*Check for high VLF count: this will omit any database snapshots*/

				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 69 )
					        BEGIN
						        IF @ProductVersionMajor &gt;= 11

							        BEGIN
								        EXEC sp_MSforeachdb N'USE [?];
		                                      INSERT INTO #LogInfo2012
		                                      EXEC sp_executesql N''DBCC LogInfo() WITH NO_INFOMSGS'';
		                                      IF    @@ROWCOUNT &gt; 999
		                                      BEGIN
			                                    INSERT  INTO #BlitzResults
			                                    ( CheckID
			                                    ,DatabaseName
			                                    ,Priority
			                                    ,FindingsGroup
			                                    ,Finding
			                                    ,URL
			                                    ,Details)
			                                    SELECT      69
			                                    ,DB_NAME()
			                                    ,170
			                                    ,''File Configuration''
			                                    ,''High VLF Count''
			                                    ,''http://BrentOzar.com/go/vlf''
			                                    ,''The ['' + DB_NAME() + ''] database has '' +  CAST(COUNT(*) as VARCHAR(20)) + '' virtual log files (VLFs). This may be slowing down startup, restores, and even inserts/updates/deletes.''
			                                    FROM #LogInfo2012
			                                    WHERE EXISTS (SELECT name FROM master.sys.databases
					                                    WHERE source_database_id is null) ;
		                                      END
		                                    TRUNCATE TABLE #LogInfo2012;'
								        DROP TABLE #LogInfo2012;
							        END
						        ELSE
							        BEGIN
								        EXEC sp_MSforeachdb N'USE [?];
		                                      INSERT INTO #LogInfo
		                                      EXEC sp_executesql N''DBCC LogInfo() WITH NO_INFOMSGS'';
		                                      IF    @@ROWCOUNT &gt; 999
		                                      BEGIN
			                                    INSERT  INTO #BlitzResults
			                                    ( CheckID
			                                    ,DatabaseName
			                                    ,Priority
			                                    ,FindingsGroup
			                                    ,Finding
			                                    ,URL
			                                    ,Details)
			                                    SELECT      69
			                                    ,DB_NAME()
			                                    ,170
			                                    ,''File Configuration''
			                                    ,''High VLF Count''
			                                    ,''http://BrentOzar.com/go/vlf''
			                                    ,''The ['' + DB_NAME() + ''] database has '' +  CAST(COUNT(*) as VARCHAR(20)) + '' virtual log files (VLFs). This may be slowing down startup, restores, and even inserts/updates/deletes.''
			                                    FROM #LogInfo
			                                    WHERE EXISTS (SELECT name FROM master.sys.databases
			                                    WHERE source_database_id is null);
		                                      END
		                                      TRUNCATE TABLE #LogInfo;'
								        DROP TABLE #LogInfo;
							        END
					        END


				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 80 )
					        BEGIN
						        EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) SELECT DISTINCT 80, DB_NAME(), 170, ''Reliability'', ''Max File Size Set'', ''http://BrentOzar.com/go/maxsize'', (''The ['' + DB_NAME() + ''] database file '' + name + '' has a max file size set to '' + CAST(CAST(max_size AS BIGINT) * 8 / 1024 AS VARCHAR(100)) + ''MB. If it runs out of space, the database will stop working even though there may be drive space available.'') FROM sys.database_files WHERE max_size &lt;&gt; 268435456 AND max_size &lt;&gt; -1 AND type &lt;&gt; 2 AND name &lt;&gt; ''DWDiagnostics'' ';
					        END

	
						/* Check if columnstore indexes are in use - for Github issue #615 */
				        IF NOT EXISTS ( SELECT  1
								        FROM    #SkipChecks
								        WHERE   DatabaseName IS NULL AND CheckID = 74 ) /* Trace flags */
					        BEGIN
								TRUNCATE TABLE #TemporaryDatabaseResults;
						        EXEC dbo.sp_MSforeachdb 'USE [?]; IF EXISTS(SELECT * FROM sys.indexes WHERE type IN (5,6)) INSERT INTO #TemporaryDatabaseResults (DatabaseName, Finding) VALUES (DB_NAME(), ''Yup'')';
								IF EXISTS (SELECT * FROM #TemporaryDatabaseResults) SET @ColumnStoreIndexesInUse = 1;
					        END


						/* Non-Default Database Scoped Config - Github issue #598 */
				        IF EXISTS ( SELECT * FROM sys.all_objects WHERE [name] = 'database_scoped_configurations' )
					        BEGIN
								INSERT INTO #DatabaseScopedConfigurationDefaults (configuration_id, [name], default_value, default_value_for_secondary, CheckID)
									SELECT 1, 'MAXDOP', 0, NULL, 194
									UNION ALL
									SELECT 2, 'LEGACY_CARDINALITY_ESTIMATION', 0, NULL, 195
									UNION ALL
									SELECT 3, 'PARAMETER_SNIFFING', 1, NULL, 196
									UNION ALL
									SELECT 4, 'QUERY_OPTIMIZER_HOTFIXES', 0, NULL, 197;
						        EXEC dbo.sp_MSforeachdb 'USE [?]; INSERT INTO #BlitzResults (CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details) 
									SELECT def1.CheckID, DB_NAME(), 210, ''Non-Default Database Scoped Config'', dsc.[name], ''http://BrentOzar.com/go/dbscope'', (''Set value: '' + COALESCE(CAST(dsc.value AS NVARCHAR(100)),''Empty'') + '' Default: '' + COALESCE(CAST(def1.default_value AS NVARCHAR(100)),''Empty'') + '' Set value for secondary: '' + COALESCE(CAST(dsc.value_for_secondary AS NVARCHAR(100)),''Empty'') + '' Default value for secondary: '' + COALESCE(CAST(def1.default_value_for_secondary AS NVARCHAR(100)),''Empty''))
									FROM [?].sys.database_scoped_configurations dsc 
									INNER JOIN #DatabaseScopedConfigurationDefaults def1 ON dsc.configuration_id = def1.configuration_id
									LEFT OUTER JOIN #DatabaseScopedConfigurationDefaults def ON dsc.configuration_id = def.configuration_id AND (dsc.value = def.default_value OR dsc.value IS NULL) AND (dsc.value_for_secondary = def.default_value_for_secondary OR dsc.value_for_secondary IS NULL)
									LEFT OUTER JOIN #SkipChecks sk ON def.CheckID = sk.CheckID AND (sk.DatabaseName IS NULL OR sk.DatabaseName = DB_NAME())
									WHERE def.configuration_id IS NULL AND sk.CheckID IS NULL ORDER BY 1';
					        END



	
					END /* IF @CheckUserDatabaseObjects = 1 */

				IF @CheckProcedureCache = 1
					BEGIN

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 35 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  35 AS CheckID ,
												100 AS Priority ,
												'Performance' AS FindingsGroup ,
												'Single-Use Plans in Procedure Cache' AS Finding ,
												'http://BrentOzar.com/go/single' AS URL ,
												( CAST(COUNT(*) AS VARCHAR(10))
												  + ' query plans are taking up memory in the procedure cache. This may be wasted memory if we cache plans for queries that never get called again. This may be a good use case for SQL Server 2008''s Optimize for Ad Hoc or for Forced Parameterization.' ) AS Details
										FROM    sys.dm_exec_cached_plans AS cp
										WHERE   cp.usecounts = 1
												AND cp.objtype = 'Adhoc'
												AND EXISTS ( SELECT
																  1
															 FROM sys.configurations
															 WHERE
																  name = 'optimize for ad hoc workloads'
																  AND value_in_use = 0 )
										HAVING  COUNT(*) &gt; 1;
							END


		  /* Set up the cache tables. Different on 2005 since it doesn't support query_hash, query_plan_hash. */
						IF @@VERSION LIKE '%Microsoft SQL Server 2005%'
							BEGIN
								IF @CheckProcedureCacheFilter = 'CPU'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			  FROM sys.dm_exec_query_stats qs
			  ORDER BY qs.total_worker_time DESC)
			  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			  FROM queries qs
			  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
			  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'Reads'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_logical_reads DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'ExecCount'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.execution_count DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'Duration'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			FROM sys.dm_exec_query_stats qs
			ORDER BY qs.total_elapsed_time DESC)
			INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time])
			SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time]
			FROM queries qs
			LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
			WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

							END;
						IF @ProductVersionMajor &gt;= 10
							BEGIN
								IF @CheckProcedureCacheFilter = 'CPU'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_worker_time DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'Reads'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_logical_reads DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'ExecCount'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.execution_count DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

								IF @CheckProcedureCacheFilter = 'Duration'
									OR @CheckProcedureCacheFilter IS NULL
									BEGIN
										SET @StringToExecute = 'WITH queries ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  AS (SELECT TOP 20 qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM sys.dm_exec_query_stats qs
		  ORDER BY qs.total_elapsed_time DESC)
		  INSERT INTO #dm_exec_query_stats ([sql_handle],[statement_start_offset],[statement_end_offset],[plan_generation_num],[plan_handle],[creation_time],[last_execution_time],[execution_count],[total_worker_time],[last_worker_time],[min_worker_time],[max_worker_time],[total_physical_reads],[last_physical_reads],[min_physical_reads],[max_physical_reads],[total_logical_writes],[last_logical_writes],[min_logical_writes],[max_logical_writes],[total_logical_reads],[last_logical_reads],[min_logical_reads],[max_logical_reads],[total_clr_time],[last_clr_time],[min_clr_time],[max_clr_time],[total_elapsed_time],[last_elapsed_time],[min_elapsed_time],[max_elapsed_time],[query_hash],[query_plan_hash])
		  SELECT qs.[sql_handle],qs.[statement_start_offset],qs.[statement_end_offset],qs.[plan_generation_num],qs.[plan_handle],qs.[creation_time],qs.[last_execution_time],qs.[execution_count],qs.[total_worker_time],qs.[last_worker_time],qs.[min_worker_time],qs.[max_worker_time],qs.[total_physical_reads],qs.[last_physical_reads],qs.[min_physical_reads],qs.[max_physical_reads],qs.[total_logical_writes],qs.[last_logical_writes],qs.[min_logical_writes],qs.[max_logical_writes],qs.[total_logical_reads],qs.[last_logical_reads],qs.[min_logical_reads],qs.[max_logical_reads],qs.[total_clr_time],qs.[last_clr_time],qs.[min_clr_time],qs.[max_clr_time],qs.[total_elapsed_time],qs.[last_elapsed_time],qs.[min_elapsed_time],qs.[max_elapsed_time],qs.[query_hash],qs.[query_plan_hash]
		  FROM queries qs
		  LEFT OUTER JOIN #dm_exec_query_stats qsCaught ON qs.sql_handle = qsCaught.sql_handle AND qs.plan_handle = qsCaught.plan_handle AND qs.statement_start_offset = qsCaught.statement_start_offset
		  WHERE qsCaught.sql_handle IS NULL;'
										EXECUTE(@StringToExecute)
									END

		/* Populate the query_plan_filtered field. Only works in 2005SP2+, but we're just doing it in 2008 to be safe. */
								UPDATE  #dm_exec_query_stats
								SET     query_plan_filtered = qp.query_plan
								FROM    #dm_exec_query_stats qs
										CROSS APPLY sys.dm_exec_text_query_plan(qs.plan_handle,
																  qs.statement_start_offset,
																  qs.statement_end_offset)
										AS qp

							END;

		/* Populate the additional query_plan, text, and text_filtered fields */
						UPDATE  #dm_exec_query_stats
						SET     query_plan = qp.query_plan ,
								[text] = st.[text] ,
								text_filtered = SUBSTRING(st.text,
														  ( qs.statement_start_offset
															/ 2 ) + 1,
														  ( ( CASE qs.statement_end_offset
																WHEN -1
																THEN DATALENGTH(st.text)
																ELSE qs.statement_end_offset
															  END
															  - qs.statement_start_offset )
															/ 2 ) + 1)
						FROM    #dm_exec_query_stats qs
								CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
								CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle)
								AS qp

		/* Dump instances of our own script. We're not trying to tune ourselves. */
						DELETE  #dm_exec_query_stats
						WHERE   text LIKE '%sp_Blitz%'
								OR text LIKE '%#BlitzResults%'

		/* Look for implicit conversions */

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 63 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  63 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Implicit Conversion' AS Finding ,
												'http://BrentOzar.com/go/implicit' AS URL ,
												( 'One of the top resource-intensive queries is comparing two fields that are not the same datatype.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%CONVERT_IMPLICIT%'
												AND COALESCE(qs.query_plan_filtered,
															 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%PhysicalOp="Index Scan"%'
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 64 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  64 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Implicit Conversion Affecting Cardinality' AS Finding ,
												'http://BrentOzar.com/go/implicit' AS URL ,
												( 'One of the top resource-intensive queries has an implicit conversion that is affecting cardinality estimation.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%&lt;PlanAffectingConvert ConvertIssue="Cardinality Estimate" Expression="CONVERT_IMPLICIT%'
							END

							/* @cms4j, 29.11.2013: Look for RID or Key Lookups */
							IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 118 )
								BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details ,
											  QueryPlan ,
											  QueryPlanFiltered
											)
											SELECT  118 AS CheckID ,
													120 AS Priority ,
													'Query Plans' AS FindingsGroup ,
													'RID or Key Lookups' AS Finding ,
													'http://BrentOzar.com/go/lookup' AS URL ,
													'One of the top resource-intensive queries contains RID or Key Lookups. Try to avoid them by creating covering indexes.' AS Details ,
													qs.query_plan ,
													qs.query_plan_filtered
											FROM    #dm_exec_query_stats qs
											WHERE   COALESCE(qs.query_plan_filtered,
															 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%Lookup="1"%'
								END /* @cms4j, 29.11.2013: Look for RID or Key Lookups */


						/* Look for missing indexes */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 65 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  65 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Missing Index' AS Finding ,
												'http://BrentOzar.com/go/missingindex' AS URL ,
												( 'One of the top resource-intensive queries may be dramatically improved by adding an index.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%MissingIndexGroup%'
							END

						/* Look for cursors */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 66 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  66 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Cursor' AS Finding ,
												'http://BrentOzar.com/go/cursor' AS URL ,
												( 'One of the top resource-intensive queries is using a cursor.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%&lt;StmtCursor%'
							END

		/* Look for scalar user-defined functions */

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 67 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details ,
										  QueryPlan ,
										  QueryPlanFiltered
										)
										SELECT  67 AS CheckID ,
												120 AS Priority ,
												'Query Plans' AS FindingsGroup ,
												'Scalar UDFs' AS Finding ,
												'http://BrentOzar.com/go/functions' AS URL ,
												( 'One of the top resource-intensive queries is using a user-defined scalar function that may inhibit parallelism.' ) AS Details ,
												qs.query_plan ,
												qs.query_plan_filtered
										FROM    #dm_exec_query_stats qs
										WHERE   COALESCE(qs.query_plan_filtered,
														 CAST(qs.query_plan AS NVARCHAR(MAX))) LIKE '%&lt;UserDefinedFunction%'
							END

					END /* IF @CheckProcedureCache = 1 */
									  
		/*Check to see if the HA endpoint account is set at the same as the SQL Server Service Account*/
		IF @ProductVersionMajor &gt;= 10
								AND NOT EXISTS ( SELECT 1
								FROM #SkipChecks
								WHERE DatabaseName IS NULL AND CheckID = 187 )

		IF SERVERPROPERTY('IsHadrEnabled') = 1
    		BEGIN
                INSERT    INTO [#BlitzResults]
                               	( [CheckID] ,
                                [Priority] ,
                                [FindingsGroup] ,
                                [Finding] ,
                                [URL] ,
                                [Details] )
               	SELECT
                        187 AS [CheckID] ,
                        230 AS [Priority] ,
                        'Security' AS [FindingsGroup] ,
                        'Endpoints Owned by Users' AS [Finding] ,
                       	'http://BrentOzar.com/go/owners' AS [URL] ,
                        ( 'Endpoint ' + ep.[name] + ' is owned by ' + SUSER_NAME(ep.principal_id) + '. If the endpoint owner login is disabled or not available due to Active Directory problems, the high availability will stop working.'
                        ) AS [Details]
					FROM sys.database_mirroring_endpoints ep
					LEFT OUTER JOIN sys.dm_server_services s ON SUSER_NAME(ep.principal_id) = s.service_account
					WHERE s.service_account IS NULL;
    		END

		/*Check for the last good DBCC CHECKDB date */
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 68 )
					BEGIN
						EXEC sp_MSforeachdb N'USE [?];
						INSERT #DBCCs
							(ParentObject,
							Object,
							Field,
							Value)
						EXEC (''DBCC DBInfo() With TableResults, NO_INFOMSGS'');
						UPDATE #DBCCs SET DbName = N''?'' WHERE DbName IS NULL;';

						WITH    DB2
								  AS ( SELECT DISTINCT
												Field ,
												Value ,
												DbName
									   FROM     #DBCCs
									   WHERE    Field = 'dbi_dbccLastKnownGood'
									 )
							INSERT  INTO #BlitzResults
									( CheckID ,
									  DatabaseName ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  68 AS CheckID ,
											DB2.DbName AS DatabaseName ,
											1 AS PRIORITY ,
											'Reliability' AS FindingsGroup ,
											'Last good DBCC CHECKDB over 2 weeks old' AS Finding ,
											'http://BrentOzar.com/go/checkdb' AS URL ,
											'Last successful CHECKDB: '
											+ CASE DB2.Value
												WHEN '1900-01-01 00:00:00.000'
												THEN ' never.'
												ELSE DB2.Value
											  END AS Details
									FROM    DB2
									WHERE   DB2.DbName &lt;&gt; 'tempdb'
											AND DB2.DbName NOT IN ( SELECT DISTINCT
																  DatabaseName
																FROM
																  #SkipChecks 
																WHERE CheckID IS NULL)
											AND CONVERT(DATETIME, DB2.Value, 121) &lt; DATEADD(DD,
																  -14,
																  CURRENT_TIMESTAMP)
					END




	/*Verify that the servername is set */
			IF NOT EXISTS ( SELECT  1
							FROM    #SkipChecks
							WHERE   DatabaseName IS NULL AND CheckID = 70 )
				BEGIN
					IF @@SERVERNAME IS NULL
						BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  70 AS CheckID ,
											200 AS Priority ,
											'Informational' AS FindingsGroup ,
											'@@Servername Not Set' AS Finding ,
											'http://BrentOzar.com/go/servername' AS URL ,
											'@@Servername variable is null. You can fix it by executing: "sp_addserver ''&lt;LocalServerName&gt;'', local"' AS Details
						END;

					IF  /* @@SERVERNAME IS set */
						(@@SERVERNAME IS NOT NULL
						AND
						/* not a named instance */
						CHARINDEX('\',CAST(SERVERPROPERTY('ServerName') AS NVARCHAR)) = 0
						AND
						/* not clustered, when computername may be different than the servername */
						SERVERPROPERTY('IsClustered') = 0
						AND
						/* @@SERVERNAME is different than the computer name */
						@@SERVERNAME &lt;&gt; CAST(ISNULL(SERVERPROPERTY('ComputerNamePhysicalNetBIOS'),@@SERVERNAME) AS NVARCHAR) )
						 BEGIN
							INSERT  INTO #BlitzResults
									( CheckID ,
									  Priority ,
									  FindingsGroup ,
									  Finding ,
									  URL ,
									  Details
									)
									SELECT  70 AS CheckID ,
											200 AS Priority ,
											'Configuration' AS FindingsGroup ,
											'@@Servername Not Correct' AS Finding ,
											'http://BrentOzar.com/go/servername' AS URL ,
											'The @@Servername is different than the computer name, which may trigger certificate errors.' AS Details
						END;

				END
		/*Check to see if a failsafe operator has been configured*/
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 73 )
					BEGIN

						DECLARE @AlertInfo TABLE
							(
							  FailSafeOperator NVARCHAR(255) ,
							  NotificationMethod INT ,
							  ForwardingServer NVARCHAR(255) ,
							  ForwardingSeverity INT ,
							  PagerToTemplate NVARCHAR(255) ,
							  PagerCCTemplate NVARCHAR(255) ,
							  PagerSubjectTemplate NVARCHAR(255) ,
							  PagerSendSubjectOnly NVARCHAR(255) ,
							  ForwardAlways INT
							)
						INSERT  INTO @AlertInfo
								EXEC [master].[dbo].[sp_MSgetalertinfo] @includeaddresses = 0
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  73 AS CheckID ,
										200 AS Priority ,
										'Monitoring' AS FindingsGroup ,
										'No failsafe operator configured' AS Finding ,
										'http://BrentOzar.com/go/failsafe' AS URL ,
										( 'No failsafe operator is configured on this server.  This is a good idea just in-case there are issues with the [msdb] database that prevents alerting.' ) AS Details
								FROM    @AlertInfo
								WHERE   FailSafeOperator IS NULL;
					END

/*Identify globally enabled trace flags*/
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 74 )
					BEGIN
						INSERT  INTO #TraceStatus
								EXEC ( ' DBCC TRACESTATUS(-1) WITH NO_INFOMSGS'
									)
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  74 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'TraceFlag On' AS Finding ,
										CASE WHEN [T].[TraceFlag] = '834'  AND @ColumnStoreIndexesInUse = 1 THEN 'https://support.microsoft.com/en-us/kb/3210239'
											 ELSE'http://www.BrentOzar.com/go/traceflags/' END AS URL ,
										'Trace flag ' + 
										CASE WHEN [T].[TraceFlag] = '2330' THEN ' 2330 enabled globally. Using this trace Flag disables missing index requests'
											 WHEN [T].[TraceFlag] = '1211' THEN ' 1211 enabled globally. Using this Trace Flag disables lock escalation when you least expect it. No Bueno!'
											 WHEN [T].[TraceFlag] = '1224' THEN ' 1224 enabled globally. Using this Trace Flag disables lock escalation based on the number of locks being taken. You shouldn''t have done that, Dave.'
											 WHEN [T].[TraceFlag] = '652'  THEN ' 652 enabled globally. Using this Trace Flag disables pre-fetching during index scans. If you hate slow queries, you should turn that off.'
											 WHEN [T].[TraceFlag] = '661'  THEN ' 661 enabled globally. Using this Trace Flag disables ghost record removal. Who you gonna call? No one, turn that thing off.'
											 WHEN [T].[TraceFlag] = '1806'  THEN ' 1806 enabled globally. Using this Trace Flag disables instant file initialization. I question your sanity.'
											 WHEN [T].[TraceFlag] = '3505'  THEN ' 3505 enabled globally. Using this Trace Flag disables Checkpoints. Probably not the wisest idea.'
											 WHEN [T].[TraceFlag] = '8649'  THEN ' 8649 enabled globally. Using this Trace Flag drops cost thresholf for parallelism down to 0. I hope this is a dev server.'
										     WHEN [T].[TraceFlag] = '834' AND @ColumnStoreIndexesInUse = 1 THEN ' 834 is enabled globally. Using this Trace Flag with Columnstore Indexes is not a great idea.'
											 ELSE [T].[TraceFlag] + ' is enabled globally.' END 
										AS Details
								FROM    #TraceStatus T
					END

		/*Check for transaction log file larger than data file */
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 75 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  75 AS CheckID ,
										DB_NAME(a.database_id) ,
										50 AS Priority ,
										'Reliability' AS FindingsGroup ,
										'Transaction Log Larger than Data File' AS Finding ,
										'http://BrentOzar.com/go/biglog' AS URL ,
										'The database [' + DB_NAME(a.database_id)
										+ '] has a ' + CAST((CAST(a.size AS BIGINT) * 8 / 1000000) AS NVARCHAR(20)) + ' GB transaction log file, larger than the total data file sizes. This may indicate that transaction log backups are not being performed or not performed often enough.' AS Details
								FROM    sys.master_files a
								WHERE   a.type = 1
										AND DB_NAME(a.database_id) NOT IN (
										SELECT DISTINCT
												DatabaseName
										FROM    #SkipChecks )
										AND a.size &gt; 125000 /* Size is measured in pages here, so this gets us log files over 1GB. */
										AND a.size &gt; ( SELECT   SUM(CAST(b.size AS BIGINT))
													   FROM     sys.master_files b
													   WHERE    a.database_id = b.database_id
																AND b.type = 0
													 )
										AND a.database_id IN (
										SELECT  database_id
										FROM    sys.databases
										WHERE   source_database_id IS NULL )
					END

		/*Check for collation conflicts between user databases and tempdb */
				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 76 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  76 AS CheckID ,
										name AS DatabaseName ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Collation is ' + collation_name AS Finding ,
										'http://BrentOzar.com/go/collate' AS URL ,
										'Collation differences between user databases and tempdb can cause conflicts especially when comparing string values' AS Details
								FROM    sys.databases
							WHERE   name NOT IN ( 'master', 'model', 'msdb')
										AND name NOT LIKE 'ReportServer%'
										AND name NOT IN ( SELECT DISTINCT
																  DatabaseName
														  FROM    #SkipChecks 
														  WHERE CheckID IS NULL)
										AND collation_name &lt;&gt; ( SELECT
																  collation_name
																FROM
																  sys.databases
																WHERE
																  name = 'tempdb'
															  )
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 77 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  DatabaseName ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  77 AS CheckID ,
										dSnap.[name] AS DatabaseName ,
										50 AS Priority ,
										'Reliability' AS FindingsGroup ,
										'Database Snapshot Online' AS Finding ,
										'http://BrentOzar.com/go/snapshot' AS URL ,
										'Database [' + dSnap.[name]
										+ '] is a snapshot of ['
										+ dOriginal.[name]
										+ ']. Make sure you have enough drive space to maintain the snapshot as the original database grows.' AS Details
								FROM    sys.databases dSnap
										INNER JOIN sys.databases dOriginal ON dSnap.source_database_id = dOriginal.database_id
																  AND dSnap.name NOT IN (
																  SELECT DISTINCT
																  DatabaseName
																  FROM
																  #SkipChecks )
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 79 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  79 AS CheckID ,
										100 AS Priority ,
										'Performance' AS FindingsGroup ,
										'Shrink Database Job' AS Finding ,
										'http://BrentOzar.com/go/autoshrink' AS URL ,
										'In the [' + j.[name] + '] job, step ['
										+ step.[step_name]
										+ '] has SHRINKDATABASE or SHRINKFILE, which may be causing database fragmentation.' AS Details
								FROM    msdb.dbo.sysjobs j
										INNER JOIN msdb.dbo.sysjobsteps step ON j.job_id = step.job_id
								WHERE   step.command LIKE N'%SHRINKDATABASE%'
										OR step.command LIKE N'%SHRINKFILE%'
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 81 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT  81 AS CheckID ,
										200 AS Priority ,
										'Non-Active Server Config' AS FindingsGroup ,
										cr.name AS Finding ,
										'http://www.BrentOzar.com/blitz/sp_configure/' AS URL ,
										( 'This sp_configure option isn''t running under its set value.  Its set value is '
										  + CAST(cr.[value] AS VARCHAR(100))
										  + ' and its running value is '
										  + CAST(cr.value_in_use AS VARCHAR(100))
										  + '. When someone does a RECONFIGURE or restarts the instance, this setting will start taking effect.' ) AS Details
								FROM    sys.configurations cr
								WHERE   cr.value &lt;&gt; cr.value_in_use
                                 AND NOT (cr.name = 'min server memory (MB)' AND cr.value IN (0,16) AND cr.value_in_use IN (0,16));
					END

				IF NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 123 )
					BEGIN
						INSERT  INTO #BlitzResults
								( CheckID ,
								  Priority ,
								  FindingsGroup ,
								  Finding ,
								  URL ,
								  Details
								)
								SELECT TOP 1 123 AS CheckID ,
										200 AS Priority ,
										'Informational' AS FindingsGroup ,
										'Agent Jobs Starting Simultaneously' AS Finding ,
										'http://BrentOzar.com/go/busyagent/' AS URL ,
										( 'Multiple SQL Server Agent jobs are configured to start simultaneously. For detailed schedule listings, see the query in the URL.' ) AS Details
								FROM    msdb.dbo.sysjobactivity
								WHERE start_execution_date &gt; DATEADD(dd, -14, GETDATE())
								GROUP BY start_execution_date HAVING COUNT(*) &gt; 1;
					END


				IF @CheckServerInfo = 1
					BEGIN

/*This checks Windows version. It would be better if Microsoft gave everything a separate build number, but whatever.*/
IF @ProductVersionMajor &gt;= 10 AND @ProductVersionMinor &gt;= 50 
			   AND NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 172 )
					BEGIN
					IF EXISTS ( SELECT  1
											FROM    sys.all_objects
											WHERE   name = 'dm_os_windows_info' )

					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )

							SELECT
							172 AS [CheckID] ,
							250 AS [Priority] ,
							'Server Info' AS [FindingsGroup] ,
							'Windows Version' AS [Finding] ,
							'https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions' AS [URL] ,
							( CASE 
								WHEN [owi].[windows_release] = '5' THEN 'You''re running a really old version: Windows 2000, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] &gt; '5' AND [owi].[windows_release] &lt; '6' THEN 'You''re running a really old version: Windows Server 2003/2003R2 era, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] &gt;= '6' AND [owi].[windows_release] &lt;= '6.1' THEN 'You''re running a pretty old version: Windows: Server 2008/2008R2 era, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] = '6.2' THEN 'You''re running a rather modern version of Windows: Server 2012 era, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] = '6.3' THEN 'You''re running a pretty modern version of Windows: Server 2012R2 era, version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								WHEN [owi].[windows_release] &gt; '6.3' THEN 'Hot dog! You''re living in the future! You''re running version ' + CAST([owi].[windows_release] AS VARCHAR(5))
								ELSE 'I have no idea which version of Windows you''re on. Sorry.'
								END
							   ) AS [Details]
							 FROM [sys].[dm_os_windows_info] [owi]

					END;
					END;

/*
This check hits the dm_os_process_memory system view
to see if locked_page_allocations_kb is &gt; 0,
which could indicate that locked pages in memory is enabled.
*/
IF @ProductVersionMajor &gt;= 10 AND  NOT EXISTS ( SELECT  1
								FROM    #SkipChecks
								WHERE   DatabaseName IS NULL AND CheckID = 166 )
					BEGIN
						  INSERT    INTO [#BlitzResults]
									( [CheckID] ,
									  [Priority] ,
									  [FindingsGroup] ,
									  [Finding] ,
									  [URL] ,
									  [Details] )
							SELECT
							166 AS [CheckID] ,
							250 AS [Priority] ,
							'Server Info' AS [FindingsGroup] ,
							'Locked Pages In Memory Enabled' AS [Finding] ,
							'http://BrentOzar.com/go/lpim' AS [URL] ,
							( 'You currently have '
							  + CASE WHEN [dopm].[locked_page_allocations_kb] / 1024. / 1024. &gt; 0
									 THEN CAST([dopm].[locked_page_allocations_kb] / 1024. / 1024. AS VARCHAR(100))
										  + ' GB'
									 ELSE CAST([dopm].[locked_page_allocations_kb] / 1024. AS VARCHAR(100))
										  + ' MB'
								END + ' of pages locked in memory.' ) AS [Details]
						  FROM
							[sys].[dm_os_process_memory] AS [dopm]
						  WHERE
							[dopm].[locked_page_allocations_kb] &gt; 0;
					END; 

			/* Server Info - Locked Pages In Memory Enabled - Check 166 - SQL Server 2016 SP1 and newer */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 166 )
							AND EXISTS ( SELECT  *
											FROM    sys.all_objects o
													INNER JOIN sys.all_columns c ON o.object_id = c.object_id
											WHERE   o.name = 'dm_os_sys_info'
													AND c.name = 'sql_memory_model' )
							BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  166 AS CheckID ,
			250 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Memory Model Unconventional'' AS Finding ,
			''http://BrentOzar.com/go/lpim'' AS URL ,
			''Memory Model: '' + CAST(sql_memory_model_desc AS NVARCHAR(100))
			FROM sys.dm_os_sys_info WHERE sql_memory_model &lt;&gt; 1';
										EXECUTE(@StringToExecute);
									END



			/*
			Starting with SQL Server 2014 SP2, Instant File Initialization 
			is logged in the SQL Server Error Log.
			*/
					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 184 )
							AND (@ProductVersionMajor &gt;= 13) OR (@ProductVersionMajor = 12 AND @ProductVersionMinor &gt;= 5000)
						BEGIN
							INSERT INTO #ErrorLog
							EXEC sys.xp_readerrorlog 0, 1, N'Database Instant File Initialization: enabled';

							IF @@ROWCOUNT &gt; 0
								INSERT  INTO #BlitzResults
										( CheckID ,
										  [Priority] ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT
												193 AS [CheckID] ,
												250 AS [Priority] ,
												'Server Info' AS [FindingsGroup] ,
												'Instant File Initialization Enabled' AS [Finding] ,
												'http://BrentOzar.com/go/instant' AS [URL] ,
												'The service account has the Perform Volume Maintenance Tasks permission.'
						END; 

			/* Server Info - Instant File Initialization Not Enabled - Check 192 - SQL Server 2016 SP1 and newer */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 192 )
							AND EXISTS ( SELECT  *
											FROM    sys.all_objects o
													INNER JOIN sys.all_columns c ON o.object_id = c.object_id
											WHERE   o.name = 'dm_server_services'
													AND c.name = 'instant_file_initialization_enabled' )
							BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  192 AS CheckID ,
			50 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Instant File Initialization Not Enabled'' AS Finding ,
			''http://BrentOzar.com/go/instant'' AS URL ,
			''Consider enabling IFI for faster restores and data file growths.''
			FROM sys.dm_server_services WHERE instant_file_initialization_enabled &lt;&gt; ''Y'' AND filename LIKE ''%sqlservr.exe%''';
										EXECUTE(@StringToExecute);
									END





					IF NOT EXISTS ( SELECT  1
									FROM    #SkipChecks
									WHERE   DatabaseName IS NULL AND CheckID = 130 )
						BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
											SELECT  130 AS CheckID ,
													250 AS Priority ,
													'Server Info' AS FindingsGroup ,
													'Server Name' AS Finding ,
													'http://BrentOzar.com/go/servername' AS URL ,
													@@SERVERNAME AS Details
												WHERE @@SERVERNAME IS NOT NULL;
								END;



						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 83 )
							BEGIN
								IF EXISTS ( SELECT  *
											FROM    sys.all_objects
											WHERE   name = 'dm_server_services' )
									BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
				SELECT  83 AS CheckID ,
				250 AS Priority ,
				''Server Info'' AS FindingsGroup ,
				''Services'' AS Finding ,
				'''' AS URL ,
				N''Service: '' + servicename + N'' runs under service account '' + service_account + N''. Last startup time: '' + COALESCE(CAST(CAST(last_startup_time AS DATETIME) AS VARCHAR(50)), ''not shown.'') + ''. Startup type: '' + startup_type_desc + N'', currently '' + status_desc + ''.''
				FROM sys.dm_server_services;'
										EXECUTE(@StringToExecute);
									END
							END

			/* Check 84 - SQL Server 2012 */
						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 84 )
							BEGIN
								IF EXISTS ( SELECT  *
											FROM    sys.all_objects o
													INNER JOIN sys.all_columns c ON o.object_id = c.object_id
											WHERE   o.name = 'dm_os_sys_info'
													AND c.name = 'physical_memory_kb' )
									BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  84 AS CheckID ,
			250 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Hardware'' AS Finding ,
			'''' AS URL ,
			''Logical processors: '' + CAST(cpu_count AS VARCHAR(50)) + ''. Physical memory: '' + CAST( CAST(ROUND((physical_memory_kb / 1024.0 / 1024), 1) AS INT) AS VARCHAR(50)) + ''GB.''
			FROM sys.dm_os_sys_info';
										EXECUTE(@StringToExecute);
									END

			/* Check 84 - SQL Server 2008 */
								IF EXISTS ( SELECT  *
											FROM    sys.all_objects o
													INNER JOIN sys.all_columns c ON o.object_id = c.object_id
											WHERE   o.name = 'dm_os_sys_info'
													AND c.name = 'physical_memory_in_bytes' )
									BEGIN
										SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
			SELECT  84 AS CheckID ,
			250 AS Priority ,
			''Server Info'' AS FindingsGroup ,
			''Hardware'' AS Finding ,
			'''' AS URL ,
			''Logical processors: '' + CAST(cpu_count AS VARCHAR(50)) + ''. Physical memory: '' + CAST( CAST(ROUND((physical_memory_in_bytes / 1024.0 / 1024 / 1024), 1) AS INT) AS VARCHAR(50)) + ''GB.''
			FROM sys.dm_os_sys_info';
										EXECUTE(@StringToExecute);
									END
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 85 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  85 AS CheckID ,
												250 AS Priority ,
												'Server Info' AS FindingsGroup ,
												'SQL Server Service' AS Finding ,
												'' AS URL ,
												N'Version: '
												+ CAST(SERVERPROPERTY('productversion') AS NVARCHAR(100))
												+ N'. Patch Level: '
												+ CAST(SERVERPROPERTY('productlevel') AS NVARCHAR(100))
												+ N'. Edition: '
												+ CAST(SERVERPROPERTY('edition') AS VARCHAR(100))
												+ N'. AlwaysOn Enabled: '
												+ CAST(COALESCE(SERVERPROPERTY('IsHadrEnabled'),
																0) AS VARCHAR(100))
												+ N'. AlwaysOn Mgr Status: '
												+ CAST(COALESCE(SERVERPROPERTY('HadrManagerStatus'),
																0) AS VARCHAR(100))
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 88 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  88 AS CheckID ,
												250 AS Priority ,
												'Server Info' AS FindingsGroup ,
												'SQL Server Last Restart' AS Finding ,
												'' AS URL ,
												CAST(create_date AS VARCHAR(100))
										FROM    sys.databases
										WHERE   database_id = 2
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 91 )
							BEGIN
								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  91 AS CheckID ,
												250 AS Priority ,
												'Server Info' AS FindingsGroup ,
												'Server Last Restart' AS Finding ,
												'' AS URL ,
												CAST(DATEADD(SECOND, (ms_ticks/1000)*(-1), GETDATE()) AS nvarchar(25))
										FROM sys.dm_os_sys_info
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 92 )
							BEGIN
								INSERT  INTO #driveInfo
										( drive, SIZE )
										EXEC master..xp_fixeddrives

								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT  92 AS CheckID ,
												250 AS Priority ,
												'Server Info' AS FindingsGroup ,
												'Drive ' + i.drive + ' Space' AS Finding ,
												'' AS URL ,
												CAST(i.SIZE AS VARCHAR)
												+ 'MB free on ' + i.drive
												+ ' drive' AS Details
										FROM    #driveInfo AS i
								DROP TABLE #driveInfo
							END


						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 103 )
							AND EXISTS ( SELECT *
										 FROM   sys.all_objects o
												INNER JOIN sys.all_columns c ON o.object_id = c.object_id
										 WHERE  o.name = 'dm_os_sys_info'
												AND c.name = 'virtual_machine_type_desc' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
									SELECT 103 AS CheckID,
									250 AS Priority,
									''Server Info'' AS FindingsGroup,
									''Virtual Server'' AS Finding,
									''http://BrentOzar.com/go/virtual'' AS URL,
									''Type: ('' + virtual_machine_type_desc + '')'' AS Details
									FROM sys.dm_os_sys_info
									WHERE virtual_machine_type &lt;&gt; 0';
								EXECUTE(@StringToExecute);
							END

						IF NOT EXISTS ( SELECT  1
										FROM    #SkipChecks
										WHERE   DatabaseName IS NULL AND CheckID = 114 )
							AND EXISTS ( SELECT *
										 FROM   sys.all_objects o
										 WHERE  o.name = 'dm_os_memory_nodes' )
							AND EXISTS ( SELECT *
										 FROM   sys.all_objects o
										 INNER JOIN sys.all_columns c ON o.object_id = c.object_id
										 WHERE  o.name = 'dm_os_nodes'
                                	 		AND c.name = 'processor_group' )
							BEGIN
								SET @StringToExecute = 'INSERT INTO #BlitzResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
										SELECT  114 AS CheckID ,
												250 AS Priority ,
												''Server Info'' AS FindingsGroup ,
												''Hardware - NUMA Config'' AS Finding ,
												'''' AS URL ,
												''Node: '' + CAST(n.node_id AS NVARCHAR(10)) + '' State: '' + node_state_desc
												+ '' Online schedulers: '' + CAST(n.online_scheduler_count AS NVARCHAR(10)) + '' Offline schedulers: '' + CAST(oac.offline_schedulers AS VARCHAR(100)) + '' Processor Group: '' + CAST(n.processor_group AS NVARCHAR(10))
												+ '' Memory node: '' + CAST(n.memory_node_id AS NVARCHAR(10)) + '' Memory VAS Reserved GB: '' + CAST(CAST((m.virtual_address_space_reserved_kb / 1024.0 / 1024) AS INT) AS NVARCHAR(100))
										FROM sys.dm_os_nodes n
										INNER JOIN sys.dm_os_memory_nodes m ON n.memory_node_id = m.memory_node_id
										OUTER APPLY (SELECT 
										COUNT(*) AS [offline_schedulers]
										FROM sys.dm_os_schedulers dos
										WHERE n.node_id = dos.parent_node_id 
										AND dos.status = ''VISIBLE OFFLINE''
										) oac
										WHERE n.node_state_desc NOT LIKE ''%DAC%''
										ORDER BY n.node_id'
								EXECUTE(@StringToExecute);
							END


							IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 106 )
											AND (select convert(int,value_in_use) from sys.configurations where name = 'default trace enabled' ) = 1
                                AND DATALENGTH( COALESCE( @base_tracefilename, '' ) ) &gt; DATALENGTH('.TRC')
							BEGIN

								INSERT  INTO #BlitzResults
										( CheckID ,
										  Priority ,
										  FindingsGroup ,
										  Finding ,
										  URL ,
										  Details
										)
										SELECT
												 106 AS CheckID
												,250 AS Priority
												,'Server Info' AS FindingsGroup
												,'Default Trace Contents' AS Finding
												,'http://BrentOzar.com/go/trace' AS URL
												,'The default trace holds '+cast(DATEDIFF(hour,MIN(StartTime),GETDATE())as varchar)+' hours of data'
												+' between '+cast(Min(StartTime) as varchar)+' and '+cast(GETDATE()as varchar)
												+('. The default trace files are located in: '+left( @curr_tracefilename,len(@curr_tracefilename) - @indx)
												) as Details
										FROM    ::fn_trace_gettable( @base_tracefilename, default )
										WHERE EventClass BETWEEN 65500 and 65600
							END /* CheckID 106 */


							IF NOT EXISTS ( SELECT  1
											FROM    #SkipChecks
											WHERE   DatabaseName IS NULL AND CheckID = 152 )
							BEGIN
								IF EXISTS (SELECT * FROM sys.dm_os_wait_stats ws
											LEFT OUTER JOIN #IgnorableWaits i ON ws.wait_type = i.wait_type
											WHERE wait_time_ms &gt; .1 * @CpuMsSinceWaitsCleared AND waiting_tasks_count &gt; 0 
											AND i.wait_type IS NULL)
									BEGIN
									/* Check for waits that have had more than 10% of the server's wait time */
									WITH os(wait_type, waiting_tasks_count, wait_time_ms, max_wait_time_ms, signal_wait_time_ms)
									AS
									(SELECT ws.wait_type, waiting_tasks_count, wait_time_ms, max_wait_time_ms, signal_wait_time_ms
										FROM sys.dm_os_wait_stats ws
										LEFT OUTER JOIN #IgnorableWaits i ON ws.wait_type = i.wait_type
											WHERE i.wait_type IS NULL 
												AND wait_time_ms &gt; .1 * @CpuMsSinceWaitsCleared
												AND waiting_tasks_count &gt; 0)
									INSERT  INTO #BlitzResults
											( CheckID ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
											SELECT TOP 9
													 152 AS CheckID
													,240 AS Priority
													,'Wait Stats' AS FindingsGroup
													, CAST(ROW_NUMBER() OVER(ORDER BY os.wait_time_ms DESC) AS NVARCHAR(10)) + N' - ' + os.wait_type AS Finding
													,'http://BrentOzar.com/go/waits' AS URL
													, Details = CAST(CAST(SUM(os.wait_time_ms / 1000.0 / 60 / 60) OVER (PARTITION BY os.wait_type) AS NUMERIC(18,1)) AS NVARCHAR(20)) + N' hours of waits, ' +
													CAST(CAST((SUM(60.0 * os.wait_time_ms) OVER (PARTITION BY os.wait_type) ) / @MsSinceWaitsCleared  AS NUMERIC(18,1)) AS NVARCHAR(20)) + N' minutes average wait time per hour, ' + 
													/* CAST(CAST(
														100.* SUM(os.wait_time_ms) OVER (PARTITION BY os.wait_type) 
														/ (1. * SUM(os.wait_time_ms) OVER () )
														AS NUMERIC(18,1)) AS NVARCHAR(40)) + N'% of waits, ' + */
													CAST(CAST(
														100. * SUM(os.signal_wait_time_ms) OVER (PARTITION BY os.wait_type) 
														/ (1. * SUM(os.wait_time_ms) OVER ())
														AS NUMERIC(18,1)) AS NVARCHAR(40)) + N'% signal wait, ' + 
													CAST(SUM(os.waiting_tasks_count) OVER (PARTITION BY os.wait_type) AS NVARCHAR(40)) + N' waiting tasks, ' +
													CAST(CASE WHEN  SUM(os.waiting_tasks_count) OVER (PARTITION BY os.wait_type) &gt; 0
													THEN
														CAST(
															SUM(os.wait_time_ms) OVER (PARTITION BY os.wait_type)
																/ (1. * SUM(os.waiting_tasks_count) OVER (PARTITION BY os.wait_type)) 
															AS NUMERIC(18,1))
													ELSE 0 END AS NVARCHAR(40)) + N' ms average wait time.'
											FROM    os
											ORDER BY SUM(os.wait_time_ms / 1000.0 / 60 / 60) OVER (PARTITION BY os.wait_type) DESC;
									END /* IF EXISTS (SELECT * FROM sys.dm_os_wait_stats WHERE wait_time_ms &gt; 0 AND waiting_tasks_count &gt; 0) */

								/* If no waits were found, add a note about that */
								IF NOT EXISTS (SELECT * FROM #BlitzResults WHERE CheckID IN (107, 108, 109, 121, 152, 162))
								BEGIN
									INSERT  INTO #BlitzResults
											( CheckID ,
											  Priority ,
											  FindingsGroup ,
											  Finding ,
											  URL ,
											  Details
											)
										VALUES (153, 240, 'Wait Stats', 'No Significant Waits Detected', 'http://BrentOzar.com/go/waits', 'This server might be just sitting around idle, or someone may have cleared wait stats recently.');
								END
							END /* CheckID 152 */    

					END /* IF @CheckServerInfo = 1 */
			END /* IF ( ( SERVERPROPERTY('ServerName') NOT IN ( SELECT ServerName */


				/* Delete priorites they wanted to skip. */
				IF @IgnorePrioritiesAbove IS NOT NULL
					DELETE  #BlitzResults
					WHERE   [Priority] &gt; @IgnorePrioritiesAbove AND CheckID &lt;&gt; -1;

				IF @IgnorePrioritiesBelow IS NOT NULL
					DELETE  #BlitzResults
					WHERE   [Priority] &lt; @IgnorePrioritiesBelow AND CheckID &lt;&gt; -1;

				/* Delete checks they wanted to skip. */
				IF @SkipChecksTable IS NOT NULL
					BEGIN
						DELETE  FROM #BlitzResults
						WHERE   DatabaseName IN ( SELECT    DatabaseName
												  FROM      #SkipChecks
												  WHERE CheckID IS NULL
												  AND (ServerName IS NULL OR ServerName = SERVERPROPERTY('ServerName')));
						DELETE  FROM #BlitzResults
						WHERE   CheckID IN ( SELECT    CheckID
												  FROM      #SkipChecks
												  WHERE DatabaseName IS NULL
												  AND (ServerName IS NULL OR ServerName = SERVERPROPERTY('ServerName')));
						DELETE r FROM #BlitzResults r
							INNER JOIN #SkipChecks c ON r.DatabaseName = c.DatabaseName and r.CheckID = c.CheckID
												  AND (ServerName IS NULL OR ServerName = SERVERPROPERTY('ServerName'));
					END

				/* Add summary mode */
				IF @SummaryMode &gt; 0
					BEGIN
					UPDATE #BlitzResults
					  SET Finding = br.Finding + ' (' + CAST(brTotals.recs AS NVARCHAR(20)) + ')'
					  FROM #BlitzResults br
						INNER JOIN (SELECT FindingsGroup, Finding, Priority, COUNT(*) AS recs FROM #BlitzResults GROUP BY FindingsGroup, Finding, Priority) brTotals ON br.FindingsGroup = brTotals.FindingsGroup AND br.Finding = brTotals.Finding AND br.Priority = brTotals.Priority
						WHERE brTotals.recs &gt; 1;

					DELETE br
					  FROM #BlitzResults br
					  WHERE EXISTS (SELECT * FROM #BlitzResults brLower WHERE br.FindingsGroup = brLower.FindingsGroup AND br.Finding = brLower.Finding AND br.Priority = brLower.Priority AND br.ID &gt; brLower.ID);

					END

				/* Add credits for the nice folks who put so much time into building and maintaining this for free: */
				INSERT  INTO #BlitzResults
						( CheckID ,
						  Priority ,
						  FindingsGroup ,
						  Finding ,
						  URL ,
						  Details
						)
				VALUES  ( -1 ,
						  255 ,
						  'Thanks!' ,
						  'From Your Community Volunteers' ,
						  'http://FirstResponderKit.org' ,
						  'We hope you found this tool useful.'
						);

				INSERT  INTO #BlitzResults
						( CheckID ,
						  Priority ,
						  FindingsGroup ,
						  Finding ,
						  URL ,
						  Details

						)
				VALUES  ( -1 ,
						  0 ,
						  'sp_Blitz ' + CAST(CONVERT(DATETIME, @VersionDate, 102) AS VARCHAR(100)),
						  'SQL Server First Responder Kit' ,
						  'http://FirstResponderKit.org/' ,
						  'To get help or add your own contributions, join us at http://FirstResponderKit.org.'

						);

				INSERT  INTO #BlitzResults
						( CheckID ,
						  Priority ,
						  FindingsGroup ,
						  Finding ,
						  URL ,
						  Details

						)
				SELECT 156 ,
						  254 ,
						  'Rundate' ,
						  GETDATE() ,
						  'http://FirstResponderKit.org/' ,
						  'Captain''s log: stardate something and something...';
						  
				IF @EmailRecipients IS NOT NULL
					BEGIN
					/* Database mail won't work off a local temp table. I'm not happy about this hacky workaround either. */
					IF (OBJECT_ID('tempdb..##BlitzResults', 'U') IS NOT NULL) DROP TABLE ##BlitzResults;
					SELECT * INTO ##BlitzResults FROM #BlitzResults;
					SET @query_result_separator = char(9);
					SET @StringToExecute = 'SET NOCOUNT ON;SELECT [Priority] , [FindingsGroup] , [Finding] , [DatabaseName] , [URL] ,  [Details] , CheckID FROM ##BlitzResults ORDER BY Priority , FindingsGroup, Finding, Details; SET NOCOUNT OFF;';
					SET @EmailSubject = 'sp_Blitz Results for ' + @@SERVERNAME;
					SET @EmailBody = 'sp_Blitz ' + CAST(CONVERT(DATETIME, @VersionDate, 102) AS VARCHAR(100)) + '. http://FirstResponderKit.org';
					IF @EmailProfile IS NULL
						EXEC msdb.dbo.sp_send_dbmail
							@recipients = @EmailRecipients,
							@subject = @EmailSubject,
							@body = @EmailBody,
							@query_attachment_filename = 'sp_Blitz-Results.csv',
							@attach_query_result_as_file = 1,
							@query_result_header = 1,
							@query_result_width = 32767,
							@append_query_error = 1,
							@query_result_no_padding = 1,
							@query_result_separator = @query_result_separator,
							@query = @StringToExecute;
					ELSE
						EXEC msdb.dbo.sp_send_dbmail
							@profile_name = @EmailProfile,
							@recipients = @EmailRecipients,
							@subject = @EmailSubject,
							@body = @EmailBody,
							@query_attachment_filename = 'sp_Blitz-Results.csv',
							@attach_query_result_as_file = 1,
							@query_result_header = 1,
							@query_result_width = 32767,
							@append_query_error = 1,
							@query_result_no_padding = 1,
							@query_result_separator = @query_result_separator,
							@query = @StringToExecute;
					IF (OBJECT_ID('tempdb..##BlitzResults', 'U') IS NOT NULL) DROP TABLE ##BlitzResults;
				END

				/* Checks if @OutputServerName is populated with a valid linked server, and that the database name specified is valid */
				DECLARE @ValidOutputServer BIT
				DECLARE @ValidOutputLocation BIT
				DECLARE @LinkedServerDBCheck NVARCHAR(2000)
				DECLARE @ValidLinkedServerDB INT
				DECLARE @tmpdbchk table (cnt int)
				IF @OutputServerName IS NOT NULL
					BEGIN
						IF EXISTS (SELECT server_id FROM sys.servers WHERE QUOTENAME([name]) = @OutputServerName)
							BEGIN
								SET @LinkedServerDBCheck = 'SELECT 1 WHERE EXISTS (SELECT * FROM '+@OutputServerName+'.master.sys.databases WHERE QUOTENAME([name]) = '''+@OutputDatabaseName+''')'
								INSERT INTO @tmpdbchk EXEC sys.sp_executesql @LinkedServerDBCheck
								SET @ValidLinkedServerDB = (SELECT COUNT(*) FROM @tmpdbchk)
								IF (@ValidLinkedServerDB &gt; 0)
									BEGIN
										SET @ValidOutputServer = 1
										SET @ValidOutputLocation = 1
									END
								ELSE
									RAISERROR('The specified database was not found on the output server', 16, 0)
							END
						ELSE
							BEGIN
								RAISERROR('The specified output server was not found', 16, 0)
							END
					END
				ELSE
					BEGIN
						IF @OutputDatabaseName IS NOT NULL
							AND @OutputSchemaName IS NOT NULL
							AND @OutputTableName IS NOT NULL
							AND EXISTS ( SELECT *
								 FROM   sys.databases
								 WHERE  QUOTENAME([name]) = @OutputDatabaseName)
							BEGIN
								SET @ValidOutputLocation = 1
							END
						ELSE IF @OutputDatabaseName IS NOT NULL
							AND @OutputSchemaName IS NOT NULL
							AND @OutputTableName IS NOT NULL
							AND NOT EXISTS ( SELECT *
								 FROM   sys.databases
								 WHERE  QUOTENAME([name]) = @OutputDatabaseName)
							BEGIN
								RAISERROR('The specified output database was not found on this server', 16, 0)
							END
						ELSE
							BEGIN
								SET @ValidOutputLocation = 0 
							END
					END

				/* @OutputTableName lets us export the results to a permanent table */
				IF @ValidOutputLocation = 1
					BEGIN
						SET @StringToExecute = 'USE '
							+ @OutputDatabaseName
							+ '; IF EXISTS(SELECT * FROM '
							+ @OutputDatabaseName
							+ '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
							+ @OutputSchemaName
							+ ''') AND NOT EXISTS (SELECT * FROM '
							+ @OutputDatabaseName
							+ '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
							+ @OutputSchemaName + ''' AND QUOTENAME(TABLE_NAME) = '''
							+ @OutputTableName + ''') CREATE TABLE '
							+ @OutputSchemaName + '.'
							+ @OutputTableName
							+ ' (ID INT IDENTITY(1,1) NOT NULL,
								ServerName NVARCHAR(128),
								CheckDate DATETIMEOFFSET,
								Priority TINYINT ,
								FindingsGroup VARCHAR(50) ,
								Finding VARCHAR(200) ,
								DatabaseName NVARCHAR(128),
								URL VARCHAR(200) ,
								Details NVARCHAR(4000) ,
								QueryPlan [XML] NULL ,
								QueryPlanFiltered [NVARCHAR](MAX) NULL,
								CheckID INT ,
								CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
						IF @ValidOutputServer = 1
							BEGIN
								SET @StringToExecute = REPLACE(@StringToExecute,''''+@OutputSchemaName+'''',''''''+@OutputSchemaName+'''''')
								SET @StringToExecute = REPLACE(@StringToExecute,''''+@OutputTableName+'''',''''''+@OutputTableName+'''''')
								SET @StringToExecute = REPLACE(@StringToExecute,'[XML]','[NVARCHAR](MAX)')
								EXEC('EXEC('''+@StringToExecute+''') AT ' + @OutputServerName);
							END   
						ELSE
							BEGIN
								EXEC(@StringToExecute);
							END
						IF @ValidOutputServer = 1
							BEGIN
								SET @StringToExecute = N' IF EXISTS(SELECT * FROM '
								+ @OutputServerName + '.'
								+ @OutputDatabaseName
								+ '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
								+ @OutputSchemaName + ''') INSERT '
								+ @OutputServerName + '.'
								+ @OutputDatabaseName + '.'
								+ @OutputSchemaName + '.'
								+ @OutputTableName
								+ ' (ServerName, CheckDate, CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered) SELECT '''
								+ CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
								+ ''', SYSDATETIMEOFFSET(), CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, CAST(QueryPlan AS NVARCHAR(MAX)), QueryPlanFiltered FROM #BlitzResults ORDER BY Priority , FindingsGroup , Finding , Details';

								EXEC(@StringToExecute);
							END   
						ELSE
							BEGIN
								SET @StringToExecute = N' IF EXISTS(SELECT * FROM '
								+ @OutputDatabaseName
								+ '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
								+ @OutputSchemaName + ''') INSERT '
								+ @OutputDatabaseName + '.'
								+ @OutputSchemaName + '.'
								+ @OutputTableName
								+ ' (ServerName, CheckDate, CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered) SELECT '''
								+ CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
								+ ''', SYSDATETIMEOFFSET(), CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered FROM #BlitzResults ORDER BY Priority , FindingsGroup , Finding , Details';
								
								EXEC(@StringToExecute);
							END
					END
				ELSE IF (SUBSTRING(@OutputTableName, 2, 2) = '##')
					BEGIN
						IF @ValidOutputServer = 1
							BEGIN
								RAISERROR('Due to the nature of temporary tables, outputting to a linked server requires a permanent table.', 16, 0)
							END
						ELSE
							BEGIN
								SET @StringToExecute = N' IF (OBJECT_ID(''tempdb..'
									+ @OutputTableName
									+ ''') IS NOT NULL) DROP TABLE ' + @OutputTableName + ';'
									+ 'CREATE TABLE '
									+ @OutputTableName
									+ ' (ID INT IDENTITY(1,1) NOT NULL,
										ServerName NVARCHAR(128),
										CheckDate DATETIMEOFFSET,
										Priority TINYINT ,
										FindingsGroup VARCHAR(50) ,
										Finding VARCHAR(200) ,
										DatabaseName NVARCHAR(128),
										URL VARCHAR(200) ,
										Details NVARCHAR(4000) ,
										QueryPlan [XML] NULL ,
										QueryPlanFiltered [NVARCHAR](MAX) NULL,
										CheckID INT ,
										CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
									+ ' INSERT '
									+ @OutputTableName
									+ ' (ServerName, CheckDate, CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered) SELECT '''
									+ CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
									+ ''', SYSDATETIMEOFFSET(), CheckID, DatabaseName, Priority, FindingsGroup, Finding, URL, Details, QueryPlan, QueryPlanFiltered FROM #BlitzResults ORDER BY Priority , FindingsGroup , Finding , Details';
							
									EXEC(@StringToExecute);
							END
					END
				ELSE IF (SUBSTRING(@OutputTableName, 2, 1) = '#')
					BEGIN
						RAISERROR('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0)
					END


				DECLARE @separator AS VARCHAR(1);
				IF @OutputType = 'RSV'
					SET @separator = CHAR(31);
				ELSE
					SET @separator = ',';

				IF @OutputType = 'COUNT'
					BEGIN
						SELECT  COUNT(*) AS Warnings
						FROM    #BlitzResults
					END
				ELSE
					IF @OutputType IN ( 'CSV', 'RSV' )
						BEGIN

							SELECT  Result = CAST([Priority] AS NVARCHAR(100))
									+ @separator + CAST(CheckID AS NVARCHAR(100))
									+ @separator + COALESCE([FindingsGroup],
															'(N/A)') + @separator
									+ COALESCE([Finding], '(N/A)') + @separator
									+ COALESCE(DatabaseName, '(N/A)') + @separator
									+ COALESCE([URL], '(N/A)') + @separator
									+ COALESCE([Details], '(N/A)')
							FROM    #BlitzResults
							ORDER BY Priority ,
									FindingsGroup ,
									Finding ,
									DatabaseName ,
									Details;
						END
					ELSE IF @OutputXMLasNVARCHAR = 1 AND @OutputType &lt;&gt; 'NONE'
						BEGIN
							SELECT  [Priority] ,
									[FindingsGroup] ,
									[Finding] ,
									[DatabaseName] ,
									[URL] ,
									[Details] ,
									CAST([QueryPlan] AS NVARCHAR(MAX)) AS QueryPlan,
									[QueryPlanFiltered] ,
									CheckID
							FROM    #BlitzResults
							ORDER BY Priority ,
									FindingsGroup ,
									Finding ,
									DatabaseName ,
									Details;
						END
					ELSE IF @OutputType = 'MARKDOWN'
						BEGIN
							WITH Results AS (SELECT row_number() OVER (ORDER BY Priority, FindingsGroup, Finding, DatabaseName, Details) AS rownum, * 
												FROM #BlitzResults
												WHERE Priority &gt; 0 AND Priority &lt; 255 AND FindingsGroup IS NOT NULL AND Finding IS NOT NULL
												AND FindingsGroup &lt;&gt; 'Security' /* Specifically excluding security checks for public exports */)
							SELECT 
								CASE 
									WHEN r.Priority &lt;&gt; COALESCE(rPrior.Priority, 0) OR r.FindingsGroup &lt;&gt; rPrior.FindingsGroup  THEN @crlf + N'**Priority ' + CAST(COALESCE(r.Priority,N'') AS NVARCHAR(5)) + N': ' + COALESCE(r.FindingsGroup,N'') + N'**:' + @crlf + @crlf 
									ELSE N'' 
								END
								+ CASE WHEN r.Finding &lt;&gt; COALESCE(rPrior.Finding,N'') AND r.Finding &lt;&gt; rNext.Finding THEN N'- ' + COALESCE(r.Finding,N'') + N' ' + COALESCE(r.DatabaseName, N'') + N' - ' + COALESCE(r.Details,N'') + @crlf
									   WHEN r.Finding &lt;&gt; COALESCE(rPrior.Finding,N'') AND r.Finding = rNext.Finding AND r.Details = rNext.Details THEN N'- ' + COALESCE(r.Finding,N'') + N' - ' + COALESCE(r.Details,N'') + @crlf + @crlf + N'    * ' + COALESCE(r.DatabaseName, N'') + @crlf
									   WHEN r.Finding &lt;&gt; COALESCE(rPrior.Finding,N'') AND r.Finding = rNext.Finding THEN N'- ' + COALESCE(r.Finding,N'') + @crlf + CASE WHEN r.DatabaseName IS NULL THEN N'' ELSE  N'    * ' + COALESCE(r.DatabaseName,N'') END + CASE WHEN r.Details &lt;&gt; rPrior.Details THEN N' - ' + COALESCE(r.Details,N'') + @crlf ELSE '' END
									   ELSE CASE WHEN r.DatabaseName IS NULL THEN N'' ELSE  N'    * ' + COALESCE(r.DatabaseName,N'') END + CASE WHEN r.Details &lt;&gt; rPrior.Details THEN N' - ' + COALESCE(r.Details,N'') + @crlf ELSE N'' + @crlf END 
								END + @crlf 
							  FROM Results r
							  LEFT OUTER JOIN Results rPrior ON r.rownum = rPrior.rownum + 1
							  LEFT OUTER JOIN Results rNext ON r.rownum = rNext.rownum - 1
							ORDER BY r.rownum FOR XML PATH(N'');
						END
					ELSE IF @OutputType &lt;&gt; 'NONE'
						BEGIN
							SELECT  [Priority] ,
									[FindingsGroup] ,
									[Finding] ,
									[DatabaseName] ,
									[URL] ,
									[Details] ,
									[QueryPlan] ,
									[QueryPlanFiltered] ,
									CheckID
							FROM    #BlitzResults
							ORDER BY Priority ,
									FindingsGroup ,
									Finding ,
									DatabaseName ,
									Details;
						END

				DROP TABLE #BlitzResults;

				IF @OutputProcedureCache = 1
				AND @CheckProcedureCache = 1
					SELECT TOP 20
							total_worker_time / execution_count AS AvgCPU ,
							total_worker_time AS TotalCPU ,
							CAST(ROUND(100.00 * total_worker_time
									   / ( SELECT   SUM(total_worker_time)
										   FROM     sys.dm_exec_query_stats
										 ), 2) AS MONEY) AS PercentCPU ,
							total_elapsed_time / execution_count AS AvgDuration ,
							total_elapsed_time AS TotalDuration ,
							CAST(ROUND(100.00 * total_elapsed_time
									   / ( SELECT   SUM(total_elapsed_time)
										   FROM     sys.dm_exec_query_stats
										 ), 2) AS MONEY) AS PercentDuration ,
							total_logical_reads / execution_count AS AvgReads ,
							total_logical_reads AS TotalReads ,
							CAST(ROUND(100.00 * total_logical_reads
									   / ( SELECT   SUM(total_logical_reads)
										   FROM     sys.dm_exec_query_stats
										 ), 2) AS MONEY) AS PercentReads ,
							execution_count ,
							CAST(ROUND(100.00 * execution_count
									   / ( SELECT   SUM(execution_count)
										   FROM     sys.dm_exec_query_stats
										 ), 2) AS MONEY) AS PercentExecutions ,
							CASE WHEN DATEDIFF(mi, creation_time,
											   qs.last_execution_time) = 0 THEN 0
								 ELSE CAST(( 1.00 * execution_count / DATEDIFF(mi,
																  creation_time,
																  qs.last_execution_time) ) AS MONEY)
							END AS executions_per_minute ,
							qs.creation_time AS plan_creation_time ,
							qs.last_execution_time ,
							text ,
							text_filtered ,
							query_plan ,
							query_plan_filtered ,
							sql_handle ,
							query_hash ,
							plan_handle ,
							query_plan_hash
					FROM    #dm_exec_query_stats qs
					ORDER BY CASE UPPER(@CheckProcedureCacheFilter)
							   WHEN 'CPU' THEN total_worker_time
							   WHEN 'READS' THEN total_logical_reads
							   WHEN 'EXECCOUNT' THEN execution_count
							   WHEN 'DURATION' THEN total_elapsed_time
							   ELSE total_worker_time
							 END DESC

	END /* ELSE -- IF @OutputType = 'SCHEMA' */

    SET NOCOUNT OFF;
GO

/*
--Sample execution call with the most common parameters:
EXEC [dbo].[sp_Blitz]
    @CheckUserDatabaseObjects = 1 ,
    @CheckProcedureCache = 0 ,
    @OutputType = 'TABLE' ,
    @OutputProcedureCache = 0 ,
    @CheckProcedureCacheFilter = NULL,
    @CheckServerInfo = 1
*/
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>sp_BlitzCache____script</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>sp_BlitzCache____script</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>SET ANSI_NULLS ON;
SET ANSI_PADDING ON;
SET ANSI_WARNINGS ON;
SET ARITHABORT ON;
SET CONCAT_NULL_YIELDS_NULL ON;
SET QUOTED_IDENTIFIER ON;
SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;
GO

IF (
SELECT
  CASE 
     WHEN CONVERT(NVARCHAR(128), SERVERPROPERTY ('PRODUCTVERSION')) like '8%' THEN 0
     WHEN CONVERT(NVARCHAR(128), SERVERPROPERTY ('PRODUCTVERSION')) like '9%' THEN 0
	 ELSE 1
  END 
) = 0
BEGIN
	DECLARE @msg VARCHAR(8000) 
	SELECT @msg = 'Sorry, sp_BlitzCache doesn''t work on versions of SQL prior to 2008.' + REPLICATE(CHAR(13), 7933)
	PRINT @msg
	RETURN
END

IF OBJECT_ID('dbo.sp_BlitzCache') IS NULL
  EXEC ('CREATE PROCEDURE dbo.sp_BlitzCache AS RETURN 0;')
GO

IF OBJECT_ID('dbo.sp_BlitzCache') IS NOT NULL AND OBJECT_ID('tempdb.dbo.##bou_BlitzCacheProcs', 'U') IS NOT NULL
    EXEC ('DROP TABLE ##bou_BlitzCacheProcs;')
GO

IF OBJECT_ID('dbo.sp_BlitzCache') IS NOT NULL AND OBJECT_ID('tempdb.dbo.##bou_BlitzCacheResults', 'U') IS NOT NULL
    EXEC ('DROP TABLE ##bou_BlitzCacheResults;')
GO

CREATE TABLE ##bou_BlitzCacheResults (
    SPID INT,
    ID INT IDENTITY(1,1),
    CheckID INT,
    Priority TINYINT,
    FindingsGroup VARCHAR(50),
    Finding VARCHAR(200),
    URL VARCHAR(200),
    Details VARCHAR(4000) 
);

CREATE TABLE ##bou_BlitzCacheProcs (
        SPID INT ,
        QueryType NVARCHAR(256),
        DatabaseName sysname,
        AverageCPU DECIMAL(38,4),
        AverageCPUPerMinute DECIMAL(38,4),
        TotalCPU DECIMAL(38,4),
        PercentCPUByType MONEY,
        PercentCPU MONEY,
        AverageDuration DECIMAL(38,4),
        TotalDuration DECIMAL(38,4),
        PercentDuration MONEY,
        PercentDurationByType MONEY,
        AverageReads BIGINT,
        TotalReads BIGINT,
        PercentReads MONEY,
        PercentReadsByType MONEY,
        ExecutionCount BIGINT,
        PercentExecutions MONEY,
        PercentExecutionsByType MONEY,
        ExecutionsPerMinute MONEY,
        TotalWrites BIGINT,
        AverageWrites MONEY,
        PercentWrites MONEY,
        PercentWritesByType MONEY,
        WritesPerMinute MONEY,
        PlanCreationTime DATETIME,
		PlanCreationTimeHours AS DATEDIFF(HOUR, PlanCreationTime, SYSDATETIME()),
        LastExecutionTime DATETIME,
        PlanHandle VARBINARY(64),
		[Remove Plan Handle From Cache] AS 
			CASE WHEN [PlanHandle] IS NOT NULL 
			THEN 'DBCC FREEPROCCACHE (' + CONVERT(VARCHAR(128), [PlanHandle], 1) + ');'
			ELSE 'N/A' END,
		SqlHandle VARBINARY(64),
			[Remove SQL Handle From Cache] AS 
			CASE WHEN [SqlHandle] IS NOT NULL 
			THEN 'DBCC FREEPROCCACHE (' + CONVERT(VARCHAR(128), [SqlHandle], 1) + ');'
			ELSE 'N/A' END,
		[SQL Handle More Info] AS 
			CASE WHEN [SqlHandle] IS NOT NULL 
			THEN 'EXEC sp_BlitzCache @OnlySqlHandles = ''' + CONVERT(VARCHAR(128), [SqlHandle], 1) + '''; '
			ELSE 'N/A' END,
		QueryHash BINARY(8),
		[Query Hash More Info] AS 
			CASE WHEN [QueryHash] IS NOT NULL 
			THEN 'EXEC sp_BlitzCache @OnlyQueryHashes = ''' + CONVERT(VARCHAR(32), [QueryHash], 1) + '''; '
			ELSE 'N/A' END,
        QueryPlanHash BINARY(8),
        StatementStartOffset INT,
        StatementEndOffset INT,
        MinReturnedRows BIGINT,
        MaxReturnedRows BIGINT,
        AverageReturnedRows MONEY,
        TotalReturnedRows BIGINT,
        LastReturnedRows BIGINT,
		/*The Memory Grant columns are only supported 
		  in certain versions, giggle giggle.
		*/
		MinGrantKB BIGINT,
		MaxGrantKB BIGINT,
		MinUsedGrantKB BIGINT, 
		MaxUsedGrantKB BIGINT,
		PercentMemoryGrantUsed MONEY,
		AvgMaxMemoryGrant MONEY,
        QueryText NVARCHAR(MAX),
        QueryPlan XML,
        /* these next four columns are the total for the type of query.
            don't actually use them for anything apart from math by type.
            */
        TotalWorkerTimeForType BIGINT,
        TotalElapsedTimeForType BIGINT,
        TotalReadsForType BIGINT,
        TotalExecutionCountForType BIGINT,
        TotalWritesForType BIGINT,
        NumberOfPlans INT,
        NumberOfDistinctPlans INT,
        SerialDesiredMemory FLOAT,
        SerialRequiredMemory FLOAT,
        CachedPlanSize FLOAT,
        CompileTime FLOAT,
        CompileCPU FLOAT ,
        CompileMemory FLOAT ,
        min_worker_time BIGINT,
        max_worker_time BIGINT,
        is_forced_plan BIT,
        is_forced_parameterized BIT,
        is_cursor BIT,
		is_optimistic_cursor BIT,
		is_forward_only_cursor BIT,
        is_parallel BIT,
		is_forced_serial BIT,
		is_key_lookup_expensive BIT,
		key_lookup_cost FLOAT,
		is_remote_query_expensive BIT,
		remote_query_cost FLOAT,
        frequent_execution BIT,
        parameter_sniffing BIT,
        unparameterized_query BIT,
        near_parallel BIT,
        plan_warnings BIT,
        plan_multiple_plans BIT,
        long_running BIT,
        downlevel_estimator BIT,
        implicit_conversions BIT,
        busy_loops BIT,
        tvf_join BIT,
        tvf_estimate BIT,
        compile_timeout BIT,
        compile_memory_limit_exceeded BIT,
        warning_no_join_predicate BIT,
        QueryPlanCost FLOAT,
        missing_index_count INT,
        unmatched_index_count INT,
        min_elapsed_time BIGINT,
        max_elapsed_time BIGINT,
        age_minutes MONEY,
        age_minutes_lifetime MONEY,
        is_trivial BIT,
		trace_flags_session VARCHAR(1000),
		is_unused_grant BIT,
		function_count INT,
		clr_function_count INT,
		is_table_variable BIT,
		no_stats_warning BIT,
		relop_warnings BIT,
		is_table_scan BIT,
	    backwards_scan BIT,
	    forced_index BIT,
	    forced_seek BIT,
	    forced_scan BIT,
		columnstore_row_mode BIT,
		is_computed_scalar BIT ,
		is_sort_expensive bit,
		sort_cost float,
        SetOptions VARCHAR(MAX),
        Warnings VARCHAR(MAX)
    );
GO 

ALTER PROCEDURE dbo.sp_BlitzCache
    @Help BIT = 0,
    @Top INT = 10,
    @SortOrder VARCHAR(50) = 'CPU',
    @UseTriggersAnyway BIT = NULL,
    @ExportToExcel BIT = 0,
    @ExpertMode TINYINT = 0,
    @OutputServerName NVARCHAR(256) = NULL ,
    @OutputDatabaseName NVARCHAR(256) = NULL ,
    @OutputSchemaName NVARCHAR(256) = NULL ,
    @OutputTableName NVARCHAR(256) = NULL ,
    @ConfigurationDatabaseName NVARCHAR(128) = NULL ,
    @ConfigurationSchemaName NVARCHAR(256) = NULL ,
    @ConfigurationTableName NVARCHAR(256) = NULL ,
    @DurationFilter DECIMAL(38,4) = NULL ,
    @HideSummary BIT = 0 ,
    @IgnoreSystemDBs BIT = 1 ,
    @OnlyQueryHashes VARCHAR(MAX) = NULL ,
    @IgnoreQueryHashes VARCHAR(MAX) = NULL ,
    @OnlySqlHandles VARCHAR(MAX) = NULL ,
    @QueryFilter VARCHAR(10) = 'ALL' ,
    @DatabaseName NVARCHAR(128) = NULL ,
   @StoredProcName NVARCHAR(128) = NULL,
    @Reanalyze BIT = 0 ,
    @SkipAnalysis BIT = 0 ,
    @BringThePain BIT = 0 /* This will forcibly set @Top to 2,147,483,647 */
WITH RECOMPILE
AS
BEGIN
SET NOCOUNT ON;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

DECLARE @Version VARCHAR(30);
DECLARE @VersionDate VARCHAR(30);
 SET @Version = '4.1';
 SET @VersionDate = '20161210';

IF @Help = 1 PRINT '
sp_BlitzCache from http://FirstResponderKit.org
	
This script displays your most resource-intensive queries from the plan cache,
and points to ways you can tune these queries to make them faster.


To learn more, visit http://FirstResponderKit.org where you can download new
versions for free, watch training videos on how it works, get more info on
the findings, contribute your own code, and more.

Known limitations of this version:
 - This query will not run on SQL Server 2005.
 - SQL Server 2008 and 2008R2 have a bug in trigger stats, so that output is
   excluded by default.
 - @IgnoreQueryHashes and @OnlyQueryHashes require a CSV list of hashes
   with no spaces between the hash values.
 - @OutputServerName is not functional yet.

Unknown limitations of this version:
 - May or may not be vulnerable to the wick effect.

Changes - for the full list of improvements and fixes in this version, see:
https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/



MIT License

Copyright (c) 2016 Brent Ozar Unlimited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
'

DECLARE @nl NVARCHAR(2) = NCHAR(13) + NCHAR(10) ;

IF @Help = 1
BEGIN
    SELECT N'@Help' AS [Parameter Name] ,
           N'BIT' AS [Data Type] ,
           N'Displays this help message.' AS [Parameter Description]

    UNION ALL
    SELECT N'@Top',
           N'INT',
           N'The number of records to retrieve and analyze from the plan cache. The following DMVs are used as the plan cache: dm_exec_query_stats, dm_exec_procedure_stats, dm_exec_trigger_stats.'

    UNION ALL
    SELECT N'@SortOrder',
           N'VARCHAR(10)',
           N'Data processing and display order. @SortOrder will still be used, even when preparing output for a table or for excel. Possible values are: "CPU", "Reads", "Writes", "Duration", "Executions", "Recent Compilations", "Memory Grant". Additionally, the word "Average" or "Avg" can be used to sort on averages rather than total. "Executions per minute" and "Executions / minute" can be used to sort by execution per minute. For the truly lazy, "xpm" can also be used.'

    UNION ALL
    SELECT N'@UseTriggersAnyway',
           N'BIT',
           N'On SQL Server 2008R2 and earlier, trigger execution count is incorrect - trigger execution count is incremented once per execution of a SQL agent job. If you still want to see relative execution count of triggers, then you can force sp_BlitzCache to include this information.'

    UNION ALL
    SELECT N'@ExportToExcel',
           N'BIT',
           N'Prepare output for exporting to Excel. Newlines and additional whitespace are removed from query text and the execution plan is not displayed.'

    UNION ALL
    SELECT N'@ExpertMode',
           N'TINYINT',
           N'Default 0. When set to 1, results include more columns. When 2, mode is optimized for Opserver, the open source dashboard.'

    UNION ALL
    SELECT N'@OutputDatabaseName',
           N'NVARCHAR(128)',
           N'The output database. If this does not exist SQL Server will divide by zero and everything will fall apart.'

    UNION ALL
    SELECT N'@OutputSchemaName',
           N'NVARCHAR(256)',
           N'The output schema. If this does not exist SQL Server will divide by zero and everything will fall apart.'

    UNION ALL
    SELECT N'@OutputTableName',
           N'NVARCHAR(256)',
           N'The output table. If this does not exist, it will be created for you.'

    UNION ALL
    SELECT N'@DurationFilter',
           N'DECIMAL(38,4)',
           N'Excludes queries with an average duration (in seconds) less than @DurationFilter.'

    UNION ALL
    SELECT N'@HideSummary',
           N'BIT',
           N'Hides the findings summary result set.'

    UNION ALL
    SELECT N'@IgnoreSystemDBs',
           N'BIT',
           N'Ignores plans found in the system databases (master, model, msdb, tempdb, and resourcedb)'

    UNION ALL
    SELECT N'@OnlyQueryHashes',
           N'VARCHAR(MAX)',
           N'A list of query hashes to query. All other query hashes will be ignored. Stored procedures and triggers will be ignored.'

    UNION ALL
    SELECT N'@IgnoreQueryHashes',
           N'VARCHAR(MAX)',
           N'A list of query hashes to ignore.'
    
    UNION ALL
    SELECT N'@OnlySqlHandles',
           N'VARCHAR(MAX)',
           N'One or more sql_handles to use for filtering results.'

    UNION ALL
    SELECT N'@DatabaseName',
           N'NVARCHAR(128)',
           N'A database name which is used for filtering results.'

    UNION ALL
    SELECT N'@BringThePain',
           N'BIT',
           N'This forces sp_BlitzCache to examine the entire plan cache. Be careful running this on servers with a lot of memory or a large execution plan cache.'

    UNION ALL
    SELECT N'@QueryFilter',
           N'VARCHAR(10)',
           N'Filter out stored procedures or statements. The default value is ''ALL''. Allowed values are ''procedures'', ''statements'', or ''all'' (any variation in capitalization is acceptable).'

    UNION ALL
    SELECT N'@Reanalyze',
           N'BIT',
           N'The default is 0. When set to 0, sp_BlitzCache will re-evalute the plan cache. Set this to 1 to reanalyze existing results';
           


    /* Column definitions */
    SELECT N'# Executions' AS [Column Name],
           N'BIGINT' AS [Data Type],
           N'The number of executions of this particular query. This is computed across statements, procedures, and triggers and aggregated by the SQL handle.' AS [Column Description]

    UNION ALL
    SELECT N'Executions / Minute',
           N'MONEY',
           N'Number of executions per minute - calculated for the life of the current plan. Plan life is the last execution time minus the plan creation time.'

    UNION ALL
    SELECT N'Execution Weight',
           N'MONEY',
           N'An arbitrary metric of total "execution-ness". A weight of 2 is "one more" than a weight of 1.'

    UNION ALL
    SELECT N'Database',
           N'sysname',
           N'The name of the database where the plan was encountered. If the database name cannot be determined for some reason, a value of NA will be substituted. A value of 32767 indicates the plan comes from ResourceDB.'

    UNION ALL
    SELECT N'Total CPU',
           N'BIGINT',
           N'Total CPU time, reported in milliseconds, that was consumed by all executions of this query since the last compilation.'

    UNION ALL
    SELECT N'Avg CPU',
           N'BIGINT',
           N'Average CPU time, reported in milliseconds, consumed by each execution of this query since the last compilation.'

    UNION ALL
    SELECT N'CPU Weight',
           N'MONEY',
           N'An arbitrary metric of total "CPU-ness". A weight of 2 is "one more" than a weight of 1.'


    UNION ALL
    SELECT N'Total Duration',
           N'BIGINT',
           N'Total elapsed time, reported in milliseconds, consumed by all executions of this query since last compilation.'

    UNION ALL
    SELECT N'Avg Duration',
           N'BIGINT',
           N'Average elapsed time, reported in milliseconds, consumed by each execution of this query since the last compilation.'

    UNION ALL
    SELECT N'Duration Weight',
           N'MONEY',
           N'An arbitrary metric of total "Duration-ness". A weight of 2 is "one more" than a weight of 1.'

    UNION ALL
    SELECT N'Total Reads',
           N'BIGINT',
           N'Total logical reads performed by this query since last compilation.'

    UNION ALL
    SELECT N'Average Reads',
           N'BIGINT',
           N'Average logical reads performed by each execution of this query since the last compilation.'

    UNION ALL
    SELECT N'Read Weight',
           N'MONEY',
           N'An arbitrary metric of "Read-ness". A weight of 2 is "one more" than a weight of 1.'

    UNION ALL
    SELECT N'Total Writes',
           N'BIGINT',
           N'Total logical writes performed by this query since last compilation.'

    UNION ALL
    SELECT N'Average Writes',
           N'BIGINT',
           N'Average logical writes performed by each execution this query since last compilation.'

    UNION ALL
    SELECT N'Write Weight',
           N'MONEY',
           N'An arbitrary metric of "Write-ness". A weight of 2 is "one more" than a weight of 1.'

    UNION ALL
    SELECT N'Query Type',
           N'NVARCHAR(256)',
           N'The type of query being examined. This can be "Procedure", "Statement", or "Trigger".'

    UNION ALL
    SELECT N'Query Text',
           N'NVARCHAR(4000)',
           N'The text of the query. This may be truncated by either SQL Server or by sp_BlitzCache(tm) for display purposes.'

    UNION ALL
    SELECT N'% Executions (Type)',
           N'MONEY',
           N'Percent of executions relative to the type of query - e.g. 17.2% of all stored procedure executions.'

    UNION ALL
    SELECT N'% CPU (Type)',
           N'MONEY',
           N'Percent of CPU time consumed by this query for a given type of query - e.g. 22% of CPU of all stored procedures executed.'

    UNION ALL
    SELECT N'% Duration (Type)',
           N'MONEY',
           N'Percent of elapsed time consumed by this query for a given type of query - e.g. 12% of all statements executed.'

    UNION ALL
    SELECT N'% Reads (Type)',
           N'MONEY',
           N'Percent of reads consumed by this query for a given type of query - e.g. 34.2% of all stored procedures executed.'

    UNION ALL
    SELECT N'% Writes (Type)',
           N'MONEY',
           N'Percent of writes performed by this query for a given type of query - e.g. 43.2% of all statements executed.'

    UNION ALL
    SELECT N'Total Rows',
           N'BIGINT',
           N'Total number of rows returned for all executions of this query. This only applies to query level stats, not stored procedures or triggers.'

    UNION ALL
    SELECT N'Average Rows',
           N'MONEY',
           N'Average number of rows returned by each execution of the query.'

    UNION ALL
    SELECT N'Min Rows',
           N'BIGINT',
           N'The minimum number of rows returned by any execution of this query.'

    UNION ALL
    SELECT N'Max Rows',
           N'BIGINT',
           N'The maximum number of rows returned by any execution of this query.'

    UNION ALL
    SELECT N'MinGrantKB',
           N'BIGINT',
           N'The minim memory grant the query received in kb.'

    UNION ALL
    SELECT N'MaxGrantKB',
           N'BIGINT',
           N'The maximum memory grant the query received in kb.'

    UNION ALL
    SELECT N'MinUsedGrantKB',
           N'BIGINT',
           N'The minim used memory grant the query received in kb.'

    UNION ALL
    SELECT N'MaxUsedGrantKB',
           N'BIGINT',
           N'The maximum used memory grant the query received in kb.'

    UNION ALL
    SELECT N'PercentMemoryGrantUsed',
           N'MONEY',
           N'Result of dividing the maximum grant used by the minimum granted.'

    UNION ALL
    SELECT N'AvgMaxMemoryGrant',
           N'MONEY',
           N'The average maximum memory grant for a query.'

    UNION ALL
    SELECT N'# Plans',
           N'INT',
           N'The total number of execution plans found that match a given query.'

    UNION ALL
    SELECT N'# Distinct Plans',
           N'INT',
           N'The number of distinct execution plans that match a given query. '
            + NCHAR(13) + NCHAR(10)
            + N'This may be caused by running the same query across multiple databases or because of a lack of proper parameterization in the database.'

    UNION ALL
    SELECT N'Created At',
           N'DATETIME',
           N'Time that the execution plan was last compiled.'

    UNION ALL
    SELECT N'Last Execution',
           N'DATETIME',
           N'The last time that this query was executed.'

    UNION ALL
    SELECT N'Query Plan',
           N'XML',
           N'The query plan. Click to display a graphical plan or, if you need to patch SSMS, a pile of XML.'

    UNION ALL
    SELECT N'Plan Handle',
           N'VARBINARY(64)',
           N'An arbitrary identifier referring to the compiled plan this query is a part of.'

    UNION ALL
    SELECT N'SQL Handle',
           N'VARBINARY(64)',
           N'An arbitrary identifier referring to a batch or stored procedure that this query is a part of.'

    UNION ALL
    SELECT N'Query Hash',
           N'BINARY(8)',
           N'A hash of the query. Queries with the same query hash have similar logic but only differ by literal values or database.'

    UNION ALL
    SELECT N'Warnings',
           N'VARCHAR(MAX)',
           N'A list of individual warnings generated by this query.' ;


           
    /* Configuration table description */
    SELECT N'Frequent Execution Threshold' AS [Configuration Parameter] ,
           N'100' AS [Default Value] ,
           N'Executions / Minute' AS [Unit of Measure] ,
           N'Executions / Minute before a "Frequent Execution Threshold" warning is triggered.' AS [Description]

    UNION ALL
    SELECT N'Parameter Sniffing Variance Percent' ,
           N'30' ,
           N'Percent' ,
           N'Variance required between min/max values and average values before a "Parameter Sniffing" warning is triggered. Applies to worker time and returned rows.'

    UNION ALL
    SELECT N'Parameter Sniffing IO Threshold' ,
           N'100,000' ,
           N'Logical reads' ,
           N'Minimum number of average logical reads before parameter sniffing checks are evaluated.'

    UNION ALL
    SELECT N'Cost Threshold for Parallelism Warning' AS [Configuration Parameter] ,
           N'10' ,
           N'Percent' ,
           N'Trigger a "Nearly Parallel" warning when a query''s cost is within X percent of the cost threshold for parallelism.'

    UNION ALL
    SELECT N'Long Running Query Warning' AS [Configuration Parameter] ,
           N'300' ,
           N'Seconds' ,
           N'Triggers a "Long Running Query Warning" when average duration, max CPU time, or max clock time is higher than this number.'

    UNION ALL
    SELECT N'Unused Memory Grant Warning' AS [Configuration Parameter] ,
           N'10' ,
           N'Percent' ,
           N'Triggers an "Unused Memory Grant Warning" when a query uses &gt;= X percent of its memory grant.'
    RETURN
END

/*Validate version*/
IF (
SELECT
  CASE 
     WHEN CONVERT(NVARCHAR(128), SERVERPROPERTY ('PRODUCTVERSION')) like '8%' THEN 0
     WHEN CONVERT(NVARCHAR(128), SERVERPROPERTY ('PRODUCTVERSION')) like '9%' THEN 0
	 ELSE 1
  END 
) = 0
BEGIN
	DECLARE @version_msg VARCHAR(8000) 
	SELECT @version_msg = 'Sorry, sp_BlitzCache doesn''t work on versions of SQL prior to 2008.' + REPLICATE(CHAR(13), 7933);
	PRINT @version_msg;
	RETURN;
END

/* validate user inputs */
IF @Top IS NULL 
    OR @SortOrder IS NULL 
    OR @QueryFilter IS NULL 
    OR @Reanalyze IS NULL
BEGIN
    RAISERROR(N'Several parameters (@Top, @SortOrder, @QueryFilter, @renalyze) are required. Do not set them to NULL. Please try again.', 16, 1) WITH NOWAIT;
    RETURN;
END

RAISERROR(N'Creating temp tables for results and warnings.', 0, 1) WITH NOWAIT;

IF OBJECT_ID('tempdb.dbo.##bou_BlitzCacheResults') IS NULL
BEGIN
    CREATE TABLE ##bou_BlitzCacheResults (
        SPID INT,
        ID INT IDENTITY(1,1),
        CheckID INT,
        Priority TINYINT,
        FindingsGroup VARCHAR(50),
        Finding VARCHAR(200),
        URL VARCHAR(200),
        Details VARCHAR(4000)
    );
END

IF OBJECT_ID('tempdb.dbo.##bou_BlitzCacheProcs') IS NULL
BEGIN
    CREATE TABLE ##bou_BlitzCacheProcs (
        SPID INT ,
        QueryType NVARCHAR(256),
        DatabaseName sysname,
        AverageCPU DECIMAL(38,4),
        AverageCPUPerMinute DECIMAL(38,4),
        TotalCPU DECIMAL(38,4),
        PercentCPUByType MONEY,
        PercentCPU MONEY,
        AverageDuration DECIMAL(38,4),
        TotalDuration DECIMAL(38,4),
        PercentDuration MONEY,
        PercentDurationByType MONEY,
        AverageReads BIGINT,
        TotalReads BIGINT,
        PercentReads MONEY,
        PercentReadsByType MONEY,
        ExecutionCount BIGINT,
        PercentExecutions MONEY,
        PercentExecutionsByType MONEY,
        ExecutionsPerMinute MONEY,
        TotalWrites BIGINT,
        AverageWrites MONEY,
        PercentWrites MONEY,
        PercentWritesByType MONEY,
        WritesPerMinute MONEY,
        PlanCreationTime DATETIME,
		PlanCreationTimeHours AS DATEDIFF(HOUR, PlanCreationTime, SYSDATETIME()),
        LastExecutionTime DATETIME,
        PlanHandle VARBINARY(64),
		[Remove Plan Handle From Cache] AS 
			CASE WHEN [PlanHandle] IS NOT NULL 
			THEN 'DBCC FREEPROCCACHE (' + CONVERT(VARCHAR(128), [PlanHandle], 1) + ');'
			ELSE 'N/A' END,
		SqlHandle VARBINARY(64),
			[Remove SQL Handle From Cache] AS 
			CASE WHEN [SqlHandle] IS NOT NULL 
			THEN 'DBCC FREEPROCCACHE (' + CONVERT(VARCHAR(128), [SqlHandle], 1) + ');'
			ELSE 'N/A' END,
		[SQL Handle More Info] AS 
			CASE WHEN [SqlHandle] IS NOT NULL 
			THEN 'EXEC sp_BlitzCache @OnlySqlHandles = ''' + CONVERT(VARCHAR(128), [SqlHandle], 1) + '''; '
			ELSE 'N/A' END,
		QueryHash BINARY(8),
		[Query Hash More Info] AS 
			CASE WHEN [QueryHash] IS NOT NULL 
			THEN 'EXEC sp_BlitzCache @OnlyQueryHashes = ''' + CONVERT(VARCHAR(32), [QueryHash], 1) + '''; '
			ELSE 'N/A' END,
        QueryPlanHash BINARY(8),
        StatementStartOffset INT,
        StatementEndOffset INT,
        MinReturnedRows BIGINT,
        MaxReturnedRows BIGINT,
        AverageReturnedRows MONEY,
        TotalReturnedRows BIGINT,
        LastReturnedRows BIGINT,
		MinGrantKB BIGINT,
		MaxGrantKB BIGINT,
		MinUsedGrantKB BIGINT, 
		MaxUsedGrantKB BIGINT,
		PercentMemoryGrantUsed MONEY,
		AvgMaxMemoryGrant MONEY,
        QueryText NVARCHAR(MAX),
        QueryPlan XML,
        /* these next four columns are the total for the type of query.
            don't actually use them for anything apart from math by type.
            */
        TotalWorkerTimeForType BIGINT,
        TotalElapsedTimeForType BIGINT,
        TotalReadsForType BIGINT,
        TotalExecutionCountForType BIGINT,
        TotalWritesForType BIGINT,
        NumberOfPlans INT,
        NumberOfDistinctPlans INT,
        SerialDesiredMemory FLOAT,
        SerialRequiredMemory FLOAT,
        CachedPlanSize FLOAT,
        CompileTime FLOAT,
        CompileCPU FLOAT ,
        CompileMemory FLOAT ,
        min_worker_time BIGINT,
        max_worker_time BIGINT,
        is_forced_plan BIT,
        is_forced_parameterized BIT,
        is_cursor BIT,
		is_optimistic_cursor BIT,
		is_forward_only_cursor BIT,
        is_parallel BIT,
		is_forced_serial BIT,
		is_key_lookup_expensive BIT,
		key_lookup_cost FLOAT,
		is_remote_query_expensive BIT,
		remote_query_cost FLOAT,
        frequent_execution BIT,
        parameter_sniffing BIT,
        unparameterized_query BIT,
        near_parallel BIT,
        plan_warnings BIT,
        plan_multiple_plans BIT,
        long_running BIT,
        downlevel_estimator BIT,
        implicit_conversions BIT,
        busy_loops BIT,
        tvf_join BIT,
        tvf_estimate BIT,
        compile_timeout BIT,
        compile_memory_limit_exceeded BIT,
        warning_no_join_predicate BIT,
        QueryPlanCost FLOAT,
        missing_index_count INT,
        unmatched_index_count INT,
        min_elapsed_time BIGINT,
        max_elapsed_time BIGINT,
        age_minutes MONEY,
        age_minutes_lifetime MONEY,
        is_trivial BIT,
		trace_flags_session VARCHAR(1000),
		is_unused_grant BIT,
		function_count INT,
		clr_function_count INT,
		is_table_variable BIT,
		no_stats_warning BIT,
		relop_warnings BIT,
		is_table_scan BIT,
	    backwards_scan BIT,
	    forced_index BIT,
	    forced_seek BIT,
	    forced_scan BIT,
		columnstore_row_mode BIT,
		is_computed_scalar BIT ,
		is_sort_expensive bit,
		sort_cost float,
        SetOptions VARCHAR(MAX),
        Warnings VARCHAR(MAX)
    );
END

DECLARE @DurationFilter_i INT,
		@MinMemoryPerQuery INT,
        @msg NVARCHAR(4000) ;


IF @BringThePain = 1
   BEGIN
   RAISERROR(N'You have chosen to bring the pain. Setting top to 2147483647.', 0, 1) WITH NOWAIT;
   SET @Top = 2147483647;
   END 

/* Change duration from seconds to milliseconds */
IF @DurationFilter IS NOT NULL
  BEGIN
  RAISERROR(N'Converting Duration Filter to milliseconds', 0, 1) WITH NOWAIT;
  SET @DurationFilter_i = CAST((@DurationFilter * 1000.0) AS INT)
  END 

RAISERROR(N'Checking database validity', 0, 1) WITH NOWAIT;
SET @DatabaseName = LTRIM(RTRIM(@DatabaseName)) ;
IF (DB_ID(@DatabaseName)) IS NULL AND @DatabaseName &lt;&gt; ''
BEGIN
   RAISERROR('The database you specified does not exist. Please check the name and try again.', 16, 1);
   RETURN;
END
IF (SELECT DATABASEPROPERTYEX(@DatabaseName, 'Status')) &lt;&gt; 'ONLINE'
BEGIN
   RAISERROR('The database you specified is not readable. Please check the name and try again. Better yet, check your server.', 16, 1);
   RETURN;
END

SELECT @MinMemoryPerQuery = CONVERT(INT, c.value) FROM sys.configurations AS c WHERE c.name = 'min memory per query (KB)';

SET @SortOrder = LOWER(@SortOrder);
SET @SortOrder = REPLACE(REPLACE(@SortOrder, 'average', 'avg'), '.', '');
SET @SortOrder = REPLACE(@SortOrder, 'executions per minute', 'avg executions');
SET @SortOrder = REPLACE(@SortOrder, 'executions / minute', 'avg executions');
SET @SortOrder = REPLACE(@SortOrder, 'xpm', 'avg executions');
SET @SortOrder = REPLACE(@SortOrder, 'recent compilations', 'compiles');

RAISERROR(N'Checking sort order', 0, 1) WITH NOWAIT;
IF @SortOrder NOT IN ('cpu', 'avg cpu', 'reads', 'avg reads', 'writes', 'avg writes',
                       'duration', 'avg duration', 'executions', 'avg executions',
                       'compiles', 'memory grant', 'avg memory grant')
  BEGIN
  RAISERROR(N'Invalid sort order chosen, reverting to cpu', 0, 1) WITH NOWAIT;
  SET @SortOrder = 'cpu';
  END 

SELECT @OutputDatabaseName = QUOTENAME(@OutputDatabaseName),
       @OutputSchemaName   = QUOTENAME(@OutputSchemaName),
       @OutputTableName    = QUOTENAME(@OutputTableName);

SET @QueryFilter = LOWER(@QueryFilter);

IF LEFT(@QueryFilter, 3) NOT IN ('all', 'sta', 'pro')
  BEGIN
  RAISERROR(N'Invalid query filter chosen. Reverting to all.', 0, 1) WITH NOWAIT;
  SET @QueryFilter = 'all';
  END

IF @SkipAnalysis = 1
  BEGIN
  RAISERROR(N'Skip Analysis set to 1, hiding Summary', 0, 1) WITH NOWAIT;
  SET @HideSummary = 1;
  END 

IF @Reanalyze = 1 AND OBJECT_ID('tempdb..##bou_BlitzCacheResults') IS NULL
  BEGIN
  RAISERROR(N'##bou_BlitzCacheResults does not exist, can''t reanalyze', 0, 1) WITH NOWAIT;
  SET @Reanalyze = 0;
  END

IF @Reanalyze = 0
  BEGIN
  RAISERROR(N'Cleaning up old warnings for your SPID', 0, 1) WITH NOWAIT;
  DELETE ##bou_BlitzCacheResults
    WHERE SPID = @@SPID;
  RAISERROR(N'Cleaning up old plans for your SPID', 0, 1) WITH NOWAIT;
  DELETE ##bou_BlitzCacheProcs
    WHERE SPID = @@SPID;
  END  

IF @Reanalyze = 1 
	BEGIN
	RAISERROR(N'Reanalyzing current data, skipping to results', 0, 1) WITH NOWAIT;
    GOTO Results
	END

RAISERROR(N'Creating temp tables for internal processing', 0, 1) WITH NOWAIT;
IF OBJECT_ID('tempdb..#only_query_hashes') IS NOT NULL
    DROP TABLE #only_query_hashes ;

IF OBJECT_ID('tempdb..#ignore_query_hashes') IS NOT NULL
    DROP TABLE #ignore_query_hashes ;

IF OBJECT_ID('tempdb..#only_sql_handles') IS NOT NULL
    DROP TABLE #only_sql_handles ;
   
IF OBJECT_ID('tempdb..#p') IS NOT NULL
    DROP TABLE #p;

IF OBJECT_ID ('tempdb..#checkversion') IS NOT NULL
    DROP TABLE #checkversion;

IF OBJECT_ID ('tempdb..#configuration') IS NOT NULL
    DROP TABLE #configuration;

CREATE TABLE #only_query_hashes (
    query_hash BINARY(8)
);

CREATE TABLE #ignore_query_hashes (
    query_hash BINARY(8)
);

CREATE TABLE #only_sql_handles (
    sql_handle VARBINARY(64)
);

CREATE TABLE #p (
    SqlHandle VARBINARY(64),
    TotalCPU BIGINT,
    TotalDuration BIGINT,
    TotalReads BIGINT,
    TotalWrites BIGINT,
    ExecutionCount BIGINT
);

CREATE TABLE #checkversion (
    version NVARCHAR(128),
    common_version AS SUBSTRING(version, 1, CHARINDEX('.', version) + 1 ),
    major AS PARSENAME(CONVERT(VARCHAR(32), version), 4),
    minor AS PARSENAME(CONVERT(VARCHAR(32), version), 3),
    build AS PARSENAME(CONVERT(VARCHAR(32), version), 2),
    revision AS PARSENAME(CONVERT(VARCHAR(32), version), 1)
);

CREATE TABLE #configuration (
    parameter_name VARCHAR(100),
    value DECIMAL(38,0)
);

RAISERROR(N'Checking plan cache age', 0, 1) WITH NOWAIT;
WITH x AS (
SELECT SUM(CASE WHEN DATEDIFF(HOUR, deqs.creation_time, SYSDATETIME()) &lt; 24 THEN 1 ELSE 0 END) AS [plans_24],
	   SUM(CASE WHEN DATEDIFF(HOUR, deqs.creation_time, SYSDATETIME()) &lt; 4 THEN 1 ELSE 0 END) AS [plans_4],
	   COUNT(deqs.creation_time) AS [total_plans]
FROM sys.dm_exec_query_stats AS deqs
)
SELECT CONVERT(DECIMAL(3,2), x.plans_24 / (1. * NULLIF(x.total_plans, 0))) * 100 AS [percent_24],
	   CONVERT(DECIMAL(3,2), x.plans_4 / (1. * NULLIF(x.total_plans, 0))) * 100 AS [percent_4],
	   @@SPID AS SPID
INTO #plan_creation
FROM x


RAISERROR(N'Checking plan stub count', 0, 1) WITH NOWAIT;
SELECT  CONVERT(DECIMAL(9, 2), ( CAST(COUNT(*) AS DECIMAL(9, 2)) / ( SELECT COUNT (*) FROM sys.dm_exec_cached_plans ) )) AS plan_stubs_percent,
        COUNT(*) AS total_plan_stubs,
		( SELECT COUNT (*) FROM sys.dm_exec_cached_plans ) AS total_plans,
        ISNULL(AVG(DATEDIFF(HOUR, qs.creation_time, GETDATE())), 0) AS avg_plan_age,
		@@SPID AS SPID
INTO #plan_stubs_warning
FROM    sys.dm_exec_cached_plans cp
LEFT JOIN sys.dm_exec_query_stats qs
ON      cp.plan_handle = qs.plan_handle
WHERE   cp.cacheobjtype = 'Compiled Plan Stub';


RAISERROR(N'Checking single use plan count', 0, 1) WITH NOWAIT;
SELECT  CONVERT(DECIMAL(9, 2), ( CAST(COUNT(*) AS DECIMAL(9, 2)) / ( SELECT COUNT (*) FROM sys.dm_exec_cached_plans ) )) AS single_use_plans_percent,
        COUNT(*) AS total_single_use_plans,
		( SELECT COUNT (*) FROM sys.dm_exec_cached_plans ) AS total_plans,
        ISNULL(AVG(DATEDIFF(HOUR, qs.creation_time, GETDATE())), 0) AS avg_plan_age,
		@@SPID AS SPID
INTO #single_use_plans_warning
FROM    sys.dm_exec_cached_plans cp
LEFT JOIN sys.dm_exec_query_stats qs
ON      cp.plan_handle = qs.plan_handle
WHERE   cp.usecounts = 1
        AND cp.cacheobjtype = 'Compiled Plan';



SET @OnlySqlHandles = LTRIM(RTRIM(@OnlySqlHandles)) ;
SET @OnlyQueryHashes = LTRIM(RTRIM(@OnlyQueryHashes)) ;
SET @IgnoreQueryHashes = LTRIM(RTRIM(@IgnoreQueryHashes)) ;

DECLARE @individual VARCHAR(100) ;

IF @OnlySqlHandles IS NOT NULL
    AND LEN(@OnlySqlHandles) &gt; 0
BEGIN
    RAISERROR(N'Processing SQL Handles', 0, 1) WITH NOWAIT;
	SET @individual = '';

    WHILE LEN(@OnlySqlHandles) &gt; 0
    BEGIN
        IF PATINDEX('%,%', @OnlySqlHandles) &gt; 0
        BEGIN  
               SET @individual = SUBSTRING(@OnlySqlHandles, 0, PATINDEX('%,%',@OnlySqlHandles)) ;
               
               INSERT INTO #only_sql_handles
               SELECT CAST('' AS XML).value('xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )', 'varbinary(max)')
               FROM (SELECT CASE SUBSTRING(@individual, 1, 2) WHEN '0x' THEN 3 ELSE 0 END) AS t(pos)
               
               --SELECT CAST(SUBSTRING(@individual, 1, 2) AS BINARY(8));

               SET @OnlySqlHandles = SUBSTRING(@OnlySqlHandles, LEN(@individual + ',') + 1, LEN(@OnlySqlHandles)) ;
        END
        ELSE
        BEGIN
               SET @individual = @OnlySqlHandles
               SET @OnlySqlHandles = NULL

               INSERT INTO #only_sql_handles
               SELECT CAST('' AS XML).value('xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )', 'varbinary(max)')
               FROM (SELECT CASE SUBSTRING(@individual, 1, 2) WHEN '0x' THEN 3 ELSE 0 END) AS t(pos)

               --SELECT CAST(SUBSTRING(@individual, 1, 2) AS VARBINARY(MAX)) ;
        END
    END
END    

IF @StoredProcName IS NOT NULL AND @StoredProcName &lt;&gt; N''

BEGIN
	RAISERROR(N'Setting up filter for stored procedure name', 0, 1) WITH NOWAIT;
	INSERT #only_sql_handles
	        ( sql_handle )
	SELECT  ISNULL(deps.sql_handle, CONVERT(VARBINARY(64),''))
	FROM sys.dm_exec_procedure_stats AS deps
	WHERE OBJECT_NAME(deps.object_id, deps.database_id) = @StoredProcName

END



IF ((@OnlyQueryHashes IS NOT NULL AND LEN(@OnlyQueryHashes) &gt; 0)
    OR (@IgnoreQueryHashes IS NOT NULL AND LEN(@IgnoreQueryHashes) &gt; 0))
   AND LEFT(@QueryFilter, 3) = 'pro'
BEGIN
   RAISERROR('You cannot limit by query hash and filter by stored procedure', 16, 1);
   RETURN;
END

/* If the user is attempting to limit by query hash, set up the
   #only_query_hashes temp table. This will be used to narrow down
   results.

   Just a reminder: Using @OnlyQueryHashes will ignore stored
   procedures and triggers.
 */
IF @OnlyQueryHashes IS NOT NULL
   AND LEN(@OnlyQueryHashes) &gt; 0
BEGIN
	RAISERROR(N'Setting up filter for Query Hashes', 0, 1) WITH NOWAIT;
    SET @individual = '';

   WHILE LEN(@OnlyQueryHashes) &gt; 0
   BEGIN
        IF PATINDEX('%,%', @OnlyQueryHashes) &gt; 0
        BEGIN  
               SET @individual = SUBSTRING(@OnlyQueryHashes, 0, PATINDEX('%,%',@OnlyQueryHashes)) ;
               
               INSERT INTO #only_query_hashes
               SELECT CAST('' AS XML).value('xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )', 'varbinary(max)')
               FROM (SELECT CASE SUBSTRING(@individual, 1, 2) WHEN '0x' THEN 3 ELSE 0 END) AS t(pos)
               
               --SELECT CAST(SUBSTRING(@individual, 1, 2) AS BINARY(8));

               SET @OnlyQueryHashes = SUBSTRING(@OnlyQueryHashes, LEN(@individual + ',') + 1, LEN(@OnlyQueryHashes)) ;
        END
        ELSE
        BEGIN
               SET @individual = @OnlyQueryHashes
               SET @OnlyQueryHashes = NULL

               INSERT INTO #only_query_hashes
               SELECT CAST('' AS XML).value('xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )', 'varbinary(max)')
               FROM (SELECT CASE SUBSTRING(@individual, 1, 2) WHEN '0x' THEN 3 ELSE 0 END) AS t(pos)

               --SELECT CAST(SUBSTRING(@individual, 1, 2) AS VARBINARY(MAX)) ;
        END
   END
END

/* If the user is setting up a list of query hashes to ignore, those
   values will be inserted into #ignore_query_hashes. This is used to
   exclude values from query results.

   Just a reminder: Using @IgnoreQueryHashes will ignore stored
   procedures and triggers.
 */
IF @IgnoreQueryHashes IS NOT NULL
   AND LEN(@IgnoreQueryHashes) &gt; 0
BEGIN
	RAISERROR(N'Setting up filter to ignore query hashes', 0, 1) WITH NOWAIT;
   SET @individual = '' ;

   WHILE LEN(@IgnoreQueryHashes) &gt; 0
   BEGIN
        IF PATINDEX('%,%', @IgnoreQueryHashes) &gt; 0
        BEGIN  
               SET @individual = SUBSTRING(@IgnoreQueryHashes, 0, PATINDEX('%,%',@IgnoreQueryHashes)) ;
               
               INSERT INTO #ignore_query_hashes
               SELECT CAST('' AS XML).value('xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )', 'varbinary(max)')
               FROM (SELECT CASE SUBSTRING(@individual, 1, 2) WHEN '0x' THEN 3 ELSE 0 END) AS t(pos) ;
               
               SET @IgnoreQueryHashes = SUBSTRING(@IgnoreQueryHashes, LEN(@individual + ',') + 1, LEN(@IgnoreQueryHashes)) ;
        END
        ELSE
        BEGIN
               SET @individual = @IgnoreQueryHashes ;
               SET @IgnoreQueryHashes = NULL ;

               INSERT INTO #ignore_query_hashes
               SELECT CAST('' AS XML).value('xs:hexBinary( substring(sql:variable("@individual"), sql:column("t.pos")) )', 'varbinary(max)')
               FROM (SELECT CASE SUBSTRING(@individual, 1, 2) WHEN '0x' THEN 3 ELSE 0 END) AS t(pos) ;
        END
   END
END

IF @ConfigurationDatabaseName IS NOT NULL
BEGIN
   RAISERROR(N'Reading values from Configuration Database', 0, 1) WITH NOWAIT;
   DECLARE @config_sql NVARCHAR(MAX) = N'INSERT INTO #configuration SELECT parameter_name, value FROM '
        + QUOTENAME(@ConfigurationDatabaseName)
        + '.' + QUOTENAME(@ConfigurationSchemaName)
        + '.' + QUOTENAME(@ConfigurationTableName)
        + ' ; ' ;
   EXEC(@config_sql);
END

RAISERROR(N'Setting up variables', 0, 1) WITH NOWAIT;
DECLARE @sql NVARCHAR(MAX) = N'',
        @insert_list NVARCHAR(MAX) = N'',
        @plans_triggers_select_list NVARCHAR(MAX) = N'',
        @body NVARCHAR(MAX) = N'',
        @body_where NVARCHAR(MAX) = N'WHERE 1 = 1 ' + @nl,
        @body_order NVARCHAR(MAX) = N'ORDER BY #sortable# DESC OPTION (RECOMPILE) ',
        
        @q NVARCHAR(1) = N'''',
        @pv VARCHAR(20),
        @pos TINYINT,
        @v DECIMAL(6,2),
        @build INT;


RAISERROR (N'Determining SQL Server version.',0,1) WITH NOWAIT;

INSERT INTO #checkversion (version)
SELECT CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128))
OPTION (RECOMPILE);


SELECT @v = common_version ,
       @build = build
FROM   #checkversion
OPTION (RECOMPILE);

IF (@SortOrder IN ('memory grant', 'avg memory grant')) 
AND ((@v &lt; 11)
OR (@v = 11 AND @build &lt; 6020) 
OR (@v = 12 AND @build &lt; 5000) 
OR (@v = 13 AND @build &lt; 1601))
BEGIN
   RAISERROR('Your version of SQL does not support sorting by memory grant or average memory grant. Please use another sort order.', 16, 1);
   RETURN;
END

RAISERROR (N'Creating dynamic SQL based on SQL Server version.',0,1) WITH NOWAIT;

SET @insert_list += N'
INSERT INTO ##bou_BlitzCacheProcs (SPID, QueryType, DatabaseName, AverageCPU, TotalCPU, AverageCPUPerMinute, PercentCPUByType, PercentDurationByType,
                    PercentReadsByType, PercentExecutionsByType, AverageDuration, TotalDuration, AverageReads, TotalReads, ExecutionCount,
                    ExecutionsPerMinute, TotalWrites, AverageWrites, PercentWritesByType, WritesPerMinute, PlanCreationTime,
                    LastExecutionTime, StatementStartOffset, StatementEndOffset, MinReturnedRows, MaxReturnedRows, AverageReturnedRows, TotalReturnedRows,
                    LastReturnedRows, MinGrantKB, MaxGrantKB, MinUsedGrantKB, MaxUsedGrantKB, PercentMemoryGrantUsed, AvgMaxMemoryGrant,
					QueryText, QueryPlan, TotalWorkerTimeForType, TotalElapsedTimeForType, TotalReadsForType,
                    TotalExecutionCountForType, TotalWritesForType, SqlHandle, PlanHandle, QueryHash, QueryPlanHash,
                    min_worker_time, max_worker_time, is_parallel, min_elapsed_time, max_elapsed_time, age_minutes, age_minutes_lifetime) ' ;

SET @body += N'
FROM   (SELECT TOP (@Top) x.*, xpa.*,
               CAST((CASE WHEN DATEDIFF(mi, cached_time, GETDATE()) &gt; 0 AND execution_count &gt; 1
                          THEN DATEDIFF(mi, cached_time, GETDATE()) 
                          ELSE NULL END) as MONEY) as age_minutes,
               CAST((CASE WHEN DATEDIFF(mi, cached_time, last_execution_time) &gt; 0 AND execution_count &gt; 1
                          THEN DATEDIFF(mi, cached_time, last_execution_time) 
                          ELSE Null END) as MONEY) as age_minutes_lifetime
        FROM   sys.#view# x
               CROSS APPLY (SELECT * FROM sys.dm_exec_plan_attributes(x.plan_handle) AS ixpa 
                            WHERE ixpa.attribute = ''dbid'') AS xpa ' + @nl ;

SET @body += N'        WHERE  1 = 1 ' +  @nl ;


IF @IgnoreSystemDBs = 1
    BEGIN
	RAISERROR(N'Ignoring system databases by default', 0, 1) WITH NOWAIT;
	SET @body += N'               AND COALESCE(DB_NAME(CAST(xpa.value AS INT)), '''') NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''32767'') AND COALESCE(DB_NAME(CAST(xpa.value AS INT)), '''') NOT IN (SELECT name FROM sys.databases WHERE is_distributor = 1)' + @nl ;
	END 

IF @DatabaseName IS NOT NULL OR @DatabaseName &lt;&gt; ''
	BEGIN 
    RAISERROR(N'Filtering database name chosen', 0, 1) WITH NOWAIT;
	SET @body += N'               AND CAST(xpa.value AS BIGINT) = DB_ID('
                 + QUOTENAME(@DatabaseName, N'''')
                 + N') ' + @nl;
	END 

IF (SELECT COUNT(*) FROM #only_sql_handles) &gt; 0
BEGIN
    RAISERROR(N'Including only chosen SQL Handles', 0, 1) WITH NOWAIT;
	SET @body += N'               AND EXISTS(SELECT 1/0 FROM #only_sql_handles q WHERE q.sql_handle = x.sql_handle) ' + @nl ;
END      

IF (SELECT COUNT(*) FROM #only_query_hashes) &gt; 0
   AND (SELECT COUNT(*) FROM #ignore_query_hashes) = 0
   AND (SELECT COUNT(*) FROM #only_sql_handles) = 0
BEGIN
    RAISERROR(N'Including only chosen Query Hashes', 0, 1) WITH NOWAIT;
	SET @body += N'               AND EXISTS(SELECT 1/0 FROM #only_query_hashes q WHERE q.query_hash = x.query_hash) ' + @nl ;
END

/* filtering for query hashes */
IF (SELECT COUNT(*) FROM #ignore_query_hashes) &gt; 0
   AND (SELECT COUNT(*) FROM #only_query_hashes) = 0
BEGIN
    RAISERROR(N'Excluding chosen Query Hashes', 0, 1) WITH NOWAIT;
	SET @body += N'               AND NOT EXISTS(SELECT 1/0 FROM #ignore_query_hashes iq WHERE iq.query_hash = x.query_hash) ' + @nl ;
END
/* end filtering for query hashes */


IF @DurationFilter IS NOT NULL
    BEGIN 
	RAISERROR(N'Setting duration filter', 0, 1) WITH NOWAIT;
	SET @body += N'       AND (total_elapsed_time / 1000.0) / execution_count &gt; @min_duration ' + @nl ;
	END 


/* Apply the sort order here to only grab relevant plans.
   This should make it faster to process since we'll be pulling back fewer
   plans for processing.
 */
RAISERROR(N'Applying chosen sort order', 0, 1) WITH NOWAIT;
SELECT @body += N'        ORDER BY ' +
                CASE @SortOrder  WHEN N'cpu' THEN N'total_worker_time'
                                 WHEN N'reads' THEN N'total_logical_reads'
                                 WHEN N'writes' THEN N'total_logical_writes'
                                 WHEN N'duration' THEN N'total_elapsed_time'
                                 WHEN N'executions' THEN N'execution_count'
                                 WHEN N'compiles' THEN N'cached_time'
								 WHEN N'memory grant' THEN N'max_grant_kb'
                                 /* And now the averages */
                                 WHEN N'avg cpu' THEN N'total_worker_time / execution_count'
                                 WHEN N'avg reads' THEN N'total_logical_reads / execution_count'
                                 WHEN N'avg writes' THEN N'total_logical_writes / execution_count'
                                 WHEN N'avg duration' THEN N'total_elapsed_time / execution_count'
								 WHEN N'avg memory grant' THEN N'CASE WHEN max_grant_kb = 0 THEN 0 ELSE max_grant_kb / execution_count END'
                                 WHEN N'avg executions' THEN 'CASE WHEN execution_count = 0 THEN 0
            WHEN COALESCE(CAST((CASE WHEN DATEDIFF(mi, cached_time, GETDATE()) &gt; 0 AND execution_count &gt; 1
                          THEN DATEDIFF(mi, cached_time, GETDATE())
                          ELSE NULL END) as MONEY), CAST((CASE WHEN DATEDIFF(mi, cached_time, last_execution_time) &gt; 0 AND execution_count &gt; 1
                          THEN DATEDIFF(mi, cached_time, last_execution_time)
                          ELSE Null END) as MONEY), 0) = 0 THEN 0
            ELSE CAST((1.00 * execution_count / COALESCE(CAST((CASE WHEN DATEDIFF(mi, cached_time, GETDATE()) &gt; 0 AND execution_count &gt; 1
                          THEN DATEDIFF(mi, cached_time, GETDATE())
                          ELSE NULL END) as MONEY), CAST((CASE WHEN DATEDIFF(mi, cached_time, last_execution_time) &gt; 0 AND execution_count &gt; 1
                          THEN DATEDIFF(mi, cached_time, last_execution_time)
                          ELSE Null END) as MONEY))) AS money)
            END '
                END + N' DESC ' + @nl ;


                          
SET @body += N') AS qs 
	   CROSS JOIN(SELECT SUM(execution_count) AS t_TotalExecs,
                         SUM(CAST(total_elapsed_time AS BIGINT) / 1000.0) AS t_TotalElapsed,
                         SUM(CAST(total_worker_time AS BIGINT) / 1000.0) AS t_TotalWorker,
                         SUM(CAST(total_logical_reads AS BIGINT)) AS t_TotalReads,
                         SUM(CAST(total_logical_writes AS BIGINT)) AS t_TotalWrites
                  FROM   sys.#view#) AS t
       CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS pa
       CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
       CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) AS qp ' + @nl ;

SET @body_where += N'       AND pa.attribute = ' + QUOTENAME('dbid', @q) + @nl ;



SET @plans_triggers_select_list += N'
SELECT TOP (@Top)
       @@SPID ,
       ''Procedure: '' + COALESCE(OBJECT_NAME(qs.object_id, qs.database_id),'''') AS QueryType,
       COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), ''-- N/A --'') AS DatabaseName,
       (total_worker_time / 1000.0) / execution_count AS AvgCPU ,
       (total_worker_time / 1000.0) AS TotalCPU ,
       CASE WHEN total_worker_time = 0 THEN 0
            WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time), 0) = 0 THEN 0
            ELSE CAST((total_worker_time / 1000.0) / COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time)) AS MONEY)
            END AS AverageCPUPerMinute ,
       CASE WHEN t.t_TotalWorker = 0 THEN 0
            ELSE CAST(ROUND(100.00 * (total_worker_time / 1000.0) / t.t_TotalWorker, 2) AS MONEY)
            END AS PercentCPUByType,
       CASE WHEN t.t_TotalElapsed = 0 THEN 0
            ELSE CAST(ROUND(100.00 * (total_elapsed_time / 1000.0) / t.t_TotalElapsed, 2) AS MONEY)
            END AS PercentDurationByType,
       CASE WHEN t.t_TotalReads = 0 THEN 0
            ELSE CAST(ROUND(100.00 * total_logical_reads / t.t_TotalReads, 2) AS MONEY)
            END AS PercentReadsByType,
       CASE WHEN t.t_TotalExecs = 0 THEN 0
            ELSE CAST(ROUND(100.00 * execution_count / t.t_TotalExecs, 2) AS MONEY)
            END AS PercentExecutionsByType,
       (total_elapsed_time / 1000.0) / execution_count AS AvgDuration ,
       (total_elapsed_time / 1000.0) AS TotalDuration ,
       total_logical_reads / execution_count AS AvgReads ,
       total_logical_reads AS TotalReads ,
       execution_count AS ExecutionCount ,
       CASE WHEN execution_count = 0 THEN 0
            WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time), 0) = 0 THEN 0
            ELSE CAST((1.00 * execution_count / COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time))) AS money)
            END AS ExecutionsPerMinute ,
       total_logical_writes AS TotalWrites ,
       total_logical_writes / execution_count AS AverageWrites ,
       CASE WHEN t.t_TotalWrites = 0 THEN 0
            ELSE CAST(ROUND(100.00 * total_logical_writes / t.t_TotalWrites, 2) AS MONEY)
            END AS PercentWritesByType,
       CASE WHEN total_logical_writes = 0 THEN 0
            WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time), 0) = 0 THEN 0
            ELSE CAST((1.00 * total_logical_writes / COALESCE(age_minutes, DATEDIFF(mi, qs.cached_time, qs.last_execution_time), 0)) AS money)
            END AS WritesPerMinute,
       qs.cached_time AS PlanCreationTime,
       qs.last_execution_time AS LastExecutionTime,
       NULL AS StatementStartOffset,
       NULL AS StatementEndOffset,
       NULL AS MinReturnedRows,
       NULL AS MaxReturnedRows,
       NULL AS AvgReturnedRows,
       NULL AS TotalReturnedRows,
       NULL AS LastReturnedRows,
       NULL AS MinGrantKB,
       NULL AS MaxGrantKB,
       NULL AS MinUsedGrantKB, 
	   NULL AS MaxUsedGrantKB,
	   NULL AS PercentMemoryGrantUsed, 
	   NULL AS AvgMaxMemoryGrant,
       st.text AS QueryText ,
       query_plan AS QueryPlan,
       t.t_TotalWorker,
       t.t_TotalElapsed,
       t.t_TotalReads,
       t.t_TotalExecs,
       t.t_TotalWrites,
       qs.sql_handle AS SqlHandle,
       qs.plan_handle AS PlanHandle,
       NULL AS QueryHash,
       NULL AS QueryPlanHash,
       qs.min_worker_time / 1000.0,
       qs.max_worker_time / 1000.0,
       CASE WHEN qp.query_plan.value(''declare namespace p="http://schemas.microsoft.com/sqlserver/2004/07/showplan";max(//p:RelOp/@Parallel)'', ''float'')  &gt; 0 THEN 1 ELSE 0 END,
       qs.min_elapsed_time / 1000.0,
       qs.max_elapsed_time / 1000.0,
       age_minutes, 
       age_minutes_lifetime '


IF LEFT(@QueryFilter, 3) IN ('all', 'sta')
BEGIN
    SET @sql += @insert_list;
    
    SET @sql += N'
    SELECT TOP (@Top)
           @@SPID ,
           ''Statement'' AS QueryType,
           COALESCE(DB_NAME(CAST(pa.value AS INT)), ''-- N/A --'') AS DatabaseName,
           (total_worker_time / 1000.0) / execution_count AS AvgCPU ,
           (total_worker_time / 1000.0) AS TotalCPU ,
           CASE WHEN total_worker_time = 0 THEN 0
                WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time), 0) = 0 THEN 0
                ELSE CAST((total_worker_time / 1000.0) / COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time)) AS MONEY)
                END AS AverageCPUPerMinute ,
           CAST(ROUND(100.00 * (total_worker_time / 1000.0) / t.t_TotalWorker, 2) AS MONEY) AS PercentCPUByType,
           CAST(ROUND(100.00 * (total_elapsed_time / 1000.0) / t.t_TotalElapsed, 2) AS MONEY) AS PercentDurationByType,
           CAST(ROUND(100.00 * total_logical_reads / t.t_TotalReads, 2) AS MONEY) AS PercentReadsByType,
           CAST(ROUND(100.00 * execution_count / t.t_TotalExecs, 2) AS MONEY) AS PercentExecutionsByType,
           (total_elapsed_time / 1000.0) / execution_count AS AvgDuration ,
           (total_elapsed_time / 1000.0) AS TotalDuration ,
           total_logical_reads / execution_count AS AvgReads ,
           total_logical_reads AS TotalReads ,
           execution_count AS ExecutionCount ,
           CASE WHEN execution_count = 0 THEN 0
                WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time), 0) = 0 THEN 0
                ELSE CAST((1.00 * execution_count / COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time))) AS money)
                END AS ExecutionsPerMinute ,
           total_logical_writes AS TotalWrites ,
           total_logical_writes / execution_count AS AverageWrites ,
           CASE WHEN t.t_TotalWrites = 0 THEN 0
                ELSE CAST(ROUND(100.00 * total_logical_writes / t.t_TotalWrites, 2) AS MONEY)
                END AS PercentWritesByType,
           CASE WHEN total_logical_writes = 0 THEN 0
                WHEN COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time), 0) = 0 THEN 0
                ELSE CAST((1.00 * total_logical_writes / COALESCE(age_minutes, DATEDIFF(mi, qs.creation_time, qs.last_execution_time), 0)) AS money)
                END AS WritesPerMinute,
           qs.creation_time AS PlanCreationTime,
           qs.last_execution_time AS LastExecutionTime,
           qs.statement_start_offset AS StatementStartOffset,
           qs.statement_end_offset AS StatementEndOffset, '
    
    IF (@v &gt;= 11) OR (@v &gt;= 10.5 AND @build &gt;= 2500)
    BEGIN
        RAISERROR(N'Adding additional info columns for newer versions of SQL', 0, 1) WITH NOWAIT;
		SET @sql += N'
           qs.min_rows AS MinReturnedRows,
           qs.max_rows AS MaxReturnedRows,
           CAST(qs.total_rows as MONEY) / execution_count AS AvgReturnedRows,
           qs.total_rows AS TotalReturnedRows,
           qs.last_rows AS LastReturnedRows, ' ;
    END
    ELSE
    BEGIN
		RAISERROR(N'Substituting NULLs for more info columns in older versions of SQL', 0, 1) WITH NOWAIT;
        SET @sql += N'
           NULL AS MinReturnedRows,
           NULL AS MaxReturnedRows,
           NULL AS AvgReturnedRows,
           NULL AS TotalReturnedRows,
           NULL AS LastReturnedRows, ' ;
    END

    IF (@v = 11 AND @build &gt;= 6020) OR (@v = 12 AND @build &gt;= 5000) OR (@v = 13 AND @build &gt;= 1601)

    BEGIN
        RAISERROR(N'Getting memory grant information for newer versions of SQL', 0, 1) WITH NOWAIT;
		SET @sql += N'
           min_grant_kb AS MinGrantKB,
           max_grant_kb AS MaxGrantKB,
           min_used_grant_kb AS MinUsedGrantKB,
           max_used_grant_kb AS MaxUsedGrantKB,
           CAST(ISNULL(NULLIF(( max_used_grant_kb * 1.00 ), 0) / NULLIF(min_grant_kb, 0), 0) * 100. AS MONEY) AS PercentMemoryGrantUsed,
		   CAST(ISNULL(NULLIF(( max_grant_kb * 1. ), 0) / NULLIF(execution_count, 0), 0) AS MONEY) AS AvgMaxMemoryGrant, ';
    END
    ELSE
    BEGIN
        RAISERROR(N'Substituting NULLs for memory grant columns in older versions of SQL', 0, 1) WITH NOWAIT;
		SET @sql += N'
           NULL AS MinGrantKB,
           NULL AS MaxGrantKB,
           NULL AS MinUsedGrantKB, 
		   NULL AS MaxUsedGrantKB,
		   NULL AS PercentMemoryGrantUsed, 
		   NULL AS AvgMaxMemoryGrant, ' ;
    END

    
    SET @sql += N'
           SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                            WHEN -1 THEN DATALENGTH(st.text)
                                                                            ELSE qs.statement_end_offset
                                                                          END - qs.statement_start_offset ) / 2 ) + 1) AS QueryText ,
           query_plan AS QueryPlan,
           t.t_TotalWorker,
           t.t_TotalElapsed,
           t.t_TotalReads,
           t.t_TotalExecs,
           t.t_TotalWrites,
           qs.sql_handle AS SqlHandle,
           qs.plan_handle AS PlanHandle,
           qs.query_hash AS QueryHash,
           qs.query_plan_hash AS QueryPlanHash,
           qs.min_worker_time / 1000.0,
           qs.max_worker_time / 1000.0,
           CASE WHEN qp.query_plan.value(''declare namespace p="http://schemas.microsoft.com/sqlserver/2004/07/showplan";max(//p:RelOp/@Parallel)'', ''float'')  &gt; 0 THEN 1 ELSE 0 END,
           qs.min_elapsed_time / 1000.0,
           qs.max_worker_time  / 1000.0,
           age_minutes,
           age_minutes_lifetime ';
    
    SET @sql += REPLACE(REPLACE(@body, '#view#', 'dm_exec_query_stats'), 'cached_time', 'creation_time') ;
    
    SET @sql += REPLACE(@body_where, 'cached_time', 'creation_time') ;
    
    SET @sql += @body_order + @nl + @nl + @nl;

    IF @SortOrder = 'compiles'
    BEGIN
        RAISERROR(N'Sorting by compiles', 0, 1) WITH NOWAIT;
		SET @sql = REPLACE(@sql, '#sortable#', 'creation_time');
    END
END


IF (@QueryFilter = 'all' 
   AND (SELECT COUNT(*) FROM #only_query_hashes) = 0 
   AND (SELECT COUNT(*) FROM #ignore_query_hashes) = 0) 
   AND (@SortOrder NOT IN ('memory grant', 'avg memory grant'))
   OR (LEFT(@QueryFilter, 3) = 'pro')
BEGIN
    SET @sql += @insert_list;
    SET @sql += REPLACE(@plans_triggers_select_list, '#query_type#', 'Stored Procedure') ;

    SET @sql += REPLACE(@body, '#view#', 'dm_exec_procedure_stats') ; 
    SET @sql += @body_where ;

    IF @IgnoreSystemDBs = 1
       SET @sql += N' AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''32767'') AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (SELECT name FROM sys.databases WHERE is_distributor = 1)' + @nl ;

    SET @sql += @body_order + @nl + @nl + @nl ;
END



/*******************************************************************************
 *
 * Because the trigger execution count in SQL Server 2008R2 and earlier is not
 * correct, we ignore triggers for these versions of SQL Server. If you'd like
 * to include trigger numbers, just know that the ExecutionCount,
 * PercentExecutions, and ExecutionsPerMinute are wildly inaccurate for
 * triggers on these versions of SQL Server.
 *
 * This is why we can't have nice things.
 *
 ******************************************************************************/
IF (@UseTriggersAnyway = 1 OR @v &gt;= 11)
   AND (SELECT COUNT(*) FROM #only_query_hashes) = 0
   AND (SELECT COUNT(*) FROM #ignore_query_hashes) = 0
   AND (@QueryFilter = 'all')
   AND (@SortOrder NOT IN ('memory grant', 'avg memory grant'))
BEGIN
   RAISERROR (N'Adding SQL to collect trigger stats.',0,1) WITH NOWAIT;

   /* Trigger level information from the plan cache */
   SET @sql += @insert_list ;

   SET @sql += REPLACE(@plans_triggers_select_list, '#query_type#', 'Trigger') ;

   SET @sql += REPLACE(@body, '#view#', 'dm_exec_trigger_stats') ;

   SET @sql += @body_where ;

   IF @IgnoreSystemDBs = 1
      SET @sql += N' AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (''master'', ''model'', ''msdb'', ''tempdb'', ''32767'') AND COALESCE(DB_NAME(database_id), CAST(pa.value AS sysname), '''') NOT IN (SELECT name FROM sys.databases WHERE is_distributor = 1)' + @nl ;
   
   SET @sql += @body_order + @nl + @nl + @nl ;
END

DECLARE @sort NVARCHAR(MAX);

SELECT @sort = CASE @SortOrder  WHEN N'cpu' THEN N'total_worker_time'
                                WHEN N'reads' THEN N'total_logical_reads'
                                WHEN N'writes' THEN N'total_logical_writes'
                                WHEN N'duration' THEN N'total_elapsed_time'
                                WHEN N'executions' THEN N'execution_count'
                                WHEN N'compiles' THEN N'cached_time'
								WHEN N'memory grant' THEN N'max_grant_kb'
                                /* And now the averages */
                                WHEN N'avg cpu' THEN N'total_worker_time / execution_count'
                                WHEN N'avg reads' THEN N'total_logical_reads / execution_count'
                                WHEN N'avg writes' THEN N'total_logical_writes / execution_count'
                                WHEN N'avg duration' THEN N'total_elapsed_time / execution_count'
								WHEN N'avg memory grant' THEN N'CASE WHEN max_grant_kb = 0 THEN 0 ELSE max_grant_kb / execution_count END'
                                WHEN N'avg executions' THEN N'CASE WHEN execution_count = 0 THEN 0
            WHEN COALESCE(age_minutes, age_minutes_lifetime, 0) = 0 THEN 0
            ELSE CAST((1.00 * execution_count / COALESCE(age_minutes, age_minutes_lifetime)) AS money)
            END'
               END ;

SELECT @sql = REPLACE(@sql, '#sortable#', @sort);

SET @sql += N'
INSERT INTO #p (SqlHandle, TotalCPU, TotalReads, TotalDuration, TotalWrites, ExecutionCount)
SELECT  SqlHandle,
        TotalCPU,
        TotalReads,
        TotalDuration,
        TotalWrites,
        ExecutionCount
FROM    (SELECT  SqlHandle,
                 TotalCPU,
                 TotalReads,
                 TotalDuration,
                 TotalWrites,
                 ExecutionCount,
                 ROW_NUMBER() OVER (PARTITION BY SqlHandle ORDER BY #sortable# DESC) AS rn
         FROM    ##bou_BlitzCacheProcs) AS x
WHERE x.rn = 1
OPTION (RECOMPILE);
';

SELECT @sort = CASE @SortOrder  WHEN N'cpu' THEN N'TotalCPU'
                                WHEN N'reads' THEN N'TotalReads'
                                WHEN N'writes' THEN N'TotalWrites'
                                WHEN N'duration' THEN N'TotalDuration'
                                WHEN N'executions' THEN N'ExecutionCount'
                                WHEN N'compiles' THEN N'PlanCreationTime'
								WHEN N'memory grant' THEN N'MaxGrantKB'
                                WHEN N'avg cpu' THEN N'TotalCPU / ExecutionCount'
                                WHEN N'avg reads' THEN N'TotalReads / ExecutionCount'
                                WHEN N'avg writes' THEN N'TotalWrites / ExecutionCount'
                                WHEN N'avg duration' THEN N'TotalDuration / ExecutionCount'
								WHEN N'avg memory grant' THEN N'AvgMaxMemoryGrant'
                                WHEN N'avg executions' THEN N'CASE WHEN ExecutionCount = 0 THEN 0
            WHEN COALESCE(age_minutes, age_minutes_lifetime, 0) = 0 THEN 0
            ELSE CAST((1.00 * ExecutionCount / COALESCE(age_minutes, age_minutes_lifetime)) AS money)
            END'
               END ;

SELECT @sql = REPLACE(@sql, '#sortable#', @sort);

IF @Reanalyze = 0
BEGIN
    RAISERROR('Collecting execution plan information.', 0, 1) WITH NOWAIT;

    EXEC sp_executesql @sql, N'@Top INT, @min_duration INT', @Top, @DurationFilter_i;
END

/*
--Debugging section
SELECT DATALENGTH(@sql)
PRINT SUBSTRING(@sql, 0, 4000)
PRINT SUBSTRING(@sql, 4000, 8000)
PRINT SUBSTRING(@sql, 8000, 12000)
PRINT SUBSTRING(@sql, 16000, 24000)
PRINT SUBSTRING(@sql, 24000, 28000)
PRINT SUBSTRING(@sql, 28000, 32000)
PRINT SUBSTRING(@sql, 32000, 36000)
PRINT SUBSTRING(@sql, 36000, 40000)
*/

/* Update ##bou_BlitzCacheProcs to get Stored Proc info 
 * This should get totals for all statements in a Stored Proc
 */
RAISERROR(N'Attempting to aggregate stored proc info from separate statements', 0, 1) WITH NOWAIT;
;WITH agg AS (
    SELECT 
        b.SqlHandle,
        SUM(b.MinReturnedRows) AS MinReturnedRows,
        SUM(b.MaxReturnedRows) AS MaxReturnedRows,
        SUM(b.AverageReturnedRows) AS AverageReturnedRows,
        SUM(b.TotalReturnedRows) AS TotalReturnedRows,
        SUM(b.LastReturnedRows) AS LastReturnedRows
    FROM ##bou_BlitzCacheProcs b
    WHERE b.QueryHash IS NOT NULL 
    GROUP BY b.SqlHandle
)
UPDATE b
    SET 
        b.MinReturnedRows     = b2.MinReturnedRows,
        b.MaxReturnedRows     = b2.MaxReturnedRows,
        b.AverageReturnedRows = b2.AverageReturnedRows,
        b.TotalReturnedRows   = b2.TotalReturnedRows,
        b.LastReturnedRows    = b2.LastReturnedRows
FROM ##bou_BlitzCacheProcs b
JOIN agg b2
ON b2.SqlHandle = b.SqlHandle
WHERE b.QueryHash IS NULL
OPTION (RECOMPILE) ;

/* Compute the total CPU, etc across our active set of the plan cache.
 * Yes, there's a flaw - this doesn't include anything outside of our @Top
 * metric.
 */
RAISERROR('Computing CPU, duration, read, and write metrics', 0, 1) WITH NOWAIT;
DECLARE @total_duration BIGINT,
        @total_cpu BIGINT,
        @total_reads BIGINT,
        @total_writes BIGINT,
        @total_execution_count BIGINT;

SELECT  @total_cpu = SUM(TotalCPU),
        @total_duration = SUM(TotalDuration),
        @total_reads = SUM(TotalReads),
        @total_writes = SUM(TotalWrites),
        @total_execution_count = SUM(ExecutionCount)
FROM    #p
OPTION (RECOMPILE) ;

DECLARE @cr NVARCHAR(1) = NCHAR(13);
DECLARE @lf NVARCHAR(1) = NCHAR(10);
DECLARE @tab NVARCHAR(1) = NCHAR(9);

/* Update CPU percentage for stored procedures */
RAISERROR(N'Update CPU percentage for stored procedures', 0, 1) WITH NOWAIT;
UPDATE ##bou_BlitzCacheProcs
SET     PercentCPU = y.PercentCPU,
        PercentDuration = y.PercentDuration,
        PercentReads = y.PercentReads,
        PercentWrites = y.PercentWrites,
        PercentExecutions = y.PercentExecutions,
        ExecutionsPerMinute = y.ExecutionsPerMinute,
        /* Strip newlines and tabs. Tabs are replaced with multiple spaces
           so that the later whitespace trim will completely eliminate them
         */
        QueryText = REPLACE(REPLACE(REPLACE(QueryText, @cr, ' '), @lf, ' '), @tab, '  ')
FROM (
    SELECT  PlanHandle,
            CASE @total_cpu WHEN 0 THEN 0
                 ELSE CAST((100. * TotalCPU) / @total_cpu AS MONEY) END AS PercentCPU,
            CASE @total_duration WHEN 0 THEN 0
                 ELSE CAST((100. * TotalDuration) / @total_duration AS MONEY) END AS PercentDuration,
            CASE @total_reads WHEN 0 THEN 0
                 ELSE CAST((100. * TotalReads) / @total_reads AS MONEY) END AS PercentReads,
            CASE @total_writes WHEN 0 THEN 0
                 ELSE CAST((100. * TotalWrites) / @total_writes AS MONEY) END AS PercentWrites,
            CASE @total_execution_count WHEN 0 THEN 0
                 ELSE CAST((100. * ExecutionCount) / @total_execution_count AS MONEY) END AS PercentExecutions,
            CASE DATEDIFF(mi, PlanCreationTime, LastExecutionTime)
                WHEN 0 THEN 0
                ELSE CAST((1.00 * ExecutionCount / DATEDIFF(mi, PlanCreationTime, LastExecutionTime)) AS MONEY)
            END AS ExecutionsPerMinute
    FROM (
        SELECT  PlanHandle,
                TotalCPU,
                TotalDuration,
                TotalReads,
                TotalWrites,
                ExecutionCount,
                PlanCreationTime,
                LastExecutionTime
        FROM    ##bou_BlitzCacheProcs
        WHERE   PlanHandle IS NOT NULL
        GROUP BY PlanHandle,
                TotalCPU,
                TotalDuration,
                TotalReads,
                TotalWrites,
                ExecutionCount,
                PlanCreationTime,
                LastExecutionTime
    ) AS x
) AS y
WHERE ##bou_BlitzCacheProcs.PlanHandle = y.PlanHandle
      AND ##bou_BlitzCacheProcs.PlanHandle IS NOT NULL
OPTION (RECOMPILE) ;


RAISERROR(N'Gather percentage information from grouped results', 0, 1) WITH NOWAIT;
UPDATE ##bou_BlitzCacheProcs
SET     PercentCPU = y.PercentCPU,
        PercentDuration = y.PercentDuration,
        PercentReads = y.PercentReads,
        PercentWrites = y.PercentWrites,
        PercentExecutions = y.PercentExecutions,
        ExecutionsPerMinute = y.ExecutionsPerMinute,
        /* Strip newlines and tabs. Tabs are replaced with multiple spaces
           so that the later whitespace trim will completely eliminate them
         */
        QueryText = REPLACE(REPLACE(REPLACE(QueryText, @cr, ' '), @lf, ' '), @tab, '  ')
FROM (
    SELECT  DatabaseName,
            SqlHandle,
            QueryHash,
            CASE @total_cpu WHEN 0 THEN 0
                 ELSE CAST((100. * TotalCPU) / @total_cpu AS MONEY) END AS PercentCPU,
            CASE @total_duration WHEN 0 THEN 0
                 ELSE CAST((100. * TotalDuration) / @total_duration AS MONEY) END AS PercentDuration,
            CASE @total_reads WHEN 0 THEN 0
                 ELSE CAST((100. * TotalReads) / @total_reads AS MONEY) END AS PercentReads,
            CASE @total_writes WHEN 0 THEN 0
                 ELSE CAST((100. * TotalWrites) / @total_writes AS MONEY) END AS PercentWrites,
            CASE @total_execution_count WHEN 0 THEN 0
                 ELSE CAST((100. * ExecutionCount) / @total_execution_count AS MONEY) END AS PercentExecutions,
            CASE  DATEDIFF(mi, PlanCreationTime, LastExecutionTime)
                WHEN 0 THEN 0
                ELSE CAST((1.00 * ExecutionCount / DATEDIFF(mi, PlanCreationTime, LastExecutionTime)) AS MONEY)
            END AS ExecutionsPerMinute
    FROM (
        SELECT  DatabaseName,
                SqlHandle,
                QueryHash,
                TotalCPU,
                TotalDuration,
                TotalReads,
                TotalWrites,
                ExecutionCount,
                PlanCreationTime,
                LastExecutionTime
        FROM    ##bou_BlitzCacheProcs
        GROUP BY DatabaseName,
                SqlHandle,
                QueryHash,
                TotalCPU,
                TotalDuration,
                TotalReads,
                TotalWrites,
                ExecutionCount,
                PlanCreationTime,
                LastExecutionTime
    ) AS x
) AS y
WHERE   ##bou_BlitzCacheProcs.SqlHandle = y.SqlHandle
        AND ##bou_BlitzCacheProcs.QueryHash = y.QueryHash
        AND ##bou_BlitzCacheProcs.DatabaseName = y.DatabaseName
        AND ##bou_BlitzCacheProcs.PlanHandle IS NULL
OPTION (RECOMPILE) ;



/* Testing using XML nodes to speed up processing */
RAISERROR(N'Begin XML nodes processing', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
SELECT  QueryHash ,
        SqlHandle ,
		PlanHandle,
        q.n.query('.') AS statement
INTO    #statements
FROM    ##bou_BlitzCacheProcs p
        CROSS APPLY p.QueryPlan.nodes('//p:StmtSimple') AS q(n) 
OPTION (RECOMPILE) ;

WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
INSERT #statements
SELECT  QueryHash ,
        SqlHandle ,
		PlanHandle,
        q.n.query('.') AS statement
FROM    ##bou_BlitzCacheProcs p
        CROSS APPLY p.QueryPlan.nodes('//p:StmtCursor') AS q(n) 
OPTION (RECOMPILE) ;

WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
SELECT  QueryHash ,
        SqlHandle ,
        q.n.query('.') AS query_plan
INTO    #query_plan
FROM    #statements p
        CROSS APPLY p.statement.nodes('//p:QueryPlan') AS q(n) 
OPTION (RECOMPILE) ;

WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
SELECT  QueryHash ,
        SqlHandle ,
        q.n.query('.') AS relop
INTO    #relop
FROM    #query_plan p
        CROSS APPLY p.query_plan.nodes('//p:RelOp') AS q(n) 
OPTION (RECOMPILE) ;



-- high level plan stuff
RAISERROR(N'Gathering high level plan information', 0, 1) WITH NOWAIT;
UPDATE  ##bou_BlitzCacheProcs
SET     NumberOfDistinctPlans = distinct_plan_count,
        NumberOfPlans = number_of_plans ,
        plan_multiple_plans = CASE WHEN distinct_plan_count &lt; number_of_plans THEN 1 END
FROM (
        SELECT  COUNT(DISTINCT QueryHash) AS distinct_plan_count,
                COUNT(QueryHash) AS number_of_plans,
                QueryHash
        FROM    ##bou_BlitzCacheProcs
        GROUP BY QueryHash
) AS x
WHERE ##bou_BlitzCacheProcs.QueryHash = x.QueryHash
OPTION (RECOMPILE) ;

-- statement level checks
RAISERROR(N'Performing statement level checks', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE ##bou_BlitzCacheProcs
SET     QueryPlanCost = CASE WHEN QueryType LIKE '%Stored Procedure%' THEN
                                statement.value('sum(/p:StmtSimple/@StatementSubTreeCost)', 'float')
                             ELSE
                                statement.value('sum(/p:StmtSimple[xs:hexBinary(substring(@QueryPlanHash, 3)) = xs:hexBinary(sql:column("QueryPlanHash"))]/@StatementSubTreeCost)', 'float')
                        END ,
        compile_timeout = CASE WHEN statement.exist('/p:StmtSimple/@StatementOptmEarlyAbortReason[.="TimeOut"]') = 1 THEN 1 END ,
        compile_memory_limit_exceeded = CASE WHEN statement.exist('/p:StmtSimple/@StatementOptmEarlyAbortReason[.="MemoryLimitExceeded"]') = 1 THEN 1 END ,
        unmatched_index_count = statement.value('count(//p:UnmatchedIndexes/Parameterization/Object)', 'int') ,
        is_trivial = CASE WHEN statement.exist('/p:StmtSimple[@StatementOptmLevel[.="TRIVIAL"]]/p:QueryPlan/p:ParameterList') = 1 THEN 1 END ,
        unparameterized_query = CASE WHEN statement.exist('//p:StmtSimple[@StatementOptmLevel[.="FULL"]]/p:QueryPlan/p:ParameterList') = 1 AND
                                          statement.exist('//p:StmtSimple[@StatementOptmLevel[.="FULL"]]/p:QueryPlan/p:ParameterList/p:ColumnReference') = 0 THEN 1
                                     WHEN statement.exist('//p:StmtSimple[@StatementOptmLevel[.="FULL"]]/p:QueryPlan/p:ParameterList') = 0 AND
                                          statement.exist('//p:StmtSimple[@StatementOptmLevel[.="FULL"]]/*/p:RelOp/descendant::p:ScalarOperator/p:Identifier/p:ColumnReference[contains(@Column, "@")]') = 1 THEN 1
                                END
FROM    #statements s
WHERE   s.QueryHash = ##bou_BlitzCacheProcs.QueryHash
OPTION (RECOMPILE);

--Gather Stored Proc costs
RAISERROR(N'Gathering stored procedure costs', 0, 1) WITH NOWAIT;
;WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
, QueryCost AS (
  SELECT
    statement.value('sum(/p:StmtSimple/@StatementSubTreeCost)', 'float') AS SubTreeCost,
    s.PlanHandle,
	s.SqlHandle
  FROM #statements AS s
  WHERE PlanHandle IS NOT NULL
)
, QueryCostUpdate AS (
  SELECT
	SUM(qc.SubTreeCost) OVER (PARTITION BY SqlHandle, PlanHandle) PlanTotalQuery,
    qc.PlanHandle,
    qc.SqlHandle
  FROM QueryCost qc
    WHERE qc.SubTreeCost &gt; 0
)
  UPDATE b
    SET b.QueryPlanCost = 
    CASE WHEN 
      b.QueryType LIKE '%Procedure%' THEN 
         (SELECT TOP 1 PlanTotalQuery FROM QueryCostUpdate qcu WHERE qcu.PlanHandle = b.PlanHandle ORDER BY PlanTotalQuery DESC)
       ELSE 
         b.QueryPlanCost 
    	 END
  FROM QueryCostUpdate qcu
    JOIN  ##bou_BlitzCacheProcs AS b
  ON qcu.SqlHandle = b.SqlHandle
OPTION (RECOMPILE);

-- query level checks
RAISERROR(N'Performing query level checks', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE  ##bou_BlitzCacheProcs
SET     missing_index_count = query_plan.value('count(/p:QueryPlan/p:MissingIndexes/p:MissingIndexGroup)', 'int') ,
        SerialDesiredMemory = query_plan.value('sum(/p:QueryPlan/p:MemoryGrantInfo/@SerialDesiredMemory)', 'float') ,
        SerialRequiredMemory = query_plan.value('sum(/p:QueryPlan/p:MemoryGrantInfo/@SerialRequiredMemory)', 'float'),
        CachedPlanSize = query_plan.value('sum(/p:QueryPlan/@CachedPlanSize)', 'float') ,
        CompileTime = query_plan.value('sum(/p:QueryPlan/@CompileTime)', 'float') ,
        CompileCPU = query_plan.value('sum(/p:QueryPlan/@CompileCPU)', 'float') ,
        CompileMemory = query_plan.value('sum(/p:QueryPlan/@CompileMemory)', 'float') ,
        implicit_conversions = CASE WHEN query_plan.exist('/p:QueryPlan/p:Warnings/p:PlanAffectingConvert/@Expression[contains(., "CONVERT_IMPLICIT")]') = 1 THEN 1 END ,
        plan_warnings = CASE WHEN query_plan.value('count(/p:QueryPlan/p:Warnings)', 'int') &gt; 0 THEN 1 END,
		is_forced_serial = CASE WHEN query_plan.value('count(/p:QueryPlan/@NonParallelPlanReason)', 'int') &gt; 0 THEN 1 END
FROM    #query_plan qp
WHERE   qp.QueryHash = ##bou_BlitzCacheProcs.QueryHash
OPTION (RECOMPILE);

-- operator level checks
RAISERROR(N'Performing operator level checks', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE p
SET    busy_loops = CASE WHEN (x.estimated_executions / 100.0) &gt; x.estimated_rows THEN 1 END ,
       tvf_join = CASE WHEN x.tvf_join = 1 THEN 1 END ,
       warning_no_join_predicate = CASE WHEN x.no_join_warning = 1 THEN 1 END,
	   is_table_variable = CASE WHEN x.is_table_variable = 1 THEN 1 END,
	   no_stats_warning = CASE WHEN x.no_stats_warning = 1 THEN 1 END,
	   relop_warnings = CASE WHEN x.relop_warnings = 1 THEN 1 END
FROM   ##bou_BlitzCacheProcs p
       JOIN (
            SELECT qs.SqlHandle,
                   relop.value('sum(/p:RelOp/@EstimateRows)', 'float') AS estimated_rows ,
                   relop.value('sum(/p:RelOp/@EstimateRewinds)', 'float') + relop.value('sum(/p:RelOp/@EstimateRebinds)', 'float') + 1.0 AS estimated_executions ,
                   relop.exist('/p:RelOp[contains(@LogicalOp, "Join")]/*/p:RelOp[(@LogicalOp[.="Table-valued function"])]') AS tvf_join,
                   relop.exist('/p:RelOp/p:Warnings[(@NoJoinPredicate[.="1"])]') AS no_join_warning,
				   relop.exist('/p:RelOp//*[local-name() = "Object"]/@Table[contains(., "@")]') AS is_table_variable,
				   relop.exist('/p:RelOp/p:Warnings/p:ColumnsWithNoStatistics') AS no_stats_warning ,
				   relop.exist('/p:RelOp/p:Warnings') AS relop_warnings
            FROM   #relop qs
       ) AS x ON p.SqlHandle = x.SqlHandle
OPTION (RECOMPILE);


RAISERROR(N'Checking for functions', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
, x AS (
SELECT qs.QueryHash,
	   n.fn.value('count(distinct-values(//p:UserDefinedFunction[not(@IsClrFunction)]))', 'INT') AS function_count,
	   n.fn.value('count(distinct-values(//p:UserDefinedFunction[@IsClrFunction = "1"]))', 'INT') AS clr_function_count
FROM   #relop qs
CROSS APPLY relop.nodes('/p:RelOp/p:ComputeScalar/p:DefinedValues/p:DefinedValue/p:ScalarOperator') n(fn)
)
UPDATE p
SET	   p.function_count = x.function_count,
	   p.clr_function_count = x.clr_function_count
FROM ##bou_BlitzCacheProcs AS p
JOIN x ON x.QueryHash = p.QueryHash
OPTION (RECOMPILE);


RAISERROR(N'Checking for expensive key lookups', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE ##bou_BlitzCacheProcs
SET key_lookup_cost = x.key_lookup_cost
FROM (
SELECT 
       qs.SqlHandle,
	   relop.value('sum(/p:RelOp/@EstimatedTotalSubtreeCost)', 'float') AS key_lookup_cost
FROM   #relop qs
WHERE [relop].exist('/p:RelOp/p:IndexScan[(@Lookup[.="1"])]') = 1
) AS x
WHERE ##bou_BlitzCacheProcs.SqlHandle = x.SqlHandle
OPTION (RECOMPILE) ;


RAISERROR(N'Checking for expensive remote queries', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE ##bou_BlitzCacheProcs
SET remote_query_cost = x.remote_query_cost
FROM (
SELECT 
       qs.SqlHandle,
	   relop.value('sum(/p:RelOp/@EstimatedTotalSubtreeCost)', 'float') AS remote_query_cost
FROM   #relop qs
WHERE [relop].exist('/p:RelOp[(@PhysicalOp[contains(., "Remote")])]') = 1
) AS x
WHERE ##bou_BlitzCacheProcs.SqlHandle = x.SqlHandle
OPTION (RECOMPILE) ;

RAISERROR(N'Checking for expensive sorts', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE ##bou_BlitzCacheProcs
SET sort_cost = (x.sort_io + x.sort_cpu) 
FROM (
SELECT 
       qs.SqlHandle,
	   relop.value('sum(/p:RelOp/@EstimateIO)', 'float') AS sort_io,
	   relop.value('sum(/p:RelOp/@EstimateCPU)', 'float') AS sort_cpu
FROM   #relop qs
WHERE [relop].exist('/p:RelOp[(@PhysicalOp[.="Sort"])]') = 1
) AS x
WHERE ##bou_BlitzCacheProcs.SqlHandle = x.SqlHandle
OPTION (RECOMPILE) ;

RAISERROR(N'Checking for icky cursors', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE b
SET b.is_optimistic_cursor =  CASE WHEN n1.fn.exist('//p:CursorPlan/@CursorConcurrency[.="Optimistic"]') = 1 THEN 1 END,
	b.is_forward_only_cursor = CASE WHEN n1.fn.exist('//p:CursorPlan/@ForwardOnly[.="true"]') = 1 THEN 1 ELSE 0 END
FROM ##bou_BlitzCacheProcs b
JOIN #statements AS qs
ON b.QueryHash = qs.QueryHash
CROSS APPLY qs.statement.nodes('/p:StmtCursor') AS n1(fn)
OPTION (RECOMPILE) ;


RAISERROR(N'Checking for bad scans and plan forcing', 0, 1) WITH NOWAIT;
;WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE b
SET 
b.is_table_scan = x.is_table_scan,
b.backwards_scan = x.backwards_scan,
b.forced_index = x.forced_index,
b.forced_seek = x.forced_seek,
b.forced_scan = x.forced_scan
FROM ##bou_BlitzCacheProcs b
JOIN (
SELECT 
       qs.SqlHandle,
	   0 AS is_table_scan,
	   q.n.exist('@ScanDirection[.="BACKWARD"]') AS backwards_scan,
	   q.n.value('@ForcedIndex', 'bit') AS forced_index,
	   q.n.value('@ForceSeek', 'bit') AS forced_seek,
	   q.n.value('@ForceScan', 'bit') AS forced_scan
FROM   #relop qs
CROSS APPLY qs.relop.nodes('//p:IndexScan') AS q(n)
UNION ALL
SELECT 
       qs.SqlHandle,
	   1 AS is_table_scan,
	   q.n.exist('@ScanDirection[.="BACKWARD"]') AS backwards_scan,
	   q.n.value('@ForcedIndex', 'bit') AS forced_index,
	   q.n.value('@ForceSeek', 'bit') AS forced_seek,
	   q.n.value('@ForceScan', 'bit') AS forced_scan
FROM   #relop qs
CROSS APPLY qs.relop.nodes('//p:TableScan') AS q(n)
) AS x ON b.SqlHandle = x.SqlHandle
OPTION (RECOMPILE) ;


RAISERROR(N'Checking for ColumnStore queries operating in Row Mode instead of Batch Mode', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE ##bou_BlitzCacheProcs
SET columnstore_row_mode = x.is_row_mode
FROM (
SELECT 
       qs.SqlHandle,
	   relop.exist('/p:RelOp[(@EstimatedExecutionMode[.="Row"])]') AS is_row_mode
FROM   #relop qs
WHERE [relop].exist('/p:RelOp/p:IndexScan[(@Storage[.="ColumnStore"])]') = 1
) AS x
WHERE ##bou_BlitzCacheProcs.SqlHandle = x.SqlHandle
OPTION (RECOMPILE) ;


RAISERROR(N'Checking for computed columns that reference scalar UDFs', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE ##bou_BlitzCacheProcs
SET is_computed_scalar = x.computed_column_function
FROM (
SELECT qs.SqlHandle,
	   n.fn.value('count(distinct-values(//p:UserDefinedFunction[not(@IsClrFunction)]))', 'INT') AS computed_column_function
FROM   #relop qs
CROSS APPLY relop.nodes('/p:RelOp/p:ComputeScalar/p:DefinedValues/p:DefinedValue/p:ScalarOperator') n(fn)
WHERE n.fn.exist('/p:RelOp/p:ComputeScalar/p:DefinedValues/p:DefinedValue/p:ColumnReference[(@ComputedColumn[.="1"])]') = 1
) AS x
WHERE ##bou_BlitzCacheProcs.SqlHandle = x.SqlHandle
OPTION (RECOMPILE)


IF @v &gt;= 12
BEGIN
    RAISERROR('Checking for downlevel cardinality estimators being used on SQL Server 2014.', 0, 1) WITH NOWAIT;

    WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
    UPDATE  p
    SET     downlevel_estimator = CASE WHEN statement.value('min(//p:StmtSimple/@CardinalityEstimationModelVersion)', 'int') &lt; (@v * 10) THEN 1 END
    FROM    ##bou_BlitzCacheProcs p
            JOIN #statements s ON p.QueryHash = s.QueryHash 
	OPTION (RECOMPILE) ;
END ;

/* END Testing using XML nodes to speed up processing */
RAISERROR(N'Gathering additional plan level information', 0, 1) WITH NOWAIT;
WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE ##bou_BlitzCacheProcs
SET NumberOfDistinctPlans = distinct_plan_count,
    NumberOfPlans = number_of_plans,
    QueryPlanCost = CASE WHEN QueryType LIKE '%Procedure%' THEN
        QueryPlanCost
        ELSE
        QueryPlan.value('sum(//p:StmtSimple[xs:hexBinary(substring(@QueryPlanHash, 3)) = xs:hexBinary(sql:column("QueryPlanHash"))]/@StatementSubTreeCost)', 'float')
        END,
	missing_index_count = QueryPlan.value('count(//p:MissingIndexGroup)', 'int') ,
    unmatched_index_count = QueryPlan.value('count(//p:UnmatchedIndexes/p:Parameterization/p:Object)', 'int') ,
    plan_multiple_plans = CASE WHEN distinct_plan_count &lt; number_of_plans THEN 1 END ,
    is_trivial = CASE WHEN QueryPlan.exist('//p:StmtSimple[@StatementOptmLevel[.="TRIVIAL"]]/p:QueryPlan/p:ParameterList') = 1 THEN 1 END ,
    SerialDesiredMemory = QueryPlan.value('sum(//p:MemoryGrantInfo/@SerialDesiredMemory)', 'float') ,
    SerialRequiredMemory = QueryPlan.value('sum(//p:MemoryGrantInfo/@SerialRequiredMemory)', 'float'),
    CachedPlanSize = QueryPlan.value('sum(//p:QueryPlan/@CachedPlanSize)', 'float') ,
    CompileTime = QueryPlan.value('sum(//p:QueryPlan/@CompileTime)', 'float') ,
    CompileCPU = QueryPlan.value('sum(//p:QueryPlan/@CompileCPU)', 'float') ,
    CompileMemory = QueryPlan.value('sum(//p:QueryPlan/@CompileMemory)', 'float')
FROM (
SELECT COUNT(DISTINCT QueryHash) AS distinct_plan_count,
       COUNT(QueryHash) AS number_of_plans,
       QueryHash
FROM   ##bou_BlitzCacheProcs
GROUP BY QueryHash
) AS x
WHERE ##bou_BlitzCacheProcs.QueryHash = x.QueryHash
OPTION (RECOMPILE) ;

/* Update to grab stored procedure name for individual statements */
RAISERROR(N'Attempting to get stored procedure name for individual statements', 0, 1) WITH NOWAIT;
UPDATE  p
SET     QueryType = QueryType + ' (parent ' +
                    + QUOTENAME(OBJECT_SCHEMA_NAME(s.object_id, s.database_id))
                    + '.'
                    + QUOTENAME(OBJECT_NAME(s.object_id, s.database_id)) + ')'
FROM    ##bou_BlitzCacheProcs p
        JOIN sys.dm_exec_procedure_stats s ON p.SqlHandle = s.sql_handle
WHERE   QueryType = 'Statement'

/* Trace Flag Checks 2014 SP2 and 2016 SP1 only)*/
RAISERROR(N'Trace flag checks', 0, 1) WITH NOWAIT;
;WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
, tf_pretty AS (
SELECT  qp.QueryHash,
		qp.SqlHandle,
		q.n.value('@Value', 'INT') AS trace_flag,
		q.n.value('@Scope', 'VARCHAR(10)') AS scope
FROM    #query_plan qp
CROSS APPLY qp.query_plan.nodes('/p:QueryPlan/p:TraceFlags/p:TraceFlag') AS q(n)
)
SELECT DISTINCT tf1.SqlHandle , tf1.QueryHash,
    STUFF((
          SELECT DISTINCT ', ' + CONVERT(VARCHAR(5), tf2.trace_flag)
          FROM  tf_pretty AS tf2 
          WHERE tf1.SqlHandle = tf2.SqlHandle 
		  AND tf1.QueryHash = tf2.QueryHash
		  AND tf2.scope = 'Global'
        FOR XML PATH(N'')), 1, 2, N''
      ) AS global_trace_flags,
    STUFF((
          SELECT DISTINCT ', ' + CONVERT(VARCHAR(5), tf2.trace_flag)
          FROM  tf_pretty AS tf2 
          WHERE tf1.SqlHandle = tf2.SqlHandle 
		  AND tf1.QueryHash = tf2.QueryHash
		  AND tf2.scope = 'Session'
        FOR XML PATH(N'')), 1, 2, N''
      ) AS session_trace_flags
INTO #trace_flags
FROM tf_pretty AS tf1
OPTION (RECOMPILE);

UPDATE p
SET    p.trace_flags_session = tf.session_trace_flags
FROM   ##bou_BlitzCacheProcs p
JOIN #trace_flags tf ON tf.QueryHash = p.QueryHash --AND tf.SqlHandle = p.PlanHandle
OPTION(RECOMPILE);

IF @SkipAnalysis = 1
    BEGIN
	RAISERROR(N'Skipping analysis, going to results', 0, 1) WITH NOWAIT; 
	GOTO Results ;
	END 


/* Set configuration values */
RAISERROR(N'Setting configuration values', 0, 1) WITH NOWAIT;
DECLARE @execution_threshold INT = 1000 ,
        @parameter_sniffing_warning_pct TINYINT = 30,
        /* This is in average reads */
        @parameter_sniffing_io_threshold BIGINT = 100000 ,
        @ctp_threshold_pct TINYINT = 10,
        @long_running_query_warning_seconds BIGINT = 300 * 1000 ,
		@memory_grant_warning_percent INT = 10;

IF EXISTS (SELECT 1/0 FROM #configuration WHERE 'frequent execution threshold' = LOWER(parameter_name))
BEGIN
    SELECT @execution_threshold = CAST(value AS INT)
    FROM   #configuration
    WHERE  'frequent execution threshold' = LOWER(parameter_name) ;

    SET @msg = ' Setting "frequent execution threshold" to ' + CAST(@execution_threshold AS VARCHAR(10)) ;

    RAISERROR(@msg, 0, 1) WITH NOWAIT;
END

IF EXISTS (SELECT 1/0 FROM #configuration WHERE 'parameter sniffing variance percent' = LOWER(parameter_name))
BEGIN
    SELECT @parameter_sniffing_warning_pct = CAST(value AS TINYINT)
    FROM   #configuration
    WHERE  'parameter sniffing variance percent' = LOWER(parameter_name) ;

    SET @msg = ' Setting "parameter sniffing variance percent" to ' + CAST(@parameter_sniffing_warning_pct AS VARCHAR(3)) ;

    RAISERROR(@msg, 0, 1) WITH NOWAIT;
END

IF EXISTS (SELECT 1/0 FROM #configuration WHERE 'parameter sniffing io threshold' = LOWER(parameter_name))
BEGIN
    SELECT @parameter_sniffing_io_threshold = CAST(value AS BIGINT)
    FROM   #configuration
    WHERE 'parameter sniffing io threshold' = LOWER(parameter_name) ;

    SET @msg = ' Setting "parameter sniffing io threshold" to ' + CAST(@parameter_sniffing_io_threshold AS VARCHAR(10));

    RAISERROR(@msg, 0, 1) WITH NOWAIT;
END

IF EXISTS (SELECT 1/0 FROM #configuration WHERE 'cost threshold for parallelism warning' = LOWER(parameter_name))
BEGIN
    SELECT @ctp_threshold_pct = CAST(value AS TINYINT)
    FROM   #configuration
    WHERE 'cost threshold for parallelism warning' = LOWER(parameter_name) ;

    SET @msg = ' Setting "cost threshold for parallelism warning" to ' + CAST(@ctp_threshold_pct AS VARCHAR(3));

    RAISERROR(@msg, 0, 1) WITH NOWAIT;
END

IF EXISTS (SELECT 1/0 FROM #configuration WHERE 'long running query warning (seconds)' = LOWER(parameter_name))
BEGIN
    SELECT @long_running_query_warning_seconds = CAST(value * 1000 AS BIGINT)
    FROM   #configuration
    WHERE 'long running query warning (seconds)' = LOWER(parameter_name) ;

    SET @msg = ' Setting "long running query warning (seconds)" to ' + CAST(@long_running_query_warning_seconds AS VARCHAR(10));

    RAISERROR(@msg, 0, 1) WITH NOWAIT;
END

IF EXISTS (SELECT 1/0 FROM #configuration WHERE 'unused memory grant' = LOWER(parameter_name))
BEGIN
    SELECT @memory_grant_warning_percent = CAST(value AS INT)
    FROM   #configuration
    WHERE 'unused memory grant' = LOWER(parameter_name) ;

    SET @msg = ' Setting "unused memory grant" to ' + CAST(@memory_grant_warning_percent AS VARCHAR(10));

    RAISERROR(@msg, 0, 1) WITH NOWAIT;
END

DECLARE @ctp INT ;

SELECT  @ctp = NULLIF(CAST(value AS INT), 0)
FROM    sys.configurations
WHERE   name = 'cost threshold for parallelism'
OPTION (RECOMPILE);


/* Update to populate checks columns */
RAISERROR('Checking for query level SQL Server issues.', 0, 1) WITH NOWAIT;

WITH XMLNAMESPACES('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS p)
UPDATE ##bou_BlitzCacheProcs
SET    frequent_execution = CASE WHEN ExecutionsPerMinute &gt; @execution_threshold THEN 1 END ,
       parameter_sniffing = CASE WHEN AverageReads &gt; @parameter_sniffing_io_threshold
                                      AND min_worker_time &lt; ((1.0 - (@parameter_sniffing_warning_pct / 100.0)) * AverageCPU) THEN 1
                                 WHEN AverageReads &gt; @parameter_sniffing_io_threshold
                                      AND max_worker_time &gt; ((1.0 + (@parameter_sniffing_warning_pct / 100.0)) * AverageCPU) THEN 1
                                 WHEN AverageReads &gt; @parameter_sniffing_io_threshold
                                      AND MinReturnedRows &lt; ((1.0 - (@parameter_sniffing_warning_pct / 100.0)) * AverageReturnedRows) THEN 1
                                 WHEN AverageReads &gt; @parameter_sniffing_io_threshold
                                      AND MaxReturnedRows &gt; ((1.0 + (@parameter_sniffing_warning_pct / 100.0)) * AverageReturnedRows) THEN 1 END ,
       near_parallel = CASE WHEN QueryPlanCost BETWEEN @ctp * (1 - (@ctp_threshold_pct / 100.0)) AND @ctp THEN 1 END,
       long_running = CASE WHEN AverageDuration &gt; @long_running_query_warning_seconds THEN 1
                           WHEN max_worker_time &gt; @long_running_query_warning_seconds THEN 1
                           WHEN max_elapsed_time &gt; @long_running_query_warning_seconds THEN 1 END,
	   is_key_lookup_expensive = CASE WHEN QueryPlanCost &gt; (@ctp / 2) AND key_lookup_cost &gt;= QueryPlanCost * .5 THEN 1 END,
	   is_sort_expensive = CASE WHEN QueryPlanCost &gt; (@ctp / 2) AND sort_cost &gt;= QueryPlanCost * .5 THEN 1 END,
	   is_remote_query_expensive = CASE WHEN remote_query_cost &gt;= QueryPlanCost * .05 THEN 1 END,
	   is_forced_serial = CASE WHEN is_forced_serial = 1 AND QueryPlanCost &gt; (@ctp / 2) THEN 1 END,
	   is_unused_grant = CASE WHEN PercentMemoryGrantUsed &lt;= @memory_grant_warning_percent AND MinGrantKB &gt; @MinMemoryPerQuery THEN 1 END
OPTION (RECOMPILE) ;



RAISERROR('Checking for forced parameterization and cursors.', 0, 1) WITH NOWAIT;

/* Set options checks */
UPDATE p
       SET is_forced_parameterized = CASE WHEN (CAST(pa.value AS INT) &amp; 131072 = 131072) THEN 1
       END ,
       is_forced_plan = CASE WHEN (CAST(pa.value AS INT) &amp; 4 = 4) THEN 1 
       END ,
       SetOptions = SUBSTRING(
                    CASE WHEN (CAST(pa.value AS INT) &amp; 1 = 1) THEN ', ANSI_PADDING' ELSE '' END +
                    CASE WHEN (CAST(pa.value AS INT) &amp; 8 = 8) THEN ', CONCAT_NULL_YIELDS_NULL' ELSE '' END +
                    CASE WHEN (CAST(pa.value AS INT) &amp; 16 = 16) THEN ', ANSI_WARNINGS' ELSE '' END +
                    CASE WHEN (CAST(pa.value AS INT) &amp; 32 = 32) THEN ', ANSI_NULLS' ELSE '' END +
                    CASE WHEN (CAST(pa.value AS INT) &amp; 64 = 64) THEN ', QUOTED_IDENTIFIER' ELSE '' END +
                    CASE WHEN (CAST(pa.value AS INT) &amp; 4096 = 4096) THEN ', ARITH_ABORT' ELSE '' END +
                    CASE WHEN (CAST(pa.value AS INT) &amp; 8192 = 8191) THEN ', NUMERIC_ROUNDABORT' ELSE '' END 
                    , 2, 200000)
FROM   ##bou_BlitzCacheProcs p
       CROSS APPLY sys.dm_exec_plan_attributes(p.PlanHandle) pa
WHERE  pa.attribute = 'set_options' 
OPTION (RECOMPILE) ;


/* Cursor checks */
UPDATE p
SET    is_cursor = CASE WHEN CAST(pa.value AS INT) &lt;&gt; 0 THEN 1 END
FROM   ##bou_BlitzCacheProcs p
       CROSS APPLY sys.dm_exec_plan_attributes(p.PlanHandle) pa
WHERE  pa.attribute LIKE '%cursor%' 
OPTION (RECOMPILE) ;



RAISERROR('Populating Warnings column', 0, 1) WITH NOWAIT;

/* Populate warnings */
UPDATE ##bou_BlitzCacheProcs
SET    Warnings = CASE WHEN QueryPlan IS NULL THEN 'We couldn''t find a plan for this query. Possible reasons for this include dynamic SQL, RECOMPILE hints, and encrypted code.' ELSE
				  SUBSTRING(
                  CASE WHEN warning_no_join_predicate = 1 THEN ', No Join Predicate' ELSE '' END +
                  CASE WHEN compile_timeout = 1 THEN ', Compilation Timeout' ELSE '' END +
                  CASE WHEN compile_memory_limit_exceeded = 1 THEN ', Compile Memory Limit Exceeded' ELSE '' END +
                  CASE WHEN busy_loops = 1 THEN ', Busy Loops' ELSE '' END +
                  CASE WHEN is_forced_plan = 1 THEN ', Forced Plan' ELSE '' END +
                  CASE WHEN is_forced_parameterized = 1 THEN ', Forced Parameterization' ELSE '' END +
                  CASE WHEN unparameterized_query = 1 THEN ', Unparameterized Query' ELSE '' END +
                  CASE WHEN missing_index_count &gt; 0 THEN ', Missing Indexes (' + CAST(missing_index_count AS VARCHAR(3)) + ')' ELSE '' END +
                  CASE WHEN unmatched_index_count &gt; 0 THEN ', Unmatched Indexes (' + CAST(unmatched_index_count AS VARCHAR(3)) + ')' ELSE '' END +                  
                  CASE WHEN is_cursor = 1 THEN ', Cursor' 
							+ CASE WHEN is_optimistic_cursor = 1 THEN ' with optimistic' ELSE '' END
							+ CASE WHEN is_forward_only_cursor = 0 THEN ' with forward only' ELSE '' END							
				  ELSE '' END +
                  CASE WHEN is_parallel = 1 THEN ', Parallel' ELSE '' END +
                  CASE WHEN near_parallel = 1 THEN ', Nearly Parallel' ELSE '' END +
                  CASE WHEN frequent_execution = 1 THEN ', Frequent Execution' ELSE '' END +
                  CASE WHEN plan_warnings = 1 THEN ', Plan Warnings' ELSE '' END +
                  CASE WHEN parameter_sniffing = 1 THEN ', Parameter Sniffing' ELSE '' END +
                  CASE WHEN long_running = 1 THEN ', Long Running Query' ELSE '' END +
                  CASE WHEN downlevel_estimator = 1 THEN ', Downlevel CE' ELSE '' END +
                  CASE WHEN implicit_conversions = 1 THEN ', Implicit Conversions' ELSE '' END +
                  CASE WHEN tvf_join = 1 THEN ', Function Join' ELSE '' END +
                  CASE WHEN plan_multiple_plans = 1 THEN ', Multiple Plans' ELSE '' END +
                  CASE WHEN is_trivial = 1 THEN ', Trivial Plans' ELSE '' END +
				  CASE WHEN is_forced_serial = 1 THEN ', Forced Serialization' ELSE '' END +
				  CASE WHEN is_key_lookup_expensive = 1 THEN ', Expensive Key Lookup' ELSE '' END +
				  CASE WHEN is_remote_query_expensive = 1 THEN ', Expensive Remote Query' ELSE '' END + 
				  CASE WHEN trace_flags_session IS NOT NULL THEN ', Session Level Trace Flag(s) Enabled: ' + trace_flags_session ELSE '' END +
				  CASE WHEN is_unused_grant = 1 THEN ', Unused Memory Grant' ELSE '' END +
				  CASE WHEN function_count &gt; 0 THEN ', Calls ' + CONVERT(VARCHAR(10), function_count) + ' function(s)' ELSE '' END + 
				  CASE WHEN clr_function_count &gt; 0 THEN ', Calls ' + CONVERT(VARCHAR(10), clr_function_count) + ' CLR function(s)' ELSE '' END + 
				  CASE WHEN PlanCreationTimeHours &lt;= 4 THEN ', Plan created last 4hrs' ELSE '' END +
				  CASE WHEN is_table_variable = 1 THEN ', Table Variables' ELSE '' END +
				  CASE WHEN no_stats_warning = 1 THEN ', Columns With No Statistics' ELSE '' END +
				  CASE WHEN relop_warnings = 1 THEN ', Operator Warnings' ELSE '' END  + 
				  CASE WHEN is_table_scan = 1 THEN ', Table Scans' ELSE '' END  + 
				  CASE WHEN backwards_scan = 1 THEN ', Backwards Scans' ELSE '' END  + 
				  CASE WHEN forced_index = 1 THEN ', Forced Indexes' ELSE '' END  + 
				  CASE WHEN forced_seek = 1 THEN ', Forced Seeks' ELSE '' END  + 
				  CASE WHEN forced_scan = 1 THEN ', Forced Scans' ELSE '' END  +
				  CASE WHEN columnstore_row_mode = 1 THEN ', ColumnStore Row Mode ' ELSE '' END +
				  CASE WHEN is_computed_scalar = 1 THEN ', Computed Column UDF ' ELSE '' END  +
				  CASE WHEN is_sort_expensive = 1 THEN ', Expensive Sort' ELSE '' END 
                  , 2, 200000) 
				  END
				  OPTION (RECOMPILE) ;






Results:
IF @OutputDatabaseName IS NOT NULL
   AND @OutputSchemaName IS NOT NULL
   AND @OutputTableName IS NOT NULL
BEGIN
    RAISERROR('Writing results to table.', 0, 1) WITH NOWAIT;

    /* send results to a table */
    DECLARE @insert_sql NVARCHAR(MAX) = N'' ;

    SET @insert_sql = 'USE '
        + @OutputDatabaseName
        + '; IF EXISTS(SELECT * FROM '
        + @OutputDatabaseName
        + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
        + @OutputSchemaName
        + ''') AND NOT EXISTS (SELECT * FROM '
        + @OutputDatabaseName
        + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
        + @OutputSchemaName + ''' AND QUOTENAME(TABLE_NAME) = '''
        + @OutputTableName + ''') CREATE TABLE '
        + @OutputSchemaName + '.'
        + @OutputTableName
        + N'(ID bigint NOT NULL IDENTITY(1,1),
          ServerName nvarchar(256),
		  CheckDate DATETIMEOFFSET,
          Version nvarchar(256),
          QueryType nvarchar(256),
          Warnings varchar(max),
          DatabaseName sysname,
          SerialDesiredMemory float,
          SerialRequiredMemory float,
          AverageCPU bigint,
          TotalCPU bigint,
          PercentCPUByType money,
          CPUWeight money,
          AverageDuration bigint,
          TotalDuration bigint,
          DurationWeight money,
          PercentDurationByType money,
          AverageReads bigint,
          TotalReads bigint,
          ReadWeight money,
          PercentReadsByType money,
          AverageWrites bigint,
          TotalWrites bigint,
          WriteWeight money,
          PercentWritesByType money,
          ExecutionCount bigint,
          ExecutionWeight money,
          PercentExecutionsByType money,' + N'
          ExecutionsPerMinute money,
          PlanCreationTime datetime,
		  PlanCreationTimeHours AS DATEDIFF(HOUR, PlanCreationTime, SYSDATETIME()),
          LastExecutionTime datetime,
		  PlanHandle varbinary(64),
		  [Remove Plan Handle From Cache] AS 
			CASE WHEN [PlanHandle] IS NOT NULL 
			THEN ''DBCC FREEPROCCACHE ('' + CONVERT(VARCHAR(128), [PlanHandle], 1) + '');''
			ELSE ''N/A'' END,
		  SqlHandle varbinary(64),
			[Remove SQL Handle From Cache] AS 
			CASE WHEN [SqlHandle] IS NOT NULL 
			THEN ''DBCC FREEPROCCACHE ('' + CONVERT(VARCHAR(128), [SqlHandle], 1) + '');''
			ELSE ''N/A'' END,
		  [SQL Handle More Info] AS 
			CASE WHEN [SqlHandle] IS NOT NULL 
			THEN ''EXEC sp_BlitzCache @OnlySqlHandles = '''''' + CONVERT(VARCHAR(128), [SqlHandle], 1) + ''''''; ''
			ELSE ''N/A'' END,
		  QueryHash binary(8),
		  [Query Hash More Info] AS 
			CASE WHEN [QueryHash] IS NOT NULL 
			THEN ''EXEC sp_BlitzCache @OnlyQueryHashes = '''''' + CONVERT(VARCHAR(32), [QueryHash], 1) + ''''''; ''
			ELSE ''N/A'' END,
          QueryPlanHash binary(8),
          StatementStartOffset int,
          StatementEndOffset int,
          MinReturnedRows bigint,
          MaxReturnedRows bigint,
          AverageReturnedRows money,
          TotalReturnedRows bigint,
          QueryText nvarchar(max),
          QueryPlan xml,
          NumberOfPlans int,
          NumberOfDistinctPlans int,
		  MinGrantKB BIGINT,
		  MaxGrantKB BIGINT,
		  MinUsedGrantKB BIGINT, 
		  MaxUsedGrantKB BIGINT,
		  PercentMemoryGrantUsed MONEY,
		  AvgMaxMemoryGrant MONEY,
		  QueryPlanCost FLOAT,
          CONSTRAINT [PK_' +CAST(NEWID() AS NCHAR(36)) + '] PRIMARY KEY CLUSTERED(ID))';

    EXEC sp_executesql @insert_sql ;


    SET @insert_sql =N' IF EXISTS(SELECT * FROM '
          + @OutputDatabaseName
          + N'.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
          + @OutputSchemaName + N''') '
          + 'INSERT '
          + @OutputDatabaseName + '.'
          + @OutputSchemaName + '.'
          + @OutputTableName
          + N' (ServerName, CheckDate, Version, QueryType, DatabaseName, AverageCPU, TotalCPU, PercentCPUByType, CPUWeight, AverageDuration, TotalDuration, DurationWeight, PercentDurationByType, AverageReads, TotalReads, ReadWeight, PercentReadsByType, '
          + N' AverageWrites, TotalWrites, WriteWeight, PercentWritesByType, ExecutionCount, ExecutionWeight, PercentExecutionsByType, '
          + N' ExecutionsPerMinute, PlanCreationTime, LastExecutionTime, PlanHandle, SqlHandle, QueryHash, StatementStartOffset, StatementEndOffset, MinReturnedRows, MaxReturnedRows, AverageReturnedRows, TotalReturnedRows, QueryText, QueryPlan, NumberOfPlans, NumberOfDistinctPlans, Warnings, '
          + N' SerialRequiredMemory, SerialDesiredMemory, MinGrantKB, MaxGrantKB, MinUsedGrantKB, MaxUsedGrantKB, PercentMemoryGrantUsed, AvgMaxMemoryGrant) '
          + N'SELECT TOP (@Top) '
          + QUOTENAME(CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128)), N'''') + N', SYSDATETIMEOFFSET(),'
          + QUOTENAME(CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)), N'''') + ', '
          + N' QueryType, DatabaseName, AverageCPU, TotalCPU, PercentCPUByType, PercentCPU, AverageDuration, TotalDuration, PercentDuration, PercentDurationByType, AverageReads, TotalReads, PercentReads, PercentReadsByType, '
          + N' AverageWrites, TotalWrites, PercentWrites, PercentWritesByType, ExecutionCount, PercentExecutions, PercentExecutionsByType, '
          + N' ExecutionsPerMinute, PlanCreationTime, LastExecutionTime, PlanHandle, SqlHandle, QueryHash, StatementStartOffset, StatementEndOffset, MinReturnedRows, MaxReturnedRows, AverageReturnedRows, TotalReturnedRows, QueryText, QueryPlan, NumberOfPlans, NumberOfDistinctPlans, Warnings, '
          + N' SerialRequiredMemory, SerialDesiredMemory, MinGrantKB, MaxGrantKB, MinUsedGrantKB, MaxUsedGrantKB, PercentMemoryGrantUsed, AvgMaxMemoryGrant, QueryPlanCost '
          + N' FROM ##bou_BlitzCacheProcs '
          
    SELECT @insert_sql += N' ORDER BY ' + CASE @SortOrder WHEN 'cpu' THEN N' TotalCPU '
                                                    WHEN 'reads' THEN N' TotalReads '
                                                    WHEN 'writes' THEN N' TotalWrites '
                                                    WHEN 'duration' THEN N' TotalDuration '
                                                    WHEN 'executions' THEN N' ExecutionCount '
                                                    WHEN 'compiles' THEN N' PlanCreationTime '
													WHEN 'memory grant' THEN N' MaxGrantKB'
                                                    WHEN 'avg cpu' THEN N' AverageCPU'
                                                    WHEN 'avg reads' THEN N' AverageReads'
                                                    WHEN 'avg writes' THEN N' AverageWrites'
                                                    WHEN 'avg duration' THEN N' AverageDuration'
                                                    WHEN 'avg executions' THEN N' ExecutionsPerMinute'
													WHEN 'avg memory grant' THEN N' AvgMaxMemoryGrant'
                                                    END + N' DESC '

    SET @insert_sql += N' OPTION (RECOMPILE) ; '    
    
    EXEC sp_executesql @insert_sql, N'@Top INT', @Top;

    RETURN
END
ELSE IF @ExportToExcel = 1
BEGIN
    RAISERROR('Displaying results with Excel formatting (no plans).', 0, 1) WITH NOWAIT;

    /* excel output */
    UPDATE ##bou_BlitzCacheProcs
    SET QueryText = SUBSTRING(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(QueryText)),' ','&lt;&gt;'),'&gt;&lt;',''),'&lt;&gt;',' '), 1, 32000);

    SET @sql = N'
    SELECT  TOP (@Top)
            DatabaseName AS [Database Name],
            QueryPlanCost AS [Cost],
            QueryText,
            QueryType AS [Query Type],
            Warnings,
            ExecutionCount,
            ExecutionsPerMinute AS [Executions / Minute],
            PercentExecutions AS [Execution Weight],
            PercentExecutionsByType AS [% Executions (Type)],
            SerialDesiredMemory AS [Serial Desired Memory],
            SerialRequiredMemory AS [Serial Required Memory],
            TotalCPU AS [Total CPU (ms)],
            AverageCPU AS [Avg CPU (ms)],
            PercentCPU AS [CPU Weight],
            PercentCPUByType AS [% CPU (Type)],
            TotalDuration AS [Total Duration (ms)],
            AverageDuration AS [Avg Duration (ms)],
            PercentDuration AS [Duration Weight],
            PercentDurationByType AS [% Duration (Type)],
            TotalReads AS [Total Reads],
            AverageReads AS [Average Reads],
            PercentReads AS [Read Weight],
            PercentReadsByType AS [% Reads (Type)],
            TotalWrites AS [Total Writes],
            AverageWrites AS [Average Writes],
            PercentWrites AS [Write Weight],
            PercentWritesByType AS [% Writes (Type)],
            TotalReturnedRows,
            AverageReturnedRows,
            MinReturnedRows,
            MaxReturnedRows,
		    MinGrantKB,
		    MaxGrantKB,
		    MinUsedGrantKB, 
		    MaxUsedGrantKB,
		    PercentMemoryGrantUsed,
			AvgMaxMemoryGrant,
            NumberOfPlans,
            NumberOfDistinctPlans,
            PlanCreationTime AS [Created At],
            LastExecutionTime AS [Last Execution],
            StatementStartOffset,
            StatementEndOffset,
			PlanHandle AS [Plan Handle],  
			SqlHandle AS [SQL Handle],  
            QueryHash,
            QueryPlanHash,
            COALESCE(SetOptions, '''') AS [SET Options]
    FROM    ##bou_BlitzCacheProcs
    WHERE   1 = 1 ' + @nl

    SELECT @sql += N' ORDER BY ' + CASE @SortOrder WHEN 'cpu' THEN ' TotalCPU '
                              WHEN 'reads' THEN ' TotalReads '
                              WHEN 'writes' THEN ' TotalWrites '
                              WHEN 'duration' THEN ' TotalDuration '
                              WHEN 'executions' THEN ' ExecutionCount '
                              WHEN 'compiles' THEN ' PlanCreationTime '
							  WHEN 'memory grant' THEN 'MaxGrantKB'
                              WHEN 'avg cpu' THEN 'AverageCPU'
                              WHEN 'avg reads' THEN 'AverageReads'
                              WHEN 'avg writes' THEN 'AverageWrites'
                              WHEN 'avg duration' THEN 'AverageDuration'
                              WHEN 'avg executions' THEN 'ExecutionsPerMinute'
							  WHEN 'avg memory grant' THEN 'AvgMaxMemoryGrant'
                              END + N' DESC '

    SET @sql += N' OPTION (RECOMPILE) ; '

    EXEC sp_executesql @sql, N'@Top INT', @Top ;
END


RAISERROR('Displaying analysis of plan cache.', 0, 1) WITH NOWAIT;

DECLARE @columns NVARCHAR(MAX) = N'' ;

IF @ExpertMode = 0
BEGIN
    RAISERROR(N'Returning ExpertMode = 0', 0, 1) WITH NOWAIT;
	SET @columns = N' DatabaseName AS [Database],
    QueryPlanCost AS [Cost],
    QueryText AS [Query Text],
    QueryType AS [Query Type],
    Warnings AS [Warnings],
    ExecutionCount AS [# Executions],
    ExecutionsPerMinute AS [Executions / Minute],
    PercentExecutions AS [Execution Weight],
    TotalCPU AS [Total CPU (ms)],
    AverageCPU AS [Avg CPU (ms)],
    PercentCPU AS [CPU Weight],
    TotalDuration AS [Total Duration (ms)],
    AverageDuration AS [Avg Duration (ms)],
    PercentDuration AS [Duration Weight],
    TotalReads AS [Total Reads],
    AverageReads AS [Avg Reads],
    PercentReads AS [Read Weight],
    TotalWrites AS [Total Writes],
    AverageWrites AS [Avg Writes],
    PercentWrites AS [Write Weight],
    AverageReturnedRows AS [Average Rows],
	MinGrantKB AS [Minimum Memory Grant KB],
	MaxGrantKB AS [Maximum Memory Grant KB],
	MinUsedGrantKB AS [Minimum Used Grant KB], 
	MaxUsedGrantKB AS [Maximum Used Grant KB],
	AvgMaxMemoryGrant AS [Average Max Memory Grant],
    PlanCreationTime AS [Created At],
    LastExecutionTime AS [Last Execution],
	PlanHandle AS [Plan Handle], 
	SqlHandle AS [SQL Handle], 
    QueryPlan AS [Query Plan],
    COALESCE(SetOptions, '''') AS [SET Options] ';
END
ELSE
BEGIN
    SET @columns = N' DatabaseName AS [Database],
        QueryText AS [Query Text],
        QueryType AS [Query Type],
        Warnings AS [Warnings], ' + @nl

    IF @ExpertMode = 2 /* Opserver */
    BEGIN
        RAISERROR(N'Returning Expert Mode = 2', 0, 1) WITH NOWAIT;
		SET @columns += N'        
				  CASE WHEN QueryPlan IS NULL THEN ''We couldn''''t find a plan for this query. Possible reasons for this include dynamic SQL, RECOMPILE hints, and encrypted code.'' ELSE
				  SUBSTRING(
                  CASE WHEN warning_no_join_predicate = 1 THEN '', 20'' ELSE '''' END +
                  CASE WHEN compile_timeout = 1 THEN '', 18'' ELSE '''' END +
                  CASE WHEN compile_memory_limit_exceeded = 1 THEN '', 19'' ELSE '''' END +
                  CASE WHEN busy_loops = 1 THEN '', 16'' ELSE '''' END +
                  CASE WHEN is_forced_plan = 1 THEN '', 3'' ELSE '''' END +
                  CASE WHEN is_forced_parameterized &gt; 0 THEN '', 5'' ELSE '''' END +
                  CASE WHEN unparameterized_query = 1 THEN '', 23'' ELSE '''' END +
                  CASE WHEN missing_index_count &gt; 0 THEN '', 10'' ELSE '''' END +
                  CASE WHEN unmatched_index_count &gt; 0 THEN '', 22'' ELSE '''' END +                  
                  CASE WHEN is_cursor = 1 THEN '', 4'' ELSE '''' END +
                  CASE WHEN is_parallel = 1 THEN '', 6'' ELSE '''' END +
                  CASE WHEN near_parallel = 1 THEN '', 7'' ELSE '''' END +
                  CASE WHEN frequent_execution = 1 THEN '', 1'' ELSE '''' END +
                  CASE WHEN plan_warnings = 1 THEN '', 8'' ELSE '''' END +
                  CASE WHEN parameter_sniffing = 1 THEN '', 2'' ELSE '''' END +
                  CASE WHEN long_running = 1 THEN '', 9'' ELSE '''' END +
                  CASE WHEN downlevel_estimator = 1 THEN '', 13'' ELSE '''' END +
                  CASE WHEN implicit_conversions = 1 THEN '', 14'' ELSE '''' END +
                  CASE WHEN tvf_join = 1 THEN '', 17'' ELSE '''' END +
                  CASE WHEN plan_multiple_plans = 1 THEN '', 21'' ELSE '''' END +
                  CASE WHEN unmatched_index_count &gt; 0 THEN '', 22'' ELSE '''' END + 
                  CASE WHEN is_trivial = 1 THEN '', 24'' ELSE '''' END + 
				  CASE WHEN is_forced_serial = 1 THEN '', 25'' ELSE '''' END +
                  CASE WHEN is_key_lookup_expensive = 1 THEN '', 26'' ELSE '''' END +
				  CASE WHEN is_remote_query_expensive = 1 THEN '', 28'' ELSE '''' END + 
				  CASE WHEN trace_flags_session IS NOT NULL THEN '', 29'' ELSE '''' END + 
				  CASE WHEN is_unused_grant = 1 THEN '', 30'' ELSE '''' END +
				  CASE WHEN function_count &gt; 0 IS NOT NULL THEN '', 31'' ELSE '''' END +
				  CASE WHEN clr_function_count &gt; 0 THEN '', 32'' ELSE '''' END +
				  CASE WHEN PlanCreationTimeHours &lt;= 4 THEN '', 33'' ELSE '''' END +
				  CASE WHEN is_table_variable = 1 THEN '', 34'' ELSE '''' END  + 
				  CASE WHEN no_stats_warning = 1 THEN '', 35'' ELSE '''' END  +
				  CASE WHEN relop_warnings = 1 THEN '', 36'' ELSE '''' END +
				  CASE WHEN is_table_scan = 1 THEN '', 37'' ELSE '''' END +
				  CASE WHEN backwards_scan = 1 THEN '', 38'' ELSE '''' END + 
				  CASE WHEN forced_index = 1 THEN '', 39'' ELSE '''' END +
				  CASE WHEN forced_seek = 1 OR forced_scan = 1 THEN '', 40'' ELSE '''' END +
				  CASE WHEN columnstore_row_mode = 1 THEN '', 41 '' ELSE '' END + 
				  CASE WHEN is_computed_scalar = 1 THEN '', 42 '' ELSE '' END +
				  CASE WHEN is_sort_expensive = 1 THEN '', 43'' ELSE '''' END
				  , 2, 200000) END AS opserver_warning , ' + @nl ;
    END
    
    SET @columns += N'        ExecutionCount AS [# Executions],
        ExecutionsPerMinute AS [Executions / Minute],
        PercentExecutions AS [Execution Weight],
        SerialDesiredMemory AS [Serial Desired Memory],
        SerialRequiredMemory AS [Serial Required Memory],
        TotalCPU AS [Total CPU (ms)],
        AverageCPU AS [Avg CPU (ms)],
        PercentCPU AS [CPU Weight],
        TotalDuration AS [Total Duration (ms)],
        AverageDuration AS [Avg Duration (ms)],
        PercentDuration AS [Duration Weight],
        TotalReads AS [Total Reads],
        AverageReads AS [Average Reads],
        PercentReads AS [Read Weight],
        TotalWrites AS [Total Writes],
        AverageWrites AS [Average Writes],
        PercentWrites AS [Write Weight],
        PercentExecutionsByType AS [% Executions (Type)],
        PercentCPUByType AS [% CPU (Type)],
        PercentDurationByType AS [% Duration (Type)],
        PercentReadsByType AS [% Reads (Type)],
        PercentWritesByType AS [% Writes (Type)],
        TotalReturnedRows AS [Total Rows],
        AverageReturnedRows AS [Avg Rows],
        MinReturnedRows AS [Min Rows],
        MaxReturnedRows AS [Max Rows],
		MinGrantKB AS [Minimum Memory Grant KB],
		MaxGrantKB AS [Maximum Memory Grant KB],
		MinUsedGrantKB AS [Minimum Used Grant KB], 
		MaxUsedGrantKB AS [Maximum Used Grant KB],
		AvgMaxMemoryGrant AS [Average Max Memory Grant],
        NumberOfPlans AS [# Plans],
        NumberOfDistinctPlans AS [# Distinct Plans],
        PlanCreationTime AS [Created At],
        LastExecutionTime AS [Last Execution],
        QueryPlanCost AS [Query Plan Cost],
        QueryPlan AS [Query Plan],
        CachedPlanSize AS [Cached Plan Size (KB)],
        CompileTime AS [Compile Time (ms)],
        CompileCPU AS [Compile CPU (ms)],
        CompileMemory AS [Compile memory (KB)],
        COALESCE(SetOptions, '''') AS [SET Options],
		PlanHandle AS [Plan Handle], 
		SqlHandle AS [SQL Handle], 
		[SQL Handle More Info],
        QueryHash AS [Query Hash],
		[Query Hash More Info],
        QueryPlanHash AS [Query Plan Hash],
        StatementStartOffset,
        StatementEndOffset,
		[Remove Plan Handle From Cache],
		[Remove SQL Handle From Cache] ';
END



SET @sql = N'
SELECT  TOP (@Top) ' + @columns + @nl + N'
FROM    ##bou_BlitzCacheProcs
WHERE   SPID = @spid ' + @nl

SELECT @sql += N' ORDER BY ' + CASE @SortOrder WHEN 'cpu' THEN N' TotalCPU '
                                                WHEN 'reads' THEN N' TotalReads '
                                                WHEN 'writes' THEN N' TotalWrites '
                                                WHEN 'duration' THEN N' TotalDuration '
                                                WHEN 'executions' THEN N' ExecutionCount '
                                                WHEN 'compiles' THEN N' PlanCreationTime '
												WHEN 'memory grant' THEN N' MaxGrantKB'
                                                WHEN 'avg cpu' THEN N' AverageCPU'
                                                WHEN 'avg reads' THEN N' AverageReads'
                                                WHEN 'avg writes' THEN N' AverageWrites'
                                                WHEN 'avg duration' THEN N' AverageDuration'
                                                WHEN 'avg executions' THEN N' ExecutionsPerMinute'
												WHEN 'avg memory grant' THEN N' AvgMaxMemoryGrant'
                               END + N' DESC '
SET @sql += N' OPTION (RECOMPILE) ; '


EXEC sp_executesql @sql, N'@Top INT, @spid INT', @Top, @@SPID ;

IF @HideSummary = 0 AND @ExportToExcel = 0
BEGIN
    IF @Reanalyze = 0
    BEGIN
        RAISERROR('Building query plan summary data.', 0, 1) WITH NOWAIT;

        /* Build summary data */
        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE frequent_execution = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    1,
                    100,
                    'Execution Pattern',
                    'Frequently Executed Queries',
                    'http://brentozar.com/blitzcache/frequently-executed-queries/',
                    'Queries are being executed more than '
                    + CAST (@execution_threshold AS VARCHAR(5))
                    + ' times per minute. This can put additional load on the server, even when queries are lightweight.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  parameter_sniffing = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    2,
                    50,
                    'Parameterization',
                    'Parameter Sniffing',
                    'http://brentozar.com/blitzcache/parameter-sniffing/',
                    'There are signs of parameter sniffing (wide variance in rows return or time to execute). Investigate query patterns and tune code appropriately.') ;

        /* Forced execution plans */
        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  is_forced_plan = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    3,
                    5,
                    'Parameterization',
                    'Forced Plans',
                    'http://brentozar.com/blitzcache/forced-plans/',
                    'Execution plans have been compiled with forced plans, either through FORCEPLAN, plan guides, or forced parameterization. This will make general tuning efforts less effective.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  is_cursor = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    4,
                    200,
                    'Cursors',
                    'Cursors',
                    'http://brentozar.com/blitzcache/cursors-found-slow-queries/',
                    'There are cursors in the plan cache. This is neither good nor bad, but it is a thing. Cursors are weird in SQL Server.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  is_cursor = 1
				   AND is_optimistic_cursor = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    4,
                    200,
                    'Cursors',
                    'Optimistic Cursors',
                    'http://brentozar.com/blitzcache/cursors-found-slow-queries/',
                    'There are optimistic cursors in the plan cache, which can harm performance.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  is_cursor = 1
				   AND is_forward_only_cursor = 0
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    4,
                    200,
                    'Cursors',
                    'Non-forward Only Cursors',
                    'http://brentozar.com/blitzcache/cursors-found-slow-queries/',
                    'There are non-forward only cursors in the plan cache, which can harm performance.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  is_forced_parameterized = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    5,
                    50,
                    'Parameterization',
                    'Forced Parameterization',
                    'http://brentozar.com/blitzcache/forced-parameterization/',
                    'Execution plans have been compiled with forced parameterization.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.is_parallel = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    6,
                    200,
                    'Execution Plans',
                    'Parallelism',
                    'http://brentozar.com/blitzcache/parallel-plans-detected/',
                    'Parallel plans detected. These warrant investigation, but are neither good nor bad.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  near_parallel = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    7,
                    200,
                    'Execution Plans',
                    'Nearly Parallel',
                    'http://brentozar.com/blitzcache/query-cost-near-cost-threshold-parallelism/',
                    'Queries near the cost threshold for parallelism. These may go parallel when you least expect it.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  plan_warnings = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    8,
                    50,
                    'Execution Plans',
                    'Query Plan Warnings',
                    'http://brentozar.com/blitzcache/query-plan-warnings/',
                    'Warnings detected in execution plans. SQL Server is telling you that something bad is going on that requires your attention.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  long_running = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    9,
                    50,
                    'Performance',
                    'Long Running Queries',
                    'http://brentozar.com/blitzcache/long-running-queries/',
                    'Long running queries have been found. These are queries with an average duration longer than '
                    + CAST(@long_running_query_warning_seconds / 1000 / 1000 AS VARCHAR(5))
                    + ' second(s). These queries should be investigated for additional tuning options') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.missing_index_count &gt; 0
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    10,
                    50,
                    'Performance',
                    'Missing Index Request',
                    'http://brentozar.com/blitzcache/missing-index-request/',
                    'Queries found with missing indexes.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.downlevel_estimator = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    13,
                    200,
                    'Cardinality',
                    'Legacy Cardinality Estimator in Use',
                    'http://brentozar.com/blitzcache/legacy-cardinality-estimator/',
                    'A legacy cardinality estimator is being used by one or more queries. Investigate whether you need to be using this cardinality estimator. This may be caused by compatibility levels, global trace flags, or query level trace flags.');

        IF EXISTS (SELECT 1/0
                   FROM ##bou_BlitzCacheProcs p
                   WHERE implicit_conversions = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    14,
                    50,
                    'Performance',
                    'Implicit Conversions',
                    'http://brentozar.com/go/implicit',
                    'One or more queries are comparing two fields that are not of the same data type.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  busy_loops = 1
				   AND SPID = @@SPID)
        INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
        VALUES (@@SPID,
                16,
                10,
                'Performance',
                'Frequently executed operators',
                'http://brentozar.com/blitzcache/busy-loops/',
                'Operations have been found that are executed 100 times more often than the number of rows returned by each iteration. This is an indicator that something is off in query execution.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  tvf_join = 1
				   AND SPID = @@SPID)
        INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
        VALUES (@@SPID,
                17,
                50,
                'Performance',
                'Joining to table valued functions',
                'http://brentozar.com/blitzcache/tvf-join/',
                'Execution plans have been found that join to table valued functions (TVFs). TVFs produce inaccurate estimates of the number of rows returned and can lead to any number of query plan problems.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  compile_timeout = 1
				   AND SPID = @@SPID)
        INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
        VALUES (@@SPID,
                18,
                50,
                'Execution Plans',
                'Compilation timeout',
                'http://brentozar.com/blitzcache/compilation-timeout/',
                'Query compilation timed out for one or more queries. SQL Server did not find a plan that meets acceptable performance criteria in the time allotted so the best guess was returned. There is a very good chance that this plan isn''t even below average - it''s probably terrible.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  compile_memory_limit_exceeded = 1
				   AND SPID = @@SPID)
        INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
        VALUES (@@SPID,
                19,
                50,
                'Execution Plans',
                'Compilation memory limit exceeded',
                'http://brentozar.com/blitzcache/compile-memory-limit-exceeded/',
                'The optimizer has a limited amount of memory available. One or more queries are complex enough that SQL Server was unable to allocate enough memory to fully optimize the query. A best fit plan was found, and it''s probably terrible.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  warning_no_join_predicate = 1
				   AND SPID = @@SPID)
        INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
        VALUES (@@SPID,
                20,
                10,
                'Execution Plans',
                'No join predicate',
                'http://brentozar.com/blitzcache/no-join-predicate/',
                'Operators in a query have no join predicate. This means that all rows from one table will be matched with all rows from anther table producing a Cartesian product. That''s a whole lot of rows. This may be your goal, but it''s important to investigate why this is happening.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  plan_multiple_plans = 1
				   AND SPID = @@SPID)
        INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
        VALUES (@@SPID,
                21,
                200,
                'Execution Plans',
                'Multiple execution plans',
                'http://brentozar.com/blitzcache/multiple-plans/',
                'Queries exist with multiple execution plans (as determined by query_plan_hash). Investigate possible ways to parameterize these queries or otherwise reduce the plan count/');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  unmatched_index_count &gt; 0
				   AND SPID = @@SPID)
        INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
        VALUES (@@SPID,
                22,
                100,
                'Performance',
                'Unmatched indexes',
                'http://brentozar.com/blitzcache/unmatched-indexes',
                'An index could have been used, but SQL Server chose not to use it - likely due to parameterization and filtered indexes.');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  unparameterized_query = 1
				   AND SPID = @@SPID)
        INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
        VALUES (@@SPID,
                23,
                100,
                'Parameterization',
                'Unparameterized queries',
                'http://brentozar.com/blitzcache/unparameterized-queries',
                'Unparameterized queries found. These could be ad hoc queries, data exploration, or queries using "OPTIMIZE FOR UNKNOWN".');

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs
                   WHERE  is_trivial = 1
				   AND SPID = @@SPID)
        INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
        VALUES (@@SPID,
                24,
                100,
                'Execution Plans',
                'Trivial Plans',
                'http://brentozar.com/blitzcache/trivial-plans',
                'Trivial plans get almost no optimization. If you''re finding these in the top worst queries, something may be going wrong.');
    
        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.is_forced_serial= 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    25,
                    10,
                    'Execution Plans',
                    'Forced Serialization',
                    'http://www.brentozar.com/blitzcache/forced-serialization/',
                    'Something in your plan is forcing a serial query. Further investigation is needed if this is not by design.') ;	

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.is_key_lookup_expensive= 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    26,
                    100,
                    'Execution Plans',
                    'Expensive Key Lookups',
                    'http://www.brentozar.com/blitzcache/expensive-key-lookups/',
                    'There''s a key lookup in your plan that costs &gt;=50% of the total plan cost.') ;	

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.is_remote_query_expensive= 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    28,
                    100,
                    'Execution Plans',
                    'Expensive Remote Query',
                    'http://www.brentozar.com/blitzcache/expensive-remote-query/',
                    'There''s a remote query in your plan that costs &gt;=50% of the total plan cost.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.trace_flags_session IS NOT NULL
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    29,
                    100,
                    'Trace Flags',
                    'Session Level Trace Flags Enabled',
                    'https://www.brentozar.com/blitz/trace-flags-enabled-globally/',
                    'Someone is enabling session level Trace Flags in a query.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.is_unused_grant IS NOT NULL
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    30,
                    100,
                    'Unused memory grants',
                    'Queries are asking for more memory than they''re using',
                    'https://www.brentozar.com/blitzcache/unused-memory-grants/',
                    'Queries have large unused memory grants. This can cause concurrency issues, if queries are waiting a long time to get memory to run.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.function_count &gt; 0
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    31,
                    100,
                    'Compute Scalar That References A Function',
                    'This could be trouble if you''re using Scalar Functions or MSTVFs',
                    'https://www.brentozar.com/blitzcache/compute-scalar-functions/',
                    'Both of these will force queries to run serially, run at least once per row, and may result in poor cardinality estimates') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.clr_function_count &gt; 0
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    32,
                    100,
                    'Compute Scalar That References A CLR Function',
                    'This could be trouble if your CLR functions perform data access',
                    'https://www.brentozar.com/blitzcache/compute-scalar-functions/',
                    'May force queries to run serially, run at least once per row, and may result in poor cardinlity estimates') ;


        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.is_table_variable = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    33,
                    100,
                    'Table Variables detected',
                    'Beware nasty side effects',
                    'https://www.brentozar.com/blitzcache/table-variables/',
                    'All modifications are single threaded, and selects have really low row estimates.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.no_stats_warning = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    35,
                    100,
                    'Columns with no statistics',
                    'Poor cardinality estimates may ensue',
                    'https://www.brentozar.com/blitzcache/columns-no-statistics/',
                    'Sometimes this happens with indexed views, other times because auto create stats is turned off.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.relop_warnings = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    36,
                    100,
                    'Operator Warnings',
                    'SQL is throwing operator level plan warnings',
                    'http://brentozar.com/blitzcache/query-plan-warnings/',
                    'Check the plan for more details.') ;

        IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.is_table_scan = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    37,
                    100,
                    'Table Scans',
                    'Your database has HEAPs',
                    'https://www.brentozar.com/archive/2012/05/video-heaps/',
                    'This may not be a problem. Run sp_BlitzIndex for more information.') ;
        
		IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.backwards_scan = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    38,
                    100,
                    'Backwards Scans',
                    'Indexes are being read backwards',
                    'https://www.brentozar.com/blitzcache/backwards-scans/',
                    'This isn''t always a problem. They can cause serial zones in plans, and may need an index to match sort order.') ;

		IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.forced_index = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    39,
                    100,
                    'Index forcing',
                    'Someone is using hints to force index usage',
                    'https://www.brentozar.com/blitzcache/optimizer-forcing/',
                    'This can cause inefficient plans, and will prevent missing index requests.') ;

		IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.forced_seek = 1
				   OR p.forced_scan = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    40,
                    100,
                    'Seek/Scan forcing',
                    'Someone is using hints to force index seeks/scans',
                    'https://www.brentozar.com/blitzcache/optimizer-forcing/',
                    'This can cause inefficient plans by taking seek vs scan choice away from the optimizer.') ;

		IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.columnstore_row_mode = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    41,
                    100,
                    'ColumnStore indexes operating in Row Mode',
                    'Batch Mode is optimal for ColumnStore indexes',
                    'https://www.brentozar.com/blitzcache/columnstore-indexes-operating-row-mode/',
                    'ColumnStore indexes operating in Row Mode indicate really poor query choices.') ;

		IF EXISTS (SELECT 1/0
                   FROM   ##bou_BlitzCacheProcs p
                   WHERE  p.is_computed_scalar = 1
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    42,
                    50,
                    'Computed Columns Referencing Scalar UDFs',
                    'This makes a whole lot of stuff run serially',
                    'https://www.brentozar.com/blitzcache/computed-columns-referencing-functions/',
                    'This can cause a whole mess of bad serializartion problems.') ;

        IF EXISTS (SELECT 1/0
                    FROM   ##bou_BlitzCacheProcs p
                    WHERE  p.is_sort_expensive= 1
  					AND SPID = @@SPID)
             INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
             VALUES (@@SPID,
                     43,
                     100,
                     'Execution Plans',
                     'Expensive Sort',
                     'http://www.brentozar.com/blitzcache/expensive-sorts/',
                     'There''s a sort in your plan that costs &gt;=50% of the total plan cost.') ;

        IF EXISTS (SELECT 1/0
                   FROM   #plan_creation p
                   WHERE (p.percent_24 &gt; 0 OR p.percent_4 &gt; 0)
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            SELECT SPID,
                    999,
                    254,
                    'Plan Cache Information',
                    'You have ' + CONVERT(NVARCHAR(10), p.percent_24) + '% plans created in the past 24 hours, and ' + CONVERT(NVARCHAR(10), p.percent_4) + '% created in the past 4 hours.',
                    '',
                    'If these percentages are high, it may be a sign of memory pressure or plan cache instability.'
			FROM   #plan_creation p	;

        IF EXISTS (SELECT 1/0
                   FROM   #single_use_plans_warning p
                   WHERE p.total_plans &gt;= 1000
				   AND p.single_use_plans_percent &gt;= 10.
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            SELECT SPID,
                    999,
                    255,
                    'Plan Cache Information',
                    'Your plan cache is ' + CONVERT(NVARCHAR(10), p.single_use_plans_percent) + '% single use plans with an average age of ' + CONVERT(NVARCHAR(10), p.avg_plan_age) + ' minutes.',
                    '',
                    'Having a lot of single use plans indicates plan cache bloat. This can be cause by non-parameterized dynamic SQL and EF code, or lots of ad hoc queries.'
			FROM   #single_use_plans_warning p	;

        IF EXISTS (SELECT 1/0
                   FROM   #plan_stubs_warning p
                   WHERE p.total_plans &gt;= 1000
				   AND p.plan_stubs_percent &gt;= 30.
				   AND p.total_plan_stubs &gt;= (40009 * 4) 
				   AND SPID = @@SPID)
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            SELECT SPID,
                    999,
                    255,
                    'Plan Cache Information',
                    'Your plan cache has ' + CONVERT(NVARCHAR(10), p.total_plan_stubs) + ' plan stubs, with an average age of ' + CONVERT(NVARCHAR(10), p.avg_plan_age) + ' minutes.',
                    'https://www.brentozar.com/blitz/poison-wait-detected/',
                    'A high number of plan stubs may result in CMEMTHREAD waits, which you have ' 
						+ CONVERT(VARCHAR(10), (SELECT CONVERT(DECIMAL(9,0), (dows.wait_time_ms / 60000.)) FROM sys.dm_os_wait_stats AS dows WHERE dows.wait_type = 'CMEMTHREAD')) + ' minutes of.'
			FROM   #plan_stubs_warning p	;			
			
        IF EXISTS (SELECT 1/0
                   FROM   #trace_flags AS tf 
                   WHERE  tf.global_trace_flags IS NOT NULL
				   )
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    1000,
                    255,
                    'Global Trace Flags Enabled',
                    'You have Global Trace Flags enabled on your server',
                    'https://www.brentozar.com/blitz/trace-flags-enabled-globally/',
                    'You have the following Global Trace Flags enabled: ' + (SELECT TOP 1 tf.global_trace_flags FROM #trace_flags AS tf WHERE tf.global_trace_flags IS NOT NULL)) ;

        IF NOT EXISTS (SELECT 1/0
					   FROM   ##bou_BlitzCacheResults AS bcr
                       WHERE  bcr.Priority = 2147483647
				      )
            INSERT INTO ##bou_BlitzCacheResults (SPID, CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (@@SPID,
                    2147483647,
                    255,
                    'Thanks for using sp_BlitzCache!' ,
                    'From Your Community Volunteers',
                    'http://FirstResponderKit.org',
                    'We hope you found this tool useful. Current version: ' + @Version + ' released on ' + @VersionDate);
	
	END            
    
    SELECT  Priority,
            FindingsGroup,
            Finding,
            URL,
            Details,
            CheckID
    FROM    ##bou_BlitzCacheResults
    WHERE   SPID = @@SPID
    GROUP BY Priority,
            FindingsGroup,
            Finding,
            URL,
            Details,
            CheckID
    ORDER BY Priority ASC, CheckID ASC
    OPTION (RECOMPILE);
END


END

GO



</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>sp_BlitzFirst_____script</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>sp_BlitzFirst_____script</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--sp_BlitzFirst_____script

--https://www.brentozar.com/askbrent/

IF OBJECT_ID('dbo.sp_BlitzFirst') IS NULL
  EXEC ('CREATE PROCEDURE dbo.sp_BlitzFirst AS RETURN 0;')
GO


ALTER PROCEDURE [dbo].[sp_BlitzFirst]
    @Question NVARCHAR(MAX) = NULL ,
    @Help TINYINT = 0 ,
    @AsOf DATETIMEOFFSET = NULL ,
    @ExpertMode TINYINT = 0 ,
    @Seconds INT = 5 ,
    @OutputType VARCHAR(20) = 'TABLE' ,
    @OutputServerName NVARCHAR(256) = NULL ,
    @OutputDatabaseName NVARCHAR(256) = NULL ,
    @OutputSchemaName NVARCHAR(256) = NULL ,
    @OutputTableName NVARCHAR(256) = NULL ,
    @OutputTableNameFileStats NVARCHAR(256) = NULL ,
    @OutputTableNamePerfmonStats NVARCHAR(256) = NULL ,
    @OutputTableNameWaitStats NVARCHAR(256) = NULL ,
    @OutputXMLasNVARCHAR TINYINT = 0 ,
    @FilterPlansByDatabase VARCHAR(MAX) = NULL ,
    @CheckProcedureCache TINYINT = 0 ,
    @FileLatencyThresholdMS INT = 100 ,
    @SinceStartup TINYINT = 0 ,
    @VersionDate DATETIME = NULL OUTPUT
    WITH EXECUTE AS CALLER, RECOMPILE
AS
BEGIN
SET NOCOUNT ON;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET @VersionDate = '20161210'

IF @Help = 1 PRINT '
sp_BlitzFirst from http://FirstResponderKit.org
	
This script gives you a prioritized list of why your SQL Server is slow right now.

This is not an overall health check - for that, check out sp_Blitz.

To learn more, visit http://FirstResponderKit.org where you can download new
versions for free, watch training videos on how it works, get more info on
the findings, contribute your own code, and more.

Known limitations of this version:
 - Only Microsoft-supported versions of SQL Server. Sorry, 2005 and 2000. It
   may work just fine on 2005, and if it does, hug your parents. Just don''t
   file support issues if it breaks.
 - If a temp table called #CustomPerfmonCounters exists for any other session,
   but not our session, this stored proc will fail with an error saying the
   temp table #CustomPerfmonCounters does not exist.
 - @OutputServerName is not functional yet.

Unknown limitations of this version:
 - None. Like Zombo.com, the only limit is yourself.

Changes - for the full list of improvements and fixes in this version, see:
https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/


MIT License

Copyright (c) 2016 Brent Ozar Unlimited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

'


RAISERROR('Setting up configuration variables',10,1) WITH NOWAIT;
DECLARE @StringToExecute NVARCHAR(MAX),
    @ParmDefinitions NVARCHAR(4000),
    @Parm1 NVARCHAR(4000),
    @OurSessionID INT,
    @LineFeed NVARCHAR(10),
    @StockWarningHeader NVARCHAR(500),
    @StockWarningFooter NVARCHAR(100),
    @StockDetailsHeader NVARCHAR(100),
    @StockDetailsFooter NVARCHAR(100),
    @StartSampleTime DATETIMEOFFSET,
    @FinishSampleTime DATETIMEOFFSET,
	@FinishSampleTimeWaitFor DATETIME,
    @ServiceName sysname,
    @OutputTableNameFileStats_View NVARCHAR(256),
    @OutputTableNamePerfmonStats_View NVARCHAR(256),
    @OutputTableNameWaitStats_View NVARCHAR(256),
    @ObjectFullName NVARCHAR(2000);

/* Sanitize our inputs */
SELECT
    @OutputTableNameFileStats_View = QUOTENAME(@OutputTableNameFileStats + '_Deltas'),
    @OutputTableNamePerfmonStats_View = QUOTENAME(@OutputTableNamePerfmonStats + '_Deltas'),
    @OutputTableNameWaitStats_View = QUOTENAME(@OutputTableNameWaitStats + '_Deltas');

SELECT
    @OutputDatabaseName = QUOTENAME(@OutputDatabaseName),
    @OutputSchemaName = QUOTENAME(@OutputSchemaName),
    @OutputTableName = QUOTENAME(@OutputTableName),
    @OutputTableNameFileStats = QUOTENAME(@OutputTableNameFileStats),
    @OutputTableNamePerfmonStats = QUOTENAME(@OutputTableNamePerfmonStats),
    @OutputTableNameWaitStats = QUOTENAME(@OutputTableNameWaitStats),
    @LineFeed = CHAR(13) + CHAR(10),
    @StartSampleTime = SYSDATETIMEOFFSET(),
    @FinishSampleTime = DATEADD(ss, @Seconds, SYSDATETIMEOFFSET()),
	@FinishSampleTimeWaitFor = DATEADD(ss, @Seconds, GETDATE()),
    @OurSessionID = @@SPID;


IF @SinceStartup = 1
    SELECT @Seconds = 0, @ExpertMode = 1;

IF @Seconds = 0 AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) = 'SQL Azure'
    SELECT @StartSampleTime = DATEADD(ms, AVG(-wait_time_ms), SYSDATETIMEOFFSET()), @FinishSampleTime = SYSDATETIMEOFFSET()
        FROM sys.dm_os_wait_stats w
        WHERE wait_type IN ('BROKER_TASK_STOP','DIRTY_PAGE_POLL','HADR_FILESTREAM_IOMGR_IOCOMPLETION','LAZYWRITER_SLEEP',
                            'LOGMGR_QUEUE','REQUEST_FOR_DEADLOCK_SEARCH','XE_DISPATCHER_WAIT','XE_TIMER_EVENT')
ELSE IF @Seconds = 0 AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) &lt;&gt; 'SQL Azure'
    SELECT @StartSampleTime = create_date , @FinishSampleTime = SYSDATETIMEOFFSET()
        FROM sys.databases
        WHERE database_id = 2;
ELSE
    SELECT @StartSampleTime = SYSDATETIMEOFFSET(), @FinishSampleTime = DATEADD(ss, @Seconds, SYSDATETIMEOFFSET());

IF @OutputType = 'SCHEMA'
BEGIN
    SELECT FieldList = '[Priority] TINYINT, [FindingsGroup] VARCHAR(50), [Finding] VARCHAR(200), [URL] VARCHAR(200), [Details] NVARCHAR(4000), [HowToStopIt] NVARCHAR(MAX), [QueryPlan] XML, [QueryText] NVARCHAR(MAX)'

END
ELSE IF @AsOf IS NOT NULL AND @OutputDatabaseName IS NOT NULL AND @OutputSchemaName IS NOT NULL AND @OutputTableName IS NOT NULL
BEGIN
    /* They want to look into the past. */

        SET @StringToExecute = N' IF EXISTS(SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
            + @OutputSchemaName + ''') SELECT CheckDate, [Priority], [FindingsGroup], [Finding], [URL], CAST([Details] AS [XML]) AS Details,'
            + '[HowToStopIt], [CheckID], [StartTime], [LoginName], [NTUserName], [OriginalLoginName], [ProgramName], [HostName], [DatabaseID],'
            + '[DatabaseName], [OpenTransactionCount], [QueryPlan], [QueryText] FROM '
            + @OutputDatabaseName + '.'
            + @OutputSchemaName + '.'
            + @OutputTableName
            + ' WHERE CheckDate &gt;= DATEADD(mi, -15, ''' + CAST(@AsOf AS NVARCHAR(100)) + ''')'
            + ' AND CheckDate &lt;= DATEADD(mi, 15, ''' + CAST(@AsOf AS NVARCHAR(100)) + ''')'
            + ' /*ORDER BY CheckDate, Priority , FindingsGroup , Finding , Details*/;';
        EXEC(@StringToExecute);


END /* IF @AsOf IS NOT NULL AND @OutputDatabaseName IS NOT NULL AND @OutputSchemaName IS NOT NULL AND @OutputTableName IS NOT NULL */
ELSE IF @Question IS NULL /* IF @OutputType = 'SCHEMA' */
BEGIN
    /* What's running right now? This is the first and last result set. */
    IF @SinceStartup = 0 AND @Seconds &gt; 0 AND @ExpertMode = 1 
    BEGIN
		IF OBJECT_ID('dbo.sp_BlitzWho') IS NULL
		BEGIN
			PRINT N'sp_BlitzWho is not installed in the current database_files.  You can get a copy from http://FirstResponderKit.org'
		END
		ELSE
		BEGIN
			EXEC [dbo].[sp_BlitzWho]
		END
    END /* IF @SinceStartup = 0 AND @Seconds &gt; 0 AND @ExpertMode = 1   -   What's running right now? This is the first and last result set. */
     

    RAISERROR('Now starting diagnostic analysis',10,1) WITH NOWAIT;

    /*
    We start by creating #BlitzFirstResults. It's a temp table that will store
    the results from our checks. Throughout the rest of this stored procedure,
    we're running a series of checks looking for dangerous things inside the SQL
    Server. When we find a problem, we insert rows into #BlitzResults. At the
    end, we return these results to the end user.

    #BlitzFirstResults has a CheckID field, but there's no Check table. As we do
    checks, we insert data into this table, and we manually put in the CheckID.
    We (Brent Ozar Unlimited) maintain a list of the checks by ID#. You can
    download that from http://FirstResponderKit.org if you want to build
    a tool that relies on the output of sp_BlitzFirst.
    */

    IF OBJECT_ID('tempdb..#BlitzFirstResults') IS NOT NULL
        DROP TABLE #BlitzFirstResults;
    CREATE TABLE #BlitzFirstResults
        (
          ID INT IDENTITY(1, 1) PRIMARY KEY CLUSTERED,
          CheckID INT NOT NULL,
          Priority TINYINT NOT NULL,
          FindingsGroup VARCHAR(50) NOT NULL,
          Finding VARCHAR(200) NOT NULL,
          URL VARCHAR(200) NULL,
          Details NVARCHAR(4000) NULL,
          HowToStopIt NVARCHAR(MAX) NULL,
          QueryPlan [XML] NULL,
          QueryText NVARCHAR(MAX) NULL,
          StartTime DATETIMEOFFSET NULL,
          LoginName NVARCHAR(128) NULL,
          NTUserName NVARCHAR(128) NULL,
          OriginalLoginName NVARCHAR(128) NULL,
          ProgramName NVARCHAR(128) NULL,
          HostName NVARCHAR(128) NULL,
          DatabaseID INT NULL,
          DatabaseName NVARCHAR(128) NULL,
          OpenTransactionCount INT NULL,
          QueryStatsNowID INT NULL,
          QueryStatsFirstID INT NULL,
          PlanHandle VARBINARY(64) NULL,
          DetailsInt INT NULL,
        );

    IF OBJECT_ID('tempdb..#WaitStats') IS NOT NULL
        DROP TABLE #WaitStats;
    CREATE TABLE #WaitStats (Pass TINYINT NOT NULL, wait_type NVARCHAR(60), wait_time_ms BIGINT, signal_wait_time_ms BIGINT, waiting_tasks_count BIGINT, SampleTime DATETIMEOFFSET);

    IF OBJECT_ID('tempdb..#FileStats') IS NOT NULL
        DROP TABLE #FileStats;
    CREATE TABLE #FileStats (
        ID INT IDENTITY(1, 1) PRIMARY KEY CLUSTERED,
        Pass TINYINT NOT NULL,
        SampleTime DATETIMEOFFSET NOT NULL,
        DatabaseID INT NOT NULL,
        FileID INT NOT NULL,
        DatabaseName NVARCHAR(256) ,
        FileLogicalName NVARCHAR(256) ,
        TypeDesc NVARCHAR(60) ,
        SizeOnDiskMB BIGINT ,
        io_stall_read_ms BIGINT ,
        num_of_reads BIGINT ,
        bytes_read BIGINT ,
        io_stall_write_ms BIGINT ,
        num_of_writes BIGINT ,
        bytes_written BIGINT,
        PhysicalName NVARCHAR(520) ,
        avg_stall_read_ms INT ,
        avg_stall_write_ms INT
    );

    IF OBJECT_ID('tempdb..#QueryStats') IS NOT NULL
        DROP TABLE #QueryStats;
    CREATE TABLE #QueryStats (
        ID INT IDENTITY(1, 1) PRIMARY KEY CLUSTERED,
        Pass INT NOT NULL,
        SampleTime DATETIMEOFFSET NOT NULL,
        [sql_handle] VARBINARY(64),
        statement_start_offset INT,
        statement_end_offset INT,
        plan_generation_num BIGINT,
        plan_handle VARBINARY(64),
        execution_count BIGINT,
        total_worker_time BIGINT,
        total_physical_reads BIGINT,
        total_logical_writes BIGINT,
        total_logical_reads BIGINT,
        total_clr_time BIGINT,
        total_elapsed_time BIGINT,
        creation_time DATETIMEOFFSET,
        query_hash BINARY(8),
        query_plan_hash BINARY(8),
        Points TINYINT
    );

    IF OBJECT_ID('tempdb..#PerfmonStats') IS NOT NULL
        DROP TABLE #PerfmonStats;
    CREATE TABLE #PerfmonStats (
        ID INT IDENTITY(1, 1) PRIMARY KEY CLUSTERED,
        Pass TINYINT NOT NULL,
        SampleTime DATETIMEOFFSET NOT NULL,
        [object_name] NVARCHAR(128) NOT NULL,
        [counter_name] NVARCHAR(128) NOT NULL,
        [instance_name] NVARCHAR(128) NULL,
        [cntr_value] BIGINT NULL,
        [cntr_type] INT NOT NULL,
        [value_delta] BIGINT NULL,
        [value_per_second] DECIMAL(18,2) NULL
    );

    IF OBJECT_ID('tempdb..#PerfmonCounters') IS NOT NULL
        DROP TABLE #PerfmonCounters;
    CREATE TABLE #PerfmonCounters (
        ID INT IDENTITY(1, 1) PRIMARY KEY CLUSTERED,
        [object_name] NVARCHAR(128) NOT NULL,
        [counter_name] NVARCHAR(128) NOT NULL,
        [instance_name] NVARCHAR(128) NULL
    );

    IF OBJECT_ID('tempdb..#FilterPlansByDatabase') IS NOT NULL
        DROP TABLE #FilterPlansByDatabase;
    CREATE TABLE #FilterPlansByDatabase (DatabaseID INT PRIMARY KEY CLUSTERED);

    IF OBJECT_ID('tempdb..#MasterFiles') IS NOT NULL
        DROP TABLE #MasterFiles;
    CREATE TABLE #MasterFiles (database_id INT, file_id INT, type_desc NVARCHAR(50), name NVARCHAR(255), physical_name NVARCHAR(255), size BIGINT);
    /* Azure SQL Database doesn't have sys.master_files, so we have to build our own. */
    IF CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) = 'SQL Azure'
        SET @StringToExecute = 'INSERT INTO #MasterFiles (database_id, file_id, type_desc, name, physical_name, size) SELECT DB_ID(), file_id, type_desc, name, physical_name, size FROM sys.database_files;'
    ELSE
        SET @StringToExecute = 'INSERT INTO #MasterFiles (database_id, file_id, type_desc, name, physical_name, size) SELECT database_id, file_id, type_desc, name, physical_name, size FROM sys.master_files;'
    EXEC(@StringToExecute);

    IF @FilterPlansByDatabase IS NOT NULL
        BEGIN
        IF UPPER(LEFT(@FilterPlansByDatabase,4)) = 'USER'
            BEGIN
            INSERT INTO #FilterPlansByDatabase (DatabaseID)
            SELECT database_id
                FROM sys.databases
                WHERE [name] NOT IN ('master', 'model', 'msdb', 'tempdb')
            END
        ELSE
            BEGIN
            SET @FilterPlansByDatabase = @FilterPlansByDatabase + ','
            ;WITH a AS
                (
                SELECT CAST(1 AS BIGINT) f, CHARINDEX(',', @FilterPlansByDatabase) t, 1 SEQ
                UNION ALL
                SELECT t + 1, CHARINDEX(',', @FilterPlansByDatabase, t + 1), SEQ + 1
                FROM a
                WHERE CHARINDEX(',', @FilterPlansByDatabase, t + 1) &gt; 0
                )
            INSERT #FilterPlansByDatabase (DatabaseID)
                SELECT SUBSTRING(@FilterPlansByDatabase, f, t - f)
                FROM a
                WHERE SUBSTRING(@FilterPlansByDatabase, f, t - f) IS NOT NULL
                OPTION (MAXRECURSION 0)
            END
        END


    SET @StockWarningHeader = '&lt;?ClickToSeeCommmand -- ' + @LineFeed + @LineFeed
        + 'WARNING: Running this command may result in data loss or an outage.' + @LineFeed
        + 'This tool is meant as a shortcut to help generate scripts for DBAs.' + @LineFeed
        + 'It is not a substitute for database training and experience.' + @LineFeed
        + 'Now, having said that, here''s the details:' + @LineFeed + @LineFeed;

    SELECT @StockWarningFooter = @LineFeed + @LineFeed + '-- ?&gt;',
        @StockDetailsHeader = '&lt;?ClickToSeeDetails -- ' + @LineFeed,
        @StockDetailsFooter = @LineFeed + ' -- ?&gt;';

    /* Get the instance name to use as a Perfmon counter prefix. */
    IF CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) = 'SQL Azure'
        SELECT TOP 1 @ServiceName = LEFT(object_name, (CHARINDEX(':', object_name) - 1))
        FROM sys.dm_os_performance_counters;
    ELSE
        BEGIN
        SET @StringToExecute = 'INSERT INTO #PerfmonStats(object_name, Pass, SampleTime, counter_name, cntr_type) SELECT CASE WHEN @@SERVICENAME = ''MSSQLSERVER'' THEN ''SQLServer'' ELSE ''MSSQL$'' + @@SERVICENAME END, 0, SYSDATETIMEOFFSET(), ''stuffing'', 0 ;'
        EXEC(@StringToExecute);
        SELECT @ServiceName = object_name FROM #PerfmonStats;
        DELETE #PerfmonStats;
        END

    /* Build a list of queries that were run in the last 10 seconds.
       We're looking for the death-by-a-thousand-small-cuts scenario
       where a query is constantly running, and it doesn't have that
       big of an impact individually, but it has a ton of impact
       overall. We're going to build this list, and then after we
       finish our @Seconds sample, we'll compare our plan cache to
       this list to see what ran the most. */

    /* Populate #QueryStats. SQL 2005 doesn't have query hash or query plan hash. */
    IF @CheckProcedureCache = 1 
	BEGIN
		RAISERROR('@CheckProcedureCache = 1, capturing first pass of plan cache',10,1) WITH NOWAIT;
		IF @@VERSION LIKE 'Microsoft SQL Server 2005%'
			BEGIN
			IF @FilterPlansByDatabase IS NULL
				BEGIN
				SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 1 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											WHERE qs.last_execution_time &gt;= (DATEADD(ss, -10, SYSDATETIMEOFFSET()));';
				END
			ELSE
				BEGIN
				SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 1 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
												CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS attr
												INNER JOIN #FilterPlansByDatabase dbs ON CAST(attr.value AS INT) = dbs.DatabaseID
											WHERE qs.last_execution_time &gt;= (DATEADD(ss, -10, SYSDATETIMEOFFSET()))
												AND attr.attribute = ''dbid'';';
				END
			END
		ELSE
			BEGIN
			IF @FilterPlansByDatabase IS NULL
				BEGIN
				SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 1 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											WHERE qs.last_execution_time &gt;= (DATEADD(ss, -10, SYSDATETIMEOFFSET()));';
				END
			ELSE
				BEGIN
				SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 1 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS attr
											INNER JOIN #FilterPlansByDatabase dbs ON CAST(attr.value AS INT) = dbs.DatabaseID
											WHERE qs.last_execution_time &gt;= (DATEADD(ss, -10, SYSDATETIMEOFFSET()))
												AND attr.attribute = ''dbid'';';
				END
			END
		EXEC(@StringToExecute);

		/* Get the totals for the entire plan cache */
		INSERT INTO #QueryStats (Pass, SampleTime, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time)
		SELECT -1 AS Pass, SYSDATETIMEOFFSET(), SUM(execution_count), SUM(total_worker_time), SUM(total_physical_reads), SUM(total_logical_writes), SUM(total_logical_reads), SUM(total_clr_time), SUM(total_elapsed_time), MIN(creation_time)
			FROM sys.dm_exec_query_stats qs;
    END /*IF @CheckProcedureCache = 1 */


    IF EXISTS (SELECT *
                    FROM tempdb.sys.all_objects obj
                    INNER JOIN tempdb.sys.all_columns col1 ON obj.object_id = col1.object_id AND col1.name = 'object_name'
                    INNER JOIN tempdb.sys.all_columns col2 ON obj.object_id = col2.object_id AND col2.name = 'counter_name'
                    INNER JOIN tempdb.sys.all_columns col3 ON obj.object_id = col3.object_id AND col3.name = 'instance_name'
                    WHERE obj.name LIKE '%CustomPerfmonCounters%')
        BEGIN
        SET @StringToExecute = 'INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) SELECT [object_name],[counter_name],[instance_name] FROM #CustomPerfmonCounters'
        EXEC(@StringToExecute);
        END
    ELSE
        BEGIN
        /* Add our default Perfmon counters */
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Forwarded Records/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Page compression attempts/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Page Splits/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Skipped Ghosted Records/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Table Lock Escalations/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Worktables Created/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Page life expectancy', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Page reads/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Page writes/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Readahead pages/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Target pages', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Total pages', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Databases','', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Active Transactions','_Total')
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Databases','Log Growths', '_Total')
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Databases','Log Shrinks', '_Total')
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Exec Statistics','Distributed Query', 'Execs in progress')
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Exec Statistics','DTC calls', 'Execs in progress')
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Exec Statistics','Extended Procedures', 'Execs in progress')
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Exec Statistics','OLEDB calls', 'Execs in progress')
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':General Statistics','Active Temp Tables', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':General Statistics','Logins/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':General Statistics','Logouts/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':General Statistics','Mars Deadlocks', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':General Statistics','Processes blocked', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Locks','Number of Deadlocks/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Memory Manager','Memory Grants Pending', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Errors','Errors/sec', '_Total')
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','Batch Requests/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','Forced Parameterizations/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','Guided plan executions/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','SQL Attention rate', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','SQL Compilations/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','SQL Re-Compilations/sec', NULL)
        /* Below counters added by Jefferson Elias */
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Worktables From Cache Base',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Worktables From Cache Ratio',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Database pages',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Free pages',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Stolen pages',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Memory Manager','Granted Workspace Memory (KB)',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Memory Manager','Maximum Workspace Memory (KB)',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Memory Manager','Target Server Memory (KB)',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Memory Manager','Total Server Memory (KB)',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Buffer cache hit ratio',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Buffer cache hit ratio base',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Checkpoint pages/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Free list stalls/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Lazy writes/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','Auto-Param Attempts/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','Failed Auto-Params/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','Safe Auto-Params/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','Unsafe Auto-Params/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Workfiles Created/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':General Statistics','User Connections',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Latches','Average Latch Wait Time (ms)',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Latches','Average Latch Wait Time Base',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Latches','Latch Waits/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Latches','Total Latch Wait Time (ms)',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Locks','Average Wait Time (ms)',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Locks','Average Wait Time Base',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Locks','Lock Requests/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Locks','Lock Timeouts/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Locks','Lock Wait Time (ms)',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Locks','Lock Waits/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Transactions','Longest Transaction Running Time',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Full Scans/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Access Methods','Index Searches/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Buffer Manager','Page lookups/sec',NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':Cursor Manager by Type','Active cursors',NULL)
        END

    /* Populate #FileStats, #PerfmonStats, #WaitStats with DMV data.
        After we finish doing our checks, we'll take another sample and compare them. */
	RAISERROR('Capturing first pass of wait stats, perfmon counters, file stats',10,1) WITH NOWAIT;
    INSERT #WaitStats(Pass, SampleTime, wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count)
		SELECT 
		x.Pass, 
		x.SampleTime, 
		x.wait_type, 
		SUM(x.sum_wait_time_ms) AS sum_wait_time_ms, 
		SUM(x.sum_signal_wait_time_ms) AS sum_signal_wait_time_ms, 
		SUM(x.sum_waiting_tasks) AS sum_waiting_tasks
		FROM (
		SELECT  
				1 AS Pass,
				CASE @Seconds WHEN 0 THEN @StartSampleTime ELSE SYSDATETIMEOFFSET() END AS SampleTime,
				owt.wait_type,
		        CASE @Seconds WHEN 0 THEN 0 ELSE SUM(owt.wait_duration_ms) OVER (PARTITION BY owt.wait_type, owt.session_id)
					 - CASE WHEN @Seconds = 0 THEN 0 ELSE (@Seconds * 1000) END END AS sum_wait_time_ms,
				0 AS sum_signal_wait_time_ms,
				0 AS sum_waiting_tasks
			FROM    sys.dm_os_waiting_tasks owt
			WHERE owt.session_id &gt; 50
			AND owt.wait_duration_ms &gt;= CASE @Seconds WHEN 0 THEN 0 ELSE @Seconds * 1000 END
		UNION ALL
		SELECT
		       1 AS Pass,
		       CASE @Seconds WHEN 0 THEN @StartSampleTime ELSE SYSDATETIMEOFFSET() END AS SampleTime,
		       os.wait_type,
		       CASE @Seconds WHEN 0 THEN 0 ELSE SUM(os.wait_time_ms) OVER (PARTITION BY os.wait_type) END AS sum_wait_time_ms,
		       CASE @Seconds WHEN 0 THEN 0 ELSE SUM(os.signal_wait_time_ms) OVER (PARTITION BY os.wait_type ) END AS sum_signal_wait_time_ms,
		       CASE @Seconds WHEN 0 THEN 0 ELSE SUM(os.waiting_tasks_count) OVER (PARTITION BY os.wait_type) END AS sum_waiting_tasks
		   FROM sys.dm_os_wait_stats os
		) x
		   WHERE x.wait_type NOT IN (
		       'REQUEST_FOR_DEADLOCK_SEARCH',
		       'SQLTRACE_INCREMENTAL_FLUSH_SLEEP',
		       'SQLTRACE_BUFFER_FLUSH',
		       'LAZYWRITER_SLEEP',
		       'XE_TIMER_EVENT',
		       'XE_DISPATCHER_WAIT',
		       'FT_IFTS_SCHEDULER_IDLE_WAIT',
		       'LOGMGR_QUEUE',
		       'CHECKPOINT_QUEUE',
		       'BROKER_TO_FLUSH',
		       'BROKER_TASK_STOP',
		       'BROKER_EVENTHANDLER',
		       'SLEEP_TASK',
		       'WAITFOR',
		       'DBMIRROR_DBM_MUTEX',
		       'DBMIRROR_EVENTS_QUEUE',
		       'DBMIRRORING_CMD',
		       'DISPATCHER_QUEUE_SEMAPHORE',
		       'BROKER_RECEIVE_WAITFOR',
		       'CLR_AUTO_EVENT',
		       'DIRTY_PAGE_POLL',
		       'HADR_FILESTREAM_IOMGR_IOCOMPLETION',
		       'ONDEMAND_TASK_QUEUE',
		       'FT_IFTSHC_MUTEX',
		       'CLR_MANUAL_EVENT',
		       'CLR_SEMAPHORE',
		       'DBMIRROR_WORKER_QUEUE',
		       'DBMIRROR_DBM_EVENT',
		       'SP_SERVER_DIAGNOSTICS_SLEEP',
		       'HADR_CLUSAPI_CALL',
		       'HADR_LOGCAPTURE_WAIT',
		       'HADR_NOTIFICATION_DEQUEUE',
		       'HADR_TIMER_TASK',
		       'HADR_WORK_QUEUE',
		       'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
		       'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP',
		       'RESOURCE_GOVERNOR_IDLE',
		       'QDS_ASYNC_QUEUE',
		       'QDS_SHUTDOWN_QUEUE',
		       'SLEEP_SYSTEMTASK',
		       'BROKER_TRANSMITTER',
		       'REDO_THREAD_PENDING_WORK',
		       'UCS_SESSION_REGISTRATION'
		   )
		GROUP BY x.Pass, x.SampleTime, x.wait_type
		ORDER BY sum_wait_time_ms DESC;


    INSERT INTO #FileStats (Pass, SampleTime, DatabaseID, FileID, DatabaseName, FileLogicalName, SizeOnDiskMB, io_stall_read_ms ,
        num_of_reads, [bytes_read] , io_stall_write_ms,num_of_writes, [bytes_written], PhysicalName, TypeDesc)
    SELECT
        1 AS Pass,
        CASE @Seconds WHEN 0 THEN @StartSampleTime ELSE SYSDATETIMEOFFSET() END AS SampleTime,
        mf.[database_id],
        mf.[file_id],
        DB_NAME(vfs.database_id) AS [db_name],
        mf.name + N' [' + mf.type_desc COLLATE SQL_Latin1_General_CP1_CI_AS + N']' AS file_logical_name ,
        CAST(( ( vfs.size_on_disk_bytes / 1024.0 ) / 1024.0 ) AS INT) AS size_on_disk_mb ,
        CASE @Seconds WHEN 0 THEN 0 ELSE vfs.io_stall_read_ms END ,
        CASE @Seconds WHEN 0 THEN 0 ELSE vfs.num_of_reads END ,
        CASE @Seconds WHEN 0 THEN 0 ELSE vfs.[num_of_bytes_read] END ,
        CASE @Seconds WHEN 0 THEN 0 ELSE vfs.io_stall_write_ms END ,
        CASE @Seconds WHEN 0 THEN 0 ELSE vfs.num_of_writes END ,
        CASE @Seconds WHEN 0 THEN 0 ELSE vfs.[num_of_bytes_written] END ,
        mf.physical_name,
        mf.type_desc
    FROM sys.dm_io_virtual_file_stats (NULL, NULL) AS vfs
    INNER JOIN #MasterFiles AS mf ON vfs.file_id = mf.file_id
        AND vfs.database_id = mf.database_id
    WHERE vfs.num_of_reads &gt; 0
        OR vfs.num_of_writes &gt; 0;

    INSERT INTO #PerfmonStats (Pass, SampleTime, [object_name],[counter_name],[instance_name],[cntr_value],[cntr_type])
    SELECT         1 AS Pass,
        CASE @Seconds WHEN 0 THEN @StartSampleTime ELSE SYSDATETIMEOFFSET() END AS SampleTime, RTRIM(dmv.object_name), RTRIM(dmv.counter_name), RTRIM(dmv.instance_name), CASE @Seconds WHEN 0 THEN 0 ELSE dmv.cntr_value END, dmv.cntr_type
        FROM #PerfmonCounters counters
        INNER JOIN sys.dm_os_performance_counters dmv ON counters.counter_name COLLATE SQL_Latin1_General_CP1_CI_AS = RTRIM(dmv.counter_name) COLLATE SQL_Latin1_General_CP1_CI_AS
            AND counters.[object_name] COLLATE SQL_Latin1_General_CP1_CI_AS = RTRIM(dmv.[object_name]) COLLATE SQL_Latin1_General_CP1_CI_AS
            AND (counters.[instance_name] IS NULL OR counters.[instance_name] COLLATE SQL_Latin1_General_CP1_CI_AS = RTRIM(dmv.[instance_name]) COLLATE SQL_Latin1_General_CP1_CI_AS)


	RAISERROR('Beginning investigatory queries',10,1) WITH NOWAIT;


    /* Maintenance Tasks Running - Backup Running - CheckID 1 */
    IF @Seconds &gt; 0
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount)
    SELECT 1 AS CheckID,
        1 AS Priority,
        'Maintenance Tasks Running' AS FindingGroup,
        'Backup Running' AS Finding,
        'http://www.BrentOzar.com/askbrent/backups/' AS URL,
        'Backup of ' + DB_NAME(db.resource_database_id) + ' database (' + (SELECT CAST(CAST(SUM(size * 8.0 / 1024 / 1024) AS BIGINT) AS NVARCHAR) FROM #MasterFiles WHERE database_id = db.resource_database_id) + 'GB) is ' + CAST(r.percent_complete AS NVARCHAR(100)) + '% complete, has been running since ' + CAST(r.start_time AS NVARCHAR(100)) + '. ' AS Details,
        'KILL ' + CAST(r.session_id AS NVARCHAR(100)) + ';' AS HowToStopIt,
        pl.query_plan AS QueryPlan,
        r.start_time AS StartTime,
        s.login_name AS LoginName,
        s.nt_user_name AS NTUserName,
        s.[program_name] AS ProgramName,
        s.[host_name] AS HostName,
        db.[resource_database_id] AS DatabaseID,
        DB_NAME(db.resource_database_id) AS DatabaseName,
        0 AS OpenTransactionCount
    FROM sys.dm_exec_requests r
    INNER JOIN sys.dm_exec_connections c ON r.session_id = c.session_id
    INNER JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
    INNER JOIN (
    SELECT DISTINCT request_session_id, resource_database_id
    FROM    sys.dm_tran_locks
    WHERE resource_type = N'DATABASE'
    AND     request_mode = N'S'
    AND     request_status = N'GRANT'
    AND     request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') AS db ON s.session_id = db.request_session_id
    CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) pl
    WHERE r.command LIKE 'BACKUP%';


    /* If there's a backup running, add details explaining how long full backup has been taking in the last month. */
    IF @Seconds &gt; 0 AND CAST(SERVERPROPERTY('edition') AS VARCHAR(100)) &lt;&gt; 'SQL Azure'
    BEGIN
        SET @StringToExecute = 'UPDATE #BlitzFirstResults SET Details = Details + '' Over the last 60 days, the full backup usually takes '' + CAST((SELECT AVG(DATEDIFF(mi, bs.backup_start_date, bs.backup_finish_date)) FROM msdb.dbo.backupset bs WHERE abr.DatabaseName = bs.database_name AND bs.type = ''D'' AND bs.backup_start_date &gt; DATEADD(dd, -60, SYSDATETIMEOFFSET()) AND bs.backup_finish_date IS NOT NULL) AS NVARCHAR(100)) + '' minutes.'' FROM #BlitzFirstResults abr WHERE abr.CheckID = 1 AND EXISTS (SELECT * FROM msdb.dbo.backupset bs WHERE bs.type = ''D'' AND bs.backup_start_date &gt; DATEADD(dd, -60, SYSDATETIMEOFFSET()) AND bs.backup_finish_date IS NOT NULL AND abr.DatabaseName = bs.database_name AND DATEDIFF(mi, bs.backup_start_date, bs.backup_finish_date) &gt; 1)';
        EXEC(@StringToExecute);
    END


    /* Maintenance Tasks Running - DBCC Running - CheckID 2 */
    IF @Seconds &gt; 0
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount)
    SELECT 2 AS CheckID,
        1 AS Priority,
        'Maintenance Tasks Running' AS FindingGroup,
        'DBCC Running' AS Finding,
        'http://www.BrentOzar.com/askbrent/dbcc/' AS URL,
        'Corruption check of ' + DB_NAME(db.resource_database_id) + ' database (' + (SELECT CAST(CAST(SUM(size * 8.0 / 1024 / 1024) AS BIGINT) AS NVARCHAR) FROM #MasterFiles WHERE database_id = db.resource_database_id) + 'GB) has been running since ' + CAST(r.start_time AS NVARCHAR(100)) + '. ' AS Details,
        'KILL ' + CAST(r.session_id AS NVARCHAR(100)) + ';' AS HowToStopIt,
        pl.query_plan AS QueryPlan,
        r.start_time AS StartTime,
        s.login_name AS LoginName,
        s.nt_user_name AS NTUserName,
        s.[program_name] AS ProgramName,
        s.[host_name] AS HostName,
        db.[resource_database_id] AS DatabaseID,
        DB_NAME(db.resource_database_id) AS DatabaseName,
        0 AS OpenTransactionCount
    FROM sys.dm_exec_requests r
    INNER JOIN sys.dm_exec_connections c ON r.session_id = c.session_id
    INNER JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
    INNER JOIN (SELECT DISTINCT l.request_session_id, l.resource_database_id
    FROM    sys.dm_tran_locks l
    INNER JOIN sys.databases d ON l.resource_database_id = d.database_id
    WHERE l.resource_type = N'DATABASE'
    AND     l.request_mode = N'S'
    AND    l.request_status = N'GRANT'
    AND    l.request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') AS db ON s.session_id = db.request_session_id
    CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) pl
    WHERE r.command LIKE 'DBCC%';


    /* Maintenance Tasks Running - Restore Running - CheckID 3 */
    IF @Seconds &gt; 0
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount)
    SELECT 3 AS CheckID,
        1 AS Priority,
        'Maintenance Tasks Running' AS FindingGroup,
        'Restore Running' AS Finding,
        'http://www.BrentOzar.com/askbrent/backups/' AS URL,
        'Restore of ' + DB_NAME(db.resource_database_id) + ' database (' + (SELECT CAST(CAST(SUM(size * 8.0 / 1024 / 1024) AS BIGINT) AS NVARCHAR) FROM #MasterFiles WHERE database_id = db.resource_database_id) + 'GB) is ' + CAST(r.percent_complete AS NVARCHAR(100)) + '% complete, has been running since ' + CAST(r.start_time AS NVARCHAR(100)) + '. ' AS Details,
        'KILL ' + CAST(r.session_id AS NVARCHAR(100)) + ';' AS HowToStopIt,
        pl.query_plan AS QueryPlan,
        r.start_time AS StartTime,
        s.login_name AS LoginName,
        s.nt_user_name AS NTUserName,
        s.[program_name] AS ProgramName,
        s.[host_name] AS HostName,
        db.[resource_database_id] AS DatabaseID,
        DB_NAME(db.resource_database_id) AS DatabaseName,
        0 AS OpenTransactionCount
    FROM sys.dm_exec_requests r
    INNER JOIN sys.dm_exec_connections c ON r.session_id = c.session_id
    INNER JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
    INNER JOIN (
    SELECT DISTINCT request_session_id, resource_database_id
    FROM    sys.dm_tran_locks
    WHERE resource_type = N'DATABASE'
    AND     request_mode = N'S'
    AND     request_status = N'GRANT'
    AND     request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') AS db ON s.session_id = db.request_session_id
    CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) pl
    WHERE r.command LIKE 'RESTORE%';


    /* SQL Server Internal Maintenance - Database File Growing - CheckID 4 */
    IF @Seconds &gt; 0
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount)
    SELECT 4 AS CheckID,
        1 AS Priority,
        'SQL Server Internal Maintenance' AS FindingGroup,
        'Database File Growing' AS Finding,
        'http://www.BrentOzar.com/go/instant' AS URL,
        'SQL Server is waiting for Windows to provide storage space for a database restore, a data file growth, or a log file growth. This task has been running since ' + CAST(r.start_time AS NVARCHAR(100)) + '.' + @LineFeed + 'Check the query plan (expert mode) to identify the database involved.' AS Details,
        'Unfortunately, you can''t stop this, but you can prevent it next time. Check out http://www.BrentOzar.com/go/instant for details.' AS HowToStopIt,
        pl.query_plan AS QueryPlan,
        r.start_time AS StartTime,
        s.login_name AS LoginName,
        s.nt_user_name AS NTUserName,
        s.[program_name] AS ProgramName,
        s.[host_name] AS HostName,
        NULL AS DatabaseID,
        NULL AS DatabaseName,
        0 AS OpenTransactionCount
    FROM sys.dm_os_waiting_tasks t
    INNER JOIN sys.dm_exec_connections c ON t.session_id = c.session_id
    INNER JOIN sys.dm_exec_requests r ON t.session_id = r.session_id
    INNER JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
    CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) pl
    WHERE t.wait_type = 'PREEMPTIVE_OS_WRITEFILEGATHER'


    /* Query Problems - Long-Running Query Blocking Others - CheckID 5 */
    /*
    IF @Seconds &gt; 0
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount)
    SELECT 5 AS CheckID,
        1 AS Priority,
        'Query Problems' AS FindingGroup,
        'Long-Running Query Blocking Others' AS Finding,
        'http://www.BrentOzar.com/go/blocking' AS URL,
        'Query in ' + DB_NAME(db.resource_database_id) + ' has been running since ' + CAST(r.start_time AS NVARCHAR(100)) + '. ' + @LineFeed + @LineFeed
            + CAST(COALESCE((SELECT TOP 1 [text] FROM sys.dm_exec_sql_text(rBlocker.sql_handle)),
            (SELECT TOP 1 [text] FROM master..sysprocesses spBlocker CROSS APPLY sys.dm_exec_sql_text(spBlocker.sql_handle) WHERE spBlocker.spid = tBlocked.blocking_session_id), '') AS NVARCHAR(2000)) AS Details,
        'KILL ' + CAST(tBlocked.blocking_session_id AS NVARCHAR(100)) + ';' AS HowToStopIt,
        (SELECT TOP 1 query_plan FROM sys.dm_exec_query_plan(rBlocker.plan_handle)) AS QueryPlan,
        COALESCE((SELECT TOP 1 [text] FROM sys.dm_exec_sql_text(rBlocker.sql_handle)),
            (SELECT TOP 1 [text] FROM master..sysprocesses spBlocker CROSS APPLY sys.dm_exec_sql_text(spBlocker.sql_handle) WHERE spBlocker.spid = tBlocked.blocking_session_id)) AS QueryText,
        r.start_time AS StartTime,
        s.login_name AS LoginName,
        s.nt_user_name AS NTUserName,
        s.[program_name] AS ProgramName,
        s.[host_name] AS HostName,
        db.[resource_database_id] AS DatabaseID,
        DB_NAME(db.resource_database_id) AS DatabaseName,
        0 AS OpenTransactionCount
    FROM sys.dm_exec_sessions s
    INNER JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
    INNER JOIN sys.dm_exec_connections c ON s.session_id = c.session_id
    INNER JOIN sys.dm_os_waiting_tasks tBlocked ON tBlocked.session_id = s.session_id AND tBlocked.session_id &lt;&gt; s.session_id
    INNER JOIN (
    SELECT DISTINCT request_session_id, resource_database_id
    FROM    sys.dm_tran_locks
    WHERE resource_type = N'DATABASE'
    AND     request_mode = N'S'
    AND     request_status = N'GRANT'
    AND     request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') AS db ON s.session_id = db.request_session_id
    LEFT OUTER JOIN sys.dm_exec_requests rBlocker ON tBlocked.blocking_session_id = rBlocker.session_id
      WHERE NOT EXISTS (SELECT * FROM sys.dm_os_waiting_tasks tBlocker WHERE tBlocker.session_id = tBlocked.blocking_session_id AND tBlocker.blocking_session_id IS NOT NULL)
      AND s.last_request_start_time &lt; DATEADD(SECOND, -30, SYSDATETIMEOFFSET())
    */

    /* Query Problems - Plan Cache Erased Recently */
    IF DATEADD(mi, -15, SYSDATETIMEOFFSET()) &lt; (SELECT TOP 1 creation_time FROM sys.dm_exec_query_stats ORDER BY creation_time)
    BEGIN
        INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt)
        SELECT TOP 1 7 AS CheckID,
            50 AS Priority,
            'Query Problems' AS FindingGroup,
            'Plan Cache Erased Recently' AS Finding,
            'http://www.BrentOzar.com/askbrent/plan-cache-erased-recently/' AS URL,
            'The oldest query in the plan cache was created at ' + CAST(creation_time AS NVARCHAR(50)) + '. ' + @LineFeed + @LineFeed
                + 'This indicates that someone ran DBCC FREEPROCCACHE at that time,' + @LineFeed
                + 'Giving SQL Server temporary amnesia. Now, as queries come in,' + @LineFeed
                + 'SQL Server has to use a lot of CPU power in order to build execution' + @LineFeed
                + 'plans and put them in cache again. This causes high CPU loads.' AS Details,
            'Find who did that, and stop them from doing it again.' AS HowToStopIt
        FROM sys.dm_exec_query_stats
        ORDER BY creation_time
    END;


    /* Query Problems - Sleeping Query with Open Transactions - CheckID 8 */
    IF @Seconds &gt; 0
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, QueryText, OpenTransactionCount)
    SELECT 8 AS CheckID,
        50 AS Priority,
        'Query Problems' AS FindingGroup,
        'Sleeping Query with Open Transactions' AS Finding,
        'http://www.brentozar.com/askbrent/sleeping-query-with-open-transactions/' AS URL,
        'Database: ' + DB_NAME(db.resource_database_id) + @LineFeed + 'Host: ' + s.[host_name] + @LineFeed + 'Program: ' + s.[program_name] + @LineFeed + 'Asleep with open transactions and locks since ' + CAST(s.last_request_end_time AS NVARCHAR(100)) + '. ' AS Details,
        'KILL ' + CAST(s.session_id AS NVARCHAR(100)) + ';' AS HowToStopIt,
        s.last_request_start_time AS StartTime,
        s.login_name AS LoginName,
        s.nt_user_name AS NTUserName,
        s.[program_name] AS ProgramName,
        s.[host_name] AS HostName,
        db.[resource_database_id] AS DatabaseID,
        DB_NAME(db.resource_database_id) AS DatabaseName,
        (SELECT TOP 1 [text] FROM sys.dm_exec_sql_text(c.most_recent_sql_handle)) AS QueryText,
        sessions_with_transactions.open_transaction_count AS OpenTransactionCount
    FROM (SELECT session_id, SUM(open_transaction_count) AS open_transaction_count FROM sys.dm_exec_requests WHERE open_transaction_count &gt; 0 GROUP BY session_id) AS sessions_with_transactions
    INNER JOIN sys.dm_exec_sessions s ON sessions_with_transactions.session_id = s.session_id
    INNER JOIN sys.dm_exec_connections c ON s.session_id = c.session_id
    INNER JOIN (
    SELECT DISTINCT request_session_id, resource_database_id
    FROM    sys.dm_tran_locks
    WHERE resource_type = N'DATABASE'
    AND     request_mode = N'S'
    AND     request_status = N'GRANT'
    AND     request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') AS db ON s.session_id = db.request_session_id
    WHERE s.status = 'sleeping'
    AND s.last_request_end_time &lt; DATEADD(ss, -10, SYSDATETIMEOFFSET())
    AND EXISTS(SELECT * FROM sys.dm_tran_locks WHERE request_session_id = s.session_id
    AND NOT (resource_type = N'DATABASE' AND request_mode = N'S' AND request_status = N'GRANT' AND request_owner_type = N'SHARED_TRANSACTION_WORKSPACE'))


    /* Query Problems - Query Rolling Back - CheckID 9 */
    IF @Seconds &gt; 0
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, StartTime, LoginName, NTUserName, ProgramName, HostName, DatabaseID, DatabaseName, QueryText)
    SELECT 9 AS CheckID,
        1 AS Priority,
        'Query Problems' AS FindingGroup,
        'Query Rolling Back' AS Finding,
        'http://www.BrentOzar.com/askbrent/rollback/' AS URL,
        'Rollback started at ' + CAST(r.start_time AS NVARCHAR(100)) + ', is ' + CAST(r.percent_complete AS NVARCHAR(100)) + '% complete.' AS Details,
        'Unfortunately, you can''t stop this. Whatever you do, don''t restart the server in an attempt to fix it - SQL Server will keep rolling back.' AS HowToStopIt,
        r.start_time AS StartTime,
        s.login_name AS LoginName,
        s.nt_user_name AS NTUserName,
        s.[program_name] AS ProgramName,
        s.[host_name] AS HostName,
        db.[resource_database_id] AS DatabaseID,
        DB_NAME(db.resource_database_id) AS DatabaseName,
        (SELECT TOP 1 [text] FROM sys.dm_exec_sql_text(c.most_recent_sql_handle)) AS QueryText
    FROM sys.dm_exec_sessions s
    INNER JOIN sys.dm_exec_connections c ON s.session_id = c.session_id
    INNER JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
    LEFT OUTER JOIN (
        SELECT DISTINCT request_session_id, resource_database_id
        FROM    sys.dm_tran_locks
        WHERE resource_type = N'DATABASE'
        AND     request_mode = N'S'
        AND     request_status = N'GRANT'
        AND     request_owner_type = N'SHARED_TRANSACTION_WORKSPACE') AS db ON s.session_id = db.request_session_id
    WHERE r.status = 'rollback'


    /* Server Performance - Page Life Expectancy Low - CheckID 10 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt)
    SELECT 10 AS CheckID,
        50 AS Priority,
        'Server Performance' AS FindingGroup,
        'Page Life Expectancy Low' AS Finding,
        'http://www.BrentOzar.com/askbrent/page-life-expectancy/' AS URL,
        'SQL Server Buffer Manager:Page life expectancy is ' + CAST(c.cntr_value AS NVARCHAR(10)) + ' seconds.' + @LineFeed
            + 'This means SQL Server can only keep data pages in memory for that many seconds after reading those pages in from storage.' + @LineFeed
            + 'This is a symptom, not a cause - it indicates very read-intensive queries that need an index, or insufficient server memory.' AS Details,
        'Add more memory to the server, or find the queries reading a lot of data, and make them more efficient (or fix them with indexes).' AS HowToStopIt
    FROM sys.dm_os_performance_counters c
    WHERE object_name LIKE 'SQLServer:Buffer Manager%'
    AND counter_name LIKE 'Page life expectancy%'
    AND cntr_value &lt; 300

    /* Server Info - Database Size, Total GB - CheckID 21 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, Details, DetailsInt, URL)
    SELECT 21 AS CheckID,
        251 AS Priority,
        'Server Info' AS FindingGroup,
        'Database Size, Total GB' AS Finding,
        CAST(SUM (CAST(size AS BIGINT)*8./1024./1024.) AS VARCHAR(100)) AS Details,
        SUM (CAST(size AS BIGINT))*8./1024./1024. AS DetailsInt,
        'http://www.BrentOzar.com/askbrent/' AS URL
    FROM #MasterFiles
    WHERE database_id &gt; 4

    /* Server Info - Database Count - CheckID 22 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, Details, DetailsInt, URL)
    SELECT 22 AS CheckID,
        251 AS Priority,
        'Server Info' AS FindingGroup,
        'Database Count' AS Finding,
        CAST(SUM(1) AS VARCHAR(100)) AS Details,
        SUM (1) AS DetailsInt,
        'http://www.BrentOzar.com/askbrent/' AS URL
    FROM sys.databases
    WHERE database_id &gt; 4

    /* Server Performance - High CPU Utilization CheckID 24 */
    IF @Seconds &lt; 30
        BEGIN
        /* If we're waiting less than 30 seconds, run this check now rather than wait til the end.
           We get this data from the ring buffers, and it's only updated once per minute, so might
           as well get it now - whereas if we're checking 30+ seconds, it might get updated by the
           end of our sp_BlitzFirst session. */
        INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, Details, DetailsInt, URL)
        SELECT 24, 50, 'Server Performance', 'High CPU Utilization', CAST(100 - SystemIdle AS NVARCHAR(20)) + N'%. Ring buffer details: ' + CAST(record AS NVARCHAR(4000)), 100 - SystemIdle, 'http://www.BrentOzar.com/go/cpu'
            FROM (
                SELECT record,
                    record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') AS SystemIdle
                FROM (
                    SELECT TOP 1 CONVERT(XML, record) AS record
                    FROM sys.dm_os_ring_buffers
                    WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
                    AND record LIKE '%&lt;SystemHealth&gt;%'
                    ORDER BY timestamp DESC) AS rb
            ) AS y
            WHERE 100 - SystemIdle &gt;= 50

        INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, Details, DetailsInt, URL)
        SELECT 23, 250, 'Server Info', 'CPU Utilization', CAST(100 - SystemIdle AS NVARCHAR(20)) + N'%. Ring buffer details: ' + CAST(record AS NVARCHAR(4000)), 100 - SystemIdle, 'http://www.BrentOzar.com/go/cpu'
            FROM (
                SELECT record,
                    record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') AS SystemIdle
                FROM (
                    SELECT TOP 1 CONVERT(XML, record) AS record
                    FROM sys.dm_os_ring_buffers
                    WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
                    AND record LIKE '%&lt;SystemHealth&gt;%'
                    ORDER BY timestamp DESC) AS rb
            ) AS y

        END /* IF @Seconds &lt; 30 */

	RAISERROR('Finished running investigatory queries',10,1) WITH NOWAIT;


    /* End of checks. If we haven't waited @Seconds seconds, wait. */
    IF SYSDATETIMEOFFSET() &lt; @FinishSampleTime
		BEGIN
		RAISERROR('Waiting to match @Seconds parameter',10,1) WITH NOWAIT;
        WAITFOR TIME @FinishSampleTimeWaitFor;
		END

	RAISERROR('Capturing second pass of wait stats, perfmon counters, file stats',10,1) WITH NOWAIT;
    /* Populate #FileStats, #PerfmonStats, #WaitStats with DMV data. In a second, we'll compare these. */
    INSERT #WaitStats(Pass, SampleTime, wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count)
		SELECT 
		x.Pass, 
		x.SampleTime, 
		x.wait_type, 
		SUM(x.sum_wait_time_ms) AS sum_wait_time_ms, 
		SUM(x.sum_signal_wait_time_ms) AS sum_signal_wait_time_ms, 
		SUM(x.sum_waiting_tasks) AS sum_waiting_tasks
		FROM (
		SELECT  
				2 AS Pass,
				SYSDATETIMEOFFSET() AS SampleTime,
				owt.wait_type,
		        SUM(owt.wait_duration_ms) OVER (PARTITION BY owt.wait_type, owt.session_id)
					 - CASE WHEN @Seconds = 0 THEN 0 ELSE (@Seconds * 1000) END AS sum_wait_time_ms,
				0 AS sum_signal_wait_time_ms,
				CASE @Seconds WHEN 0 THEN 0 ELSE 1 END AS sum_waiting_tasks
			FROM    sys.dm_os_waiting_tasks owt
			WHERE owt.session_id &gt; 50
			AND owt.wait_duration_ms &gt;= CASE @Seconds WHEN 0 THEN 0 ELSE @Seconds * 1000 END
		UNION ALL
		SELECT
		       2 AS Pass,
		       SYSDATETIMEOFFSET() AS SampleTime,
		       os.wait_type,
			   SUM(os.wait_time_ms) OVER (PARTITION BY os.wait_type) AS sum_wait_time_ms,
			   SUM(os.signal_wait_time_ms) OVER (PARTITION BY os.wait_type ) AS sum_signal_wait_time_ms,
			   SUM(os.waiting_tasks_count) OVER (PARTITION BY os.wait_type) AS sum_waiting_tasks
		   FROM sys.dm_os_wait_stats os
		) x
		   WHERE x.wait_type NOT IN (
		       'REQUEST_FOR_DEADLOCK_SEARCH',
		       'SQLTRACE_INCREMENTAL_FLUSH_SLEEP',
		       'SQLTRACE_BUFFER_FLUSH',
		       'LAZYWRITER_SLEEP',
		       'XE_TIMER_EVENT',
		       'XE_DISPATCHER_WAIT',
		       'FT_IFTS_SCHEDULER_IDLE_WAIT',
		       'LOGMGR_QUEUE',
		       'CHECKPOINT_QUEUE',
		       'BROKER_TO_FLUSH',
		       'BROKER_TASK_STOP',
		       'BROKER_EVENTHANDLER',
		       'SLEEP_TASK',
		       'WAITFOR',
		       'DBMIRROR_DBM_MUTEX',
		       'DBMIRROR_EVENTS_QUEUE',
		       'DBMIRRORING_CMD',
		       'DISPATCHER_QUEUE_SEMAPHORE',
		       'BROKER_RECEIVE_WAITFOR',
		       'CLR_AUTO_EVENT',
		       'DIRTY_PAGE_POLL',
		       'HADR_FILESTREAM_IOMGR_IOCOMPLETION',
		       'ONDEMAND_TASK_QUEUE',
		       'FT_IFTSHC_MUTEX',
		       'CLR_MANUAL_EVENT',
		       'CLR_SEMAPHORE',
		       'DBMIRROR_WORKER_QUEUE',
		       'DBMIRROR_DBM_EVENT',
		       'SP_SERVER_DIAGNOSTICS_SLEEP',
		       'HADR_CLUSAPI_CALL',
		       'HADR_LOGCAPTURE_WAIT',
		       'HADR_NOTIFICATION_DEQUEUE',
		       'HADR_TIMER_TASK',
		       'HADR_WORK_QUEUE',
		       'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
		       'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP',
		       'RESOURCE_GOVERNOR_IDLE',
		       'QDS_ASYNC_QUEUE',
		       'QDS_SHUTDOWN_QUEUE',
		       'SLEEP_SYSTEMTASK',
		       'BROKER_TRANSMITTER',
		       'REDO_THREAD_PENDING_WORK',
		       'UCS_SESSION_REGISTRATION'
		   )
		GROUP BY x.Pass, x.SampleTime, x.wait_type
		ORDER BY sum_wait_time_ms DESC;

    INSERT INTO #FileStats (Pass, SampleTime, DatabaseID, FileID, DatabaseName, FileLogicalName, SizeOnDiskMB, io_stall_read_ms ,
        num_of_reads, [bytes_read] , io_stall_write_ms,num_of_writes, [bytes_written], PhysicalName, TypeDesc, avg_stall_read_ms, avg_stall_write_ms)
    SELECT         2 AS Pass,
        SYSDATETIMEOFFSET() AS SampleTime,
        mf.[database_id],
        mf.[file_id],
        DB_NAME(vfs.database_id) AS [db_name],
        mf.name + N' [' + mf.type_desc COLLATE SQL_Latin1_General_CP1_CI_AS + N']' AS file_logical_name ,
        CAST(( ( vfs.size_on_disk_bytes / 1024.0 ) / 1024.0 ) AS INT) AS size_on_disk_mb ,
        vfs.io_stall_read_ms ,
        vfs.num_of_reads ,
        vfs.[num_of_bytes_read],
        vfs.io_stall_write_ms ,
        vfs.num_of_writes ,
        vfs.[num_of_bytes_written],
        mf.physical_name,
        mf.type_desc,
        0,
        0
    FROM sys.dm_io_virtual_file_stats (NULL, NULL) AS vfs
    INNER JOIN #MasterFiles AS mf ON vfs.file_id = mf.file_id
        AND vfs.database_id = mf.database_id
    WHERE vfs.num_of_reads &gt; 0
        OR vfs.num_of_writes &gt; 0;

    INSERT INTO #PerfmonStats (Pass, SampleTime, [object_name],[counter_name],[instance_name],[cntr_value],[cntr_type])
    SELECT         2 AS Pass,
        SYSDATETIMEOFFSET() AS SampleTime,
        RTRIM(dmv.object_name), RTRIM(dmv.counter_name), RTRIM(dmv.instance_name), dmv.cntr_value, dmv.cntr_type
        FROM #PerfmonCounters counters
        INNER JOIN sys.dm_os_performance_counters dmv ON counters.counter_name COLLATE SQL_Latin1_General_CP1_CI_AS = RTRIM(dmv.counter_name) COLLATE SQL_Latin1_General_CP1_CI_AS
            AND counters.[object_name] COLLATE SQL_Latin1_General_CP1_CI_AS = RTRIM(dmv.[object_name]) COLLATE SQL_Latin1_General_CP1_CI_AS
            AND (counters.[instance_name] IS NULL OR counters.[instance_name] COLLATE SQL_Latin1_General_CP1_CI_AS = RTRIM(dmv.[instance_name]) COLLATE SQL_Latin1_General_CP1_CI_AS)

    /* Set the latencies and averages. We could do this with a CTE, but we're not ambitious today. */
    UPDATE fNow
    SET avg_stall_read_ms = ((fNow.io_stall_read_ms - fBase.io_stall_read_ms) / (fNow.num_of_reads - fBase.num_of_reads))
    FROM #FileStats fNow
    INNER JOIN #FileStats fBase ON fNow.DatabaseID = fBase.DatabaseID AND fNow.FileID = fBase.FileID AND fNow.SampleTime &gt; fBase.SampleTime AND fNow.num_of_reads &gt; fBase.num_of_reads AND fNow.io_stall_read_ms &gt; fBase.io_stall_read_ms
    WHERE (fNow.num_of_reads - fBase.num_of_reads) &gt; 0

    UPDATE fNow
    SET avg_stall_write_ms = ((fNow.io_stall_write_ms - fBase.io_stall_write_ms) / (fNow.num_of_writes - fBase.num_of_writes))
    FROM #FileStats fNow
    INNER JOIN #FileStats fBase ON fNow.DatabaseID = fBase.DatabaseID AND fNow.FileID = fBase.FileID AND fNow.SampleTime &gt; fBase.SampleTime AND fNow.num_of_writes &gt; fBase.num_of_writes AND fNow.io_stall_write_ms &gt; fBase.io_stall_write_ms
    WHERE (fNow.num_of_writes - fBase.num_of_writes) &gt; 0

    UPDATE pNow
        SET [value_delta] = pNow.cntr_value - pFirst.cntr_value,
            [value_per_second] = ((1.0 * pNow.cntr_value - pFirst.cntr_value) / DATEDIFF(ss, pFirst.SampleTime, pNow.SampleTime))
        FROM #PerfmonStats pNow
            INNER JOIN #PerfmonStats pFirst ON pFirst.[object_name] = pNow.[object_name] AND pFirst.counter_name = pNow.counter_name AND (pFirst.instance_name = pNow.instance_name OR (pFirst.instance_name IS NULL AND pNow.instance_name IS NULL))
                AND pNow.ID &gt; pFirst.ID
        WHERE  DATEDIFF(ss, pFirst.SampleTime, pNow.SampleTime) &gt; 0;


    /* If we're within 10 seconds of our projected finish time, do the plan cache analysis. */
    IF DATEDIFF(ss, @FinishSampleTime, SYSDATETIMEOFFSET()) &gt; 10 AND @CheckProcedureCache = 1
        BEGIN

            INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details)
            VALUES (18, 210, 'Query Stats', 'Plan Cache Analysis Skipped', 'http://www.BrentOzar.com/go/topqueries',
                'Due to excessive load, the plan cache analysis was skipped. To override this, use @ExpertMode = 1.')

        END
    ELSE IF @CheckProcedureCache = 1
        BEGIN


		RAISERROR('@CheckProcedureCache = 1, capturing second pass of plan cache',10,1) WITH NOWAIT;

        /* Populate #QueryStats. SQL 2005 doesn't have query hash or query plan hash. */
		IF @@VERSION LIKE 'Microsoft SQL Server 2005%'
			BEGIN
			IF @FilterPlansByDatabase IS NULL
				BEGIN
				SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											WHERE qs.last_execution_time &gt;= @StartSampleTimeText;';
				END
			ELSE
				BEGIN
				SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
												CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS attr
												INNER JOIN #FilterPlansByDatabase dbs ON CAST(attr.value AS INT) = dbs.DatabaseID
											WHERE qs.last_execution_time &gt;= @StartSampleTimeText
												AND attr.attribute = ''dbid'';';
				END
			END
		ELSE
			BEGIN
			IF @FilterPlansByDatabase IS NULL
				BEGIN
				SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											WHERE qs.last_execution_time &gt;= @StartSampleTimeText';
				END
			ELSE
				BEGIN
				SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
											SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
											FROM sys.dm_exec_query_stats qs
											CROSS APPLY sys.dm_exec_plan_attributes(qs.plan_handle) AS attr
											INNER JOIN #FilterPlansByDatabase dbs ON CAST(attr.value AS INT) = dbs.DatabaseID
											WHERE qs.last_execution_time &gt;= @StartSampleTimeText
												AND attr.attribute = ''dbid'';';
				END
			END
		/* Old version pre-2016/06/13:
        IF @@VERSION LIKE 'Microsoft SQL Server 2005%'
            SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
                                        SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, NULL AS query_hash, NULL AS query_plan_hash, 0
                                        FROM sys.dm_exec_query_stats qs
                                        WHERE qs.last_execution_time &gt;= @StartSampleTimeText;';
        ELSE
            SET @StringToExecute = N'INSERT INTO #QueryStats ([sql_handle], Pass, SampleTime, statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, Points)
                                        SELECT [sql_handle], 2 AS Pass, SYSDATETIMEOFFSET(), statement_start_offset, statement_end_offset, plan_generation_num, plan_handle, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time, query_hash, query_plan_hash, 0
                                        FROM sys.dm_exec_query_stats qs
                                        WHERE qs.last_execution_time &gt;= @StartSampleTimeText;';
		*/
        SET @ParmDefinitions = N'@StartSampleTimeText NVARCHAR(100)';
        SET @Parm1 = CONVERT(NVARCHAR(100), CAST(@StartSampleTime AS DATETIME), 127);

        EXECUTE sp_executesql @StringToExecute, @ParmDefinitions, @StartSampleTimeText = @Parm1;

		RAISERROR('@CheckProcedureCache = 1, totaling up plan cache metrics',10,1) WITH NOWAIT;

        /* Get the totals for the entire plan cache */
        INSERT INTO #QueryStats (Pass, SampleTime, execution_count, total_worker_time, total_physical_reads, total_logical_writes, total_logical_reads, total_clr_time, total_elapsed_time, creation_time)
        SELECT 0 AS Pass, SYSDATETIMEOFFSET(), SUM(execution_count), SUM(total_worker_time), SUM(total_physical_reads), SUM(total_logical_writes), SUM(total_logical_reads), SUM(total_clr_time), SUM(total_elapsed_time), MIN(creation_time)
            FROM sys.dm_exec_query_stats qs;


		RAISERROR('@CheckProcedureCache = 1, so analyzing execution plans',10,1) WITH NOWAIT;
        /*
        Pick the most resource-intensive queries to review. Update the Points field
        in #QueryStats - if a query is in the top 10 for logical reads, CPU time,
        duration, or execution, add 1 to its points.
        */
        WITH qsTop AS (
        SELECT TOP 10 qsNow.ID
        FROM #QueryStats qsNow
          INNER JOIN #QueryStats qsFirst ON qsNow.[sql_handle] = qsFirst.[sql_handle] AND qsNow.statement_start_offset = qsFirst.statement_start_offset AND qsNow.statement_end_offset = qsFirst.statement_end_offset AND qsNow.plan_generation_num = qsFirst.plan_generation_num AND qsNow.plan_handle = qsFirst.plan_handle AND qsFirst.Pass = 1
        WHERE qsNow.total_elapsed_time &gt; qsFirst.total_elapsed_time
            AND qsNow.Pass = 2
            AND qsNow.total_elapsed_time - qsFirst.total_elapsed_time &gt; 1000000 /* Only queries with over 1 second of runtime */
        ORDER BY (qsNow.total_elapsed_time - COALESCE(qsFirst.total_elapsed_time, 0)) DESC)
        UPDATE #QueryStats
            SET Points = Points + 1
            FROM #QueryStats qs
            INNER JOIN qsTop ON qs.ID = qsTop.ID;

        WITH qsTop AS (
        SELECT TOP 10 qsNow.ID
        FROM #QueryStats qsNow
          INNER JOIN #QueryStats qsFirst ON qsNow.[sql_handle] = qsFirst.[sql_handle] AND qsNow.statement_start_offset = qsFirst.statement_start_offset AND qsNow.statement_end_offset = qsFirst.statement_end_offset AND qsNow.plan_generation_num = qsFirst.plan_generation_num AND qsNow.plan_handle = qsFirst.plan_handle AND qsFirst.Pass = 1
        WHERE qsNow.total_logical_reads &gt; qsFirst.total_logical_reads
            AND qsNow.Pass = 2
            AND qsNow.total_logical_reads - qsFirst.total_logical_reads &gt; 1000 /* Only queries with over 1000 reads */
        ORDER BY (qsNow.total_logical_reads - COALESCE(qsFirst.total_logical_reads, 0)) DESC)
        UPDATE #QueryStats
            SET Points = Points + 1
            FROM #QueryStats qs
            INNER JOIN qsTop ON qs.ID = qsTop.ID;

        WITH qsTop AS (
        SELECT TOP 10 qsNow.ID
        FROM #QueryStats qsNow
          INNER JOIN #QueryStats qsFirst ON qsNow.[sql_handle] = qsFirst.[sql_handle] AND qsNow.statement_start_offset = qsFirst.statement_start_offset AND qsNow.statement_end_offset = qsFirst.statement_end_offset AND qsNow.plan_generation_num = qsFirst.plan_generation_num AND qsNow.plan_handle = qsFirst.plan_handle AND qsFirst.Pass = 1
        WHERE qsNow.total_worker_time &gt; qsFirst.total_worker_time
            AND qsNow.Pass = 2
            AND qsNow.total_worker_time - qsFirst.total_worker_time &gt; 1000000 /* Only queries with over 1 second of worker time */
        ORDER BY (qsNow.total_worker_time - COALESCE(qsFirst.total_worker_time, 0)) DESC)
        UPDATE #QueryStats
            SET Points = Points + 1
            FROM #QueryStats qs
            INNER JOIN qsTop ON qs.ID = qsTop.ID;

        WITH qsTop AS (
        SELECT TOP 10 qsNow.ID
        FROM #QueryStats qsNow
          INNER JOIN #QueryStats qsFirst ON qsNow.[sql_handle] = qsFirst.[sql_handle] AND qsNow.statement_start_offset = qsFirst.statement_start_offset AND qsNow.statement_end_offset = qsFirst.statement_end_offset AND qsNow.plan_generation_num = qsFirst.plan_generation_num AND qsNow.plan_handle = qsFirst.plan_handle AND qsFirst.Pass = 1
        WHERE qsNow.execution_count &gt; qsFirst.execution_count
            AND qsNow.Pass = 2
            AND (qsNow.total_elapsed_time - qsFirst.total_elapsed_time &gt; 1000000 /* Only queries with over 1 second of runtime */
                OR qsNow.total_logical_reads - qsFirst.total_logical_reads &gt; 1000 /* Only queries with over 1000 reads */
                OR qsNow.total_worker_time - qsFirst.total_worker_time &gt; 1000000 /* Only queries with over 1 second of worker time */)
        ORDER BY (qsNow.execution_count - COALESCE(qsFirst.execution_count, 0)) DESC)
        UPDATE #QueryStats
            SET Points = Points + 1
            FROM #QueryStats qs
            INNER JOIN qsTop ON qs.ID = qsTop.ID;

        /* Query Stats - CheckID 17 - Most Resource-Intensive Queries */
        INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, QueryStatsNowID, QueryStatsFirstID, PlanHandle)
        SELECT 17, 210, 'Query Stats', 'Most Resource-Intensive Queries', 'http://www.BrentOzar.com/go/topqueries',
            'Query stats during the sample:' + @LineFeed +
            'Executions: ' + CAST(qsNow.execution_count - (COALESCE(qsFirst.execution_count, 0)) AS NVARCHAR(100)) + @LineFeed +
            'Elapsed Time: ' + CAST(qsNow.total_elapsed_time - (COALESCE(qsFirst.total_elapsed_time, 0)) AS NVARCHAR(100)) + @LineFeed +
            'CPU Time: ' + CAST(qsNow.total_worker_time - (COALESCE(qsFirst.total_worker_time, 0)) AS NVARCHAR(100)) + @LineFeed +
            'Logical Reads: ' + CAST(qsNow.total_logical_reads - (COALESCE(qsFirst.total_logical_reads, 0)) AS NVARCHAR(100)) + @LineFeed +
            'Logical Writes: ' + CAST(qsNow.total_logical_writes - (COALESCE(qsFirst.total_logical_writes, 0)) AS NVARCHAR(100)) + @LineFeed +
            'CLR Time: ' + CAST(qsNow.total_clr_time - (COALESCE(qsFirst.total_clr_time, 0)) AS NVARCHAR(100)) + @LineFeed +
            @LineFeed + @LineFeed + 'Query stats since ' + CONVERT(NVARCHAR(100), qsNow.creation_time ,121) + @LineFeed +
            'Executions: ' + CAST(qsNow.execution_count AS NVARCHAR(100)) +
                    CASE qsTotal.execution_count WHEN 0 THEN '' ELSE (' - Percent of Server Total: ' + CAST(CAST(100.0 * qsNow.execution_count / qsTotal.execution_count AS DECIMAL(6,2)) AS NVARCHAR(100)) + '%') END + @LineFeed +
            'Elapsed Time: ' + CAST(qsNow.total_elapsed_time AS NVARCHAR(100)) +
                    CASE qsTotal.total_elapsed_time WHEN 0 THEN '' ELSE (' - Percent of Server Total: ' + CAST(CAST(100.0 * qsNow.total_elapsed_time / qsTotal.total_elapsed_time AS DECIMAL(6,2)) AS NVARCHAR(100)) + '%') END + @LineFeed +
            'CPU Time: ' + CAST(qsNow.total_worker_time AS NVARCHAR(100)) +
                    CASE qsTotal.total_worker_time WHEN 0 THEN '' ELSE (' - Percent of Server Total: ' + CAST(CAST(100.0 * qsNow.total_worker_time / qsTotal.total_worker_time AS DECIMAL(6,2)) AS NVARCHAR(100)) + '%') END + @LineFeed +
            'Logical Reads: ' + CAST(qsNow.total_logical_reads AS NVARCHAR(100)) +
                    CASE qsTotal.total_logical_reads WHEN 0 THEN '' ELSE (' - Percent of Server Total: ' + CAST(CAST(100.0 * qsNow.total_logical_reads / qsTotal.total_logical_reads AS DECIMAL(6,2)) AS NVARCHAR(100)) + '%') END + @LineFeed +
            'Logical Writes: ' + CAST(qsNow.total_logical_writes AS NVARCHAR(100)) +
                    CASE qsTotal.total_logical_writes WHEN 0 THEN '' ELSE (' - Percent of Server Total: ' + CAST(CAST(100.0 * qsNow.total_logical_writes / qsTotal.total_logical_writes AS DECIMAL(6,2)) AS NVARCHAR(100)) + '%') END + @LineFeed +
            'CLR Time: ' + CAST(qsNow.total_clr_time AS NVARCHAR(100)) +
                    CASE qsTotal.total_clr_time WHEN 0 THEN '' ELSE (' - Percent of Server Total: ' + CAST(CAST(100.0 * qsNow.total_clr_time / qsTotal.total_clr_time AS DECIMAL(6,2)) AS NVARCHAR(100)) + '%') END + @LineFeed +
            --@LineFeed + @LineFeed + 'Query hash: ' + CAST(qsNow.query_hash AS NVARCHAR(100)) + @LineFeed +
            --@LineFeed + @LineFeed + 'Query plan hash: ' + CAST(qsNow.query_plan_hash AS NVARCHAR(100)) +
            @LineFeed AS Details,
            'See the URL for tuning tips on why this query may be consuming resources.' AS HowToStopIt,
            qp.query_plan,
            QueryText = SUBSTRING(st.text,
                 (qsNow.statement_start_offset / 2) + 1,
                 ((CASE qsNow.statement_end_offset
                   WHEN -1 THEN DATALENGTH(st.text)
                   ELSE qsNow.statement_end_offset
                   END - qsNow.statement_start_offset) / 2) + 1),
            qsNow.ID AS QueryStatsNowID,
            qsFirst.ID AS QueryStatsFirstID,
            qsNow.plan_handle AS PlanHandle
            FROM #QueryStats qsNow
                INNER JOIN #QueryStats qsTotal ON qsTotal.Pass = 0
                LEFT OUTER JOIN #QueryStats qsFirst ON qsNow.[sql_handle] = qsFirst.[sql_handle] AND qsNow.statement_start_offset = qsFirst.statement_start_offset AND qsNow.statement_end_offset = qsFirst.statement_end_offset AND qsNow.plan_generation_num = qsFirst.plan_generation_num AND qsNow.plan_handle = qsFirst.plan_handle AND qsFirst.Pass = 1
                CROSS APPLY sys.dm_exec_sql_text(qsNow.sql_handle) AS st
                CROSS APPLY sys.dm_exec_query_plan(qsNow.plan_handle) AS qp
            WHERE qsNow.Points &gt; 0 AND st.text IS NOT NULL AND qp.query_plan IS NOT NULL

            UPDATE #BlitzFirstResults
                SET DatabaseID = CAST(attr.value AS INT),
                DatabaseName = DB_NAME(CAST(attr.value AS INT))
            FROM #BlitzFirstResults
                CROSS APPLY sys.dm_exec_plan_attributes(#BlitzFirstResults.PlanHandle) AS attr
            WHERE attr.attribute = 'dbid'


        END /* IF DATEDIFF(ss, @FinishSampleTime, SYSDATETIMEOFFSET()) &gt; 10 AND @CheckProcedureCache = 1 */


	RAISERROR('Analyzing changes between first and second passes of DMVs',10,1) WITH NOWAIT;

    /* Wait Stats - CheckID 6 */
    /* Compare the current wait stats to the sample we took at the start, and insert the top 10 waits. */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, DetailsInt)
    SELECT TOP 10 6 AS CheckID,
        200 AS Priority,
        'Wait Stats' AS FindingGroup,
        wNow.wait_type AS Finding,
        N'http://www.brentozar.com/sql/wait-stats/#' + wNow.wait_type AS URL,
        'For ' + CAST(((wNow.wait_time_ms - COALESCE(wBase.wait_time_ms,0)) / 1000) AS NVARCHAR(100)) + ' seconds over the last ' + CASE @Seconds WHEN 0 THEN (CAST(DATEDIFF(dd,@StartSampleTime,@FinishSampleTime) AS NVARCHAR(10)) + ' days') ELSE (CAST(@Seconds AS NVARCHAR(10)) + ' seconds') END + ', SQL Server was waiting on this particular bottleneck.' + @LineFeed + @LineFeed AS Details,
        'See the URL for more details on how to mitigate this wait type.' AS HowToStopIt,
        ((wNow.wait_time_ms - COALESCE(wBase.wait_time_ms,0)) / 1000) AS DetailsInt
    FROM #WaitStats wNow
    LEFT OUTER JOIN #WaitStats wBase ON wNow.wait_type = wBase.wait_type AND wNow.SampleTime &gt; wBase.SampleTime
    WHERE wNow.wait_time_ms &gt; (wBase.wait_time_ms + (.5 * (DATEDIFF(ss,@StartSampleTime,@FinishSampleTime)) * 1000)) /* Only look for things we've actually waited on for half of the time or more */
    ORDER BY (wNow.wait_time_ms - COALESCE(wBase.wait_time_ms,0)) DESC;

    /* Server Performance - Slow Data File Reads - CheckID 11 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, DatabaseID, DatabaseName)
    SELECT TOP 10 11 AS CheckID,
        50 AS Priority,
        'Server Performance' AS FindingGroup,
        'Slow Data File Reads' AS Finding,
        'http://www.BrentOzar.com/go/slow/' AS URL,
        'File: ' + fNow.PhysicalName + @LineFeed
            + 'Number of reads during the sample: ' + CAST((fNow.num_of_reads - fBase.num_of_reads) AS NVARCHAR(20)) + @LineFeed
            + 'Seconds spent waiting on storage for these reads: ' + CAST(((fNow.io_stall_read_ms - fBase.io_stall_read_ms) / 1000.0) AS NVARCHAR(20)) + @LineFeed
            + 'Average read latency during the sample: ' + CAST(((fNow.io_stall_read_ms - fBase.io_stall_read_ms) / (fNow.num_of_reads - fBase.num_of_reads) ) AS NVARCHAR(20)) + ' milliseconds' + @LineFeed
            + 'Microsoft guidance for data file read speed: 20ms or less.' + @LineFeed + @LineFeed AS Details,
        'See the URL for more details on how to mitigate this wait type.' AS HowToStopIt,
        fNow.DatabaseID,
        fNow.DatabaseName
    FROM #FileStats fNow
    INNER JOIN #FileStats fBase ON fNow.DatabaseID = fBase.DatabaseID AND fNow.FileID = fBase.FileID AND fNow.SampleTime &gt; fBase.SampleTime AND fNow.num_of_reads &gt; fBase.num_of_reads AND fNow.io_stall_read_ms &gt; (fBase.io_stall_read_ms + 1000)
    WHERE (fNow.io_stall_read_ms - fBase.io_stall_read_ms) / (fNow.num_of_reads - fBase.num_of_reads) &gt;= @FileLatencyThresholdMS
        AND fNow.TypeDesc = 'ROWS'
    ORDER BY (fNow.io_stall_read_ms - fBase.io_stall_read_ms) / (fNow.num_of_reads - fBase.num_of_reads) DESC;

    /* Server Performance - Slow Log File Writes - CheckID 12 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, DatabaseID, DatabaseName)
    SELECT TOP 10 12 AS CheckID,
        50 AS Priority,
        'Server Performance' AS FindingGroup,
        'Slow Log File Writes' AS Finding,
        'http://www.BrentOzar.com/go/slow/' AS URL,
        'File: ' + fNow.PhysicalName + @LineFeed
            + 'Number of writes during the sample: ' + CAST((fNow.num_of_writes - fBase.num_of_writes) AS NVARCHAR(20)) + @LineFeed
            + 'Seconds spent waiting on storage for these writes: ' + CAST(((fNow.io_stall_write_ms - fBase.io_stall_write_ms) / 1000.0) AS NVARCHAR(20)) + @LineFeed
            + 'Average write latency during the sample: ' + CAST(((fNow.io_stall_write_ms - fBase.io_stall_write_ms) / (fNow.num_of_writes - fBase.num_of_writes) ) AS NVARCHAR(20)) + ' milliseconds' + @LineFeed
            + 'Microsoft guidance for log file write speed: 3ms or less.' + @LineFeed + @LineFeed AS Details,
        'See the URL for more details on how to mitigate this wait type.' AS HowToStopIt,
        fNow.DatabaseID,
        fNow.DatabaseName
    FROM #FileStats fNow
    INNER JOIN #FileStats fBase ON fNow.DatabaseID = fBase.DatabaseID AND fNow.FileID = fBase.FileID AND fNow.SampleTime &gt; fBase.SampleTime AND fNow.num_of_writes &gt; fBase.num_of_writes AND fNow.io_stall_write_ms &gt; (fBase.io_stall_write_ms + 1000)
    WHERE (fNow.io_stall_write_ms - fBase.io_stall_write_ms) / (fNow.num_of_writes - fBase.num_of_writes) &gt;= @FileLatencyThresholdMS
        AND fNow.TypeDesc = 'LOG'
    ORDER BY (fNow.io_stall_write_ms - fBase.io_stall_write_ms) / (fNow.num_of_writes - fBase.num_of_writes) DESC;


    /* SQL Server Internal Maintenance - Log File Growing - CheckID 13 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt)
    SELECT 13 AS CheckID,
        1 AS Priority,
        'SQL Server Internal Maintenance' AS FindingGroup,
        'Log File Growing' AS Finding,
        'http://www.BrentOzar.com/askbrent/file-growing/' AS URL,
        'Number of growths during the sample: ' + CAST(ps.value_delta AS NVARCHAR(20)) + @LineFeed
            + 'Determined by sampling Perfmon counter ' + ps.object_name + ' - ' + ps.counter_name + @LineFeed AS Details,
        'Pre-grow data and log files during maintenance windows so that they do not grow during production loads. See the URL for more details.'  AS HowToStopIt
    FROM #PerfmonStats ps
    WHERE ps.Pass = 2
        AND object_name = @ServiceName + ':Databases'
        AND counter_name = 'Log Growths'
        AND value_delta &gt; 0


    /* SQL Server Internal Maintenance - Log File Shrinking - CheckID 14 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt)
    SELECT 14 AS CheckID,
        1 AS Priority,
        'SQL Server Internal Maintenance' AS FindingGroup,
        'Log File Shrinking' AS Finding,
        'http://www.BrentOzar.com/askbrent/file-shrinking/' AS URL,
        'Number of shrinks during the sample: ' + CAST(ps.value_delta AS NVARCHAR(20)) + @LineFeed
            + 'Determined by sampling Perfmon counter ' + ps.object_name + ' - ' + ps.counter_name + @LineFeed AS Details,
        'Pre-grow data and log files during maintenance windows so that they do not grow during production loads. See the URL for more details.' AS HowToStopIt
    FROM #PerfmonStats ps
    WHERE ps.Pass = 2
        AND object_name = @ServiceName + ':Databases'
        AND counter_name = 'Log Shrinks'
        AND value_delta &gt; 0

    /* Query Problems - Compilations/Sec High - CheckID 15 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt)
    SELECT 15 AS CheckID,
        50 AS Priority,
        'Query Problems' AS FindingGroup,
        'Compilations/Sec High' AS Finding,
        'http://www.BrentOzar.com/askbrent/compilations/' AS URL,
        'Number of batch requests during the sample: ' + CAST(ps.value_delta AS NVARCHAR(20)) + @LineFeed
            + 'Number of compilations during the sample: ' + CAST(psComp.value_delta AS NVARCHAR(20)) + @LineFeed
            + 'For OLTP environments, Microsoft recommends that 90% of batch requests should hit the plan cache, and not be compiled from scratch. We are exceeding that threshold.' + @LineFeed AS Details,
        'Find out why plans are not being reused, and consider enabling Forced Parameterization. See the URL for more details.' AS HowToStopIt
    FROM #PerfmonStats ps
        INNER JOIN #PerfmonStats psComp ON psComp.Pass = 2 AND psComp.object_name = @ServiceName + ':SQL Statistics' AND psComp.counter_name = 'SQL Compilations/sec' AND psComp.value_delta &gt; 0
    WHERE ps.Pass = 2
        AND ps.object_name = @ServiceName + ':SQL Statistics'
        AND ps.counter_name = 'Batch Requests/sec'
        AND ps.value_delta &gt; (1000 * @Seconds) /* Ignore servers sitting idle */
        AND (psComp.value_delta * 10) &gt; ps.value_delta /* Compilations are more than 10% of batch requests per second */

    /* Query Problems - Re-Compilations/Sec High - CheckID 16 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt)
    SELECT 16 AS CheckID,
        50 AS Priority,
        'Query Problems' AS FindingGroup,
        'Re-Compilations/Sec High' AS Finding,
        'http://www.BrentOzar.com/askbrent/recompilations/' AS URL,
        'Number of batch requests during the sample: ' + CAST(ps.value_delta AS NVARCHAR(20)) + @LineFeed
            + 'Number of recompilations during the sample: ' + CAST(psComp.value_delta AS NVARCHAR(20)) + @LineFeed
            + 'More than 10% of our queries are being recompiled. This is typically due to statistics changing on objects.' + @LineFeed AS Details,
        'Find out which objects are changing so quickly that they hit the stats update threshold. See the URL for more details.' AS HowToStopIt
    FROM #PerfmonStats ps
        INNER JOIN #PerfmonStats psComp ON psComp.Pass = 2 AND psComp.object_name = @ServiceName + ':SQL Statistics' AND psComp.counter_name = 'SQL Re-Compilations/sec' AND psComp.value_delta &gt; 0
    WHERE ps.Pass = 2
        AND ps.object_name = @ServiceName + ':SQL Statistics'
        AND ps.counter_name = 'Batch Requests/sec'
        AND ps.value_delta &gt; (1000 * @Seconds) /* Ignore servers sitting idle */
        AND (psComp.value_delta * 10) &gt; ps.value_delta /* Recompilations are more than 10% of batch requests per second */

    /* Server Info - Batch Requests per Sec - CheckID 19 */
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, DetailsInt)
    SELECT 19 AS CheckID,
        250 AS Priority,
        'Server Info' AS FindingGroup,
        'Batch Requests per Sec' AS Finding,
        'http://www.BrentOzar.com/go/measure' AS URL,
        CAST(ps.value_delta / (DATEDIFF(ss, ps1.SampleTime, ps.SampleTime)) AS NVARCHAR(20)) AS Details,
        ps.value_delta / (DATEDIFF(ss, ps1.SampleTime, ps.SampleTime)) AS DetailsInt
    FROM #PerfmonStats ps
        INNER JOIN #PerfmonStats ps1 ON ps.object_name = ps1.object_name AND ps.counter_name = ps1.counter_name AND ps1.Pass = 1
    WHERE ps.Pass = 2
        AND ps.object_name = @ServiceName + ':SQL Statistics'
        AND ps.counter_name = 'Batch Requests/sec';


        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','SQL Compilations/sec', NULL)
        INSERT INTO #PerfmonCounters ([object_name],[counter_name],[instance_name]) VALUES (@ServiceName + ':SQL Statistics','SQL Re-Compilations/sec', NULL)

    /* Server Info - SQL Compilations/sec - CheckID 25 */
    IF @ExpertMode = 1
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, DetailsInt)
    SELECT 25 AS CheckID,
        250 AS Priority,
        'Server Info' AS FindingGroup,
        'SQL Compilations per Sec' AS Finding,
        'http://www.BrentOzar.com/go/measure' AS URL,
        CAST(ps.value_delta / (DATEDIFF(ss, ps1.SampleTime, ps.SampleTime)) AS NVARCHAR(20)) AS Details,
        ps.value_delta / (DATEDIFF(ss, ps1.SampleTime, ps.SampleTime)) AS DetailsInt
    FROM #PerfmonStats ps
        INNER JOIN #PerfmonStats ps1 ON ps.object_name = ps1.object_name AND ps.counter_name = ps1.counter_name AND ps1.Pass = 1
    WHERE ps.Pass = 2
        AND ps.object_name = @ServiceName + ':SQL Statistics'
        AND ps.counter_name = 'SQL Compilations/sec';

    /* Server Info - SQL Re-Compilations/sec - CheckID 26 */
    IF @ExpertMode = 1
    INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, DetailsInt)
    SELECT 26 AS CheckID,
        250 AS Priority,
        'Server Info' AS FindingGroup,
        'SQL Re-Compilations per Sec' AS Finding,
        'http://www.BrentOzar.com/go/measure' AS URL,
        CAST(ps.value_delta / (DATEDIFF(ss, ps1.SampleTime, ps.SampleTime)) AS NVARCHAR(20)) AS Details,
        ps.value_delta / (DATEDIFF(ss, ps1.SampleTime, ps.SampleTime)) AS DetailsInt
    FROM #PerfmonStats ps
        INNER JOIN #PerfmonStats ps1 ON ps.object_name = ps1.object_name AND ps.counter_name = ps1.counter_name AND ps1.Pass = 1
    WHERE ps.Pass = 2
        AND ps.object_name = @ServiceName + ':SQL Statistics'
        AND ps.counter_name = 'SQL Re-Compilations/sec';

    /* Server Info - Wait Time per Core per Sec - CheckID 20 */
    IF @Seconds &gt; 0
    BEGIN
        WITH waits1(SampleTime, waits_ms) AS (SELECT SampleTime, SUM(ws1.wait_time_ms) FROM #WaitStats ws1 WHERE ws1.Pass = 1 GROUP BY SampleTime),
        waits2(SampleTime, waits_ms) AS (SELECT SampleTime, SUM(ws2.wait_time_ms) FROM #WaitStats ws2 WHERE ws2.Pass = 2 GROUP BY SampleTime),
        cores(cpu_count) AS (SELECT SUM(1) FROM sys.dm_os_schedulers WHERE status = 'VISIBLE ONLINE' AND is_online = 1)
        INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, URL, Details, DetailsInt)
        SELECT 19 AS CheckID,
            250 AS Priority,
            'Server Info' AS FindingGroup,
            'Wait Time per Core per Sec' AS Finding,
            'http://www.BrentOzar.com/go/measure' AS URL,
            CAST((waits2.waits_ms - waits1.waits_ms) / 1000 / i.cpu_count / DATEDIFF(ss, waits1.SampleTime, waits2.SampleTime) AS NVARCHAR(20)) AS Details,
            (waits2.waits_ms - waits1.waits_ms) / 1000 / i.cpu_count / DATEDIFF(ss, waits1.SampleTime, waits2.SampleTime) AS DetailsInt
        FROM cores i
          CROSS JOIN waits1
          CROSS JOIN waits2;
    END

    /* Server Performance - High CPU Utilization CheckID 24 */
    IF @Seconds &gt;= 30
        BEGIN
        /* If we're waiting 30+ seconds, run this check at the end.
           We get this data from the ring buffers, and it's only updated once per minute, so might
           as well get it now - whereas if we're checking 30+ seconds, it might get updated by the
           end of our sp_BlitzFirst session. */
        INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, Details, DetailsInt, URL)
        SELECT 24, 50, 'Server Performance', 'High CPU Utilization', CAST(100 - SystemIdle AS NVARCHAR(20)) + N'%. Ring buffer details: ' + CAST(record AS NVARCHAR(4000)), 100 - SystemIdle, 'http://www.BrentOzar.com/go/cpu'
            FROM (
                SELECT record,
                    record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') AS SystemIdle
                FROM (
                    SELECT TOP 1 CONVERT(XML, record) AS record
                    FROM sys.dm_os_ring_buffers
                    WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
                    AND record LIKE '%&lt;SystemHealth&gt;%'
                    ORDER BY timestamp DESC) AS rb
            ) AS y
            WHERE 100 - SystemIdle &gt;= 50

        INSERT INTO #BlitzFirstResults (CheckID, Priority, FindingsGroup, Finding, Details, DetailsInt, URL)
        SELECT 23, 250, 'Server Info', 'CPU Utilization', CAST(100 - SystemIdle AS NVARCHAR(20)) + N'%. Ring buffer details: ' + CAST(record AS NVARCHAR(4000)), 100 - SystemIdle, 'http://www.BrentOzar.com/go/cpu'
            FROM (
                SELECT record,
                    record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') AS SystemIdle
                FROM (
                    SELECT TOP 1 CONVERT(XML, record) AS record
                    FROM sys.dm_os_ring_buffers
                    WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR'
                    AND record LIKE '%&lt;SystemHealth&gt;%'
                    ORDER BY timestamp DESC) AS rb
            ) AS y

        END /* IF @Seconds &lt; 30 */

	RAISERROR('Analysis finished, outputting results',10,1) WITH NOWAIT;


    /* If we didn't find anything, apologize. */
    IF NOT EXISTS (SELECT * FROM #BlitzFirstResults WHERE Priority &lt; 250)
    BEGIN

        INSERT  INTO #BlitzFirstResults
                ( CheckID ,
                  Priority ,
                  FindingsGroup ,
                  Finding ,
                  URL ,
                  Details
                )
        VALUES  ( -1 ,
                  1 ,
                  'No Problems Found' ,
                  'From Your Community Volunteers' ,
                  'http://FirstResponderKit.org/' ,
                  'Try running our more in-depth checks with sp_Blitz, or there may not be an unusual SQL Server performance problem. '
                );

    END /*IF NOT EXISTS (SELECT * FROM #BlitzFirstResults) */

        /* Add credits for the nice folks who put so much time into building and maintaining this for free: */
        INSERT  INTO #BlitzFirstResults
                ( CheckID ,
                  Priority ,
                  FindingsGroup ,
                  Finding ,
                  URL ,
                  Details
                )
        VALUES  ( -1 ,
                  255 ,
                  'Thanks!' ,
                  'From Your Community Volunteers' ,
                  'http://FirstResponderKit.org/' ,
                  'To get help or add your own contributions, join us at http://FirstResponderKit.org.'
                );

        INSERT  INTO #BlitzFirstResults
                ( CheckID ,
                  Priority ,
                  FindingsGroup ,
                  Finding ,
                  URL ,
                  Details

                )
        VALUES  ( -1 ,
                  0 ,
                  'sp_BlitzFirst ' + CAST(CONVERT(DATETIMEOFFSET, @VersionDate, 102) AS VARCHAR(100)),
                  'From Your Community Volunteers' ,
                  'http://FirstResponderKit.org/' ,
                  'We hope you found this tool useful.'
                );

                /* Outdated sp_BlitzFirst - sp_BlitzFirst is Over 6 Months Old */
                IF DATEDIFF(MM, @VersionDate, SYSDATETIMEOFFSET()) &gt; 6
                    BEGIN
                        INSERT  INTO #BlitzFirstResults
                                ( CheckID ,
                                    Priority ,
                                    FindingsGroup ,
                                    Finding ,
                                    URL ,
                                    Details
                                )
                                SELECT 27 AS CheckID ,
                                        0 AS Priority ,
                                        'Outdated sp_BlitzFirst' AS FindingsGroup ,
                                        'sp_BlitzFirst is Over 6 Months Old' AS Finding ,
                                        'http://FirstResponderKit.org/' AS URL ,
                                        'Some things get better with age, like fine wine and your T-SQL. However, sp_BlitzFirst is not one of those things - time to go download the current one.' AS Details
                    END



    /* @OutputTableName lets us export the results to a permanent table */
    IF @OutputDatabaseName IS NOT NULL
        AND @OutputSchemaName IS NOT NULL
        AND @OutputTableName IS NOT NULL
        AND @OutputTableName NOT LIKE '#%'
        AND EXISTS ( SELECT *
                     FROM   sys.databases
                     WHERE  QUOTENAME([name]) = @OutputDatabaseName)
    BEGIN
        SET @StringToExecute = 'USE '
            + @OutputDatabaseName
            + '; IF EXISTS(SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
            + @OutputSchemaName
            + ''') AND NOT EXISTS (SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
            + @OutputSchemaName + ''' AND QUOTENAME(TABLE_NAME) = '''
            + @OutputTableName + ''') CREATE TABLE '
            + @OutputSchemaName + '.'
            + @OutputTableName
            + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                CheckID INT NOT NULL,
                Priority TINYINT NOT NULL,
                FindingsGroup VARCHAR(50) NOT NULL,
                Finding VARCHAR(200) NOT NULL,
                URL VARCHAR(200) NOT NULL,
                Details NVARCHAR(4000) NULL,
                HowToStopIt [XML] NULL,
                QueryPlan [XML] NULL,
                QueryText NVARCHAR(MAX) NULL,
                StartTime DATETIMEOFFSET NULL,
                LoginName NVARCHAR(128) NULL,
                NTUserName NVARCHAR(128) NULL,
                OriginalLoginName NVARCHAR(128) NULL,
                ProgramName NVARCHAR(128) NULL,
                HostName NVARCHAR(128) NULL,
                DatabaseID INT NULL,
                DatabaseName NVARCHAR(128) NULL,
                OpenTransactionCount INT NULL,
                DetailsInt INT NULL,
                CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'

        EXEC(@StringToExecute);
        SET @StringToExecute = N' IF EXISTS(SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
            + @OutputSchemaName + ''') INSERT '
            + @OutputDatabaseName + '.'
            + @OutputSchemaName + '.'
            + @OutputTableName
            + ' (ServerName, CheckDate, CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, OriginalLoginName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount, DetailsInt) SELECT '''
            + CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
            + ''', ''' + (CONVERT(NVARCHAR(100), @StartSampleTime, 127)) + ''', CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, OriginalLoginName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount, DetailsInt FROM #BlitzFirstResults ORDER BY Priority , FindingsGroup , Finding , Details';
        EXEC(@StringToExecute);
    END
    ELSE IF (SUBSTRING(@OutputTableName, 2, 2) = '##')
    BEGIN
        SET @StringToExecute = N' IF (OBJECT_ID(''tempdb..'
            + @OutputTableName
            + ''') IS NULL) CREATE TABLE '
            + @OutputTableName
            + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                CheckID INT NOT NULL,
                Priority TINYINT NOT NULL,
                FindingsGroup VARCHAR(50) NOT NULL,
                Finding VARCHAR(200) NOT NULL,
                URL VARCHAR(200) NOT NULL,
                Details NVARCHAR(4000) NULL,
                HowToStopIt [XML] NULL,
                QueryPlan [XML] NULL,
                QueryText NVARCHAR(MAX) NULL,
                StartTime DATETIMEOFFSET NULL,
                LoginName NVARCHAR(128) NULL,
                NTUserName NVARCHAR(128) NULL,
                OriginalLoginName NVARCHAR(128) NULL,
                ProgramName NVARCHAR(128) NULL,
                HostName NVARCHAR(128) NULL,
                DatabaseID INT NULL,
                DatabaseName NVARCHAR(128) NULL,
                OpenTransactionCount INT NULL,
                DetailsInt INT NULL,
                CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
            + ' INSERT '
            + @OutputTableName
            + ' (ServerName, CheckDate, CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, OriginalLoginName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount, DetailsInt) SELECT '''
            + CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
            + ''', ''' + CONVERT(NVARCHAR(100), @StartSampleTime, 127) + ''', CheckID, Priority, FindingsGroup, Finding, URL, Details, HowToStopIt, QueryPlan, QueryText, StartTime, LoginName, NTUserName, OriginalLoginName, ProgramName, HostName, DatabaseID, DatabaseName, OpenTransactionCount, DetailsInt FROM #BlitzFirstResults ORDER BY Priority , FindingsGroup , Finding , Details';
        EXEC(@StringToExecute);
    END
    ELSE IF (SUBSTRING(@OutputTableName, 2, 1) = '#')
    BEGIN
        RAISERROR('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0)
    END

    /* @OutputTableNameFileStats lets us export the results to a permanent table */
    IF @OutputDatabaseName IS NOT NULL
        AND @OutputSchemaName IS NOT NULL
        AND @OutputTableNameFileStats IS NOT NULL
        AND @OutputTableNameFileStats NOT LIKE '#%'
        AND EXISTS ( SELECT *
                     FROM   sys.databases
                     WHERE  QUOTENAME([name]) = @OutputDatabaseName)
    BEGIN
        /* Create the table */
        SET @StringToExecute = 'USE '
            + @OutputDatabaseName
            + '; IF EXISTS(SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
            + @OutputSchemaName
            + ''') AND NOT EXISTS (SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
            + @OutputSchemaName + ''' AND QUOTENAME(TABLE_NAME) = '''
            + @OutputTableNameFileStats + ''') CREATE TABLE '
            + @OutputSchemaName + '.'
            + @OutputTableNameFileStats
            + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                DatabaseID INT NOT NULL,
                FileID INT NOT NULL,
                DatabaseName NVARCHAR(256) ,
                FileLogicalName NVARCHAR(256) ,
                TypeDesc NVARCHAR(60) ,
                SizeOnDiskMB BIGINT ,
                io_stall_read_ms BIGINT ,
                num_of_reads BIGINT ,
                bytes_read BIGINT ,
                io_stall_write_ms BIGINT ,
                num_of_writes BIGINT ,
                bytes_written BIGINT,
                PhysicalName NVARCHAR(520) ,
                CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
        EXEC(@StringToExecute);

        /* Create the view */
        SET @ObjectFullName = @OutputDatabaseName + N'.' + @OutputSchemaName + N'.' +  @OutputTableNameFileStats_View;
        IF OBJECT_ID(@ObjectFullName) IS NULL
            BEGIN
            SET @StringToExecute = 'USE '
                + @OutputDatabaseName
                + '; EXEC (''CREATE VIEW '
                + @OutputSchemaName + '.'
                + @OutputTableNameFileStats_View + ' AS ' + @LineFeed
                + 'SELECT f.ServerName, f.CheckDate, f.DatabaseID, f.DatabaseName, f.FileID, f.FileLogicalName, f.TypeDesc, f.PhysicalName, f.SizeOnDiskMB' + @LineFeed
                + ', DATEDIFF(ss, fPrior.CheckDate, f.CheckDate) AS ElapsedSeconds' + @LineFeed
                + ', (f.SizeOnDiskMB - fPrior.SizeOnDiskMB) AS SizeOnDiskMBgrowth' + @LineFeed
                + ', (f.io_stall_read_ms - fPrior.io_stall_read_ms) AS io_stall_read_ms' + @LineFeed
                + ', io_stall_read_ms_average = CASE WHEN (f.num_of_reads - fPrior.num_of_reads) = 0 THEN 0 ELSE (f.io_stall_read_ms - fPrior.io_stall_read_ms) / (f.num_of_reads - fPrior.num_of_reads) END' + @LineFeed
                + ', (f.num_of_reads - fPrior.num_of_reads) AS num_of_reads' + @LineFeed
                + ', (f.bytes_read - fPrior.bytes_read) / 1024.0 / 1024.0 AS megabytes_read' + @LineFeed
                + ', (f.io_stall_write_ms - fPrior.io_stall_write_ms) AS io_stall_write_ms' + @LineFeed
                + ', io_stall_write_ms_average = CASE WHEN (f.num_of_writes - fPrior.num_of_writes) = 0 THEN 0 ELSE (f.io_stall_write_ms - fPrior.io_stall_write_ms) / (f.num_of_writes - fPrior.num_of_writes) END' + @LineFeed
                + ', (f.num_of_writes - fPrior.num_of_writes) AS num_of_writes' + @LineFeed
                + ', (f.bytes_written - fPrior.bytes_written) / 1024.0 / 1024.0 AS megabytes_written' + @LineFeed
                + 'FROM ' + @OutputSchemaName + '.' + @OutputTableNameFileStats + ' f' + @LineFeed
                + 'INNER JOIN ' + @OutputSchemaName + '.' + @OutputTableNameFileStats + ' fPrior ON f.ServerName = fPrior.ServerName AND f.DatabaseID = fPrior.DatabaseID AND f.FileID = fPrior.FileID AND f.CheckDate &gt; fPrior.CheckDate' + @LineFeed
                + 'LEFT OUTER JOIN ' + @OutputSchemaName + '.' + @OutputTableNameFileStats + ' fMiddle ON f.ServerName = fMiddle.ServerName AND f.DatabaseID = fMiddle.DatabaseID AND f.FileID = fMiddle.FileID AND f.CheckDate &gt; fMiddle.CheckDate AND fMiddle.CheckDate &gt; fPrior.CheckDate' + @LineFeed
                + 'WHERE fMiddle.ID IS NULL;'')'
            EXEC(@StringToExecute);
            END

        SET @StringToExecute = N' IF EXISTS(SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
            + @OutputSchemaName + ''') INSERT '
            + @OutputDatabaseName + '.'
            + @OutputSchemaName + '.'
            + @OutputTableNameFileStats
            + ' (ServerName, CheckDate, DatabaseID, FileID, DatabaseName, FileLogicalName, TypeDesc, SizeOnDiskMB, io_stall_read_ms, num_of_reads, bytes_read, io_stall_write_ms, num_of_writes, bytes_written, PhysicalName) SELECT '''
            + CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
            + ''', ''' + CONVERT(NVARCHAR(100), @StartSampleTime, 127) + ''', '
            + 'DatabaseID, FileID, DatabaseName, FileLogicalName, TypeDesc, SizeOnDiskMB, io_stall_read_ms, num_of_reads, bytes_read, io_stall_write_ms, num_of_writes, bytes_written, PhysicalName FROM #FileStats WHERE Pass = 2';
        EXEC(@StringToExecute);
    END
    ELSE IF (SUBSTRING(@OutputTableNameFileStats, 2, 2) = '##')
    BEGIN
        SET @StringToExecute = N' IF (OBJECT_ID(''tempdb..'
            + @OutputTableNameFileStats
            + ''') IS NULL) CREATE TABLE '
            + @OutputTableNameFileStats
            + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                DatabaseID INT NOT NULL,
                FileID INT NOT NULL,
                DatabaseName NVARCHAR(256) ,
                FileLogicalName NVARCHAR(256) ,
                TypeDesc NVARCHAR(60) ,
                SizeOnDiskMB BIGINT ,
                io_stall_read_ms BIGINT ,
                num_of_reads BIGINT ,
                bytes_read BIGINT ,
                io_stall_write_ms BIGINT ,
                num_of_writes BIGINT ,
                bytes_written BIGINT,
                PhysicalName NVARCHAR(520) ,
                DetailsInt INT NULL,
                CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
            + ' INSERT '
            + @OutputTableNameFileStats
            + ' (ServerName, CheckDate, DatabaseID, FileID, DatabaseName, FileLogicalName, TypeDesc, SizeOnDiskMB, io_stall_read_ms, num_of_reads, bytes_read, io_stall_write_ms, num_of_writes, bytes_written, PhysicalName) SELECT '''
            + CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
            + ''', ''' + CONVERT(NVARCHAR(100), @StartSampleTime, 127) + ''', '
            + 'DatabaseID, FileID, DatabaseName, FileLogicalName, TypeDesc, SizeOnDiskMB, io_stall_read_ms, num_of_reads, bytes_read, io_stall_write_ms, num_of_writes, bytes_written, PhysicalName FROM #FileStats WHERE Pass = 2';
        EXEC(@StringToExecute);
    END
    ELSE IF (SUBSTRING(@OutputTableNameFileStats, 2, 1) = '#')
    BEGIN
        RAISERROR('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0)
    END


    /* @OutputTableNamePerfmonStats lets us export the results to a permanent table */
    IF @OutputDatabaseName IS NOT NULL
        AND @OutputSchemaName IS NOT NULL
        AND @OutputTableNamePerfmonStats IS NOT NULL
        AND @OutputTableNamePerfmonStats NOT LIKE '#%'
        AND EXISTS ( SELECT *
                     FROM   sys.databases
                     WHERE  QUOTENAME([name]) = @OutputDatabaseName)
    BEGIN
        /* Create the table */
        SET @StringToExecute = 'USE '
            + @OutputDatabaseName
            + '; IF EXISTS(SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
            + @OutputSchemaName
            + ''') AND NOT EXISTS (SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
            + @OutputSchemaName + ''' AND QUOTENAME(TABLE_NAME) = '''
            + @OutputTableNamePerfmonStats + ''') CREATE TABLE '
            + @OutputSchemaName + '.'
            + @OutputTableNamePerfmonStats
            + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                [object_name] NVARCHAR(128) NOT NULL,
                [counter_name] NVARCHAR(128) NOT NULL,
                [instance_name] NVARCHAR(128) NULL,
                [cntr_value] BIGINT NULL,
                [cntr_type] INT NOT NULL,
                [value_delta] BIGINT NULL,
                [value_per_second] DECIMAL(18,2) NULL,
                CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
        EXEC(@StringToExecute);

        /* Create the view */
        SET @ObjectFullName = @OutputDatabaseName + N'.' + @OutputSchemaName + N'.' +  @OutputTableNamePerfmonStats_View;
        IF OBJECT_ID(@ObjectFullName) IS NULL
            BEGIN
            SET @StringToExecute = 'USE '
                + @OutputDatabaseName
                + '; EXEC (''CREATE VIEW '
                + @OutputSchemaName + '.'
                + @OutputTableNamePerfmonStats_View + ' AS ' + @LineFeed
                + 'SELECT p.ServerName, p.CheckDate, p.object_name, p.counter_name, p.instance_name' + @LineFeed
                + ', DATEDIFF(ss, pPrior.CheckDate, p.CheckDate) AS ElapsedSeconds' + @LineFeed
                + ', p.cntr_value' + @LineFeed
                + ', p.cntr_type' + @LineFeed
                + ', (p.cntr_value - pPrior.cntr_value) AS cntr_delta' + @LineFeed
                + 'FROM ' + @OutputSchemaName + '.' + @OutputTableNamePerfmonStats + ' p' + @LineFeed
                + 'INNER JOIN ' + @OutputSchemaName + '.' + @OutputTableNamePerfmonStats + ' pPrior ON p.ServerName = pPrior.ServerName AND p.object_name = pPrior.object_name AND p.counter_name = pPrior.counter_name AND p.instance_name = pPrior.instance_name AND p.CheckDate &gt; pPrior.CheckDate' + @LineFeed
                + 'LEFT OUTER JOIN ' + @OutputSchemaName + '.' + @OutputTableNamePerfmonStats + ' pMiddle ON p.ServerName = pMiddle.ServerName AND p.object_name = pMiddle.object_name AND p.counter_name = pMiddle.counter_name AND p.instance_name = pMiddle.instance_name AND p.CheckDate &gt; pMiddle.CheckDate AND pMiddle.CheckDate &gt; pPrior.CheckDate' + @LineFeed
                + 'WHERE pMiddle.ID IS NULL;'')'
            EXEC(@StringToExecute);
            END;

        SET @StringToExecute = N' IF EXISTS(SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
            + @OutputSchemaName + ''') INSERT '
            + @OutputDatabaseName + '.'
            + @OutputSchemaName + '.'
            + @OutputTableNamePerfmonStats
            + ' (ServerName, CheckDate, object_name, counter_name, instance_name, cntr_value, cntr_type, value_delta, value_per_second) SELECT '''
            + CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
            + ''', ''' + CONVERT(NVARCHAR(100), @StartSampleTime, 127) + ''', '
            + 'object_name, counter_name, instance_name, cntr_value, cntr_type, value_delta, value_per_second FROM #PerfmonStats WHERE Pass = 2';
        EXEC(@StringToExecute);

    END
    ELSE IF (SUBSTRING(@OutputTableNamePerfmonStats, 2, 2) = '##')
    BEGIN
        SET @StringToExecute = N' IF (OBJECT_ID(''tempdb..'
            + @OutputTableNamePerfmonStats
            + ''') IS NULL) CREATE TABLE '
            + @OutputTableNamePerfmonStats
            + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                [object_name] NVARCHAR(128) NOT NULL,
                [counter_name] NVARCHAR(128) NOT NULL,
                [instance_name] NVARCHAR(128) NULL,
                [cntr_value] BIGINT NULL,
                [cntr_type] INT NOT NULL,
                [value_delta] BIGINT NULL,
                [value_per_second] DECIMAL(18,2) NULL,
                CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
            + ' INSERT '
            + @OutputTableNamePerfmonStats
            + ' (ServerName, CheckDate, object_name, counter_name, instance_name, cntr_value, cntr_type, value_delta, value_per_second) SELECT '''
            + CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
            + ''', ''' + CONVERT(NVARCHAR(100), @StartSampleTime, 127) + ''', '
            + 'object_name, counter_name, instance_name, cntr_value, cntr_type, value_delta, value_per_second FROM #PerfmonStats WHERE Pass = 2';
        EXEC(@StringToExecute);
    END
    ELSE IF (SUBSTRING(@OutputTableNamePerfmonStats, 2, 1) = '#')
    BEGIN
        RAISERROR('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0)
    END


    /* @OutputTableNameWaitStats lets us export the results to a permanent table */
    IF @OutputDatabaseName IS NOT NULL
        AND @OutputSchemaName IS NOT NULL
        AND @OutputTableNameWaitStats IS NOT NULL
        AND @OutputTableNameWaitStats NOT LIKE '#%'
        AND EXISTS ( SELECT *
                     FROM   sys.databases
                     WHERE  QUOTENAME([name]) = @OutputDatabaseName)
    BEGIN
        /* Create the table */
        SET @StringToExecute = 'USE '
            + @OutputDatabaseName
            + '; IF EXISTS(SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
            + @OutputSchemaName
            + ''') AND NOT EXISTS (SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.TABLES WHERE QUOTENAME(TABLE_SCHEMA) = '''
            + @OutputSchemaName + ''' AND QUOTENAME(TABLE_NAME) = '''
            + @OutputTableNameWaitStats + ''') CREATE TABLE '
            + @OutputSchemaName + '.'
            + @OutputTableNameWaitStats
            + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                wait_type NVARCHAR(60),
                wait_time_ms BIGINT,
                signal_wait_time_ms BIGINT,
                waiting_tasks_count BIGINT ,
                CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
        EXEC(@StringToExecute);

        /* Create the view */
        SET @ObjectFullName = @OutputDatabaseName + N'.' + @OutputSchemaName + N'.' +  @OutputTableNameWaitStats_View;
        IF OBJECT_ID(@ObjectFullName) IS NULL
            BEGIN
            SET @StringToExecute = 'USE '
                + @OutputDatabaseName
                + '; EXEC (''CREATE VIEW '
                + @OutputSchemaName + '.'
                + @OutputTableNameWaitStats_View + ' AS ' + @LineFeed
                + 'SELECT w.ServerName, w.CheckDate, w.wait_type' + @LineFeed
                + ', DATEDIFF(ss, wPrior.CheckDate, w.CheckDate) AS ElapsedSeconds' + @LineFeed
                + ', (w.wait_time_ms - wPrior.wait_time_ms) AS wait_time_ms_delta' + @LineFeed
                + ', (w.signal_wait_time_ms - wPrior.signal_wait_time_ms) AS signal_wait_time_ms_delta' + @LineFeed
                + ', (w.waiting_tasks_count - wPrior.waiting_tasks_count) AS waiting_tasks_count_delta' + @LineFeed
                + 'FROM ' + @OutputSchemaName + '.' + @OutputTableNameWaitStats + ' w' + @LineFeed
                + 'INNER JOIN ' + @OutputSchemaName + '.' + @OutputTableNameWaitStats + ' wPrior ON w.ServerName = wPrior.ServerName AND w.wait_type = wPrior.wait_type AND w.CheckDate &gt; wPrior.CheckDate' + @LineFeed
                + 'LEFT OUTER JOIN ' + @OutputSchemaName + '.' + @OutputTableNameWaitStats + ' wMiddle ON w.ServerName = wMiddle.ServerName AND w.wait_type = wMiddle.wait_type AND w.CheckDate &gt; wMiddle.CheckDate AND wMiddle.CheckDate &gt; wPrior.CheckDate' + @LineFeed
                + 'WHERE wMiddle.ID IS NULL;'')'
            EXEC(@StringToExecute);
            END


        SET @StringToExecute = N' IF EXISTS(SELECT * FROM '
            + @OutputDatabaseName
            + '.INFORMATION_SCHEMA.SCHEMATA WHERE QUOTENAME(SCHEMA_NAME) = '''
            + @OutputSchemaName + ''') INSERT '
            + @OutputDatabaseName + '.'
            + @OutputSchemaName + '.'
            + @OutputTableNameWaitStats
            + ' (ServerName, CheckDate, wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count) SELECT '''
            + CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
            + ''', ''' + CONVERT(NVARCHAR(100), @StartSampleTime, 127) + ''', '
            + 'wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count FROM #WaitStats WHERE Pass = 2 AND wait_time_ms &gt; 0 AND waiting_tasks_count &gt; 0';
        EXEC(@StringToExecute);
    END
    ELSE IF (SUBSTRING(@OutputTableNameWaitStats, 2, 2) = '##')
    BEGIN
        SET @StringToExecute = N' IF (OBJECT_ID(''tempdb..'
            + @OutputTableNameWaitStats
            + ''') IS NULL) CREATE TABLE '
            + @OutputTableNameWaitStats
            + ' (ID INT IDENTITY(1,1) NOT NULL,
                ServerName NVARCHAR(128),
                CheckDate DATETIMEOFFSET,
                wait_type NVARCHAR(60),
                wait_time_ms BIGINT,
                signal_wait_time_ms BIGINT,
                waiting_tasks_count BIGINT ,
                CONSTRAINT [PK_' + CAST(NEWID() AS CHAR(36)) + '] PRIMARY KEY CLUSTERED (ID ASC));'
            + ' INSERT '
            + @OutputTableNameWaitStats
            + ' (ServerName, CheckDate, wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count) SELECT '''
            + CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128))
            + ''', ''' + CONVERT(NVARCHAR(100), @StartSampleTime, 127) + ''', '
            + 'wait_type, wait_time_ms, signal_wait_time_ms, waiting_tasks_count FROM #WaitStats WHERE Pass = 2 AND wait_time_ms &gt; 0 AND waiting_tasks_count &gt; 0';
        EXEC(@StringToExecute);
    END
    ELSE IF (SUBSTRING(@OutputTableNameWaitStats, 2, 1) = '#')
    BEGIN
        RAISERROR('Due to the nature of Dymamic SQL, only global (i.e. double pound (##)) temp tables are supported for @OutputTableName', 16, 0)
    END




    DECLARE @separator AS VARCHAR(1);
    IF @OutputType = 'RSV'
        SET @separator = CHAR(31);
    ELSE
        SET @separator = ',';

    IF @OutputType = 'COUNT' AND @SinceStartup = 0
    BEGIN
        SELECT  COUNT(*) AS Warnings
        FROM    #BlitzFirstResults
    END
    ELSE
        IF @OutputType = 'Opserver1' AND @SinceStartup = 0
        BEGIN

            SELECT  r.[Priority] ,
                    r.[FindingsGroup] ,
                    r.[Finding] ,
                    r.[URL] ,
                    r.[Details],
                    r.[HowToStopIt] ,
                    r.[CheckID] ,
                    r.[StartTime],
                    r.[LoginName],
                    r.[NTUserName],
                    r.[OriginalLoginName],
                    r.[ProgramName],
                    r.[HostName],
                    r.[DatabaseID],
                    r.[DatabaseName],
                    r.[OpenTransactionCount],
                    r.[QueryPlan],
                    r.[QueryText],
                    qsNow.plan_handle AS PlanHandle,
                    qsNow.sql_handle AS SqlHandle,
                    qsNow.statement_start_offset AS StatementStartOffset,
                    qsNow.statement_end_offset AS StatementEndOffset,
                    [Executions] = qsNow.execution_count - (COALESCE(qsFirst.execution_count, 0)),
                    [ExecutionsPercent] = CAST(100.0 * (qsNow.execution_count - (COALESCE(qsFirst.execution_count, 0))) / (qsTotal.execution_count - qsTotalFirst.execution_count) AS DECIMAL(6,2)),
                    [Duration] = qsNow.total_elapsed_time - (COALESCE(qsFirst.total_elapsed_time, 0)),
                    [DurationPercent] = CAST(100.0 * (qsNow.total_elapsed_time - (COALESCE(qsFirst.total_elapsed_time, 0))) / (qsTotal.total_elapsed_time - qsTotalFirst.total_elapsed_time) AS DECIMAL(6,2)),
                    [CPU] = qsNow.total_worker_time - (COALESCE(qsFirst.total_worker_time, 0)),
                    [CPUPercent] = CAST(100.0 * (qsNow.total_worker_time - (COALESCE(qsFirst.total_worker_time, 0))) / (qsTotal.total_worker_time - qsTotalFirst.total_worker_time) AS DECIMAL(6,2)),
                    [Reads] = qsNow.total_logical_reads - (COALESCE(qsFirst.total_logical_reads, 0)),
                    [ReadsPercent] = CAST(100.0 * (qsNow.total_logical_reads - (COALESCE(qsFirst.total_logical_reads, 0))) / (qsTotal.total_logical_reads - qsTotalFirst.total_logical_reads) AS DECIMAL(6,2)),
                    [PlanCreationTime] = CONVERT(NVARCHAR(100), qsNow.creation_time ,121),
                    [TotalExecutions] = qsNow.execution_count,
                    [TotalExecutionsPercent] = CAST(100.0 * qsNow.execution_count / qsTotal.execution_count AS DECIMAL(6,2)),
                    [TotalDuration] = qsNow.total_elapsed_time,
                    [TotalDurationPercent] = CAST(100.0 * qsNow.total_elapsed_time / qsTotal.total_elapsed_time AS DECIMAL(6,2)),
                    [TotalCPU] = qsNow.total_worker_time,
                    [TotalCPUPercent] = CAST(100.0 * qsNow.total_worker_time / qsTotal.total_worker_time AS DECIMAL(6,2)),
                    [TotalReads] = qsNow.total_logical_reads,
                    [TotalReadsPercent] = CAST(100.0 * qsNow.total_logical_reads / qsTotal.total_logical_reads AS DECIMAL(6,2)),
                    r.[DetailsInt]
            FROM    #BlitzFirstResults r
                LEFT OUTER JOIN #QueryStats qsTotal ON qsTotal.Pass = 0
                LEFT OUTER JOIN #QueryStats qsTotalFirst ON qsTotalFirst.Pass = -1
                LEFT OUTER JOIN #QueryStats qsNow ON r.QueryStatsNowID = qsNow.ID
                LEFT OUTER JOIN #QueryStats qsFirst ON r.QueryStatsFirstID = qsFirst.ID
            ORDER BY r.Priority ,
                    r.FindingsGroup ,
                    CASE
                        WHEN r.CheckID = 6 THEN DetailsInt
                        ELSE 0
                    END DESC,
                    r.Finding,
                    r.ID;
        END
        ELSE IF @OutputType IN ( 'CSV', 'RSV' ) AND @SinceStartup = 0
        BEGIN

            SELECT  Result = CAST([Priority] AS NVARCHAR(100))
                    + @separator + CAST(CheckID AS NVARCHAR(100))
                    + @separator + COALESCE([FindingsGroup],
                                            '(N/A)') + @separator
                    + COALESCE([Finding], '(N/A)') + @separator
                    + COALESCE(DatabaseName, '(N/A)') + @separator
                    + COALESCE([URL], '(N/A)') + @separator
                    + COALESCE([Details], '(N/A)')
            FROM    #BlitzFirstResults
            ORDER BY Priority ,
                    FindingsGroup ,
                    CASE
                        WHEN CheckID = 6 THEN DetailsInt
                        ELSE 0
                    END DESC,
                    Finding,
                    Details;
        END
        ELSE IF @ExpertMode = 0 AND @OutputXMLasNVARCHAR = 0 AND @SinceStartup = 0
        BEGIN
            SELECT  [Priority] ,
                    [FindingsGroup] ,
                    [Finding] ,
                    [URL] ,
                    CAST(@StockDetailsHeader + [Details] + @StockDetailsFooter AS XML) AS Details,
                    CAST(@StockWarningHeader + HowToStopIt + @StockWarningFooter AS XML) AS HowToStopIt,
                    [QueryText],
                    [QueryPlan]
            FROM    #BlitzFirstResults
            WHERE (@Seconds &gt; 0 OR (Priority IN (0, 250, 251, 255))) /* For @Seconds = 0, filter out broken checks for now */
            ORDER BY Priority ,
                    FindingsGroup ,
                    CASE
                        WHEN CheckID = 6 THEN DetailsInt
                        ELSE 0
                    END DESC,
                    Finding,
                    ID;
        END
        ELSE IF @ExpertMode = 0 AND @OutputXMLasNVARCHAR = 1 AND @SinceStartup = 0
        BEGIN
            SELECT  [Priority] ,
                    [FindingsGroup] ,
                    [Finding] ,
                    [URL] ,
                    CAST(@StockDetailsHeader + [Details] + @StockDetailsFooter AS NVARCHAR(MAX)) AS Details,
                    CAST([HowToStopIt] AS NVARCHAR(MAX)) AS HowToStopIt,
                    CAST([QueryText] AS NVARCHAR(MAX)) AS QueryText,
                    CAST([QueryPlan] AS NVARCHAR(MAX)) AS QueryPlan
            FROM    #BlitzFirstResults
            WHERE (@Seconds &gt; 0 OR (Priority IN (0, 250, 251, 255))) /* For @Seconds = 0, filter out broken checks for now */
            ORDER BY Priority ,
                    FindingsGroup ,
                    CASE
                        WHEN CheckID = 6 THEN DetailsInt
                        ELSE 0
                    END DESC,
                    Finding,
                    ID;
        END
        ELSE IF @ExpertMode = 1
        BEGIN
            IF @SinceStartup = 0
                SELECT  r.[Priority] ,
                        r.[FindingsGroup] ,
                        r.[Finding] ,
                        r.[URL] ,
                        CAST(@StockDetailsHeader + r.[Details] + @StockDetailsFooter AS XML) AS Details,
                        CAST(@StockWarningHeader + r.HowToStopIt + @StockWarningFooter AS XML) AS HowToStopIt,
                        r.[CheckID] ,
                        r.[StartTime],
                        r.[LoginName],
                        r.[NTUserName],
                        r.[OriginalLoginName],
                        r.[ProgramName],
                        r.[HostName],
                        r.[DatabaseID],
                        r.[DatabaseName],
                        r.[OpenTransactionCount],
                        r.[QueryPlan],
                        r.[QueryText],
                        qsNow.plan_handle AS PlanHandle,
                        qsNow.sql_handle AS SqlHandle,
                        qsNow.statement_start_offset AS StatementStartOffset,
                        qsNow.statement_end_offset AS StatementEndOffset,
                        [Executions] = qsNow.execution_count - (COALESCE(qsFirst.execution_count, 0)),
                        [ExecutionsPercent] = CAST(100.0 * (qsNow.execution_count - (COALESCE(qsFirst.execution_count, 0))) / (qsTotal.execution_count - qsTotalFirst.execution_count) AS DECIMAL(6,2)),
                        [Duration] = qsNow.total_elapsed_time - (COALESCE(qsFirst.total_elapsed_time, 0)),
                        [DurationPercent] = CAST(100.0 * (qsNow.total_elapsed_time - (COALESCE(qsFirst.total_elapsed_time, 0))) / (qsTotal.total_elapsed_time - qsTotalFirst.total_elapsed_time) AS DECIMAL(6,2)),
                        [CPU] = qsNow.total_worker_time - (COALESCE(qsFirst.total_worker_time, 0)),
                        [CPUPercent] = CAST(100.0 * (qsNow.total_worker_time - (COALESCE(qsFirst.total_worker_time, 0))) / (qsTotal.total_worker_time - qsTotalFirst.total_worker_time) AS DECIMAL(6,2)),
                        [Reads] = qsNow.total_logical_reads - (COALESCE(qsFirst.total_logical_reads, 0)),
                        [ReadsPercent] = CAST(100.0 * (qsNow.total_logical_reads - (COALESCE(qsFirst.total_logical_reads, 0))) / (qsTotal.total_logical_reads - qsTotalFirst.total_logical_reads) AS DECIMAL(6,2)),
                        [PlanCreationTime] = CONVERT(NVARCHAR(100), qsNow.creation_time ,121),
                        [TotalExecutions] = qsNow.execution_count,
                        [TotalExecutionsPercent] = CAST(100.0 * qsNow.execution_count / qsTotal.execution_count AS DECIMAL(6,2)),
                        [TotalDuration] = qsNow.total_elapsed_time,
                        [TotalDurationPercent] = CAST(100.0 * qsNow.total_elapsed_time / qsTotal.total_elapsed_time AS DECIMAL(6,2)),
                        [TotalCPU] = qsNow.total_worker_time,
                        [TotalCPUPercent] = CAST(100.0 * qsNow.total_worker_time / qsTotal.total_worker_time AS DECIMAL(6,2)),
                        [TotalReads] = qsNow.total_logical_reads,
                        [TotalReadsPercent] = CAST(100.0 * qsNow.total_logical_reads / qsTotal.total_logical_reads AS DECIMAL(6,2)),
                        r.[DetailsInt]
                FROM    #BlitzFirstResults r
                    LEFT OUTER JOIN #QueryStats qsTotal ON qsTotal.Pass = 0
                    LEFT OUTER JOIN #QueryStats qsTotalFirst ON qsTotalFirst.Pass = -1
                    LEFT OUTER JOIN #QueryStats qsNow ON r.QueryStatsNowID = qsNow.ID
                    LEFT OUTER JOIN #QueryStats qsFirst ON r.QueryStatsFirstID = qsFirst.ID
                WHERE (@Seconds &gt; 0 OR (Priority IN (0, 250, 251, 255))) /* For @Seconds = 0, filter out broken checks for now */
                ORDER BY r.Priority ,
                        r.FindingsGroup ,
                        CASE
                            WHEN r.CheckID = 6 THEN DetailsInt
                            ELSE 0
                        END DESC,
                        r.Finding,
                        r.ID;

            -------------------------
            --What happened: #WaitStats
            -------------------------
            IF @Seconds = 0
                BEGIN
                /* Measure waits in hours */
                ;WITH max_batch AS (
                    SELECT MAX(SampleTime) AS SampleTime
                    FROM #WaitStats
                )
                SELECT
                    'WAIT STATS' AS Pattern,
                    b.SampleTime AS [Sample Ended],
                    CAST(DATEDIFF(mi,wd1.SampleTime, wd2.SampleTime) / 60.0 AS DECIMAL(18,1)) AS [Hours Sample],
                    wd1.wait_type,
                    CAST(c.[Wait Time (Seconds)] / 60.0 / 60 AS DECIMAL(18,1)) AS [Wait Time (Hours)],
                    CAST((wd2.wait_time_ms - wd1.wait_time_ms) / 1000.0 / 60 / 60 / cores.cpu_count / DATEDIFF(ss, wd1.SampleTime, wd2.SampleTime) AS DECIMAL(18,1)) AS [Per Core Per Hour],
                    CAST(c.[Signal Wait Time (Seconds)] / 60.0 / 60 AS DECIMAL(18,1)) AS [Signal Wait Time (Hours)],
                    CASE WHEN c.[Wait Time (Seconds)] &gt; 0
                     THEN CAST(100.*(c.[Signal Wait Time (Seconds)]/c.[Wait Time (Seconds)]) AS NUMERIC(4,1))
                    ELSE 0 END AS [Percent Signal Waits],
                    (wd2.waiting_tasks_count - wd1.waiting_tasks_count) AS [Number of Waits],
                    CASE WHEN (wd2.waiting_tasks_count - wd1.waiting_tasks_count) &gt; 0
                    THEN
                        CAST((wd2.wait_time_ms-wd1.wait_time_ms)/
                            (1.0*(wd2.waiting_tasks_count - wd1.waiting_tasks_count)) AS NUMERIC(12,1))
                    ELSE 0 END AS [Avg ms Per Wait],
                    N'http://www.brentozar.com/sql/wait-stats/#' + wd1.wait_type AS URL
                FROM  max_batch b
                JOIN #WaitStats wd2 ON
                    wd2.SampleTime =b.SampleTime
                JOIN #WaitStats wd1 ON
                    wd1.wait_type=wd2.wait_type AND
                    wd2.SampleTime &gt; wd1.SampleTime
                CROSS APPLY (SELECT SUM(1) AS cpu_count FROM sys.dm_os_schedulers WHERE status = 'VISIBLE ONLINE' AND is_online = 1) AS cores
                CROSS APPLY (SELECT
                    CAST((wd2.wait_time_ms-wd1.wait_time_ms)/1000. AS NUMERIC(12,1)) AS [Wait Time (Seconds)],
                    CAST((wd2.signal_wait_time_ms - wd1.signal_wait_time_ms)/1000. AS NUMERIC(12,1)) AS [Signal Wait Time (Seconds)]) AS c
                WHERE (wd2.waiting_tasks_count - wd1.waiting_tasks_count) &gt; 0
                    AND wd2.wait_time_ms-wd1.wait_time_ms &gt; 0
                ORDER BY [Wait Time (Seconds)] DESC;
                END
            ELSE
                BEGIN
                /* Measure waits in seconds */
                ;WITH max_batch AS (
                    SELECT MAX(SampleTime) AS SampleTime
                    FROM #WaitStats
                )
                SELECT
                    'WAIT STATS' AS Pattern,
                    b.SampleTime AS [Sample Ended],
                    DATEDIFF(ss,wd1.SampleTime, wd2.SampleTime) AS [Seconds Sample],
                    wd1.wait_type,
                    c.[Wait Time (Seconds)],
                    CAST((wd2.wait_time_ms - wd1.wait_time_ms) / 1000.0 / cores.cpu_count / DATEDIFF(ss, wd1.SampleTime, wd2.SampleTime) AS DECIMAL(18,1)) AS [Per Core Per Second],
                    c.[Signal Wait Time (Seconds)],
                    CASE WHEN c.[Wait Time (Seconds)] &gt; 0
                     THEN CAST(100.*(c.[Signal Wait Time (Seconds)]/c.[Wait Time (Seconds)]) AS NUMERIC(4,1))
                    ELSE 0 END AS [Percent Signal Waits],
                    (wd2.waiting_tasks_count - wd1.waiting_tasks_count) AS [Number of Waits],
                    CASE WHEN (wd2.waiting_tasks_count - wd1.waiting_tasks_count) &gt; 0
                    THEN
                        CAST((wd2.wait_time_ms-wd1.wait_time_ms)/
                            (1.0*(wd2.waiting_tasks_count - wd1.waiting_tasks_count)) AS NUMERIC(12,1))
                    ELSE 0 END AS [Avg ms Per Wait],
                    N'http://www.brentozar.com/sql/wait-stats/#' + wd1.wait_type AS URL
                FROM  max_batch b
                JOIN #WaitStats wd2 ON
                    wd2.SampleTime =b.SampleTime
                JOIN #WaitStats wd1 ON
                    wd1.wait_type=wd2.wait_type AND
                    wd2.SampleTime &gt; wd1.SampleTime
                CROSS APPLY (SELECT SUM(1) AS cpu_count FROM sys.dm_os_schedulers WHERE status = 'VISIBLE ONLINE' AND is_online = 1) AS cores
                CROSS APPLY (SELECT
                    CAST((wd2.wait_time_ms-wd1.wait_time_ms)/1000. AS NUMERIC(12,1)) AS [Wait Time (Seconds)],
                    CAST((wd2.signal_wait_time_ms - wd1.signal_wait_time_ms)/1000. AS NUMERIC(12,1)) AS [Signal Wait Time (Seconds)]) AS c
                WHERE (wd2.waiting_tasks_count - wd1.waiting_tasks_count) &gt; 0
                    AND wd2.wait_time_ms-wd1.wait_time_ms &gt; 0
                ORDER BY [Wait Time (Seconds)] DESC;
                END;

            -------------------------
            --What happened: #FileStats
            -------------------------
            WITH readstats AS (
                SELECT 'PHYSICAL READS' AS Pattern,
                ROW_NUMBER() OVER (ORDER BY wd2.avg_stall_read_ms DESC) AS StallRank,
                wd2.SampleTime AS [Sample Time],
                DATEDIFF(ss,wd1.SampleTime, wd2.SampleTime) AS [Sample (seconds)],
                wd1.DatabaseName ,
                wd1.FileLogicalName AS [File Name],
                UPPER(SUBSTRING(wd1.PhysicalName, 1, 2)) AS [Drive] ,
                wd1.SizeOnDiskMB ,
                ( wd2.num_of_reads - wd1.num_of_reads ) AS [# Reads/Writes],
                CASE WHEN wd2.num_of_reads - wd1.num_of_reads &gt; 0
                  THEN CAST(( wd2.bytes_read - wd1.bytes_read)/1024./1024. AS NUMERIC(21,1))
                  ELSE 0
                END AS [MB Read/Written],
                wd2.avg_stall_read_ms AS [Avg Stall (ms)],
                wd1.PhysicalName AS [file physical name]
            FROM #FileStats wd2
                JOIN #FileStats wd1 ON wd2.SampleTime &gt; wd1.SampleTime
                  AND wd1.DatabaseID = wd2.DatabaseID
                  AND wd1.FileID = wd2.FileID
            ),
            writestats AS (
                SELECT
                'PHYSICAL WRITES' AS Pattern,
                ROW_NUMBER() OVER (ORDER BY wd2.avg_stall_write_ms DESC) AS StallRank,
                wd2.SampleTime AS [Sample Time],
                DATEDIFF(ss,wd1.SampleTime, wd2.SampleTime) AS [Sample (seconds)],
                wd1.DatabaseName ,
                wd1.FileLogicalName AS [File Name],
                UPPER(SUBSTRING(wd1.PhysicalName, 1, 2)) AS [Drive] ,
                wd1.SizeOnDiskMB ,
                ( wd2.num_of_writes - wd1.num_of_writes ) AS [# Reads/Writes],
                CASE WHEN wd2.num_of_writes - wd1.num_of_writes &gt; 0
                  THEN CAST(( wd2.bytes_written - wd1.bytes_written)/1024./1024. AS NUMERIC(21,1))
                  ELSE 0
                END AS [MB Read/Written],
                wd2.avg_stall_write_ms AS [Avg Stall (ms)],
                wd1.PhysicalName AS [file physical name]
            FROM #FileStats wd2
                JOIN #FileStats wd1 ON wd2.SampleTime &gt; wd1.SampleTime
                  AND wd1.DatabaseID = wd2.DatabaseID
                  AND wd1.FileID = wd2.FileID
            )
            SELECT
                Pattern, [Sample Time], [Sample (seconds)], [File Name], [Drive],  [# Reads/Writes],[MB Read/Written],[Avg Stall (ms)], [file physical name]
            FROM readstats
            WHERE StallRank &lt;=5 AND [MB Read/Written] &gt; 0
            UNION ALL
            SELECT Pattern, [Sample Time], [Sample (seconds)], [File Name], [Drive],  [# Reads/Writes],[MB Read/Written],[Avg Stall (ms)], [file physical name]
            FROM writestats
            WHERE StallRank &lt;=5 AND [MB Read/Written] &gt; 0;


            -------------------------
            --What happened: #PerfmonStats
            -------------------------

            SELECT 'PERFMON' AS Pattern, pLast.[object_name], pLast.counter_name, pLast.instance_name,
                pFirst.SampleTime AS FirstSampleTime, pFirst.cntr_value AS FirstSampleValue,
                pLast.SampleTime AS LastSampleTime, pLast.cntr_value AS LastSampleValue,
                pLast.cntr_value - pFirst.cntr_value AS ValueDelta,
                ((1.0 * pLast.cntr_value - pFirst.cntr_value) / DATEDIFF(ss, pFirst.SampleTime, pLast.SampleTime)) AS ValuePerSecond
                FROM #PerfmonStats pLast
                    INNER JOIN #PerfmonStats pFirst ON pFirst.[object_name] = pLast.[object_name] AND pFirst.counter_name = pLast.counter_name AND (pFirst.instance_name = pLast.instance_name OR (pFirst.instance_name IS NULL AND pLast.instance_name IS NULL))
                    AND pLast.ID &gt; pFirst.ID
				WHERE (pLast.cntr_value - pFirst.cntr_value) &gt; 0
                ORDER BY Pattern, pLast.[object_name], pLast.counter_name, pLast.instance_name


            -------------------------
            --What happened: #FileStats
            -------------------------
            SELECT
                [qsNow].[ID] AS [Now-ID],
                [qsNow].[Pass] AS [Now-Pass],
                [qsNow].[SampleTime] AS [Now-SampleTime],
                [qsNow].[sql_handle] AS [Now-sql_handle],
                [qsNow].[statement_start_offset] AS [Now-statement_start_offset],
                [qsNow].[statement_end_offset] AS [Now-statement_end_offset],
                [qsNow].[plan_generation_num] AS [Now-plan_generation_num],
                [qsNow].[plan_handle] AS [Now-plan_handle],
                [qsNow].[execution_count] AS [Now-execution_count],
                [qsNow].[total_worker_time] AS [Now-total_worker_time],
                [qsNow].[total_physical_reads] AS [Now-total_physical_reads],
                [qsNow].[total_logical_writes] AS [Now-total_logical_writes],
                [qsNow].[total_logical_reads] AS [Now-total_logical_reads],
                [qsNow].[total_clr_time] AS [Now-total_clr_time],
                [qsNow].[total_elapsed_time] AS [Now-total_elapsed_time],
                [qsNow].[creation_time] AS [Now-creation_time],
                [qsNow].[query_hash] AS [Now-query_hash],
                [qsNow].[query_plan_hash] AS [Now-query_plan_hash],
                [qsNow].[Points] AS [Now-Points],
                [qsFirst].[ID] AS [First-ID],
                [qsFirst].[Pass] AS [First-Pass],
                [qsFirst].[SampleTime] AS [First-SampleTime],
                [qsFirst].[sql_handle] AS [First-sql_handle],
                [qsFirst].[statement_start_offset] AS [First-statement_start_offset],
                [qsFirst].[statement_end_offset] AS [First-statement_end_offset],
                [qsFirst].[plan_generation_num] AS [First-plan_generation_num],
                [qsFirst].[plan_handle] AS [First-plan_handle],
                [qsFirst].[execution_count] AS [First-execution_count],
                [qsFirst].[total_worker_time] AS [First-total_worker_time],
                [qsFirst].[total_physical_reads] AS [First-total_physical_reads],
                [qsFirst].[total_logical_writes] AS [First-total_logical_writes],
                [qsFirst].[total_logical_reads] AS [First-total_logical_reads],
                [qsFirst].[total_clr_time] AS [First-total_clr_time],
                [qsFirst].[total_elapsed_time] AS [First-total_elapsed_time],
                [qsFirst].[creation_time] AS [First-creation_time],
                [qsFirst].[query_hash] AS [First-query_hash],
                [qsFirst].[query_plan_hash] AS [First-query_plan_hash],
                [qsFirst].[Points] AS [First-Points]
            FROM #QueryStats qsNow
              INNER JOIN #QueryStats qsFirst ON qsNow.[sql_handle] = qsFirst.[sql_handle] AND qsNow.statement_start_offset = qsFirst.statement_start_offset AND qsNow.statement_end_offset = qsFirst.statement_end_offset AND qsNow.plan_generation_num = qsFirst.plan_generation_num AND qsNow.plan_handle = qsFirst.plan_handle AND qsFirst.Pass = 1
            WHERE qsNow.Pass = 2
        END

    DROP TABLE #BlitzFirstResults;

    /* What's running right now? This is the first and last result set. */
    IF @SinceStartup = 0 AND @Seconds &gt; 0 AND @ExpertMode = 1 
    BEGIN
		IF OBJECT_ID('dbo.sp_BlitzWho') IS NOT NULL
		BEGIN
			EXEC [dbo].[sp_BlitzWho]
		END
    END /* IF @SinceStartup = 0 AND @Seconds &gt; 0 AND @ExpertMode = 1   -   What's running right now? This is the first and last result set. */

END /* IF @Question IS NULL */
ELSE IF @Question IS NOT NULL

/* We're playing Magic SQL 8 Ball, so give them an answer. */
BEGIN
    IF OBJECT_ID('tempdb..#BlitzFirstAnswers') IS NOT NULL
        DROP TABLE #BlitzFirstAnswers;
    CREATE TABLE #BlitzFirstAnswers(Answer VARCHAR(200) NOT NULL);
    INSERT INTO #BlitzFirstAnswers VALUES ('It sounds like a SAN problem.');
    INSERT INTO #BlitzFirstAnswers VALUES ('You know what you need? Bacon.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Talk to the developers about that.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Let''s post that on StackOverflow.com and find out.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Have you tried adding an index?');
    INSERT INTO #BlitzFirstAnswers VALUES ('Have you tried dropping an index?');
    INSERT INTO #BlitzFirstAnswers VALUES ('You can''t prove anything.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Please phrase the question in the form of an answer.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Outlook not so good. Access even worse.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Did you try asking the rubber duck? http://www.codinghorror.com/blog/2012/03/rubber-duck-problem-solving.html');
    INSERT INTO #BlitzFirstAnswers VALUES ('Oooo, I read about that once.');
    INSERT INTO #BlitzFirstAnswers VALUES ('I feel your pain.');
    INSERT INTO #BlitzFirstAnswers VALUES ('http://LMGTFY.com');
    INSERT INTO #BlitzFirstAnswers VALUES ('No comprende Ingles, senor.');
    INSERT INTO #BlitzFirstAnswers VALUES ('I don''t have that problem on my Mac.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Is Priority Boost on?');
    INSERT INTO #BlitzFirstAnswers VALUES ('Have you tried rebooting your machine?');
    INSERT INTO #BlitzFirstAnswers VALUES ('Try defragging your cursors.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Why are you wearing that? Do you have a job interview later or something?');
    INSERT INTO #BlitzFirstAnswers VALUES ('I''m ashamed that you don''t know the answer to that question.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Duh, Debra.');
    INSERT INTO #BlitzFirstAnswers VALUES ('Have you tried restoring TempDB?');
    SELECT TOP 1 Answer FROM #BlitzFirstAnswers ORDER BY NEWID();
END

END /* ELSE IF @OutputType = 'SCHEMA' */

SET NOCOUNT OFF;
GO



/* How to run it:
EXEC dbo.sp_BlitzFirst

With extra diagnostic info:
EXEC dbo.sp_BlitzFirst @ExpertMode = 1;

In Ask a Question mode:
EXEC dbo.sp_BlitzFirst 'Is this cursor bad?';

Saving output to tables:
EXEC sp_BlitzFirst @Seconds = 60
, @OutputDatabaseName = 'DBAtools'
, @OutputSchemaName = 'dbo'
, @OutputTableName = 'BlitzFirstResults'
, @OutputTableNameFileStats = 'BlitzFirstResults_FileStats'
, @OutputTableNamePerfmonStats = 'BlitzFirstResults_PerfmonStats'
, @OutputTableNameWaitStats = 'BlitzFirstResults_WaitStats'
*/</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>sp_BlitzIndex____script</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>sp_BlitzIndex____script</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>SET ANSI_NULLS ON;
SET ANSI_PADDING ON;
SET ANSI_WARNINGS ON;
SET ARITHABORT ON;
SET CONCAT_NULL_YIELDS_NULL ON;
SET QUOTED_IDENTIFIER ON;
SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;
GO

IF OBJECT_ID('dbo.sp_BlitzIndex') IS NULL
  EXEC ('CREATE PROCEDURE dbo.sp_BlitzIndex AS RETURN 0;')
GO

ALTER PROCEDURE dbo.sp_BlitzIndex
    @DatabaseName NVARCHAR(128) = NULL, /*Defaults to current DB if not specified*/
    @SchemaName NVARCHAR(128) = NULL, /*Requires table_name as well.*/
    @TableName NVARCHAR(128) = NULL,  /*Requires schema_name as well.*/
    @Mode TINYINT=0, /*0=Diagnose, 1=Summarize, 2=Index Usage Detail, 3=Missing Index Detail, 4=Diagnose Details*/
        /*Note:@Mode doesn't matter if you're specifying schema_name and @TableName.*/
    @Filter TINYINT = 0, /* 0=no filter (default). 1=No low-usage warnings for objects with 0 reads. 2=Only warn for objects &gt;= 500MB */
        /*Note:@Filter doesn't do anything unless @Mode=0*/
	@SkipPartitions BIT	= 0,
	@SkipStatistics BIT	= 1,
    @GetAllDatabases BIT = 0,
    @BringThePain BIT = 0,
    @ThresholdMB INT = 250 /* Number of megabytes that an object must be before we include it in basic results */,
    @OutputServerName NVARCHAR(256) = NULL ,
    @OutputDatabaseName NVARCHAR(256) = NULL ,
    @OutputSchemaName NVARCHAR(256) = NULL ,
    @OutputTableName NVARCHAR(256) = NULL ,
	@Help TINYINT = 0,
	@VersionDate DATETIME = NULL OUTPUT
WITH RECOMPILE
AS
SET NOCOUNT ON;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
DECLARE @Version VARCHAR(30);
SET @Version = '4.6';
SET @VersionDate = '20161210';
IF @Help = 1 PRINT '
/*
sp_BlitzIndex from http://FirstResponderKit.org
	
This script analyzes the design and performance of your indexes.

To learn more, visit http://FirstResponderKit.org where you can download new
versions for free, watch training videos on how it works, get more info on
the findings, contribute your own code, and more.

Known limitations of this version:
 - Only Microsoft-supported versions of SQL Server. Sorry, 2005 and 2000.
 - The @OutputDatabaseName parameters are not functional yet. To check the
   status of this enhancement request, visit:
   https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/issues/221
 - Does not analyze columnstore, spatial, XML, or full text indexes. If you
   would like to contribute code to analyze those, head over to Github and
   check out the issues list: http://FirstResponderKit.org
 - Index create statements are just to give you a rough idea of the syntax. It includes filters and fillfactor.
 --        Example 1: index creates use ONLINE=? instead of ONLINE=ON / ONLINE=OFF. This is because it is important 
           for the user to understand if it is going to be offline and not just run a script.
 --        Example 2: they do not include all the options the index may have been created with (padding, compression
           filegroup/partition scheme etc.)
 --        (The compression and filegroup index create syntax is not trivial because it is set at the partition 
           level and is not trivial to code.)
 - Does not advise you about data modeling for clustered indexes and primary keys (primarily looks for signs of insanity.)

Unknown limitations of this version:
 - We knew them once, but we forgot.

Changes - for the full list of improvements and fixes in this version, see:
https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit/milestone/4?closed=1


MIT License

Copyright (c) 2016 Brent Ozar Unlimited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
'


DECLARE @ScriptVersionName NVARCHAR(50);
DECLARE @DaysUptime NUMERIC(23,2);
DECLARE @DatabaseID INT;
DECLARE @ObjectID INT;
DECLARE @dsql NVARCHAR(MAX);
DECLARE @params NVARCHAR(MAX);
DECLARE @msg NVARCHAR(4000);
DECLARE @ErrorSeverity INT;
DECLARE @ErrorState INT;
DECLARE @Rowcount BIGINT;
DECLARE @SQLServerProductVersion NVARCHAR(128);
DECLARE @SQLServerEdition INT;
DECLARE @FilterMB INT;
DECLARE @collation NVARCHAR(256);
DECLARE @NumDatabases INT;
DECLARE @LineFeed NVARCHAR(5);

SET @LineFeed = CHAR(13) + CHAR(10);
SELECT @SQLServerProductVersion = CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128));
SELECT @SQLServerEdition =CAST(SERVERPROPERTY('EngineEdition') AS INT); /* We default to online index creates where EngineEdition=3*/
SET @FilterMB=250;
SELECT @ScriptVersionName = 'sp_BlitzIndex(TM) v' + @Version + ' - ' + DATENAME(MM, @VersionDate) + ' ' + RIGHT('0'+DATENAME(DD, @VersionDate),2) + ', ' + DATENAME(YY, @VersionDate)

RAISERROR(N'Starting run. %s', 0,1, @ScriptVersionName) WITH NOWAIT;

IF OBJECT_ID('tempdb..#IndexSanity') IS NOT NULL 
    DROP TABLE #IndexSanity;

IF OBJECT_ID('tempdb..#IndexPartitionSanity') IS NOT NULL 
    DROP TABLE #IndexPartitionSanity;

IF OBJECT_ID('tempdb..#IndexSanitySize') IS NOT NULL 
    DROP TABLE #IndexSanitySize;

IF OBJECT_ID('tempdb..#IndexColumns') IS NOT NULL 
    DROP TABLE #IndexColumns;

IF OBJECT_ID('tempdb..#MissingIndexes') IS NOT NULL 
    DROP TABLE #MissingIndexes;

IF OBJECT_ID('tempdb..#ForeignKeys') IS NOT NULL 
    DROP TABLE #ForeignKeys;

IF OBJECT_ID('tempdb..#BlitzIndexResults') IS NOT NULL 
    DROP TABLE #BlitzIndexResults;
        
IF OBJECT_ID('tempdb..#IndexCreateTsql') IS NOT NULL    
    DROP TABLE #IndexCreateTsql;

IF OBJECT_ID('tempdb..#DatabaseList') IS NOT NULL 
    DROP TABLE #DatabaseList;

IF OBJECT_ID('tempdb..#Statistics') IS NOT NULL 
    DROP TABLE #Statistics;

IF OBJECT_ID('tempdb..#PartitionCompressionInfo') IS NOT NULL 
    DROP TABLE #PartitionCompressionInfo;

IF OBJECT_ID('tempdb..#ComputedColumns') IS NOT NULL 
    DROP TABLE #ComputedColumns;
	
IF OBJECT_ID('tempdb..#TraceStatus') IS NOT NULL
	DROP TABLE #TraceStatus;

        RAISERROR (N'Create temp tables.',0,1) WITH NOWAIT;
        CREATE TABLE #BlitzIndexResults
            (
              blitz_result_id INT IDENTITY PRIMARY KEY,
              check_id INT NOT NULL,
              index_sanity_id INT NULL,
              Priority INT NULL,
              findings_group VARCHAR(4000) NOT NULL,
              finding VARCHAR(200) NOT NULL,
              [database_name] VARCHAR(200) NULL,
              URL VARCHAR(200) NOT NULL,
              details NVARCHAR(4000) NOT NULL,
              index_definition NVARCHAR(MAX) NOT NULL,
              secret_columns NVARCHAR(MAX) NULL,
              index_usage_summary NVARCHAR(MAX) NULL,
              index_size_summary NVARCHAR(MAX) NULL,
              create_tsql NVARCHAR(MAX) NULL,
              more_info NVARCHAR(MAX)NULL
            );

        CREATE TABLE #IndexSanity
            (
              [index_sanity_id] INT IDENTITY PRIMARY KEY,
              [database_id] SMALLINT NOT NULL ,
              [object_id] INT NOT NULL ,
              [index_id] INT NOT NULL ,
              [index_type] TINYINT NOT NULL,
              [database_name] NVARCHAR(128) NOT NULL ,
              [schema_name] NVARCHAR(128) NOT NULL ,
              [object_name] NVARCHAR(128) NOT NULL ,
              index_name NVARCHAR(128) NULL ,
              key_column_names NVARCHAR(MAX) NULL ,
              key_column_names_with_sort_order NVARCHAR(MAX) NULL ,
              key_column_names_with_sort_order_no_types NVARCHAR(MAX) NULL ,
              count_key_columns INT NULL ,
              include_column_names NVARCHAR(MAX) NULL ,
              include_column_names_no_types NVARCHAR(MAX) NULL ,
              count_included_columns INT NULL ,
              partition_key_column_name NVARCHAR(MAX) NULL,
              filter_definition NVARCHAR(MAX) NOT NULL ,
              is_indexed_view BIT NOT NULL ,
              is_unique BIT NOT NULL ,
              is_primary_key BIT NOT NULL ,
              is_XML BIT NOT NULL,
              is_spatial BIT NOT NULL,
              is_NC_columnstore BIT NOT NULL,
              is_CX_columnstore BIT NOT NULL,
              is_disabled BIT NOT NULL ,
              is_hypothetical BIT NOT NULL ,
              is_padded BIT NOT NULL ,
              fill_factor SMALLINT NOT NULL ,
              user_seeks BIGINT NOT NULL ,
              user_scans BIGINT NOT NULL ,
              user_lookups BIGINT NOT  NULL ,
              user_updates BIGINT NULL ,
              last_user_seek DATETIME NULL ,
              last_user_scan DATETIME NULL ,
              last_user_lookup DATETIME NULL ,
              last_user_update DATETIME NULL ,
              is_referenced_by_foreign_key BIT DEFAULT(0),
              secret_columns NVARCHAR(MAX) NULL,
              count_secret_columns INT NULL,
              create_date DATETIME NOT NULL,
              modify_date DATETIME NOT NULL,
            [db_schema_object_name] AS [schema_name] + '.' + [object_name]  ,
            [db_schema_object_indexid] AS [schema_name] + '.' + [object_name]
                + CASE WHEN [index_name] IS NOT NULL THEN '.' + index_name
                ELSE ''
                END + ' (' + CAST(index_id AS NVARCHAR(20)) + ')' ,
            first_key_column_name AS CASE    WHEN count_key_columns &gt; 1
                THEN LEFT(key_column_names, CHARINDEX(',', key_column_names, 0) - 1)
                ELSE key_column_names
                END ,
            index_definition AS 
            CASE WHEN partition_key_column_name IS NOT NULL 
                THEN N'[PARTITIONED BY:' + partition_key_column_name +  N']' 
                ELSE '' 
                END +
                CASE index_id
                    WHEN 0 THEN N'[HEAP] '
                    WHEN 1 THEN N'[CX] '
                    ELSE N'' END + CASE WHEN is_indexed_view = 1 THEN '[VIEW] '
                    ELSE N'' END + CASE WHEN is_primary_key = 1 THEN N'[PK] '
                    ELSE N'' END + CASE WHEN is_XML = 1 THEN N'[XML] '
                    ELSE N'' END + CASE WHEN is_spatial = 1 THEN N'[SPATIAL] '
                    ELSE N'' END + CASE WHEN is_NC_columnstore = 1 THEN N'[COLUMNSTORE] '
                    ELSE N'' END + CASE WHEN is_disabled = 1 THEN N'[DISABLED] '
                    ELSE N'' END + CASE WHEN is_hypothetical = 1 THEN N'[HYPOTHETICAL] '
                    ELSE N'' END + CASE WHEN is_unique = 1 AND is_primary_key = 0 THEN N'[UNIQUE] '
                    ELSE N'' END + CASE WHEN count_key_columns &gt; 0 THEN 
                        N'[' + CAST(count_key_columns AS VARCHAR(10)) + N' KEY' 
                            + CASE WHEN count_key_columns &gt; 1 THEN  N'S' ELSE N'' END
                            + N'] ' + LTRIM(key_column_names_with_sort_order)
                    ELSE N'' END + CASE WHEN count_included_columns &gt; 0 THEN 
                        N' [' + CAST(count_included_columns AS VARCHAR(10))  + N' INCLUDE' + 
                            + CASE WHEN count_included_columns &gt; 1 THEN  N'S' ELSE N'' END                    
                            + N'] ' + include_column_names
                    ELSE N'' END + CASE WHEN filter_definition &lt;&gt; N'' THEN N' [FILTER] ' + filter_definition
                    ELSE N'' END ,
            [total_reads] AS user_seeks + user_scans + user_lookups,
            [reads_per_write] AS CAST(CASE WHEN user_updates &gt; 0
                THEN ( user_seeks + user_scans + user_lookups )  / (1.0 * user_updates)
                ELSE 0 END AS MONEY) ,
            [index_usage_summary] AS N'Reads: ' + 
                REPLACE(CONVERT(NVARCHAR(30),CAST((user_seeks + user_scans + user_lookups) AS MONEY), 1), '.00', '')
                + CASE WHEN user_seeks + user_scans + user_lookups &gt; 0 THEN
                    N' (' 
                        + RTRIM(
                        CASE WHEN user_seeks &gt; 0 THEN REPLACE(CONVERT(NVARCHAR(30),CAST((user_seeks) AS MONEY), 1), '.00', '') + N' seek ' ELSE N'' END
                        + CASE WHEN user_scans &gt; 0 THEN REPLACE(CONVERT(NVARCHAR(30),CAST((user_scans) AS MONEY), 1), '.00', '') + N' scan '  ELSE N'' END
                        + CASE WHEN user_lookups &gt; 0 THEN  REPLACE(CONVERT(NVARCHAR(30),CAST((user_lookups) AS MONEY), 1), '.00', '') + N' lookup' ELSE N'' END
                        )
                        + N') '
                    ELSE N' ' END 
                + N'Writes:' + 
                REPLACE(CONVERT(NVARCHAR(30),CAST(user_updates AS MONEY), 1), '.00', ''),
            [more_info] AS N'EXEC dbo.sp_BlitzIndex @DatabaseName=' + QUOTENAME([database_name],'''') + 
                N', @SchemaName=' + QUOTENAME([schema_name],'''') + N', @TableName=' + QUOTENAME([object_name],'''') + N';'
		);


        CREATE TABLE #IndexPartitionSanity
            (
              [index_partition_sanity_id] INT IDENTITY PRIMARY KEY ,
              [index_sanity_id] INT NULL ,
              [database_id] INT NOT NULL ,
              [object_id] INT NOT NULL ,
              [index_id] INT NOT NULL ,
              [partition_number] INT NOT NULL ,
              row_count BIGINT NOT NULL ,
              reserved_MB NUMERIC(29,2) NOT NULL ,
              reserved_LOB_MB NUMERIC(29,2) NOT NULL ,
              reserved_row_overflow_MB NUMERIC(29,2) NOT NULL ,
              leaf_insert_count BIGINT NULL ,
              leaf_delete_count BIGINT NULL ,
              leaf_update_count BIGINT NULL ,
              range_scan_count BIGINT NULL ,
              singleton_lookup_count BIGINT NULL , 
              forwarded_fetch_count BIGINT NULL ,
              lob_fetch_in_pages BIGINT NULL ,
              lob_fetch_in_bytes BIGINT NULL ,
              row_overflow_fetch_in_pages BIGINT NULL ,
              row_overflow_fetch_in_bytes BIGINT NULL ,
              row_lock_count BIGINT NULL ,
              row_lock_wait_count BIGINT NULL ,
              row_lock_wait_in_ms BIGINT NULL ,
              page_lock_count BIGINT NULL ,
              page_lock_wait_count BIGINT NULL ,
              page_lock_wait_in_ms BIGINT NULL ,
              index_lock_promotion_attempt_count BIGINT NULL ,
              index_lock_promotion_count BIGINT NULL,
              data_compression_desc VARCHAR(60) NULL
            );

        CREATE TABLE #IndexSanitySize
            (
              [index_sanity_size_id] INT IDENTITY NOT NULL ,
              [index_sanity_id] INT NULL ,
              [database_id] INT NOT NULL,
              partition_count INT NOT NULL ,
              total_rows BIGINT NOT NULL ,
              total_reserved_MB NUMERIC(29,2) NOT NULL ,
              total_reserved_LOB_MB NUMERIC(29,2) NOT NULL ,
              total_reserved_row_overflow_MB NUMERIC(29,2) NOT NULL ,
              total_leaf_delete_count BIGINT NULL,
              total_leaf_update_count BIGINT NULL,
              total_range_scan_count BIGINT NULL,
              total_singleton_lookup_count BIGINT NULL,
              total_forwarded_fetch_count BIGINT NULL,
              total_row_lock_count BIGINT NULL ,
              total_row_lock_wait_count BIGINT NULL ,
              total_row_lock_wait_in_ms BIGINT NULL ,
              avg_row_lock_wait_in_ms BIGINT NULL ,
              total_page_lock_count BIGINT NULL ,
              total_page_lock_wait_count BIGINT NULL ,
              total_page_lock_wait_in_ms BIGINT NULL ,
              avg_page_lock_wait_in_ms BIGINT NULL ,
               total_index_lock_promotion_attempt_count BIGINT NULL ,
              total_index_lock_promotion_count BIGINT NULL ,
              data_compression_desc VARCHAR(8000) NULL,
              index_size_summary AS ISNULL(
                CASE WHEN partition_count &gt; 1
                        THEN N'[' + CAST(partition_count AS NVARCHAR(10)) + N' PARTITIONS] '
                        ELSE N''
                END + REPLACE(CONVERT(NVARCHAR(30),CAST([total_rows] AS MONEY), 1), N'.00', N'') + N' rows; '
                + CASE WHEN total_reserved_MB &gt; 1024 THEN 
                    CAST(CAST(total_reserved_MB/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'GB'
                ELSE 
                    CAST(CAST(total_reserved_MB AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'MB'
                END
                + CASE WHEN total_reserved_LOB_MB &gt; 1024 THEN 
                    N'; ' + CAST(CAST(total_reserved_LOB_MB/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'GB LOB'
                WHEN total_reserved_LOB_MB &gt; 0 THEN
                    N'; ' + CAST(CAST(total_reserved_LOB_MB AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'MB LOB'
                ELSE ''
                END
                 + CASE WHEN total_reserved_row_overflow_MB &gt; 1024 THEN
                    N'; ' + CAST(CAST(total_reserved_row_overflow_MB/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'GB Row Overflow'
                WHEN total_reserved_row_overflow_MB &gt; 0 THEN
                    N'; ' + CAST(CAST(total_reserved_row_overflow_MB AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'MB Row Overflow'
                ELSE ''
                END ,
                    N'Error- NULL in computed column'),
            index_op_stats AS ISNULL(
                (
                    REPLACE(CONVERT(NVARCHAR(30),CAST(total_singleton_lookup_count AS MONEY), 1),N'.00',N'') + N' singleton lookups; '
                    + REPLACE(CONVERT(NVARCHAR(30),CAST(total_range_scan_count AS MONEY), 1),N'.00',N'') + N' scans/seeks; '
                    + REPLACE(CONVERT(NVARCHAR(30),CAST(total_leaf_delete_count AS MONEY), 1),N'.00',N'') + N' deletes; '
                    + REPLACE(CONVERT(NVARCHAR(30),CAST(total_leaf_update_count AS MONEY), 1),N'.00',N'') + N' updates; '
                    + CASE WHEN ISNULL(total_forwarded_fetch_count,0) &gt;0 THEN
                        REPLACE(CONVERT(NVARCHAR(30),CAST(total_forwarded_fetch_count AS MONEY), 1),N'.00',N'') + N' forward records fetched; '
                    ELSE N'' END

                    /* rows will only be in this dmv when data is in memory for the table */
                ), N'Table metadata not in memory'),
            index_lock_wait_summary AS ISNULL(
                CASE WHEN total_row_lock_wait_count = 0 AND  total_page_lock_wait_count = 0 AND
                    total_index_lock_promotion_attempt_count = 0 THEN N'0 lock waits.'
                ELSE
                    CASE WHEN total_row_lock_wait_count &gt; 0 THEN
                        N'Row lock waits: ' + REPLACE(CONVERT(NVARCHAR(30),CAST(total_row_lock_wait_count AS MONEY), 1), N'.00', N'')
                        + N'; total duration: ' + 
                            CASE WHEN total_row_lock_wait_in_ms &gt;= 60000 THEN /*More than 1 min*/
                                REPLACE(CONVERT(NVARCHAR(30),CAST((total_row_lock_wait_in_ms/60000) AS MONEY), 1), N'.00', N'') + N' minutes; '
                            ELSE                         
                                REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(total_row_lock_wait_in_ms/1000,0) AS MONEY), 1), N'.00', N'') + N' seconds; '
                            END
                        + N'avg duration: ' + 
                            CASE WHEN avg_row_lock_wait_in_ms &gt;= 60000 THEN /*More than 1 min*/
                                REPLACE(CONVERT(NVARCHAR(30),CAST((avg_row_lock_wait_in_ms/60000) AS MONEY), 1), N'.00', N'') + N' minutes; '
                            ELSE                         
                                REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(avg_row_lock_wait_in_ms/1000,0) AS MONEY), 1), N'.00', N'') + N' seconds; '
                            END
                    ELSE N''
                    END +
                    CASE WHEN total_page_lock_wait_count &gt; 0 THEN
                        N'Page lock waits: ' + REPLACE(CONVERT(NVARCHAR(30),CAST(total_page_lock_wait_count AS MONEY), 1), N'.00', N'')
                        + N'; total duration: ' + 
                            CASE WHEN total_page_lock_wait_in_ms &gt;= 60000 THEN /*More than 1 min*/
                                REPLACE(CONVERT(NVARCHAR(30),CAST((total_page_lock_wait_in_ms/60000) AS MONEY), 1), N'.00', N'') + N' minutes; '
                            ELSE                         
                                REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(total_page_lock_wait_in_ms/1000,0) AS MONEY), 1), N'.00', N'') + N' seconds; '
                            END
                        + N'avg duration: ' + 
                            CASE WHEN avg_page_lock_wait_in_ms &gt;= 60000 THEN /*More than 1 min*/
                                REPLACE(CONVERT(NVARCHAR(30),CAST((avg_page_lock_wait_in_ms/60000) AS MONEY), 1), N'.00', N'') + N' minutes; '
                            ELSE                         
                                REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(avg_page_lock_wait_in_ms/1000,0) AS MONEY), 1), N'.00', N'') + N' seconds; '
                            END
                    ELSE N''
                    END +
                    CASE WHEN total_index_lock_promotion_attempt_count &gt; 0 THEN
                        N'Lock escalation attempts: ' + REPLACE(CONVERT(NVARCHAR(30),CAST(total_index_lock_promotion_attempt_count AS MONEY), 1), N'.00', N'')
                        + N'; Actual Escalations: ' + REPLACE(CONVERT(NVARCHAR(30),CAST(ISNULL(total_index_lock_promotion_count,0) AS MONEY), 1), N'.00', N'') + N'.'
                    ELSE N''
                    END
                END                  
                    ,'Error- NULL in computed column')
            );

        CREATE TABLE #IndexColumns
            (
              [database_id] INT NOT NULL,
              [object_id] INT NOT NULL ,
              [index_id] INT NOT NULL ,
              [key_ordinal] INT NULL ,
              is_included_column BIT NULL ,
              is_descending_key BIT NULL ,
              [partition_ordinal] INT NULL ,
              column_name NVARCHAR(256) NOT NULL ,
              system_type_name NVARCHAR(256) NOT NULL,
              max_length SMALLINT NOT NULL,
              [precision] TINYINT NOT NULL,
              [scale] TINYINT NOT NULL,
              collation_name NVARCHAR(256) NULL,
              is_nullable BIT NULL,
              is_identity BIT NULL,
              is_computed BIT NULL,
              is_replicated BIT NULL,
              is_sparse BIT NULL,
              is_filestream BIT NULL,
              seed_value BIGINT NULL,
              increment_value INT NULL ,
              last_value BIGINT NULL,
              is_not_for_replication BIT NULL
            );

        CREATE TABLE #MissingIndexes
            ([object_id] INT NOT NULL,
            [database_name] NVARCHAR(128) NOT NULL ,
            [schema_name] NVARCHAR(128) NOT NULL ,
            [table_name] NVARCHAR(128),
            [statement] NVARCHAR(512) NOT NULL,
            magic_benefit_number AS (( user_seeks + user_scans ) * avg_total_user_cost * avg_user_impact),
            avg_total_user_cost NUMERIC(29,4) NOT NULL,
            avg_user_impact NUMERIC(29,1) NOT NULL,
            user_seeks BIGINT NOT NULL,
            user_scans BIGINT NOT NULL,
            unique_compiles BIGINT NULL,
            equality_columns NVARCHAR(4000), 
            inequality_columns NVARCHAR(4000),
            included_columns NVARCHAR(4000),
                [index_estimated_impact] AS 
                    REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(
                                    (user_seeks + user_scans)
                                     AS BIGINT) AS MONEY), 1), '.00', '') + N' use' 
                        + CASE WHEN (user_seeks + user_scans) &gt; 1 THEN N's' ELSE N'' END
                         +N'; Impact: ' + CAST(avg_user_impact AS NVARCHAR(30))
                        + N'%; Avg query cost: '
                        + CAST(avg_total_user_cost AS NVARCHAR(30)),
                [missing_index_details] AS
                    CASE WHEN equality_columns IS NOT NULL THEN N'EQUALITY: ' + equality_columns + N' '
                         ELSE N''
                    END + CASE WHEN inequality_columns IS NOT NULL THEN N'INEQUALITY: ' + inequality_columns + N' '
                       ELSE N''
                    END + CASE WHEN included_columns IS NOT NULL THEN N'INCLUDES: ' + included_columns + N' '
                        ELSE N''
                    END,
                [create_tsql] AS N'CREATE INDEX [ix_' + table_name + N'_' 
                    + REPLACE(REPLACE(REPLACE(REPLACE(
                        ISNULL(equality_columns,N'')+ 
                        CASE WHEN equality_columns IS NOT NULL AND inequality_columns IS NOT NULL THEN N'_' ELSE N'' END
                        + ISNULL(inequality_columns,''),',','')
                        ,'[',''),']',''),' ','_') 
                    + CASE WHEN included_columns IS NOT NULL THEN N'_includes' ELSE N'' END + N'] ON ' 
                    + [statement] + N' (' + ISNULL(equality_columns,N'')
                    + CASE WHEN equality_columns IS NOT NULL AND inequality_columns IS NOT NULL THEN N', ' ELSE N'' END
                    + CASE WHEN inequality_columns IS NOT NULL THEN inequality_columns ELSE N'' END + 
                    ') ' + CASE WHEN included_columns IS NOT NULL THEN N' INCLUDE (' + included_columns + N')' ELSE N'' END
                    + N' WITH (' 
                        + N'FILLFACTOR=100, ONLINE=?, SORT_IN_TEMPDB=?' 
                    + N')'
                    + N';'
                    ,
                [more_info] AS N'EXEC dbo.sp_BlitzIndex @DatabaseName=' + QUOTENAME([database_name],'''') + 
                    N', @SchemaName=' + QUOTENAME([schema_name],'''') + N', @TableName=' + QUOTENAME([table_name],'''') + N';'
            );

        CREATE TABLE #ForeignKeys (
            [database_name] NVARCHAR(128) NOT NULL ,
            foreign_key_name NVARCHAR(256),
            parent_object_id INT,
            parent_object_name NVARCHAR(256),
            referenced_object_id INT,
            referenced_object_name NVARCHAR(256),
            is_disabled BIT,
            is_not_trusted BIT,
            is_not_for_replication BIT,
            parent_fk_columns NVARCHAR(MAX),
            referenced_fk_columns NVARCHAR(MAX),
            update_referential_action_desc NVARCHAR(16),
            delete_referential_action_desc NVARCHAR(60)
        )
        
        CREATE TABLE #IndexCreateTsql (
            index_sanity_id INT NOT NULL,
            create_tsql NVARCHAR(MAX) NOT NULL
        )

        CREATE TABLE #DatabaseList (
			DatabaseName NVARCHAR(256)
        )

		CREATE TABLE #PartitionCompressionInfo (
			[index_sanity_id] INT NULL,
			[partition_compression_detail] VARCHAR(8000) NULL
        )

		CREATE TABLE #Statistics (
		  database_name NVARCHAR(256) NOT NULL,
		  table_name NVARCHAR(128) NULL,
		  schema_name NVARCHAR(128) NULL,
		  index_name  NVARCHAR(128) NULL,
		  column_name  NVARCHAR(128) NULL,
		  statistics_name NVARCHAR(128) NULL,
		  last_statistics_update DATETIME NULL,
		  days_since_last_stats_update INT NULL,
		  rows BIGINT NULL,
		  rows_sampled BIGINT NULL,
		  percent_sampled DECIMAL(18, 1) NULL,
		  histogram_steps INT NULL,
		  modification_counter BIGINT NULL,
		  percent_modifications DECIMAL(18, 1) NULL,
		  modifications_before_auto_update INT NULL,
		  index_type_desc NVARCHAR(128) NULL,
		  table_create_date DATETIME NULL,
		  table_modify_date DATETIME NULL,
		  no_recompute BIT NULL,
		  has_filter BIT NULL,
		  filter_definition NVARCHAR(MAX) NULL
		); 

		CREATE TABLE #ComputedColumns
		(
		  index_sanity_id INT IDENTITY(1, 1) NOT NULL,
		  database_name NVARCHAR(128) NULL,
		  table_name NVARCHAR(128) NOT NULL,
		  schema_name NVARCHAR(128) NOT NULL,
		  column_name NVARCHAR(128) NULL,
		  is_nullable BIT NULL,
		  definition NVARCHAR(MAX) NULL,
		  uses_database_collation BIT NOT NULL,
		  is_persisted BIT NOT NULL,
		  is_computed BIT NOT NULL,
		  is_function INT NOT NULL,
		  column_definition NVARCHAR(MAX) NULL
		);
		
		CREATE TABLE #TraceStatus
		(
		 TraceFlag VARCHAR(10) ,
		 status BIT ,
		 Global BIT ,
		 Session BIT
		);


IF @GetAllDatabases = 1
    BEGIN
        INSERT INTO #DatabaseList (DatabaseName)
        SELECT  DB_NAME(database_id)
        FROM    sys.databases
        WHERE user_access_desc='MULTI_USER'
        AND state_desc = 'ONLINE'
        AND database_id &gt; 4
        AND DB_NAME(database_id) NOT IN ('ReportServer','ReportServerTempDB')
        AND is_distributor = 0;
    END
ELSE
    BEGIN
        INSERT INTO #DatabaseList
                ( DatabaseName )
        SELECT CASE WHEN @DatabaseName IS NULL OR @DatabaseName = N'' THEN DB_NAME()
                    ELSE @DatabaseName END
    END

SET @NumDatabases = @@ROWCOUNT;

/* Running on 50+ databases can take a reaaallly long time, so we want explicit permission to do so (and only after warning about it) */

BEGIN TRY
        IF @NumDatabases &gt;= 50 AND @BringThePain != 1
        BEGIN

            INSERT    #BlitzIndexResults ( Priority, check_id, findings_group, finding, URL, details, index_definition,
                                            index_usage_summary, index_size_summary )
            VALUES  ( -1, 0 , 
		            @ScriptVersionName,
                    CASE WHEN @GetAllDatabases = 1 THEN N'All Databases' ELSE N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + CONVERT(NVARCHAR(16),GETDATE(),121) END, 
                    N'From Your Community Volunteers' ,   N'http://www.BrentOzar.com/BlitzIndex' ,
                    N''
                    , N'',N''
                    );
            INSERT    #BlitzIndexResults ( Priority, check_id, findings_group, finding, database_name, URL, details, index_definition,
                                            index_usage_summary, index_size_summary )
            VALUES  ( 1, 0 , 
		           N'You''re trying to run sp_BlitzIndex on a server with ' + CAST(@NumDatabases AS NVARCHAR(8)) + N' databases. ',
                   N'Running sp_BlitzIndex on a server with 50+ databases may cause temporary insanity for the server and/or user.',
				   N'If you''re sure you want to do this, run again with the parameter @BringThePain = 1.',
                   'http://FirstResponderKit.org', '', '', '', ''
                    );        
		
		SELECT bir.blitz_result_id,
               bir.check_id,
               bir.index_sanity_id,
               bir.Priority,
               bir.findings_group,
               bir.finding,
               bir.database_name,
               bir.URL,
               bir.details,
               bir.index_definition,
               bir.secret_columns,
               bir.index_usage_summary,
               bir.index_size_summary,
               bir.create_tsql,
               bir.more_info 
			   FROM #BlitzIndexResults AS bir

		RETURN;

		END
END TRY
BEGIN CATCH
        RAISERROR (N'Failure to execute due to number of databases.', 0,1) WITH NOWAIT;

        SELECT    @msg = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE();

        RAISERROR (@msg, 
               @ErrorSeverity, 
               @ErrorState 
               );
        
        WHILE @@trancount &gt; 0 
            ROLLBACK;

        RETURN;
    END CATCH;

/* Permission granted or unnecessary? Ok, let's go! */

DECLARE c1 CURSOR 
LOCAL FAST_FORWARD 
FOR 
SELECT DatabaseName FROM #DatabaseList ORDER BY DatabaseName

OPEN c1
FETCH NEXT FROM c1 INTO @DatabaseName
                WHILE @@FETCH_STATUS = 0
BEGIN
    
    RAISERROR (@LineFeed, 0, 1) WITH NOWAIT;
    RAISERROR (@LineFeed, 0, 1) WITH NOWAIT;
    RAISERROR (@DatabaseName, 0, 1) WITH NOWAIT;

SELECT   @DatabaseID = [database_id]
FROM     sys.databases
         WHERE [name] = @DatabaseName
         AND user_access_desc='MULTI_USER'
         AND state_desc = 'ONLINE';

/* Last startup */
SELECT @DaysUptime = CAST(DATEDIFF(hh,create_date,GETDATE())/24. AS NUMERIC (23,2))
FROM    sys.databases
WHERE   database_id = 2;

IF @DaysUptime = 0 SET @DaysUptime = .01;

----------------------------------------
--STEP 1: OBSERVE THE PATIENT
--This step puts index information into temp tables.
----------------------------------------
BEGIN TRY
    BEGIN

        --Validate SQL Server Verson

        IF (SELECT LEFT(@SQLServerProductVersion,
              CHARINDEX('.',@SQLServerProductVersion,0)-1
              )) &lt;= 9
        BEGIN
            SET @msg=N'sp_BlitzIndex is only supported on SQL Server 2008 and higher. The version of this instance is: ' + @SQLServerProductVersion;
            RAISERROR(@msg,16,1);
        END

        --Short circuit here if database name does not exist.
        IF @DatabaseName IS NULL OR @DatabaseID IS NULL
        BEGIN
            SET @msg='Database does not exist or is not online/multi-user: cannot proceed.'
            RAISERROR(@msg,16,1);
        END    

        --Validate parameters.
        IF (@Mode NOT IN (0,1,2,3,4))
        BEGIN
            SET @msg=N'Invalid @Mode parameter. 0=diagnose, 1=summarize, 2=index detail, 3=missing index detail, 4=diagnose detail';
            RAISERROR(@msg,16,1);
        END

        IF (@Mode &lt;&gt; 0 AND @TableName IS NOT NULL)
        BEGIN
            SET @msg=N'Setting the @Mode doesn''t change behavior if you supply @TableName. Use default @Mode=0 to see table detail.';
            RAISERROR(@msg,16,1);
        END

        IF ((@Mode &lt;&gt; 0 OR @TableName IS NOT NULL) AND @Filter &lt;&gt; 0)
        BEGIN
            SET @msg=N'@Filter only appies when @Mode=0 and @TableName is not specified. Please try again.';
            RAISERROR(@msg,16,1);
        END

        IF (@SchemaName IS NOT NULL AND @TableName IS NULL) 
        BEGIN
            SET @msg='We can''t run against a whole schema! Specify a @TableName, or leave both NULL for diagnosis.'
            RAISERROR(@msg,16,1);
        END


        IF  (@TableName IS NOT NULL AND @SchemaName IS NULL)
        BEGIN
            SET @SchemaName=N'dbo'
            SET @msg='@SchemaName wasn''t specified-- assuming schema=dbo.'
            RAISERROR(@msg,1,1) WITH NOWAIT;
        END

        --If a table is specified, grab the object id.
        --Short circuit if it doesn't exist.
        IF @TableName IS NOT NULL
        BEGIN
            SET @dsql = N'
                    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                    SELECT    @ObjectID= OBJECT_ID
                    FROM    ' + QUOTENAME(@DatabaseName) + N'.sys.objects AS so
                    JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.schemas AS sc on 
                        so.schema_id=sc.schema_id
                    where so.type in (''U'', ''V'')
                    and so.name=' + QUOTENAME(@TableName,'''')+ N'
                    and sc.name=' + QUOTENAME(@SchemaName,'''')+ N'
                    /*Has a row in sys.indexes. This lets us get indexed views.*/
                    and exists (
                        SELECT si.name
                        FROM ' + QUOTENAME(@DatabaseName) + '.sys.indexes AS si 
                        WHERE so.object_id=si.object_id)
                    OPTION (RECOMPILE);';

            SET @params='@ObjectID INT OUTPUT'                

            IF @dsql IS NULL 
                RAISERROR('@dsql is null',16,1);

            EXEC sp_executesql @dsql, @params, @ObjectID=@ObjectID OUTPUT;
            
            IF @ObjectID IS NULL
                    BEGIN
                        SET @msg=N'Oh, this is awkward. I can''t find the table or indexed view you''re looking for in that database.' + CHAR(10) +
                            N'Please check your parameters.'
                        RAISERROR(@msg,1,1);
                        RETURN;
                    END
        END

        --set @collation
        SELECT @collation=collation_name
        FROM sys.databases
        WHERE database_id=@DatabaseID;

        --insert columns for clustered indexes and heaps
        --collect info on identity columns for this one
        SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                SELECT ' + CAST(@DatabaseID AS NVARCHAR(16)) + ',    
                    si.object_id, 
                    si.index_id, 
                    sc.key_ordinal, 
                    sc.is_included_column, 
                    sc.is_descending_key,
                    sc.partition_ordinal,
                    c.name as column_name, 
                    st.name as system_type_name,
                    c.max_length,
                    c.[precision],
                    c.[scale],
                    c.collation_name,
                    c.is_nullable,
                    c.is_identity,
                    c.is_computed,
                    c.is_replicated,
                    ' + CASE WHEN @SQLServerProductVersion NOT LIKE '9%' THEN N'c.is_sparse' ELSE N'NULL as is_sparse' END + N',
                    ' + CASE WHEN @SQLServerProductVersion NOT LIKE '9%' THEN N'c.is_filestream' ELSE N'NULL as is_filestream' END + N',
                    CAST(ic.seed_value AS BIGINT),
                    CAST(ic.increment_value AS INT),
                    CAST(ic.last_value AS BIGINT),
                    ic.is_not_for_replication
                FROM    ' + QUOTENAME(@DatabaseName) + N'.sys.indexes si
                JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.columns c ON
                    si.object_id=c.object_id
                LEFT JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.index_columns sc ON 
                    sc.object_id = si.object_id
                    and sc.index_id=si.index_id
                    AND sc.column_id=c.column_id
                LEFT JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.identity_columns ic ON
                    c.object_id=ic.object_id and
                    c.column_id=ic.column_id
                JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.types st ON 
                    c.system_type_id=st.system_type_id
                    AND c.user_type_id=st.user_type_id
                WHERE si.index_id in (0,1) ' 
                    + CASE WHEN @ObjectID IS NOT NULL 
                        THEN N' AND si.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) 
                    ELSE N'' END 
                + N'OPTION (RECOMPILE);';

        IF @dsql IS NULL 
            RAISERROR('@dsql is null',16,1);

        RAISERROR (N'Inserting data into #IndexColumns for clustered indexes and heaps',0,1) WITH NOWAIT;
        INSERT    #IndexColumns ( database_id, object_id, index_id, key_ordinal, is_included_column, is_descending_key, partition_ordinal,
            column_name, system_type_name, max_length, precision, scale, collation_name, is_nullable, is_identity, is_computed,
            is_replicated, is_sparse, is_filestream, seed_value, increment_value, last_value, is_not_for_replication )
                EXEC sp_executesql @dsql;

        --insert columns for nonclustered indexes
        --this uses a full join to sys.index_columns
        --We don't collect info on identity columns here. They may be in NC indexes, but we just analyze identities in the base table.
        SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                SELECT ' + CAST(@DatabaseID AS NVARCHAR(16)) + ',    
                    si.object_id, 
                    si.index_id, 
                    sc.key_ordinal, 
                    sc.is_included_column, 
                    sc.is_descending_key,
                    sc.partition_ordinal,
                    c.name as column_name, 
                    st.name as system_type_name,
                    c.max_length,
                    c.[precision],
                    c.[scale],
                    c.collation_name,
                    c.is_nullable,
                    c.is_identity,
                    c.is_computed,
                    c.is_replicated,
                    ' + CASE WHEN @SQLServerProductVersion NOT LIKE '9%' THEN N'c.is_sparse' ELSE N'NULL AS is_sparse' END + N',
                    ' + CASE WHEN @SQLServerProductVersion NOT LIKE '9%' THEN N'c.is_filestream' ELSE N'NULL AS is_filestream' END + N'                
                FROM    ' + QUOTENAME(@DatabaseName) + N'.sys.indexes AS si
                JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.columns AS c ON
                    si.object_id=c.object_id
                JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.index_columns AS sc ON 
                    sc.object_id = si.object_id
                    and sc.index_id=si.index_id
                    AND sc.column_id=c.column_id
                JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.types AS st ON 
                    c.system_type_id=st.system_type_id
                    AND c.user_type_id=st.user_type_id
                WHERE si.index_id not in (0,1) ' 
                    + CASE WHEN @ObjectID IS NOT NULL 
                        THEN N' AND si.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) 
                    ELSE N'' END 
                + N'OPTION (RECOMPILE);';

        IF @dsql IS NULL 
            RAISERROR('@dsql is null',16,1);

        RAISERROR (N'Inserting data into #IndexColumns for nonclustered indexes',0,1) WITH NOWAIT;
        INSERT    #IndexColumns ( database_id, object_id, index_id, key_ordinal, is_included_column, is_descending_key, partition_ordinal,
            column_name, system_type_name, max_length, precision, scale, collation_name, is_nullable, is_identity, is_computed,
            is_replicated, is_sparse, is_filestream )
                EXEC sp_executesql @dsql;
                    
        SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                SELECT    ' + CAST(@DatabaseID AS NVARCHAR(10)) + ' AS database_id, 
                        so.object_id, 
                        si.index_id, 
                        si.type,
                        ' + QUOTENAME(@DatabaseName, '''') + ' AS database_name, 
                        COALESCE(sc.NAME, ''Unknown'') AS [schema_name],
                        COALESCE(so.name, ''Unknown'') AS [object_name], 
                        COALESCE(si.name, ''Unknown'') AS [index_name],
                        CASE    WHEN so.[type] = CAST(''V'' AS CHAR(2)) THEN 1 ELSE 0 END, 
                        si.is_unique, 
                        si.is_primary_key, 
                        CASE when si.type = 3 THEN 1 ELSE 0 END AS is_XML,
                        CASE when si.type = 4 THEN 1 ELSE 0 END AS is_spatial,
                        CASE when si.type = 6 THEN 1 ELSE 0 END AS is_NC_columnstore,
                        CASE when si.type = 5 then 1 else 0 end as is_CX_columnstore,
                        si.is_disabled,
                        si.is_hypothetical, 
                        si.is_padded, 
                        si.fill_factor,'
                        + CASE WHEN @SQLServerProductVersion NOT LIKE '9%' THEN '
                        CASE WHEN si.filter_definition IS NOT NULL THEN si.filter_definition
                             ELSE ''''
                        END AS filter_definition' ELSE ''''' AS filter_definition' END + '
                        , ISNULL(us.user_seeks, 0), ISNULL(us.user_scans, 0),
                        ISNULL(us.user_lookups, 0), ISNULL(us.user_updates, 0), us.last_user_seek, us.last_user_scan,
                        us.last_user_lookup, us.last_user_update,
                        so.create_date, so.modify_date
                FROM    ' + QUOTENAME(@DatabaseName) + '.sys.indexes AS si WITH (NOLOCK)
                        JOIN ' + QUOTENAME(@DatabaseName) + '.sys.objects AS so WITH (NOLOCK) ON si.object_id = so.object_id
                                               AND so.is_ms_shipped = 0 /*Exclude objects shipped by Microsoft*/
                                               AND so.type &lt;&gt; ''TF'' /*Exclude table valued functions*/
                        JOIN ' + QUOTENAME(@DatabaseName) + '.sys.schemas sc ON so.schema_id = sc.schema_id
                        LEFT JOIN sys.dm_db_index_usage_stats AS us WITH (NOLOCK) ON si.[object_id] = us.[object_id]
                                                                       AND si.index_id = us.index_id
                                                                       AND us.database_id = '+ CAST(@DatabaseID AS NVARCHAR(10)) + '
                WHERE    si.[type] IN ( 0, 1, 2, 3, 4, 5, 6 ) 
                /* Heaps, clustered, nonclustered, XML, spatial, Cluster Columnstore, NC Columnstore */ ' +
                CASE WHEN @TableName IS NOT NULL THEN ' and so.name=' + QUOTENAME(@TableName,'''') + ' ' ELSE '' END + 
        'OPTION    ( RECOMPILE );
        ';
        IF @dsql IS NULL 
            RAISERROR('@dsql is null',16,1);

        RAISERROR (N'Inserting data into #IndexSanity',0,1) WITH NOWAIT;
        INSERT    #IndexSanity ( [database_id], [object_id], [index_id], [index_type], [database_name], [schema_name], [object_name],
                                index_name, is_indexed_view, is_unique, is_primary_key, is_XML, is_spatial, is_NC_columnstore, is_CX_columnstore,
                                is_disabled, is_hypothetical, is_padded, fill_factor, filter_definition, user_seeks, user_scans, 
                                user_lookups, user_updates, last_user_seek, last_user_scan, last_user_lookup, last_user_update,
                                create_date, modify_date )
                EXEC sp_executesql @dsql;

        RAISERROR (N'Updating #IndexSanity.key_column_names',0,1) WITH NOWAIT;
        UPDATE    #IndexSanity
        SET        key_column_names = D1.key_column_names
        FROM    #IndexSanity si
                CROSS APPLY ( SELECT    RTRIM(STUFF( (SELECT    N', ' + c.column_name 
                                    + N' {' + system_type_name + N' ' + CAST(max_length AS NVARCHAR(50)) +  N'}'
                                        AS col_definition
                                    FROM    #IndexColumns c
                                    WHERE    c.database_id= si.database_id
                                            AND c.object_id = si.object_id
                                            AND c.index_id = si.index_id
                                            AND c.is_included_column = 0 /*Just Keys*/
                                            AND c.key_ordinal &gt; 0 /*Ignore non-key columns, such as partitioning keys*/
                                    ORDER BY c.object_id, c.index_id, c.key_ordinal    
                            FOR      XML PATH('') ,TYPE).value('.', 'varchar(max)'), 1, 1, ''))
                                        ) D1 ( key_column_names )

        RAISERROR (N'Updating #IndexSanity.partition_key_column_name',0,1) WITH NOWAIT;
        UPDATE    #IndexSanity
        SET        partition_key_column_name = D1.partition_key_column_name
        FROM    #IndexSanity si
                CROSS APPLY ( SELECT    RTRIM(STUFF( (SELECT    N', ' + c.column_name AS col_definition
                                    FROM    #IndexColumns c
                                    WHERE    c.database_id= si.database_id
                                            AND c.object_id = si.object_id
                                            AND c.index_id = si.index_id
                                            AND c.partition_ordinal &lt;&gt; 0 /*Just Partitioned Keys*/
                                    ORDER BY c.object_id, c.index_id, c.key_ordinal    
                            FOR      XML PATH('') , TYPE).value('.', 'varchar(max)'), 1, 1,''))) D1 
                                        ( partition_key_column_name )

        RAISERROR (N'Updating #IndexSanity.key_column_names_with_sort_order',0,1) WITH NOWAIT;
        UPDATE    #IndexSanity
        SET        key_column_names_with_sort_order = D2.key_column_names_with_sort_order
        FROM    #IndexSanity si
                CROSS APPLY ( SELECT    RTRIM(STUFF( (SELECT    N', ' + c.column_name + CASE c.is_descending_key
                                    WHEN 1 THEN N' DESC'
                                    ELSE N''
                                + N' {' + system_type_name + N' ' + CAST(max_length AS NVARCHAR(50)) +  N'}'
                                END AS col_definition
                            FROM    #IndexColumns c
                            WHERE    c.database_id= si.database_id
                                    AND c.object_id = si.object_id
                                    AND c.index_id = si.index_id
                                    AND c.is_included_column = 0 /*Just Keys*/
                                    AND c.key_ordinal &gt; 0 /*Ignore non-key columns, such as partitioning keys*/
                            ORDER BY c.object_id, c.index_id, c.key_ordinal    
                    FOR      XML PATH('') , TYPE).value('.', 'varchar(max)'), 1, 1, ''))
                    ) D2 ( key_column_names_with_sort_order )

        RAISERROR (N'Updating #IndexSanity.key_column_names_with_sort_order_no_types (for create tsql)',0,1) WITH NOWAIT;
        UPDATE    #IndexSanity
        SET        key_column_names_with_sort_order_no_types = D2.key_column_names_with_sort_order_no_types
        FROM    #IndexSanity si
                CROSS APPLY ( SELECT    RTRIM(STUFF( (SELECT    N', ' + QUOTENAME(c.column_name) + CASE c.is_descending_key
                                    WHEN 1 THEN N' [DESC]'
                                    ELSE N''
                                END AS col_definition
                            FROM    #IndexColumns c
                            WHERE    c.database_id= si.database_id
                                    AND c.object_id = si.object_id
                                    AND c.index_id = si.index_id
                                    AND c.is_included_column = 0 /*Just Keys*/
                                    AND c.key_ordinal &gt; 0 /*Ignore non-key columns, such as partitioning keys*/
                            ORDER BY c.object_id, c.index_id, c.key_ordinal    
                    FOR      XML PATH('') , TYPE).value('.', 'varchar(max)'), 1, 1, ''))
                    ) D2 ( key_column_names_with_sort_order_no_types )

        RAISERROR (N'Updating #IndexSanity.include_column_names',0,1) WITH NOWAIT;
        UPDATE    #IndexSanity
        SET        include_column_names = D3.include_column_names
        FROM    #IndexSanity si
                CROSS APPLY ( SELECT    RTRIM(STUFF( (SELECT    N', ' + c.column_name
                                + N' {' + system_type_name + N' ' + CAST(max_length AS NVARCHAR(50)) +  N'}'
                                FROM    #IndexColumns c
                                WHERE    c.database_id= si.database_id
                                        AND c.object_id = si.object_id
                                        AND c.index_id = si.index_id
                                        AND c.is_included_column = 1 /*Just includes*/
                                ORDER BY c.column_name /*Order doesn't matter in includes, 
                                        this is here to make rows easy to compare.*/ 
                        FOR      XML PATH('') ,  TYPE).value('.', 'varchar(max)'), 1, 1, ''))
                        ) D3 ( include_column_names );

        RAISERROR (N'Updating #IndexSanity.include_column_names_no_types (for create tsql)',0,1) WITH NOWAIT;
        UPDATE    #IndexSanity
        SET        include_column_names_no_types = D3.include_column_names_no_types
        FROM    #IndexSanity si
                CROSS APPLY ( SELECT    RTRIM(STUFF( (SELECT    N', ' + QUOTENAME(c.column_name)
                                FROM    #IndexColumns c
                                        WHERE    c.database_id= si.database_id
                                        AND c.object_id = si.object_id
                                        AND c.index_id = si.index_id
                                        AND c.is_included_column = 1 /*Just includes*/
                                ORDER BY c.column_name /*Order doesn't matter in includes, 
                                        this is here to make rows easy to compare.*/ 
                        FOR      XML PATH('') ,  TYPE).value('.', 'varchar(max)'), 1, 1, ''))
                        ) D3 ( include_column_names_no_types );

        RAISERROR (N'Updating #IndexSanity.count_key_columns and count_include_columns',0,1) WITH NOWAIT;
        UPDATE    #IndexSanity
        SET        count_included_columns = D4.count_included_columns,
                count_key_columns = D4.count_key_columns
        FROM    #IndexSanity si
                CROSS APPLY ( SELECT    SUM(CASE WHEN is_included_column = 'true' THEN 1
                                                 ELSE 0
                                            END) AS count_included_columns,
                                        SUM(CASE WHEN is_included_column = 'false' AND c.key_ordinal &gt; 0 THEN 1
                                                 ELSE 0
                                            END) AS count_key_columns
                              FROM        #IndexColumns c
                                    WHERE    c.database_id= si.database_id
                                            AND c.object_id = si.object_id
                                        AND c.index_id = si.index_id 
                                        ) AS D4 ( count_included_columns, count_key_columns );

		 IF (@SkipPartitions = 0)
			BEGIN			
			IF (SELECT LEFT(@SQLServerProductVersion,
			      CHARINDEX('.',@SQLServerProductVersion,0)-1 )) &lt;= 2147483647 --Make change here 			
			BEGIN
            
			RAISERROR (N'Preferring non-2012 syntax with LEFT JOIN to sys.dm_db_index_operational_stats',0,1) WITH NOWAIT;

            --NOTE: If you want to use the newer syntax for 2012+, you'll have to change 2147483647 to 11 on line ~819
			--This change was made because on a table with lots of paritions, the OUTER APPLY was crazy slow.
            SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                        SELECT    ' + CAST(@DatabaseID AS NVARCHAR(10)) + ' AS database_id,
                                ps.object_id, 
                                ps.index_id, 
                                ps.partition_number, 
                                ps.row_count,
                                ps.reserved_page_count * 8. / 1024. AS reserved_MB,
                                ps.lob_reserved_page_count * 8. / 1024. AS reserved_LOB_MB,
                                ps.row_overflow_reserved_page_count * 8. / 1024. AS reserved_row_overflow_MB,
                                os.leaf_insert_count, 
                                os.leaf_delete_count, 
                                os.leaf_update_count, 
                                os.range_scan_count, 
                                os.singleton_lookup_count,  
                                os.forwarded_fetch_count,
                                os.lob_fetch_in_pages, 
                                os.lob_fetch_in_bytes, 
                                os.row_overflow_fetch_in_pages,
                                os.row_overflow_fetch_in_bytes, 
                                os.row_lock_count, 
                                os.row_lock_wait_count,
                                os.row_lock_wait_in_ms, 
                                os.page_lock_count, 
                                os.page_lock_wait_count, 
                                os.page_lock_wait_in_ms,
                                os.index_lock_promotion_attempt_count, 
                                os.index_lock_promotion_count, 
                            ' + CASE WHEN @SQLServerProductVersion NOT LIKE '9%' THEN 'par.data_compression_desc ' ELSE 'null as data_compression_desc' END + '
                    FROM    ' + QUOTENAME(@DatabaseName) + '.sys.dm_db_partition_stats AS ps  
                    JOIN ' + QUOTENAME(@DatabaseName) + '.sys.partitions AS par on ps.partition_id=par.partition_id
                    JOIN ' + QUOTENAME(@DatabaseName) + '.sys.objects AS so ON ps.object_id = so.object_id
                               AND so.is_ms_shipped = 0 /*Exclude objects shipped by Microsoft*/
                               AND so.type &lt;&gt; ''TF'' /*Exclude table valued functions*/
                    LEFT JOIN ' + QUOTENAME(@DatabaseName) + '.sys.dm_db_index_operational_stats('
                + CAST(@DatabaseID AS NVARCHAR(10)) + ', NULL, NULL,NULL) AS os ON
                    ps.object_id=os.object_id and ps.index_id=os.index_id and ps.partition_number=os.partition_number 
                    WHERE 1=1 
                    ' + CASE WHEN @ObjectID IS NOT NULL THEN N'AND so.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) + N' ' ELSE N' ' END + '
                    ' + CASE WHEN @Filter = 2 THEN N'AND ps.reserved_page_count * 8./1024. &gt; ' + CAST(@FilterMB AS NVARCHAR(5)) + N' ' ELSE N' ' END + '
            ORDER BY ps.object_id,  ps.index_id, ps.partition_number
            OPTION    ( RECOMPILE );
            ';
        END
        ELSE
        BEGIN
        RAISERROR (N'Using 2012 syntax to query sys.dm_db_index_operational_stats',0,1) WITH NOWAIT;
		--This is the syntax that will be used if you change 2147483647 to 11 on line ~819.
		--If you have a lot of paritions and this suddenly starts running for a long time, change it back.
         SET @dsql = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                        SELECT  ' + CAST(@DatabaseID AS NVARCHAR(10)) + ' AS database_id,
                                ps.object_id, 
                                ps.index_id, 
                                ps.partition_number, 
                                ps.row_count,
                                ps.reserved_page_count * 8. / 1024. AS reserved_MB,
                                ps.lob_reserved_page_count * 8. / 1024. AS reserved_LOB_MB,
                                ps.row_overflow_reserved_page_count * 8. / 1024. AS reserved_row_overflow_MB,
                                os.leaf_insert_count, 
                                os.leaf_delete_count, 
                                os.leaf_update_count, 
                                os.range_scan_count, 
                                os.singleton_lookup_count,  
                                os.forwarded_fetch_count,
                                os.lob_fetch_in_pages, 
                                os.lob_fetch_in_bytes, 
                                os.row_overflow_fetch_in_pages,
                                os.row_overflow_fetch_in_bytes, 
                                os.row_lock_count, 
                                os.row_lock_wait_count,
                                os.row_lock_wait_in_ms, 
                                os.page_lock_count, 
                                os.page_lock_wait_count, 
                                os.page_lock_wait_in_ms,
                                os.index_lock_promotion_attempt_count, 
                                os.index_lock_promotion_count, 
                                ' + CASE WHEN @SQLServerProductVersion NOT LIKE '9%' THEN N'par.data_compression_desc ' ELSE N'null as data_compression_desc' END + N'
                        FROM    ' + QUOTENAME(@DatabaseName) + N'.sys.dm_db_partition_stats AS ps  
                        JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.partitions AS par on ps.partition_id=par.partition_id
                        JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects AS so ON ps.object_id = so.object_id
                                   AND so.is_ms_shipped = 0 /*Exclude objects shipped by Microsoft*/
                                   AND so.type &lt;&gt; ''TF'' /*Exclude table valued functions*/
                        OUTER APPLY ' + QUOTENAME(@DatabaseName) + N'.sys.dm_db_index_operational_stats('
                    + CAST(@DatabaseID AS NVARCHAR(10)) + N', ps.object_id, ps.index_id,ps.partition_number) AS os
                        WHERE 1=1 
                        ' + CASE WHEN @ObjectID IS NOT NULL THEN N'AND so.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) + N' ' ELSE N' ' END + N'
                        ' + CASE WHEN @Filter = 2 THEN N'AND ps.reserved_page_count * 8./1024. &gt; ' + CAST(@FilterMB AS NVARCHAR(5)) + N' ' ELSE N' ' END + '
                ORDER BY ps.object_id,  ps.index_id, ps.partition_number
                OPTION    ( RECOMPILE );
                ';
        END;       

        IF @dsql IS NULL 
            RAISERROR('@dsql is null',16,1);

        RAISERROR (N'Inserting data into #IndexPartitionSanity',0,1) WITH NOWAIT;
        INSERT    #IndexPartitionSanity ( [database_id],
                                          [object_id], 
                                          index_id, 
                                          partition_number, 
                                          row_count, 
                                          reserved_MB,
                                          reserved_LOB_MB, 
                                          reserved_row_overflow_MB, 
                                          leaf_insert_count,
                                          leaf_delete_count, 
                                          leaf_update_count, 
                                          range_scan_count,
                                          singleton_lookup_count,
                                          forwarded_fetch_count, 
                                          lob_fetch_in_pages, 
                                          lob_fetch_in_bytes, 
                                          row_overflow_fetch_in_pages,
                                          row_overflow_fetch_in_bytes, 
                                          row_lock_count, 
                                          row_lock_wait_count,
                                          row_lock_wait_in_ms, 
                                          page_lock_count, 
                                          page_lock_wait_count,
                                          page_lock_wait_in_ms, 
                                          index_lock_promotion_attempt_count,
                                          index_lock_promotion_count, 
                                          data_compression_desc )
                EXEC sp_executesql @dsql;
        
        RAISERROR (N'Updating index_sanity_id on #IndexPartitionSanity',0,1) WITH NOWAIT;
        UPDATE    #IndexPartitionSanity
        SET        index_sanity_id = i.index_sanity_id
        FROM #IndexPartitionSanity ps
                JOIN #IndexSanity i ON ps.[object_id] = i.[object_id]
                                        AND ps.index_id = i.index_id
                                        AND i.database_id = ps.database_id
		END; --End Check For @SkipPartitions = 0


        RAISERROR (N'Inserting data into #IndexSanitySize',0,1) WITH NOWAIT;
        INSERT    #IndexSanitySize ( [index_sanity_id], [database_id], partition_count, total_rows, total_reserved_MB,
                                     total_reserved_LOB_MB, total_reserved_row_overflow_MB, total_range_scan_count,
                                     total_singleton_lookup_count, total_leaf_delete_count, total_leaf_update_count, 
                                     total_forwarded_fetch_count,total_row_lock_count,
                                     total_row_lock_wait_count, total_row_lock_wait_in_ms, avg_row_lock_wait_in_ms,
                                     total_page_lock_count, total_page_lock_wait_count, total_page_lock_wait_in_ms,
                                     avg_page_lock_wait_in_ms, total_index_lock_promotion_attempt_count, 
                                     total_index_lock_promotion_count, data_compression_desc )
                SELECT    index_sanity_id, ipp.database_id, COUNT(*), SUM(row_count), SUM(reserved_MB), SUM(reserved_LOB_MB),
                        SUM(reserved_row_overflow_MB), 
                        SUM(range_scan_count),
                        SUM(singleton_lookup_count),
                        SUM(leaf_delete_count), 
                        SUM(leaf_update_count),
                        SUM(forwarded_fetch_count),
                        SUM(row_lock_count), 
                        SUM(row_lock_wait_count),
                        SUM(row_lock_wait_in_ms), 
                        CASE WHEN SUM(row_lock_wait_in_ms) &gt; 0 THEN
                            SUM(row_lock_wait_in_ms)/(1.*SUM(row_lock_wait_count))
                        ELSE 0 END AS avg_row_lock_wait_in_ms,           
                        SUM(page_lock_count), 
                        SUM(page_lock_wait_count),
                        SUM(page_lock_wait_in_ms), 
                        CASE WHEN SUM(page_lock_wait_in_ms) &gt; 0 THEN
                            SUM(page_lock_wait_in_ms)/(1.*SUM(page_lock_wait_count))
                        ELSE 0 END AS avg_page_lock_wait_in_ms,           
                        SUM(index_lock_promotion_attempt_count),
                        SUM(index_lock_promotion_count),
                        LEFT(MAX(data_compression_info.data_compression_rollup),8000)
                FROM #IndexPartitionSanity ipp
                /* individual partitions can have distinct compression settings, just roll them into a list here*/
                OUTER APPLY (SELECT STUFF((
                    SELECT    N', ' + data_compression_desc
                    FROM #IndexPartitionSanity ipp2
                    WHERE ipp.[object_id]=ipp2.[object_id]
                        AND ipp.[index_id]=ipp2.[index_id]
                        AND ipp.database_id = @DatabaseID
                    ORDER BY ipp2.partition_number
                    FOR      XML PATH(''),TYPE).value('.', 'varchar(max)'), 1, 1, '')) 
                        data_compression_info(data_compression_rollup)
                WHERE ipp.database_id = @DatabaseID
                GROUP BY index_sanity_id, ipp.database_id
                ORDER BY index_sanity_id 
        OPTION    ( RECOMPILE );

        RAISERROR (N'Adding UQ index on #IndexSanity (database_id, object_id, index_id)',0,1) WITH NOWAIT;
        IF NOT EXISTS(SELECT 1 FROM tempdb.sys.indexes WHERE name='uq_database_id_object_id_index_id') 
            CREATE UNIQUE INDEX uq_database_id_object_id_index_id ON #IndexSanity (database_id, object_id, index_id);

        RAISERROR (N'Inserting data into #MissingIndexes',0,1) WITH NOWAIT;
        SET @dsql=N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
                SELECT    id.object_id, ' + QUOTENAME(@DatabaseName,'''') + N', sc.[name], so.[name], id.statement , gs.avg_total_user_cost, 
                        gs.avg_user_impact, gs.user_seeks, gs.user_scans, gs.unique_compiles,id.equality_columns, 
                        id.inequality_columns,id.included_columns
                FROM    sys.dm_db_missing_index_groups ig
                        JOIN sys.dm_db_missing_index_details id ON ig.index_handle = id.index_handle
                        JOIN sys.dm_db_missing_index_group_stats gs ON ig.index_group_handle = gs.group_handle
                        JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects so on 
                            id.object_id=so.object_id
                        JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.schemas sc on 
                            so.schema_id=sc.schema_id
                WHERE    id.database_id = ' + CAST(@DatabaseID AS NVARCHAR(30)) + '
                ' + CASE WHEN @ObjectID IS NULL THEN N'' 
                    ELSE N'and id.object_id=' + CAST(@ObjectID AS NVARCHAR(30)) 
                END +
        N'OPTION (RECOMPILE);'

        IF @dsql IS NULL 
            RAISERROR('@dsql is null',16,1);
        INSERT    #MissingIndexes ( [object_id], [database_name], [schema_name], [table_name], [statement], avg_total_user_cost, 
                                    avg_user_impact, user_seeks, user_scans, unique_compiles, equality_columns, 
                                    inequality_columns,included_columns)
        EXEC sp_executesql @dsql;

        SET @dsql = N'
            SELECT ' + QUOTENAME(@DatabaseName,'''')  + N' AS [database_name],
                fk_object.name AS foreign_key_name,
                parent_object.[object_id] AS parent_object_id,
                parent_object.name AS parent_object_name,
                referenced_object.[object_id] AS referenced_object_id,
                referenced_object.name AS referenced_object_name,
                fk.is_disabled,
                fk.is_not_trusted,
                fk.is_not_for_replication,
                parent.fk_columns,
                referenced.fk_columns,
                [update_referential_action_desc],
                [delete_referential_action_desc]
            FROM ' + QUOTENAME(@DatabaseName) + N'.sys.foreign_keys fk
            JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects fk_object ON fk.object_id=fk_object.object_id
            JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects parent_object ON fk.parent_object_id=parent_object.object_id
            JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.objects referenced_object ON fk.referenced_object_id=referenced_object.object_id
            CROSS APPLY ( SELECT    STUFF( (SELECT    N'', '' + c_parent.name AS fk_columns
                                            FROM    ' + QUOTENAME(@DatabaseName) + N'.sys.foreign_key_columns fkc 
                                            JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.columns c_parent ON fkc.parent_object_id=c_parent.[object_id]
                                                AND fkc.parent_column_id=c_parent.column_id
                                            WHERE    fk.parent_object_id=fkc.parent_object_id
                                                AND fk.[object_id]=fkc.constraint_object_id
                                            ORDER BY fkc.constraint_column_id 
                                    FOR      XML PATH('''') ,
                                              TYPE).value(''.'', ''varchar(max)''), 1, 1, '''')/*This is how we remove the first comma*/ ) parent ( fk_columns )
            CROSS APPLY ( SELECT    STUFF( (SELECT    N'', '' + c_referenced.name AS fk_columns
                                            FROM    ' + QUOTENAME(@DatabaseName) + N'.sys.    foreign_key_columns fkc 
                                            JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.columns c_referenced ON fkc.referenced_object_id=c_referenced.[object_id]
                                                AND fkc.referenced_column_id=c_referenced.column_id
                                            WHERE    fk.referenced_object_id=fkc.referenced_object_id
                                                and fk.[object_id]=fkc.constraint_object_id
                                            ORDER BY fkc.constraint_column_id  /*order by col name, we don''t have anything better*/
                                    FOR      XML PATH('''') ,
                                              TYPE).value(''.'', ''varchar(max)''), 1, 1, '''') ) referenced ( fk_columns )
            ' + CASE WHEN @ObjectID IS NOT NULL THEN 
                    'WHERE fk.parent_object_id=' + CAST(@ObjectID AS NVARCHAR(30)) + N' OR fk.referenced_object_id=' + CAST(@ObjectID AS NVARCHAR(30)) + N' ' 
                    ELSE N' ' END + '
            ORDER BY parent_object_name, foreign_key_name
			OPTION (RECOMPILE);';
        IF @dsql IS NULL 
            RAISERROR('@dsql is null',16,1);

        RAISERROR (N'Inserting data into #ForeignKeys',0,1) WITH NOWAIT;
        INSERT  #ForeignKeys ( [database_name], foreign_key_name, parent_object_id,parent_object_name, referenced_object_id, referenced_object_name,
                                is_disabled, is_not_trusted, is_not_for_replication, parent_fk_columns, referenced_fk_columns,
                                [update_referential_action_desc], [delete_referential_action_desc] )
                EXEC sp_executesql @dsql;

        RAISERROR (N'Updating #IndexSanity.referenced_by_foreign_key',0,1) WITH NOWAIT;
        UPDATE #IndexSanity
            SET is_referenced_by_foreign_key=1
        FROM #IndexSanity s
        JOIN #ForeignKeys fk ON 
            s.object_id=fk.referenced_object_id
            AND LEFT(s.key_column_names,LEN(fk.referenced_fk_columns)) = fk.referenced_fk_columns

        RAISERROR (N'Update index_secret on #IndexSanity for NC indexes.',0,1) WITH NOWAIT;
        UPDATE nc 
        SET secret_columns=
            N'[' + 
            CASE tb.count_key_columns WHEN 0 THEN '1' ELSE CAST(tb.count_key_columns AS VARCHAR(10)) END +
            CASE nc.is_unique WHEN 1 THEN N' INCLUDE' ELSE N' KEY' END +
            CASE WHEN tb.count_key_columns &gt; 1 THEN  N'S] ' ELSE N'] ' END +
            CASE tb.index_id WHEN 0 THEN '[RID]' ELSE LTRIM(tb.key_column_names) +
                /* Uniquifiers only needed on non-unique clustereds-- not heaps */
                CASE tb.is_unique WHEN 0 THEN ' [UNIQUIFIER]' ELSE N'' END
            END
            , count_secret_columns=
            CASE tb.index_id WHEN 0 THEN 1 ELSE 
                tb.count_key_columns +
                    CASE tb.is_unique WHEN 0 THEN 1 ELSE 0 END
            END
        FROM #IndexSanity AS nc
        JOIN #IndexSanity AS tb ON nc.object_id=tb.object_id
            AND tb.index_id IN (0,1) 
        WHERE nc.index_id &gt; 1;

        RAISERROR (N'Update index_secret on #IndexSanity for heaps and non-unique clustered.',0,1) WITH NOWAIT;
        UPDATE tb
        SET secret_columns=    CASE tb.index_id WHEN 0 THEN '[RID]' ELSE '[UNIQUIFIER]' END
            , count_secret_columns = 1
        FROM #IndexSanity AS tb
        WHERE tb.index_id = 0 /*Heaps-- these have the RID */
            OR (tb.index_id=1 AND tb.is_unique=0); /* Non-unique CX: has uniquifer (when needed) */


        RAISERROR (N'Populate #IndexCreateTsql.',0,1) WITH NOWAIT;
        INSERT #IndexCreateTsql (index_sanity_id, create_tsql)
        SELECT
            index_sanity_id,
            ISNULL (
            /* Script drops for disabled non-clustered indexes*/
            CASE WHEN is_disabled = 1 AND index_id &lt;&gt; 1
                THEN N'--DROP INDEX ' + QUOTENAME([index_name]) + N' ON '
                 + QUOTENAME([schema_name]) + N'.' + QUOTENAME([object_name]) 
            ELSE
                CASE index_id WHEN 0 THEN N'--I''m a Heap!' 
                ELSE 
                    CASE WHEN is_XML = 1 OR is_spatial=1 THEN N'' /* Not even trying for these just yet...*/
                    ELSE 
                        CASE WHEN is_primary_key=1 THEN
                            N'ALTER TABLE ' + QUOTENAME([schema_name]) +
                                N'.' + QUOTENAME([object_name]) + 
                                N' ADD CONSTRAINT [' +
                                index_name + 
                                N'] PRIMARY KEY ' + 
                                CASE WHEN index_id=1 THEN N'CLUSTERED (' ELSE N'(' END +
                                key_column_names_with_sort_order_no_types + N' )' 
                            WHEN is_CX_columnstore= 1 THEN
                                 N'CREATE CLUSTERED COLUMNSTORE INDEX ' + QUOTENAME(index_name) + N' on ' + QUOTENAME([schema_name]) + '.' + QUOTENAME([object_name])
                        ELSE /*Else not a PK or cx columnstore */ 
                            N'CREATE ' + 
                            CASE WHEN is_unique=1 THEN N'UNIQUE ' ELSE N'' END +
                            CASE WHEN index_id=1 THEN N'CLUSTERED ' ELSE N'' END +
                            CASE WHEN is_NC_columnstore=1 THEN N'NONCLUSTERED COLUMNSTORE ' 
                            ELSE N'' END +
                            N'INDEX ['
                                 + index_name + N'] ON ' + 
                                QUOTENAME([schema_name]) + '.' + QUOTENAME([object_name]) + 
                                    CASE WHEN is_NC_columnstore=1 THEN 
                                        N' (' + ISNULL(include_column_names_no_types,'') +  N' )' 
                                    ELSE /*Else not colunnstore */ 
                                        N' (' + ISNULL(key_column_names_with_sort_order_no_types,'') +  N' )' 
                                        + CASE WHEN include_column_names_no_types IS NOT NULL THEN 
                                            N' INCLUDE (' + include_column_names_no_types + N')' 
                                            ELSE N'' 
                                        END
                                    END /*End non-colunnstore case */ 
                                + CASE WHEN filter_definition &lt;&gt; N'' THEN N' WHERE ' + filter_definition ELSE N'' END
                            END /*End Non-PK index CASE */ 
                        + CASE WHEN is_NC_columnstore=0 AND is_CX_columnstore=0 THEN
                            N' WITH (' 
                                + N'FILLFACTOR=' + CASE fill_factor WHEN 0 THEN N'100' ELSE CAST(fill_factor AS NVARCHAR(5)) END + ', '
                                + N'ONLINE=?, SORT_IN_TEMPDB=?'
                            + N')'
                        ELSE N'' END
                        + N';'
                      END /*End non-spatial and non-xml CASE */ 
                END
            END, '[Unknown Error]')
                AS create_tsql
        FROM #IndexSanity
        WHERE database_id = @DatabaseID;
	  
	  RAISERROR (N'Populate #PartitionCompressionInfo.',0,1) WITH NOWAIT;
	 ;WITH    [maps]
			  AS ( SELECT   
							index_sanity_id,
							partition_number,
							data_compression_desc,
							partition_number - ROW_NUMBER() OVER (PARTITION BY ips.index_sanity_id, data_compression_desc ORDER BY partition_number ) AS [rN]
				   FROM     #IndexPartitionSanity ips
					),
			[grps]
			  AS ( SELECT   MIN([maps].[partition_number]) AS [MinKey] ,
							MAX([maps].[partition_number]) AS [MaxKey] ,
							index_sanity_id,
							maps.data_compression_desc
				   FROM     [maps]
				   GROUP BY [maps].[rN], index_sanity_id, maps.data_compression_desc)
		INSERT #PartitionCompressionInfo
				(index_sanity_id, partition_compression_detail)
		SELECT DISTINCT grps.index_sanity_id , SUBSTRING((  STUFF((SELECT ', ' + ' Partition'
													+ CASE WHEN [grps2].[MinKey] &lt; [grps2].[MaxKey]
														   THEN +'s '
																+ CAST([grps2].[MinKey] AS VARCHAR)
																+ ' - '
																+ CAST([grps2].[MaxKey] AS VARCHAR)
																+ ' use ' + grps2.data_compression_desc
														   ELSE ' '
																+ CAST([grps2].[MinKey] AS VARCHAR)
																+ ' uses '  + grps2.data_compression_desc
													  END AS [Partitions]
											 FROM   [grps] AS grps2
											 WHERE grps2.index_sanity_id = grps.index_sanity_id
											 ORDER BY grps2.MinKey, grps2.MaxKey
									FOR     XML PATH('') ,
												TYPE 
							).[value]('.', 'VARCHAR(MAX)'), 1, 1, '') ), 0, 8000) AS [partition_compression_detail]
		FROM grps;
		
		RAISERROR (N'Update #PartitionCompressionInfo.',0,1) WITH NOWAIT;
		UPDATE sz
		SET sz.data_compression_desc = pci.partition_compression_detail
		FROM #IndexSanitySize sz
		JOIN #PartitionCompressionInfo AS pci
		ON pci.index_sanity_id = sz.index_sanity_id;
                  



		IF @SkipStatistics = 0 
			BEGIN
		IF  ((PARSENAME(@SQLServerProductVersion, 4) &gt;= 12)
		OR   (PARSENAME(@SQLServerProductVersion, 4) = 11 AND PARSENAME(@SQLServerProductVersion, 2) &gt;= 3000)
		OR   (PARSENAME(@SQLServerProductVersion, 4) = 10 AND PARSENAME(@SQLServerProductVersion, 3) = 50 AND PARSENAME(@SQLServerProductVersion, 2) &gt;= 2500))
		BEGIN
		RAISERROR (N'Gathering Statistics Info With Newer Syntax.',0,1) WITH NOWAIT;
		SET @dsql=N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
					SELECT  ' + QUOTENAME(@DatabaseName,'''') + N' AS database_name,
					obj.name AS table_name,
					sch.name AS schema_name,
			        ISNULL(i.name, ''System Or User Statistic'') AS index_name,
			        c.name AS column_name,
			        s.name AS statistics_name,
			        CONVERT(DATETIME, ddsp.last_updated) AS last_statistics_update,
			        DATEDIFF(DAY, ddsp.last_updated, GETDATE()) AS days_since_last_stats_update,
			        ddsp.rows,
			        ddsp.rows_sampled,
			        CAST(ddsp.rows_sampled / ( 1. * NULLIF(ddsp.rows, 0) ) * 100 AS DECIMAL(18, 1)) AS percent_sampled,
			        ddsp.steps AS histogram_steps,
			        ddsp.modification_counter,
			        CASE WHEN ddsp.modification_counter &gt; 0
			             THEN CAST(ddsp.modification_counter / ( 1. * NULLIF(ddsp.rows, 0) ) * 100 AS DECIMAL(18, 1))
			             ELSE ddsp.modification_counter
			        END AS percent_modifications,
			        CASE WHEN ddsp.rows &lt; 500 THEN 500
			             ELSE CAST(( ddsp.rows * .20 ) + 500 AS INT)
			        END AS modifications_before_auto_update,
			        ISNULL(i.type_desc, ''System Or User Statistic - N/A'') AS index_type_desc,
			        CONVERT(DATETIME, obj.create_date) AS table_create_date,
			        CONVERT(DATETIME, obj.modify_date) AS table_modify_date,
					s.no_recompute,
					s.has_filter,
					s.filter_definition
			FROM    ' + QUOTENAME(@DatabaseName) + N'.sys.stats AS s
			JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.stats_columns sc
			ON      sc.object_id = s.object_id
			        AND sc.stats_id = s.stats_id
			JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.columns c
			ON      c.object_id = sc.object_id
			        AND c.column_id = sc.column_id
			JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.objects obj
			ON      s.object_id = obj.object_id
			JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.schemas sch
			ON		sch.schema_id = obj.schema_id
			LEFT JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.indexes AS i
			ON      i.object_id = s.object_id
			        AND i.index_id = s.stats_id
			OUTER APPLY ' + QUOTENAME(@DatabaseName) + N'.sys.dm_db_stats_properties(s.object_id, s.stats_id) AS ddsp
			WHERE obj.is_ms_shipped = 0
			OPTION (RECOMPILE);'
			
			IF @dsql IS NULL 
            RAISERROR('@dsql is null',16,1);

			RAISERROR (N'Inserting data into #Statistics',0,1) WITH NOWAIT;
			INSERT #Statistics ( database_name, table_name, schema_name, index_name, column_name, statistics_name, last_statistics_update, 
								days_since_last_stats_update, rows, rows_sampled, percent_sampled, histogram_steps, modification_counter, 
								percent_modifications, modifications_before_auto_update, index_type_desc, table_create_date, table_modify_date,
								no_recompute, has_filter, filter_definition)
			
			EXEC sp_executesql @dsql;
			END
			ELSE 
			BEGIN
			RAISERROR (N'Gathering Statistics Info With Older Syntax.',0,1) WITH NOWAIT;
			SET @dsql=N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
						SELECT  ' + QUOTENAME(@DatabaseName,'''') + N' AS database_name,
								obj.name AS table_name,
								sch.name AS schema_name,
						        ISNULL(i.name, ''System Or User Statistic'') AS index_name,
						        c.name AS column_name,
						        s.name AS statistics_name,
						        CONVERT(DATETIME, STATS_DATE(s.object_id, s.stats_id)) AS last_statistics_update,
						        DATEDIFF(DAY, STATS_DATE(s.object_id, s.stats_id), GETDATE()) AS days_since_last_stats_update,
						        si.rowcnt,
						        si.rowmodctr,
						        CASE WHEN si.rowmodctr &gt; 0 THEN CAST(si.rowmodctr / ( 1. * NULLIF(si.rowcnt, 0) ) * 100 AS DECIMAL(18, 1))
						             ELSE si.rowmodctr
						        END AS percent_modifications,
						        CASE WHEN si.rowcnt &lt; 500 THEN 500
						             ELSE CAST(( si.rowcnt * .20 ) + 500 AS INT)
						        END AS modifications_before_auto_update,
						        ISNULL(i.type_desc, ''System Or User Statistic - N/A'') AS index_type_desc,
						        CONVERT(DATETIME, obj.create_date) AS table_create_date,
						        CONVERT(DATETIME, obj.modify_date) AS table_modify_date,
								s.no_recompute,
								'
								+ CASE WHEN @SQLServerProductVersion NOT LIKE '9%' 
								THEN N's.has_filter,
									   s.filter_definition' 
								ELSE N'NULL AS has_filter,
								       NULL AS filter_definition' END 
						+ N'								
						FROM    ' + QUOTENAME(@DatabaseName) + N'.sys.stats AS s
						INNER HASH JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.sysindexes si
						ON      si.name = s.name
						INNER HASH JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.stats_columns sc
						ON      sc.object_id = s.object_id
						        AND sc.stats_id = s.stats_id
						INNER HASH JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.columns c
						ON      c.object_id = sc.object_id
						        AND c.column_id = sc.column_id
						INNER HASH JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.objects obj
						ON      s.object_id = obj.object_id
						INNER HASH JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.schemas sch
						ON		sch.schema_id = obj.schema_id
						LEFT HASH JOIN ' + QUOTENAME(@DatabaseName) + N'.sys.indexes AS i
						ON      i.object_id = s.object_id
						        AND i.index_id = s.stats_id
						WHERE obj.is_ms_shipped = 0
						AND si.rowcnt &gt; 0
						OPTION (RECOMPILE);'

			IF @dsql IS NULL 
            RAISERROR('@dsql is null',16,1);

			RAISERROR (N'Inserting data into #Statistics',0,1) WITH NOWAIT;
			INSERT #Statistics(database_name, table_name, schema_name, index_name, column_name, statistics_name, 
								last_statistics_update, days_since_last_stats_update, rows, modification_counter, 
								percent_modifications, modifications_before_auto_update, index_type_desc, table_create_date, table_modify_date,
								no_recompute, has_filter, filter_definition)
			
			EXEC sp_executesql @dsql;
			END

			END

			IF  (PARSENAME(@SQLServerProductVersion, 4) &gt;= 10)
			BEGIN
			RAISERROR (N'Gathering Computed Column Info.',0,1) WITH NOWAIT;
			SET @dsql=N'SELECT ' + QUOTENAME(@DatabaseName,'''') + N' AS DatabaseName,
   					   		   t.name AS table_name,
   					           s.name AS schema_name,
   					           c.name AS column_name,
   					           cc.is_nullable,
   					           cc.definition,
   					           cc.uses_database_collation,
   					           cc.is_persisted,
   					           cc.is_computed,
   					   		   CASE WHEN cc.definition LIKE ''%.%'' THEN 1 ELSE 0 END AS is_function,
   					   		   ''ALTER TABLE '' + QUOTENAME(s.name) + ''.'' + QUOTENAME(t.name) + 
   					   		   '' ADD '' + QUOTENAME(c.name) + '' AS '' + cc.definition  + 
							   CASE WHEN is_persisted = 1 THEN '' PERSISTED'' ELSE '''' END + '';'' COLLATE DATABASE_DEFAULT AS [column_definition]
   					   FROM    ' + QUOTENAME(@DatabaseName) + N'.sys.computed_columns AS cc
   					   JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.columns AS c
   					   ON      cc.object_id = c.object_id
   					   		   AND cc.column_id = c.column_id
   					   JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.tables AS t
   					   ON      t.object_id = cc.object_id
   					   JOIN    ' + QUOTENAME(@DatabaseName) + N'.sys.schemas AS s
   					   ON      s.schema_id = t.schema_id
					   OPTION (RECOMPILE);'

			IF @dsql IS NULL 
            RAISERROR('@dsql is null',16,1);

			INSERT #ComputedColumns
			        ( database_name, table_name, schema_name, column_name, is_nullable, definition, 
					  uses_database_collation, is_persisted, is_computed, is_function, column_definition )			
			EXEC sp_executesql @dsql;

			END 
			
			RAISERROR (N'Gathering Trace Flag Information',0,1) WITH NOWAIT;
			INSERT #TraceStatus
			EXEC ('DBCC TRACESTATUS(-1) WITH NO_INFOMSGS')			
			
END                    
END TRY
BEGIN CATCH
        RAISERROR (N'Failure populating temp tables.', 0,1) WITH NOWAIT;

        IF @dsql IS NOT NULL
        BEGIN
            SET @msg= 'Last @dsql: ' + @dsql;
            RAISERROR(@msg, 0, 1) WITH NOWAIT;
        END

        SELECT    @msg = @DatabaseName + N' database failed to process. ' + ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE();
        RAISERROR (@msg,@ErrorSeverity, @ErrorState )WITH NOWAIT;
        
        
        WHILE @@trancount &gt; 0 
            ROLLBACK;

        RETURN;
END CATCH;
 FETCH NEXT FROM c1 INTO @DatabaseName
END
DEALLOCATE c1;

----------------------------------------
--STEP 2: DIAGNOSE THE PATIENT
--EVERY QUERY AFTER THIS GOES AGAINST TEMP TABLES ONLY.
----------------------------------------
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                BEGIN TRY
----------------------------------------
--If @TableName is specified, just return information for that table.
--The @Mode parameter doesn't matter if you're looking at a specific table.
----------------------------------------
IF @TableName IS NOT NULL
BEGIN
    RAISERROR(N'@TableName specified, giving detail only on that table.', 0,1) WITH NOWAIT;

    --We do a left join here in case this is a disabled NC.
    --In that case, it won't have any size info/pages allocated.
 
   	
	   WITH table_mode_cte AS (
        SELECT 
            s.db_schema_object_indexid, 
            s.key_column_names,
            s.index_definition, 
            ISNULL(s.secret_columns,N'') AS secret_columns,
            s.fill_factor,
            s.index_usage_summary, 
            sz.index_op_stats,
            ISNULL(sz.index_size_summary,'') /*disabled NCs will be null*/ AS index_size_summary,
			partition_compression_detail ,
            ISNULL(sz.index_lock_wait_summary,'') AS index_lock_wait_summary,
            s.is_referenced_by_foreign_key,
            (SELECT COUNT(*)
                FROM #ForeignKeys fk WHERE fk.parent_object_id=s.object_id
                AND PATINDEX (fk.parent_fk_columns, s.key_column_names)=1) AS FKs_covered_by_index,
            s.last_user_seek,
            s.last_user_scan,
            s.last_user_lookup,
            s.last_user_update,
            s.create_date,
            s.modify_date,
            ct.create_tsql,
            1 AS display_order
        FROM #IndexSanity s
        LEFT JOIN #IndexSanitySize sz ON 
            s.index_sanity_id=sz.index_sanity_id
        LEFT JOIN #IndexCreateTsql ct ON 
            s.index_sanity_id=ct.index_sanity_id
		LEFT JOIN #PartitionCompressionInfo pci ON 
			pci.index_sanity_id = s.index_sanity_id
        WHERE s.[object_id]=@ObjectID
        UNION ALL
        SELECT     N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + CONVERT(NVARCHAR(16),GETDATE(),121) +             
                N' (' + @ScriptVersionName + ')' ,   
                N'SQL Server First Responder Kit' ,   
                N'http://FirstResponderKit.org' ,
                N'From Your Community Volunteers',
                NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                0 AS display_order
    )
    SELECT 
            db_schema_object_indexid AS [Details: db_schema.table.index(indexid)], 
            index_definition AS [Definition: [Property]] ColumnName {datatype maxbytes}], 
            secret_columns AS [Secret Columns],
            fill_factor AS [Fillfactor],
            index_usage_summary AS [Usage Stats], 
            index_op_stats AS [Op Stats],
            index_size_summary AS [Size],
			partition_compression_detail AS [Compression Type],
            index_lock_wait_summary AS [Lock Waits],
            is_referenced_by_foreign_key AS [Referenced by FK?],
            FKs_covered_by_index AS [FK Covered by Index?],
            last_user_seek AS [Last User Seek],
            last_user_scan AS [Last User Scan],
            last_user_lookup AS [Last User Lookup],
            last_user_update AS [Last User Write],
            create_date AS [Created],
            modify_date AS [Last Modified],
            create_tsql AS [Create TSQL]
    FROM table_mode_cte
    ORDER BY display_order ASC, key_column_names ASC
    OPTION    ( RECOMPILE );                        

    IF (SELECT TOP 1 [object_id] FROM    #MissingIndexes mi) IS NOT NULL
    BEGIN  
        SELECT  N'Missing index.' AS Finding ,
                N'http://BrentOzar.com/go/Indexaphobia' AS URL ,
                mi.[statement] + 
                ' Est. Benefit: '
                    + CASE WHEN magic_benefit_number &gt;= 922337203685477 THEN '&gt;= 922,337,203,685,477'
                    ELSE REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(
                                        (magic_benefit_number/@DaysUptime)
                                        AS BIGINT) AS MONEY), 1), '.00', '')
                    END AS [Estimated Benefit],
                missing_index_details AS [Missing Index Request] ,
                index_estimated_impact AS [Estimated Impact],
                create_tsql AS [Create TSQL]
        FROM    #MissingIndexes mi
        WHERE   [object_id] = @ObjectID
                /* Minimum benefit threshold = 100k/day of uptime */
        AND (magic_benefit_number/@DaysUptime) &gt;= 100000
        ORDER BY magic_benefit_number DESC
        OPTION    ( RECOMPILE );
    END       
    ELSE     
    SELECT 'No missing indexes.' AS finding;

    SELECT     
        column_name AS [Column Name],
        (SELECT COUNT(*)  
            FROM #IndexColumns c2 
            WHERE c2.column_name=c.column_name
            AND c2.key_ordinal IS NOT NULL)
        + CASE WHEN c.index_id = 1 AND c.key_ordinal IS NOT NULL THEN
            -1+ (SELECT COUNT(DISTINCT index_id)
            FROM #IndexColumns c3
            WHERE c3.index_id NOT IN (0,1))
            ELSE 0 END
                AS [Found In],
        system_type_name + 
            CASE max_length WHEN -1 THEN N' (max)' ELSE
                CASE  
                    WHEN system_type_name IN (N'char',N'nchar',N'binary',N'varbinary') THEN N' (' + CAST(max_length AS NVARCHAR(20)) + N')' 
                    WHEN system_type_name IN (N'varchar',N'nvarchar') THEN N' (' + CAST(max_length/2 AS NVARCHAR(20)) + N')' 
                    ELSE '' 
                END
            END
            AS [Type],
        CASE is_computed WHEN 1 THEN 'yes' ELSE '' END AS [Computed?],
        max_length AS [Length (max bytes)],
        [precision] AS [Prec],
        [scale] AS [Scale],
        CASE is_nullable WHEN 1 THEN 'yes' ELSE '' END AS [Nullable?],
        CASE is_identity WHEN 1 THEN 'yes' ELSE '' END AS [Identity?],
        CASE is_replicated WHEN 1 THEN 'yes' ELSE '' END AS [Replicated?],
        CASE is_sparse WHEN 1 THEN 'yes' ELSE '' END AS [Sparse?],
        CASE is_filestream WHEN 1 THEN 'yes' ELSE '' END AS [Filestream?],
        collation_name AS [Collation]
    FROM #IndexColumns AS c
    WHERE index_id IN (0,1);

    IF (SELECT TOP 1 parent_object_id FROM #ForeignKeys) IS NOT NULL
    BEGIN
        SELECT [database_name] + N':' + parent_object_name + N': ' + foreign_key_name AS [Foreign Key],
            parent_fk_columns AS [Foreign Key Columns],
            referenced_object_name AS [Referenced Table],
            referenced_fk_columns AS [Referenced Table Columns],
            is_disabled AS [Is Disabled?],
            is_not_trusted AS [Not Trusted?],
            is_not_for_replication [Not for Replication?],
            [update_referential_action_desc] AS [Cascading Updates?],
            [delete_referential_action_desc] AS [Cascading Deletes?]
        FROM #ForeignKeys
        ORDER BY [Foreign Key]
        OPTION    ( RECOMPILE );
    END
    ELSE
    SELECT 'No foreign keys.' AS finding;
END 

--If @TableName is NOT specified...
--Act based on the @Mode and @Filter. (@Filter applies only when @Mode=0 "diagnose")
ELSE
BEGIN;
    IF @Mode IN (0, 4) /* DIAGNOSE*/
    BEGIN;
        RAISERROR(N'@Mode=0 or 4, we are diagnosing.', 0,1) WITH NOWAIT;

        ----------------------------------------
        --Multiple Index Personalities: Check_id 0-10
        ----------------------------------------
        BEGIN;

        --SELECT    [object_id], key_column_names, database_id
        --                   FROM        #IndexSanity
        --                   WHERE  index_type IN (1,2) /* Clustered, NC only*/
        --                        AND is_hypothetical = 0
        --                        AND is_disabled = 0
        --                   GROUP BY    [object_id], key_column_names, database_id
        --                   HAVING    COUNT(*) &gt; 1


        RAISERROR('check_id 1: Duplicate keys', 0,1) WITH NOWAIT;
            WITH    duplicate_indexes
                      AS ( SELECT    [object_id], key_column_names, database_id
                           FROM        #IndexSanity
                           WHERE  index_type IN (1,2) /* Clustered, NC only*/
                                AND is_hypothetical = 0
                                AND is_disabled = 0
								AND is_primary_key = 0
                           GROUP BY    [object_id], key_column_names, database_id
                           HAVING    COUNT(*) &gt; 1)
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    1 AS check_id, 
                                ip.index_sanity_id,
                                50 AS Priority,
                                'Multiple Index Personalities' AS findings_group,
                                'Duplicate keys' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/duplicateindex' AS URL,
                                N'Index Name: ' + ip.index_name + N' Table Name: ' + ip.db_schema_object_name AS details,
                                ip.index_definition, 
                                ip.secret_columns, 
                                ip.index_usage_summary,
                                ips.index_size_summary
                        FROM    duplicate_indexes di
                                JOIN #IndexSanity ip ON di.[object_id] = ip.[object_id]
                                                         AND ip.database_id = di.database_id
                                                         AND di.key_column_names = ip.key_column_names
                                JOIN #IndexSanitySize ips ON ip.index_sanity_id = ips.index_sanity_id AND ip.database_id = ips.database_id
                        /* WHERE clause limits to only @ThresholdMB or larger duplicate indexes when getting all databases or using PainRelief mode */
                        WHERE ips.total_reserved_MB &gt;= CASE WHEN (@GetAllDatabases = 1 OR @Mode = 0) THEN @ThresholdMB ELSE ips.total_reserved_MB END
						AND ip.is_primary_key = 0
                        ORDER BY ip.object_id, ip.key_column_names_with_sort_order    
                OPTION    ( RECOMPILE );

        RAISERROR('check_id 2: Keys w/ identical leading columns.', 0,1) WITH NOWAIT;
            WITH    borderline_duplicate_indexes
                      AS ( SELECT DISTINCT [object_id], first_key_column_name, key_column_names,
                                    COUNT([object_id]) OVER ( PARTITION BY [object_id], first_key_column_name ) AS number_dupes
                           FROM        #IndexSanity
                           WHERE index_type IN (1,2) /* Clustered, NC only*/
                            AND is_hypothetical=0
                            AND is_disabled=0
							AND is_primary_key = 0)
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    2 AS check_id, 
                                ip.index_sanity_id,
                                60 AS Priority,
                                'Multiple Index Personalities' AS findings_group,
                                'Borderline duplicate keys' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/duplicateindex' AS URL,
                                ip.db_schema_object_indexid AS details, 
                                ip.index_definition, 
                                ip.secret_columns,
                                ip.index_usage_summary,
                                ips.index_size_summary
                        FROM    #IndexSanity AS ip 
                        JOIN #IndexSanitySize ips ON ip.index_sanity_id = ips.index_sanity_id
                        WHERE EXISTS (
                            SELECT di.[object_id]
                            FROM borderline_duplicate_indexes AS di
                            WHERE di.[object_id] = ip.[object_id] AND
                                di.first_key_column_name = ip.first_key_column_name AND
                                di.key_column_names &lt;&gt; ip.key_column_names AND
                                di.number_dupes &gt; 1    
                        )
						AND ip.is_primary_key = 0
                        /* WHERE clause skips near-duplicate indexes when getting all databases or using PainRelief mode */
                        AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                                                
                        ORDER BY ip.[schema_name], ip.[object_name], ip.key_column_names, ip.include_column_names
            OPTION    ( RECOMPILE );

        END
        ----------------------------------------
        --Aggressive Indexes: Check_id 10-19
        ----------------------------------------
        BEGIN;

        RAISERROR(N'check_id 11: Total lock wait time &gt; 5 minutes (row + page) with long average waits', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                SELECT    11 AS check_id, 
                        i.index_sanity_id,
                        10 AS Priority,
                        N'Aggressive Indexes' AS findings_group,
                        N'Total lock wait time &gt; 5 minutes (row + page) with long average waits' AS finding, 
                        [database_name] AS [Database Name],
                        N'http://BrentOzar.com/go/AggressiveIndexes' AS URL,
                        i.db_schema_object_indexid + N': ' +
                            sz.index_lock_wait_summary AS details, 
                        i.index_definition,
                        i.secret_columns,
                        i.index_usage_summary,
                        sz.index_size_summary
                FROM    #IndexSanity AS i
                JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
                WHERE    (total_row_lock_wait_in_ms + total_page_lock_wait_in_ms) &gt; 300000
				AND (sz.avg_page_lock_wait_in_ms + sz.avg_row_lock_wait_in_ms) &gt; 5000
                OPTION    ( RECOMPILE );

        RAISERROR(N'check_id 12: Total lock wait time &gt; 5 minutes (row + page) with short average waits', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                SELECT    12 AS check_id, 
                        i.index_sanity_id,
                        10 AS Priority,
                        N'Aggressive Indexes' AS findings_group,
                        N'Total lock wait time &gt; 5 minutes (row + page) with short average waits' AS finding, 
                        [database_name] AS [Database Name],
                        N'http://BrentOzar.com/go/AggressiveIndexes' AS URL,
                        i.db_schema_object_indexid + N': ' +
                            sz.index_lock_wait_summary AS details, 
                        i.index_definition,
                        i.secret_columns,
                        i.index_usage_summary,
                        sz.index_size_summary
                FROM    #IndexSanity AS i
                JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
                WHERE    (total_row_lock_wait_in_ms + total_page_lock_wait_in_ms) &gt; 300000
				AND (sz.avg_page_lock_wait_in_ms + sz.avg_row_lock_wait_in_ms) &lt; 5000
                OPTION    ( RECOMPILE );

        END

        ---------------------------------------- 
        --Index Hoarder: Check_id 20-29
        ----------------------------------------
        BEGIN
            RAISERROR(N'check_id 20: &gt;=7 NC indexes on any given table. Yes, 7 is an arbitrary number.', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    20 AS check_id, 
                                MAX(i.index_sanity_id) AS index_sanity_id, 
                                100 AS Priority,
                                'Index Hoarder' AS findings_group,
                                'Many NC indexes on a single table' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/IndexHoarder' AS URL,
                                CAST (COUNT(*) AS NVARCHAR(30)) + ' NC indexes on ' + i.db_schema_object_name AS details,
                                i.db_schema_object_name + ' (' + CAST (COUNT(*) AS NVARCHAR(30)) + ' indexes)' AS index_definition,
                                '' AS secret_columns,
                                REPLACE(CONVERT(NVARCHAR(30),CAST(SUM(total_reads) AS MONEY), 1), N'.00', N'') + N' reads (ALL); '
                                    + REPLACE(CONVERT(NVARCHAR(30),CAST(SUM(user_updates) AS MONEY), 1), N'.00', N'') + N' writes (ALL); ',
                                REPLACE(CONVERT(NVARCHAR(30),CAST(MAX(total_rows) AS MONEY), 1), N'.00', N'') + N' rows (MAX)'
                                    + CASE WHEN SUM(total_reserved_MB) &gt; 1024 THEN 
                                        N'; ' + CAST(CAST(SUM(total_reserved_MB)/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + 'GB (ALL)'
                                    WHEN SUM(total_reserved_MB) &gt; 0 THEN
                                        N'; ' + CAST(CAST(SUM(total_reserved_MB) AS NUMERIC(29,1)) AS NVARCHAR(30)) + 'MB (ALL)'
                                    ELSE ''
                                    END AS index_size_summary
                        FROM    #IndexSanity i
                        JOIN #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        WHERE    index_id NOT IN ( 0, 1 )
                        AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                        GROUP BY db_schema_object_name, [i].[database_name]
                        HAVING    COUNT(*) &gt;= 7
                        ORDER BY i.db_schema_object_name DESC  OPTION    ( RECOMPILE );

            IF @Filter = 1 /*@Filter=1 is "ignore unusued" */
            BEGIN
                RAISERROR(N'Skipping checks on unused indexes (21 and 22) because @Filter=1', 0,1) WITH NOWAIT;
            END
            ELSE /*Otherwise, go ahead and do the checks*/
            BEGIN
                RAISERROR(N'check_id 21: &gt;=5 percent of indexes are unused. Yes, 5 is an arbitrary number.', 0,1) WITH NOWAIT;
                    DECLARE @percent_NC_indexes_unused NUMERIC(29,1);
                    DECLARE @NC_indexes_unused_reserved_MB NUMERIC(29,1);

                    SELECT    @percent_NC_indexes_unused =( 100.00 * SUM(CASE    WHEN total_reads = 0 THEN 1
                                                ELSE 0
                                           END) ) / COUNT(*) ,
                            @NC_indexes_unused_reserved_MB = SUM(CASE WHEN total_reads = 0 THEN sz.total_reserved_MB
                                     ELSE 0
                                END) 
                    FROM    #IndexSanity i
                    JOIN    #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE    index_id NOT IN ( 0, 1 ) 
                            AND i.is_unique = 0
							/*Skipping tables created in the last week, or modified in past 2 days*/
							AND	i.create_date &gt;= DATEADD(dd,-7,GETDATE()) 
							AND i.modify_date &gt; DATEADD(dd,-2,GETDATE()) 
                    OPTION    ( RECOMPILE );

                IF @percent_NC_indexes_unused &gt;= 5 
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                            SELECT    21 AS check_id, 
                                    MAX(i.index_sanity_id) AS index_sanity_id, 
                                    150 AS Priority,
                                    N'Index Hoarder' AS findings_group,
                                    N'More than 5 percent NC indexes are unused' AS finding,
                                    [database_name] AS [Database Name],
                                    N'http://BrentOzar.com/go/IndexHoarder' AS URL,
                                    CAST (@percent_NC_indexes_unused AS NVARCHAR(30)) + N' percent NC indexes (' + CAST(COUNT(*) AS NVARCHAR(10)) + N') unused. ' +
                                    N'These take up ' + CAST (@NC_indexes_unused_reserved_MB AS NVARCHAR(30)) + N'MB of space.' AS details,
                                    i.database_name + ' (' + CAST (COUNT(*) AS NVARCHAR(30)) + N' indexes)' AS index_definition,
                                    '' AS secret_columns, 
                                    CAST(SUM(total_reads) AS NVARCHAR(256)) + N' reads (ALL); '
                                        + CAST(SUM([user_updates]) AS NVARCHAR(256)) + N' writes (ALL)' AS index_usage_summary,
                                
                                    REPLACE(CONVERT(NVARCHAR(30),CAST(MAX([total_rows]) AS MONEY), 1), '.00', '') + N' rows (MAX)'
                                        + CASE WHEN SUM(total_reserved_MB) &gt; 1024 THEN 
                                            N'; ' + CAST(CAST(SUM(total_reserved_MB)/1024. AS NUMERIC(29,1)) AS NVARCHAR(30)) + 'GB (ALL)'
                                        WHEN SUM(total_reserved_MB) &gt; 0 THEN
                                            N'; ' + CAST(CAST(SUM(total_reserved_MB) AS NUMERIC(29,1)) AS NVARCHAR(30)) + 'MB (ALL)'
                                        ELSE ''
                                        END AS index_size_summary
                            FROM    #IndexSanity i
                            JOIN    #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                            WHERE    index_id NOT IN ( 0, 1 )
                                    AND i.is_unique = 0
                                    AND total_reads = 0
                                    AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
									/*Skipping tables created in the last week, or modified in past 2 days*/
									AND	i.create_date &gt;= DATEADD(dd,-7,GETDATE()) 
									AND i.modify_date &gt; DATEADD(dd,-2,GETDATE())
                            GROUP BY i.database_name 
                    OPTION    ( RECOMPILE );

                RAISERROR(N'check_id 22: NC indexes with 0 reads. (Borderline)', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    22 AS check_id, 
                                i.index_sanity_id,
                                150 AS Priority,
                                N'Index Hoarder' AS findings_group,
                                N'Unused NC index' AS finding, 
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/IndexHoarder' AS URL,
                                N'0 reads: ' + i.db_schema_object_indexid AS details, 
                                i.index_definition, 
                                i.secret_columns, 
                                i.index_usage_summary,
                                sz.index_size_summary
                        FROM    #IndexSanity AS i
                        JOIN    #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
                        WHERE    i.total_reads=0
                                AND i.index_id NOT IN (0,1) /*NCs only*/
                                AND i.is_unique = 0
                                AND sz.total_reserved_MB &gt;= CASE WHEN (@GetAllDatabases = 1 OR @Mode = 0) THEN @ThresholdMB ELSE sz.total_reserved_MB END
                        ORDER BY i.db_schema_object_indexid
                        OPTION    ( RECOMPILE );
            END /*end checks only run when @Filter &lt;&gt; 1*/

            RAISERROR(N'check_id 23: Indexes with 7 or more columns. (Borderline)', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    23 AS check_id, 
                            i.index_sanity_id,
                            150 AS Priority, 
                            N'Index Hoarder' AS findings_group,
                            N'Borderline: Wide indexes (7 or more columns)' AS finding, 
                            [database_name] AS [Database Name],
                            N'http://BrentOzar.com/go/IndexHoarder' AS URL,
                            CAST(count_key_columns + count_included_columns AS NVARCHAR(10)) + ' columns on '
                            + i.db_schema_object_indexid AS details, i.index_definition, 
                            i.secret_columns, 
                            i.index_usage_summary,
                            sz.index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN    #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE    ( count_key_columns + count_included_columns ) &gt;= 7
                            AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                    OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 24: Wide clustered indexes (&gt; 3 columns or &gt; 16 bytes).', 0,1) WITH NOWAIT;
                WITH count_columns AS (
                            SELECT [object_id],
                                SUM(CASE max_length WHEN -1 THEN 0 ELSE max_length END) AS sum_max_length
                            FROM #IndexColumns ic
                            WHERE index_id IN (1,0) /*Heap or clustered only*/
                            AND key_ordinal &gt; 0
                            GROUP BY object_id
                            )
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    24 AS check_id, 
                                i.index_sanity_id, 
                                150 AS Priority,
                                N'Index Hoarder' AS findings_group,
                                N'Wide clustered index (&gt; 3 columns OR &gt; 16 bytes)' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/IndexHoarder' AS URL,
                                CAST (i.count_key_columns AS NVARCHAR(10)) + N' columns with potential size of '
                                    + CAST(cc.sum_max_length AS NVARCHAR(10))
                                    + N' bytes in clustered index:' + i.db_schema_object_name 
                                    + N'. ' + 
                                        (SELECT CAST(COUNT(*) AS NVARCHAR(23)) FROM #IndexSanity i2 
                                        WHERE i2.[object_id]=i.[object_id] AND i2.index_id &lt;&gt; 1
                                        AND i2.is_disabled=0 AND i2.is_hypothetical=0)
                                        + N' NC indexes on the table.'
                                    AS details,
                                i.index_definition,
                                secret_columns, 
                                i.index_usage_summary,
                                ip.index_size_summary
                        FROM    #IndexSanity i
                        JOIN    #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        JOIN    count_columns AS cc ON i.[object_id]=cc.[object_id]    
                        WHERE    index_id = 1 /* clustered only */
                                AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                                AND 
                                    (count_key_columns &gt; 3 /*More than three key columns.*/
                                    OR cc.sum_max_length &gt; 16 /*More than 16 bytes in key */)
									AND i.is_CX_columnstore = 0
                        ORDER BY i.db_schema_object_name DESC OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 25: Addicted to nullable columns.', 0,1) WITH NOWAIT;
                WITH count_columns AS (
                            SELECT [object_id],
                                SUM(CASE is_nullable WHEN 1 THEN 0 ELSE 1 END) AS non_nullable_columns,
                                COUNT(*) AS total_columns
                            FROM #IndexColumns ic
                            WHERE index_id IN (1,0) /*Heap or clustered only*/
                            GROUP BY object_id
                            )
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    25 AS check_id, 
                                i.index_sanity_id, 
                                200 AS Priority,
                                N'Index Hoarder' AS findings_group,
                                N'Addicted to nulls' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/IndexHoarder' AS URL,
                                i.db_schema_object_name 
                                    + N' allows null in ' + CAST((total_columns-non_nullable_columns) AS NVARCHAR(10))
                                    + N' of ' + CAST(total_columns AS NVARCHAR(10))
                                    + N' columns.' AS details,
                                i.index_definition,
                                secret_columns, 
                                ISNULL(i.index_usage_summary,''),
                                ISNULL(ip.index_size_summary,'')
                        FROM    #IndexSanity i
                        JOIN    #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        JOIN    count_columns AS cc ON i.[object_id]=cc.[object_id]
                        WHERE    i.index_id IN (1,0)
                        AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                            AND cc.non_nullable_columns &lt; 2
                            AND cc.total_columns &gt; 3
                        ORDER BY i.db_schema_object_name DESC OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 26: Wide tables (35+ cols or &gt; 2000 non-LOB bytes).', 0,1) WITH NOWAIT;
                WITH count_columns AS (
                            SELECT [object_id],
                                SUM(CASE max_length WHEN -1 THEN 1 ELSE 0 END) AS count_lob_columns,
                                SUM(CASE max_length WHEN -1 THEN 0 ELSE max_length END) AS sum_max_length,
                                COUNT(*) AS total_columns
                            FROM #IndexColumns ic
                            WHERE index_id IN (1,0) /*Heap or clustered only*/
                            GROUP BY object_id
                            )
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    26 AS check_id, 
                                i.index_sanity_id, 
                                150 AS Priority,
                                N'Index Hoarder' AS findings_group,
                                N'Wide tables: 35+ cols or &gt; 2000 non-LOB bytes' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/IndexHoarder' AS URL,
                                i.db_schema_object_name 
                                    + N' has ' + CAST((total_columns) AS NVARCHAR(10))
                                    + N' total columns with a max possible width of ' + CAST(sum_max_length AS NVARCHAR(10))
                                    + N' bytes.' +
                                    CASE WHEN count_lob_columns &gt; 0 THEN CAST((count_lob_columns) AS NVARCHAR(10))
                                        + ' columns are LOB types.' ELSE ''
                                    END
                                        AS details,
                                i.index_definition,
                                secret_columns, 
                                ISNULL(i.index_usage_summary,''),
                                ISNULL(ip.index_size_summary,'')
                        FROM    #IndexSanity i
                        JOIN    #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        JOIN    count_columns AS cc ON i.[object_id]=cc.[object_id]
                        WHERE    i.index_id IN (1,0)
                        AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                            AND 
                            (cc.total_columns &gt;= 35 OR
                            cc.sum_max_length &gt;= 2000)
                        ORDER BY i.db_schema_object_name DESC OPTION    ( RECOMPILE );
                    
            RAISERROR(N'check_id 27: Addicted to strings.', 0,1) WITH NOWAIT;
                WITH count_columns AS (
                            SELECT [object_id],
                                SUM(CASE WHEN system_type_name IN ('varchar','nvarchar','char') OR max_length=-1 THEN 1 ELSE 0 END) AS string_or_LOB_columns,
                                COUNT(*) AS total_columns
                            FROM #IndexColumns ic
                            WHERE index_id IN (1,0) /*Heap or clustered only*/
                            GROUP BY object_id
                            )
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    27 AS check_id, 
                                i.index_sanity_id, 
                                200 AS Priority,
                                N'Index Hoarder' AS findings_group,
                                N'Addicted to strings' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/IndexHoarder' AS URL,
                                i.db_schema_object_name 
                                    + N' uses string or LOB types for ' + CAST((string_or_LOB_columns) AS NVARCHAR(10))
                                    + N' of ' + CAST(total_columns AS NVARCHAR(10))
                                    + N' columns. Check if data types are valid.' AS details,
                                i.index_definition,
                                secret_columns, 
                                ISNULL(i.index_usage_summary,''),
                                ISNULL(ip.index_size_summary,'')
                        FROM    #IndexSanity i
                        JOIN    #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        JOIN    count_columns AS cc ON i.[object_id]=cc.[object_id]
                        CROSS APPLY (SELECT cc.total_columns - string_or_LOB_columns AS non_string_or_lob_columns) AS calc1
                        WHERE    i.index_id IN (1,0)
                        AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                            AND calc1.non_string_or_lob_columns &lt;= 1
                            AND cc.total_columns &gt; 3
                        ORDER BY i.db_schema_object_name DESC OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 28: Non-unique clustered index.', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    28 AS check_id, 
                                i.index_sanity_id, 
                                100 AS Priority,
                                N'Index Hoarder' AS findings_group,
                                N'Non-Unique clustered index' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/IndexHoarder' AS URL,
                                N'Uniquifiers will be required! Clustered index: ' + i.db_schema_object_name 
                                    + N' and all NC indexes. ' + 
                                        (SELECT CAST(COUNT(*) AS NVARCHAR(23)) FROM #IndexSanity i2 
                                        WHERE i2.[object_id]=i.[object_id] AND i2.index_id &lt;&gt; 1
                                        AND i2.is_disabled=0 AND i2.is_hypothetical=0)
                                        + N' NC indexes on the table.'
                                    AS details,
                                i.index_definition,
                                secret_columns, 
                                i.index_usage_summary,
                                ip.index_size_summary
                        FROM    #IndexSanity i
                        JOIN    #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        WHERE    index_id = 1 /* clustered only */
                        AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                                AND is_unique=0 /* not unique */
                                AND is_CX_columnstore=0 /* not a clustered columnstore-- no unique option on those */
                        ORDER BY i.db_schema_object_name DESC OPTION    ( RECOMPILE )



        END
         ----------------------------------------
        --Feature-Phobic Indexes: Check_id 30-39
        ---------------------------------------- 
        BEGIN
            RAISERROR(N'check_id 30: No indexes with includes', 0,1) WITH NOWAIT;

            DECLARE    @number_indexes_with_includes INT;
            DECLARE    @percent_indexes_with_includes NUMERIC(10, 1);

            SELECT    @number_indexes_with_includes = SUM(CASE WHEN count_included_columns &gt; 0 THEN 1 ELSE 0    END),
                    @percent_indexes_with_includes = 100.* 
                        SUM(CASE WHEN count_included_columns &gt; 0 THEN 1 ELSE 0 END) / ( 1.0 * COUNT(*) )
            FROM    #IndexSanity;

            IF @number_indexes_with_includes = 0 AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    30 AS check_id, 
                                NULL AS index_sanity_id, 
                                250 AS Priority,
                                N'Feature-Phobic Indexes' AS findings_group,
                                N'No indexes use includes' AS finding, 'http://BrentOzar.com/go/IndexFeatures' AS URL,
                                N'No indexes use includes' AS details,
                                @DatabaseName + N' (Entire database)' AS index_definition, 
                                N'' AS secret_columns, 
                                N'N/A' AS index_usage_summary, 
                                N'N/A' AS index_size_summary OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 31: &lt; 3 percent of indexes have includes', 0,1) WITH NOWAIT;
            IF @percent_indexes_with_includes &lt;= 3 AND @number_indexes_with_includes &gt; 0 AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    31 AS check_id,
                                NULL AS index_sanity_id, 
                                150 AS Priority,
                                N'Feature-Phobic Indexes' AS findings_group,
                                N'Borderline: Includes are used in &lt; 3% of indexes' AS findings,
                                @DatabaseName AS [Database Name],
                                N'http://BrentOzar.com/go/IndexFeatures' AS URL,
                                N'Only ' + CAST(@percent_indexes_with_includes AS NVARCHAR(10)) + '% of indexes have includes' AS details, 
                                N'Entire database' AS index_definition, 
                                N'' AS secret_columns,
                                N'N/A' AS index_usage_summary, 
                                N'N/A' AS index_size_summary OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 32: filtered indexes and indexed views', 0,1) WITH NOWAIT;
            DECLARE @count_filtered_indexes INT;
            DECLARE @count_indexed_views INT;

                SELECT    @count_filtered_indexes=COUNT(*)
                FROM    #IndexSanity
                WHERE    filter_definition &lt;&gt; '' OPTION    ( RECOMPILE );

                SELECT    @count_indexed_views=COUNT(*)
                FROM    #IndexSanity AS i
                        JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
                WHERE    is_indexed_view = 1 OPTION    ( RECOMPILE );

            IF @count_filtered_indexes = 0 AND @count_indexed_views=0 AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    32 AS check_id, 
                                NULL AS index_sanity_id,
                                250 AS Priority,
                                N'Feature-Phobic Indexes' AS findings_group,
                                N'Borderline: No filtered indexes or indexed views exist' AS finding, 
                                @DatabaseName AS [Database Name],
                                N'http://BrentOzar.com/go/IndexFeatures' AS URL,
                                N'These are NOT always needed-- but do you know when you would use them?' AS details,
                                @DatabaseName + N' (Entire database)' AS index_definition, 
                                N'' AS secret_columns,
                                N'N/A' AS index_usage_summary, 
                                N'N/A' AS index_size_summary OPTION    ( RECOMPILE );
        END;

        RAISERROR(N'check_id 33: Potential filtered indexes based on column names.', 0,1) WITH NOWAIT;

                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
        SELECT    33 AS check_id, 
                i.index_sanity_id AS index_sanity_id,
                250 AS Priority,
                N'Feature-Phobic Indexes' AS findings_group,
                N'Potential filtered index (based on column name)' AS finding, 
                [database_name] AS [Database Name],
                N'http://BrentOzar.com/go/IndexFeatures' AS URL,
                N'A column name in this index suggests it might be a candidate for filtering (is%, %archive%, %active%, %flag%)' AS details,
                i.index_definition, 
                i.secret_columns,
                i.index_usage_summary, 
                sz.index_size_summary
        FROM #IndexColumns ic 
        JOIN #IndexSanity i ON 
            ic.[object_id]=i.[object_id] AND
            ic.[index_id]=i.[index_id] AND
            i.[index_id] &gt; 1 /* non-clustered index */
        JOIN    #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
        WHERE (column_name LIKE 'is%'
            OR column_name LIKE '%archive%'
            OR column_name LIKE '%active%'
            OR column_name LIKE '%flag%')
            AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
        OPTION    ( RECOMPILE );
        
         ----------------------------------------
        --Self Loathing Indexes : Check_id 40-49
        ----------------------------------------
        BEGIN
        
            RAISERROR(N'check_id 40: Fillfactor in nonclustered 80 percent or less', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    40 AS check_id, 
                            i.index_sanity_id,
                            100 AS Priority,
                            N'Self Loathing Indexes' AS findings_group,
                            N'Low Fill Factor: nonclustered index' AS finding, 
                            [database_name] AS [Database Name],
                            N'http://BrentOzar.com/go/SelfLoathing' AS URL,
                            CAST(fill_factor AS NVARCHAR(10)) + N'% fill factor on ' + db_schema_object_indexid + N'. '+
                                CASE WHEN (last_user_update IS NULL OR user_updates &lt; 1)
                                THEN N'No writes have been made.'
                                ELSE
                                    N'Last write was ' +  CONVERT(NVARCHAR(16),last_user_update,121) + N' and ' + 
                                    CAST(user_updates AS NVARCHAR(25)) + N' updates have been made.'
                                END
                                AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            sz.index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN    #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE    index_id &gt; 1
                    AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                    AND    fill_factor BETWEEN 1 AND 80 OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 40: Fillfactor in clustered 80 percent or less', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    40 AS check_id, 
                            i.index_sanity_id,
                            100 AS Priority,
                            N'Self Loathing Indexes' AS findings_group,
                            N'Low Fill Factor: clustered index' AS finding, 
                            [database_name] AS [Database Name],
                            N'http://BrentOzar.com/go/SelfLoathing' AS URL,
                            N'Fill factor on ' + db_schema_object_indexid + N' is ' + CAST(fill_factor AS NVARCHAR(10)) + N'%. '+
                                CASE WHEN (last_user_update IS NULL OR user_updates &lt; 1)
                                THEN N'No writes have been made.'
                                ELSE
                                    N'Last write was ' +  CONVERT(NVARCHAR(16),last_user_update,121) + N' and ' + 
                                    CAST(user_updates AS NVARCHAR(25)) + N' updates have been made.'
                                END
                                AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            sz.index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE    index_id = 1
                    AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                    AND fill_factor BETWEEN 1 AND 80 OPTION    ( RECOMPILE );


            RAISERROR(N'check_id 41: Hypothetical indexes ', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    41 AS check_id, 
                            i.index_sanity_id,
                            150 AS Priority,
                            N'Self Loathing Indexes' AS findings_group,
                            N'Hypothetical Index' AS finding,
                            [database_name] AS [Database Name],
                            N'http://BrentOzar.com/go/SelfLoathing' AS URL,
                            N'Hypothetical Index: ' + db_schema_object_indexid AS details, 
                            i.index_definition,
                            i.secret_columns,
                            N'' AS index_usage_summary, 
                            N'' AS index_size_summary
                    FROM    #IndexSanity AS i
                    WHERE    is_hypothetical = 1 
                    AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                    OPTION    ( RECOMPILE );


            RAISERROR(N'check_id 42: Disabled indexes', 0,1) WITH NOWAIT;
            --Note: disabled NC indexes will have O rows in #IndexSanitySize!
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    42 AS check_id, 
                            index_sanity_id,
                            150 AS Priority,
                            N'Self Loathing Indexes' AS findings_group,
                            N'Disabled Index' AS finding, 
                            [database_name] AS [Database Name],
                            N'http://BrentOzar.com/go/SelfLoathing' AS URL,
                            N'Disabled Index:' + db_schema_object_indexid AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            'DISABLED' AS index_size_summary
                    FROM    #IndexSanity AS i
                    WHERE    is_disabled = 1
                    AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                    OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 43: Heaps with forwarded records or deletes', 0,1) WITH NOWAIT;
            WITH    heaps_cte
                      AS ( SELECT    [object_id], 
                                    SUM(forwarded_fetch_count) AS forwarded_fetch_count,
                                    SUM(leaf_delete_count) AS leaf_delete_count
                           FROM        #IndexPartitionSanity
                           GROUP BY    [object_id]
                           HAVING    SUM(forwarded_fetch_count) &gt; 0
                                    OR SUM(leaf_delete_count) &gt; 0)
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    43 AS check_id, 
                                i.index_sanity_id,
                                100 AS Priority,
                                N'Self Loathing Indexes' AS findings_group,
                                N'Heaps with forwarded records or deletes' AS finding, 
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/SelfLoathing' AS URL,
                                CAST(h.forwarded_fetch_count AS NVARCHAR(256)) + ' forwarded fetches, '
                                + CAST(h.leaf_delete_count AS NVARCHAR(256)) + ' deletes against heap:'
                                + db_schema_object_indexid AS details, 
                                i.index_definition, 
                                i.secret_columns,
                                i.index_usage_summary,
                                sz.index_size_summary
                        FROM    #IndexSanity i
                        JOIN heaps_cte h ON i.[object_id] = h.[object_id]
                        JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                        WHERE    i.index_id = 0 
                        AND sz.total_reserved_MB &gt;= CASE WHEN NOT (@GetAllDatabases = 1 OR @Mode = 4) THEN @ThresholdMB ELSE sz.total_reserved_MB END
                OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 44: Large Heaps with reads or writes.', 0,1) WITH NOWAIT;
            WITH    heaps_cte
                      AS ( SELECT    [object_id], SUM(forwarded_fetch_count) AS forwarded_fetch_count,
                                    SUM(leaf_delete_count) AS leaf_delete_count
                           FROM        #IndexPartitionSanity
                           GROUP BY    [object_id]
                           HAVING    SUM(forwarded_fetch_count) &gt; 0
                                    OR SUM(leaf_delete_count) &gt; 0)
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    44 AS check_id, 
                                i.index_sanity_id,
                                100 AS Priority,
                                N'Self Loathing Indexes' AS findings_group,
                                N'Large Active heap' AS finding, 
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/SelfLoathing' AS URL,
                                N'Should this table be a heap? ' + db_schema_object_indexid AS details, 
                                i.index_definition, 
                                'N/A' AS secret_columns,
                                i.index_usage_summary,
                                sz.index_size_summary
                        FROM    #IndexSanity i
                        LEFT JOIN heaps_cte h ON i.[object_id] = h.[object_id]
                        JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                        WHERE    i.index_id = 0 
                                AND 
                                    (i.total_reads &gt; 0 OR i.user_updates &gt; 0)
								AND sz.total_rows &gt;= 100000
                                AND h.[object_id] IS NULL /*don't duplicate the prior check.*/
                                AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 45: Medium Heaps with reads or writes.', 0,1) WITH NOWAIT;
            WITH    heaps_cte
                      AS ( SELECT    [object_id], SUM(forwarded_fetch_count) AS forwarded_fetch_count,
                                    SUM(leaf_delete_count) AS leaf_delete_count
                           FROM        #IndexPartitionSanity
                           GROUP BY    [object_id]
                           HAVING    SUM(forwarded_fetch_count) &gt; 0
                                    OR SUM(leaf_delete_count) &gt; 0)
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    45 AS check_id, 
                                i.index_sanity_id,
                                100 AS Priority,
                                N'Self Loathing Indexes' AS findings_group,
                                N'Medium Active heap' AS finding, 
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/SelfLoathing' AS URL,
                                N'Should this table be a heap? ' + db_schema_object_indexid AS details, 
                                i.index_definition, 
                                'N/A' AS secret_columns,
                                i.index_usage_summary,
                                sz.index_size_summary
                        FROM    #IndexSanity i
                        LEFT JOIN heaps_cte h ON i.[object_id] = h.[object_id]
                        JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                        WHERE    i.index_id = 0 
                                AND 
                                    (i.total_reads &gt; 0 OR i.user_updates &gt; 0)
								AND sz.total_rows &gt;= 10000 AND sz.total_rows &lt; 100000
                                AND h.[object_id] IS NULL /*don't duplicate the prior check.*/
                                AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 46: Small Heaps with reads or writes.', 0,1) WITH NOWAIT;
            WITH    heaps_cte
                      AS ( SELECT    [object_id], SUM(forwarded_fetch_count) AS forwarded_fetch_count,
                                    SUM(leaf_delete_count) AS leaf_delete_count
                           FROM        #IndexPartitionSanity
                           GROUP BY    [object_id]
                           HAVING    SUM(forwarded_fetch_count) &gt; 0
                                    OR SUM(leaf_delete_count) &gt; 0)
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    46 AS check_id, 
                                i.index_sanity_id,
                                100 AS Priority,
                                N'Self Loathing Indexes' AS findings_group,
                                N'Small Active heap' AS finding, 
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/SelfLoathing' AS URL,
                                N'Should this table be a heap? ' + db_schema_object_indexid AS details, 
                                i.index_definition, 
                                'N/A' AS secret_columns,
                                i.index_usage_summary,
                                sz.index_size_summary
                        FROM    #IndexSanity i
                        LEFT JOIN heaps_cte h ON i.[object_id] = h.[object_id]
                        JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                        WHERE    i.index_id = 0 
                                AND 
                                    (i.total_reads &gt; 0 OR i.user_updates &gt; 0)
								AND sz.total_rows &lt; 10000
                                AND h.[object_id] IS NULL /*don't duplicate the prior check.*/
                                AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                OPTION    ( RECOMPILE );

				            RAISERROR(N'check_id 47: Heap with a Nonclustered Primary Key', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT  47 AS check_id, 
                                i.index_sanity_id,
                                100 AS Priority,
                                N'Self Loathing Indexes' AS findings_group,
                                N'Heap with a Nonclustered Primary Key' AS finding, 
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/SelfLoathing' AS URL,
								db_schema_object_indexid + N' is a HEAP with a Nonclustered Primary Key' AS details, 
                                i.index_definition, 
                                i.secret_columns,
                                i.index_usage_summary,
                                sz.index_size_summary
                        FROM    #IndexSanity i
                        JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                        WHERE    i.index_type = 2 AND i.is_primary_key = 1 AND i.secret_columns LIKE '%RID%'
                OPTION    ( RECOMPILE );

            END;
        ----------------------------------------
        --Indexaphobia
        --Missing indexes with value &gt;= 5 million: : Check_id 50-59
        ----------------------------------------
        BEGIN
            RAISERROR(N'check_id 50: Indexaphobia.', 0,1) WITH NOWAIT;
            WITH    index_size_cte
                      AS ( SELECT   i.database_id,
									i.[object_id], 
                                    MAX(i.index_sanity_id) AS index_sanity_id,
                                ISNULL (
                                    CAST(SUM(CASE WHEN index_id NOT IN (0,1) THEN 1 ELSE 0 END)
                                         AS NVARCHAR(30))+ N' NC indexes exist (' + 
                                    CASE WHEN SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END) &gt; 1024
                                        THEN CAST(CAST(SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END )/1024. 

                                            AS NUMERIC(29,1)) AS NVARCHAR(30)) + N'GB); ' 
                                        ELSE CAST(SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END) 
                                            AS NVARCHAR(30)) + N'MB); '
                                    END + 
                                        CASE WHEN MAX(sz.[total_rows]) &gt;= 922337203685477 THEN '&gt;= 922,337,203,685,477'
                                        ELSE REPLACE(CONVERT(NVARCHAR(30),CAST(MAX(sz.[total_rows]) AS MONEY), 1), '.00', '') 
                                        END +
                                    + N' Estimated Rows;' 
                                ,N'') AS index_size_summary
                            FROM    #IndexSanity AS i
                            LEFT    JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id  AND i.database_id = sz.database_id
							WHERE i.is_hypothetical = 0
                                  AND i.is_disabled = 0
                           GROUP BY    i.database_id, i.[object_id])
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               index_usage_summary, index_size_summary, create_tsql, more_info )
                        
                        SELECT check_id, t.index_sanity_id, t.check_id, t.findings_group, t.finding, t.[Database Name], t.URL, t.details, t.[definition],
                                index_estimated_impact, t.index_size_summary, create_tsql, more_info
                        FROM
                        (
                            SELECT  ROW_NUMBER() OVER (ORDER BY magic_benefit_number DESC) AS rownum,
                                50 AS check_id, 
                                sz.index_sanity_id,
                                10 AS Priority,
                                N'Indexaphobia' AS findings_group,
                                N'High value missing index' AS finding, 
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/Indexaphobia' AS URL,
                                mi.[statement] + 
                                N' Est. benefit per day: ' + 
                                    CASE WHEN magic_benefit_number &gt;= 922337203685477 THEN '&gt;= 922,337,203,685,477'
                                    ELSE REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(
                                    (magic_benefit_number/@DaysUptime)
                                     AS BIGINT) AS MONEY), 1), '.00', '') 
                                    END AS details,
                                missing_index_details AS [definition],
                                index_estimated_impact,
                                sz.index_size_summary,
                                mi.create_tsql,
                                mi.more_info,
                                magic_benefit_number
                        FROM    #MissingIndexes mi
                                LEFT JOIN index_size_cte sz ON mi.[object_id] = sz.object_id AND DB_ID(mi.database_name) = sz.database_id
                                        /* Minimum benefit threshold = 100k/day of uptime */
                        WHERE ( @Mode = 4 AND (magic_benefit_number/@DaysUptime) &gt;= 100000 ) OR (magic_benefit_number/@DaysUptime) &gt;= 100000
                        ) AS t
                        WHERE t.rownum &lt;= CASE WHEN (@Mode &lt;&gt; 4) THEN 20 ELSE t.rownum END
                        ORDER BY magic_benefit_number DESC


    END
         ----------------------------------------
        --Abnormal Psychology : Check_id 60-79
        ----------------------------------------
    BEGIN
            RAISERROR(N'check_id 60: XML indexes', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    60 AS check_id, 
                            i.index_sanity_id,
                            150 AS Priority,
                            N'Abnormal Psychology' AS findings_group,
                            N'XML Indexes' AS finding, 
                            [database_name] AS [Database Name],
                            N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                            i.db_schema_object_indexid AS details, 
                            i.index_definition,
                            i.secret_columns,
                            N'' AS index_usage_summary,
                            ISNULL(sz.index_size_summary,'') AS index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE i.is_XML = 1 OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 61: Columnstore indexes', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    61 AS check_id, 
                            i.index_sanity_id,
                            150 AS Priority,
                            N'Abnormal Psychology' AS findings_group,
                            CASE WHEN i.is_NC_columnstore=1
                                THEN N'NC Columnstore Index' 
                                ELSE N'Clustered Columnstore Index' 
                                END AS finding, 
                            [database_name] AS [Database Name],
                            N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                            i.db_schema_object_indexid AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            ISNULL(sz.index_size_summary,'') AS index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE i.is_NC_columnstore = 1 OR i.is_CX_columnstore=1
                    OPTION    ( RECOMPILE );


            RAISERROR(N'check_id 62: Spatial indexes', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    62 AS check_id, 
                            i.index_sanity_id,
                            150 AS Priority,
                            N'Abnormal Psychology' AS findings_group,
                            N'Spatial indexes' AS finding,
                            [database_name] AS [Database Name], 
                            N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                            i.db_schema_object_indexid AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            ISNULL(sz.index_size_summary,'') AS index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE i.is_spatial = 1 OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 63: Compressed indexes', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    63 AS check_id, 
                            i.index_sanity_id,
                            150 AS Priority,
                            N'Abnormal Psychology' AS findings_group,
                            N'Compressed indexes' AS finding,
                            [database_name] AS [Database Name], 
                            N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                            i.db_schema_object_indexid  + N'. COMPRESSION: ' + sz.data_compression_desc AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            ISNULL(sz.index_size_summary,'') AS index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE sz.data_compression_desc LIKE '%PAGE%' OR sz.data_compression_desc LIKE '%ROW%' OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 64: Partitioned', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    64 AS check_id, 
                            i.index_sanity_id,
                            150 AS Priority,
                            N'Abnormal Psychology' AS findings_group,
                            N'Partitioned indexes' AS finding,
                            [database_name] AS [Database Name], 
                            N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                            i.db_schema_object_indexid AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            ISNULL(sz.index_size_summary,'') AS index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE i.partition_key_column_name IS NOT NULL OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 65: Non-Aligned Partitioned', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    65 AS check_id, 
                            i.index_sanity_id,
                            150 AS Priority,
                            N'Abnormal Psychology' AS findings_group,
                            N'Non-Aligned index on a partitioned table' AS finding,
                            i.[database_name] AS [Database Name], 
                            N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                            i.db_schema_object_indexid AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            ISNULL(sz.index_size_summary,'') AS index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanity AS iParent ON
                        i.[object_id]=iParent.[object_id]
                        AND iParent.index_id IN (0,1) /* could be a partitioned heap or clustered table */
                        AND iParent.partition_key_column_name IS NOT NULL /* parent is partitioned*/         
                    JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE i.partition_key_column_name IS NULL 
                        OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 66: Recently created tables/indexes (1 week)', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    66 AS check_id, 
                            i.index_sanity_id,
                            200 AS Priority,
                            N'Abnormal Psychology' AS findings_group,
                            N'Recently created tables/indexes (1 week)' AS finding,
                            [database_name] AS [Database Name], 
                            N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                            i.db_schema_object_indexid + N' was created on ' + 
                                CONVERT(NVARCHAR(16),i.create_date,121) + 
                                N'. Tables/indexes which are dropped/created regularly require special methods for index tuning.'
                                     AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            ISNULL(sz.index_size_summary,'') AS index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE i.create_date &gt;= DATEADD(dd,-7,GETDATE()) 
                    AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                        OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 67: Recently modified tables/indexes (2 days)', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    67 AS check_id, 
                            i.index_sanity_id,
                            200 AS Priority,
                            N'Abnormal Psychology' AS findings_group,
                            N'Recently modified tables/indexes (2 days)' AS finding,
                            [database_name] AS [Database Name], 
                            N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                            i.db_schema_object_indexid + N' was modified on ' + 
                                CONVERT(NVARCHAR(16),i.modify_date,121) + 
                                N'. A large amount of recently modified indexes may mean a lot of rebuilds are occurring each night.'
                                     AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            ISNULL(sz.index_size_summary,'') AS index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE i.modify_date &gt; DATEADD(dd,-2,GETDATE()) 
                    AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                    AND /*Exclude recently created tables.*/
                    i.create_date &lt; DATEADD(dd,-7,GETDATE()) 
                        OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 68: Identity columns within 30 percent of the end of range', 0,1) WITH NOWAIT;
            -- Allowed Ranges: 
                --int -2,147,483,648 to 2,147,483,647
                --smallint -32,768 to 32,768
                --tinyint 0 to 255

                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    68 AS check_id, 
                                i.index_sanity_id, 
                                200 AS Priority,
                                N'Abnormal Psychology' AS findings_group,
                                N'Identity column within ' +                                     
                                    CAST (calc1.percent_remaining AS NVARCHAR(256))
                                    + N' percent  end of range' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                                i.db_schema_object_name + N'.' +  QUOTENAME(ic.column_name)
                                    + N' is an identity with type ' + ic.system_type_name 
                                    + N', last value of ' 
                                        + ISNULL(REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(ic.last_value AS BIGINT) AS MONEY), 1), '.00', ''),N'NULL')
                                    + N', seed of '
                                        + ISNULL(REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(ic.seed_value AS BIGINT) AS MONEY), 1), '.00', ''),N'NULL')
                                    + N', increment of ' + CAST(ic.increment_value AS NVARCHAR(256)) 
                                    + N', and range of ' +
                                        CASE ic.system_type_name WHEN 'int' THEN N'+/- 2,147,483,647'
                                            WHEN 'smallint' THEN N'+/- 32,768'
                                            WHEN 'tinyint' THEN N'0 to 255'
                                        END
                                        AS details,
                                i.index_definition,
                                secret_columns, 
                                ISNULL(i.index_usage_summary,''),
                                ISNULL(ip.index_size_summary,'')
                        FROM    #IndexSanity i
                        JOIN    #IndexColumns ic ON
                            i.object_id=ic.object_id
                            AND i.index_id IN (0,1) /* heaps and cx only */
                            AND ic.is_identity=1
                            AND ic.system_type_name IN ('tinyint', 'smallint', 'int')
                        JOIN    #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        CROSS APPLY (
                            SELECT CAST(CASE WHEN ic.increment_value &gt;= 0
                                    THEN
                                        CASE ic.system_type_name 
                                            WHEN 'int' THEN (2147483647 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 2147483647.*100
                                            WHEN 'smallint' THEN (32768 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 32768.*100
                                            WHEN 'tinyint' THEN ( 255 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 255.*100
                                            ELSE 999
                                        END
                                ELSE --ic.increment_value is negative
                                        CASE ic.system_type_name 
                                            WHEN 'int' THEN ABS(-2147483647 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 2147483647.*100
                                            WHEN 'smallint' THEN ABS(-32768 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 32768.*100
                                            WHEN 'tinyint' THEN ABS( 0 - (ISNULL(ic.last_value,ic.seed_value) + ic.increment_value)) / 255.*100
                                            ELSE -1
                                        END 
                                END AS NUMERIC(5,1)) AS percent_remaining
                                ) AS calc1
                        WHERE    i.index_id IN (1,0)
                            AND calc1.percent_remaining &lt;= 30
                        UNION ALL
                        SELECT    68 AS check_id, 
                                i.index_sanity_id, 
                                200 AS Priority,
                                N'Abnormal Psychology' AS findings_group,
                                N'Identity column using a negative seed or increment other than 1' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                                i.db_schema_object_name + N'.' +  QUOTENAME(ic.column_name)
                                    + N' is an identity with type ' + ic.system_type_name 
                                    + N', last value of ' 
                                        + ISNULL(REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(ic.last_value AS BIGINT) AS MONEY), 1), '.00', ''),N'NULL')
                                    + N', seed of '
                                        + ISNULL(REPLACE(CONVERT(NVARCHAR(256),CAST(CAST(ic.seed_value AS BIGINT) AS MONEY), 1), '.00', ''),N'NULL')
                                    + N', increment of ' + CAST(ic.increment_value AS NVARCHAR(256)) 
                                    + N', and range of ' +
                                        CASE ic.system_type_name WHEN 'int' THEN N'+/- 2,147,483,647'
                                            WHEN 'smallint' THEN N'+/- 32,768'
                                            WHEN 'tinyint' THEN N'0 to 255'
                                        END
                                        AS details,
                                i.index_definition,
                                secret_columns, 
                                ISNULL(i.index_usage_summary,''),
                                ISNULL(ip.index_size_summary,'')
                        FROM    #IndexSanity i
                        JOIN    #IndexColumns ic ON
                            i.object_id=ic.object_id
                            AND i.index_id IN (0,1) /* heaps and cx only */
                            AND ic.is_identity=1
                            AND ic.system_type_name IN ('tinyint', 'smallint', 'int')
                        JOIN    #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        WHERE    i.index_id IN (1,0)
                            AND (ic.seed_value &lt; 0 OR ic.increment_value &lt;&gt; 1)
                        ORDER BY finding, details DESC OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 69: Column collation does not match database collation', 0,1) WITH NOWAIT;
                WITH count_columns AS (
                            SELECT [object_id],
                                COUNT(*) AS column_count
                            FROM #IndexColumns ic
                            WHERE index_id IN (1,0) /*Heap or clustered only*/
                                AND collation_name &lt;&gt; @collation
                            GROUP BY object_id
                            )
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    69 AS check_id, 
                                i.index_sanity_id, 
                                150 AS Priority,
                                N'Abnormal Psychology' AS findings_group,
                                N'Column collation does not match database collation' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                                i.db_schema_object_name 
                                    + N' has ' + CAST(column_count AS NVARCHAR(20))
                                    + N' column' + CASE WHEN column_count &gt; 1 THEN 's' ELSE '' END
                                    + N' with a different collation than the db collation of '
                                    + @collation    AS details,
                                i.index_definition,
                                secret_columns, 
                                ISNULL(i.index_usage_summary,''),
                                ISNULL(ip.index_size_summary,'')
                        FROM    #IndexSanity i
                        JOIN    #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        JOIN    count_columns AS cc ON i.[object_id]=cc.[object_id]
                        WHERE    i.index_id IN (1,0)
                        AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                        ORDER BY i.db_schema_object_name DESC OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 70: Replicated columns', 0,1) WITH NOWAIT;
                WITH count_columns AS (
                            SELECT [object_id],
                                COUNT(*) AS column_count,
                                SUM(CASE is_replicated WHEN 1 THEN 1 ELSE 0 END) AS replicated_column_count
                            FROM #IndexColumns ic
                            WHERE index_id IN (1,0) /*Heap or clustered only*/
                            GROUP BY object_id
                            )
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                        SELECT    70 AS check_id, 
                                i.index_sanity_id,
                                200 AS Priority, 
                                N'Abnormal Psychology' AS findings_group,
                                N'Replicated columns' AS finding,
                                [database_name] AS [Database Name],
                                N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                                i.db_schema_object_name 
                                    + N' has ' + CAST(replicated_column_count AS NVARCHAR(20))
                                    + N' out of ' + CAST(column_count AS NVARCHAR(20))
                                    + N' column' + CASE WHEN column_count &gt; 1 THEN 's' ELSE '' END
                                    + N' in one or more publications.'
                                        AS details,
                                i.index_definition,
                                secret_columns, 
                                ISNULL(i.index_usage_summary,''),
                                ISNULL(ip.index_size_summary,'')
                        FROM    #IndexSanity i
                        JOIN    #IndexSanitySize ip ON i.index_sanity_id = ip.index_sanity_id
                        JOIN    count_columns AS cc ON i.[object_id]=cc.[object_id]
                        WHERE    i.index_id IN (1,0)
                            AND replicated_column_count &gt; 0
                            AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
                        ORDER BY i.db_schema_object_name DESC OPTION    ( RECOMPILE );

            RAISERROR(N'check_id 71: Cascading updates or cascading deletes.', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary, more_info )
            SELECT    71 AS check_id, 
                    NULL AS index_sanity_id,
                    150 AS Priority,
                    N'Abnormal Psychology' AS findings_group,
                    N'Cascading Updates or Deletes' AS finding, 
                    [database_name] AS [Database Name],
                    N'http://BrentOzar.com/go/AbnormalPsychology' AS URL,
                    N'Foreign Key ' + foreign_key_name +
                    N' on ' + QUOTENAME(parent_object_name)  + N'(' + LTRIM(parent_fk_columns) + N')'
                        + N' referencing ' + QUOTENAME(referenced_object_name) + N'(' + LTRIM(referenced_fk_columns) + N')'
                        + N' has settings:'
                        + CASE [delete_referential_action_desc] WHEN N'NO_ACTION' THEN N'' ELSE N' ON DELETE ' +[delete_referential_action_desc] END
                        + CASE [update_referential_action_desc] WHEN N'NO_ACTION' THEN N'' ELSE N' ON UPDATE ' + [update_referential_action_desc] END
                            AS details, 
                    [fk].[database_name] 
                            AS index_definition, 
                    N'N/A' AS secret_columns,
                    N'N/A' AS index_usage_summary,
                    N'N/A' AS index_size_summary,
                    (SELECT TOP 1 more_info FROM #IndexSanity i WHERE i.object_id=fk.parent_object_id)
                        AS more_info
            FROM #ForeignKeys fk
            WHERE ([delete_referential_action_desc] &lt;&gt; N'NO_ACTION'
            OR [update_referential_action_desc] &lt;&gt; N'NO_ACTION')
            AND NOT (@GetAllDatabases = 1 OR @Mode = 0)

			RAISERROR(N'check_id 72: Columnstore indexes with Trace Flag 834', 0,1) WITH NOWAIT;
                IF EXISTS (SELECT * FROM #IndexSanity WHERE index_type IN (5,6))
				AND EXISTS (SELECT * FROM #TraceStatus WHERE TraceFlag = 834 AND status = 1)
				BEGIN
				INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
                    SELECT    72 AS check_id, 
                            i.index_sanity_id,
                            150 AS Priority,
                            N'Abnormal Psychology' AS findings_group,
                            'Columnstore Indexes are being used in conjunction with trace flag 834. Visit the link to see why this can be a bad idea' AS finding, 
                            [database_name] AS [Database Name],
                            N'https://support.microsoft.com/en-us/kb/3210239' AS URL,
                            i.db_schema_object_indexid AS details, 
                            i.index_definition,
                            i.secret_columns,
                            i.index_usage_summary,
                            ISNULL(sz.index_size_summary,'') AS index_size_summary
                    FROM    #IndexSanity AS i
                    JOIN #IndexSanitySize sz ON i.index_sanity_id = sz.index_sanity_id
                    WHERE i.index_type IN (5,6)
                    OPTION    ( RECOMPILE )
				END

    END

         ----------------------------------------
        --Workaholics: Check_id 80-89
        ----------------------------------------
    BEGIN

        RAISERROR(N'check_id 80: Most scanned indexes (index_usage_stats)', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )

        --Workaholics according to index_usage_stats
        --This isn't perfect: it mentions the number of scans present in a plan
        --A "scan" isn't necessarily a full scan, but hey, we gotta do the best with what we've got.
        --in the case of things like indexed views, the operator might be in the plan but never executed
        SELECT TOP 5 
            80 AS check_id,
            i.index_sanity_id AS index_sanity_id,
            200 AS Priority,
            N'Workaholics' AS findings_group,
            N'Scan-a-lots (index_usage_stats)' AS finding,
            [database_name] AS [Database Name],
            N'http://BrentOzar.com/go/Workaholics' AS URL,
            REPLACE(CONVERT( NVARCHAR(50),CAST(i.user_scans AS MONEY),1),'.00','')
                + N' scans against ' + i.db_schema_object_indexid
                + N'. Latest scan: ' + ISNULL(CAST(i.last_user_scan AS NVARCHAR(128)),'?') + N'. ' 
                + N'ScanFactor=' + CAST(((i.user_scans * iss.total_reserved_MB)/1000000.) AS NVARCHAR(256)) AS details,
            ISNULL(i.key_column_names_with_sort_order,'N/A') AS index_definition,
            ISNULL(i.secret_columns,'') AS secret_columns,
            i.index_usage_summary AS index_usage_summary,
            iss.index_size_summary AS index_size_summary
        FROM #IndexSanity i
        JOIN #IndexSanitySize iss ON i.index_sanity_id=iss.index_sanity_id
        WHERE ISNULL(i.user_scans,0) &gt; 0
        AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
        ORDER BY  i.user_scans * iss.total_reserved_MB DESC;

        RAISERROR(N'check_id 81: Top recent accesses (op stats)', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, index_sanity_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
        --Workaholics according to index_operational_stats
        --This isn't perfect either: range_scan_count contains full scans, partial scans, even seeks in nested loop ops
        --But this can help bubble up some most-accessed tables 
        SELECT TOP 5 
            81 AS check_id,
            i.index_sanity_id AS index_sanity_id,
            200 AS Priority,
            N'Workaholics' AS findings_group,
            N'Top recent accesses (index_op_stats)' AS finding,
            [database_name] AS [Database Name],
            N'http://BrentOzar.com/go/Workaholics' AS URL,
            ISNULL(REPLACE(
                    CONVERT(NVARCHAR(50),CAST((iss.total_range_scan_count + iss.total_singleton_lookup_count) AS MONEY),1),
                    N'.00',N'') 
                + N' uses of ' + i.db_schema_object_indexid + N'. '
                + REPLACE(CONVERT(NVARCHAR(50), CAST(iss.total_range_scan_count AS MONEY),1),N'.00',N'') + N' scans or seeks. '
                + REPLACE(CONVERT(NVARCHAR(50), CAST(iss.total_singleton_lookup_count AS MONEY), 1),N'.00',N'') + N' singleton lookups. '
                + N'OpStatsFactor=' + CAST(((((iss.total_range_scan_count + iss.total_singleton_lookup_count) * iss.total_reserved_MB))/1000000.) AS VARCHAR(256)),'') AS details,
            ISNULL(i.key_column_names_with_sort_order,'N/A') AS index_definition,
            ISNULL(i.secret_columns,'') AS secret_columns,
            i.index_usage_summary AS index_usage_summary,
            iss.index_size_summary AS index_size_summary
        FROM #IndexSanity i
        JOIN #IndexSanitySize iss ON i.index_sanity_id=iss.index_sanity_id
        WHERE (ISNULL(iss.total_range_scan_count,0)  &gt; 0 OR ISNULL(iss.total_singleton_lookup_count,0) &gt; 0)
        AND NOT (@GetAllDatabases = 1 OR @Mode = 0)
        ORDER BY ((iss.total_range_scan_count + iss.total_singleton_lookup_count) * iss.total_reserved_MB) DESC;


    END

         ----------------------------------------
        --Statistics Info: Check_id 90-99
        ----------------------------------------
    BEGIN

        RAISERROR(N'check_id 90: Outdated statistics', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
		SELECT  90 AS check_id, 
				200 AS Priority,
				'Functioning Statistaholics' AS findings_group,
				'Statistic Abandonment Issues',
				s.database_name,
				'' AS URL,
				'Statistics on this table were last updated ' + 
					CASE s.last_statistics_update WHEN NULL THEN N' NEVER '
					ELSE CONVERT(NVARCHAR(20), s.last_statistics_update) + 
						' have had ' + CONVERT(NVARCHAR(100), s.modification_counter) +
						' modifications in that time, which is ' +
						CONVERT(NVARCHAR(100), s.percent_modifications) + 
						'% of the table.'
					END,
				QUOTENAME(database_name) + '.' + QUOTENAME(s.schema_name) + '.' + QUOTENAME(s.table_name) + '.' + QUOTENAME(s.index_name) + '.' + QUOTENAME(s.statistics_name) + '.' + QUOTENAME(s.column_name) AS index_definition,
				'N/A' AS secret_columns,
				'N/A' AS index_usage_summary,
				'N/A' AS index_size_summary
		FROM #Statistics AS s
		WHERE s.last_statistics_update &lt;= CONVERT(DATETIME, GETDATE() - 7) 
		AND s.percent_modifications &gt;= 10. 
		AND s.rows &gt;= 10000

        RAISERROR(N'check_id 91: Statistics with a low sample rate', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
		SELECT  91 AS check_id, 
				200 AS Priority,
				'Functioning Statistaholics' AS findings_group,
				'Antisocial Samples',
				s.database_name,
				'' AS URL,
				'Only ' + CONVERT(NVARCHAR(100), s.percent_sampled) + '% of the rows were sampled during the last statistics update. This may lead to poor cardinality estimates.' ,
				QUOTENAME(database_name) + '.' + QUOTENAME(s.schema_name) + '.' + QUOTENAME(s.table_name) + '.' + QUOTENAME(s.index_name) + '.' + QUOTENAME(s.statistics_name) + '.' + QUOTENAME(s.column_name) AS index_definition,
				'N/A' AS secret_columns,
				'N/A' AS index_usage_summary,
				'N/A' AS index_size_summary
		FROM #Statistics AS s
		WHERE s.rows_sampled &lt; 1.
		AND s.rows &gt;= 10000

        RAISERROR(N'check_id 92: Statistics with NO RECOMPUTE', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
		SELECT  92 AS check_id, 
				200 AS Priority,
				'Functioning Statistaholics' AS findings_group,
				'Cyberphobic Samples',
				s.database_name,
				'' AS URL,
				'The statistic ' + QUOTENAME(s.statistics_name) +  ' is set to not recompute. This can be helpful if data is really skewed, but harmful if you expect automatic statistics updates.' ,
				QUOTENAME(database_name) + '.' + QUOTENAME(s.schema_name) + '.' + QUOTENAME(s.table_name) + '.' + QUOTENAME(s.index_name) + '.' + QUOTENAME(s.statistics_name) + '.' + QUOTENAME(s.column_name) AS index_definition,
				'N/A' AS secret_columns,
				'N/A' AS index_usage_summary,
				'N/A' AS index_size_summary
		FROM #Statistics AS s
		WHERE s.no_recompute = 1

        RAISERROR(N'check_id 93: Statistics with filters', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
		SELECT  93 AS check_id, 
				200 AS Priority,
				'Functioning Statistaholics' AS findings_group,
				'Filter Fixation',
				s.database_name,
				'' AS URL,
				'The statistic ' + QUOTENAME(s.statistics_name) +  ' is filtered on [' + s.filter_definition + ']. It could be part of a filtered index, or just a filtered statistic. This is purely informational.' ,
				QUOTENAME(database_name) + '.' + QUOTENAME(s.schema_name) + '.' + QUOTENAME(s.table_name) + '.' + QUOTENAME(s.index_name) + '.' + QUOTENAME(s.statistics_name) + '.' + QUOTENAME(s.column_name) AS index_definition,
				'N/A' AS secret_columns,
				'N/A' AS index_usage_summary,
				'N/A' AS index_size_summary
		FROM #Statistics AS s
		WHERE s.has_filter = 1

		END 

         ----------------------------------------
        --Computed Column Info: Check_id 90-99
        ----------------------------------------
    BEGIN

	     RAISERROR(N'check_id 99: Computed Columns That Reference Functions', 0,1) WITH NOWAIT;
                INSERT    #BlitzIndexResults ( check_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
		SELECT  99 AS check_id, 
				50 AS Priority,
				'Cold Calculators' AS findings_group,
				'Serial Forcer' AS finding,
				cc.database_name,
				'' AS URL,
				'The computed column ' + QUOTENAME(cc.column_name) + ' on ' + QUOTENAME(cc.schema_name) + '.' + QUOTENAME(cc.table_name) + ' is based on ' + cc.definition 
				+ '. That indicates it may reference a scalar function, or a CLR function with data access, which can cause all queries and maintenance to run serially.' AS details,
				cc.column_definition,
				'N/A' AS secret_columns,
				'N/A' AS index_usage_summary,
				'N/A' AS index_size_summary
		FROM #ComputedColumns AS cc
		WHERE cc.is_function = 1

		RAISERROR(N'check_id 100: Computed Columns that are not Persisted.', 0,1) WITH NOWAIT;
        INSERT    #BlitzIndexResults ( check_id, Priority, findings_group, finding, [database_name], URL, details, index_definition,
                                               secret_columns, index_usage_summary, index_size_summary )
		SELECT  100 AS check_id, 
				200 AS Priority,
				'Cold Calculators' AS findings_group,
				'Definition Defeatists' AS finding,
				cc.database_name,
				'' AS URL,
				'The computed column ' + QUOTENAME(cc.column_name) + ' on ' + QUOTENAME(cc.schema_name) + '.' + QUOTENAME(cc.table_name) + ' is not persisted, which means it will be calculated when a query runs.' + 
				'You can change this with the following command, if the definition is deterministic: ALTER TABLE ' + QUOTENAME(cc.schema_name) + '.' + QUOTENAME(cc.table_name) + ' ALTER COLUMN ' + cc.column_name +
				' ADD PERSISTED'  AS details,
				cc.column_definition,
				'N/A' AS secret_columns,
				'N/A' AS index_usage_summary,
				'N/A' AS index_size_summary
		FROM #ComputedColumns AS cc
		WHERE cc.is_persisted = 0

	END 
 
        RAISERROR(N'Insert a row to help people find help', 0,1) WITH NOWAIT;
        IF DATEDIFF(MM, @VersionDate, GETDATE()) &gt; 6
		BEGIN
            INSERT    #BlitzIndexResults ( Priority, check_id, findings_group, finding, URL, details, index_definition,
                                            index_usage_summary, index_size_summary )
            VALUES  ( -1, 0 , 
		           'Outdated sp_BlitzIndex', 'sp_BlitzIndex is Over 6 Months Old', 'http://FirstResponderKit.org/', 
                   'Fine wine gets better with age, but this ' + @ScriptVersionName + ' is more like bad cheese. Time to get a new one.',
                    N'',N'',N''
                    );
        END

        IF EXISTS(SELECT * FROM #BlitzIndexResults)
		BEGIN
            INSERT    #BlitzIndexResults ( Priority, check_id, findings_group, finding, URL, details, index_definition,
                                            index_usage_summary, index_size_summary )
            VALUES  ( -1, 0 , 
		            @ScriptVersionName,
                    CASE WHEN @GetAllDatabases = 1 THEN N'All Databases' ELSE N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + CONVERT(NVARCHAR(16),GETDATE(),121) END, 
                    N'From Your Community Volunteers' ,   N'http://FirstResponderKit.org' ,
                    N''
                    , N'',N''
                    );
        END
        ELSE IF @Mode = 0 OR (@GetAllDatabases = 1 AND @Mode &lt;&gt; 4)
        BEGIN
            INSERT    #BlitzIndexResults ( Priority, check_id, findings_group, finding, URL, details, index_definition,
                                            index_usage_summary, index_size_summary )
            VALUES  ( -1, 0 , 
		            @ScriptVersionName,
                    CASE WHEN @GetAllDatabases = 1 THEN N'All Databases' ELSE N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + CONVERT(NVARCHAR(16),GETDATE(),121) END, 
                    N'From Your Community Volunteers' ,   N'http://FirstResponderKit.org' ,
                    N''
                    , N'',N''
                    );
            INSERT    #BlitzIndexResults ( Priority, check_id, findings_group, finding, URL, details, index_definition,
                                            index_usage_summary, index_size_summary )
            VALUES  ( 1, 0 , 
		           'No Major Problems Found',
                   'Nice Work!',
                   'http://FirstResponderKit.org', 'Consider running with @Mode = 4 in individual databases (not all) for more detailed diagnostics.', 'The new default Mode 0 only looks for very serious index issues.', '', ''
                    );

        END
        ELSE
        BEGIN
            INSERT    #BlitzIndexResults ( Priority, check_id, findings_group, finding, URL, details, index_definition,
                                            index_usage_summary, index_size_summary )
            VALUES  ( -1, 0 , 
		            @ScriptVersionName,
                    CASE WHEN @GetAllDatabases = 1 THEN N'All Databases' ELSE N'Database ' + QUOTENAME(@DatabaseName) + N' as of ' + CONVERT(NVARCHAR(16),GETDATE(),121) END, 
                    N'From Your Community Volunteers' ,   N'http://www.BrentOzar.com/BlitzIndex' ,
                    N''
                    , N'',N''
                    );
            INSERT    #BlitzIndexResults ( Priority, check_id, findings_group, finding, URL, details, index_definition,
                                            index_usage_summary, index_size_summary )
            VALUES  ( 1, 0 , 
		           'No Problems Found',
                   'Nice job! Or more likely, you have a nearly empty database.',
                   'http://FirstResponderKit.org', 'Time to go read some blog posts.', '', '', ''
                    );

        END

        RAISERROR(N'Returning results.', 0,1) WITH NOWAIT;
            
        /*Return results.*/
        IF (@Mode = 0)
        BEGIN

            SELECT Priority, ISNULL(br.findings_group,N'') + 
                    CASE WHEN ISNULL(br.finding,N'') &lt;&gt; N'' THEN N': ' ELSE N'' END
                    + br.finding AS [Finding], 
                br.[database_name] AS [Database Name],
                br.details AS [Details: schema.table.index(indexid)], 
                br.index_definition AS [Definition: [Property]] ColumnName {datatype maxbytes}], 
                ISNULL(br.secret_columns,'') AS [Secret Columns],          
                br.index_usage_summary AS [Usage], 
                br.index_size_summary AS [Size],
                COALESCE(br.more_info,sn.more_info,'') AS [More Info],
                br.URL, 
                COALESCE(br.create_tsql,ts.create_tsql,'') AS [Create TSQL]
            FROM #BlitzIndexResults br
            LEFT JOIN #IndexSanity sn ON 
                br.index_sanity_id=sn.index_sanity_id
            LEFT JOIN #IndexCreateTsql ts ON 
                br.index_sanity_id=ts.index_sanity_id
            WHERE br.check_id IN (0, 1, 11, 22, 43, 68, 50, 60, 61, 62, 63, 64, 65, 72)
            ORDER BY br.Priority ASC, br.check_id ASC, br.blitz_result_id ASC, br.findings_group ASC
			OPTION (RECOMPILE);

        END
        ELSE IF (@Mode = 4)
            SELECT Priority, ISNULL(br.findings_group,N'') + 
                    CASE WHEN ISNULL(br.finding,N'') &lt;&gt; N'' THEN N': ' ELSE N'' END
                    + br.finding AS [Finding], 
				br.[database_name] AS [Database Name],
                br.details AS [Details: schema.table.index(indexid)], 
                br.index_definition AS [Definition: [Property]] ColumnName {datatype maxbytes}], 
                ISNULL(br.secret_columns,'') AS [Secret Columns],          
                br.index_usage_summary AS [Usage], 
                br.index_size_summary AS [Size],
                COALESCE(br.more_info,sn.more_info,'') AS [More Info],
                br.URL, 
                COALESCE(br.create_tsql,ts.create_tsql,'') AS [Create TSQL]
            FROM #BlitzIndexResults br
            LEFT JOIN #IndexSanity sn ON 
                br.index_sanity_id=sn.index_sanity_id
            LEFT JOIN #IndexCreateTsql ts ON 
                br.index_sanity_id=ts.index_sanity_id
            ORDER BY br.Priority ASC, br.check_id ASC, br.blitz_result_id ASC, br.findings_group ASC
			OPTION (RECOMPILE);

    END; /* End @Mode=0 or 4 (diagnose)*/
    ELSE IF @Mode=1 /*Summarize*/
    BEGIN
    --This mode is to give some overall stats on the database.
        RAISERROR(N'@Mode=1, we are summarizing.', 0,1) WITH NOWAIT;

        SELECT DB_NAME(i.database_id) AS [Database Name],
            CAST((COUNT(*)) AS NVARCHAR(256)) AS [Number Objects],
            CAST(CAST(SUM(sz.total_reserved_MB)/
                1024. AS NUMERIC(29,1)) AS NVARCHAR(500)) AS [All GB],
            CAST(CAST(SUM(sz.total_reserved_LOB_MB)/
                1024. AS NUMERIC(29,1)) AS NVARCHAR(500)) AS [LOB GB],
            CAST(CAST(SUM(sz.total_reserved_row_overflow_MB)/
                1024. AS NUMERIC(29,1)) AS NVARCHAR(500)) AS [Row Overflow GB],
            CAST(SUM(CASE WHEN index_id=1 THEN 1 ELSE 0 END)AS NVARCHAR(50)) AS [Clustered Tables],
            CAST(SUM(CASE WHEN index_id=1 THEN sz.total_reserved_MB ELSE 0 END)
                /1024. AS NUMERIC(29,1)) AS [Clustered Tables GB],
            SUM(CASE WHEN index_id NOT IN (0,1) THEN 1 ELSE 0 END) AS [NC Indexes],
            CAST(SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)
                /1024. AS NUMERIC(29,1)) AS [NC Indexes GB],
            CASE WHEN SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)  &gt; 0 THEN
                CAST(SUM(CASE WHEN index_id IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)
                    / SUM(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END) AS NUMERIC(29,1)) 
                ELSE 0 END AS [ratio table: NC Indexes],
            SUM(CASE WHEN index_id=0 THEN 1 ELSE 0 END) AS [Heaps],
            CAST(SUM(CASE WHEN index_id=0 THEN sz.total_reserved_MB ELSE 0 END)
                /1024. AS NUMERIC(29,1)) AS [Heaps GB],
            SUM(CASE WHEN index_id IN (0,1) AND partition_key_column_name IS NOT NULL THEN 1 ELSE 0 END) AS [Partitioned Tables],
            SUM(CASE WHEN index_id NOT IN (0,1) AND  partition_key_column_name IS NOT NULL THEN 1 ELSE 0 END) AS [Partitioned NCs],
            CAST(SUM(CASE WHEN partition_key_column_name IS NOT NULL THEN sz.total_reserved_MB ELSE 0 END)/1024. AS NUMERIC(29,1)) AS [Partitioned GB],
            SUM(CASE WHEN filter_definition &lt;&gt; '' THEN 1 ELSE 0 END) AS [Filtered Indexes],
            SUM(CASE WHEN is_indexed_view=1 THEN 1 ELSE 0 END) AS [Indexed Views],
            MAX(total_rows) AS [Max Row Count],
            CAST(MAX(CASE WHEN index_id IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)
                /1024. AS NUMERIC(29,1)) AS [Max Table GB],
            CAST(MAX(CASE WHEN index_id NOT IN (0,1) THEN sz.total_reserved_MB ELSE 0 END)
                /1024. AS NUMERIC(29,1)) AS [Max NC Index GB],
            SUM(CASE WHEN index_id IN (0,1) AND sz.total_reserved_MB &gt; 1024 THEN 1 ELSE 0 END) AS [Count Tables &gt; 1GB],
            SUM(CASE WHEN index_id IN (0,1) AND sz.total_reserved_MB &gt; 10240 THEN 1 ELSE 0 END) AS [Count Tables &gt; 10GB],
            SUM(CASE WHEN index_id IN (0,1) AND sz.total_reserved_MB &gt; 102400 THEN 1 ELSE 0 END) AS [Count Tables &gt; 100GB],    
            SUM(CASE WHEN index_id NOT IN (0,1) AND sz.total_reserved_MB &gt; 1024 THEN 1 ELSE 0 END) AS [Count NCs &gt; 1GB],
            SUM(CASE WHEN index_id NOT IN (0,1) AND sz.total_reserved_MB &gt; 10240 THEN 1 ELSE 0 END) AS [Count NCs &gt; 10GB],
            SUM(CASE WHEN index_id NOT IN (0,1) AND sz.total_reserved_MB &gt; 102400 THEN 1 ELSE 0 END) AS [Count NCs &gt; 100GB],
            MIN(create_date) AS [Oldest Create Date],
            MAX(create_date) AS [Most Recent Create Date],
            MAX(modify_date) AS [Most Recent Modify Date],
            1 AS [Display Order]
        FROM #IndexSanity AS i
        --left join here so we don't lose disabled nc indexes
        LEFT JOIN #IndexSanitySize AS sz 
            ON i.index_sanity_id=sz.index_sanity_id
		GROUP BY DB_NAME(i.database_id)	 
        UNION ALL
        SELECT  CASE WHEN @GetAllDatabases = 1 THEN N'All Databases' ELSE N'Database ' + N' as of ' + CONVERT(NVARCHAR(16),GETDATE(),121) END,        
                @ScriptVersionName,   
                N'From Your Community Volunteers' ,   
                N'http://FirstResponderKit.org' ,
                N'',
                NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                NULL,NULL,0 AS display_order
        ORDER BY [Display Order] ASC
        OPTION (RECOMPILE);
           
    END /* End @Mode=1 (summarize)*/
    ELSE IF @Mode=2 /*Index Detail*/
    BEGIN
        --This mode just spits out all the detail without filters.
        --This supports slicing AND dicing in Excel
        RAISERROR(N'@Mode=2, here''s the details on existing indexes.', 0,1) WITH NOWAIT;

        SELECT  [database_name] AS [Database Name], 
                [schema_name] AS [Schema Name], 
                [object_name] AS [Object Name], 
                ISNULL(index_name, '') AS [Index Name], 
                CAST(index_id AS VARCHAR(10))AS [Index ID],
                db_schema_object_indexid AS [Details: schema.table.index(indexid)], 
                CASE    WHEN index_id IN ( 1, 0 ) THEN 'TABLE'
                    ELSE 'NonClustered'
                    END AS [Object Type], 
                index_definition AS [Definition: [Property]] ColumnName {datatype maxbytes}],
                ISNULL(LTRIM(key_column_names_with_sort_order), '') AS [Key Column Names With Sort],
                ISNULL(count_key_columns, 0) AS [Count Key Columns],
                ISNULL(include_column_names, '') AS [Include Column Names], 
                ISNULL(count_included_columns,0) AS [Count Included Columns],
                ISNULL(secret_columns,'') AS [Secret Column Names], 
                ISNULL(count_secret_columns,0) AS [Count Secret Columns],
                ISNULL(partition_key_column_name, '') AS [Partition Key Column Name],
                ISNULL(filter_definition, '') AS [Filter Definition], 
                is_indexed_view AS [Is Indexed View], 
                is_primary_key AS [Is Primary Key],
                is_XML AS [Is XML],
                is_spatial AS [Is Spatial],
                is_NC_columnstore AS [Is NC Columnstore],
                is_CX_columnstore AS [Is CX Columnstore],
                is_disabled AS [Is Disabled], 
                is_hypothetical AS [Is Hypothetical],
                is_padded AS [Is Padded], 
                fill_factor AS [Fill Factor], 
                is_referenced_by_foreign_key AS [Is Reference by Foreign Key], 
                last_user_seek AS [Last User Seek], 
                last_user_scan AS [Last User Scan], 
                last_user_lookup AS [Last User Lookup],
                last_user_update AS [Last User Update], 
                total_reads AS [Total Reads], 
                user_updates AS [User Updates], 
                reads_per_write AS [Reads Per Write], 
                index_usage_summary AS [Index Usage], 
                sz.partition_count AS [Partition Count],
                sz.total_rows AS [Rows], 
                sz.total_reserved_MB AS [Reserved MB], 
                sz.total_reserved_LOB_MB AS [Reserved LOB MB], 
                sz.total_reserved_row_overflow_MB AS [Reserved Row Overflow MB],
                sz.index_size_summary AS [Index Size], 
                sz.total_row_lock_count AS [Row Lock Count],
                sz.total_row_lock_wait_count AS [Row Lock Wait Count],
                sz.total_row_lock_wait_in_ms AS [Row Lock Wait ms],
                sz.avg_row_lock_wait_in_ms AS [Avg Row Lock Wait ms],
                sz.total_page_lock_count AS [Page Lock Count],
                sz.total_page_lock_wait_count AS [Page Lock Wait Count],
                sz.total_page_lock_wait_in_ms AS [Page Lock Wait ms],
                sz.avg_page_lock_wait_in_ms AS [Avg Page Lock Wait ms],
                sz.total_index_lock_promotion_attempt_count AS [Lock Escalation Attempts],
                sz.total_index_lock_promotion_count AS [Lock Escalations],
                sz.data_compression_desc AS [Data Compression],
                i.create_date AS [Create Date],
                i.modify_date AS [Modify Date],
                more_info AS [More Info],
                1 AS [Display Order]
        FROM    #IndexSanity AS i --left join here so we don't lose disabled nc indexes
                LEFT JOIN #IndexSanitySize AS sz ON i.index_sanity_id = sz.index_sanity_id
        ORDER BY [Database Name], [Schema Name], [Object Name], [Index ID]
        OPTION (RECOMPILE);



    END /* End @Mode=2 (index detail)*/
    ELSE IF @Mode=3 /*Missing index Detail*/
    BEGIN
        SELECT 
            database_name AS [Database Name], 
            [schema_name] AS [Schema], 
            table_name AS [Table], 
            CAST((magic_benefit_number/@DaysUptime) AS BIGINT)
                AS [Magic Benefit Number], 
            missing_index_details AS [Missing Index Details], 
            avg_total_user_cost AS [Avg Query Cost], 
            avg_user_impact AS [Est Index Improvement], 
            user_seeks AS [Seeks], 
            user_scans AS [Scans],
            unique_compiles AS [Compiles], 
            equality_columns AS [Equality Columns], 
            inequality_columns AS [Inequality Columns], 
            included_columns AS [Included Columns], 
            index_estimated_impact AS [Estimated Impact], 
            create_tsql AS [Create TSQL], 
            more_info AS [More Info],
            1 AS [Display Order]
        FROM #MissingIndexes
        /* Minimum benefit threshold = 100k/day of uptime */
        WHERE (magic_benefit_number/@DaysUptime) &gt;= 100000
        UNION ALL
        SELECT                 
            @ScriptVersionName,   
            N'From Your Community Volunteers' ,   
            N'http://FirstResponderKit.org' ,
            100000000000,
            N'',
            NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
            NULL, 0 AS display_order
        ORDER BY [Display Order] ASC, [Magic Benefit Number] DESC
		OPTION (RECOMPILE);

    END /* End @Mode=3 (index detail)*/
END
END TRY

BEGIN CATCH
        RAISERROR (N'Failure analyzing temp tables.', 0,1) WITH NOWAIT;

        SELECT    @msg = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE();

        RAISERROR (@msg, 
               @ErrorSeverity, 
               @ErrorState 
               );
        
        WHILE @@trancount &gt; 0 
            ROLLBACK;

        RETURN;
    END CATCH;
GO
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>sp_BlitzTrace____script</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>sp_BlitzTrace____script</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>SET ANSI_NULLS ON;
SET ANSI_PADDING ON;
SET ANSI_WARNINGS ON;
SET ARITHABORT ON;
SET CONCAT_NULL_YIELDS_NULL ON;
SET QUOTED_IDENTIFIER ON;
SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;
GO
IF OBJECT_ID('dbo.sp_BlitzTrace') IS NOT NULL
    DROP PROCEDURE dbo.sp_BlitzTrace
GO
CREATE PROCEDURE dbo.sp_BlitzTrace
    @Debug BIT = 0 , /* 1 prints the statement and won't execute it */
    @SessionId INT = NULL ,
    @Action VARCHAR(5) = NULL ,  /* 'start', 'read', 'stop', 'drop'*/
    @TargetPath VARCHAR(528) = NULL,  /* Required for 'start'. 'Read' will look for a running sp_BlitzTrace session if not specified.*/
    @TraceRecompiles BIT = 1,
    @TraceObjectCreates BIT = 1,
    @TraceParallelism BIT = 1,
    @TraceSortWarnings BIT = 1,
    @TraceStatements BIT = 0,
    @MaxFileSizeMB INT = 256,
    @TraceExecutionPlansAndKillMyPerformance BIT = 0, /* Non-production environments only */
    @MaxRolloverFiles INT = 4,
    @MaxDispatchLatencySeconds INT = 5 /* 0 is unlimited! */,
    @Help TINYINT = 0

WITH RECOMPILE
AS
IF @Help = 1 PRINT '
/*
sp_BlitzTrace from http://FirstResponderKit.org

Description: Starts, stops, and reads Extended Events traces.

--List running sessions
exec sp_BlitzTrace @Action=''start'';

--Start a trace for a session. You specify the @SessionID and @TargetPath
exec sp_BlitzTrace @SessionId=52, @TargetPath=''S:\XEvents\Traces\'', @Action=''start'';

--Stop a session
exec sp_BlitzTrace @Action=''stop'';

--Read the results. You can move the files to another server and read there by specifying a @TargetPath.
exec sp_BlitzTrace @Action=''read'';

--Drop the session. This does NOT delete files created in @TargetPath.
exec sp_BlitzTrace @Action=''drop'';

To learn more, visit http://FirstResponderKit.org where you can download new
versions for free, watch training videos on how it works, get more info on
the findings, contribute your own code, and more.

Known limitations of this version:
 - Extended Events can be hard.

Unknown limitations of this version:
 - Probably a lot. This is one of our lesser-tested scripts.

Changes in v1.0 - 2016/06/26
 - Switched to MIT licensing.
 - Added @Help parameter.

MIT License

Copyright (c) 2016 Brent Ozar Unlimited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
'

    DECLARE @nl NVARCHAR(2) = NCHAR(13) + NCHAR(10) ;

    SET NOCOUNT ON;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    SET XACT_ABORT ON;

BEGIN TRY

    DECLARE @msg NVARCHAR(MAX);
    DECLARE @rowcount INT;
    DECLARE @v decimal(6,2);
    DECLARE @build int;
    DECLARE @datestamp VARCHAR(30);
    DECLARE @TargetPathFull NVARCHAR(MAX);
    DECLARE @filepathXML XML;
    DECLARE @filepath VARCHAR(1024);
    DECLARE @traceexists BIT = 0;
    DECLARE @tracerunning BIT = 0;



    /* Validate parameters */
    SET @msg = CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Validatin'' parameters.'
    RAISERROR (@msg,0,1) WITH NOWAIT;

    IF @Action NOT IN (N'start', N'read', N'stop', N'drop')  OR @Action is NULL
    BEGIN
        RAISERROR (N'You need to specify a valid @Action for sp_BlitzTrace: ''start'', ''read'', ''stop'', or ''drop''.',16,1) WITH NOWAIT;
    END

    IF @Action = N'start' AND @SessionId IS NULL
    BEGIN
        SELECT ses.session_id, con.last_read, con.last_write, ses.login_name, ses.host_name, ses.program_name,
            con.connect_time, con.protocol_type, con.encrypt_option,
            con.num_reads, con.num_writes, con.client_net_address,
            req.status, req.command, req.wait_type, req.last_wait_type, req.open_transaction_count
        FROM sys.dm_exec_sessions as ses
        JOIN sys.dm_exec_connections AS con ON
            con.session_id=ses.session_id
        LEFT JOIN sys.dm_exec_requests AS req ON
            con.session_id=req.session_id
        WHERE
            ses.session_id &lt;&gt; @@SPID
        ORDER BY last_read DESC

        RAISERROR (N'sp_BlitzTrace watches just one session, so you have to specify @SessionId. Check out the session list above for some ideas.',16,1) WITH NOWAIT;
    END

    IF @MaxDispatchLatencySeconds &gt; 99
    BEGIN
        RAISERROR (N'@MaxDispatchLatencySeconds must be 99 or less. 5 is the default. 0 is unlimited latency.',16,1) WITH NOWAIT;
    END

    IF @MaxFileSizeMB &gt; 9999
    BEGIN
        RAISERROR (N'@MaxFileSizeMB must be 9999 or smaller - 256MB is the default.',16,1) WITH NOWAIT;
    END

    IF @MaxRolloverFiles &gt; 99
    BEGIN
        RAISERROR (N'@MaxRolloverFiles must be 99 or smaller. 4 is the default.',16,1) WITH NOWAIT;
    END

    IF @TargetPath IS NULL AND @Action = N'start'
    BEGIN
        RAISERROR (N'You gotta give a valid @TargetPath for ''start''.',16,1) WITH NOWAIT;
    END

    IF @TargetPath IS NOT NULL AND @Action=N'start' AND RIGHT(@TargetPath, 1) &lt;&gt; N'\'
    BEGIN
        RAISERROR (N'@TargetPath must be a directory ending in ''\'', like: ''S:\Xevents\''',16,1) WITH NOWAIT;
    END


    IF @TargetPath IS NOT NULL AND @Action='read' AND  ( RIGHT(@TargetPath, 1) &lt;&gt; '\' AND RIGHT(@TargetPath, 4) &lt;&gt; '.xel')
    BEGIN
        RAISERROR (N'To read, @TargetPath must be a directory ending in ''\'', like: ''S:\XEvents\'', or a file ending in .xel, like ''S:\XEvents\sp_BlitzTrace*.xel''',16,1) WITH NOWAIT;
    END

    /* Validate transaction state */
    SET @msg = CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Validatin'' transaction state.'
    RAISERROR (@msg,0,1) WITH NOWAIT;
    IF @@TRANCOUNT &gt; 0
    BEGIN
        RAISERROR (N'@@TRANCOUNT &gt; 0 not supported',16,1) WITH NOWAIT;
    END

    /* Check version */
    SET @msg = CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Determining SQL Server version.'
    RAISERROR (@msg,0,1) WITH NOWAIT;

    SELECT @v = SUBSTRING(CAST(SERVERPROPERTY('ProductVersion') as NVARCHAR(128)), 1,CHARINDEX('.', CAST(SERVERPROPERTY('ProductVersion') as NVARCHAR(128))) + 1 )

    IF @v &lt; N'11'
    BEGIN
        SET @msg = N'Sad news: most the events sp_BlitzTrace uses are only in SQL Server 2012 and higher-- so it''s not supported on SQL 2008/R2.'
        RAISERROR (@msg,16,1) WITH NOWAIT;
        RETURN;
    END


    /* Get current trace status */
    SELECT
        @traceexists = (CASE WHEN (s.name IS NULL) THEN 0 ELSE 1 END),
        @tracerunning = (CASE WHEN (r.create_time IS NULL) THEN 0 ELSE 1 END)
    FROM sys.server_event_sessions AS s
    LEFT OUTER JOIN sys.dm_xe_sessions AS r ON r.name = s.name
    WHERE s.name=N'sp_BlitzTrace'


    /* We use this to filter sp_BlitzTrace activity out of the results, */
    /* in case you're tracing your own session. */
    /* That's just to make the results less confusing */
    DECLARE @context VARBINARY(128);
    SET @context=CAST('sp_BlitzTrace IS THE BEST' as binary);
    SET CONTEXT_INFO @context;

    IF @Action = N'start'
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Creating extended events trace.'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        IF @traceexists = 1
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- A trace named sp_BlitzTrace already exists'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            IF @tracerunning=1
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- sp_BlitzTrace is running, so stopping it before we recreate: ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = STOP;'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = STOP;

                SET @tracerunning=0;
            END

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Dropping the trace: DROP EVENT SESSION sp_BlitzTrace ON SERVER; '
            RAISERROR (@msg,0,1) WITH NOWAIT;

            DROP EVENT SESSION sp_BlitzTrace ON SERVER;

            SET @traceexists=0;

        END

        IF @traceexists = 0
        BEGIN
            SELECT @datestamp = REPLACE(REPLACE( CONVERT(VARCHAR(26),getdate(),126),':','-'),'.','')
            SET @TargetPathFull=@TargetPath + N'sp_BlitzTrace-' + @datestamp

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Target path = ' + @TargetPathFull;
            RAISERROR (@msg,0,1) WITH NOWAIT;


            DECLARE @dsql NVARCHAR(MAX);
            DECLARE @dsql1 NVARCHAR(MAX)=
                N'CREATE EVENT SESSION sp_BlitzTrace ON SERVER
                ' + case @TraceStatements when 1 then + N'
                ADD EVENT sqlserver.sp_statement_completed (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ADD EVENT sqlserver.sql_statement_completed (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END + case @TraceSortWarnings when 1 then N'
                ADD EVENT sqlserver.sort_warning (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END + case @TraceParallelism when 1 then + N'
                ADD EVENT sqlserver.degree_of_parallelism (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END + N'
                ' + case @TraceObjectCreates when 1 then + N'
                ADD EVENT sqlserver.object_created (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END;

            DECLARE @dsql2 NVARCHAR(MAX)=
                N'ADD EVENT sqlserver.sql_batch_completed (
                    ACTION(sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' + case @TraceRecompiles when 1 then + N'
                ADD EVENT sqlserver.sql_statement_recompile (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END
                + case @TraceExecutionPlansAndKillMyPerformance when 1 then + N'
                ADD EVENT sqlserver.query_post_execution_showplan (
                    ACTION(sqlserver.context_info, sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N'))),
                ' ELSE N'' END + N'
                ADD EVENT sqlserver.rpc_completed (
                    ACTION(sqlserver.sql_text, sqlserver.query_hash, sqlserver.query_plan_hash)
                    WHERE ([sqlserver].[session_id]=('+ CAST(@SessionId as NVARCHAR(6)) + N')))
                ADD TARGET package0.event_file(SET filename=''' + @TargetPathFull + N''',
                    MAX_FILE_SIZE=(' + CAST(@MaxFileSizeMB AS VARCHAR(4)) + N'),
                    MAX_ROLLOVER_FILES = ' + CAST(@MaxRolloverFiles as VARCHAR(2)) + N')
                WITH (
                    MAX_MEMORY = 128 MB,
                    EVENT_RETENTION_MODE = ALLOW_MULTIPLE_EVENT_LOSS,
                    MAX_DISPATCH_LATENCY = ' + CAST(@MaxDispatchLatencySeconds AS NVARCHAR(2)) + N' SECONDS,
                    MEMORY_PARTITION_MODE=NONE,
                    TRACK_CAUSALITY=OFF,
                    STARTUP_STATE=OFF)';

            SET @dsql=@dsql1 + @dsql2;

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Creating trace with dynamic SQL. I REGRET NOTHING!!!'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            IF @Debug=1
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Debug mode, printing but not executing.'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                RAISERROR (@nl,0,1) WITH NOWAIT;

                RAISERROR (@dsql1,0,0) WITH NOWAIT;
                RAISERROR (@dsql2,0,0) WITH NOWAIT;
            END
            ELSE
            BEGIN

                EXEC sp_executesql @dsql;

            END
            SET @traceexists = 1;
        END

        IF @tracerunning = 0
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = START;'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            IF @Debug=0
            BEGIN
                ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = START;

                SET @tracerunning = 1;
            END
            ELSE
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- @Debug=1, not starting trace;'
                RAISERROR (@msg,0,1) WITH NOWAIT;
            END
        END
    END
    IF @Action = 'read'
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Reading, processing, and reporting.'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        IF @traceexists = 0
        BEGIN
            SET @filepath=@TargetPath + N'*.xel';

        END

        /* Figure out the file name for current trace, if it's running */
        if @tracerunning=1
        BEGIN
            SELECT TOP 1 @filepathXML= x.target_data
            FROM sys.dm_xe_sessions as se
            JOIN sys.dm_xe_session_targets as t on
                se.address=t.event_session_address
            CROSS APPLY (SELECT cast(t.target_data as XML) AS target_data) as x
            WHERE se.name=N'sp_BlitzTrace'
            OPTION (RECOMPILE);

            SELECT @filepath=CAST(@filepathXML.query('data(EventFileTarget/File/@name)') AS VARCHAR(1024))
        END
        ELSE /* Figure out the file path for the trace if exists and isn't running */
        BEGIN
            SELECT TOP 1 @filepath=CAST(f.value AS VARCHAR(1024)) + N'*.xel'
            FROM sys.server_event_sessions AS ses
            LEFT OUTER JOIN sys.dm_xe_sessions AS running ON
                running.name = ses.name
            JOIN sys.server_event_session_targets AS t ON
                ses.event_session_id = t.event_session_id
                and t.package = 'package0'
                and t.name='event_file'
                and ses.name='sp_BlitzTrace'
            JOIN sys.dm_xe_objects AS o ON
                t.name = o.name
                AND o.object_type='target'
            JOIN sys.dm_xe_object_columns AS c ON
                t.name = c.object_name AND
                c.column_type = 'customizable' AND
                c.name='filename'
            JOIN sys.server_event_session_fields AS f ON
                t.event_session_id = f.event_session_id AND
                t.target_id = f.object_id
                AND c.name = f.name
        END

        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Using filepath: ' + @filepath
        RAISERROR (@msg,0,1) WITH NOWAIT;

        IF @Debug = 0
        BEGIN
            CREATE TABLE #sp_BlitzTraceXML (
                event_data XML NOT NULL
            );

            CREATE TABLE #sp_BlitzTraceEvents (
                event_time DATETIME2 NOT NULL,
                event_type NVARCHAR(256) NOT NULL,
                batch_text VARCHAR(MAX) NULL,
                sql_text VARCHAR(MAX) NULL,
                [statement] VARCHAR(MAX) NULL,
                duration_micros INT NULL,
                cpu_micros INT NULL,
                physical_reads INT NULL,
                logical_reads INT NULL,
                writes INT NULL,
                row_count INT NULL,
                result NVARCHAR(256) NULL,
                dop_statement_type SYSNAME NULL,
                dop INT NULL,
                workspace_memory_grant_kb INT NULL,
                object_id INT NULL,
                object_type sysname NULL,
                object_name sysname NULL,
                ddl_phase sysname NULL,
                recompile_cause sysname NULL,
                sort_warning_type VARCHAR(256) NULL,
                query_operation_node_id INT NULL,
                query_hash varchar(256) NULL,
                query_plan_hash varchar(256) NULL,
                estimated_cost bigint NULL,
                [showplan_xml] XML NULL,
                context_info sysname NULL,
                event_data XML NOT NULL
            )

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Populating #sp_BlitzTraceXML...'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            INSERT #sp_BlitzTraceXML (event_data)
            SELECT
                x.event_data
            FROM  sys.fn_xe_file_target_read_file(@filepath,null,null,null) as xet
            CROSS APPLY (SELECT CAST(event_data AS XML) AS event_data) as x
            OUTER APPLY x.event_data.nodes('//event') AS y(n) OPTION (RECOMPILE);

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Started populating #sp_BlitzTraceEvents...'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            INSERT #sp_BlitzTraceEvents (event_time, event_type, batch_text, sql_text, [statement], duration_micros, cpu_micros, physical_reads,
            logical_reads, writes, row_count, result, dop_statement_type, dop, workspace_memory_grant_kb, object_id, object_type,
            object_name, ddl_phase, recompile_cause, sort_warning_type, query_operation_node_id, query_hash, query_plan_hash,
            estimated_cost, [showplan_xml], context_info, event_data)
            SELECT
                DATEADD(mi, DATEDIFF(mi, GETUTCDATE(), CURRENT_TIMESTAMP), n.value('@timestamp', 'datetime2')) AS event_time,
                n.value('@name', 'NVARCHAR(max)') AS event_type,
                n.value('(data[@name="batch_text"]/value)[1]', 'varchar(max)') AS batch_text,
                n.value('(action[@name="sql_text"]/value)[1]', 'varchar(max)') AS sql_text,
                n.value('(data[@name="statement"]/value)[1]', 'varchar(max)') AS [statement],
                n.value('(data[@name="duration"]/value)[1]', 'int') AS duration_micros,
                n.value('(data[@name="cpu_time"]/value)[1]', 'int') AS cpu_micros,
                n.value('(data[@name="physical_reads"]/value)[1]', 'int') AS physical_reads,
                n.value('(data[@name="logical_reads"]/value)[1]', 'int') AS logical_reads,
                n.value('(data[@name="writes"]/value)[1]', 'int') AS writes,
                n.value('(data[@name="row_count"]/value)[1]', 'int') AS row_count,
                n.value('(data[@name="result"]/text)[1]', 'varchar(256)') AS result,

                /* Parallelism */
                n.value('(data[@name="statement_type"]/text)[1]', 'varchar(256)') AS dop_statement_type,
                n.value('(data[@name="dop"]/value)[1]', 'int') AS dop,
                n.value('(data[@name="workspace_memory_grant_kb"]/value)[1]', 'bigint') AS workspace_memory_grant_kb,

                /* Object create comes in pairs, begin and end */
                n.value('(data[@name="object_id"]/value)[1]', 'int') AS [object_id],
                n.value('(data[@name="object_type"]/value)[1]', 'varchar(256)') AS object_type,
                n.value('(data[@name="object_name"]/value)[1]', 'varchar(256)') AS [object_name],
                n.value('(data[@name="ddl_phase"]/value)[1]', 'varchar(256)') AS ddl_phase,

                /* Recompiles */
                n.value('(data[@name="recompile_cause"]/text)[1]', 'varchar(256)') AS recompile_cause,

                /* tempdb spills */
                n.value('(data[@name="sort_warning_type"]/text)[1]', 'varchar(256)') AS sort_warning_type,
                n.value('(data[@name="query_operation_node_id"]/value)[1]', 'varchar(256)') AS query_operation_node_id,

                /* query hash and query plan hash */
                n.value('(action[@name="query_hash"]/value)[1]', 'varchar(256)') AS query_hash,
                n.value('(action[@name="query_plan_hash"]/value)[1]', 'varchar(256)') AS query_plan_hash,

                /* actual execution plan */
                n.value('(data[@name="estimated_cost"]/value)[1]', 'bigint') AS estimated_cost,
                n.query('(data[@name="showplan_xml"]/value/*)[1]') AS [showplan_xml],

                /* Context info, for filtering */
                n.value('(action[@name="context_info"]/value)[1]', 'VARCHAR(MAX)') AS [context_info],
                x.event_data as event_data
            FROM #sp_BlitzTraceXML AS xet
            CROSS APPLY (SELECT CAST(xet.event_data AS XML) AS event_data) as x
            OUTER APPLY x.event_data.nodes('//event') AS y(n)
            OPTION (RECOMPILE);

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Finished populating #sp_BlitzTraceEvents...'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            SET @rowcount=@@ROWCOUNT;

            IF @rowcount = 0
            BEGIN
                RAISERROR('No rows found in the trace for these events for your session id',0,1) WITH NOWAIT;
            END
            ELSE
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- ' + CAST(@rowcount AS NVARCHAR(20)) + N' rows inserted into #sp_BlitzTraceEvents.'
                RAISERROR (@msg,0,1) WITH NOWAIT;
            END

            CREATE CLUSTERED INDEX cx_spBlitzTrace on #sp_BlitzTraceEvents (event_type, event_time)

            DELETE FROM #sp_BlitzTraceEvents
            WHERE (@SessionId=@@SPID and [context_info] = '73705f426c69747a5472616365204953205448452042455354')
            OR PATINDEX('%sp_BlitzTrace%',batch_text) &lt;&gt; 0
            OR PATINDEX('%sp_BlitzTrace%',sql_text) &lt;&gt; 0
                OPTION (RECOMPILE);

            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying sql_batch_completed, rpc_completed, sql_statement_completed, sp_statement_completed...'
            RAISERROR (@msg,0,1) WITH NOWAIT;
            /* sql_batch_completed, rpc_completed */
            SELECT
                event_time,
                event_type,
                batch_text,
                [statement],
                sql_text,
                duration_micros,
                cpu_micros,
                physical_reads,
                logical_reads,
                writes,
                row_count,
                result,
                query_hash,
                query_plan_hash,
                event_data
            FROM #sp_BlitzTraceEvents
            WHERE event_type in (N'sql_batch_completed',N'rpc_completed','sql_statement_completed', 'sp_statement_completed')
            ORDER BY 1;

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'degree_of_parallelism')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying parallelism and memory grant...'
                RAISERROR (@msg,0,1) WITH NOWAIT;
                /* parallelism and memory grant */
                SELECT
                    event_time,
                    event_type,
                    sql_text,
                    dop_statement_type,
                    dop,
                    workspace_memory_grant_kb,
                    query_hash,
                    query_plan_hash,
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'degree_of_parallelism'
                  and query_hash &lt;&gt; '0'
                ORDER BY 1;
            END

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'object_created')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying object_created ...'
                RAISERROR (@msg,0,1) WITH NOWAIT;
                /* object_created */
                SELECT
                    event_time,
                    event_type,
                    sql_text,
                    [object_id],
                    [object_name],
                    cpu_micros,
                    ddl_phase,
                    query_hash,
                    query_plan_hash,
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'object_created'
                ORDER BY 1;
            END

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'sql_statement_recompile')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying sql_statement_recompile ...'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                /* sql_statement_recompile */
                SELECT
                    event_time,
                    event_type,
                    sql_text,
                    recompile_cause,
                    query_hash,
                    query_plan_hash,
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'sql_statement_recompile'
                ORDER BY 1;
            END

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'sort_warning')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying sort_warning ...'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                /* sql_statement_recompile */
                SELECT
                    event_time,
                    event_type,
                    sort_warning_type,
                    query_operation_node_id,
                    query_hash,
                    query_plan_hash,
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'sort_warning'
                ORDER BY 1;
            END

            IF (SELECT TOP 1 event_time FROM #sp_BlitzTraceEvents WHERE event_type = N'query_post_execution_showplan')
                IS NOT NULL
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Querying actual execution plans ...'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                /* sql_statement_recompile */
                SELECT
                    event_time,
                    estimated_cost,
                    [object_name],
                    sql_text,
                    [showplan_xml] as [hope_this_isn't_production],
                    event_data
                FROM #sp_BlitzTraceEvents
                WHERE event_type = 'query_post_execution_showplan'
                ORDER BY 1;
            END

        END
        ELSE /* We're in @Debug=1 mode */
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- @Debug=1, not reading sp_BlitzTrace Extended Events session files;'
            RAISERROR (@msg,0,1) WITH NOWAIT;
        END
    END

    IF @Action = 'stop'
    BEGIN
        IF @tracerunning = 1
        BEGIN
            IF @Debug = 0
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Stopping sp_BlitzTrace Extended Events session.'
                RAISERROR (@msg,0,1) WITH NOWAIT;

                ALTER EVENT SESSION sp_BlitzTrace ON SERVER STATE = STOP;

                SET @tracerunning = 0;
            END
            ELSE /* @Debug=1 */
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- @Debug=1, sp_BlitzTrace Extended Events session is running but we are NOT stopping it;'
                RAISERROR (@msg,0,1) WITH NOWAIT;
            END
        END
        ELSE
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- No running sp_BlitzTrace Extended Events session to stop.'
            RAISERROR (@msg,16,1) WITH NOWAIT;
        END
    END


    IF @Action = 'drop'
    BEGIN
        IF @traceexists = 1
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Dropping sp_BlitzTrace Extended Events session.'
            RAISERROR (@msg,0,1) WITH NOWAIT;

            IF @Debug=0
            BEGIN
                DROP EVENT SESSION sp_BlitzTrace ON SERVER;

                SET @traceexists=0;
            END
            ELSE /* @Debug=1 */
            BEGIN
                SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- @Debug=1, sp_BlitzTrace Extended Events session exists but we are NOT dropping it.'
                RAISERROR (@msg,0,1) WITH NOWAIT;
            END
        END
        ELSE
        BEGIN
            SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- No sp_BlitzTrace XEvents trace to drop.'
            RAISERROR (@msg,16,1) WITH NOWAIT;
        END
    END

    RAISERROR (@nl,0,1) WITH NOWAIT;
    RAISERROR (N'********************READ ME!********************',0,1) WITH NOWAIT;


    IF @traceexists = 1 and @tracerunning = 0
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Extended Events session sp_BlitzTrace exists, but is stopped.'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- To drop sp_BlitzTrace, run: exec dbo.sp_BlitzTrace @Action=''drop'';'
        RAISERROR (@msg,0,1) WITH NOWAIT;

    END
    ELSE IF @traceexists = 1 and @tracerunning = 1
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Extended Events session sp_BlitzTrace exists and is running' +
            CASE WHEN @SessionId is not null
               THEN N' for @SessionId=' + cast(@SessionId as NVARCHAR(5))
               ELSE N''
               END
        RAISERROR (@msg,0,1) WITH NOWAIT;

        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Don''t leave the sp_BlitzTrace session running for long periods!'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- To stop sp_BlitzTrace, run: exec dbo.sp_BlitzTrace @Action=''stop'';'
        RAISERROR (@msg,0,1) WITH NOWAIT;
    END
    ELSE IF @traceexists = 0
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Extended Events session sp_BlitzTrace doesn''t exist, we''re all cleaned up.'
        RAISERROR (@msg,0,1) WITH NOWAIT;
    END

    RAISERROR (N'********************SEE YA********************',0,1) WITH NOWAIT;

    SET CONTEXT_INFO 0x;
END TRY
BEGIN CATCH

    SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Catching error ...'
    RAISERROR (@msg,0,1) WITH NOWAIT;

    SELECT
        ERROR_NUMBER() AS ErrorNumber
        ,ERROR_SEVERITY() AS ErrorSeverity
        ,ERROR_STATE() AS ErrorState
        ,ERROR_PROCEDURE() AS ErrorProcedure
        ,ERROR_LINE() AS ErrorLine
        ,ERROR_MESSAGE() AS ErrorMessage;

    /* Re-check trace status */
    SELECT
        @traceexists = (CASE WHEN (s.name IS NULL) THEN 0 ELSE 1 END),
        @tracerunning = (CASE WHEN (r.create_time IS NULL) THEN 0 ELSE 1 END)
    FROM sys.server_event_sessions AS s
    LEFT OUTER JOIN sys.dm_xe_sessions AS r ON r.name = s.name
    WHERE s.name='sp_BlitzTrace'


    IF @Action='start' and @traceexists=1
    BEGIN
        SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- An error occurred starting the trace. Cleaning it up.'
        RAISERROR (@msg,0,1) WITH NOWAIT;

        DROP EVENT SESSION sp_BlitzTrace ON SERVER;
    END

    SET @msg= CONVERT(NVARCHAR(30), GETDATE(), 126) + N'- Resetting context and we''re outta here.'
    RAISERROR (@msg,0,1) WITH NOWAIT;

    SET CONTEXT_INFO 0x;

END CATCH

GO
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>WhichDriveHasTheFiles_WhatTypeOf_Recovery</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>WhichDriveHasTheFiles_WhatTypeOf_Recovery</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0000_216_WhichDriveHasTheFiles_WhatTypeOf_Recovery.sql

-- From eBooksSQLServerTacklebox.pdf, Chapter 2

IF EXISTS ( SELECT  *
            FROM    tempdb.dbo.sysobjects
            WHERE   id = OBJECT_ID(N'[tempdb].[dbo].[HoldforEachDB]') ) 
    DROP TABLE [tempdb].[dbo].[HoldforEachDB] ; 
CREATE TABLE [tempdb].[dbo].[HoldforEachDB]
    (
      [Server] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                               NULL,
      [DatabaseName] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                                     NOT NULL,
      [Size] [int] NOT NULL,
      [File_Status] [int] NULL,
      [Name] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                             NOT NULL,
      [Filename] [nvarchar](260) COLLATE SQL_Latin1_General_CP1_CI_AS
                                 NOT NULL,
      [Status] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                               NULL,
      [Updateability] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                                      NULL,
      [User_Access] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                                    NULL,
      [Recovery] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                                 NULL
    )
ON  [PRIMARY]
INSERT  INTO [tempdb].[dbo].[HoldforEachDB]
        EXEC sp_MSforeachdb 'SELECT CONVERT(char(100), SERVERPROPERTY(''Servername'')) AS Server,
                 ''?'' as DatabaseName,[?]..sysfiles.size, [?]..sysfiles.status, [?]..sysfiles.name, [?]..sysfiles.filename,convert(sysname,DatabasePropertyEx(''?'',''Status'')) as Status,
convert(sysname,DatabasePropertyEx(''?'',''Updateability'')) as Updateability,
 convert(sysname,DatabasePropertyEx(''?'',''UserAccess'')) as User_Access,
convert(sysname,DatabasePropertyEx(''?'',''Recovery'')) as Recovery From [?]..sysfiles '

SELECT [Server]
      ,[DatabaseName]
      ,[Size]
      ,[File_Status]
      ,[Name]
      ,[Filename]
      ,[Status]
      ,[Updateability]
      ,[User_Access]
      ,[Recovery]
  FROM [tempdb].[dbo].[HoldforEachDB] 
  Order by Recovery, DatabaseName

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TroubleShooting</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>WhoHasAccess_ToWhichDatabase</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TroubleShooting</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>WhoHasAccess_ToWhichDatabase</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0000_218_WhoHasAccess_ToWhichDatabase.sql

-- From eBooksSQLServerTacklebox.pdf, Chapter 2


IF EXISTS ( SELECT  *
            FROM    tempdb.dbo.sysobjects
            WHERE   id = OBJECT_ID(N'[tempdb].[dbo].[SQL_DB_REP]') ) 
    DROP TABLE [tempdb].[dbo].[SQL_DB_REP] ; 
GO

CREATE TABLE [tempdb].[dbo].[SQL_DB_REP]
    (
      [Server] [varchar](100) NOT NULL,
      [DB_Name] [varchar](70) NOT NULL,
      [User_Name] [nvarchar](90) NULL,
      [Group_Name] [varchar](100) NULL,
      [Account_Type] [varchar](22) NULL,
      [Login_Name] [varchar](80) NULL,
      [Def_DB] [varchar](100) NULL
    )
ON  [PRIMARY]

INSERT  INTO [tempdb].[dbo].[SQL_DB_REP]
        Exec sp_MSForEachDB 'SELECT  
        CONVERT(varchar(100), SERVERPROPERTY(''Servername'')) AS Server, 
		''?'' AS DB_Name,usu.name u_name,
			CASE	WHEN (usg.uid is null) THEN ''public''
					ELSE usg.name
				    END as Group_Name,
			CASE	WHEN usu.isntuser=1 THEN ''Windows Domain Account'' 
					WHEN usu.isntgroup = 1 THEN ''Windows Group'' 
					WHEN usu.issqluser = 1 THEN''SQL Account'' 
					WHEN usu.issqlrole = 1 THEN ''SQL Role'' 
					END as Account_Type,
			lo.loginname,
            lo.dbname AS Def_DB
FROM
      [?]..sysusers usu LEFT OUTER JOIN
      ([?]..sysmembers mem INNER JOIN
      [?]..sysusers usg ON mem.groupuid = usg.uid)
      ON usu.uid = mem.memberuid LEFT OUTER JOIN 
      master.dbo.syslogins  lo ON usu.sid = lo.sid
WHERE
           ( usu.islogin = 1 AND 
				usu.isaliased = 0 AND 
				usu.hasdbaccess = 1) AND
          (usg.issqlrole = 1 OR 
			usg.uid is null)'


Select  *
from    [tempdb].[dbo].[SQL_DB_REP]
Order By Group_Name</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TVF_Table_Value_Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>about_TVF_Table_Value_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TVF_Table_Value_Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>about_TVF_Table_Value_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_TVF_Table_Value_Functions

/*

To view all of the table-valued functions contained in a database from within the Object Explorer tree, traverse this path:

Databases &gt; {the database} &gt; Programmability &gt; Functions &gt; Table-valued Functions

------------------------


The body of a table-valued function will essentially contain a query. 

A table valued function can only be used within a scope of a single SELECT statement. It cannot perform DML, catch exceptions etc.

On the other hand, it can return a set which can immediately be joined with another recordset in the same query.

If you use DML or don't need to use the output parameters in the set-based statements, use a stored proc; otherwise create a TVF.


Disadvantage					Details
==========================================================================================================
No side effects					A function can't insert, update or delete rows in permanent tables.
No stored procedures			A function can't call a standard stored procedure (although it can call extended stored procedures and other functions).
Deterministic functions only	A function can't call certain non-deterministic functions (ie ones whose return value isn't predictable) such as the rand function to generate a random number.
No temporary tables				You can't use temporary tables within a user-defined function.
Limited error trapping			You can't use TRY / CATCH clausee in functions that you create.


 By placing the query within the set of parentheses after the keyword RETURN, we have the body of the function.
 The RETURNS TABLE keyword specifies that the table-valued function GetAllProducts must return the result in the form of a table.
 */
CREATE FUNCTION GetAllProducts( )
RETURNS TABLE
AS
RETURN
(SELECT ProductID, ProductName, RetailPrice, Category
FROM CurrentProducts)
GO

/*
Just how do you query a table-valued function?  
The syntax is somewhat similar to how you would run a SELECT statement against a table or a view. 
All functions need to be called by using a set of parentheses with all required parameters inside them. 
If the function has no parameters (which is currently the case with GetAllProducts), 
then you will simply include an empty set of parentheses.
*/

SELECT * FROM GetAllProducts()
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TVF_Table_Value_Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Drop_Create_TVF</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TVF_Table_Value_Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Drop_Create_TVF</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE AdventureWorks2008
GO
IF OBJECT_ID(N'dbo.func_SalesOrderDetailInformation', N'TF') IS NOT NULL
DROP FUNCTION dbo.func_SalesOrderDetailInformation;
GO

CREATE FUNCTION dbo.func_SalesOrderDetailInformation
				(@SalesOrderRowGuids dbo.GUIDTableType READONLY)
RETURNS @retSalesOrderDetailInformation TABLE
	(
		-- Columns returned by the function
		[SalesOrderID]          [INT]          NOT NULL,
		[SalesOrderDetailID]    [INT]          NOT NULL,
		[CarrierTrackingNumber] [NVARCHAR](25) NULL,
		[OrderQty]              [SMALLINT]     NOT NULL,
		[ProductID]             [INT]          NOT NULL,
		[SpecialOfferID]        [INT]          NOT NULL,
		[UnitPrice]             [MONEY]        NOT NULL,
		[UnitPriceDiscount]     [MONEY]        NOT NULL,
		[LineTotal]             [NUMERIC]      NOT NULL,
		[ModifiedDate]          [DATETIME]     NOT NULL
	)
AS
-- Returns the first name, last name, job title, and contact type for the specified contact.
BEGIN
	INSERT @retSalesOrderDetailInformation
	SELECT Sales.SalesOrderDetail.SalesOrderID,
			Sales.SalesOrderDetail.SalesOrderDetailID,
			Sales.SalesOrderDetail.CarrierTrackingNumber,
			Sales.SalesOrderDetail.OrderQty,
			Sales.SalesOrderDetail.ProductID,
			Sales.SalesOrderDetail.SpecialOfferID,
			Sales.SalesOrderDetail.UnitPrice,
			Sales.SalesOrderDetail.UnitPriceDiscount,
			Sales.SalesOrderDetail.LineTotal,
			Sales.SalesOrderDetail.ModifiedDate
	FROM @SalesOrderRowGuids SalesOrderRowGuids
	INNER JOIN Sales.SalesOrderDetail ON Sales.SalesOrderDetail.rowguid = SalesOrderRowGuids.GUIDValue
	RETURN
END
GO

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TVF_Table_Value_Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Example_01</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TVF_Table_Value_Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Example_01</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>/*
The following example creates the dbo.ufnGetContactInformation function and demonstrates the components of the table-valued function. 
In this function, the local return variable name is @retContactInformation. 
Statements in the function body insert rows into this variable to build the table result returned by the function.
*/

USE AdventureWorks2008R2;
GO
IF OBJECT_ID(N'dbo.ufnGetContactInformation', N'TF') IS NOT NULL
    DROP FUNCTION dbo.ufnGetContactInformation;
GO
CREATE FUNCTION dbo.ufnGetContactInformation(@ContactID int)
RETURNS @retContactInformation TABLE 
(
    -- Columns returned by the function
    ContactID int PRIMARY KEY NOT NULL, 
    FirstName nvarchar(50) NULL, 
    LastName nvarchar(50) NULL, 
    JobTitle nvarchar(50) NULL, 
    ContactType nvarchar(50) NULL
)
AS 
-- Returns the first name, last name, job title, and contact type for the specified contact.
BEGIN
    DECLARE 
        @FirstName nvarchar(50), 
        @LastName nvarchar(50), 
        @JobTitle nvarchar(50), 
        @ContactType nvarchar(50);
    -- Get common contact information
    SELECT 
        @ContactID = BusinessEntityID, 
        @FirstName = FirstName, 
        @LastName = LastName
    FROM Person.Person 
    WHERE BusinessEntityID = @ContactID;
    -- Get contact job title
    SELECT @JobTitle = 
        CASE 
            -- Check for employee
            WHEN EXISTS(SELECT * FROM Person.Person AS p 
                        WHERE p.BusinessEntityID = @ContactID AND p.PersonType = 'EM') 
                THEN (SELECT JobTitle 
                      FROM HumanResources.Employee AS e
                      WHERE e.BusinessEntityID = @ContactID)
            -- Check for vendor
            WHEN EXISTS(SELECT * FROM Person.Person AS p 
                        WHERE p.BusinessEntityID = @ContactID AND p.PersonType = 'VC') 
                THEN (SELECT ct.Name 
                      FROM Person.ContactType AS ct 
                      INNER JOIN Person.BusinessEntityContact AS bec 
                          ON bec.ContactTypeID = ct.ContactTypeID  
                      WHERE bec.PersonID = @ContactID)

            -- Check for store
            WHEN EXISTS(SELECT * FROM Person.Person AS p 
                        WHERE p.BusinessEntityID = @ContactID AND p.PersonType = 'SC') 
                THEN (SELECT ct.Name 
                      FROM Person.ContactType AS ct 
                      INNER JOIN Person.BusinessEntityContact AS bec 
                          ON bec.ContactTypeID = ct.ContactTypeID  
                      WHERE bec.PersonID = @ContactID)
            ELSE NULL 
        END;
    -- Get contact type
    SET @ContactType = 
        CASE 
            -- Check for employee
            WHEN EXISTS(SELECT * FROM Person.Person AS p 
                        WHERE p.BusinessEntityID = @ContactID AND p.PersonType = 'EM') 
            THEN 'Employee'
            -- Check for vendor
            WHEN EXISTS(SELECT * FROM Person.Person AS p 
                        WHERE p.BusinessEntityID = @ContactID AND p.PersonType = 'VC')
            THEN 'Vendor Contact'
            -- Check for store
            WHEN EXISTS(SELECT * FROM Person.Person AS p 
                        WHERE p.BusinessEntityID = @ContactID AND p.PersonType = 'SC')
            THEN 'Store Contact'
            -- Check for individual consumer
            WHEN EXISTS(SELECT * FROM Person.Person AS p 
                        WHERE p.BusinessEntityID = @ContactID AND p.PersonType = 'IN') 
            THEN 'Consumer'
             -- Check for general contact
            WHEN EXISTS(SELECT * FROM Person.Person AS p 
                        WHERE p.BusinessEntityID = @ContactID AND p.PersonType = 'GC') 
            THEN 'General Contact'
        END;
    -- Return the information to the caller
    IF @ContactID IS NOT NULL 
    BEGIN
        INSERT @retContactInformation
        SELECT @ContactID, @FirstName, @LastName, @JobTitle, @ContactType;
    END;
    RETURN;
END;
GO

--The following example uses the table-valued function dbo.ufnGetContactInformation in the FROM clause of two SELECT statements.

USE AdventureWorks2008R2;
GO
SELECT ContactID, FirstName, LastName, JobTitle, ContactType
FROM dbo.ufnGetContactInformation(1209);
GO
SELECT ContactID, FirstName, LastName, JobTitle, ContactType
FROM dbo.ufnGetContactInformation(5);
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TVF_Table_Value_Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Multi-Statement Table-Valued Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TVF_Table_Value_Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Multi-Statement Table-Valued Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
/*
A multi-statement table-valued function returns a set of records given some initial input parameters. 
The difference is that the function can perform a whole range of processing within it, 
and in this respect is like a cross between a table variable and a stored procedure.

Here's an example of an MSTVF to solve our problem:	*/

CREATE FUNCTION fnPeople(

 -- pass in the gender: M or F
 @gender varchar(10)
)

-- spit out a table containing the people
RETURNS @people TABLE (
 PersonId int IDENTITY(1,1) PRIMARY KEY,
 PersonName varchar(20),
 Job varchar(10),
 Dob datetime
)

AS

BEGIN

 -- add in the female directors 
 INSERT INTO
  @people
 SELECT
  DirectorName AS PersonName,
  'Director' AS Job,
  DirectorDob AS Dob
 FROM
  tblDirector
 WHERE
  DirectorGender = @gender
   
 -- now add in the female actors
 INSERT INTO
  @people
 SELECT
  ActorName AS PersonName,
  'Actor' AS Job,
  ActorDob AS Dob
 FROM
  tblActor
 WHERE
  ActorGender = @gender
  
 RETURN
 
END

GO

SELECT * FROM dbo.fnPeople('Female')</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>TVF_Table_Value_Functions</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>TVP_as_input_to_StoredProcedure_using_a_TableType</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>TVF_Table_Value_Functions</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>TVP_as_input_to_StoredProcedure_using_a_TableType</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>USE AdventureWorks2008R2;
GO

/* Create a table type. */
CREATE TYPE LocationTableType AS TABLE 
( LocationName VARCHAR(50)
, CostRate INT );
GO

/* Create a procedure to receive data for the table-valued parameter. */
CREATE PROCEDURE usp_InsertProductionLocation
    @TVP LocationTableType READONLY
    AS 
    SET NOCOUNT ON
    INSERT INTO [AdventureWorks2008R2].[Production].[Location]
           ([Name]
           ,[CostRate]
           ,[Availability]
           ,[ModifiedDate])
        SELECT *, 0, GETDATE()
        FROM  @TVP;
        GO

/* Declare a variable that references the type. */
DECLARE @LocationTVP 
AS LocationTableType;

/* Add data to the table variable. */
INSERT INTO @LocationTVP (LocationName, CostRate)
    SELECT [Name], 0.00
    FROM 
    [AdventureWorks2008R2].[Person].[StateProvince];

/* Pass the table variable data to a stored procedure. */
EXEC usp_InsertProductionLocation @LocationTVP;
GO</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Update</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Update_from_Join</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Update</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Update_from_Join</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>UPDATE  a
SET     a.marks = b.marks
FROM    tempDataView a
        INNER JOIN tempData b
            ON a.Name = b.Name
            
            
            
-------

              
              

CREATE TABLE tempDATA
	([Name] varchar(8), [Marks] int)
;
	
INSERT INTO tempDATA
	([Name], [Marks])
VALUES
	('Narendra', 80),
	('Ravi', 85),
	('Sanjay', 90)
;

CREATE TABLE tempDATAView
	([Name] varchar(8), [Marks] int)
;
	
INSERT INTO tempDATAView
	([Name], [Marks])
VALUES
	('Narendra', NULL),
	('Narendra', NULL),
	('Narendra', NULL),
	('Narendra', NULL),
	('Ravi', NULL),
	('Ravi', NULL),
	('Sanjay', NULL)
;


UPDATE  a
SET     a.marks = b.marks
FROM    tempDataView a
        INNER JOIN tempData b
            ON a.Name = b.Name            </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>Update</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Update_with_Subquery</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>Update</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Update_with_Subquery</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--using SUBQUERY            
UPDATE  tempDataView 
SET     marks = 
        (
          SELECT marks 
          FROM tempData b 
          WHERE tempDataView.Name = b.Name
        )   
        
        
        
--------------------------------------------------  
CREATE TABLE tempDATA
	([Name] varchar(8), [Marks] int)
;
	
INSERT INTO tempDATA
	([Name], [Marks])
VALUES
	('Narendra', 80),
	('Ravi', 85),
	('Sanjay', 90)
;

CREATE TABLE tempDATAView
	([Name] varchar(8), [Marks] int)
;
	
INSERT INTO tempDATAView
	([Name], [Marks])
VALUES
	('Narendra', NULL),
	('Narendra', NULL),
	('Narendra', NULL),
	('Narendra', NULL),
	('Ravi', NULL),
	('Ravi', NULL),
	('Sanjay', NULL)
;


UPDATE  tempDataView 
SET     marks = 
        (
          SELECT marks 
          FROM tempData b 
          WHERE tempDataView.Name = b.Name
        )      </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>UTILITIES</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SP_IndexAnalysisForAll_Indexes_OnAllTables</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>UTILITIES</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SP_IndexAnalysisForAll_Indexes_OnAllTables</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--FROM: http://www.mssqltips.com/sqlservertip/1003/sql-server-index-analysis-script-for-all-indexes-on-all-tables/

--    Download this stored procedure and put it in your master database so you can use it across all databases
--    Refer to this stored procedure whenever you need to do index analysis across your database


Use DB2_CRM
go

-- Modified sp_helpindex SP to show all indexes for all tables
-- this was modified to handle object owned by dbo and other users

CREATE proc prj_0000_210_UTILITY_IndexAnalysis_AllIndexs_AllTables
	--@objname nvarchar(776)		-- the table to check for indexes
as
	-- PRELIM
	set nocount on

	declare @objname nvarchar(776), 
			@objid int,			-- the object id of the table
			@indid smallint,	-- the index id of an index
			@groupid smallint,  -- the filegroup id of an index
			@indname sysname,
			@groupname sysname,
			@status int,
			@keys nvarchar(2126),	--Length (16*max_identifierLength)+(15*2)+(16*3)
			@dbname	sysname,
			@usrname sysname

	-- Check to see that the object names are local to the current database.
	select @dbname = parsename(@objname,3)

	if @dbname is not null and @dbname &lt;&gt; db_name()
	begin
			raiserror(15250,-1,-1)
			return (1)
	end


	-- create temp table
	create table #spindtab
	(
		
		usr_name			sysname,
		table_name			sysname,		
		index_name			sysname	collate database_default,
		stats				int,
		groupname			sysname collate database_default,
		index_keys			nvarchar(2126)	collate database_default  -- see @keys above for length descr
	)


	-- OPEN CURSOR OVER TABLES (skip stats: bug shiloh_51196)
	declare ms_crs_tab cursor local static for
	select sysobjects.id, sysobjects.name, sysusers.name from sysobjects inner join sysusers on sysobjects.uid = sysusers.uid where type = 'U'

	open ms_crs_tab
	fetch ms_crs_tab into @objid, @objname, @usrname

	while @@fetch_status &gt;= 0
	begin


	-- Check to see the the table exists and initialize @objid.
	/*
	select @objid = object_id(@objname)
	if @objid is NULL
	begin
		select @dbname=db_name()
		raiserror(15009,-1,-1,@objname,@dbname)
		return (1)
	end
	*/
	-- OPEN CURSOR OVER INDEXES (skip stats: bug shiloh_51196)
	declare ms_crs_ind cursor local static for
		select indid, groupid, name, status from sysindexes
			where id = @objid and indid &gt; 0 and indid &lt; 255 and (status &amp; 64)=0 order by indid
	open ms_crs_ind
	fetch ms_crs_ind into @indid, @groupid, @indname, @status

	-- IF NO INDEX, QUIT
	--if @@fetch_status &lt; 0
	--begin
		--deallocate ms_crs_ind
		--raiserror(15472,-1,-1) --'Object does not have any indexes.'
		--return (0)
	--end

	-- Now check out each index, figure out its type and keys and
	--	save the info in a temporary table that we'll print out at the end.
	while @@fetch_status &gt;= 0
	begin
		-- First we'll figure out what the keys are.
		declare @i int, @thiskey nvarchar(131) -- 128+3

		select @keys = index_col(@usrname + '.' + @objname, @indid, 1), @i = 2
		if (indexkey_property(@objid, @indid, 1, 'isdescending') = 1)
			select @keys = @keys  + '(-)'

		select @thiskey = index_col(@usrname + '.' + @objname, @indid, @i)
		if ((@thiskey is not null) and (indexkey_property(@objid, @indid, @i, 'isdescending') = 1))
			select @thiskey = @thiskey + '(-)'

		while (@thiskey is not null )
		begin
			select @keys = @keys + ', ' + @thiskey, @i = @i + 1
			select @thiskey = index_col(@usrname + '.' + @objname, @indid, @i)
			if ((@thiskey is not null) and (indexkey_property(@objid, @indid, @i, 'isdescending') = 1))
				select @thiskey = @thiskey + '(-)'
		end

		select @groupname = groupname from sysfilegroups where groupid = @groupid

		-- INSERT ROW FOR INDEX
		insert into #spindtab values (@usrname, @objname, @indname, @status, @groupname, @keys)

		-- Next index
		fetch ms_crs_ind into @indid, @groupid, @indname, @status
	end
	deallocate ms_crs_ind

	fetch ms_crs_tab into @objid, @objname, @usrname
	end
	deallocate ms_crs_tab

	-- SET UP SOME CONSTANT VALUES FOR OUTPUT QUERY
	declare @empty varchar(1) select @empty = ''
	declare @des1			varchar(35),	-- 35 matches spt_values
			@des2			varchar(35),
			@des4			varchar(35),
			@des32			varchar(35),
			@des64			varchar(35),
			@des2048		varchar(35),
			@des4096		varchar(35),
			@des8388608		varchar(35),
			@des16777216	varchar(35)
	select @des1 = name from master.dbo.spt_values where type = 'I' and number = 1
	select @des2 = name from master.dbo.spt_values where type = 'I' and number = 2
	select @des4 = name from master.dbo.spt_values where type = 'I' and number = 4
	select @des32 = name from master.dbo.spt_values where type = 'I' and number = 32
	select @des64 = name from master.dbo.spt_values where type = 'I' and number = 64
	select @des2048 = name from master.dbo.spt_values where type = 'I' and number = 2048
	select @des4096 = name from master.dbo.spt_values where type = 'I' and number = 4096
	select @des8388608 = name from master.dbo.spt_values where type = 'I' and number = 8388608
	select @des16777216 = name from master.dbo.spt_values where type = 'I' and number = 16777216

	-- DISPLAY THE RESULTS
	select
		'usr_name'=usr_name,
		'table_name'=table_name,		
		'index_name' = index_name,
		'index_description' = convert(varchar(210), --bits 16 off, 1, 2, 16777216 on, located on group
				case when (stats &amp; 16)&lt;&gt;0 then 'clustered' else 'nonclustered' end
				+ case when (stats &amp; 1)&lt;&gt;0 then ', '+@des1 else @empty end
				+ case when (stats &amp; 2)&lt;&gt;0 then ', '+@des2 else @empty end
				+ case when (stats &amp; 4)&lt;&gt;0 then ', '+@des4 else @empty end
				+ case when (stats &amp; 64)&lt;&gt;0 then ', '+@des64 else case when (stats &amp; 32)&lt;&gt;0 then ', '+@des32 else @empty end end
				+ case when (stats &amp; 2048)&lt;&gt;0 then ', '+@des2048 else @empty end
				+ case when (stats &amp; 4096)&lt;&gt;0 then ', '+@des4096 else @empty end
				+ case when (stats &amp; 8388608)&lt;&gt;0 then ', '+@des8388608 else @empty end
				+ case when (stats &amp; 16777216)&lt;&gt;0 then ', '+@des16777216 else @empty end
				+ ' located on ' + groupname),
		'index_keys' = index_keys
	from #spindtab
	order by table_name, index_name


	return (0) -- sp_helpindex

GO
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>UTILITIES</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Users_and_Connections</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>UTILITIES</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Users_and_Connections</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>SELECT 
    DB_NAME(dbid) as DBName, 
    COUNT(dbid) as NumberOfConnections,
    loginame as LoginName
FROM
    sys.sysprocesses
WHERE 
    dbid &gt; 0
GROUP BY 
    dbid, loginame
;


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

exec sp_who

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

exec sp_who2

//////////////////////////////

Declare @dbName varchar(150)
set @dbName = 'barriere'

--Total machine connections
--SELECT  COUNT(dbid) as TotalConnections FROM sys.sysprocesses WHERE dbid &gt; 0

--Available connections
DECLARE @SPWHO1 TABLE (DBName VARCHAR(1000) NULL, NoOfAvailableConnections VARCHAR(1000) NULL, LoginName VARCHAR(1000) NULL)
INSERT INTO @SPWHO1 
    SELECT db_name(dbid), count(dbid), loginame FROM sys.sysprocesses WHERE dbid &gt; 0 GROUP BY dbid, loginame
SELECT * FROM @SPWHO1 WHERE DBName = @dbName

--Running connections
DECLARE @SPWHO2 TABLE (SPID VARCHAR(1000), [Status] VARCHAR(1000) NULL, [Login] VARCHAR(1000) NULL, HostName VARCHAR(1000) NULL, BlkBy VARCHAR(1000) NULL, DBName VARCHAR(1000) NULL, Command VARCHAR(1000) NULL, CPUTime VARCHAR(1000) NULL, DiskIO VARCHAR(1000) NULL, LastBatch VARCHAR(1000) NULL, ProgramName VARCHAR(1000) NULL, SPID2 VARCHAR(1000) NULL, Request VARCHAR(1000) NULL)
INSERT INTO @SPWHO2 
    EXEC sp_who2 'Active'
SELECT * FROM @SPWHO2 WHERE DBName = @dbName


////////////////////////////////////////////

SELECT DB_NAME(dbid) AS DBName,
COUNT(dbid) AS NumberOfConnections,
loginame
FROM    sys.sysprocesses
GROUP BY dbid, loginame
ORDER BY DB_NAME(dbid)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>UTILITIES</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>WhichDriveHasTheFiles_ForEachDatabase_WhatTypeOf_Recovery</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>UTILITIES</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>WhichDriveHasTheFiles_ForEachDatabase_WhatTypeOf_Recovery</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0000_216_WhichDriveHasTheFiles_WhatTypeOf_Recovery.sql

-- From eBooksSQLServerTacklebox.pdf, Chapter 2

IF EXISTS ( SELECT  *
            FROM    tempdb.dbo.sysobjects
            WHERE   id = OBJECT_ID(N'[tempdb].[dbo].[HoldforEachDB]') ) 
    DROP TABLE [tempdb].[dbo].[HoldforEachDB] ; 
CREATE TABLE [tempdb].[dbo].[HoldforEachDB]
    (
      [Server] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                               NULL,
      [DatabaseName] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                                     NOT NULL,
      [Size] [int] NOT NULL,
      [File_Status] [int] NULL,
      [Name] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                             NOT NULL,
      [Filename] [nvarchar](260) COLLATE SQL_Latin1_General_CP1_CI_AS
                                 NOT NULL,
      [Status] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                               NULL,
      [Updateability] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                                      NULL,
      [User_Access] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                                    NULL,
      [Recovery] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS
                                 NULL
    )
ON  [PRIMARY]
INSERT  INTO [tempdb].[dbo].[HoldforEachDB]
        EXEC sp_MSforeachdb 'SELECT CONVERT(char(100), SERVERPROPERTY(''Servername'')) AS Server,
                 ''?'' as DatabaseName,[?]..sysfiles.size, [?]..sysfiles.status, [?]..sysfiles.name, [?]..sysfiles.filename,convert(sysname,DatabasePropertyEx(''?'',''Status'')) as Status,
convert(sysname,DatabasePropertyEx(''?'',''Updateability'')) as Updateability,
 convert(sysname,DatabasePropertyEx(''?'',''UserAccess'')) as User_Access,
convert(sysname,DatabasePropertyEx(''?'',''Recovery'')) as Recovery From [?]..sysfiles '

SELECT [Server]
      ,[DatabaseName]
      ,[Size]
      ,[File_Status]
      ,[Name]
      ,[Filename]
      ,[Status]
      ,[Updateability]
      ,[User_Access]
      ,[Recovery]
  FROM [tempdb].[dbo].[HoldforEachDB] 
  Order by Recovery, DatabaseName

</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VIEW</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>CreateView_ReadMe</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VIEW</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>CreateView_ReadMe</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
--Using Windows authentication does not mean that any user can see the whole database. 
--Users have only the permissions granted to their account or to a group of which their account is a member.

--You can use views to further restrict the data to which a user has access.
--For example ...

--In the SQL Server Northwind database, create the following table ...

CREATE TABLE [dbo].[EmployeeUser] (
[EmployeeID] [int] NOT NULL ,
[UserName] [nvarchar] (50) NOT NULL
) ON [PRIMARY]
GO

ALTER TABLE [dbo].[EmployeeUser] WITH NOCHECK ADD CONSTRAINT [PK_EmployeeUser] PRIMARY KEY CLUSTERED ( [EmployeeID], [UserName]
) ON [PRIMARY]
GO

--Now enter a few rows of data ...

ALTER PROCEDURE dbo.EmployeeUser_Insert
AS
INSERT INTO dbo.EmployeeUser (EmployeeID, UserName) VALUES (1, N'SomeDomain\SomeUser') 
INSERT INTO dbo.EmployeeUser(EmployeeID, UserName) VALUES (2, N'SomeDomain\SomeUser') 
INSERT INTO dbo.EmployeeUser(EmployeeID, UserName) VALUES (3, N'SomeDomain\SomeUser')

--Now create the following view ...

SELECT dbo.Employees.*
FROM 
		dbo.Employees 
		INNER JOIN
		dbo.EmployeeUser 
		ON dbo.Employees.EmployeeID = dbo.EmployeeUser.EmployeeID 
WHERE (dbo.EmployeeUser.UserName = SYSTEM_USER)

--Grant your users permission on this view, 
--not on the underlying tables, and they can view only the Employees records that you have authorised them to view,
-- by adding that EmployeeID and the user's UserName to the EmployeeUser table.


</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VIEW</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SCRIPT_all_Views_FROM_Dewey</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VIEW</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SCRIPT_all_Views_FROM_Dewey</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--FROM DEWEY: worked on new server, but not the old server


USE barriere;

SET NOCOUNT ON;

DECLARE @StoredProcedure TABLE
    (
      procedure_name VARCHAR(8000) ,
      procedure_definition NVARCHAR(MAX) 
    );

INSERT  INTO @StoredProcedure
        ( procedure_name ,
          procedure_definition 
        )
        SELECT  so.name AS SPECIFIC_NAME,
					   a.definition AS ROUTINE_DEFINITION
        FROM    sys.objects AS so
                INNER JOIN sys.all_sql_modules a ON a.object_id = so.object_id
        WHERE   so.type = 'V';

		--		SELECT SPECIFIC_NAME, ROUTINE_DEFINITION
		--FROM barriere.INFORMATION_SCHEMA.ROUTINES
		--WHERE ROUTINE_TYPE = 'VIEW' AND LEFT(ROUTINE_NAME,3) NOT IN ('dt_','sp_','xp_','ms_')  AND YEAR(LAST_ALTERED) IN (2015,2016)
		--ORDER  BY 1;

DECLARE @procName AS VARCHAR(8000);
DECLARE @procDefinition AS NVARCHAR(MAX);

DECLARE T1 CURSOR
FOR
    SELECT  *
    FROM    @StoredProcedure;
OPEN T1;

FETCH NEXT FROM T1 INTO @procName, @procDefinition
WHILE @@FETCH_STATUS = 0
    BEGIN
        PRINT 'IF OBJECT_ID(' + '''' + @procName + '''' + ') IS NOT NULL DROP PROCEDURE ' + @procName;
        PRINT 'GO';
        PRINT '';
        PRINT @procDefinition;
        PRINT 'GO';
        PRINT '';
        PRINT '';
        FETCH NEXT FROM T1 INTO @procName, @procDefinition
    END;

CLOSE T1;
DEALLOCATE T1;
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>VIEW</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>SCRIPT_all_Views</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>VIEW</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>SCRIPT_all_Views</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_0006_RES_913_LIST_of_Views_v0.sql
/* NOT WORKING YET
	************************************************************************************
	NOTE: This will output a file for each View on the database, and an SQLCMD file to run them 
			into a designated directory ON the Database Server
		  This script requires that the function 'prj_0000_SP_201_WriteLineToFile' exists in the database
		  See the documentation for that function for requirements on the server. i.e. enabling 'Ole Automation Procedures' 
		  NOTE: spaces in file names cause PROBLEMS
	Uses: 
	Created: 11/18/2016
	By: glenn garson
	************************************************************************************
*/
use barriere
go

DECLARE @tmp table (Id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, View_Name nvarchar(Max))	--, Table_Name nvarchar(max))
DECLARE @View_Name nvarchar(max) 
--DECLARE @Table_Name nvarchar(max)
DECLARE @Id INT = 0

----from SQLCMD
DECLARE @destinationpath NVARCHAR(1000)
SET @destinationpath = N'C:\JUNK' 
DECLARE @SQLCMD_Path_FileName NVARCHAR(1000) 	 
DECLARE @SQLCMD_First_Line NVARCHAR(1000) 	

SET @SQLCMD_Path_FileName =  @destinationpath + '\_SQLCMD.sql'
SET @SQLCMD_First_Line =  '--_SQLCMD.sql'
--xxx] Create a File to store the lines of code for the View
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=@SQLCMD_First_Line   , @FileAction = 'CREATENEW'	
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=' '   , @FileAction = 'APPEND'	   
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=':setvar path "c:\xxx\"'   , @FileAction = 'APPEND'	 
exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=' '   , @FileAction = 'APPEND'


;WITH CTE_Views(View_Name)	--, Table_Name)
AS
(
	SELECT --TOP(3)			--&lt;============================================
		 sysobjects.name AS View_Name		--,
		 --Object_name(parent_obj) as "Table_Name" 
	FROM sysobjects 
	WHERE (
			(sysobjects.type = 'V')
									-- P = Stored Procedure
									-- V = View
									-- TF = Table Function
									-- TR = Trigger					
			--AND
			--(upper(sysobjects.name) like '%vw_%')   --&lt;== This should pull out all of mine
		   )

)

--0] Add a Primary Key to each record

INSERT INTO @tmp 
SELECT View_Name	--, Table_Name 
FROM CTE_Views
ORDER BY View_Name	--Table_Name, 


Select * from @tmp

-- Iterate over all the Views in the database
WHILE (1=1)
BEGIN

	--1] Get the next View name from the Table of View Names
    SELECT @View_Name = View_Name, @Id = Id		--, @Table_Name = Table_Name
    FROM @tmp
    WHERE Id = @Id + 1

	----1b] Create the SQLCMD file


	

    IF @@rowcount = 0 BREAK;


        -- 2] Create a table consisting of the lines of code for that View
    	BEGIN
			DECLARE @TTV_LinesOfCodeForView TABLE  (CodeID INT IDENTITY(1,1) PRIMARY KEY NOT NULL, LineOfCode nvarchar(Max)) 
			INSERT INTO @TTV_LinesOfCodeForView exec sp_helptext @View_Name
			
			
			--SELECT * from @TTV_LinesOfCodeForView



			DECLARE @View_filename NVARCHAR(1000) 
			DECLARE @FirstLineOfFile NVARCHAR(1000)  
			DECLARE @DropViewLine_1 NVARCHAR(1000)  
			DECLARE @DropViewLine_2 NVARCHAR(1000) 			
			
			
			
 			--SET @View_filename = @destinationpath + '\prj_0006_TRIG_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' + @Table_Name  + '_' +  @View_Name + N'.sql' 
			SET @View_filename = @destinationpath + '\prj_0006_V_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' +  @View_Name + N'.sql' 
			--SET @FirstLineOfFile = '--' + '\prj_0006_TRIG_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' + @Table_Name  + '_' +  @View_Name + N'.sql'
			SET @FirstLineOfFile = '--' + '\prj_0006_V_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) +  '_' +  @View_Name + N'.sql'			
			SET @DropViewLine_1 = 'IF OBJECT_ID(' + char(39) + @View_Name + char(39) + ') IS NOT NULL DROP PROC ' + @View_Name 
			SET @DropViewLine_2 = 'GO'
			
			DECLARE @CodeID INT = 0
			DECLARE @LineOfCode nvarchar(max) = ''
			DECLARE @LineForSQLCMDFile nvarchar(max) = ''
				
			
			--3b] APPEND a line to the SQLCMD file that calls the Create View file	
			--SET @LineForSQLCMDFile = ':r $(path)\' + 'prj_0006_TRIG_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_' + @Table_Name  + '_' +  @View_Name + N'.sql'	
			SET @LineForSQLCMDFile = ':r $(path)\' + 'prj_0006_V_' + RIGHT('000' + CAST(@Id AS NVARCHAR), 3) + '_'  +  @View_Name + N'.sql'			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@SQLCMD_Path_FileName  , @TextData=@LineForSQLCMDFile   , @FileAction = 'APPEND'
			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@View_filename  , @TextData=@FirstLineOfFile   , @FileAction = 'CREATENEW'		 			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@View_filename  , @TextData=' '   , @FileAction = 'APPEND'	
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@View_filename  , @TextData=@DropViewLine_1   , @FileAction = 'APPEND'			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@View_filename  , @TextData=@DropViewLine_2   , @FileAction = 'APPEND'			
			exec prj_0000_SP_201_WriteLineToFile  @FileName =@View_filename  , @TextData=' '   , @FileAction = 'APPEND'	
			
						
			-- 4] Iterate over all the lines of code in the output=============================================
			WHILE 2=2
			BEGIN
			 
				SELECT TOP(1) @CodeID = CodeID, @LineOfCode = LineOfCode
				FROM @TTV_LinesOfCodeForView
				WHERE CodeID &gt; @CodeID
				ORDER BY CodeID

				-- Exit loop if no more code
				IF @@ROWCOUNT = 0 BREAK;
							
			

				PRINT 'Line of Code: ' + @LineOfCode
				--5] Save the Line of Code to the file
				exec prj_0000_SP_201_WriteLineToFile  @FileName =@View_filename  , @TextData=@LineOfCode   , @FileAction = 'APPEND'									
			END	-- end of writing codelines to file
			
			--6] Clear out the records, otherwise they accumulate from each View
			DELETE FROM @TTV_LinesOfCodeForView	
			
			
  		END	-- end of list of Views
  		
  		

    
END
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>WAREHOUSE</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>about_WAREHOUSE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>WAREHOUSE</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>about_WAREHOUSE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_WAREHOUSE
/*
--Corporate Information Factory (CIF)
--Kimbal Method - Star Schema (Ralph Kimball)

--Surrogate Key (SK) = a new key used as a PK
--Business Key (BK) - the PK in the Dimension table?

--Slowly Changing Dimension (SCD)

Dimensional Types are at the column level, not the row
Type 0 Dimension: fixed dimension, static data that never changes
Type 1 Dimension: When a value is updated, the old one is overwritten
Type 2 Dimension: When a value is updated, the old record is end dated, and a new record is inserted
Type 3 Dimension:- stupid idea
Type 4 Dimension: When value is updated, old record copied to history and current record is updated


Generally store Type 2 data range as INT (e.g. 20180315), but some people use date (e.g. 3/15/2018)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>WSUS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>spGetObsoleteUpdatesToCleanup.sql</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>WSUS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>spGetObsoleteUpdatesToCleanup.sql</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

--===========================================================================SQL
--spGetObsoleteUpdatesToCleanup.sql

	USE SUSDB
	GO
	exec spGetObsoleteUpdatesToCleanup
--===========================================================================
--https://github.com/DeploymentResearch/DRFiles/blob/master/Scripts/Get-WSUSObsoleteUpdatesNumber.sql

USE SUSDB

DECLARE @var1 INT, @curitem INT, @totaltodelete INT

CREATE TABLE #results (Col1 INT) 
INSERT INTO #results(Col1) EXEC spGetObsoleteUpdatesToCleanup

SELECT COUNT(*) FROM #results
DROP TABLE #results
===========================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>WSUS</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>spGetObsoleteUpdatesToCleanup_cleanUp_ALL_mayNotBeBestSolution</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>WSUS</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>spGetObsoleteUpdatesToCleanup_cleanUp_ALL_mayNotBeBestSolution</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>http://sccm-local-admin.blogspot.com/2016/11/wsus-cleanup-using-sql-script.html

--Again execute the below query to clean up the unapproved, superseded and obsolete updates.

DECLARE @var1 INT
                                DECLARE @msg nvarchar(100)
                                 CREATE TABLE #results (Col1 INT)
                                INSERT INTO #results(Col1) EXEC spGetObsoleteUpdatesToCleanup
                                 DECLARE WC Cursor
                                FOR
                                SELECT Col1 FROM #results
                                OPEN WC
                                FETCH NEXT FROM WC
                                INTO @var1
                                WHILE (@@FETCH_STATUS &gt; -1)
                                BEGIN SET @msg = 'Deleting ' + CONVERT(varchar(10), @var1)
                                RAISERROR(@msg,0,1) WITH NOWAIT EXEC spDeleteUpdate @localUpdateID=@var1
                                FETCH NEXT FROM WC INTO @var1 END
                                CLOSE WC
                                DEALLOCATE WC
DROP TABLE #results</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>All_Steps_exceptXSD_For_AssetManagement</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>All_Steps_exceptXSD_For_AssetManagement</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_1023_106_ImportAllDataFromDataDump.sql
--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

-- IMPORTANT:

--1] Set the data dump file name!! (Around line 51)
--2] CHANGE THE DATE DUMPED VARIABLE!!!! BEFORE RUNNING (Around line 101)

--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Use DB6_AssetManagement
go

-- Drop Table first, b/c the otherwise you can't drop the schema--------------------

IF OBJECT_ID('dbo.[XmlImport_JUNK_001]') IS NOT NULL
    DROP TABLE dbo.[XmlImport_JUNK_001]
GO
IF EXISTS ( SELECT * FROM sys.xml_schema_collections where [name] = 'XmlSchema_001')
DROP XML SCHEMA COLLECTION [XmlSchema_001]
GO

-------------------------------------------------------------------------------------
DECLARE @MySchema XML
SET @MySchema = 
(
    SELECT * FROM OPENROWSET
    (
        --BULK 'G:\DATA_No_Backup\From_CCWNC\2013_03_08_AssetManagement\asset_tracking_dump_03-05-13.xsd', SINGLE_CLOB 
        BULK '\\SQL-SERVER\QI_Data_Storage\XSD_001.xsd', SINGLE_CLOB 
    ) AS xmlData
)

CREATE XML SCHEMA COLLECTION [XmlSchema_001] AS @MySchema 
GO
    
--Code to create the table with a typed XML column:



CREATE TABLE [dbo].[XmlImport_JUNK_001] (
        xmlFileName VARCHAR(300),
        xml_data xml
        )

go

--=========================================================================================

    DECLARE @xmlFileName VARCHAR(300)
    SELECT  @xmlFileName = '\\SQL-SERVER\QI_Data_Storage\AssetManagement_2013_05_13.xml'
    --'G:\DATA_No_Backup\From_CCWNC\2013_03_08_AssetManagement\asset_tracking_dump_03-05-13.xml'
    -- dynamic sql is just so we can use @xmlFileName variable in OPENROWSET
    EXEC('
    INSERT INTO XmlImport_JUNK_001(xmlFileName, xml_data)

    SELECT ''' + @xmlFileName + ''', xmlData 
    FROM
    (
        SELECT  * 
        FROM    OPENROWSET (BULK ''' + @xmlFileName + ''' , SINGLE_BLOB) AS XMLDATA
    ) AS FileImport (XMLDATA)
    ')
    GO
    --SELECT top 10 * FROM XmlImport_JUNK_1
    
--=========================================================================================    

--||||||||||||||||||||||||||||||||||||||||||||||||||||||
IF OBJECT_ID('dbo.T0_Machine') IS NOT NULL
    DROP TABLE dbo.T0_Machine


CREATE TABLE T0_Machine(

		  [T00_PK] [int] IDENTITY(1,1) NOT NULL,
		  DeviceSerial_ComputerName NVARCHAR(100),
		  chassis NVARCHAR(25),
		  IP NVARCHAR(15),
		  DeviceSerial NVARCHAR(15),
		  mac1  NVARCHAR(17),
		  mac2  NVARCHAR(17),
		  mac3  NVARCHAR(17),
		 [USER] NVARCHAR(50), 
		  ComputerName NVARCHAR(50), 
		 manufacturer NVARCHAR(50),
		 model NVARCHAR(50), 
		 os NVARCHAR(100),
		 OS_Serial_Number NVARCHAR(50),
		 OS_Product_Key NVARCHAR(50),
		 OS_ServicePack smallINT,
		 ram  NVARCHAR(20),
		 scantime NVARCHAR(50),
		 Date_Uploaded Date,
		 Date_Dumped Date
  );		 
		  
go

DECLARE @Date_Dumped date
SELECT @Date_Dumped ='05-13-2013'

INSERT INTO T0_Machine 
	(
[DeviceSerial_ComputerName]	
,[chassis]
,ip
,DeviceSerial
,mac1
,mac2
,mac3
,[user]
,[ComputerName]
,[manufacturer]
,[model]
,[os]
,[OS_Serial_Number]
,[OS_Product_Key]
,OS_ServicePack
,[ram]
,[scantime]
,[Date_Uploaded]
,[Date_Dumped]
	)
--||||||||||||||||||||||||||||||||||||||||||||||||||||||	
SELECT	
(SELECT 'TheCalculation' =  coalesce(C.value('(deviceserial/text())[1]', 'nvarchar(15)'), '{missing}') + '_' + coalesce(RTRIM(C.value('(name/text())[1]', 'nvarchar(50)')), '{missing}') ) AS [DeviceSerial_ComputerName]
,C.value('(chassis/text())[1]', 'nvarchar(25)') chassis
,C.value('(ip/text())[1]', 'nvarchar(15)') ip
,C.value('(deviceserial/text())[1]', 'nvarchar(15)') DeviceSerial
,C.value('(mac1/text())[1]', 'nvarchar(17)') mac1
,C.value('(mac2/text())[1]', 'nvarchar(17)') mac2
,C.value('(mac3/text())[1]', 'nvarchar(17)') mac3
,C.value('(user/text())[1]', 'nvarchar(50)') [user]
,C.value('(name/text())[1]', 'nvarchar(50)') [ComputerName]
,C.value('(manufacturer/text())[1]', 'nvarchar(50)') [manufacturer]
,C.value('(model/text())[1]', 'nvarchar(50)') [model]
,C.value('(os/text())[1]', 'nvarchar(50)') [os]
,C.value('(osserialnumber/text())[1]', 'nvarchar(50)') [osserialnumber]
,C.value('(osproductkey/text())[1]', 'nvarchar(50)') [osproductkey]
,C.value('(servicepack/text())[1]', 'smallINT') [servicepack]
,C.value('(ram/text())[1]', 'nvarchar(50)') [ram]
,C.value('(scantime/text())[1]', 'datetime') [scantime]
,GETDATE() AS Date_Uploaded
,@Date_Dumped as Date_Dumped



FROM
[XmlImport_JUNK_001]
CROSS APPLY 
XmlImport_JUNK_001.xml_data.nodes('assets/client/machine') T(C)


--=========================================================================================

--||||||||||||||||||||||||||||||||||||||||||||||||||||||
IF OBJECT_ID('dbo.T01_Hardware') IS NOT NULL
    DROP TABLE dbo.T01_Hardware
go

CREATE TABLE T01_Hardware(

		  [T01_PK] [int] IDENTITY(1,1) NOT NULL,
		  DeviceSerial NVARCHAR(50),
		  ComputerName NVARCHAR(50),
		  DeviceSerial_ComputerName NVARCHAR(100),
		  DeviceType  NVARCHAR(50),
		  DeviceName  NVARCHAR(100),
		  DeviceManufacturer  NVARCHAR(100)
  );		 
go		  

INSERT INTO T01_Hardware 
	(
DeviceSerial
,ComputerName
,DeviceSerial_ComputerName
,DeviceType
,DeviceName
,DeviceManufacturer

	)
--||||||||||||||||||||||||||||||||||||||||||||||||||||||

	
SELECT	

	C.value('(deviceserial/text())[1]', 'nvarchar(15)') DeviceSerial
	,C.value('(name/text())[1]', 'nvarchar(50)') [ComputerName]
	, (SELECT 'TheCalculation' =  coalesce(C.value('(deviceserial/text())[1]', 'nvarchar(15)'), '{missing}') + '_' + coalesce(RTRIM(C.value('(name/text())[1]', 'nvarchar(50)')), '{missing}') ) AS [DeviceSerial_ComputerName]
	,B.value('(type/text())[1]', 'nvarchar(255)') [DeviceType]
	,B.value('(name/text())[1]', 'nvarchar(255)') [DeviceName]
	,B.value('(manufacturer/text())[1]', 'nvarchar(255)') [DeviceManufacturer]

FROM
[XmlImport_JUNK_001]
CROSS APPLY 
XmlImport_JUNK_001.xml_data.nodes('assets/client/machine') T(C)
OUTER APPLY
C.nodes('hardware/item') as S(B)


--=========================================================================================


--||||||||||||||||||||||||||||||||||||||||||||||||||||||
IF OBJECT_ID('dbo.T02_Software') IS NOT NULL
    DROP TABLE dbo.T02_Software
go

CREATE TABLE T02_Software(

		  [T02_PK] [int] IDENTITY(1,1) NOT NULL,
		  DeviceSerial NVARCHAR(50),
		  ComputerName NVARCHAR(50),
		  DeviceSerial_ComputerName NVARCHAR(100),
		  SoftwareName  NVARCHAR(255),
		  SoftwareVersion  NVARCHAR(50),
		  SoftwareInstallDate  NVARCHAR(100)
  );		 
go		  

INSERT INTO T02_Software 
	(
DeviceSerial
,ComputerName
,DeviceSerial_ComputerName
,SoftwareName
,SoftwareVersion
,SoftwareInstallDate

	)
--||||||||||||||||||||||||||||||||||||||||||||||||||||||

	
SELECT	

	C.value('(deviceserial/text())[1]', 'nvarchar(15)') DeviceSerial
	,C.value('(name/text())[1]', 'nvarchar(50)') [ComputerName]
	, (SELECT 'TheCalculation' =  coalesce(C.value('(deviceserial/text())[1]', 'nvarchar(15)'), '{missing}') + '_' + coalesce(RTRIM(C.value('(name/text())[1]', 'nvarchar(50)')), '{missing}') ) AS [DeviceSerial_ComputerName]
	,B.value('(name/text())[1]', 'nvarchar(255)') [SoftwareName]
	,B.value('(version/text())[1]', 'nvarchar(255)') [SoftwareVersion]
	,B.value('(install_date/text())[1]', 'nvarchar(255)') [SoftwareInstallDate]

FROM
[XmlImport_JUNK_001]
CROSS APPLY 
XmlImport_JUNK_001.xml_data.nodes('assets/client/machine') T(C)
OUTER APPLY
C.nodes('software/item') as S(B)


--=========================================================================================</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Complex_OPENROWSET_BULK</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Complex_OPENROWSET_BULK</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- From: http://www.sqlservercentral.com/Forums/Topic1108062-392-1.aspx


--Sample XML file

&lt;CustomerDetails&gt;
  &lt;PersonalInfo&gt;
	&lt;CustID&gt;1001&lt;/CustID&gt;
	&lt;CustLastName&gt;Smith&lt;/CustLastName&gt;
	&lt;DOB&gt;2011-05-05T09:25:48.253&lt;/DOB&gt;
	&lt;Address&gt;
		&lt;Addr1&gt;100 Smith St.&lt;/Addr1&gt;
		&lt;City&gt;New York&lt;/City&gt;
	&lt;/Address&gt; 
 &lt;/PersonalInfo&gt;	
&lt;/CustomerDetails&gt;


--And the result table should look like

CREATE TABLE #Cust
	(CustID INT, CustLastName VARCHAR(10)
             , DOB DATETIME, Addr1 VARCHAR(100), City VARCHAR(10))
	
INSERT INTO #Cust
VALUES (1001, 'Smith', '2011-05-05', '100 Smith St.', 'New York')


--Replace the C:\test.txt with your filename in the following.

insert into #Cust
select
   c3.value('CustID[1]','int'),
   c3.value('CustLastName[1]','varchar(10)'),
   c3.value('DOB[1]','DATETIME'),
   c3.value('(Address/Addr1)[1]','VARCHAR(100)'),
   c3.value('(Address/City)[1]','VARCHAR(10)')
from
(
   select 
      cast(c1 as xml)
   from 
      OPENROWSET (BULK 'C:\test.txt',SINGLE_BLOB) as T1(c1)
)as T2(c2)
cross apply c2.nodes('/CustomerDetails/PersonalInfo') T3(c3)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Example_Read_AssetManagement_intoOneRowOneCol_ThenReadFromThere</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Example_Read_AssetManagement_intoOneRowOneCol_ThenReadFromThere</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--prj_1013_103_Read_From_OneRowOneColumn_XMLrecord.sql
-- less than a second

use DB6_AssetManagement
go

IF OBJECT_ID('dbo.T0_Machine_v2') IS NOT NULL
    DROP TABLE dbo.T0_Machine_v2
go

--==============
-- Can use  a SELECT while doing developement rather than 
-- The following: Create Table, and Insert Into
--==============
CREATE TABLE T0_Machine_v2(

		  [T00_PK] [int] IDENTITY(1,1) NOT NULL,
		  chassis NVARCHAR(25),
		  IP NVARCHAR(15),
		  Deviceserial NVARCHAR(15),
		  mac1  NVARCHAR(17),
		  mac2  NVARCHAR(17),
		  mac3  NVARCHAR(17),
		 [USER] NVARCHAR(50), 
		  name NVARCHAR(50), 
		 manufacturer NVARCHAR(50),
		 model NVARCHAR(50), 
		 os NVARCHAR(100),
		 osserialnumber NVARCHAR(50),
		 osproductkey NVARCHAR(50),
		 servicepack smallINT,
		 ram  NVARCHAR(20),
		 scantime NVARCHAR(50),
		 Date_Uploaded Date
  );		 
go		  

INSERT INTO T0_Machine_v2 
	(
[chassis]
,ip
,deviceserial
,mac1
,mac2
,mac3
,[user]
,[name]
,[manufacturer]
,[model]
,[os]
,[osserialnumber]
,[osproductkey]
,servicepack
,[ram]
,[scantime]
	)
--==============	
SELECT	
C.value('(chassis/text())[1]', 'nvarchar(25)') chassis
,C.value('(ip/text())[1]', 'nvarchar(15)') ip
,C.value('(deviceserial/text())[1]', 'nvarchar(15)') deviceserial
,C.value('(mac1/text())[1]', 'nvarchar(17)') mac1
,C.value('(mac2/text())[1]', 'nvarchar(17)') mac2
,C.value('(mac3/text())[1]', 'nvarchar(17)') mac3
,C.value('(user/text())[1]', 'nvarchar(50)') [user]
,C.value('(name/text())[1]', 'nvarchar(50)') [name]
,C.value('(manufacturer/text())[1]', 'nvarchar(50)') [manufacturer]
,C.value('(model/text())[1]', 'nvarchar(50)') [model]
,C.value('(os/text())[1]', 'nvarchar(50)') [os]
,C.value('(osserialnumber/text())[1]', 'nvarchar(50)') [osserialnumber]
,C.value('(osproductkey/text())[1]', 'nvarchar(50)') [osproductkey]
,C.value('(servicepack/text())[1]', 'smallINT') [servicepack]
,C.value('(ram/text())[1]', 'nvarchar(50)') [ram]
,C.value('(scantime/text())[1]', 'datetime') [scantime]



FROM
[XmlImport_JUNK_1]
CROSS APPLY 
XmlImport_JUNK_1.xml_data.nodes('assets/client/machine') T(C)


--XmlImport_JUNK_1.nodes('/root/Subnode/Subsubnode') e(x)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Example_Read_AssetManagement_XML_IntoTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Example_Read_AssetManagement_XML_IntoTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code> --prj_1023_CreateTable_T0_Machine_v2.sql
-- This took 11 minutes 6 seconds to run
-- it reads directly from the XML file

Use DB6_AssetManagement
go
IF OBJECT_ID('dbo.T0_Machine') IS NOT NULL
    DROP TABLE dbo.T0_Machine
go
CREATE TABLE T0_Machine(

		  [T00_PK] [int] IDENTITY(1,1) NOT NULL,
		  chassis NVARCHAR(25),
		  IP NVARCHAR(15),
		  Deviceserial NVARCHAR(15),
		  mac1  NVARCHAR(17),
		  mac2  NVARCHAR(17),
		  mac3  NVARCHAR(17),
		 [USER] NVARCHAR(50), 
		  name NVARCHAR(50), 
		 manufacturer NVARCHAR(50),
		 model NVARCHAR(50), 
		 os NVARCHAR(100),
		 osserialnumber NVARCHAR(50),
		 osproductkey NVARCHAR(50),
		 servicepack smallINT,
		 ram  NVARCHAR(20),
		 scantime NVARCHAR(50),
		 Date_Uploaded as Date
		  
  );


--Finally, the following statement will load the XML file, parse the XML elements to columns, and insert into the Products table:

INSERT INTO T0_Machine (
		  chassis,
		  IP,
		  Deviceserial,
		  mac1,
		  mac2,
		  mac3,
		 [USER], 
		  name, 
		 manufacturer,
		 model, 
		 os,
		 osserialnumber,
		 osproductkey,
		 servicepack,
		 ram ,
		 scantime,
		 Date_Uploaded
			)
SELECT 
		--X.machine.query('ip').value('.', 'NVARCHAR(15)'),
		--X.machine.query('user').value('.', 'NVARCHAR(50)')
		
		
		  X.machine.query('chassis').value('.', 'NVARCHAR(25)'),
		  X.machine.query('ip').value('.', 'NVARCHAR(15)'),
		  X.machine.query('deviceserial').value('.', 'NVARCHAR(15)'),
		  X.machine.query('mac1').value('.', 'NVARCHAR(17)'),		  
		  X.machine.query('mac2').value('.', 'NVARCHAR(17)'),	
		  X.machine.query('mac3').value('.', 'NVARCHAR(17)'),			  
		  X.machine.query('user').value('.', 'NVARCHAR(50)'),		  
		  X.machine.query('name').value('.', 'NVARCHAR(50)'),		  		  
		  X.machine.query('manufacturer').value('.', 'NVARCHAR(50)'),
		  X.machine.query('model').value('.', 'NVARCHAR(50)'),
		  X.machine.query('os').value('.', 'NVARCHAR(100)'),
		  X.machine.query('osserialnumber').value('.', 'NVARCHAR(50)'),
		  X.machine.query('osproductkey').value('.', 'NVARCHAR(50)'),
		  X.machine.query('servicepack').value('.', 'smallINT'),
		  X.machine.query('ram').value('.', 'NVARCHAR(20)'),
		  X.machine.query('scantime').value('.', 'NVARCHAR(50)'),
		  GETDATE() as [Date_Uploaded]
	
		
		
		
FROM (
SELECT CAST(x AS XML)
FROM OPENROWSET(
    BULK '\\SQL-SERVER\QI_Data_Storage\AssetManagement_2013_04_18.xml',   --&lt;== MOVE data to folder:  N:\DATA\QI_Data_Storage 
    SINGLE_BLOB) AS T(x)
    ) AS T(x)
CROSS APPLY x.nodes('assets/client/machine') AS X(machine);


--Here are the results:
select *
--SELECT IP, [USER], LEN(ltrim(rtrim([user]))) as LenUser
FROM T0_Machine
--Order by LenUser desc</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ImportFromFile_Simple</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ImportFromFile_Simple</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--FROM: http://pratchev.blogspot.com/2008/11/import-xml-file-to-sql-table.html
--First, the following XML is saved to XML file C:\Products.xml.

    &lt;Products&gt;
      &lt;Product&gt;
        &lt;SKU&gt;1&lt;/SKU&gt;
        &lt;Desc&gt;Book&lt;/Desc&gt;
      &lt;/Product&gt;
      &lt;Product&gt;
        &lt;SKU&gt;2&lt;/SKU&gt;
        &lt;Desc&gt;DVD&lt;/Desc&gt;
      &lt;/Product&gt;
      &lt;Product&gt;
        &lt;SKU&gt;3&lt;/SKU&gt;
        &lt;Desc&gt;Video&lt;/Desc&gt;
      &lt;/Product&gt;
    &lt;/Products&gt;


--Next, a table named Products is created to store the XML data.

    CREATE TABLE Products(
     sku INT PRIMARY KEY,
     product_desc VARCHAR(30));


--Finally, the following statement will load the XML file, parse the XML elements to columns, and insert into the Products table:

    INSERT INTO Products (sku, product_desc)
    SELECT X.product.query('SKU').value('.', 'INT'),
           X.product.query('Desc').value('.', 'VARCHAR(30)')
    FROM (
    SELECT CAST(x AS XML)
    FROM OPENROWSET(
        BULK 'C:\Products.xml',
        SINGLE_BLOB) AS T(x)
        ) AS T(x)
    CROSS APPLY x.nodes('Products/Product') AS X(product);


--Here are the results:

    SELECT sku, product_desc
    FROM Products;

     

    /*

     

    Results:

     

    sku         product_desc

    ----------- -------------

    1           Book

    2           DVD

    3           Video

     

    */</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Needed_Namespace_Declaration</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Needed_Namespace_Declaration</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--query is not working: SEE at bottom for version w/ Namespace

INSERT INTO neutc_import(macaddr,tcname)
SELECT X.a.query('MACAddress').value('.', 'varchar(50)'),
X.a.query('ComputerName').value('.', 'VARCHAR(50)')
FROM (
SELECT CAST(x AS XML)
FROM OPENROWSET(
BULK 'E:\scout_import\DSBU010995_Imdly_2_HwInfo.xml',
SINGLE_BLOB) AS T(x)
) AS T(x)
CROSS APPLY x.nodes('records/record') AS X(a);

--referenced xml:

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Systems Version="4.00" xsi:schemaLocation="urn:schemas-ts-fujitsu-com:software-preload HWInfo4.00.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:schemas-ts-fujitsu-com:software-preload"&gt;
&lt;System&gt;
&lt;SystemIdentification&gt;
&lt;SerialNumber&gt;DSBU010995&lt;/SerialNumber&gt;
&lt;IndividualSoftwareID /&gt;
&lt;SystemUUID&gt;{B2E832CC-7484-11E1-8B14-5026909B9A32}&lt;/SystemUUID&gt;
&lt;CustomerSerialNumber /&gt;
&lt;IMEINumber&gt;&lt;/IMEINumber&gt;
&lt;MACAddresses&gt;
&lt;MACAddress type="OnBoard"&gt;00:30:05:68:FF:BD&lt;/MACAddress&gt;
&lt;/MACAddresses&gt;
&lt;/SystemIdentification&gt;
&lt;OrderReferenceData&gt;
&lt;P82OrderNumber&gt;xxxxxxx&lt;/P82OrderNumber&gt;
&lt;P82CustomerOrderNumber&gt;xxxxxxx&lt;/P82CustomerOrderNumber&gt;
&lt;P84OrderNumber&gt;xxxxxxx&lt;/P84OrderNumber&gt;
&lt;P84OrderPosition&gt;100&lt;/P84OrderPosition&gt;
&lt;P84CustomerOrderNumber&gt;xxxxxxx&lt;/P84CustomerOrderNumber&gt;
&lt;EndCustomerOrderNumber&gt;xxxxxxx&lt;/EndCustomerOrderNumber&gt;
&lt;/OrderReferenceData&gt;
&lt;ProductDetails&gt;
&lt;OrderCode&gt;CUZ:KxxxVXXX-EMFxx&lt;/OrderCode&gt;
&lt;Product&gt;LB P771 BLACK /CUZ:KxxxVXXX-EMFxx&lt;/Product&gt;
&lt;/ProductDetails&gt;
&lt;SoftwareModules /&gt;
&lt;OrderAttachements&gt;
&lt;HeaderSpecificData /&gt;
&lt;PositionSpecificData&gt;
&lt;ClientParameters SubClient="None" Client="Caritas"&gt;
&lt;ComputerName&gt;CNxxxxx&lt;/ComputerName&gt;
&lt;OldComputerName&gt;ONxxxxx&lt;/OldComputerName&gt;
&lt;PrimaryContact&gt;Max Mustermann&lt;/PrimaryContact&gt;
&lt;/ClientParameters&gt;
&lt;/PositionSpecificData&gt;
&lt;/OrderAttachements&gt;
&lt;/System&gt;
&lt;System&gt;
&lt;SystemIdentification&gt;
&lt;SerialNumber&gt;DSBU010995&lt;/SerialNumber&gt;
&lt;IndividualSoftwareID /&gt;
&lt;SystemUUID&gt;{B2E832CC-7484-11E1-8B14-5026909B9A32}&lt;/SystemUUID&gt;
&lt;CustomerSerialNumber /&gt;
&lt;IMEINumber&gt;&lt;/IMEINumber&gt;
&lt;MACAddresses&gt;
&lt;MACAddress type="OnBoard"&gt;00:30:05:68:FF:BD&lt;/MACAddress&gt;
&lt;/MACAddresses&gt;
&lt;/SystemIdentification&gt;
&lt;OrderReferenceData&gt;
&lt;P82OrderNumber&gt;xxxxxxx&lt;/P82OrderNumber&gt;
&lt;P82CustomerOrderNumber&gt;xxxxxxx&lt;/P82CustomerOrderNumber&gt;
&lt;P84OrderNumber&gt;xxxxxxx&lt;/P84OrderNumber&gt;
&lt;P84OrderPosition&gt;200&lt;/P84OrderPosition&gt;
&lt;P84CustomerOrderNumber&gt;xxxxxxx&lt;/P84CustomerOrderNumber&gt;
&lt;EndCustomerOrderNumber&gt;xxxxxxx&lt;/EndCustomerOrderNumber&gt;
&lt;/OrderReferenceData&gt;
&lt;ProductDetails&gt;
&lt;OrderCode&gt;CUZ:KxxxVXXX-EMFxx&lt;/OrderCode&gt;
&lt;Product&gt;LB P771 BLACK /CUZ:KxxxVXXX-EMFxx&lt;/Product&gt;
&lt;/ProductDetails&gt;
&lt;SoftwareModules /&gt;
&lt;OrderAttachements&gt;
&lt;HeaderSpecificData /&gt;
&lt;PositionSpecificData&gt;
&lt;ClientParameters SubClient="None" Client="Caritas"&gt;
&lt;ComputerName&gt;CNxxxxx&lt;/ComputerName&gt;
&lt;OldComputerName&gt;ONxxxxx&lt;/OldComputerName&gt;
&lt;PrimaryContact&gt;Max Mustermann&lt;/PrimaryContact&gt;
&lt;/ClientParameters&gt;
&lt;/PositionSpecificData&gt;
&lt;/OrderAttachements&gt;
&lt;/System&gt;
&lt;/Systems&gt;p.




--I think the main thing that you was missing was the namespace declaration. 
--I have also made a couple of minor alterations, namely the cross apply and removing the .query() methods in the select statement. 
--I have come up with the following that gets the MAC address and the computer name from the example xml

WITH xmlnamespaces (DEFAULT 'urn:schemas-ts-fujitsu-com:software-preload')
SELECT X.a.value('(SystemIdentification/MACAddresses/MACAddress/text())[1]', 'VARCHAR(30)') AS 'MAC',
X.a.value('(OrderAttachements/PositionSpecificData/ClientParameters/ComputerName/text())[1]', 'VARCHAR(30)')
FROM (
SELECT CAST(x AS XML)
FROM OPENROWSET(
BULK 'd:\ExampleXml.xml',
SINGLE_BLOB) AS T(x)
) AS T(x)
CROSS APPLY x.nodes('Systems/System') AS X(a);

 </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>OPENROWSET_BULK_SINGLE_BLOB</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>OPENROWSET_BULK_SINGLE_BLOB</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>--More than  one example


///////////////////////////
--1. Save the xml file to a location on your drive eg.C:\xmlfiles\Students.xml
--2. Create Table Students
--3. Import the xml using Openrowset bulk option  and select the values in xml using xpath and xquery
--    and Do a Insert into using select
--4. Results
--STEP 1
--The contents of the saved file will be
&lt;Students&gt;
  &lt;Student&gt;
    &lt;Id&gt;1&lt;/Id&gt;
    &lt;Name&gt;Madhan&lt;/Name&gt;
  &lt;/Student&gt;
  &lt;Student&gt;
    &lt;Id&gt;2&lt;/Id&gt;
    &lt;Name&gt;Karthi&lt;/Name&gt;
  &lt;/Student&gt;
  &lt;Student&gt;
    &lt;Id&gt;3&lt;/Id&gt;
    &lt;Name&gt;Bata&lt;/Name&gt;
  &lt;/Student&gt;
&lt;/Students&gt;
--STEP 2
--The syntax to create a table
CREATE TABLE TblStudents
(
 Id INT PRIMARY KEY,
 Name VARCHAR(50)
);
--STEP 3
--Query to select the values from xml and to extract

INSERT INTO TblStudents (Id , Name )
SELECT students.student.query('Id').value('.', 'INT') as Id,
       students.student.query('Name').value('.', 'VARCHAR(30)') as Name
FROM (
SELECT CAST(b AS XML)
FROM OPENROWSET(
     BULK 'C:\xmlfiles\Students.xml',
     SINGLE_BLOB) AS a(b)
     ) AS a(b)
CROSS APPLY b.nodes('Students/Student') AS students(student);

--STEP 4

SELECT Id, Name FROM TblStudents;

/*
Results:
Id        Name
----------- -------------
1           Madhan
2           Karthi
3           Bata

*/


///////////Another example/////////////////////////////

-- Save this in a file:

&lt;books&gt;
	&lt;category type="ssrs"&gt;
		&lt;book lang="en"&gt;
			Microsoft SQL Server 2008 Reporting Services Step by Step
		&lt;/book&gt;
		&lt;book lang="en"&gt;
			Microsoft SQL Server 2008 Reporting Services
		&lt;/book&gt;
		&lt;book lang="en"&gt;
			Applied Microsoft SQL Server 2008 Reporting Services
		&lt;/book&gt;
		&lt;book lang="en"&gt;
			Microsoft SQL Server Reporting Services Recipes: for Designing Expert Reports
		&lt;/book&gt;
	&lt;/category&gt;
	&lt;category type="ssas"&gt;
		&lt;book lang="en"&gt;
			Microsoft SQL Server 2008 Analysis Services Step by Step
		&lt;/book&gt;
		&lt;book lang="en"&gt;
			Microsoft SQL Server 2008 MDX Step by Step
		&lt;/book&gt;
		&lt;book lang="en"&gt;
			Expert Cube Development with Microsoft SQL Server 2008 Analysis Services
		&lt;/book&gt;
	&lt;/category&gt;
	&lt;category&gt;
		&lt;book lang="en"&gt;
			Smart Business Intelligence Solutions with Microsoft SQL Server 2008
		&lt;/book&gt;
		&lt;book lang="en"&gt;
			Delivering Business Intelligence with Microsoft SQL Server 2008
		&lt;/book&gt;
	&lt;/category&gt;
&lt;/books&gt;





DECLARE @X XML

SELECT
  @X = books
FROM OPENROWSET (BULK 'c:\sql-server-2008-books.xml', SINGLE_BLOB) AS Import(books)

Select
  [Book Name].value('.','varchar(100)') AS Book
From @X.




</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Parse_OPENROWSET_GoodExample</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Parse_OPENROWSET_GoodExample</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- Sample xml file:

&lt;CustomerDetails&gt;
  &lt;PersonalInfo&gt;
	&lt;CustID&gt;1001&lt;/CustID&gt;
	&lt;CustLastName&gt;Smith&lt;/CustLastName&gt;
	&lt;DOB&gt;2011-05-05T09:25:48.253&lt;/DOB&gt;
	&lt;Address&gt;
		&lt;Addr1&gt;100 Smith St.&lt;/Addr1&gt;
		&lt;City&gt;New York&lt;/City&gt;
	&lt;/Address&gt; 
 &lt;/PersonalInfo&gt;	
&lt;/CustomerDetails&gt;



--Replace the C:\test.txt with your filename in the following. 

insert into #Cust
select
   c3.value('CustID[1]','int'),
   c3.value('CustLastName[1]','varchar(10)'),
   c3.value('DOB[1]','DATETIME'),
   c3.value('(Address/Addr1)[1]','VARCHAR(100)'),
   c3.value('(Address/City)[1]','VARCHAR(10)')
from
(
   select 
      cast(c1 as xml)
   from 
      OPENROWSET (BULK 'C:\test.txt',SINGLE_BLOB) as T1(c1)
)as T2(c2)
cross apply c2.nodes('/CustomerDetails/PersonalInfo') T3(c3)</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Read_XML_file_JoinWithExistingTable</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Read_XML_file_JoinWithExistingTable</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>CREATE PROCEDURE [dbo].[spXMLJOIN]
	@xmlData xml
AS
BEGIN


DECLARE @xmlTable Table
(
	EmployeeID int UNIQUE,
	FirstName nvarchar(MAX),
	LastName nvarchar(MAX)
)
--Pull the xml into a table variable (THIS NOT A TMP TABLE!)
INSERT INTO @xmlTable ( Rapp_Report_Xref_ID, Rapp_Question_ID,OK, Notes)
		SELECT
			q.itm.value('EmployeeID[1]','int') as EmployeeID,
			q.itm.value('FirstName[1]','int') as FirstName,
			q.itm.value('LastName[1]', 'nvarchar(MAX)') as LastName,
			FROM @xmlData.nodes('DocumentElement/Employee') as q([itm])


SELECT Employee.*, b.* FROM Employee
LEFT JOIN @xmlTable as b ON Employee.EmployeeID = b.EmployeeID
	
END</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>ReadsXML_BUT_DoesNotParseIt</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>ReadsXML_BUT_DoesNotParseIt</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code> --From: http://weblogs.sqlteam.com/mladenp/archive/2007/06/18/60235.aspx
 
 use AssetManagment
    go
    
    
    CREATE TABLE XmlImportTest
    (
        xmlFileName VARCHAR(300),
        xml_data xml
    )
    GO

    DECLARE @xmlFileName VARCHAR(300)
    SELECT  @xmlFileName = 'G:\DATA_No_Backup\From_CCWNC\2013_03_08_AssetManagement\asset_tracking_dump_03-05-13.xml'
    -- dynamic sql is just so we can use @xmlFileName variable in OPENROWSET
    EXEC('
    INSERT INTO XmlImportTest(xmlFileName, xml_data)

    SELECT ''' + @xmlFileName + ''', xmlData 
    FROM
    (
        SELECT  * 
        FROM    OPENROWSET (BULK ''' + @xmlFileName + ''' , SINGLE_BLOB) AS XMLDATA
    ) AS FileImport (XMLDATA)
    ')
    GO
    SELECT * FROM XmlImportTest

    DROP TABLE XmlImportTest	--&lt;== Need to run this to drop it from memory</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Simple_OPENROWSET_BULK</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Simple_OPENROWSET_BULK</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>


--In order to import XML data in SQL Server, you can use the BULK keyword with OPENROWSET

--Let us explore how to import XML data with an example.

--Step 1: Create an independent sample table in the Northwind database or any db of your choice :

USE NORTHWIND
CREATE TABLE CustomerDiscount (ID int NOT NULL, Discount xml)
GO

--Step 2: Now create a XML file and save it on your disk. We will call the file 'sample.xml' and save it in C:\

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Customers&gt;
&lt;Customer ID="1"&gt;
&lt;Discount&gt;20&lt;/Discount&gt;
&lt;/Customer&gt;
&lt;/Customers&gt;

--Step 3: Let us now import the xml data from C:\sample.xml into our newly created table 'CustomerDiscount'

INSERT INTO CustomerDiscount(ID, Discount)
SELECT 1, Disc
FROM
	(
	SELECT * 
	FROM OPENROWSET(BULK 'c:\sample.xml',SINGLE_BLOB) as Disc
	) AS ImportXML (Disc)

--Note: Do not forget to specify the UTF-8 encoding scheme in the XML file. </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_Import</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>Use_XSD_CreateSchema_CreateTypedXML_Create_XML_Index</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_Import</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>Use_XSD_CreateSchema_CreateTypedXML_Create_XML_Index</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>-- from: http://stackoverflow.com/questions/61233/the-best-way-to-shred-xml-data-into-sql-server-database-columns

--Stumbled across this question whilst having a very similar problem, 
--I'd been running a query processing a 7.5MB XML file 
--(~approx 10,000 nodes) for around 3.5~4 hours before finally giving up.

--However, after a little more research 
--I found that having typed the XML using a schema and created an XML Index 
--(I'd bulk inserted into a table) the same query completed in ~ 0.04ms.

--How's that for a performance improvement!

--Code to create a schema:


IF EXISTS ( SELECT * FROM sys.xml_schema_collections where [name] = 'MyXmlSchema')
DROP XML SCHEMA COLLECTION [MyXmlSchema]
GO

DECLARE @MySchema XML
SET @MySchema = 
(
    SELECT * FROM OPENROWSET
    (
        BULK 'C:\Path\To\Schema\MySchema.xsd', SINGLE_CLOB 
    ) AS xmlData
)

CREATE XML SCHEMA COLLECTION [MyXmlSchema] AS @MySchema 
GO

--Code to create the table with a typed XML column:

CREATE TABLE [dbo].[XmlFiles] (
    [Id] [uniqueidentifier] NOT NULL,

    -- Data from CV element 
    [Data] xml(CONTENT dbo.[MyXmlSchema]) NOT NULL,

CONSTRAINT [PK_XmlFiles] PRIMARY KEY NONCLUSTERED 
(
    [Id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]

--Code to create Index

CREATE PRIMARY XML INDEX PXML_Data
ON [dbo].[XmlFiles] (Data)

--There are a few things to bear in mind though. SQL Server's implementation of Schema doesn't support xsd:include.
-- This means that if you have a schema which references other schema, you'll have to copy all of these into a single schema and add that.

--Also I would get an error:

--XQuery [dbo.XmlFiles.Data.value()]: Cannot implicitly atomize or apply 'fn:data()' to complex content elements, found type 'xs:anyType' within inferred type 'element({http://www.mynamespace.fake/schemas}:SequenceNumber,xs:anyType) ?'.

--if I tried to navigate above the node I had selected with the nodes function. E.g.

SELECT
    ,C.value('CVElementId[1]', 'INT') AS [CVElementId]
    ,C.value('../SequenceNumber[1]', 'INT') AS [Level]
FROM 
    [dbo].[XmlFiles]
CROSS APPLY
    [Data].nodes('/CVSet/Level/CVElement') AS T(C)
    
    
--Found that the best way to handle this was to use the OUTER APPLY to in effect perform an "outer join" on the XML. 

SELECT
    ,C.value('CVElementId[1]', 'INT') AS [CVElementId]
    ,B.value('SequenceNumber[1]', 'INT') AS [Level]
FROM 
    [dbo].[XmlFiles]
CROSS APPLY
    [Data].nodes('/CVSet/Level') AS T(B)
OUTER APPLY
    B.nodes ('CVElement') AS S(C)   </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_ReadIn_Untyped_ConvertToTyped</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>XML_Read_Typed</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_ReadIn_Untyped_ConvertToTyped</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>XML_Read_Typed</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>use AssetManagment
    go
    
    
	IF OBJECT_ID('dbo.XmlImportTest') IS NOT NULL
		DROP TABLE dbo.XmlImportTest

    ----Untyped
    --CREATE TABLE XmlImportTest
    --(
    --    xmlFileName VARCHAR(300),
    --    xml_data xml
    --)
    --GO

   -- Typed
    CREATE TABLE XmlImportTest
    (
        xmlFileName VARCHAR(300),
        xml_data xml (MyXmlSchema)
    )
    GO

    DECLARE @xmlFileName VARCHAR(300)
    SELECT  @xmlFileName = 'G:\DATA_No_Backup\From_CCWNC\2013_03_08_AssetManagement\asset_tracking_dump_03-05-13.xml'
    -- dynamic sql is just so we can use @xmlFileName variable in OPENROWSET
    EXEC('
    INSERT INTO XmlImportTest(xmlFileName, xml_data)

    SELECT ''' + @xmlFileName + ''', xmlData 
    FROM
    (
        SELECT  * 
        FROM    OPENROWSET (BULK ''' + @xmlFileName + ''' , SINGLE_BLOB) AS XMLDATA
    ) AS FileImport (XMLDATA)
    ')
    GO
    SELECT top 10 * FROM XmlImportTest
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>XML_ReadIn_Untyped_ConvertToTyped</Category>
        <Language>SQLSERVER2K SQL</Language>
        <Public>false</Public>
        <Name>XML_Read_Untyped</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>XML_ReadIn_Untyped_ConvertToTyped</Category>
          <Language>SQLSERVER2K SQL</Language>
          <Public>false</Public>
          <Name>XML_Read_Untyped</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>use AssetManagment
    go
    
    
	IF OBJECT_ID('dbo.XmlImportTest') IS NOT NULL
		DROP TABLE dbo.XmlImportTest

    ----Untyped
    CREATE TABLE XmlImportTest
    (
        xmlFileName VARCHAR(300),
        xml_data xml
    )
    GO

    --Typed
    --CREATE TABLE XmlImportTest
    --(
    --    xmlFileName VARCHAR(300),
    --    xml_data xml (MyXmlSchema)
    --)
    --GO

    DECLARE @xmlFileName VARCHAR(300)
    SELECT  @xmlFileName = 'G:\DATA_No_Backup\From_CCWNC\2013_03_08_AssetManagement\asset_tracking_dump_03-05-13.xml'
    -- dynamic sql is just so we can use @xmlFileName variable in OPENROWSET
    EXEC('
    INSERT INTO XmlImportTest(xmlFileName, xml_data)

    SELECT ''' + @xmlFileName + ''', xmlData 
    FROM
    (
        SELECT  * 
        FROM    OPENROWSET (BULK ''' + @xmlFileName + ''' , SINGLE_BLOB) AS XMLDATA
    ) AS FileImport (XMLDATA)
    ')
    GO
    SELECT top 10 * FROM XmlImportTest
</Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>