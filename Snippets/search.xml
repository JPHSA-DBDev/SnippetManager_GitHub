<?xml version="1.0" encoding="utf-8"?>
<dictionary>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Filtering</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_DAX_Filtering</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Filtering</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_DAX_Filtering</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>about_DAX_Filtering

Implicit Filter: 	'Filtering applied by the GUI (user or layout) of the report

Explicit Filter:  	'Filtering applied by the the Measures

Explicit filters overide Implicit Filters

CALCULATE: 'to override filters, designed to be fast, can use multiple filter statements: Single column to fixed value

FILTER: 'for advanced filters, designed to be flexible, and when evaluating multiple Columns
		' for comparing to an aggregate function or measure
		' Returns a Table, for example to a function that requires a table input

ALL: 'to undo filters


BASE table
'This is the table you load into the model
Expanded tables
'If you flatten out all the tables in a model that are related with SINGLE, 
'	Many-To-One relationships you end up with the EXPANDED table (like a LEFT JOIN)
'When you apply a “table” filter (on one or more columns) you reference the entire Extended Table.
FILTER = Table of tuples
'Filter Context: set of Filters
'Created by the client tool (e.g. Power BI)
'Can be created programattically (CALCULATE)
Row Context : exists in particular situations, 
'It a Calculated Row it allows you to write a Table[Column] reference and it refers to the current row
'It is not a good idea to aggregate over a calculated column b/c it is faster and more efficient to use a Measure
' M1 = SUMX( theTable, theTable[Field1] * theTable[Field2])
'Automatically created for calculated columns
'Can be introduced with an ITERATOR (SUMX, AVERAGEX, FILTER)
'Provides the current row in which to evaluate column values.
TUPLE = Value for a set of columns (i.e. the combination of field values in a row)

A filter context 
'	is a table, so the values that are ‘selected’ in a slicer, or another visual each set up a table of values that are allowed to be included in the final context of the calculation
'	The table/filter can have one or multiple columns (e.g. Year &amp; Month)
'	Applying a Filter Context to a Calculation is extremely fast
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>about_ITERATOR_and_AGGREGATOR_functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>about_ITERATOR_and_AGGREGATOR_functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://elias-nordlinder.medium.com/dax-series-4-iterators-and-aggregators-dba4314c0292


NOTE:
'the only differences between the Iterators, such as SUMX, and the aggregator, 
' such as SUM, is the table parameter as the first parameter in the iterator (‘Sales’).
'When the Expression only is a column, such as ‘Sales’[Quantity] the two can be used interchangeable

'As long as you want to write an expression that is not a single column, you must use an iterator.
===================================================================================================
'Iteration functions 
--------------------
' take in (at least) two parameters to work, which means that they do not work by only sending in a column. 
' The first parameter 
		'that iterators works on are the table that they need to “scan”.
' The second parameter
	'They need the virtual table that the expression, which is the second parameter, should iterate over.
	'The second parameter is often an expression that the iterator will evaluate for each row in the table.

'	move row-by-row through the table
'	does a calculation, or retrieves some data	
'	Then aggregates it when it is all done

e.g.
	 X = SUMX(
				Sales,
				Sales[Order Quantity]
			  )
'the iterator SUMX require the table, Sales, and the Expression, 
'	which in this case is just the column, to compute the order quantity.



'They work like calculated columns 
'	so Interation functions, which are aggregation functions, are similar to calculated columns

SUMX
COUNTX
AVERAGEX
MINX
MAXX
RANKX

===================================================================================================
'Aggregator Functions
---------------------
'Aggregators are functions that aggregate values of a column in a table and return a single value.
e.g.
	Y = SUM(Sales[Order Quantity])


'They could work while only taking in one parameter, i.e. a column

SUM' Total Quantity = SUM ( ‘Sales’[Quantity] )
MAX' Max Sales = MAX ( ‘Sales’[Quantity] )
MIN' Min Sales = MIN ( ‘Sales’[Quantity] )
AVERAGE' Average Sales = AVERAGE ( ‘Sales’[Quantity] )


=========================================================================MORE details about ITERATORS

'The second parameter can be a single column like " Sales[Order Quantity] ", 
'	but it can also be a specific expression like the example below.
Total Sales = 
SUMX (
    Sales,
    Sales[Order Quantity] * Sales[Unit Price] * (1 - Sales[Discount Applied] )
    )</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>AVERAGEX_moving_average</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>AVERAGEX_moving_average</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>



===========================================================================EXAMPLES==========================

'using MAX, FILTER &amp; ALL to create a 30-day rolling time period (based on latest transaction date)
Moving Average (AVERAGEX) = 
							VAR LastTransactionDate =  MAX('Calendar'[Transaction_Date])				//'Use the latest date available
							VAR AverageDay = 30								//' 30 day average
							VAR PeriodInVisual = 							//'The rolling window
												FILTER(						//' This is the table expression for the FILTER function
												    ALL(
												        'Calendar'[Transaction_Date]
												    ),
												    AND(					//'This is the filter expression for the FILTER function
												        'Calendar'[Transaction_Date] &gt; LastTransactionDate - AverageDay,
												        'Calendar'[Transaction_Date] &lt;= LastTransactionDate
												    )
												)
							VAR OutPut =									//'gets the daily average over the days in 'Calendar' filtered by PeriodInVisual
										CALCULATE(
										    AVERAGEX(						//'would work for SUMX or COUNTX, etc to get the moving SUM or COUNT respectively
												        'Calendar',
												        [Profit]
												    ),
										    PeriodInVisual
							)
RETURN
OutPut</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>AVERAGEX_with_FILTERS</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>AVERAGEX_with_FILTERS</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'Excluding zeros
AVG_AmountFinanced_NEW_2 = AVERAGEX(
            FILTER(
                    P_0052_TASK_17_VIEW_01_vwApplicationsContracts
                    ,P_0052_TASK_17_VIEW_01_vwApplicationsContracts[AmountFinance_Line4_new] &lt;&gt; 0
            )
            ,P_0052_TASK_17_VIEW_01_vwApplicationsContracts[AmountFinance_Line4_new]
    )


'Use the RETURN statement for the logic
Average =
VAR tab =
    SUMMARIZE ( ALL ( 'Table' ), 'Table'[AppID], 'Table'[Value] )
RETURN
    IF (
        SELECTEDVALUE ( 'Table'[Value] ) = 0,
        BLANK (),
        AVERAGEX ( FILTER ( tab, [Value] &gt; 0 ), [Value] )
    )
    
    
    
'Line level

AVERAGEX(
FILTERS(VALUES('TableName'[Value]) &gt;0 || not(isblank('TableName'[Value]))),
'TableName'[Value])

 

'GT Level

divide(
Sumx(
FILTERS(VALUES('TableName'[Value]) &gt;0 || not(isblank('TableName'[Value]))),
'TableName'[Value]) ,calculate(distinctcount('TableName'[APPID]),
FILTERS(VALUES('TableName'[Value]) &gt;0 || not(isblank('TableName'[Value]))),
))    </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions_ITERATORS</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>AVERAGEX</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions_ITERATORS</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>AVERAGEX</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>AVERAGEX
'Calculates the average (arithmetic mean) of a set of expressions evaluated over a table.

'SYNTAX
AVERAGEX(
		&lt;table&gt;
		,&lt;expression&gt;
		)
		
table	
'Name of a physical table, or table expression that specifies the rows over which the aggregation can be performed.
expression	
'An expression with a scalar result, which will be evaluated for each row of the table in the first argument.		

Return value
'A decimal number.

NOTES:

'AVERAGE and AVERAGEX do NOT count days with zero sales when computing an average. To evaluate an 
'	average over a date range that includes dates with no sales, use DIVIDE &amp; COUNTROWS instead

'The AVERAGEX function enables you to evaluate expressions for each row of a table, 
'	and then take the resulting set of values and calculate its arithmetic mean. 
'	Therefore, the function takes a table as its first argument, and an expression as the second argument.

'In all other respects, 
'	AVERAGEX follows the same rules as AVERAGE. 
'	You cannot include non-numeric or null cells. 
'	Both the table and expression arguments are required.

'When there are no rows to aggregate, 
'	the function returns a blank. 
'	When there are rows, but none of them meet the specified criteria, then the function returns 0.


=========================================================================EXAMPLES======================
= AVERAGEX(
			InternetSales
			, InternetSales[Freight]+ InternetSales[TaxAmt]
		  )  
		  
--------------
'REMEMBER: To evaluate an 
'			average over a date range that includes dates with no sales, use DIVIDE &amp; COUNTROWS instead

Average Daily Sales (AVERAGEX) = 
									AVERAGEX(
									    'Calendar',
									    [Customer Sales]
									)		  </Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATE_CALCULATETABLE___Reviser_Functions_FilterContext</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATE_CALCULATETABLE___Reviser_Functions_FilterContext</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'CALCULATE_CALCULATETABLE___Reviser_Functions_FilterContext

https://www.youtube.com/c/CSGProChannel/videos

REVISERs are the only thing in DAX that change the filters
'Filter Revisers create a new Revised Filter Context, AND THEN they run a Sub Expression within it
'The Sub Expression is what runs AFTER the filters have been revised
'Think of the Sub Expression as frozen, once the new filters are ready it is unfrozen and runs

Three Revisers
===============

' A CALCULATE statement is a function that gives you the behaviour of a measure without having to add
'	a measure, i.e. an anonymous Measure.

SYNTAX: CALCULATE(
					&lt;Scaler Expression&gt; 
					[,&lt;Table Value&gt;[,&lt;Table Value&gt;[,]]]]]
				 )

&lt;Table Value&gt; ' is a Table of Values, or virtual/temp table

1] 'ex. of CALCULATE without a &lt;Table Value&gt;:, so the only filter is the Row context which in the simplest example would
'				  be a single column table with one value
'	So the result would be evaluated under each rows 'current row context', 
'		and that is transistioned to the 'Revised Filter Context'
CALCULATE(
			SUMX(
				theTable,
				TheTable[theColumn]
				)
		)
2] 'A measure is a pre-built CALCULATE statement with a predifined Sub Expression, e.g. SUMX is the Sub Expression		
[MEASURE] =
	SUMX(
				theTable,
				TheTable[theColumn]
				)
		)

3] '
CALCULATETABLE(
				VALUES(TheTable[theColumn])
			  )

-----------------------------------------------------------------

'Without Reviser (e.g. without CALCULATE) =&gt; same value on each row for SUMX, i.e. in each row Context

1] 'without Context Transition, i.e. without a Reviser

	AVERAGEX(
			VALUES(TheTable[theColumn]),
			SUMX(
				  TheTable,
				  TheTable[theColumn]
				)
			 )
-------------------------		 
'With Reviser (e.g. with CALCULATE) =&gt;  value on each row is calculated individually for SUMX, i.e. in each row Context

2] 'With context transition, i.e. with a reviser

	AVERAGEX(
			VALUES(TheTable[theColumn]),
			CALCULATE(
						SUMX(
							theTable,
							TheTable[theColumn]
							)
					)				
			 )
-------------------------

3] using a Measure, which is essenntially a named CALCULATE fumction, and is a reviser

	'Define the Measure
	
	[MEASURE] =
		SUMX(
					theTable,
					TheTable[theColumn]
					)
			)

	AVERAGEX(
			VALUES(TheTable[theColumn]),
			[MEASURE]
			 )
			 
=====================================CALCULATE with a FILTER statement 'which is a &lt;Table Value&gt;	consisting of 1 column, and one cell
'NOTE: the Sub Expression is not evaluated until the Filter is evaluated at each Context (e.g. Row)
'		in this example the result for FILTER is the same at each row b/c  "some Category" is hard-coded.
CALCULATE(
			SUMX(											'&lt;=== Argument #1: Expression
				theTable,
				TheTable[theColumn1] * TheTable[theColumn2]
				),
			FILTER(											'&lt;=== Argument #2: Table of valuies
					VALUES(TheTable[aCategoricalColumn] ).
					TheTable[aCategoricalColumn] = "some Category"
				  )
		)
'==&gt; returns a scaler value
			
------------- heristic example: with CALCULATETABLE, not really a usefull business example

CALCULATETABLE(
			FILTER(											'&lt;=== Argument #1: Table Expression
					VALUES(TheTable[aCategoricalColumn] ).
					TheTable[aCategoricalColumn] = "some Category"
				  ),
			FILTER(											'&lt;=== Argument #2: Table of valuies
					VALUES(TheTable[aCategoricalColumn] ).
					TheTable[aCategoricalColumn] = "some Category"
				  )
		)
'==&gt; returns a table w/ one column table: column:"aCategoricalColumn", cell value: "some Category"		</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>CALCULATE_examples</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>CALCULATE_examples</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>
'SYNTAX
CALCULATE ( 
			&lt;Expression&gt; 			'&lt;=== Scaler Value, often this is a previously created MEASURE, or calculation
			[, &lt;Filter&gt; 			'Filters are OPTIONAL, Filters are tables, NOT scaler values
			[, &lt;Filter&gt; 			'	and if they clash with a visual filter, the Calculate Filter wins
			[, … ] 					'	Calculate filters should not clash with one another
			] 
			] 
		  )
------------------------------------------------CALCULATE without the FILTER syntax
1] 'cannot use a MEASURE in the FILTER, (i.e. second argument) in the simple syntax rather, it must be a Column.
' e.g. of something that does not work:
                         =============
 SalesOver 10k = CALCULATE(
 							[No Employees]
 							, [Tot Salaries] &gt; 100						&lt;&lt; ERROR: cannot use MEASURE in the filter Expression
 						  )
 
 ERROR: 'CALCULATE has been used in a TRUE/FALSE expression that is used as a table filter expression  
 BUT, this is OK:                                        

SalesOver 10k = CALCULATE(
							[No Employees]
							, FILTER(									&lt;&lt; OK: b/c use MEASURE in the FILTER statement, as the filter expression
										Emeployee
										, [Tot Salaries] &gt; 100			&lt;&lt; the MEASURE
									)
						 )

' The results of the filter cannot be a table, it must be a scaler: number, text, date


------------------------------------------------FILTER is what is used by DAX engine whenm you write a simple filter
Suppose there are three rows in visual, each 

'This is the way you can write it
Measure1 = 
	CALCULATE ( 
				[Sales Amount], 			'--&lt;== this is a MEASURE
				Product[Color] = "Green" 	'This filter is applied like a FILTER statement that uses ALL()
			   )							'   i.e. it ignores the external filters

'But the DAX engine translates it to this:	{so the one ABOVE,a nd BELOW are identical}		 
Measure1 = 
	CALCULATE ( 
				[Sales Amount], 			'--&lt;== this is a MEASURE
				FILTER(
					ALL(Product[Color] ),			'&lt;= This means: FILTER will ignore the  'outer filters' on the color
					Product[Color] = "Green" 		' without using ALL, This filter would be applied in addition to the external filters
			   )
' IF you write the FILTER statement , and leave out ALL() then it takes into account the external filters			   
Measure1 = 
	CALCULATE ( 
				[Sales Amount], 			'--&lt;== this is a MEASURE
				FILTER(
					(Product[Color] ),			'&lt;= This means: FILTER take into account the  'outer filters' on the color
					Product[Color] = "Green" 		' without using ALL, This filter is applied IN ADDITION to the external filters
			   )			   			 
			   			 
------------------------------------------------ Context Transition Example	

'CALCULATE performs Context Transition
'So the SUMX sums the sales over just the Currently interated year, as the AVERAGEX iterates over the years
MEASURE Sales[Yearly Avg] =
	AVERAGEX (
		VALUES( theDateTable[Calendar Year] ),
			CALCULATE(						'&lt;== This occurs in the row context created as The AVERAGEX iterates over the table: theDateTable
						SUMX( Sales, Sales[Quantity] * Sales[Net Price] )
					  )
			  )
 'and this is equivalent to this
 MEASURE Sales[Yearly Avg] =
	AVERAGEX (
		VALUES( theDateTable[Calendar Year] ),
			[Sales Amount]							'this is true if [Sales Amount] is a Measure that expands to tp tje SUMX clause (above)
			  )
   
------------------------------------------------ example of the 4 evaluation steps
'Calculate evaluation steps

' 1] Evaluation of filter arguments
' 2] Content transition			&lt;==	"ALL" can get rid of context transition
' 3] Evaluation of CALCULATE Modifiers
' 4] Application of filter arguments and KEEPFILTERS

 Sales[Test] =
 	AVERAGEX (
 		VALUES ( theDateTable[Calendar Year] ),			'--&lt;== AverageX is iterating over the VALUES
 		CALCULATE (
 			[Sales Amount],								'--&lt;== [Sales Amount] is the expression to compute for CALCULATE
 			Product[Category] = "Audio"							' one FILTER argument
 		  KEEPFILTERS( Product[Color] IN {"Red", "Blue"}),		' another Filter argument, that modifies the external filters
 		  USERELATIONSHIP(Sales[Delivery Date], theDateTable[Date])	' a global modifer that changes the relatiohship
 		 )

		   
------------------------------------------------		   
		   
https://www.youtube.com/watch?v=Vz-38fJ4asc

'Example:
'1] There are three channels: Affiliate, Organic, Promotional
'2] There is a measure:
	Total Sales = SUM(Sales[Sales])			--&lt;=== MEASURE
	
'This Measure can be used in a table with a row for each channel, but the value will be the same on each row, 
	'as for the 'affiliate' row channel, so it doesn't work well im the table

Affiliate Sales = 
		CALCULATE(
					[Total Sales],
					Sales[Channel] = "Affiliate"
				  )

'But if you want the Total on each row, in order to get percent of each Total for each channel, then 
'	calculating the Total does make sense:
Total Sales = 
		CALCULATE(
					[Total Sales],
					ALL(Sales[Channel])
				  )
				  
'To get the percent of total sales using a measure:

Prcnt Total Sales =
	DIVIDE(
		[Total Sales],							--&lt;=== MEASURE					
		CALCULATE(
					[Total Sales],				--&lt;=== MEASURE
					ALL(Sales[Channel])
				  )					
				  
'To get the Sales, Same Time Last Year, create a new Measure
SalesLastYear = 
		CALCULATE(
					[Total Sales],
					SAMEPERIODLASTYEAR('Calendar'[Date])
				 )
				 
'To get the Sales Growth Percentage over last year:
SalesGrowthOverLastYear = 
	    [Total Sales] /
		CALCULATE(
					[Total Sales],
					SAMEPERIODLASTYEAR('Calendar'[Date])
				 )
				 
'But when the denominator or numerator are missing you will get ugly results.
'So to fix that:

SalesGrowthOverLastYear = 
	VAR LastYearSales = 
						CALCULATE(
									[Total Sales],
									SAMEPERIODLASTYEAR('Calendar'[Date])
								 )				 
	RETURN
		IF(
			[Total Sales] &lt;&gt; BLANK() &amp;&amp;
			LastYearSales &lt;&gt; BLANK(),
			[Total Sales]/LastYearSales
	)
=================================================================================================
'Example: 4 tables:
' Country ==&gt; City ==&gt; Sales &lt;== Product	
--------------------------------------------------------------------------ALL				  
				  

'Measure that shows the pcnt a given product is of all the products				  
Pcnt of all products = DIVIDE(
								 
								    //' the numerator: number of sales for the current filter context
								    COUNT(Sales[SalesId]),
								    //' the denominator: number of sales for the current filter
								    //' context, but for ALL products
								    CALCULATE(
								        COUNT(Sales[SalesId]),
								        ALL('Product'[ProductName])
								    )
								)				  
				  
'Measure that shows the number of sales as a percentage of the total for all cities and for all products				  
Pcnt of all products and cities = DIVIDE( 
											    //' divide the number of sales ...
											    COUNT(Sales[SalesId]),
											    //' ... by the number of sales for all products and
											    //' cities
											    CALCULATE(
											        COUNT(Sales[SalesId]),
											        ALL('Product'[ProductName]),
											        ALL(City[CityName])
											    )
											)				  
--------------------------------------------------------------------------ALLEXCEPT
'a measure which would show each product/city’s contribution to the grand total for each country:
Pcnt relaxing everything but country = DIVIDE(
											    //' divide the number of sales ...
											    COUNT(Sales[SalesId]),
											    //' ... by the number of sales, keeping only the 
											    //' country constraint
											    CALCULATE(
											        COUNT(Sales[SalesId]),
											        ALLEXCEPT(
											            Sales,
											            Country[CountryName]
											        )
											    )
											)											
------------------------------------------------------------------MODIFIERS
'REMOVEFILTERS from a table, note it would be equivalent to an ALL()
CALCULATE(
			[Customer Sales],
			REMOVEFILTERS( ‘Store Lookup')
		)
'REMOVEFILTERS from a column											
CALCULATE(
			[Customer Sales],
			REMOVEFILTERS(‘Store Lookup’[store_id])
		 )										
----------------------------
'KEEPFILTERS: So when the external context is Store ID = 5, then this will show results, otherwise blank														
measureX = 
			CALCULATE(
			    [Profit],
			    KEEPFILTERS(
						        'Store Lookup'[store_id] = 5
						    )	
						    
'vs. this one: this will show "Store ID = 5" results for every row, and situation

measureX = 
			CALCULATE(
				    [Profit],
				    'Store Lookup'[store_id] = 5
					 )
----------------------------

																	
																	
																	
																	
																	</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Statistical_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Statistical_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>https://docs.microsoft.com/en-us/dax/statistical-functions-dax

' Filters do not propogate in a Row Context, i.e. in Calculated Columns
----------------------------------------------------------------------------------
'SO if you created two columns in a Visual (e.g. Table) and one was based on a Calculated Column using data from a Related table, 
'	and the other was based on a Measure using data from a Related table, then the Calculated-based Rank would remain unchanged as you
'	apply filters to the related Table, but the Measure-based Rank would change as you applied filters to the related Table.

'e.g. for a Calculated Column
Ranking =        RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))

'e.g. for a MEASURE Column
RankingMeasure = RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))		
---------------------------------------------------------------------------------

ADDCOLUMNS
APPROXIMATEDISTINCTCOUNT
AVERAGE
AVERAGEA

AVERAGEX
 		'e.g.
 		AverageGrossSales = AVERAGEX(SalesOrderDetail, SalesOrderDetail[OrderQty] * SalesOrderDetail[UnitPrice] * (1 - SalesOrderDetail[UnitPriceDiscount]))
 		
BETA.DIST
BETA.INV
CHISQ.INV
CHISQ.INV.RT
CONFIDENCE.NORM
CONFIDENCE.T

COUNT():
	'The COUNT function counts the number of cells in a column that contains 
	'values of the whole number or integer or string datatype excluding the 
	'blank cell. It even counts the cell with repeated values.
	' only count non-empty cells  and are not sensitive to repetitive values 
	'in cells.
	Apps = COUNT(FactApplication[Client_App_ID])
	
	'EXAMPLE: show 0 if there are none, 1 if there are some
	' add a zero to convert the blanks to zero, then use "&gt;" to create boolean, then INT to convert back to 0/1
	INT((COUNT(FactApplication[Client_App_ID]) + 0) &gt; 0)

COUNTA():
	'COUNTA function can also count the boolean values (True or False) 
	'whereas count function returns an error .
	' only count non-empty cells  and are not sensitive to repetitive values 
	'in cells.

	Measure  = CALCULATE(
							COUNTA(	Table[Column1] )
							,ALLEXCEPT(
										Table
										,Table[Column1]
									   )
					     )

COUNTX():
	'Syntax: COUNTX(&lt;table&gt;,&lt;expression&gt;)
	'COUNTX function counts the number of rows which are non-empty when 
	'evaluating an expression over a table.
	'This function cannot be used for boolean values.

COUNTAX():
	'Syntax: COUNTAX(&lt;table&gt;,&lt;expression&gt;)
	'similar to COUNTX function with the only difference being that COUNTAX function can operate on boolean values.	

COUNTBLANKS():
	'Syntax: COUNTBLANK(&lt;column&gt;)
	' calculate the number of blanks present in a column.
	 NumbOfRowNumbersWithBlanks = COUNTBLANK('tableName'[columnName])
	
COUNTROWS():
	'Syntax : COUNTROWS(&lt;table&gt;)
	'NOTE: can use FILTERs in place of &lt;table&gt;
	'counts the number of rows in the specified table, or in a table defined by an expression .


CROSSJOIN
	'e.g. Cross Join 3 tables
	RowHeader_Territory_Segment = CROSSJOIN(RowHeaders,Segments,Territories)
DATATABLE function
DISTINCTCOUNT():
	'Syntax: DISTINCTCOUNT(&lt;column&gt;)
	' returns the number of unique values present in a column.
	'It counts NULL as a unique value

DISTINCTCOUNTNOBLANK
	' returns the number of unique values present in a column.
	'It DOES NOT counts NULL as a unique value
	
	CALCULATE( 
				DISTINCTCOUNT(DimDealer[DealerCode]),
				FILTER(DimDealer,DimDealer[DealerActive] = True())
			  )
	
	
EXPON.DIST
GENERATE
GENERATEALL
GEOMEAN
GEOMEANX
MAX
	'This takes the Max from a column, but does not let you filter by some category
MAXA
MAXX
	'This takes the Max from an expression, where the expression is what let's us 'filter' 
	'	down to just some rows
	
	Last Purchase Date for each Customer = 
	    //'return the MAX value from the set of returned rows
	    MAXX(
	            RELATEDTABLE(Internet Sales),     //'Work on the related set of rows from the table, related by the relationship (i.e. the customer)
	            Internet Sales[Order Date]       // 'for each row returned, return this field
	        )	
MEDIAN
	'Returns the median of numbers in a column
	'To return the median of an expresssion evaluated for each row in a table, use MEDIANX function.
	'Syntax
	MEDIAN(&lt;column&gt;)
	'Return value
		A decimal number
		
	'NOTES
		'Only the numbers in the column are counted. Blanks, logical values, and text are ignored.
		'MEDIAN( Table[Column] ) is equivalent to MEDIANX( Table, Table[Column] ).
MEDIANX
	'Returns the median number of an expression evaluated for each row in a table
	'To return the median of numbers in a column, use MEDIAN function.
	
	'Syntax
	MEDIANX(&lt;table&gt;, &lt;expression&gt;) 
	
	table	'The table containing the rows for which the expression will be evaluated.
	expression	'The expression to be evaluated for each row of the table.
	
	'NOTES
		'Only the numbers in the column are counted.
		'Logical values and text are ignored.
		' MEDIANX does not ignore blanks; however, MEDIAN does ignore blanks  &lt;====== IMPORTANT DIFFERENCE
		
	'EX
	= MEDIANX( FILTER(Customers, RELATED( Geography[Country]="USA" ) ), Customers[Age] )  
	
MIN
MINA
MINX
NORM.DIST
NORM.INV
NORM.S.DIST
NORM.S.INV (DAX)
PERCENTILE.EXC   (EXCLUSIVE)
	'Returns the k-th percentile of values in a range, where k is in the range 0..1, EXCLUSIVE.
	'To return the percentile number of an expression evaluated for each row in a table, use PERCENTILEX.EXC function.
	
	'SYNTAX
		PERCENTILE.EXC(&lt;column&gt;, &lt;k&gt;) 
		
		column	'A column containing the values that define relative standing.
		k	'The percentile value in the range 0..1, exclusive.	
PERCENTILE.INC  (INCLUSIVE)
	' Returns the k-th percentile of values in a range, where k is in the range 0..1, INCLUSIVE.
	' To return the percentile number of an expression evaluated for each row in a table, use PERCENTILEX.INC.

	'SYNTAX
		PERCENTILE.INC(&lt;column&gt;, &lt;k&gt;)   
		
		column	'A column containing the values that define relative standing.
		k	'The percentile value in the range 0..1, inclusive.	
PERCENTILEX.EXC   (EXCLUSIVE)
	'Returns the percentile number of an expression evaluated for each row in a table.
	'To return the percentile of numbers in a column, use PERCENTILE.EXC function.
	
	PERCENTILEX.EXC(&lt;table&gt;, &lt;expression&gt;, k)  
	
	table'	The table containing the rows for which the expression will be evaluated.
	expression	'The expression to be evaluated for each row of the table.
	k	'The desired percentile value in the range 0 to 1 EXCLUSIVE.

PERCENTILEX.INC  (INCLUSIVE)
	'Returns the percentile number of an expression evaluated for each row in a table.
	'To return the percentile of numbers in a column, use PERCENTILE.INC.
	
	PERCENTILEX.INC(&lt;table&gt;, &lt;expression&gt;;, k)  

	table	'The table containing the rows for which the expression will be evaluated.
	expression	'The expression to be evaluated for each row of the table.
	k	'The desired percentile value in the range 0 to 1 INCLUSIVE.

POISSON.DIST
RANK.EQ
RANKX
	RANKX(&lt;table&gt;, &lt;expression&gt;[, &lt;value&gt;[, &lt;order&gt;[, &lt;ties&gt;]]])  
	'e.g. create a MEASURE: for each product (in TABLE_1: Products), go through each row in another table (TABLE_2: SalesOrderDetail)
	
	Ranking = RANKX(
					ALL(Products), 
					SUMX(
							RELATEDTABLE(SalesOrderDetail), 
							SalesOrderDetail[GrossSales])
						)
					)
	'NOTE: if you used  SUMX(SalesOrderDetail, SalesOrderDetail[GrossSales]) 
	'	then it would sum up all the rows, rather than just the related rows
	'NOTE: if we did not use ALL (for [Products] table) then it would only rank for the filtered rows of [Products], and not give us an overall Rank


ROW
SAMPLE
SELECTCOLUMNS
SIN
SINH
SQRTPI
STDEV.P
STDEV.S
STDEVX.P
STDEVX.S
SUMMARIZE
	'SYNTAX
	SUMMARIZE (&lt;table&gt;, &lt;groupBy_columnName&gt;[, &lt;groupBy_columnName&gt;]…[, &lt;name&gt;, &lt;expression&gt;]…)
	'Returns a summary table for the requested totals over a set of groups.
	&lt;expression&gt;	'Any DAX expression that returns a single scalar value, where the expression is to be evaluated multiple times (for each row/context).
T.DIST
T.DIST.2T
T.DIST.RT
T.INV
T.INV.2t
TAN
TANH
TOPN
VAR.P
VAR.S
VARX.P
VARX.S
XIRR
XNPV
</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Functions</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Table_Functions</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Functions</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Table_Functions</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>'Table_Functions

'One key limitation of a table function is that its output can’t be used in a visual in your report. 
'	If you think about it, 
'	each cell on a pivot table can only fit one number, not an entire table of numbers.

 'returns a table of data
------------------------------------------------ 
 'In DAX, a table function is used in a few ways:

'1]	As input to another DAX function where the function argument requires a table. 
'		For example, the FILTER function iterates over a table of data 
'		and tests each value for a condition 
'		(actually any X function like SUMX or AVERAGEX is an iterator and would require a table as the first argument.)
'2] As a calculated table definition in Power BI Desktop
'3] As a query written against your data model using DAX Studio or SQL Server Management Studio.
------------------------------------------------

'Tables can become scalars: 
'	A neat feature of DAX is that any table function that resolves to a single row and column (i.e., one value) is automatically converted to a scalar value if possible. 
'	That means that you can use a table function as an input to another function, 
'	but do so cautiously to avoid the dreaded “Table of Multiple Values…” error.

----------------------------------------------------------------------------------
'SO if you created two columns in a Visual (e.g. Table) and one was based on a Calculated Column using data from a Related table, 
'	and the other was based on a Measure using data from a Related table, then the Calculated-based Rank would remain unchanged as you
'	apply filters to the related Table, but the Measure-based Rank would change as you applied filters to the related Table.

'e.g. for a Calculated Column
Ranking =        RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))

'e.g. for a MEASURE Column
RankingMeasure = RANKX(ALL(Products), SUMX(RELATEDTABLE(SalesOrderDetail), SalesOrderDetail[GrossSales]))		
---------------------------------------------------------------------------------



FILTER
	Returns a TABLE
	'get just the rows from DateTable that match criteria 
	FilterExampleTable = FILTER(DateTable, (DateTable[IsPreviousWeek]= 1) )
	
VALUES	
	VALUESexampleTable = VALUES(RowHeaders[RowHeader])
	
	'VALUES Returns a single column table of unique values when a column name is given. If a table
	'	name is supplied, VALUES returns the entire table (including duplicates) plus a blank row
	
ALL

	'Using a table argument, ALL returns all the rows of the table including any duplicated rows.
	'Using a single column argument, ALL returns all the unique values of the column.
	'Using two or more columns arguments, ALL returns all the unique combinations of values in multiple columns.
	'In every case, ALL includes in the result the additional blank row generated for invalid relationships.

	ALLexampleTable = ALL(RowHeaders)				'&lt;== Returns all rows, of all columns
	ALLexampleTable = ALL(RowHeaders[RowHeader])	'&lt;== returns unique rows, of one column
		
DISTINCT
	'returns a single column table of unique Values when a column name is given.
	'	if a table is supplied, DISTINCT returns all unique combinations</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_HowTo</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>Slicer_Parameter_for_time_Period_of_MovingAverage</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_HowTo</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>Slicer_Parameter_for_time_Period_of_MovingAverage</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>

A] This does not use a WHAT-IF parameter from wizard, rather it is a manual version
B] This works for a MEASURE, i.e. the parameter is used/read by the MEASURE
	BUT it does NOT work for a calculated table, b/c a calculated table is created before the slicer is used.

1]' A calculated table with the values to use for the parameter.
'Generates a series (rows of 1 column) from 7 to 63 in increments of 7.
'NOTE the name of the generated field is "Value"

	Average Days = GENERATESERIES(7,63,7)

2]' A Measure to get/read the "Average Days" value from the row context, that is equivalent to the value in the table in step 1, i.e. it will pick up the row context as the 
'	'selected value' and echo it back, if it can't find it, in the table, then the default/alternate will be 30

	Average Days Value = 											//'&lt;====== HERE is the PARAMTER/MEASURE
						SELECTEDVALUE(
						    'Average Days'[Average Days],
						    30
						)
3]' A measure that will consume this parameter (e.g. a Moving average, where the length of time for the moving average is the Parameter)

3a]' Just for reference, but NOT needed in general; The MEASURE used in the 3b, as the MEASURE whose moving average we want
	
	Profit =  [Customer Sales] - [Cost]
3b]' The Measure that actually consumes the Parameter

	Moving Average Profit (AVERAGEX) = 
							VAR LastTransactionDate = MAX('Calendar'[Transaction_Date])
							VAR AverageDay = [Average Days Value]						//'&lt;====== HERE is the PARAMTER/MEASURE being consumed
							VAR PeriodInVisual = 
							FILTER(
							    ALL(
							        'Calendar'[Transaction_Date]
							    ),
							    AND(
							        'Calendar'[Transaction_Date] &gt; LastTransactionDate - AverageDay,
							        'Calendar'[Transaction_Date] &lt;= LastTransactionDate
							    )
							)
							VAR OutPut =
							CALCULATE(
							    AVERAGEX(
							        'Calendar',
							        [PROFIT]
							    ),
							    PeriodInVisual
							)
	RETURN
	OutPut
	
4]' Then use the MEASURE from 3b in a Visual. Until you add a slicer to control the Parameter it will use the default value (e.g. 30)

5]' Add a slicer that gets its values from the column of the calculated table in #1 (above)
'	Try it as a list to pick from, but don't allow multiple values to be selected from the list</Code>
      </SnippetValue>
    </value>
  </item>
  <item>
    <key>
      <SnippetKey xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Category>DAX_Relationhships</Category>
        <Language>VB</Language>
        <Public>false</Public>
        <Name>RELATEDTABLE</Name>
        <Group>My Snippets</Group>
      </SnippetKey>
    </key>
    <value>
      <SnippetValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <Key>
          <Category>DAX_Relationhships</Category>
          <Language>VB</Language>
          <Public>false</Public>
          <Name>RELATEDTABLE</Name>
          <Group>My Snippets</Group>
        </Key>
        <Keywords />
        <Imports />
        <Code>RELATEDTABLE
'Evaluates a table expression in a context modified by the given filters.
'The RELATEDTABLE function will travel through the existing relationship between tables, 
'	and will populate a list of rows (sub-table) from the give table

'RELATEDTABLE is a shortcut for CALCULATETABLE (with no logical expression) and performs a
'	context transition from row context to filter context, in order to return only the rows
' which satisfy the filter condition

'SYNTAX
RELATEDTABLE(&lt;tableName&gt;)

tableName	
'The name of an existing table using standard DAX syntax. It cannot be an expression.
'Must reference a table on the "many" side of a many-to-one relationship

NOTE
=====
'The RELATEDTETABLE function changes the context in which the data is filtered, 
'	and evaluates the expression in the new context that you specify.
'RELATEDTETABLE is commonly used with aggregators like COUNTROWS, SUMX, AVERAGEX, etc

'This function is a shortcut for CALCULATETABLE function with no logical expression.


This is not backed by testing: Row context propogation: Iterators vs (Revisers &amp; FILTER)
========================
'Iterator functions (SUMX, RANKX, etc.) use row context to evaluate row level calculations so they don't 
'	need to use RELATED or RELATEDTABLE functions
'CALCULATE and FILTER creates/modifies Filter Context) and therefore the Row context doesn't 
'	automatically propagate through table relationships so they need to use RELATED or RELATEDTABLE functions


EXAMPLES
=================

SUMX( 
		RELATEDTABLE('InternetSales_USD')  
    	 , [SalesAmount_USD]
    ) 

'Calculated Column (aggregation)
' the related table is tied to this calculated column's table by the Product ID, so I think it is creating a virtual table of rows with the same Product IT
'	to be used as the &lt;table&gt; by SUMX, and then the column 'Food Inventory'[quantity_start_of_day] in the Virtual Table is summed up.
Number of Food Items Made = 
							SUMX(
							    RELATEDTABLE(								//'&lt;== This is doing the context transition for the SUMX on each row
										        'Food Inventory'
										    ),
									   'Food Inventory'[quantity_start_of_day]
									)        </Code>
      </SnippetValue>
    </value>
  </item>
</dictionary>